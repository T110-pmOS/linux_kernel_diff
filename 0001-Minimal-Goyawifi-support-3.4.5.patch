From 33e6300848f30218ea79706de3047152540bf403 Mon Sep 17 00:00:00 2001
From: cheadrian <che.adrian@yahoo.com>
Date: Sun, 29 May 2022 18:05:41 -0400
Subject: [PATCH] Minimal Goyawifi support 3.4.5

---
 Makefile                                      |   54 +-
 arch/arm/Kconfig                              |  129 +-
 arch/arm/Makefile                             |    2 +
 arch/arm/boot/compressed/head.S               |   12 +-
 arch/arm/common/Kconfig                       |   50 +
 arch/arm/common/Makefile                      |    2 +
 arch/arm/common/gic.c                         |    9 +
 .../configs/goyawifi_pmos_minimal_defconfig   | 1702 ++++
 arch/arm/include/asm/assembler.h              |   16 +
 arch/arm/include/asm/barrier.h                |    4 +
 arch/arm/include/asm/cache.h                  |    4 +
 arch/arm/include/asm/cacheflush.h             |   20 +-
 arch/arm/include/asm/delay.h                  |    4 +
 arch/arm/include/asm/device.h                 |    4 +
 arch/arm/include/asm/dma-contiguous.h         |   15 +
 arch/arm/include/asm/fpstate.h                |    3 +
 arch/arm/include/asm/glue-cache.h             |    1 +
 arch/arm/include/asm/hardirq.h                |    2 +-
 arch/arm/include/asm/hardware/cache-l2x0.h    |    6 +
 arch/arm/include/asm/irq.h                    |    3 +
 arch/arm/include/asm/mach/map.h               |    1 +
 arch/arm/include/asm/memory.h                 |    7 +
 arch/arm/include/asm/mmu.h                    |    7 -
 arch/arm/include/asm/mmu_context.h            |  104 +-
 arch/arm/include/asm/mutex.h                  |  119 +-
 arch/arm/include/asm/rodata.h                 |   32 +
 arch/arm/include/asm/sched_clock.h            |    2 +
 arch/arm/include/asm/smp.h                    |    2 +
 arch/arm/include/asm/thread_info.h            |    8 +-
 arch/arm/include/asm/uaccess.h                |   40 +-
 arch/arm/kernel/Makefile                      |    7 +-
 arch/arm/kernel/head.S                        |    4 +-
 arch/arm/kernel/machine_kexec.c               |    5 +
 arch/arm/kernel/process.c                     |  141 +-
 arch/arm/kernel/ptrace.c                      |   12 +-
 arch/arm/kernel/sched_clock.c                 |   24 +
 arch/arm/kernel/setup.c                       |    9 +-
 arch/arm/kernel/signal.c                      |   10 +-
 arch/arm/kernel/smp.c                         |   88 +-
 arch/arm/kernel/smp_scu.c                     |    2 +-
 arch/arm/kernel/suspend.c                     |   19 +-
 arch/arm/kernel/sys_arm.c                     |  138 +
 arch/arm/kernel/traps.c                       |   30 +-
 arch/arm/lib/Makefile                         |    6 +-
 arch/arm/lib/getuser.S                        |   23 +-
 arch/arm/lib/putuser.S                        |    6 +
 arch/arm/mach-mmp/Kconfig                     |  521 +-
 arch/arm/mach-mmp/Makefile                    |  144 +-
 arch/arm/mach-mmp/Makefile.boot               |   13 +-
 arch/arm/mach-mmp/acpuclock-pxa988.c          | 3630 ++++++++
 arch/arm/mach-mmp/board-goya-battery.c        |  871 ++
 arch/arm/mach-mmp/board-goya-input.c          |  293 +
 arch/arm/mach-mmp/board-goya.c                | 4880 ++++++++++
 arch/arm/mach-mmp/board-goya.h                |   37 +
 arch/arm/mach-mmp/boost.c                     |  200 +
 arch/arm/mach-mmp/clock-pxa988.c              | 4955 ++++++++++
 arch/arm/mach-mmp/common.c                    |   26 +
 arch/arm/mach-mmp/common.h                    |   23 +
 arch/arm/mach-mmp/coresight-v7.c              |  417 +
 arch/arm/mach-mmp/cpuidle-pxa988.c            |  229 +
 arch/arm/mach-mmp/devices.c                   |  635 ++
 arch/arm/mach-mmp/dvfs-pxa988.c               | 2039 ++++
 arch/arm/mach-mmp/gpio-edge.c                 |  216 +
 arch/arm/mach-mmp/gpu_mem.c                   |  209 +
 arch/arm/mach-mmp/helpfunc_v7.S               |  115 +
 .../mach/Quicklogic_Vxbridge_interface.h      |  255 +
 arch/arm/mach-mmp/include/mach/addr-map.h     |   75 +
 arch/arm/mach-mmp/include/mach/camera.h       |  118 +
 arch/arm/mach-mmp/include/mach/clock-pxa988.h |  219 +
 arch/arm/mach-mmp/include/mach/cputype.h      |  178 +
 arch/arm/mach-mmp/include/mach/delay.h        |   41 +
 arch/arm/mach-mmp/include/mach/devices.h      |   47 +
 arch/arm/mach-mmp/include/mach/dvfs.h         |   19 +
 arch/arm/mach-mmp/include/mach/features.h     |  157 +
 arch/arm/mach-mmp/include/mach/gpio-edge.h    |   42 +
 arch/arm/mach-mmp/include/mach/gpio.h         |    7 +
 arch/arm/mach-mmp/include/mach/gpu_mem.h      |   19 +
 arch/arm/mach-mmp/include/mach/io.h           |   21 +
 arch/arm/mach-mmp/include/mach/irqs.h         |  640 +-
 arch/arm/mach-mmp/include/mach/isl29043.h     |   19 +
 arch/arm/mach-mmp/include/mach/isp_dev.h      |   94 +
 arch/arm/mach-mmp/include/mach/memory.h       |   29 +
 arch/arm/mach-mmp/include/mach/mfp-mmp2.h     |   22 +
 .../mach-mmp/include/mach/mfp-pxa986-goya.h   |  228 +
 arch/arm/mach-mmp/include/mach/mfp.h          |    8 +-
 arch/arm/mach-mmp/include/mach/mmp3.h         |  307 +
 arch/arm/mach-mmp/include/mach/mmp_device.h   |   69 +
 arch/arm/mach-mmp/include/mach/pxa168fb.h     |  678 ++
 arch/arm/mach-mmp/include/mach/pxa988.h       |  277 +
 arch/arm/mach-mmp/include/mach/pxa988_ddr.h   |   51 +
 .../mach-mmp/include/mach/pxa988_lowpower.h   |  158 +
 arch/arm/mach-mmp/include/mach/regs-apbc.h    |   61 +-
 arch/arm/mach-mmp/include/mach/regs-apmu.h    |  217 +-
 arch/arm/mach-mmp/include/mach/regs-ciu.h     |   95 +
 .../mach-mmp/include/mach/regs-coresight.h    |  100 +
 arch/arm/mach-mmp/include/mach/regs-icu.h     |  270 +
 arch/arm/mach-mmp/include/mach/regs-map.h     |  249 +
 arch/arm/mach-mmp/include/mach/regs-mcu.h     |  159 +
 arch/arm/mach-mmp/include/mach/regs-mpmu.h    |  139 +
 arch/arm/mach-mmp/include/mach/regs-timers.h  |   10 +-
 arch/arm/mach-mmp/include/mach/regs-usb.h     |  416 +
 arch/arm/mach-mmp/include/mach/reset-pxa988.h |   49 +
 .../mach-mmp/include/mach/samsung_camera.h    |   48 +
 .../include/mach/samsung_camera_goya.h        |   44 +
 arch/arm/mach-mmp/include/mach/scu.h          |   18 +
 arch/arm/mach-mmp/include/mach/sec_debug.h    |   83 +
 arch/arm/mach-mmp/include/mach/soc_coda7542.h |    8 +
 arch/arm/mach-mmp/include/mach/timex.h        |    2 +-
 arch/arm/mach-mmp/include/mach/uio_hdmi.h     |   39 +
 arch/arm/mach-mmp/include/mach/uio_isp.h      |    8 +
 arch/arm/mach-mmp/include/mach/uncompress.h   |    2 +-
 arch/arm/mach-mmp/mmp_device.c                |  323 +
 arch/arm/mach-mmp/onboard.h                   |   23 +
 .../mach-mmp/onboard/Lcd_mipi2lvds_vx5b3d.c   |  777 ++
 arch/arm/mach-mmp/onboard/Makefile            |   22 +
 .../arm/mach-mmp/onboard/board-goya-display.c |  635 ++
 arch/arm/mach-mmp/platsmp.c                   |  262 +
 arch/arm/mach-mmp/platsmp.h                   |   20 +
 arch/arm/mach-mmp/pm-pxa988.c                 |  467 +
 arch/arm/mach-mmp/pmu.c                       |  143 +
 arch/arm/mach-mmp/pxa988.c                    | 1572 ++++
 arch/arm/mach-mmp/pxa988_headsmp.S            |  278 +
 arch/arm/mach-mmp/pxa988_hotplug.c            |   74 +
 arch/arm/mach-mmp/pxa988_lowpower.c           | 1182 +++
 arch/arm/mach-mmp/reset-pxa988.c              |  147 +
 arch/arm/mach-mmp/reset.c                     |  176 +
 arch/arm/mach-mmp/sec-common.c                |   38 +
 arch/arm/mach-mmp/sleep-pxa988.S              |  278 +
 arch/arm/mach-mmp/sram.c                      |    2 +-
 arch/arm/mach-mmp/stand-hotplug.c             |  747 ++
 arch/arm/mach-mmp/time.c                      |  198 +-
 arch/arm/mach-mmp/wakeupgen.c                 |  184 +
 arch/arm/mm/Makefile                          |    2 +
 arch/arm/mm/alignment.c                       |   11 +-
 arch/arm/mm/cache-l2x0.c                      |  273 +-
 arch/arm/mm/cache-v7.S                        |   74 +-
 arch/arm/mm/context.c                         |   57 +-
 arch/arm/mm/dma-mapping.c                     |  376 +-
 arch/arm/mm/init.c                            |   59 +-
 arch/arm/mm/mm.h                              |    3 +
 arch/arm/mm/mmu.c                             |  103 +-
 arch/arm/mm/proc-macros.S                     |    1 +
 arch/arm/mm/proc-v7-2level.S                  |    9 +-
 arch/arm/mm/proc-v7.S                         |   65 +
 arch/arm/mm/vmregion.c                        |    2 +
 arch/arm/mm/vmregion.h                        |    1 +
 arch/arm/plat-pxa/Makefile                    |    9 +-
 arch/arm/plat-pxa/clock.c                     |  631 ++
 arch/arm/plat-pxa/debugfs.c                   |  732 ++
 arch/arm/plat-pxa/dma.c                       |   17 +-
 arch/arm/plat-pxa/dump_regs.c                 |  158 +
 arch/arm/plat-pxa/dvfs.c                      |  364 +
 arch/arm/plat-pxa/include/plat/clock.h        |  112 +
 arch/arm/plat-pxa/include/plat/debugfs.h      |   22 +
 arch/arm/plat-pxa/include/plat/devfreq.h      |   56 +
 arch/arm/plat-pxa/include/plat/dump_regs.h    |   28 +
 arch/arm/plat-pxa/include/plat/dvfs.h         |   89 +
 arch/arm/plat-pxa/include/plat/fb_ioctl.h     |  279 +
 arch/arm/plat-pxa/include/plat/mfp.h          |   94 +
 arch/arm/plat-pxa/include/plat/pm.h           |   35 +
 .../arm/plat-pxa/include/plat/pxa27x_keypad.h |    5 +
 arch/arm/plat-pxa/include/plat/pxa3xx_nand.h  |   21 +-
 arch/arm/plat-pxa/include/plat/pxa9xx_acipc.h |  191 +
 arch/arm/plat-pxa/include/plat/pxa_trace.h    |  424 +
 arch/arm/plat-pxa/mfp.c                       |  365 +-
 arch/arm/plat-pxa/panic.c                     |  169 +
 arch/arm/plat-pxa/ssp.c                       |    3 +
 arch/arm/plat-pxa/usb.c                       |   83 +
 arch/arm/tools/mach-types                     |   19 +
 arch/arm/vfp/entry.S                          |    3 +-
 arch/arm/vfp/vfpmodule.c                      |    8 +-
 drivers/Kconfig                               |    8 +
 drivers/Makefile                              |    9 +
 drivers/base/Kconfig                          |  116 +
 drivers/base/Makefile                         |    5 +
 drivers/base/cpu.c                            |    5 +
 drivers/base/dma-buf.c                        |   64 +-
 drivers/base/dma-contiguous.c                 |  536 ++
 drivers/base/power/main.c                     |   87 +-
 drivers/base/power/qos.c                      |   19 +-
 drivers/base/power/runtime.c                  |  103 +-
 drivers/base/power/sysfs.c                    |   54 +-
 drivers/base/power/wakeup.c                   |  211 +-
 drivers/base/regdump.c                        |  544 ++
 drivers/base/regmap/regmap-irq.c              |   30 +-
 drivers/base/regmap/regmap.c                  |    8 +-
 drivers/battery/88pm80x_fuelgauge.c           | 1860 ++++
 drivers/battery/Kconfig                       |  315 +
 drivers/battery/Makefile                      |   35 +
 drivers/battery/sec_battery.c                 | 3358 +++++++
 drivers/battery/sec_fuelgauge.c               |  743 ++
 drivers/char/88pm822_usb.c                    |  372 +
 drivers/char/Kconfig                          |   73 +
 drivers/char/Makefile                         |    9 +-
 drivers/char/maxscend/Kconfig                 |   16 +
 drivers/char/maxscend/Makefile                |    3 +
 drivers/char/maxscend/mxdchar.h               |   34 +
 drivers/char/maxscend/mxdspi_pxa.c            |  879 ++
 drivers/char/mem.c                            |   17 +
 drivers/char/pxa9xx_acipc.c                   | 1099 +++
 drivers/clk/clkdev.c                          |   45 +
 drivers/cpufreq/Kconfig                       |   27 +
 drivers/cpufreq/Kconfig.arm                   |    8 +
 drivers/cpufreq/Makefile                      |    2 +
 drivers/cpufreq/cpufreq.c                     |  405 +-
 drivers/cpufreq/cpufreq_conservative.c        |   13 +-
 drivers/cpufreq/cpufreq_interactive.c         | 1066 +++
 drivers/cpufreq/cpufreq_stats.c               |   52 +-
 drivers/cpufreq/freq_table.c                  |    9 +
 drivers/cpufreq/pxa988-cpufreq.c              |  360 +
 drivers/cpuidle/Kconfig                       |    3 +
 drivers/cpuidle/Makefile                      |    1 +
 drivers/cpuidle/coupled.c                     |  727 ++
 drivers/cpuidle/cpuidle.c                     |   68 +-
 drivers/cpuidle/cpuidle.h                     |   32 +
 drivers/cpuidle/governors/menu.c              |    7 +-
 drivers/devfreq/Kconfig                       |   62 +
 drivers/devfreq/Makefile                      |    3 +
 drivers/devfreq/devfreq-vpu.c                 |  156 +
 drivers/devfreq/devfreq.c                     |  235 +-
 drivers/devfreq/governor_performance.c        |    7 +
 drivers/devfreq/governor_powersave.c          |    7 +
 drivers/devfreq/governor_simpleondemand.c     |  137 +-
 drivers/devfreq/governor_throughput.c         |  218 +
 drivers/devfreq/mck4_memorybus.c              | 1117 +++
 drivers/gpio/Kconfig                          |    3 +
 drivers/gpio/Makefile                         |    1 +
 drivers/gpio/gpio-pxa.c                       |  224 +-
 drivers/gpio/secgpio_dvs.c                    |  375 +
 drivers/gpu/Makefile                          |    2 +-
 drivers/gpu/drm/Kconfig                       |    7 +
 drivers/gpu/drm/Makefile                      |    1 +
 drivers/gpu/ion/Kconfig                       |   19 +
 drivers/gpu/ion/Makefile                      |    4 +
 drivers/gpu/ion/ion.c                         | 1526 +++
 drivers/gpu/ion/ion_carveout_heap.c           |  265 +
 drivers/gpu/ion/ion_heap.c                    |   73 +
 drivers/gpu/ion/ion_page_pool.c               |  163 +
 drivers/gpu/ion/ion_priv.h                    |  253 +
 drivers/gpu/ion/ion_system_heap.c             |  478 +
 drivers/gpu/ion/pxa/Makefile                  |    1 +
 drivers/gpu/ion/pxa/pxa_ion.c                 |  177 +
 drivers/i2c/Kconfig                           |    1 +
 drivers/i2c/Makefile                          |    2 +-
 drivers/i2c/busses/i2c-pxa.c                  |  624 +-
 drivers/i2c/chips/Kconfig                     |   41 +
 drivers/i2c/chips/Makefile                    |    7 +
 drivers/i2c/i2c-core.c                        |   22 +-
 drivers/input/Kconfig                         |    9 +
 drivers/input/Makefile                        |    1 +
 drivers/input/evdev.c                         |   53 +
 drivers/input/input.c                         |   13 +-
 drivers/input/keyboard/Kconfig                |    9 +
 drivers/input/keyboard/Makefile               |    1 +
 drivers/input/keyboard/gpio_keys.c            |  235 +-
 drivers/input/keyreset.c                      |  263 +
 drivers/input/misc/88pm822_onkey.c            |  275 +
 drivers/input/misc/Kconfig                    |   43 +
 drivers/input/misc/Makefile                   |    5 +
 drivers/input/touchscreen/Kconfig             |  107 +
 drivers/input/touchscreen/Makefile            |   12 +
 drivers/input/touchscreen/bt532_ts.c          | 4296 +++++++++
 .../zinitix_touch_bt532_firmware.h            | 4127 +++++++++
 drivers/leds/Kconfig                          |   25 +
 drivers/leds/Makefile                         |    3 +
 drivers/media/video/Kconfig                   | 1541 +---
 drivers/media/video/Makefile                  |   33 +-
 drivers/media/video/mmp_camera.h              |  291 +
 drivers/mfd/88pm822.c                         | 1253 +++
 drivers/mfd/Kconfig                           |  113 +
 drivers/mfd/Makefile                          |   17 +
 drivers/mfd/rt8973.c                          | 1365 +++
 drivers/misc/Kconfig                          |   54 +
 drivers/misc/Makefile                         |   10 +
 drivers/misc/uid_stat.c                       |  156 +
 drivers/nfc/Kconfig                           |   47 +-
 drivers/nfc/Makefile                          |    4 +-
 drivers/power/Kconfig                         |  138 +
 drivers/power/Makefile                        |   21 +-
 drivers/power/power_supply_core.c             |   31 +-
 drivers/power/power_supply_sysfs.c            |   26 +-
 drivers/regulator/88pm822.c                   |  550 ++
 drivers/regulator/Kconfig                     |   44 +-
 drivers/regulator/Makefile                    |    7 +-
 drivers/rtc/Kconfig                           |   27 +
 drivers/rtc/Makefile                          |    5 +-
 drivers/rtc/rtc-88pm822.c                     |  400 +
 drivers/rtc/rtc-sa1100.c                      |  117 +-
 drivers/spi/Kconfig                           |    4 +-
 drivers/spi/spi-pxa2xx.c                      |  109 +-
 drivers/staging/iio/Kconfig                   |    2 +
 drivers/staging/iio/imu/Kconfig               |    1 +
 drivers/staging/iio/imu/Makefile              |    1 +
 drivers/staging/iio/imu/mpu/Kconfig           |   24 +
 drivers/staging/iio/imu/mpu/Makefile          |   28 +
 drivers/staging/iio/industrialio-buffer.c     |    4 +-
 drivers/staging/iio/industrialio-core.c       |   11 +
 drivers/staging/iio/industrialio-event.c      |   12 +-
 drivers/staging/iio/inkern.c                  |    2 +-
 drivers/staging/iio/inv_test/Kconfig          |   11 +
 drivers/staging/iio/inv_test/Makefile         |    6 +
 drivers/staging/iio/inv_test/inv_counters.h   |   75 +
 drivers/staging/iio/kfifo_buf.c               |   23 +-
 drivers/staging/iio/magnetometer/Kconfig      |   10 +
 drivers/staging/iio/magnetometer/Makefile     |    9 +
 .../iio/magnetometer/inv_mmc328x_core.c       |  412 +
 .../iio/magnetometer/inv_mmc328x_iio.h        |   84 +
 .../iio/magnetometer/inv_mmc328x_ring.c       |  136 +
 .../iio/magnetometer/inv_mmc328x_trigger.c    |   84 +
 drivers/staging/iio/types.h                   |    2 +
 drivers/staging/zsmalloc/Kconfig              |    4 -
 drivers/staging/zsmalloc/zsmalloc-main.c      |  269 +-
 drivers/staging/zsmalloc/zsmalloc.h           |   20 +-
 drivers/staging/zsmalloc/zsmalloc_int.h       |    8 +-
 drivers/tty/serial/pxa.c                      |  800 +-
 drivers/tty/serial/serial_core.c              |   21 +-
 drivers/tty/vt/vt_ioctl.c                     |   47 +-
 drivers/uio/Kconfig                           |   35 +
 drivers/uio/Makefile                          |    4 +
 drivers/uio/uio.c                             |   43 +-
 drivers/uio/uio_coda7542.c                    |  596 ++
 drivers/uio/uio_mvisp.c                       |  338 +
 drivers/video/Kconfig                         |   32 +-
 drivers/video/Makefile                        |    7 +-
 drivers/video/backlight/Kconfig               |   33 +
 drivers/video/backlight/Makefile              |    2 +
 drivers/video/backlight/lcd.c                 |    2 +-
 drivers/video/fbmem.c                         |   64 +-
 drivers/video/logo/Makefile                   |    1 +
 drivers/video/logo/logo.c                     |    5 +
 drivers/video/logo/logo_android_clut224.ppm   | 8163 +++++++++++++++++
 drivers/video/pxa168fb.c                      | 2832 +++++-
 drivers/video/pxa168fb.h                      | 2060 ++++-
 drivers/video/pxa168fb_common.c               | 2651 ++++++
 drivers/video/pxa168fb_common.h               |  100 +
 drivers/video/pxa168fb_ovly.c                 | 1174 +++
 drivers/video/pxa688_misc.c                   | 1064 +++
 drivers/video/pxa688_phy.c                    | 1495 +++
 firmware/Makefile                             |   16 +-
 fs/Kconfig                                    |    5 +
 fs/Makefile                                   |    4 +
 fs/eventpoll.c                                |   90 +-
 fs/exec.c                                     |    2 +-
 fs/fs-writeback.c                             |    2 +-
 fs/proc/base.c                                |   37 +-
 include/asm-generic/cputime.h                 |    3 +
 include/asm-generic/dma-contiguous.h          |   28 +
 include/asm-generic/emergency-restart.h       |    2 +-
 include/asm-generic/mutex-xchg.h              |   11 +-
 include/linux/alarmtimer.h                    |    6 +-
 include/linux/battery/fuelgauge/88pm80x_fg.h  |   60 +
 .../battery/fuelgauge/88pm80x_table_goya.h    |  806 ++
 include/linux/battery/sec_battery.h           |  245 +
 include/linux/battery/sec_charger.h           |  151 +
 include/linux/battery/sec_charging_common.h   |  594 ++
 include/linux/battery/sec_fuelgauge.h         |  143 +
 include/linux/capability.h                    |    5 +-
 include/linux/cgroup.h                        |   14 +-
 include/linux/clk.h                           |   32 +
 include/linux/cpu.h                           |    7 +
 include/linux/cpufreq.h                       |    9 +-
 include/linux/cpuidle.h                       |   11 +
 include/linux/devfreq.h                       |   71 +
 include/linux/device.h                        |    4 +
 include/linux/dma-buf.h                       |   16 +
 include/linux/dma-contiguous.h                |  112 +
 include/linux/dmaengine.h                     |    6 +
 include/linux/eventpoll.h                     |   12 +
 include/linux/freezer.h                       |   11 +
 include/linux/gfp.h                           |   14 +
 include/linux/gpio-pxa.h                      |    3 +
 include/linux/gpio_event.h                    |  170 +
 include/linux/huge_mm.h                       |    4 +-
 include/linux/i2c.h                           |    3 +
 include/linux/i2c/ft5306_touch.h              |   32 +
 include/linux/i2c/pxa-i2c.h                   |    9 +
 include/linux/input.h                         |    9 +-
 include/linux/input/bt532_ts.h                |   58 +
 include/linux/ion.h                           |  361 +
 include/linux/kernel.h                        |    3 +
 include/linux/kexec.h                         |    3 +
 include/linux/keyreset.h                      |   30 +
 include/linux/kthread.h                       |    8 +-
 include/linux/lcd.h                           |    2 +
 include/linux/linux_logo.h                    |    1 +
 include/linux/lockdep.h                       |    3 +
 include/linux/lps331ap.h                      |   57 +
 include/linux/mfd/88pm80x.h                   |  645 ++
 include/linux/mfd/88pm822.h                   |  602 ++
 include/linux/mfd/rt8973.h                    |   76 +
 include/linux/mm.h                            |   22 +-
 include/linux/mmc/card.h                      |   17 +-
 include/linux/mmc/core.h                      |    7 +
 include/linux/mmc/host.h                      |  144 +-
 include/linux/mmc/mmc.h                       |   65 +-
 include/linux/mmc/pm.h                        |    1 +
 include/linux/mmc/sdhci.h                     |   33 +-
 include/linux/mmu_notifier.h                  |    2 +-
 include/linux/mmzone.h                        |   46 +-
 include/linux/mpu.h                           |  110 +
 include/linux/mtd/mtd.h                       |    1 +
 include/linux/mvisp.h                         |  311 +
 include/linux/namei.h                         |    3 +
 include/linux/page-isolation.h                |   22 +-
 include/linux/persistent_ram.h                |   83 +
 include/linux/platform_data/mmp_audio.h       |   22 +
 include/linux/platform_data/mv_usb.h          |  104 +-
 include/linux/platform_data/pxa_sdhci.h       |   63 +
 include/linux/pm.h                            |    2 -
 include/linux/pm_qos.h                        |   34 +-
 include/linux/pm_runtime.h                    |    3 -
 include/linux/pm_wakeup.h                     |   15 +-
 include/linux/power/fake-sysoff.h             |   22 +
 include/linux/power_supply.h                  |   85 +
 include/linux/pxa2xx_ssp.h                    |    6 +-
 include/linux/pxa_ion.h                       |   44 +
 include/linux/regdump_ops.h                   |   51 +
 include/linux/regmap.h                        |    1 +
 include/linux/regulator/consumer.h            |    6 +
 include/linux/rfkill.h                        |    7 +-
 include/linux/rmap.h                          |   55 +-
 include/linux/rtdefs.h                        |   81 +
 include/linux/rwsem.h                         |    9 +
 include/linux/sched.h                         |   23 +-
 include/linux/sd8x_rfkill.h                   |   53 +
 include/linux/secgpio_dvs.h                   |   31 +
 include/linux/serial_core.h                   |    1 +
 include/linux/serial_reg.h                    |   13 +-
 include/linux/sockios.h                       |    1 +
 include/linux/spi/cmmb.h                      |   19 +
 include/linux/spi/pxa2xx_spi.h                |    3 +-
 include/linux/spi/spi.h                       |    4 +
 include/linux/suspend.h                       |   15 +-
 include/linux/switch.h                        |   53 +
 include/linux/uid_stat.h                      |   29 +
 include/linux/uio_coda7542.h                  |   49 +
 include/linux/uio_driver.h                    |   13 +-
 include/linux/uio_mvisp.h                     |   29 +
 include/linux/vibrator.h                      |   28 +
 include/linux/videodev2.h                     |   45 +-
 include/linux/vmstat.h                        |    9 +
 include/linux/wakelock.h                      |   67 +
 include/media/ispvideo.h                      |   75 +
 include/media/map_camera.h                    |  162 +
 include/media/map_hw.h                        |  268 +
 include/media/map_vnode.h                     |   81 +
 include/media/mrvl-camera.h                   |  130 +
 include/media/soc_camera.h                    |    6 +
 include/media/v4l2-subdev.h                   |    1 +
 include/net/activity_stats.h                  |   25 +
 include/net/dst.h                             |    3 +-
 include/trace/events/cpufreq_interactive.h    |  112 +
 include/trace/events/power.h                  |   53 +
 include/video/mmpdisp_export_funcs.h          |   62 +
 init/Kconfig                                  |   14 +
 init/main.c                                   |    2 +-
 kernel/Makefile                               |    7 +
 kernel/cpu.c                                  |   22 +-
 kernel/fork.c                                 |   19 +-
 kernel/futex.c                                |   18 +-
 kernel/irq/handle.c                           |   11 +-
 kernel/irq/pm.c                               |    7 +-
 kernel/kexec.c                                |    4 +-
 kernel/kthread.c                              |   88 +-
 kernel/panic.c                                |   17 +-
 kernel/power/Makefile                         |    3 +
 kernel/power/autosleep.c                      |  128 +
 kernel/power/main.c                           |  160 +-
 kernel/power/power.h                          |   27 +
 kernel/power/qos.c                            |  325 +-
 kernel/power/suspend.c                        |   15 +
 kernel/printk.c                               |  178 +-
 kernel/ptrace.c                               |   72 +-
 kernel/rcutree.c                              |    4 +-
 kernel/rwsem.c                                |   10 +
 kernel/sched/core.c                           |  102 +-
 kernel/sched/fair.c                           |    6 +-
 kernel/sched/rt.c                             |   23 +-
 kernel/signal.c                               |   22 +-
 kernel/softirq.c                              |   21 +
 kernel/sys.c                                  |  111 +-
 kernel/sysctl.c                               |   33 +
 kernel/time/alarmtimer.c                      |  113 +-
 kernel/time/timekeeping.c                     |    3 +-
 kernel/timeconst.pl                           |    2 +-
 kernel/timer.c                                |    9 +
 kernel/trace/ring_buffer.c                    |  412 +-
 kernel/trace/trace.c                          |   65 +-
 kernel/trace/trace.h                          |    2 +
 kernel/watchdog.c                             |  100 +-
 kernel/workqueue.c                            |   10 +-
 lib/Kconfig.debug                             |   46 +-
 lib/idr.c                                     |   10 +-
 mm/Kconfig                                    |    8 +-
 mm/Makefile                                   |    3 +-
 mm/compaction.c                               |  430 +-
 mm/internal.h                                 |   50 +
 mm/memory.c                                   |   50 +-
 mm/migrate.c                                  |    8 +-
 mm/mmap.c                                     |   34 +-
 mm/mremap.c                                   |   65 +-
 mm/page_alloc.c                               |  706 +-
 mm/page_isolation.c                           |   35 +-
 mm/rmap.c                                     |  145 +-
 mm/shmem.c                                    |   24 +-
 mm/slub.c                                     |   63 +-
 mm/vmscan.c                                   |  382 +-
 mm/vmstat.c                                   |   59 +-
 net/Kconfig                                   |   16 +-
 net/Makefile                                  |    1 +
 scripts/Makefile                              |    2 +
 scripts/cgitinfo.c                            |  159 +
 scripts/setlocalversion                       |    2 +-
 security/commoncap.c                          |   11 +
 514 files changed, 106648 insertions(+), 4306 deletions(-)
 create mode 100644 arch/arm/configs/goyawifi_pmos_minimal_defconfig
 create mode 100644 arch/arm/include/asm/dma-contiguous.h
 create mode 100644 arch/arm/include/asm/rodata.h
 create mode 100644 arch/arm/mach-mmp/acpuclock-pxa988.c
 create mode 100755 arch/arm/mach-mmp/board-goya-battery.c
 create mode 100755 arch/arm/mach-mmp/board-goya-input.c
 create mode 100755 arch/arm/mach-mmp/board-goya.c
 create mode 100755 arch/arm/mach-mmp/board-goya.h
 create mode 100644 arch/arm/mach-mmp/boost.c
 create mode 100644 arch/arm/mach-mmp/clock-pxa988.c
 create mode 100644 arch/arm/mach-mmp/coresight-v7.c
 create mode 100644 arch/arm/mach-mmp/cpuidle-pxa988.c
 create mode 100644 arch/arm/mach-mmp/dvfs-pxa988.c
 create mode 100644 arch/arm/mach-mmp/gpio-edge.c
 create mode 100644 arch/arm/mach-mmp/gpu_mem.c
 create mode 100644 arch/arm/mach-mmp/helpfunc_v7.S
 create mode 100755 arch/arm/mach-mmp/include/mach/Quicklogic_Vxbridge_interface.h
 create mode 100644 arch/arm/mach-mmp/include/mach/camera.h
 create mode 100644 arch/arm/mach-mmp/include/mach/clock-pxa988.h
 create mode 100644 arch/arm/mach-mmp/include/mach/delay.h
 create mode 100644 arch/arm/mach-mmp/include/mach/dvfs.h
 create mode 100644 arch/arm/mach-mmp/include/mach/features.h
 create mode 100644 arch/arm/mach-mmp/include/mach/gpio-edge.h
 create mode 100644 arch/arm/mach-mmp/include/mach/gpu_mem.h
 create mode 100644 arch/arm/mach-mmp/include/mach/io.h
 create mode 100644 arch/arm/mach-mmp/include/mach/isl29043.h
 create mode 100644 arch/arm/mach-mmp/include/mach/isp_dev.h
 create mode 100644 arch/arm/mach-mmp/include/mach/memory.h
 create mode 100755 arch/arm/mach-mmp/include/mach/mfp-pxa986-goya.h
 create mode 100644 arch/arm/mach-mmp/include/mach/mmp3.h
 create mode 100644 arch/arm/mach-mmp/include/mach/mmp_device.h
 create mode 100644 arch/arm/mach-mmp/include/mach/pxa168fb.h
 create mode 100644 arch/arm/mach-mmp/include/mach/pxa988.h
 create mode 100644 arch/arm/mach-mmp/include/mach/pxa988_ddr.h
 create mode 100644 arch/arm/mach-mmp/include/mach/pxa988_lowpower.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-ciu.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-coresight.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-map.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-mcu.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-mpmu.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-usb.h
 create mode 100644 arch/arm/mach-mmp/include/mach/reset-pxa988.h
 create mode 100755 arch/arm/mach-mmp/include/mach/samsung_camera.h
 create mode 100644 arch/arm/mach-mmp/include/mach/samsung_camera_goya.h
 create mode 100644 arch/arm/mach-mmp/include/mach/scu.h
 create mode 100644 arch/arm/mach-mmp/include/mach/sec_debug.h
 create mode 100644 arch/arm/mach-mmp/include/mach/soc_coda7542.h
 create mode 100644 arch/arm/mach-mmp/include/mach/uio_hdmi.h
 create mode 100644 arch/arm/mach-mmp/include/mach/uio_isp.h
 create mode 100644 arch/arm/mach-mmp/mmp_device.c
 create mode 100644 arch/arm/mach-mmp/onboard.h
 create mode 100755 arch/arm/mach-mmp/onboard/Lcd_mipi2lvds_vx5b3d.c
 create mode 100644 arch/arm/mach-mmp/onboard/Makefile
 create mode 100755 arch/arm/mach-mmp/onboard/board-goya-display.c
 create mode 100644 arch/arm/mach-mmp/platsmp.c
 create mode 100644 arch/arm/mach-mmp/platsmp.h
 create mode 100644 arch/arm/mach-mmp/pm-pxa988.c
 create mode 100644 arch/arm/mach-mmp/pmu.c
 create mode 100644 arch/arm/mach-mmp/pxa988.c
 create mode 100644 arch/arm/mach-mmp/pxa988_headsmp.S
 create mode 100644 arch/arm/mach-mmp/pxa988_hotplug.c
 create mode 100644 arch/arm/mach-mmp/pxa988_lowpower.c
 create mode 100644 arch/arm/mach-mmp/reset-pxa988.c
 create mode 100644 arch/arm/mach-mmp/reset.c
 create mode 100755 arch/arm/mach-mmp/sec-common.c
 create mode 100644 arch/arm/mach-mmp/sleep-pxa988.S
 create mode 100644 arch/arm/mach-mmp/stand-hotplug.c
 create mode 100644 arch/arm/mach-mmp/wakeupgen.c
 create mode 100644 arch/arm/plat-pxa/clock.c
 create mode 100644 arch/arm/plat-pxa/debugfs.c
 create mode 100644 arch/arm/plat-pxa/dump_regs.c
 create mode 100644 arch/arm/plat-pxa/dvfs.c
 create mode 100644 arch/arm/plat-pxa/include/plat/clock.h
 create mode 100644 arch/arm/plat-pxa/include/plat/debugfs.h
 create mode 100644 arch/arm/plat-pxa/include/plat/devfreq.h
 create mode 100644 arch/arm/plat-pxa/include/plat/dump_regs.h
 create mode 100644 arch/arm/plat-pxa/include/plat/dvfs.h
 create mode 100644 arch/arm/plat-pxa/include/plat/fb_ioctl.h
 create mode 100644 arch/arm/plat-pxa/include/plat/pm.h
 create mode 100644 arch/arm/plat-pxa/include/plat/pxa9xx_acipc.h
 create mode 100644 arch/arm/plat-pxa/include/plat/pxa_trace.h
 create mode 100644 arch/arm/plat-pxa/panic.c
 create mode 100644 arch/arm/plat-pxa/usb.c
 create mode 100644 drivers/base/dma-contiguous.c
 create mode 100644 drivers/base/regdump.c
 create mode 100755 drivers/battery/88pm80x_fuelgauge.c
 create mode 100755 drivers/battery/Kconfig
 create mode 100755 drivers/battery/Makefile
 create mode 100755 drivers/battery/sec_battery.c
 create mode 100755 drivers/battery/sec_fuelgauge.c
 create mode 100644 drivers/char/88pm822_usb.c
 create mode 100644 drivers/char/maxscend/Kconfig
 create mode 100644 drivers/char/maxscend/Makefile
 create mode 100644 drivers/char/maxscend/mxdchar.h
 create mode 100644 drivers/char/maxscend/mxdspi_pxa.c
 create mode 100644 drivers/char/pxa9xx_acipc.c
 create mode 100644 drivers/cpufreq/cpufreq_interactive.c
 create mode 100644 drivers/cpufreq/pxa988-cpufreq.c
 create mode 100644 drivers/cpuidle/coupled.c
 create mode 100644 drivers/devfreq/devfreq-vpu.c
 create mode 100644 drivers/devfreq/governor_throughput.c
 create mode 100644 drivers/devfreq/mck4_memorybus.c
 create mode 100755 drivers/gpio/secgpio_dvs.c
 create mode 100644 drivers/gpu/ion/Kconfig
 create mode 100644 drivers/gpu/ion/Makefile
 create mode 100644 drivers/gpu/ion/ion.c
 create mode 100644 drivers/gpu/ion/ion_carveout_heap.c
 create mode 100644 drivers/gpu/ion/ion_heap.c
 create mode 100644 drivers/gpu/ion/ion_page_pool.c
 create mode 100644 drivers/gpu/ion/ion_priv.h
 create mode 100644 drivers/gpu/ion/ion_system_heap.c
 create mode 100644 drivers/gpu/ion/pxa/Makefile
 create mode 100644 drivers/gpu/ion/pxa/pxa_ion.c
 create mode 100755 drivers/i2c/chips/Kconfig
 create mode 100755 drivers/i2c/chips/Makefile
 create mode 100644 drivers/input/keyreset.c
 create mode 100644 drivers/input/misc/88pm822_onkey.c
 create mode 100755 drivers/input/touchscreen/bt532_ts.c
 create mode 100755 drivers/input/touchscreen/zinitix_touch_bt532_firmware.h
 create mode 100644 drivers/media/video/mmp_camera.h
 create mode 100755 drivers/mfd/88pm822.c
 create mode 100644 drivers/mfd/rt8973.c
 create mode 100644 drivers/misc/uid_stat.c
 create mode 100755 drivers/regulator/88pm822.c
 create mode 100755 drivers/rtc/rtc-88pm822.c
 create mode 100644 drivers/staging/iio/imu/mpu/Kconfig
 create mode 100644 drivers/staging/iio/imu/mpu/Makefile
 create mode 100644 drivers/staging/iio/inv_test/Kconfig
 create mode 100644 drivers/staging/iio/inv_test/Makefile
 create mode 100644 drivers/staging/iio/inv_test/inv_counters.h
 create mode 100644 drivers/staging/iio/magnetometer/inv_mmc328x_core.c
 create mode 100644 drivers/staging/iio/magnetometer/inv_mmc328x_iio.h
 create mode 100644 drivers/staging/iio/magnetometer/inv_mmc328x_ring.c
 create mode 100644 drivers/staging/iio/magnetometer/inv_mmc328x_trigger.c
 create mode 100644 drivers/uio/uio_coda7542.c
 create mode 100644 drivers/uio/uio_mvisp.c
 create mode 100644 drivers/video/logo/logo_android_clut224.ppm
 create mode 100644 drivers/video/pxa168fb_common.c
 create mode 100644 drivers/video/pxa168fb_common.h
 create mode 100644 drivers/video/pxa168fb_ovly.c
 create mode 100644 drivers/video/pxa688_misc.c
 create mode 100644 drivers/video/pxa688_phy.c
 create mode 100644 include/asm-generic/dma-contiguous.h
 create mode 100755 include/linux/battery/fuelgauge/88pm80x_fg.h
 create mode 100755 include/linux/battery/fuelgauge/88pm80x_table_goya.h
 create mode 100755 include/linux/battery/sec_battery.h
 create mode 100755 include/linux/battery/sec_charger.h
 create mode 100755 include/linux/battery/sec_charging_common.h
 create mode 100755 include/linux/battery/sec_fuelgauge.h
 create mode 100644 include/linux/dma-contiguous.h
 create mode 100644 include/linux/gpio_event.h
 create mode 100644 include/linux/i2c/ft5306_touch.h
 create mode 100755 include/linux/input/bt532_ts.h
 create mode 100644 include/linux/ion.h
 create mode 100644 include/linux/keyreset.h
 create mode 100644 include/linux/lps331ap.h
 create mode 100644 include/linux/mfd/88pm80x.h
 create mode 100755 include/linux/mfd/88pm822.h
 create mode 100644 include/linux/mfd/rt8973.h
 create mode 100644 include/linux/mpu.h
 create mode 100644 include/linux/mvisp.h
 create mode 100644 include/linux/persistent_ram.h
 create mode 100644 include/linux/platform_data/mmp_audio.h
 create mode 100644 include/linux/power/fake-sysoff.h
 create mode 100644 include/linux/pxa_ion.h
 create mode 100644 include/linux/regdump_ops.h
 create mode 100644 include/linux/rtdefs.h
 create mode 100644 include/linux/sd8x_rfkill.h
 create mode 100755 include/linux/secgpio_dvs.h
 create mode 100644 include/linux/spi/cmmb.h
 create mode 100644 include/linux/switch.h
 create mode 100644 include/linux/uid_stat.h
 create mode 100644 include/linux/uio_coda7542.h
 create mode 100644 include/linux/uio_mvisp.h
 create mode 100755 include/linux/vibrator.h
 create mode 100644 include/linux/wakelock.h
 create mode 100644 include/media/ispvideo.h
 create mode 100644 include/media/map_camera.h
 create mode 100644 include/media/map_hw.h
 create mode 100644 include/media/map_vnode.h
 create mode 100644 include/media/mrvl-camera.h
 create mode 100644 include/net/activity_stats.h
 create mode 100644 include/trace/events/cpufreq_interactive.h
 create mode 100644 include/video/mmpdisp_export_funcs.h
 create mode 100644 kernel/power/autosleep.c
 create mode 100644 scripts/cgitinfo.c

diff --git a/Makefile b/Makefile
index a2e69a08..37ada86c 100644
--- a/Makefile
+++ b/Makefile
@@ -192,8 +192,10 @@ SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
+#ARCH		?= $(SUBARCH)
+ARCH		?= arm
+#CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
+CROSS_COMPILE	?= /usr/bin/arm-linux-gnueabi-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
@@ -330,8 +332,8 @@ include $(srctree)/scripts/Kbuild.include
 
 AS		= $(CROSS_COMPILE)as
 LD		= $(CROSS_COMPILE)ld
-CC		= $(CROSS_COMPILE)gcc
-CPP		= $(CC) -E
+CC		= ccache $(CROSS_COMPILE)gcc-4.7
+CPP		= ccache $(CC) -E
 AR		= $(CROSS_COMPILE)ar
 NM		= $(CROSS_COMPILE)nm
 STRIP		= $(CROSS_COMPILE)strip
@@ -342,6 +344,7 @@ GENKSYMS	= scripts/genksyms/genksyms
 INSTALLKERNEL  := installkernel
 DEPMOD		= /sbin/depmod
 KALLSYMS	= scripts/kallsyms
+CGITINFO	= scripts/cgitinfo
 PERL		= perl
 CHECK		= sparse
 
@@ -364,11 +367,9 @@ LINUXINCLUDE    := -I$(srctree)/arch/$(hdr-arch)/include \
 
 KBUILD_CPPFLAGS := -D__KERNEL__
 
-KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
-		   -fno-strict-aliasing -fno-common \
-		   -Werror-implicit-function-declaration \
-		   -Wno-format-security \
-		   -fno-delete-null-pointer-checks
+KBUILD_CFLAGS   := -Wall -fno-strict-aliasing -fno-common \
+		   -fno-delete-null-pointer-checks -w
+
 KBUILD_AFLAGS_KERNEL :=
 KBUILD_CFLAGS_KERNEL :=
 KBUILD_AFLAGS   := -D__ASSEMBLY__
@@ -393,6 +394,8 @@ export KBUILD_AFLAGS_MODULE KBUILD_CFLAGS_MODULE KBUILD_LDFLAGS_MODULE
 export KBUILD_AFLAGS_KERNEL KBUILD_CFLAGS_KERNEL
 export KBUILD_ARFLAGS
 
+export CGITINFO
+
 # When compiling out-of-tree modules, put MODVERDIR in the module
 # tree rather than in the kernel tree. The kernel tree might
 # even be read-only.
@@ -686,7 +689,9 @@ export	INSTALL_PATH ?= /boot
 # makefile but the argument can be passed to make if needed.
 #
 
-MODLIB	= $(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE)
+#MODLIB	= $(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE)
+#MODLIB	= $(INSTALL_MOD_PATH)/lib/modules/$(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))
+MODLIB	= $(INSTALL_MOD_PATH)/lib/modules
 export MODLIB
 
 #
@@ -1115,16 +1120,16 @@ modules_install: _modinst_ _modinst_post
 
 PHONY += _modinst_
 _modinst_:
-	@rm -rf $(MODLIB)/kernel
-	@rm -f $(MODLIB)/source
-	@mkdir -p $(MODLIB)/kernel
-	@ln -s $(srctree) $(MODLIB)/source
-	@if [ ! $(objtree) -ef  $(MODLIB)/build ]; then \
-		rm -f $(MODLIB)/build ; \
-		ln -s $(objtree) $(MODLIB)/build ; \
-	fi
-	@cp -f $(objtree)/modules.order $(MODLIB)/
-	@cp -f $(objtree)/modules.builtin $(MODLIB)/
+#	@rm -rf $(MODLIB)/kernel
+#	@rm -f $(MODLIB)/source
+#	@mkdir -p $(MODLIB)/kernel
+#	@ln -s $(srctree) $(MODLIB)/source
+#	@if [ ! $(objtree) -ef  $(MODLIB)/build ]; then \
+#		rm -f $(MODLIB)/build ; \
+#		ln -s $(objtree) $(MODLIB)/build ; \
+#	fi
+#	@cp -f $(objtree)/modules.order $(MODLIB)/
+#	@cp -f $(objtree)/modules.builtin $(MODLIB)/
 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modinst
 
 # This depmod is only for convenience to give the initial
@@ -1133,7 +1138,7 @@ _modinst_:
 PHONY += _modinst_post
 _modinst_post: _modinst_
 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.fwinst obj=firmware __fw_modinst
-	$(call cmd,depmod)
+#	$(call cmd,depmod)
 
 else # CONFIG_MODULES
 
@@ -1530,9 +1535,12 @@ quiet_cmd_rmfiles = $(if $(wildcard $(rm-files)),CLEAN   $(wildcard $(rm-files))
       cmd_rmfiles = rm -f $(rm-files)
 
 # Run depmod only if we have System.map and depmod is executable
-quiet_cmd_depmod = DEPMOD  $(KERNELRELEASE)
+#quiet_cmd_depmod = DEPMOD  $(KERNELRELEASE)
+#      cmd_depmod = $(CONFIG_SHELL) $(srctree)/scripts/depmod.sh $(DEPMOD) \
+#                   $(KERNELRELEASE)
+quiet_cmd_depmod = DEPMOD $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))
       cmd_depmod = $(CONFIG_SHELL) $(srctree)/scripts/depmod.sh $(DEPMOD) \
-                   $(KERNELRELEASE)
+                   $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))
 
 # Create temporary dir for module support files
 # clean it up only when building all modules
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 7a8660a2..ec8226ab 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -4,6 +4,8 @@ config ARM
 	select HAVE_AOUT
 	select HAVE_DMA_API_DEBUG
 	select HAVE_IDE if PCI || ISA || PCMCIA
+	select HAVE_DMA_CONTIGUOUS if (CPU_V6 || CPU_V6K || CPU_V7)
+	select CMA if (CPU_V6 || CPU_V6K || CPU_V7)
 	select HAVE_MEMBLOCK
 	select RTC_LIB
 	select SYS_SUPPORTS_APM_EMULATION
@@ -194,6 +196,9 @@ config NEED_RET_TO_USER
 config ARCH_MTD_XIP
 	bool
 
+config ARCH_PROVIDES_UDELAY
+	bool
+
 config VECTORS_BASE
 	hex
 	default 0xffff0000 if MMU || CPU_HIGH_VECTOR
@@ -626,18 +631,22 @@ config ARCH_ORION5X
 	  Orion-2 (5281), Orion-1-90 (6183).
 
 config ARCH_MMP
-	bool "Marvell PXA168/910/MMP2"
+	bool "Marvell PXA168/910/988/MMP2/EDEN"
 	depends on MMU
 	select ARCH_REQUIRE_GPIOLIB
 	select CLKDEV_LOOKUP
 	select GENERIC_CLOCKEVENTS
 	select GPIO_PXA
+	select IRQ_DOMAIN
 	select TICK_ONESHOT
 	select PLAT_PXA
 	select SPARSE_IRQ
+	select ARCH_HAS_CPUFREQ
 	select GENERIC_ALLOCATOR
+	select NEED_MACH_IO_H
+	select NEED_MACH_MEMORY_H
 	help
-	  Support for Marvell's PXA168/PXA910(MMP) and MMP2 processor line.
+	  Support for Marvell's PXA168/PXA910/PXA988/MMP2 and EDEN processor line.
 
 config ARCH_KS8695
 	bool "Micrel/Kendin KS8695"
@@ -723,6 +732,7 @@ config ARCH_PXA
 	select MULTI_IRQ_HANDLER
 	select ARM_CPU_SUSPEND if PM
 	select HAVE_IDE
+	select NEED_MACH_IO_H
 	help
 	  Support for Intel/Marvell's PXA2xx/PXA3xx processor line.
 
@@ -1160,7 +1170,7 @@ config ARM_NR_BANKS
 
 config IWMMXT
 	bool "Enable iWMMXt support"
-	depends on CPU_XSCALE || CPU_XSC3 || CPU_MOHAWK || CPU_PJ4
+	depends on CPU_XSCALE || CPU_XSC3 || CPU_MOHAWK || CPU_PJ4 || CPU_PJ4B
 	default y if PXA27x || PXA3xx || PXA95x || ARCH_MMP
 	help
 	  Enable support for iWMMXt context switching at run time if
@@ -1393,6 +1403,34 @@ config ARM_ERRATA_764369
 	  relevant cache maintenance functions and sets a specific bit
 	  in the diagnostic control register of the SCU.
 
+config ARM_ERRATA_794322
+	bool "ARM errata: An instruction fetch can be allocated into the L2 cache after the cache is disabled"
+	depends on CPU_CA7MP
+	help
+	  This option enables the workaround for erratum 794322
+	  affecting Cortex-A7 MPCore r0p2, r0p3 with an L2 cache. The
+	  SCTLR.C bit controls when data can be allocated to data and
+	  unified caches. On a Cortex-A7 processor, instruction fetches
+	  can cause lines to be allocated to the L2 cache when the C bit
+	  is set to 1. Because of this erratum, an instruction fetch
+	  might cause an allocation to the L2 cache when the C bit is
+	  set to 0.
+
+config ARM_ERRATA_802022
+       bool "ARM errata: last duplicate tag may become un-sync with L1 tag after exiting MP shutdown mode"
+       depends on CPU_CA7MP && !ARCH_NEEDS_CPU_IDLE_COUPLED
+       help
+	 This option enables the workaround for erratum 802022 affecting
+	 Cortex-A7 MPCore r0p0, r0p1, r0p2, r0p3, r0p4. A duplicate tag
+	 update for CPU A gets priority over the last duplicate tag
+	 invalidate for CPU B during CPU B's automatic invalidation process.
+	 Normally CPU B's tag invalidation will pause and then continue,
+	 but for the last tag entry it will pause and then forget it was
+	 invalidating entries because the index counter has reached the
+	 maximum value.
+	 This workaround is to make sure all CPUs exit shutdown mode when
+	 exit MP shutdown mode before dcache of any core is enabled.
+
 config PL310_ERRATA_769419
 	bool "PL310 errata: no automatic Store Buffer drain"
 	depends on CACHE_L2X0
@@ -1405,6 +1443,37 @@ config PL310_ERRATA_769419
 	  on systems with an outer cache, the store buffer is drained
 	  explicitly.
 
+config ARM_ERRATA_775420
+	bool "ARM errata: A data cache maintenance operation which aborts, might lead to deadlock"
+	depends on CPU_V7
+	help
+	  This option enables the workaround for the 775420 Cortex-A9 (r2p2,
+	  r2p6,r2p8,r2p10,r3p0) erratum. In case a date cache maintenance
+	  operation aborts with MMU exception, it might cause the processor
+	  to deadlock. This workaround puts DSB before executing ISB if
+	  an abort may occur on cache maintenance.
+
+config PJ4B_ERRATA_6315
+       bool "PJ4B errata 6315"
+       depends on CPU_PJ4B
+       help
+	  Replace DMB w. DSB when its necessary to enforce an ordering between an
+	  explicit load/store op and a set/way op.
+
+config PJ4B_ERRATA_6359
+	bool "PJ4B errata 6359"
+	depends on CPU_PJ4B
+	help
+	  Boradcast DMB operations do not fully synchronize local cache hits. This option
+	  replaces all occurences of DMB with DSB.
+
+config PJ4B_ERRATA_6409
+	bool "PJ4B errata 6409"
+	depends on CPU_PJ4B
+	help
+	  IFU predicts-taken a branch, but tells ROB not-taken. This option disable static
+	  branch prediction
+
 endmenu
 
 source "arch/arm/common/Kconfig"
@@ -1491,7 +1560,7 @@ config SMP
 	depends on HAVE_SMP
 	depends on MMU
 	select USE_GENERIC_SMP_HELPERS
-	select HAVE_ARM_SCU if !ARCH_MSM_SCORPIONMP
+	select HAVE_ARM_SCU if (!ARCH_MSM_SCORPIONMP && !CPU_CA7MP)
 	help
 	  This enables support for systems with more than one CPU. If you have
 	  a system with only one CPU, like most personal computers, say N. If
@@ -1552,6 +1621,12 @@ config HAVE_ARM_SCU
 	help
 	  This option enables support for the ARM system coherency unit
 
+config ARM_ARCH_TIMER
+	bool "Architected timer support"
+	depends on CPU_V7
+	help
+	  This option enables support for the ARM architected timer
+
 config HAVE_ARM_TWD
 	bool
 	depends on SMP
@@ -1582,6 +1657,15 @@ config PAGE_OFFSET
 	default 0x80000000 if VMSPLIT_2G
 	default 0xC0000000
 
+config TEXT_OFFSET_OVERRIDE
+	bool "Enable CONFIG_TEXT_OFFSET"
+	default n
+
+config TEXT_OFFSET
+	hex "Specific kernel TEXT offset from PAGE_OFFSET"
+	depends on TEXT_OFFSET_OVERRIDE
+	default 0x00008000
+
 config NR_CPUS
 	int "Maximum number of CPUs (2-32)"
 	range 2 32
@@ -1599,7 +1683,7 @@ config LOCAL_TIMERS
 	bool "Use local timer interrupts"
 	depends on SMP
 	default y
-	select HAVE_ARM_TWD if (!ARCH_MSM_SCORPIONMP && !EXYNOS4_MCT)
+	select HAVE_ARM_TWD if (!ARCH_MSM_SCORPIONMP && !EXYNOS4_MCT && !CPU_CA7MP)
 	help
 	  Enable support for local timers on SMP platforms, rather then the
 	  legacy IPI broadcast method.  Local timers allows the system
@@ -1626,6 +1710,7 @@ config HZ
 	default OMAP_32K_TIMER_HZ if ARCH_OMAP && OMAP_32K_TIMER
 	default AT91_TIMER_HZ if ARCH_AT91
 	default SHMOBILE_TIMER_HZ if ARCH_SHMOBILE
+	default 128 if (ARCH_PXA || ARCH_MMP) && PXA_32KTIMER
 	default 100
 
 config THUMB2_KERNEL
@@ -1885,6 +1970,27 @@ config DEPRECATED_PARAM_STRUCT
 	  This was deprecated in 2001 and announced to live on for 5 years.
 	  Some old boot loaders still use this way.
 
+config ARM_FLUSH_CONSOLE_ON_RESTART
+	bool "Force flush the console on restart"
+	help
+	  If the console is locked while the system is rebooted, the messages
+	  in the temporary logbuffer would not have propogated to all the
+	  console drivers. This option forces the console lock to be
+	  released if it failed to be acquired, which will cause all the
+	  pending messages to be flushed.
+
+config ARCH_ENABLE_MEMORY_HOTPLUG
+	def_bool y
+	depends on SPARSEMEM && MMU && ARCH_MMP
+
+config ARCH_ENABLE_MEMORY_HOTREMOVE
+	def_bool y
+	depends on ARCH_ENABLE_MEMORY_HOTPLUG
+
+config ARCH_MEMORY_PROBE
+	def_bool y
+	depends on ARCH_ENABLE_MEMORY_HOTPLUG
+
 endmenu
 
 menu "Boot options"
@@ -2258,6 +2364,10 @@ config NEON
 	  Say Y to include support code for NEON, the ARMv7 Advanced SIMD
 	  Extension.
 
+config GPU_RESERVE_MEM
+	bool "GC video memory allocator"
+	help
+		reserve memory for GC as video memory
 endmenu
 
 menu "Userspace binary formats"
@@ -2283,12 +2393,15 @@ source "kernel/power/Kconfig"
 config ARCH_SUSPEND_POSSIBLE
 	depends on !ARCH_S5PC100
 	depends on CPU_ARM920T || CPU_ARM926T || CPU_SA1100 || \
-		CPU_V6 || CPU_V6K || CPU_V7 || CPU_XSC3 || CPU_XSCALE
+		CPU_V6 || CPU_V6K || CPU_V7 || CPU_XSC3 || CPU_XSCALE || CPU_MOHAWK
 	def_bool y
 
 config ARM_CPU_SUSPEND
 	def_bool PM_SLEEP
 
+config KERNEL_DEBUG_SEC
+	bool
+	default n
 endmenu
 
 source "net/Kconfig"
@@ -2304,3 +2417,7 @@ source "security/Kconfig"
 source "crypto/Kconfig"
 
 source "lib/Kconfig"
+
+config SND_AUDIODOCK_SWITCH
+	tristate "Alalog audio dock switch support"
+	
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 047a2078..af92a2e9 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -121,6 +121,8 @@ CHECKFLAGS	+= -D__arm__
 #Default value
 head-y		:= arch/arm/kernel/head$(MMUEXT).o arch/arm/kernel/init_task.o
 textofs-y	:= 0x00008000
+textofs-$(CONFIG_TEXT_OFFSET_OVERRIDE)	:= $(CONFIG_TEXT_OFFSET)
+
 textofs-$(CONFIG_ARCH_CLPS711X) := 0x00028000
 # We don't want the htc bootloader to corrupt kernel during resume
 textofs-$(CONFIG_PM_H1940)      := 0x00108000
diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index dc7e8ce8..841121a2 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -171,7 +171,8 @@ not_angel:
 		@ determine final kernel image address
 		mov	r4, pc
 		and	r4, r4, #0xf8000000
-		add	r4, r4, #TEXT_OFFSET
+		ldr	r3, =TEXT_OFFSET
+		add	r4, r4, r3
 #else
 		ldr	r4, =zreladdr
 #endif
@@ -638,6 +639,12 @@ __armv4_mmu_cache_on:
 
 __armv7_mmu_cache_on:
 		mov	r12, lr
+#ifdef CONFIG_CPU_CA7MP
+		@ CA7 Core - Set ACTLR.SMP bit before enabling MMU/Caches
+		mrc	p15, 0, r0, c1, c0, 1	@ Read CP15 ACTLR
+		orr	r0, r0, #1 << 6		@ Set ACTLR.SMP bit
+		mcr	p15, 0, r0, c1, c0, 1	@ Write CP15 ACTLR
+#endif
 #ifdef CONFIG_MMU
 		mrc	p15, 0, r11, c0, c1, 4	@ read ID_MMFR0
 		tst	r11, #0xf		@ VMSA
@@ -766,6 +773,8 @@ proc_types:
 @		b	__arm6_mmu_cache_off
 @		b	__armv3_mmu_cache_flush
 
+#if !defined(CONFIG_CPU_V7)
+		/* This collides with some V7 IDs, preventing correct detection */
 		.word	0x00000000		@ old ARM ID
 		.word	0x0000f000
 		mov	pc, lr
@@ -774,6 +783,7 @@ proc_types:
  THUMB(		nop				)
 		mov	pc, lr
  THUMB(		nop				)
+#endif
 
 		.word	0x41007000		@ ARM7/710
 		.word	0xfff8fe00
diff --git a/arch/arm/common/Kconfig b/arch/arm/common/Kconfig
index 283fa1d8..271dd136 100644
--- a/arch/arm/common/Kconfig
+++ b/arch/arm/common/Kconfig
@@ -40,3 +40,53 @@ config SHARP_PARAM
 
 config SHARP_SCOOP
 	bool
+
+config FIQ_GLUE
+	bool
+	select FIQ
+
+config FIQ_DEBUGGER
+	bool "FIQ Mode Serial Debugger"
+	select FIQ
+	select FIQ_GLUE
+	default n
+	help
+	  The FIQ serial debugger can accept commands even when the
+	  kernel is unresponsive due to being stuck with interrupts
+	  disabled.
+
+
+config FIQ_DEBUGGER_NO_SLEEP
+	bool "Keep serial debugger active"
+	depends on FIQ_DEBUGGER
+	default n
+	help
+	  Enables the serial debugger at boot. Passing
+	  fiq_debugger.no_sleep on the kernel commandline will
+	  override this config option.
+
+config FIQ_DEBUGGER_WAKEUP_IRQ_ALWAYS_ON
+	bool "Don't disable wakeup IRQ when debugger is active"
+	depends on FIQ_DEBUGGER
+	default n
+	help
+	  Don't disable the wakeup irq when enabling the uart clock.  This will
+	  cause extra interrupts, but it makes the serial debugger usable with
+	  on some MSM radio builds that ignore the uart clock request in power
+	  collapse.
+
+config FIQ_DEBUGGER_CONSOLE
+	bool "Console on FIQ Serial Debugger port"
+	depends on FIQ_DEBUGGER
+	default n
+	help
+	  Enables a console so that printk messages are displayed on
+	  the debugger serial port as the occur.
+
+config FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE
+	bool "Put the FIQ debugger into console mode by default"
+	depends on FIQ_DEBUGGER_CONSOLE
+	default n
+	help
+	  If enabled, this puts the fiq debugger into console mode by default.
+	  Otherwise, the fiq debugger will start out in debug mode.
diff --git a/arch/arm/common/Makefile b/arch/arm/common/Makefile
index 215816f1..11670f9d 100644
--- a/arch/arm/common/Makefile
+++ b/arch/arm/common/Makefile
@@ -15,3 +15,5 @@ obj-$(CONFIG_ARCH_IXP2000)	+= uengine.o
 obj-$(CONFIG_ARCH_IXP23XX)	+= uengine.o
 obj-$(CONFIG_PCI_HOST_ITE8152)  += it8152.o
 obj-$(CONFIG_ARM_TIMER_SP804)	+= timer-sp.o
+obj-$(CONFIG_FIQ_GLUE)		+= fiq_glue.o fiq_glue_setup.o
+obj-$(CONFIG_FIQ_DEBUGGER)	+= fiq_debugger.o
diff --git a/arch/arm/common/gic.c b/arch/arm/common/gic.c
index aa526998..a8d1df3e 100644
--- a/arch/arm/common/gic.c
+++ b/arch/arm/common/gic.c
@@ -80,6 +80,7 @@ struct irq_chip gic_arch_extn = {
 	.irq_retrigger	= NULL,
 	.irq_set_type	= NULL,
 	.irq_set_wake	= NULL,
+	.irq_set_affinity = NULL,
 };
 
 #ifndef MAX_GIC_NR
@@ -245,6 +246,10 @@ static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
 	bit = 1 << (cpu_logical_map(cpu) + shift);
 
 	raw_spin_lock(&irq_controller_lock);
+
+	if (gic_arch_extn.irq_set_affinity)
+		gic_arch_extn.irq_set_affinity(d, mask_val, false);
+
 	val = readl_relaxed(reg) & ~mask;
 	writel_relaxed(val | bit, reg);
 	raw_spin_unlock(&irq_controller_lock);
@@ -375,6 +380,10 @@ static void __init gic_dist_init(struct gic_chip_data *gic)
 	for (i = 32; i < gic_irqs; i += 4)
 		writel_relaxed(0xa0a0a0a0, base + GIC_DIST_PRI + i * 4 / 4);
 
+#ifdef CONFIG_EOF_FC_WORKAROUND
+	writel_relaxed(0xa0a090a0, base + GIC_DIST_PRI + 0x48);
+#endif
+
 	/*
 	 * Disable all interrupts.  Leave the PPI and SGIs alone
 	 * as these enables are banked registers.
diff --git a/arch/arm/configs/goyawifi_pmos_minimal_defconfig b/arch/arm/configs/goyawifi_pmos_minimal_defconfig
new file mode 100644
index 00000000..1f1c1107
--- /dev/null
+++ b/arch/arm/configs/goyawifi_pmos_minimal_defconfig
@@ -0,0 +1,1702 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.4.5 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_LOCKBREAK=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_PROVIDES_UDELAY=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_NEED_MACH_IO_H=y
+CONFIG_NEED_MACH_MEMORY_H=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_FHANDLE=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_SPARSE_IRQ=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=19
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=1
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_CGITINFO=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+# CONFIG_BUG is not set
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_TRACEPOINTS=y
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+# CONFIG_MODULES is not set
+CONFIG_STOP_MACHINE=y
+# CONFIG_BLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+CONFIG_ARCH_MMP=y
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_MACH_TAVOREVB is not set
+CONFIG_PXA_SSP=y
+CONFIG_PXA_PANIC_FLUSH=y
+CONFIG_PXA_32KTIMER=y
+CONFIG_DUMP_REGS=y
+
+#
+# Marvell PXA168/910/MMP2 Implmentations
+#
+# CONFIG_MACH_ASPENITE is not set
+# CONFIG_MACH_ZYLONITE2 is not set
+# CONFIG_MACH_AVENGERS_LITE is not set
+# CONFIG_MACH_TTC_DKB is not set
+# CONFIG_MACH_BROWNSTONE is not set
+# CONFIG_MACH_FLINT is not set
+# CONFIG_MACH_MARVELL_JASPER is not set
+# CONFIG_MACH_TETON_BGA is not set
+# CONFIG_MACH_GPLUGD is not set
+# CONFIG_MACH_YELLOWSTONE is not set
+# CONFIG_MACH_MMP_DT is not set
+# CONFIG_MACH_MMP2_DT is not set
+# CONFIG_MACH_EMEIDKB is not set
+# CONFIG_MACH_ARUBA_TD is not set
+# CONFIG_MACH_WARUBA is not set
+# CONFIG_MACH_HARRISON is not set
+# CONFIG_MACH_LT02 is not set
+# CONFIG_MACH_HELANDKB is not set
+# CONFIG_MACH_DELOS3GVIA is not set
+# CONFIG_MACH_HELANDELOS is not set
+# CONFIG_MACH_CS05 is not set
+# CONFIG_CS05_CAMERA_REV02 is not set
+# CONFIG_MACH_WILCOX is not set
+# CONFIG_MACH_DEGAS is not set
+# CONFIG_MACH_CT01 is not set
+# CONFIG_MACH_WILCOX_CMCC is not set
+# CONFIG_MACH_CS02 is not set
+# CONFIG_MACH_GOLDEN is not set
+CONFIG_MACH_GOYA=y
+# CONFIG_MACH_GOYA_USA is not set
+# CONFIG_MACH_BAFFIN is not set
+# CONFIG_MACH_BAFFINQ is not set
+# CONFIG_MACH_BAFFINQ_CMCC is not set
+# CONFIG_FAKE_SYSTEMOFF is not set
+# CONFIG_MACH_EDEN_FPGA is not set
+CONFIG_CPU_PXA988=y
+CONFIG_CPU_CA9MP=y
+CONFIG_EOF_FC_WORKAROUND=y
+CONFIG_DISP_DFC=y
+# CONFIG_CORE_1248 is not set
+CONFIG_CORESIGHT_SUPPORT=y
+# CONFIG_CORESIGHT_TRACE_SUPPORT is not set
+# CONFIG_APB_LOCALTIMER is not set
+# CONFIG_TZ_HYPERVISOR is not set
+CONFIG_BOOST_SUPPORT=y
+# CONFIG_RECOVERY_KERNEL is not set
+# CONFIG_MMP_ORIGINAL_POLICY is not set
+CONFIG_STAND_ALONE_POLICY=y
+# CONFIG_NO_HOTPLUG_POLICY is not set
+# CONFIG_SEC_MODEM is not set
+
+#
+# Debugging Feature
+#
+# CONFIG_SEC_DEBUG is not set
+
+#
+# Samsung TN Power Management Options
+#
+# CONFIG_SEC_PM is not set
+# CONFIG_SEC_THERMISTOR is not set
+# CONFIG_NFC_PN544 is not set
+# CONFIG_NFC_PN547 is not set
+# CONFIG_GOYA_BD_00 is not set
+# CONFIG_GOYA_BD_01 is not set
+# CONFIG_GOYA_WIFI is not set
+# CONFIG_CS05_BD_00 is not set
+# CONFIG_CS05_BD_02 is not set
+
+#
+# System MMU
+#
+CONFIG_PLAT_PXA=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+CONFIG_ARM_THUMBEE=y
+# CONFIG_SWP_EMULATE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_CACHE_L2X0_PREFETCH=y
+CONFIG_CACHE_L2X0_PREFETCH_OFFSET=7
+# CONFIG_CACHE_TAUROS2 is not set
+# CONFIG_CACHE_TAUROS3 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_NR_BANKS=8
+CONFIG_CPU_HAS_PMU=y
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_PL310_ERRATA_727915 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_PL310_ERRATA_753970 is not set
+CONFIG_ARM_ERRATA_754322=y
+# CONFIG_ARM_ERRATA_754327 is not set
+CONFIG_ARM_ERRATA_764369=y
+# CONFIG_PL310_ERRATA_769419 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+CONFIG_ARM_GIC=y
+# CONFIG_FIQ_DEBUGGER is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+# CONFIG_SCHED_MC is not set
+# CONFIG_SCHED_SMT is not set
+CONFIG_HAVE_ARM_SCU=y
+# CONFIG_ARM_ARCH_TIMER is not set
+CONFIG_HAVE_ARM_TWD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_TEXT_OFFSET_OVERRIDE=y
+CONFIG_TEXT_OFFSET=0x00108000
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+CONFIG_LOCAL_TIMERS=y
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=128
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART=y
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="initrd=0x01100000,1m rw androidboot.console=ttyS1 console=ttyS1,115200 panic_debug"
+# CONFIG_CMDLINE_FROM_BOOTLOADER is not set
+CONFIG_CMDLINE_EXTEND=y
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+
+#
+# ARM CPU frequency scaling drivers
+#
+# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS4X12_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS5250_CPUFREQ is not set
+CONFIG_ARM_PXA988_CPUFREQ=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+CONFIG_GPU_RESERVE_MEM=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_WAKELOCK=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_AUTOSLEEP=y
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+# CONFIG_SUSPEND_TIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+# CONFIG_KERNEL_DEBUG_SEC is not set
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_IRQ=y
+# CONFIG_SYNC is not set
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_CMA=y
+CONFIG_CMA_DEBUG=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=128
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=5
+CONFIG_CMA_AREAS=7
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+CONFIG_UID_STAT=y
+# CONFIG_BMP085 is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_SM5502_MUIC is not set
+# CONFIG_TC35876X is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_MPU_SENSORS_TIMERIRQ is not set
+# CONFIG_INV_SENSORS is not set
+# CONFIG_USE_DPP2601 is not set
+# CONFIG_QUICKLOGIC_BRIDGE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+CONFIG_INPUT_KEYRESET=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_PXA27x is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_TC360 is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_FT5306 is not set
+# CONFIG_TOUCHSCREEN_GT9XX is not set
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_VNC is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_MMS136_TS is not set
+# CONFIG_TOUCHSCREEN_MXT224S is not set
+# CONFIG_TOUCHSCREEN_BT432_TS is not set
+# CONFIG_TOUCHSCREEN_BT531_TS is not set
+CONFIG_TOUCHSCREEN_BT532_TS=y
+CONFIG_TOUCHSCREEN_BT532_TS_ORIENTATION=0
+# CONFIG_TOUCHSCREEN_CYPRESS_TMA46X is not set
+# CONFIG_TOUCHSCREEN_MELFAS_MMS144 is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_88PM822_ONKEY=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_KEYCHORD is not set
+# CONFIG_INPUT_KXTJ9 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_PXA=y
+CONFIG_SERIAL_PXA_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_PXA9XX_ACIPC=y
+CONFIG_USB_88PM822=y
+CONFIG_MXDCMMB=y
+# CONFIG_MXDCMMB_DEBUG is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_SMBUS is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+CONFIG_I2C_GPIO=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+CONFIG_I2C_PXA=y
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_PXA_SLAVE is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_SENSORS_CORE is not set
+# CONFIG_SENSORS_GP2A002S is not set
+# CONFIG_SENSORS_GP2A030 is not set
+# CONFIG_SENSORS_BMA2X2 is not set
+# CONFIG_SENSORS_BMM050 is not set
+# CONFIG_INPUT_BMA2x2_ACC_ALERT_INT is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SENSORS_SYMLINK_CORE is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_PXA2XX=y
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+CONFIG_GPIO_PXA=y
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+CONFIG_SEC_GPIO_DVS=y
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+CONFIG_BATTERY_SAMSUNG=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_SPA is not set
+# CONFIG_STC3105_FUELGAUGE is not set
+# CONFIG_MAX17043_FUELGAUGE is not set
+# CONFIG_BQ27425_FUELGAUGE is not set
+# CONFIG_SS6000_CHARGER is not set
+# CONFIG_STC3115_FUELGAUGE is not set
+# CONFIG_BQ24157_CHARGER is not set
+# CONFIG_FSA9480_MICROUSB is not set
+# CONFIG_FSA9480_MUIC_PXA_USB_NOTIFY is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_BATTERY_ANDROID is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_T7 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_CHARGER_ISL9226 is not set
+# CONFIG_CHARGER_SMB358 is not set
+# CONFIG_I2C_RT9455 is not set
+# CONFIG_SAMSUNG_LPM_MODE is not set
+# CONFIG_STBC_SAMSUNG is not set
+CONFIG_FUELGAUGE_MFD=y
+# CONFIG_FUELGAUGE_DUMMY is not set
+# CONFIG_FUELGAUGE_MAX17042 is not set
+# CONFIG_FUELGAUGE_MAX17048 is not set
+# CONFIG_FUELGAUGE_D2199 is not set
+# CONFIG_FUELGAUGE_MAX17050 is not set
+# CONFIG_FUELGAUGE_PM8917 is not set
+# CONFIG_FUELGAUGE_STC3115 is not set
+# CONFIG_FUELGAUGE_RT5033 is not set
+CONFIG_FUELGAUGE_88PM822=y
+# CONFIG_CHARGER_MFD is not set
+# CONFIG_CHARGER_DUMMY is not set
+# CONFIG_CHARGER_SMB328 is not set
+# CONFIG_CHARGER_PM8917 is not set
+# CONFIG_CHARGER_BQ24157 is not set
+# CONFIG_CHARGER_BQ24190 is not set
+# CONFIG_CHARGER_BQ24191 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_CHARGER_NCP1851 is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_D2199 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_88PM830 is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+CONFIG_MFD_88PM822=y
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_PXA_DS1WM is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_RT8973=y
+CONFIG_RTMUSC_INT_GPIO_NUMBER=93
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_STBC is not set
+# CONFIG_MFD_RT5033 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+# CONFIG_REGULATOR_88PG870 is not set
+CONFIG_REGULATOR_88PM822=y
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+CONFIG_ION=y
+CONFIG_ION_PXA=y
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_PXA168=y
+CONFIG_PXA688_PHY=y
+CONFIG_PXA688_MISC=y
+# CONFIG_LDI_SUPPORT_MDNIE is not set
+# CONFIG_LCD_ESD_RECOVERY is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_EXYNOS_VIDEO is not set
+# CONFIG_MMP_DISP is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+# CONFIG_LCD_TEMPERATURE_COMPENSATION is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_KTD253 is not set
+# CONFIG_BACKLIGHT_KTD3102 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_SWITCH is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_DRV_88PM822=y
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_SA1100=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=y
+# CONFIG_UIO_PDRV is not set
+# CONFIG_UIO_PDRV_GENIRQ is not set
+CONFIG_UIO_CODA7542=y
+CONFIG_UIO_MVISP=y
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+# CONFIG_ECHO is not set
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+CONFIG_IIO_SW_RING=y
+CONFIG_IIO_KFIFO_BUF=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
+
+#
+# Accelerometers
+#
+# CONFIG_ADIS16201 is not set
+# CONFIG_ADIS16203 is not set
+# CONFIG_ADIS16204 is not set
+# CONFIG_ADIS16209 is not set
+# CONFIG_ADIS16220 is not set
+# CONFIG_ADIS16240 is not set
+# CONFIG_KXSD9 is not set
+# CONFIG_LIS3L02DQ is not set
+# CONFIG_SCA3000 is not set
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7291 is not set
+# CONFIG_AD7298 is not set
+# CONFIG_AD7606 is not set
+# CONFIG_AD799X is not set
+# CONFIG_AD7476 is not set
+# CONFIG_AD7887 is not set
+# CONFIG_AD7780 is not set
+# CONFIG_AD7793 is not set
+# CONFIG_AD7816 is not set
+# CONFIG_AD7192 is not set
+# CONFIG_ADT7310 is not set
+# CONFIG_ADT7410 is not set
+# CONFIG_AD7280 is not set
+# CONFIG_MAX1363 is not set
+
+#
+# Analog digital bi-direction converters
+#
+# CONFIG_ADT7316 is not set
+
+#
+# Capacitance to digital converters
+#
+# CONFIG_AD7150 is not set
+# CONFIG_AD7152 is not set
+# CONFIG_AD7746 is not set
+
+#
+# Digital to analog converters
+#
+# CONFIG_AD5064 is not set
+# CONFIG_AD5360 is not set
+# CONFIG_AD5380 is not set
+# CONFIG_AD5421 is not set
+# CONFIG_AD5624R_SPI is not set
+# CONFIG_AD5446 is not set
+# CONFIG_AD5504 is not set
+# CONFIG_AD5764 is not set
+# CONFIG_AD5791 is not set
+# CONFIG_AD5686 is not set
+# CONFIG_MAX517 is not set
+
+#
+# Direct Digital Synthesis
+#
+# CONFIG_AD5930 is not set
+# CONFIG_AD9832 is not set
+# CONFIG_AD9834 is not set
+# CONFIG_AD9850 is not set
+# CONFIG_AD9852 is not set
+# CONFIG_AD9910 is not set
+# CONFIG_AD9951 is not set
+
+#
+# Digital gyroscope sensors
+#
+# CONFIG_ADIS16060 is not set
+# CONFIG_ADIS16080 is not set
+# CONFIG_ADIS16130 is not set
+# CONFIG_ADIS16260 is not set
+# CONFIG_ADXRS450 is not set
+
+#
+# Network Analyzer, Impedance Converters
+#
+# CONFIG_AD5933 is not set
+
+#
+# Inertial measurement units
+#
+# CONFIG_ADIS16400 is not set
+# CONFIG_INV_MPU_IIO is not set
+
+#
+# Light sensors
+#
+# CONFIG_SENSORS_ISL29018 is not set
+# CONFIG_SENSORS_TSL2563 is not set
+# CONFIG_TSL2583 is not set
+
+#
+# Magnetometer sensors
+#
+# CONFIG_SENSORS_HMC5843 is not set
+CONFIG_INV_MMC328X_IIO=y
+
+#
+# Active energy metering IC
+#
+# CONFIG_ADE7753 is not set
+# CONFIG_ADE7754 is not set
+# CONFIG_ADE7758 is not set
+# CONFIG_ADE7759 is not set
+# CONFIG_ADE7854 is not set
+
+#
+# Resolver to digital converters
+#
+# CONFIG_AD2S90 is not set
+# CONFIG_AD2S1200 is not set
+# CONFIG_AD2S1210 is not set
+
+#
+# Triggers - standalone
+#
+# CONFIG_IIO_PERIODIC_RTC_TRIGGER is not set
+# CONFIG_IIO_GPIO_TRIGGER is not set
+# CONFIG_IIO_SYSFS_TRIGGER is not set
+# CONFIG_IIO_SIMPLE_DUMMY is not set
+CONFIG_ZSMALLOC=y
+# CONFIG_FB_SM7XX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_PHONE is not set
+CONFIG_CLKDEV_LOOKUP=y
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Remoteproc drivers (EXPERIMENTAL)
+#
+
+#
+# Rpmsg drivers (EXPERIMENTAL)
+#
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_POWERSAVE=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_DEVFREQ_GOV_THROUGHPUT=y
+
+#
+# DEVFREQ Drivers
+#
+CONFIG_VPU_DEVFREQ=y
+CONFIG_DDR_DEVFREQ=y
+# CONFIG_DDR_DEVFREQ_GOV_THROUGHPUT is not set
+CONFIG_DDR_DEVFREQ_GOV_ONDEMAND=y
+# CONFIG_DDR_DEVFREQ_GOV_USERSPACE is not set
+
+#
+# File systems
+#
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_FILE_LOCKING is not set
+# CONFIG_FSNOTIFY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_PRINTK_CPU_ID=y
+CONFIG_PRINTK_PID=y
+CONFIG_PRINTK_COMM=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_LOCKUP_DETECTOR=y
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_SMP_HARDLOCKUP_DETECTOR=y
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=1
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=1
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=1
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_DEBUG_KMEMLEAK=y
+CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE=1000
+CONFIG_DEBUG_KMEMLEAK_DEFAULT_OFF=y
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_CPU_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_EVENT_POWER_TRACING_DEPRECATED=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+CONFIG_DYNAMIC_DEBUG=y
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+CONFIG_REGDUMP=y
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_RODATA is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Samsung Rooting Restriction Feature
+#
+# CONFIG_SEC_RESTRICT_ROOTING is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+# CONFIG_CRYPTO is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
+# CONFIG_SND_AUDIODOCK_SWITCH is not set
diff --git a/arch/arm/include/asm/assembler.h b/arch/arm/include/asm/assembler.h
index 03fb9362..70d540ae 100644
--- a/arch/arm/include/asm/assembler.h
+++ b/arch/arm/include/asm/assembler.h
@@ -210,11 +210,19 @@
 	.macro	smp_dmb mode
 #ifdef CONFIG_SMP
 #if __LINUX_ARM_ARCH__ >= 7
+#ifdef CONFIG_PJ4B_ERRATA_6359
+	.ifeqs "\mode","arm"
+	ALT_SMP(dsb)
+	.else
+	ALT_SMP(W(dsb))
+	.endif
+#else
 	.ifeqs "\mode","arm"
 	ALT_SMP(dmb)
 	.else
 	ALT_SMP(W(dmb))
 	.endif
+#endif
 #elif __LINUX_ARM_ARCH__ == 6
 	ALT_SMP(mcr	p15, 0, r0, c7, c10, 5)	@ dmb
 #else
@@ -320,4 +328,12 @@
 	.size \name , . - \name
 	.endm
 
+	.macro check_uaccess, addr:req, size:req, limit:req, tmp:req, bad:req
+#ifndef CONFIG_CPU_USE_DOMAINS
+	adds	\tmp, \addr, #\size - 1
+	sbcccs	\tmp, \tmp, \limit
+	bcs	\bad
+#endif
+	.endm
+
 #endif /* __ASM_ASSEMBLER_H__ */
diff --git a/arch/arm/include/asm/barrier.h b/arch/arm/include/asm/barrier.h
index 05112380..0f66f61e 100644
--- a/arch/arm/include/asm/barrier.h
+++ b/arch/arm/include/asm/barrier.h
@@ -16,7 +16,11 @@
 #if __LINUX_ARM_ARCH__ >= 7
 #define isb() __asm__ __volatile__ ("isb" : : : "memory")
 #define dsb() __asm__ __volatile__ ("dsb" : : : "memory")
+#ifdef CONFIG_PJ4B_ERRATA_6359
+#define dmb() __asm__ __volatile__ ("dsb" : : : "memory")
+#else
 #define dmb() __asm__ __volatile__ ("dmb" : : : "memory")
+#endif
 #elif defined(CONFIG_CPU_XSC3) || __LINUX_ARM_ARCH__ == 6
 #define isb() __asm__ __volatile__ ("mcr p15, 0, %0, c7, c5, 4" \
 				    : : "r" (0) : "memory")
diff --git a/arch/arm/include/asm/cache.h b/arch/arm/include/asm/cache.h
index 75fe66bc..47fef8f8 100644
--- a/arch/arm/include/asm/cache.h
+++ b/arch/arm/include/asm/cache.h
@@ -14,7 +14,11 @@
  * cache before the transfer is done, causing old data to be seen by
  * the CPU.
  */
+#if defined(CACHE_TAUROS2) && !defined(CONFIG_CACHE_TAUROS2_PREFETCH_OFF)
+#define ARCH_DMA_MINALIGN	(L1_CACHE_BYTES << 1)
+#else
 #define ARCH_DMA_MINALIGN	L1_CACHE_BYTES
+#endif
 
 /*
  * With EABI on ARMv5 and above we must have 64-bit aligned slab pointers.
diff --git a/arch/arm/include/asm/cacheflush.h b/arch/arm/include/asm/cacheflush.h
index 1252a267..2246bdb3 100644
--- a/arch/arm/include/asm/cacheflush.h
+++ b/arch/arm/include/asm/cacheflush.h
@@ -16,6 +16,7 @@
 #include <asm/shmparam.h>
 #include <asm/cachetype.h>
 #include <asm/outercache.h>
+#include <asm/rodata.h>
 
 #define CACHE_COLOUR(vaddr)	((vaddr & (SHMLBA - 1)) >> PAGE_SHIFT)
 
@@ -49,6 +50,13 @@
  *
  *		Unconditionally clean and invalidate the entire cache.
  *
+ *     flush_kern_louis()
+ *
+ *             Flush data cache levels up to the level of unification
+ *             inner shareable and invalidate the I-cache.
+ *             Only needed from v7 onwards, falls back to flush_cache_all()
+ *             for all other processor versions.
+ *
  *	flush_user_all()
  *
  *		Clean and invalidate all user space cache entries
@@ -97,11 +105,12 @@
 struct cpu_cache_fns {
 	void (*flush_icache_all)(void);
 	void (*flush_kern_all)(void);
+	void (*flush_kern_louis)(void);
 	void (*flush_user_all)(void);
 	void (*flush_user_range)(unsigned long, unsigned long, unsigned int);
 
 	void (*coherent_kern_range)(unsigned long, unsigned long);
-	void (*coherent_user_range)(unsigned long, unsigned long);
+	int  (*coherent_user_range)(unsigned long, unsigned long);
 	void (*flush_kern_dcache_area)(void *, size_t);
 
 	void (*dma_map_area)(const void *, size_t, int);
@@ -119,6 +128,7 @@ extern struct cpu_cache_fns cpu_cache;
 
 #define __cpuc_flush_icache_all		cpu_cache.flush_icache_all
 #define __cpuc_flush_kern_all		cpu_cache.flush_kern_all
+#define __cpuc_flush_kern_louis		cpu_cache.flush_kern_louis
 #define __cpuc_flush_user_all		cpu_cache.flush_user_all
 #define __cpuc_flush_user_range		cpu_cache.flush_user_range
 #define __cpuc_coherent_kern_range	cpu_cache.coherent_kern_range
@@ -139,10 +149,11 @@ extern struct cpu_cache_fns cpu_cache;
 
 extern void __cpuc_flush_icache_all(void);
 extern void __cpuc_flush_kern_all(void);
+extern void __cpuc_flush_kern_louis(void);
 extern void __cpuc_flush_user_all(void);
 extern void __cpuc_flush_user_range(unsigned long, unsigned long, unsigned int);
 extern void __cpuc_coherent_kern_range(unsigned long, unsigned long);
-extern void __cpuc_coherent_user_range(unsigned long, unsigned long);
+extern int  __cpuc_coherent_user_range(unsigned long, unsigned long);
 extern void __cpuc_flush_dcache_area(void *, size_t);
 
 /*
@@ -204,6 +215,11 @@ static inline void __flush_icache_all(void)
 	__flush_icache_preferred();
 }
 
+/*
+ * Flush caches up to Level of Unification Inner Shareable
+ */
+#define flush_cache_louis()		__cpuc_flush_kern_louis()
+
 #define flush_cache_all()		__cpuc_flush_kern_all()
 
 static inline void vivt_flush_cache_mm(struct mm_struct *mm)
diff --git a/arch/arm/include/asm/delay.h b/arch/arm/include/asm/delay.h
index b2deda18..57f1fa0e 100644
--- a/arch/arm/include/asm/delay.h
+++ b/arch/arm/include/asm/delay.h
@@ -8,6 +8,9 @@
 
 #include <asm/param.h>	/* HZ */
 
+#ifdef CONFIG_ARCH_PROVIDES_UDELAY
+#include <mach/delay.h>
+#else
 extern void __delay(int loops);
 
 /*
@@ -40,5 +43,6 @@ extern void __const_udelay(unsigned long);
 			__const_udelay((n) * ((2199023U*HZ)>>11))) :	\
 	  __udelay(n))
 
+#endif /* defined(ARCH_PROVIDES_UDELAY) */
 #endif /* defined(_ARM_DELAY_H) */
 
diff --git a/arch/arm/include/asm/device.h b/arch/arm/include/asm/device.h
index 7aa36800..3b1b8ddd 100644
--- a/arch/arm/include/asm/device.h
+++ b/arch/arm/include/asm/device.h
@@ -16,11 +16,15 @@ struct dev_archdata {
 };
 
 struct omap_device;
+struct mmp_device;
 
 struct pdev_archdata {
 #ifdef CONFIG_ARCH_OMAP
 	struct omap_device *od;
 #endif
+#ifdef CONFIG_ARCH_MMP
+	struct mmp_device *md;
+#endif
 };
 
 #endif
diff --git a/arch/arm/include/asm/dma-contiguous.h b/arch/arm/include/asm/dma-contiguous.h
new file mode 100644
index 00000000..3ed37b4d
--- /dev/null
+++ b/arch/arm/include/asm/dma-contiguous.h
@@ -0,0 +1,15 @@
+#ifndef ASMARM_DMA_CONTIGUOUS_H
+#define ASMARM_DMA_CONTIGUOUS_H
+
+#ifdef __KERNEL__
+#ifdef CONFIG_CMA
+
+#include <linux/types.h>
+#include <asm-generic/dma-contiguous.h>
+
+void dma_contiguous_early_fixup(phys_addr_t base, unsigned long size);
+
+#endif
+#endif
+
+#endif
diff --git a/arch/arm/include/asm/fpstate.h b/arch/arm/include/asm/fpstate.h
index 3ad4c10d..3140981f 100644
--- a/arch/arm/include/asm/fpstate.h
+++ b/arch/arm/include/asm/fpstate.h
@@ -68,6 +68,9 @@ struct fp_soft_struct {
 
 struct iwmmxt_struct {
 	unsigned int save[IWMMXT_SIZE / sizeof(unsigned int)];
+#ifdef CONFIG_SMP
+	unsigned int cpu;
+#endif
 };
 
 union fp_state {
diff --git a/arch/arm/include/asm/glue-cache.h b/arch/arm/include/asm/glue-cache.h
index 7e308743..2d6a7de8 100644
--- a/arch/arm/include/asm/glue-cache.h
+++ b/arch/arm/include/asm/glue-cache.h
@@ -132,6 +132,7 @@
 #ifndef MULTI_CACHE
 #define __cpuc_flush_icache_all		__glue(_CACHE,_flush_icache_all)
 #define __cpuc_flush_kern_all		__glue(_CACHE,_flush_kern_cache_all)
+#define __cpuc_flush_kern_louis		__glue(_CACHE,_flush_kern_cache_louis)
 #define __cpuc_flush_user_all		__glue(_CACHE,_flush_user_cache_all)
 #define __cpuc_flush_user_range		__glue(_CACHE,_flush_user_cache_range)
 #define __cpuc_coherent_kern_range	__glue(_CACHE,_coherent_kern_range)
diff --git a/arch/arm/include/asm/hardirq.h b/arch/arm/include/asm/hardirq.h
index 436e60b2..3d7351c8 100644
--- a/arch/arm/include/asm/hardirq.h
+++ b/arch/arm/include/asm/hardirq.h
@@ -5,7 +5,7 @@
 #include <linux/threads.h>
 #include <asm/irq.h>
 
-#define NR_IPI	5
+#define NR_IPI	7
 
 typedef struct {
 	unsigned int __softirq_pending;
diff --git a/arch/arm/include/asm/hardware/cache-l2x0.h b/arch/arm/include/asm/hardware/cache-l2x0.h
index c4c87bc1..86532e6b 100644
--- a/arch/arm/include/asm/hardware/cache-l2x0.h
+++ b/arch/arm/include/asm/hardware/cache-l2x0.h
@@ -66,6 +66,7 @@
 #define   L2X0_STNDBY_MODE_EN		(1 << 0)
 
 /* Registers shifts and masks */
+#define L2X0_CACHE_ID_REV_MASK		(0x3f)
 #define L2X0_CACHE_ID_PART_MASK		(0xf << 6)
 #define L2X0_CACHE_ID_PART_L210		(1 << 6)
 #define L2X0_CACHE_ID_PART_L310		(3 << 6)
@@ -102,6 +103,8 @@
 
 #define L2X0_ADDR_FILTER_EN		1
 
+#define REV_PL310_R2P0				4
+
 #ifndef __ASSEMBLY__
 extern void __init l2x0_init(void __iomem *base, u32 aux_val, u32 aux_mask);
 #if defined(CONFIG_CACHE_L2X0) && defined(CONFIG_OF)
@@ -126,9 +129,12 @@ struct l2x0_regs {
 	unsigned long filter_end;
 	unsigned long prefetch_ctrl;
 	unsigned long pwr_ctrl;
+	/* If L2 is global disabled, we need also save/restore it */
+	unsigned long ctrl;
 };
 
 extern struct l2x0_regs l2x0_saved_regs;
+extern void pl310_suspend(void);
 
 #endif /* __ASSEMBLY__ */
 
diff --git a/arch/arm/include/asm/irq.h b/arch/arm/include/asm/irq.h
index 35c21c37..3e0857a6 100644
--- a/arch/arm/include/asm/irq.h
+++ b/arch/arm/include/asm/irq.h
@@ -30,6 +30,9 @@ extern void asm_do_IRQ(unsigned int, struct pt_regs *);
 void handle_IRQ(unsigned int, struct pt_regs *);
 void init_IRQ(void);
 
+void arch_trigger_all_cpu_backtrace(void);
+#define arch_trigger_all_cpu_backtrace arch_trigger_all_cpu_backtrace
+
 #endif
 
 #endif
diff --git a/arch/arm/include/asm/mach/map.h b/arch/arm/include/asm/mach/map.h
index b36f3654..a6efcdd6 100644
--- a/arch/arm/include/asm/mach/map.h
+++ b/arch/arm/include/asm/mach/map.h
@@ -30,6 +30,7 @@ struct map_desc {
 #define MT_MEMORY_DTCM		12
 #define MT_MEMORY_ITCM		13
 #define MT_MEMORY_SO		14
+#define MT_MEMORY_DMA_READY	15
 
 #ifdef CONFIG_MMU
 extern void iotable_init(struct map_desc *, int);
diff --git a/arch/arm/include/asm/memory.h b/arch/arm/include/asm/memory.h
index fcb57574..3e3b095d 100644
--- a/arch/arm/include/asm/memory.h
+++ b/arch/arm/include/asm/memory.h
@@ -49,8 +49,15 @@
  * and PAGE_OFFSET - it must be within 32MB of the kernel text.
  */
 #ifndef CONFIG_THUMB2_KERNEL
+#if !defined(CONFIG_TEXT_OFFSET) || (CONFIG_TEXT_OFFSET < 8*1024*1024)
 #define MODULES_VADDR		(PAGE_OFFSET - 16*1024*1024)
 #else
+/* TEXT_OFFSET does not allow to use 16MB modules area as ARM32
+	branches to kernel may go out of range
+	taking into account the kernel .text size */
+#define MODULES_VADDR		(PAGE_OFFSET - 8*1024*1024)
+#endif
+#else
 /* smaller range for Thumb-2 symbols relocation (2^24)*/
 #define MODULES_VADDR		(PAGE_OFFSET - 8*1024*1024)
 #endif
diff --git a/arch/arm/include/asm/mmu.h b/arch/arm/include/asm/mmu.h
index b8e580a2..14965658 100644
--- a/arch/arm/include/asm/mmu.h
+++ b/arch/arm/include/asm/mmu.h
@@ -34,11 +34,4 @@ typedef struct {
 
 #endif
 
-/*
- * switch_mm() may do a full cache flush over the context switch,
- * so enable interrupts over the context switch to avoid high
- * latency.
- */
-#define __ARCH_WANT_INTERRUPTS_ON_CTXSW
-
 #endif
diff --git a/arch/arm/include/asm/mmu_context.h b/arch/arm/include/asm/mmu_context.h
index a0b3cac0..0306bc64 100644
--- a/arch/arm/include/asm/mmu_context.h
+++ b/arch/arm/include/asm/mmu_context.h
@@ -43,45 +43,104 @@ void __check_kvm_seq(struct mm_struct *mm);
 #define ASID_FIRST_VERSION	(1 << ASID_BITS)
 
 extern unsigned int cpu_last_asid;
-#ifdef CONFIG_SMP
-DECLARE_PER_CPU(struct mm_struct *, current_mm);
-#endif
 
 void __init_new_context(struct task_struct *tsk, struct mm_struct *mm);
 void __new_context(struct mm_struct *mm);
+void cpu_set_reserved_ttbr0(void);
 
-static inline void check_context(struct mm_struct *mm)
+static inline void switch_new_context(struct mm_struct *mm)
 {
-	/*
-	 * This code is executed with interrupts enabled. Therefore,
-	 * mm->context.id cannot be updated to the latest ASID version
-	 * on a different CPU (and condition below not triggered)
-	 * without first getting an IPI to reset the context. The
-	 * alternative is to take a read_lock on mm->context.id_lock
-	 * (after changing its type to rwlock_t).
-	 */
-	if (unlikely((mm->context.id ^ cpu_last_asid) >> ASID_BITS))
-		__new_context(mm);
+	unsigned long flags;
+
+	__new_context(mm);
+
+	local_irq_save(flags);
+	cpu_switch_mm(mm->pgd, mm);
+	local_irq_restore(flags);
+}
 
+static inline void check_and_switch_context(struct mm_struct *mm,
+					    struct task_struct *tsk)
+{
 	if (unlikely(mm->context.kvm_seq != init_mm.context.kvm_seq))
 		__check_kvm_seq(mm);
+
+	/*
+	 * Required during context switch to avoid speculative page table
+	 * walking with the wrong TTBR.
+	 */
+	cpu_set_reserved_ttbr0();
+
+	if (!((mm->context.id ^ cpu_last_asid) >> ASID_BITS))
+		/*
+		 * The ASID is from the current generation, just switch to the
+		 * new pgd. This condition is only true for calls from
+		 * context_switch() and interrupts are already disabled.
+		 */
+		cpu_switch_mm(mm->pgd, mm);
+	else if (irqs_disabled())
+		/*
+		 * Defer the new ASID allocation until after the context
+		 * switch critical region since __new_context() cannot be
+		 * called with interrupts disabled (it sends IPIs).
+		 */
+		set_ti_thread_flag(task_thread_info(tsk), TIF_SWITCH_MM);
+	else
+		/*
+		 * That is a direct call to switch_mm() or activate_mm() with
+		 * interrupts enabled and a new context.
+		 */
+		switch_new_context(mm);
 }
 
 #define init_new_context(tsk,mm)	(__init_new_context(tsk,mm),0)
 
-#else
-
-static inline void check_context(struct mm_struct *mm)
+#define finish_arch_post_lock_switch \
+	finish_arch_post_lock_switch
+static inline void finish_arch_post_lock_switch(void)
 {
+	if (test_and_clear_thread_flag(TIF_SWITCH_MM))
+		switch_new_context(current->mm);
+}
+
+#else	/* !CONFIG_CPU_HAS_ASID */
+
 #ifdef CONFIG_MMU
+
+static inline void check_and_switch_context(struct mm_struct *mm,
+					    struct task_struct *tsk)
+{
 	if (unlikely(mm->context.kvm_seq != init_mm.context.kvm_seq))
 		__check_kvm_seq(mm);
-#endif
+
+	if (irqs_disabled())
+		/*
+		 * cpu_switch_mm() needs to flush the VIVT caches. To avoid
+		 * high interrupt latencies, defer the call and continue
+		 * running with the old mm. Since we only support UP systems
+		 * on non-ASID CPUs, the old mm will remain valid until the
+		 * finish_arch_post_lock_switch() call.
+		 */
+		set_ti_thread_flag(task_thread_info(tsk), TIF_SWITCH_MM);
+	else
+		cpu_switch_mm(mm->pgd, mm);
 }
 
+#define finish_arch_post_lock_switch \
+	finish_arch_post_lock_switch
+static inline void finish_arch_post_lock_switch(void)
+{
+	if (test_and_clear_thread_flag(TIF_SWITCH_MM)) {
+		struct mm_struct *mm = current->mm;
+		cpu_switch_mm(mm->pgd, mm);
+	}
+}
+
+#endif	/* CONFIG_MMU */
+
 #define init_new_context(tsk,mm)	0
 
-#endif
+#endif	/* CONFIG_CPU_HAS_ASID */
 
 #define destroy_context(mm)		do { } while(0)
 
@@ -119,12 +178,7 @@ switch_mm(struct mm_struct *prev, struct mm_struct *next,
 		__flush_icache_all();
 #endif
 	if (!cpumask_test_and_set_cpu(cpu, mm_cpumask(next)) || prev != next) {
-#ifdef CONFIG_SMP
-		struct mm_struct **crt_mm = &per_cpu(current_mm, cpu);
-		*crt_mm = next;
-#endif
-		check_context(next);
-		cpu_switch_mm(next->pgd, next);
+		check_and_switch_context(next, tsk);
 		if (cache_is_vivt())
 			cpumask_clear_cpu(cpu, mm_cpumask(prev));
 	}
diff --git a/arch/arm/include/asm/mutex.h b/arch/arm/include/asm/mutex.h
index 93226cf2..b1479fd0 100644
--- a/arch/arm/include/asm/mutex.h
+++ b/arch/arm/include/asm/mutex.h
@@ -7,121 +7,10 @@
  */
 #ifndef _ASM_MUTEX_H
 #define _ASM_MUTEX_H
-
-#if __LINUX_ARM_ARCH__ < 6
-/* On pre-ARMv6 hardware the swp based implementation is the most efficient. */
-# include <asm-generic/mutex-xchg.h>
-#else
-
 /*
- * Attempting to lock a mutex on ARMv6+ can be done with a bastardized
- * atomic decrement (it is not a reliable atomic decrement but it satisfies
- * the defined semantics for our purpose, while being smaller and faster
- * than a real atomic decrement or atomic swap.  The idea is to attempt
- * decrementing the lock value only once.  If once decremented it isn't zero,
- * or if its store-back fails due to a dispute on the exclusive store, we
- * simply bail out immediately through the slow path where the lock will be
- * reattempted until it succeeds.
+ * On pre-ARMv6 hardware this results in a swp-based implementation,
+ * which is the most efficient. For ARMv6+, we emit a pair of exclusive
+ * accesses instead.
  */
-static inline void
-__mutex_fastpath_lock(atomic_t *count, void (*fail_fn)(atomic_t *))
-{
-	int __ex_flag, __res;
-
-	__asm__ (
-
-		"ldrex	%0, [%2]	\n\t"
-		"sub	%0, %0, #1	\n\t"
-		"strex	%1, %0, [%2]	"
-
-		: "=&r" (__res), "=&r" (__ex_flag)
-		: "r" (&(count)->counter)
-		: "cc","memory" );
-
-	__res |= __ex_flag;
-	if (unlikely(__res != 0))
-		fail_fn(count);
-}
-
-static inline int
-__mutex_fastpath_lock_retval(atomic_t *count, int (*fail_fn)(atomic_t *))
-{
-	int __ex_flag, __res;
-
-	__asm__ (
-
-		"ldrex	%0, [%2]	\n\t"
-		"sub	%0, %0, #1	\n\t"
-		"strex	%1, %0, [%2]	"
-
-		: "=&r" (__res), "=&r" (__ex_flag)
-		: "r" (&(count)->counter)
-		: "cc","memory" );
-
-	__res |= __ex_flag;
-	if (unlikely(__res != 0))
-		__res = fail_fn(count);
-	return __res;
-}
-
-/*
- * Same trick is used for the unlock fast path. However the original value,
- * rather than the result, is used to test for success in order to have
- * better generated assembly.
- */
-static inline void
-__mutex_fastpath_unlock(atomic_t *count, void (*fail_fn)(atomic_t *))
-{
-	int __ex_flag, __res, __orig;
-
-	__asm__ (
-
-		"ldrex	%0, [%3]	\n\t"
-		"add	%1, %0, #1	\n\t"
-		"strex	%2, %1, [%3]	"
-
-		: "=&r" (__orig), "=&r" (__res), "=&r" (__ex_flag)
-		: "r" (&(count)->counter)
-		: "cc","memory" );
-
-	__orig |= __ex_flag;
-	if (unlikely(__orig != 0))
-		fail_fn(count);
-}
-
-/*
- * If the unlock was done on a contended lock, or if the unlock simply fails
- * then the mutex remains locked.
- */
-#define __mutex_slowpath_needs_to_unlock()	1
-
-/*
- * For __mutex_fastpath_trylock we use another construct which could be
- * described as a "single value cmpxchg".
- *
- * This provides the needed trylock semantics like cmpxchg would, but it is
- * lighter and less generic than a true cmpxchg implementation.
- */
-static inline int
-__mutex_fastpath_trylock(atomic_t *count, int (*fail_fn)(atomic_t *))
-{
-	int __ex_flag, __res, __orig;
-
-	__asm__ (
-
-		"1: ldrex	%0, [%3]	\n\t"
-		"subs		%1, %0, #1	\n\t"
-		"strexeq	%2, %1, [%3]	\n\t"
-		"movlt		%0, #0		\n\t"
-		"cmpeq		%2, #0		\n\t"
-		"bgt		1b		"
-
-		: "=&r" (__orig), "=&r" (__res), "=&r" (__ex_flag)
-		: "r" (&count->counter)
-		: "cc", "memory" );
-
-	return __orig;
-}
-
-#endif
+#include <asm-generic/mutex-xchg.h>
 #endif
diff --git a/arch/arm/include/asm/rodata.h b/arch/arm/include/asm/rodata.h
new file mode 100644
index 00000000..8c8add87
--- /dev/null
+++ b/arch/arm/include/asm/rodata.h
@@ -0,0 +1,32 @@
+/*
+ *  arch/arm/include/asm/rodata.h
+ *
+ *  Copyright (C) 2011 Google, Inc.
+ *
+ *  Author: Colin Cross <ccross@android.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_RODATA_H
+#define _ASMARM_RODATA_H
+
+#ifndef __ASSEMBLY__
+
+#ifdef CONFIG_DEBUG_RODATA
+
+int set_memory_rw(unsigned long virt, int numpages);
+int set_memory_ro(unsigned long virt, int numpages);
+
+void mark_rodata_ro(void);
+void set_kernel_text_rw(void);
+void set_kernel_text_ro(void);
+#else
+static inline void set_kernel_text_rw(void) { }
+static inline void set_kernel_text_ro(void) { }
+#endif
+
+#endif
+
+#endif
diff --git a/arch/arm/include/asm/sched_clock.h b/arch/arm/include/asm/sched_clock.h
index e3f75726..05b8e82e 100644
--- a/arch/arm/include/asm/sched_clock.h
+++ b/arch/arm/include/asm/sched_clock.h
@@ -10,5 +10,7 @@
 
 extern void sched_clock_postinit(void);
 extern void setup_sched_clock(u32 (*read)(void), int bits, unsigned long rate);
+extern void setup_sched_clock_needs_suspend(u32 (*read)(void), int bits,
+		unsigned long rate);
 
 #endif
diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index ae292932..7f74b59f 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -93,4 +93,6 @@ extern void platform_cpu_enable(unsigned int cpu);
 extern void arch_send_call_function_single_ipi(int cpu);
 extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
 
+extern void smp_send_all_cpu_backtrace(void);
+
 #endif /* ifndef __ASM_ARM_SMP_H */
diff --git a/arch/arm/include/asm/thread_info.h b/arch/arm/include/asm/thread_info.h
index 0f04d845..8eab5210 100644
--- a/arch/arm/include/asm/thread_info.h
+++ b/arch/arm/include/asm/thread_info.h
@@ -109,11 +109,8 @@ extern void crunch_task_copy(struct thread_info *, void *);
 extern void crunch_task_restore(struct thread_info *, void *);
 extern void crunch_task_release(struct thread_info *);
 
-extern void iwmmxt_task_disable(struct thread_info *);
-extern void iwmmxt_task_copy(struct thread_info *, void *);
-extern void iwmmxt_task_restore(struct thread_info *, void *);
-extern void iwmmxt_task_release(struct thread_info *);
-extern void iwmmxt_task_switch(struct thread_info *);
+extern void iwmmxt_sync_hwstate(struct thread_info *);
+extern void iwmmxt_flush_hwstate(struct thread_info *);
 
 extern void vfp_sync_hwstate(struct thread_info *);
 extern void vfp_flush_hwstate(struct thread_info *);
@@ -153,6 +150,7 @@ extern int vfp_restore_user_hwstate(struct user_vfp __user *,
 #define TIF_MEMDIE		18	/* is terminating due to OOM killer */
 #define TIF_RESTORE_SIGMASK	20
 #define TIF_SECCOMP		21
+#define TIF_SWITCH_MM		22	/* deferred switch_mm */
 
 #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
 #define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
diff --git a/arch/arm/include/asm/uaccess.h b/arch/arm/include/asm/uaccess.h
index 71f6536d..0a070e98 100644
--- a/arch/arm/include/asm/uaccess.h
+++ b/arch/arm/include/asm/uaccess.h
@@ -101,28 +101,39 @@ extern int __get_user_1(void *);
 extern int __get_user_2(void *);
 extern int __get_user_4(void *);
 
-#define __get_user_x(__r2,__p,__e,__s,__i...)				\
+#define __GUP_CLOBBER_1	"lr", "cc"
+#ifdef CONFIG_CPU_USE_DOMAINS
+#define __GUP_CLOBBER_2	"ip", "lr", "cc"
+#else
+#define __GUP_CLOBBER_2 "lr", "cc"
+#endif
+#define __GUP_CLOBBER_4	"lr", "cc"
+
+#define __get_user_x(__r2,__p,__e,__l,__s)				\
 	   __asm__ __volatile__ (					\
 		__asmeq("%0", "r0") __asmeq("%1", "r2")			\
+		__asmeq("%3", "r1")					\
 		"bl	__get_user_" #__s				\
 		: "=&r" (__e), "=r" (__r2)				\
-		: "0" (__p)						\
-		: __i, "cc")
+		: "0" (__p), "r" (__l)					\
+		: __GUP_CLOBBER_##__s)
 
 #define get_user(x,p)							\
 	({								\
+		unsigned long __limit = current_thread_info()->addr_limit - 1; \
 		register const typeof(*(p)) __user *__p asm("r0") = (p);\
 		register unsigned long __r2 asm("r2");			\
+		register unsigned long __l asm("r1") = __limit;		\
 		register int __e asm("r0");				\
 		switch (sizeof(*(__p))) {				\
 		case 1:							\
-			__get_user_x(__r2, __p, __e, 1, "lr");		\
-	       		break;						\
+			__get_user_x(__r2, __p, __e, __l, 1);		\
+			break;						\
 		case 2:							\
-			__get_user_x(__r2, __p, __e, 2, "r3", "lr");	\
+			__get_user_x(__r2, __p, __e, __l, 2);		\
 			break;						\
 		case 4:							\
-	       		__get_user_x(__r2, __p, __e, 4, "lr");		\
+			__get_user_x(__r2, __p, __e, __l, 4);		\
 			break;						\
 		default: __e = __get_user_bad(); break;			\
 		}							\
@@ -135,31 +146,34 @@ extern int __put_user_2(void *, unsigned int);
 extern int __put_user_4(void *, unsigned int);
 extern int __put_user_8(void *, unsigned long long);
 
-#define __put_user_x(__r2,__p,__e,__s)					\
+#define __put_user_x(__r2,__p,__e,__l,__s)				\
 	   __asm__ __volatile__ (					\
 		__asmeq("%0", "r0") __asmeq("%2", "r2")			\
+		__asmeq("%3", "r1")					\
 		"bl	__put_user_" #__s				\
 		: "=&r" (__e)						\
-		: "0" (__p), "r" (__r2)					\
+		: "0" (__p), "r" (__r2), "r" (__l)			\
 		: "ip", "lr", "cc")
 
 #define put_user(x,p)							\
 	({								\
+		unsigned long __limit = current_thread_info()->addr_limit - 1; \
 		register const typeof(*(p)) __r2 asm("r2") = (x);	\
 		register const typeof(*(p)) __user *__p asm("r0") = (p);\
+		register unsigned long __l asm("r1") = __limit;		\
 		register int __e asm("r0");				\
 		switch (sizeof(*(__p))) {				\
 		case 1:							\
-			__put_user_x(__r2, __p, __e, 1);		\
+			__put_user_x(__r2, __p, __e, __l, 1);		\
 			break;						\
 		case 2:							\
-			__put_user_x(__r2, __p, __e, 2);		\
+			__put_user_x(__r2, __p, __e, __l, 2);		\
 			break;						\
 		case 4:							\
-			__put_user_x(__r2, __p, __e, 4);		\
+			__put_user_x(__r2, __p, __e, __l, 4);		\
 			break;						\
 		case 8:							\
-			__put_user_x(__r2, __p, __e, 8);		\
+			__put_user_x(__r2, __p, __e, __l, 8);		\
 			break;						\
 		default: __e = __put_user_bad(); break;			\
 		}							\
diff --git a/arch/arm/kernel/Makefile b/arch/arm/kernel/Makefile
index 7b787d64..851aa69b 100644
--- a/arch/arm/kernel/Makefile
+++ b/arch/arm/kernel/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_ARM_CPU_SUSPEND)	+= sleep.o suspend.o
 obj-$(CONFIG_SMP)		+= smp.o smp_tlb.o
 obj-$(CONFIG_HAVE_ARM_SCU)	+= smp_scu.o
 obj-$(CONFIG_HAVE_ARM_TWD)	+= smp_twd.o
+obj-$(CONFIG_ARM_ARCH_TIMER)	+= arch_timer.o
 obj-$(CONFIG_DYNAMIC_FTRACE)	+= ftrace.o insn.o
 obj-$(CONFIG_FUNCTION_GRAPH_TRACER)	+= ftrace.o insn.o
 obj-$(CONFIG_JUMP_LABEL)	+= jump_label.o insn.o patch.o
@@ -63,11 +64,7 @@ obj-$(CONFIG_SWP_EMULATE)	+= swp_emulate.o
 CFLAGS_swp_emulate.o		:= -Wa,-march=armv7-a
 obj-$(CONFIG_HAVE_HW_BREAKPOINT)	+= hw_breakpoint.o
 
-obj-$(CONFIG_CPU_XSCALE)	+= xscale-cp0.o
-obj-$(CONFIG_CPU_XSC3)		+= xscale-cp0.o
-obj-$(CONFIG_CPU_MOHAWK)	+= xscale-cp0.o
-obj-$(CONFIG_CPU_PJ4)		+= pj4-cp0.o
-obj-$(CONFIG_IWMMXT)		+= iwmmxt.o
+obj-$(CONFIG_IWMMXT)		+= iwmmxt.o iwmmxtmodule.o
 obj-$(CONFIG_CPU_HAS_PMU)	+= pmu.o
 obj-$(CONFIG_HW_PERF_EVENTS)	+= perf_event.o
 AFLAGS_iwmmxt.o			:= -Wa,-mcpu=iwmmxt
diff --git a/arch/arm/kernel/head.S b/arch/arm/kernel/head.S
index 3bf0c7f8..529f489d 100644
--- a/arch/arm/kernel/head.S
+++ b/arch/arm/kernel/head.S
@@ -52,7 +52,9 @@
 	.equ	swapper_pg_dir, KERNEL_RAM_VADDR - PG_DIR_SIZE
 
 	.macro	pgtbl, rd, phys
-	add	\rd, \phys, #TEXT_OFFSET - PG_DIR_SIZE
+	ldr	\rd, =TEXT_OFFSET
+	sub	\rd, \rd, #PG_DIR_SIZE
+	add	\rd, \phys, \rd
 	.endm
 
 #ifdef CONFIG_XIP_KERNEL
diff --git a/arch/arm/kernel/machine_kexec.c b/arch/arm/kernel/machine_kexec.c
index dfcdb9f7..f2362f2a 100644
--- a/arch/arm/kernel/machine_kexec.c
+++ b/arch/arm/kernel/machine_kexec.c
@@ -54,6 +54,11 @@ void machine_crash_nonpanic_core(void *unused)
 		cpu_relax();
 }
 
+void machine_crash_update(struct pt_regs *regs)
+{
+	crash_save_cpu(regs, smp_processor_id());
+}
+
 static void machine_kexec_mask_interrupts(void)
 {
 	unsigned int i;
diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 2b7b017a..e9ae2148 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -31,9 +31,9 @@
 #include <linux/random.h>
 #include <linux/hw_breakpoint.h>
 #include <linux/cpuidle.h>
+#include <linux/console.h>
 
 #include <asm/cacheflush.h>
-#include <asm/leds.h>
 #include <asm/processor.h>
 #include <asm/thread_notify.h>
 #include <asm/stacktrace.h>
@@ -60,6 +60,18 @@ extern void setup_mm_for_reboot(void);
 
 static volatile int hlt_counter;
 
+#ifdef CONFIG_SMP
+void arch_trigger_all_cpu_backtrace(void)
+{
+	smp_send_all_cpu_backtrace();
+}
+#else
+void arch_trigger_all_cpu_backtrace(void)
+{
+	dump_stack();
+}
+#endif
+
 void disable_hlt(void)
 {
 	hlt_counter++;
@@ -92,6 +104,31 @@ __setup("hlt", hlt_setup);
 extern void call_with_stack(void (*fn)(void *), void *arg, void *sp);
 typedef void (*phys_reset_t)(unsigned long);
 
+#ifdef CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART
+void arm_machine_flush_console(void)
+{
+	printk("\n");
+	pr_emerg("Restarting %s\n", linux_banner);
+	if (console_trylock()) {
+		console_unlock();
+		return;
+	}
+
+	mdelay(50);
+
+	local_irq_disable();
+	if (!console_trylock())
+		pr_emerg("arm_restart: Console was locked! Busting\n");
+	else
+		pr_emerg("arm_restart: Console was locked!\n");
+	console_unlock();
+}
+#else
+void arm_machine_flush_console(void)
+{
+}
+#endif
+
 /*
  * A temporary stack to use for CPU reset. This is static so that we
  * don't clobber it with the identity mapping. When running with this
@@ -195,6 +232,12 @@ static void default_idle(void)
 void (*pm_idle)(void) = default_idle;
 EXPORT_SYMBOL(pm_idle);
 
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+#ifndef CONFIG_ZRAM_FOR_RTCC2
+extern void could_cswap(void);
+#endif
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
+
 /*
  * The idle thread, has rather strange semantics for calling pm_idle,
  * but this is what x86 does and we need to do the same, so that
@@ -207,15 +250,19 @@ void cpu_idle(void)
 
 	/* endless idle loop with no priority at all */
 	while (1) {
+		idle_notifier_call_chain(IDLE_START);
 		tick_nohz_idle_enter();
 		rcu_idle_enter();
-		leds_event(led_idle_start);
 		while (!need_resched()) {
 #ifdef CONFIG_HOTPLUG_CPU
 			if (cpu_is_offline(smp_processor_id()))
 				cpu_die();
 #endif
-
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+#ifndef CONFIG_ZRAM_FOR_RTCC2
+			could_cswap();
+#endif
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
 			/*
 			 * We need to disable interrupts here
 			 * to ensure we don't miss a wakeup call.
@@ -240,9 +287,9 @@ void cpu_idle(void)
 			} else
 				local_irq_enable();
 		}
-		leds_event(led_idle_end);
 		rcu_idle_exit();
 		tick_nohz_idle_exit();
+		idle_notifier_call_chain(IDLE_END);
 		schedule_preempt_disabled();
 	}
 }
@@ -260,6 +307,15 @@ __setup("reboot=", reboot_setup);
 void machine_shutdown(void)
 {
 #ifdef CONFIG_SMP
+	/*
+	 * Disable preemption so we're guaranteed to
+	 * run to power off or reboot and prevent
+	 * the possibility of switching to another
+	 * thread that might wind up blocking on
+	 * one of the stopped CPUs.
+	 */
+	preempt_disable();
+
 	smp_send_stop();
 #endif
 }
@@ -281,6 +337,10 @@ void machine_restart(char *cmd)
 {
 	machine_shutdown();
 
+	/* Flush the console to make sure all the relevant messages make it
+	 * out to the console drivers */
+	arm_machine_flush_console();
+
 	arm_pm_restart(reboot_mode, cmd);
 
 	/* Give a grace period for failure to restart of 1s */
@@ -291,6 +351,77 @@ void machine_restart(char *cmd)
 	while (1);
 }
 
+/*
+ * dump a block of kernel memory from around the given address
+ */
+static void show_data(unsigned long addr, int nbytes, const char *name)
+{
+	int	i, j;
+	int	nlines;
+	u32	*p;
+
+	/*
+	 * don't attempt to dump non-kernel addresses or
+	 * values that are probably just small negative numbers
+	 */
+	if (addr < PAGE_OFFSET || addr > -256UL)
+		return;
+
+	printk("\n%s: %#lx:\n", name, addr);
+
+	/*
+	 * round address down to a 32 bit boundary
+	 * and always dump a multiple of 32 bytes
+	 */
+	p = (u32 *)(addr & ~(sizeof(u32) - 1));
+	nbytes += (addr & (sizeof(u32) - 1));
+	nlines = (nbytes + 31) / 32;
+
+
+	for (i = 0; i < nlines; i++) {
+		/*
+		 * just display low 16 bits of address to keep
+		 * each line of the dump < 80 characters
+		 */
+		printk("%04lx ", (unsigned long)p & 0xffff);
+		for (j = 0; j < 8; j++) {
+			u32	data;
+			if (probe_kernel_address(p, data)) {
+				printk(" ********");
+			} else {
+				printk(" %08x", data);
+			}
+			++p;
+		}
+		printk("\n");
+	}
+}
+
+static void show_extra_register_data(struct pt_regs *regs, int nbytes)
+{
+	mm_segment_t fs;
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	show_data(regs->ARM_pc - nbytes, nbytes * 2, "PC");
+	show_data(regs->ARM_lr - nbytes, nbytes * 2, "LR");
+	show_data(regs->ARM_sp - nbytes, nbytes * 2, "SP");
+	show_data(regs->ARM_ip - nbytes, nbytes * 2, "IP");
+	show_data(regs->ARM_fp - nbytes, nbytes * 2, "FP");
+	show_data(regs->ARM_r0 - nbytes, nbytes * 2, "R0");
+	show_data(regs->ARM_r1 - nbytes, nbytes * 2, "R1");
+	show_data(regs->ARM_r2 - nbytes, nbytes * 2, "R2");
+	show_data(regs->ARM_r3 - nbytes, nbytes * 2, "R3");
+	show_data(regs->ARM_r4 - nbytes, nbytes * 2, "R4");
+	show_data(regs->ARM_r5 - nbytes, nbytes * 2, "R5");
+	show_data(regs->ARM_r6 - nbytes, nbytes * 2, "R6");
+	show_data(regs->ARM_r7 - nbytes, nbytes * 2, "R7");
+	show_data(regs->ARM_r8 - nbytes, nbytes * 2, "R8");
+	show_data(regs->ARM_r9 - nbytes, nbytes * 2, "R9");
+	show_data(regs->ARM_r10 - nbytes, nbytes * 2, "R10");
+	set_fs(fs);
+}
+
 void __show_regs(struct pt_regs *regs)
 {
 	unsigned long flags;
@@ -350,6 +481,8 @@ void __show_regs(struct pt_regs *regs)
 		printk("Control: %08x%s\n", ctrl, buf);
 	}
 #endif
+
+	show_extra_register_data(regs, 128);
 }
 
 void show_regs(struct pt_regs * regs)
diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c
index 9650c143..e2865f16 100644
--- a/arch/arm/kernel/ptrace.c
+++ b/arch/arm/kernel/ptrace.c
@@ -301,7 +301,7 @@ static int ptrace_getwmmxregs(struct task_struct *tsk, void __user *ufp)
 
 	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
 		return -ENODATA;
-	iwmmxt_task_disable(thread);  /* force it to ram */
+	iwmmxt_sync_hwstate(thread);
 	return copy_to_user(ufp, &thread->fpstate.iwmmxt, IWMMXT_SIZE)
 		? -EFAULT : 0;
 }
@@ -315,9 +315,13 @@ static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
 
 	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
 		return -EACCES;
-	iwmmxt_task_release(thread);  /* force a reload */
-	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
-		? -EFAULT : 0;
+	iwmmxt_sync_hwstate(thread);
+	if (copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE))
+		return  -EFAULT;
+
+	iwmmxt_flush_hwstate(thread);
+
+	return 0;
 }
 
 #endif
diff --git a/arch/arm/kernel/sched_clock.c b/arch/arm/kernel/sched_clock.c
index 27d186ab..f4515393 100644
--- a/arch/arm/kernel/sched_clock.c
+++ b/arch/arm/kernel/sched_clock.c
@@ -21,6 +21,8 @@ struct clock_data {
 	u32 epoch_cyc_copy;
 	u32 mult;
 	u32 shift;
+	bool suspended;
+	bool needs_suspend;
 };
 
 static void sched_clock_poll(unsigned long wrap_ticks);
@@ -49,6 +51,9 @@ static unsigned long long cyc_to_sched_clock(u32 cyc, u32 mask)
 	u64 epoch_ns;
 	u32 epoch_cyc;
 
+	if (cd.suspended)
+		return cd.epoch_ns;
+
 	/*
 	 * Load the epoch_cyc and epoch_ns atomically.  We do this by
 	 * ensuring that we always write epoch_cyc, epoch_ns and
@@ -98,6 +103,13 @@ static void sched_clock_poll(unsigned long wrap_ticks)
 	update_sched_clock();
 }
 
+void __init setup_sched_clock_needs_suspend(u32 (*read)(void), int bits,
+		unsigned long rate)
+{
+	setup_sched_clock(read, bits, rate);
+	cd.needs_suspend = true;
+}
+
 void __init setup_sched_clock(u32 (*read)(void), int bits, unsigned long rate)
 {
 	unsigned long r, w;
@@ -169,11 +181,23 @@ void __init sched_clock_postinit(void)
 static int sched_clock_suspend(void)
 {
 	sched_clock_poll(sched_clock_timer.data);
+	if (cd.needs_suspend)
+		cd.suspended = true;
 	return 0;
 }
 
+static void sched_clock_resume(void)
+{
+	if (cd.needs_suspend) {
+		cd.epoch_cyc = read_sched_clock();
+		cd.epoch_cyc_copy = cd.epoch_cyc;
+		cd.suspended = false;
+	}
+}
+
 static struct syscore_ops sched_clock_ops = {
 	.suspend = sched_clock_suspend,
+	.resume = sched_clock_resume,
 };
 
 static int __init sched_clock_syscore_init(void)
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index ebfac782..1b3096df 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -81,6 +81,7 @@ __setup("fpe=", fpe_setup);
 extern void paging_init(struct machine_desc *desc);
 extern void sanity_check_meminfo(void);
 extern void reboot_setup(char *str);
+extern void setup_dma_zone(struct machine_desc *desc);
 
 unsigned int processor_id;
 EXPORT_SYMBOL(processor_id);
@@ -939,12 +940,8 @@ void __init setup_arch(char **cmdline_p)
 	machine_desc = mdesc;
 	machine_name = mdesc->name;
 
-#ifdef CONFIG_ZONE_DMA
-	if (mdesc->dma_zone_size) {
-		extern unsigned long arm_dma_zone_size;
-		arm_dma_zone_size = mdesc->dma_zone_size;
-	}
-#endif
+	setup_dma_zone(mdesc);
+
 	if (mdesc->restart_mode)
 		reboot_setup(&mdesc->restart_mode);
 
diff --git a/arch/arm/kernel/signal.c b/arch/arm/kernel/signal.c
index d68d1b69..4c85f35e 100644
--- a/arch/arm/kernel/signal.c
+++ b/arch/arm/kernel/signal.c
@@ -149,12 +149,14 @@ static int preserve_iwmmxt_context(struct iwmmxt_sigframe *frame)
 {
 	char kbuf[sizeof(*frame) + 8];
 	struct iwmmxt_sigframe *kframe;
+	struct thread_info *thread = current_thread_info();
 
 	/* the iWMMXt context must be 64 bit aligned */
 	kframe = (struct iwmmxt_sigframe *)((unsigned long)(kbuf + 8) & ~7);
 	kframe->magic = IWMMXT_MAGIC;
 	kframe->size = IWMMXT_STORAGE_SIZE;
-	iwmmxt_task_copy(current_thread_info(), &kframe->storage);
+	iwmmxt_sync_hwstate(thread);
+	memcpy(&kframe->storage, &thread->fpstate.iwmmxt, sizeof(struct iwmmxt_struct));
 	return __copy_to_user(frame, kframe, sizeof(*frame));
 }
 
@@ -162,6 +164,7 @@ static int restore_iwmmxt_context(struct iwmmxt_sigframe *frame)
 {
 	char kbuf[sizeof(*frame) + 8];
 	struct iwmmxt_sigframe *kframe;
+	struct thread_info *thread = current_thread_info();
 
 	/* the iWMMXt context must be 64 bit aligned */
 	kframe = (struct iwmmxt_sigframe *)((unsigned long)(kbuf + 8) & ~7);
@@ -170,7 +173,8 @@ static int restore_iwmmxt_context(struct iwmmxt_sigframe *frame)
 	if (kframe->magic != IWMMXT_MAGIC ||
 	    kframe->size != IWMMXT_STORAGE_SIZE)
 		return -1;
-	iwmmxt_task_restore(current_thread_info(), &kframe->storage);
+	memcpy(&thread->fpstate.iwmmxt, &kframe->storage, sizeof(struct iwmmxt_struct));
+	iwmmxt_flush_hwstate(thread);
 	return 0;
 }
 
@@ -642,7 +646,7 @@ static void do_signal(struct pt_regs *regs, int syscall)
 		}
 	}
 
-	if (try_to_freeze())
+	if (try_to_freeze_nowarn())
 		goto no_signal;
 
 	/*
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index 8f464465..8ee55085 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -42,6 +42,9 @@
 #include <asm/ptrace.h>
 #include <asm/localtimer.h>
 #include <asm/smp_plat.h>
+#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
+#include <mach/sec_debug.h>
+#endif
 
 /*
  * as from 2.5, kernels no longer have an init_tasks structure
@@ -51,11 +54,13 @@
 struct secondary_data secondary_data;
 
 enum ipi_msg_type {
-	IPI_TIMER = 2,
+	IPI_WAKEUP =1,
+	IPI_TIMER,
 	IPI_RESCHEDULE,
 	IPI_CALL_FUNC,
 	IPI_CALL_FUNC_SINGLE,
 	IPI_CPU_STOP,
+	IPI_CPU_BACKTRACE,
 };
 
 static DECLARE_COMPLETION(cpu_running);
@@ -156,8 +161,11 @@ int __cpu_disable(void)
 	/*
 	 * Flush user cache and TLB mappings, and then remove this CPU
 	 * from the vm mask set of all processes.
+	 *
+	 * Caches are flushed to the Level of Unification Inner Shareable
+	 * to write-back dirty lines to unified caches shared by all CPUs.
 	 */
-	flush_cache_all();
+	flush_cache_louis();
 	local_flush_tlb_all();
 
 	read_lock(&tasklist_lock);
@@ -377,12 +385,14 @@ void arch_send_call_function_single_ipi(int cpu)
 }
 
 static const char *ipi_types[NR_IPI] = {
-#define S(x,s)	[x - IPI_TIMER] = s
+#define S(x, s)	[x - IPI_WAKEUP] = s
+	S(IPI_WAKEUP, "CPU wakeup interrupts"),
 	S(IPI_TIMER, "Timer broadcast interrupts"),
 	S(IPI_RESCHEDULE, "Rescheduling interrupts"),
 	S(IPI_CALL_FUNC, "Function call interrupts"),
 	S(IPI_CALL_FUNC_SINGLE, "Single function call interrupts"),
 	S(IPI_CPU_STOP, "CPU stop interrupts"),
+	S(IPI_CPU_BACKTRACE, "CPU backtrace"),
 };
 
 void show_ipi_list(struct seq_file *p, int prec)
@@ -514,6 +524,58 @@ static void ipi_cpu_stop(unsigned int cpu)
 		cpu_relax();
 }
 
+static cpumask_t backtrace_mask;
+static DEFINE_RAW_SPINLOCK(backtrace_lock);
+
+/* "in progress" flag of arch_trigger_all_cpu_backtrace */
+static unsigned long backtrace_flag;
+
+void smp_send_all_cpu_backtrace(void)
+{
+	unsigned int this_cpu = smp_processor_id();
+	int i;
+
+	if (test_and_set_bit(0, &backtrace_flag))
+		/*
+		 * If there is already a trigger_all_cpu_backtrace() in progress
+		 * (backtrace_flag == 1), don't output double cpu dump infos.
+		 */
+		return;
+
+	cpumask_copy(&backtrace_mask, cpu_online_mask);
+	cpu_clear(this_cpu, backtrace_mask);
+
+	pr_info("Backtrace for cpu %d (current):\n", this_cpu);
+	dump_stack();
+
+	pr_info("\nsending IPI to all other CPUs:\n");
+	smp_cross_call(&backtrace_mask, IPI_CPU_BACKTRACE);
+
+	/* Wait for up to 10 seconds for all other CPUs to do the backtrace */
+	for (i = 0; i < 10 * 1000; i++) {
+		if (cpumask_empty(&backtrace_mask))
+			break;
+		mdelay(1);
+	}
+
+	clear_bit(0, &backtrace_flag);
+	smp_mb__after_clear_bit();
+}
+
+/*
+ * ipi_cpu_backtrace - handle IPI from smp_send_all_cpu_backtrace()
+ */
+static void ipi_cpu_backtrace(unsigned int cpu, struct pt_regs *regs)
+{
+	if (cpu_isset(cpu, backtrace_mask)) {
+		raw_spin_lock(&backtrace_lock);
+		pr_warning("IPI backtrace for cpu %d\n", cpu);
+		show_regs(regs);
+		raw_spin_unlock(&backtrace_lock);
+		cpu_clear(cpu, backtrace_mask);
+	}
+}
+
 /*
  * Main handler for inter-processor interrupts
  */
@@ -527,10 +589,15 @@ void handle_IPI(int ipinr, struct pt_regs *regs)
 	unsigned int cpu = smp_processor_id();
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
-	if (ipinr >= IPI_TIMER && ipinr < IPI_TIMER + NR_IPI)
-		__inc_irq_stat(cpu, ipi_irqs[ipinr - IPI_TIMER]);
-
-	switch (ipinr) {
+	if (ipinr >= IPI_WAKEUP && ipinr < IPI_WAKEUP + NR_IPI)
+		__inc_irq_stat(cpu, ipi_irqs[ipinr - IPI_WAKEUP]);
+#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
+	sec_debug_irq_log(ipinr, do_IPI, 1);
+#endif
+ 	switch (ipinr) {
+	case IPI_WAKEUP:
+		/* Wake up from WFI/WFE using SGI */
+		break;
 	case IPI_TIMER:
 		irq_enter();
 		ipi_timer();
@@ -559,11 +626,18 @@ void handle_IPI(int ipinr, struct pt_regs *regs)
 		irq_exit();
 		break;
 
+	case IPI_CPU_BACKTRACE:
+		ipi_cpu_backtrace(cpu, regs);
+		break;
+
 	default:
 		printk(KERN_CRIT "CPU%u: Unknown IPI message 0x%x\n",
 		       cpu, ipinr);
 		break;
 	}
+#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
+	sec_debug_irq_log(ipinr, do_IPI, 2);
+#endif
 	set_irq_regs(old_regs);
 }
 
diff --git a/arch/arm/kernel/smp_scu.c b/arch/arm/kernel/smp_scu.c
index 8f5dd796..0bfff28c 100644
--- a/arch/arm/kernel/smp_scu.c
+++ b/arch/arm/kernel/smp_scu.c
@@ -71,7 +71,7 @@ void scu_enable(void __iomem *scu_base)
  * has the side effect of disabling coherency, caches must have been
  * flushed.  Interrupts must also have been disabled.
  */
-int scu_power_mode(void __iomem *scu_base, unsigned int mode)
+int notrace scu_power_mode(void __iomem *scu_base, unsigned int mode)
 {
 	unsigned int val;
 	int cpu = smp_processor_id();
diff --git a/arch/arm/kernel/suspend.c b/arch/arm/kernel/suspend.c
index 1794cc3b..ffd42b2a 100644
--- a/arch/arm/kernel/suspend.c
+++ b/arch/arm/kernel/suspend.c
@@ -17,6 +17,8 @@ extern void cpu_resume_mmu(void);
  */
 void __cpu_suspend_save(u32 *ptr, u32 ptrsz, u32 sp, u32 *save_ptr)
 {
+	u32 *ctx = ptr;
+
 	*save_ptr = virt_to_phys(ptr);
 
 	/* This must correspond to the LDM in cpu_resume() assembly */
@@ -26,7 +28,22 @@ void __cpu_suspend_save(u32 *ptr, u32 ptrsz, u32 sp, u32 *save_ptr)
 
 	cpu_do_suspend(ptr);
 
-	flush_cache_all();
+#if !defined(CONFIG_CPU_PXA988) && !defined(CONFIG_CPU_PXA1088) && !defined(CONFIG_CPU_EDEN)
+	flush_cache_louis();
+#endif
+
+	/*
+	 * flush_cache_louis does not guarantee that
+	 * save_ptr and ptr are cleaned to main memory,
+	 * just up to the Level of Unification Inner Shareable.
+	 * Since the context pointer and context itself
+	 * are to be retrieved with the MMU off that
+	 * data must be cleaned from all cache levels
+	 * to main memory using "area" cache primitives.
+	*/
+	__cpuc_flush_dcache_area(ctx, ptrsz);
+	__cpuc_flush_dcache_area(save_ptr, sizeof(*save_ptr));
+
 	outer_clean_range(*save_ptr, *save_ptr + ptrsz);
 	outer_clean_range(virt_to_phys(save_ptr),
 			  virt_to_phys(save_ptr) + sizeof(*save_ptr));
diff --git a/arch/arm/kernel/sys_arm.c b/arch/arm/kernel/sys_arm.c
index 76cbb055..ed43afd4 100644
--- a/arch/arm/kernel/sys_arm.c
+++ b/arch/arm/kernel/sys_arm.c
@@ -59,6 +59,131 @@ asmlinkage int sys_vfork(struct pt_regs *regs)
 	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs->ARM_sp, regs, 0, NULL, NULL);
 }
 
+#if defined CONFIG_SEC_RESTRICT_FORK
+#if defined CONFIG_SEC_RESTRICT_ROOTING_LOG
+#define PRINT_LOG(...)	printk(KERN_ERR __VA_ARGS__)
+#else
+#define PRINT_LOG(...)
+#endif	// End of CONFIG_SEC_RESTRICT_ROOTING_LOG
+
+#define CHECK_ROOT_UID(x) (x->cred->uid == 0 || x->cred->gid == 0 || \
+			x->cred->euid == 0 || x->cred->egid == 0 || \
+			x->cred->suid == 0 || x->cred->sgid == 0)
+
+/*  sec_check_execpath
+    return value : give task's exec path is matched or not
+*/
+int sec_check_execpath(struct mm_struct *mm, char *denypath)
+{
+	struct file *exe_file;
+	char *path, *pathbuf = NULL;
+	unsigned int path_length = 0, denypath_length = 0;
+	int ret = 0;
+
+	if (mm == NULL)
+		return 0;
+
+	if (!(exe_file = get_mm_exe_file(mm))) {
+		PRINT_LOG("Cannot get exe from task->mm.\n");
+		goto out_nofile;
+	}
+
+	if (!(pathbuf = kmalloc(PATH_MAX, GFP_TEMPORARY))) {
+		PRINT_LOG("failed to kmalloc for pathbuf\n");
+		goto out;
+	}
+
+	path = d_path(&exe_file->f_path, pathbuf, PATH_MAX);
+	if (IS_ERR(path)) {
+		PRINT_LOG("Error get path..\n");
+		goto out;
+	}
+
+	path_length = strlen(path);
+	denypath_length = strlen(denypath);
+
+	if (!strncmp(path, denypath, (path_length < denypath_length) ?
+				path_length : denypath_length)) {
+		ret = 1;
+	}
+out:
+	fput(exe_file);
+out_nofile:
+	if (pathbuf)
+		kfree(pathbuf);
+
+	return ret;
+}
+EXPORT_SYMBOL(sec_check_execpath);
+
+static int sec_restrict_fork(void)
+{
+	struct cred *shellcred;
+	int ret = 0;
+	struct task_struct *parent_tsk;
+	struct mm_struct *parent_mm = NULL;
+	const struct cred *parent_cred;
+
+	read_lock(&tasklist_lock);
+	parent_tsk = current->parent;
+	if (!parent_tsk) {
+		read_unlock(&tasklist_lock);
+		return 0;
+	}
+
+	get_task_struct(parent_tsk);
+	/* holding on to the task struct is enough so just release
+	 * the tasklist lock here */
+	read_unlock(&tasklist_lock);
+
+	if (current->pid == 1 || parent_tsk->pid == 1)
+		goto out;
+
+	/* get current->parent's mm struct to access it's mm
+	 * and to keep it alive */
+	parent_mm = get_task_mm(parent_tsk);
+
+	if (current->mm == NULL || parent_mm == NULL)
+		goto out;
+
+	if (sec_check_execpath(parent_mm, "/sbin/adbd")) {
+		shellcred = prepare_creds();
+		if (!shellcred) {
+			ret = 1;
+			goto out;
+		}
+
+		shellcred->uid = 2000;
+		shellcred->gid = 2000;
+		shellcred->euid = 2000;
+		shellcred->egid = 2000;
+		commit_creds(shellcred);
+		ret = 0;
+		goto out;
+	}
+
+	if (sec_check_execpath(current->mm, "/data/")) {
+		ret = 1;
+		goto out;
+	}
+
+	parent_cred = get_task_cred(parent_tsk);
+	if (!parent_cred)
+		goto out;
+	if (!CHECK_ROOT_UID(parent_tsk))
+	{
+		ret = 1;
+	}
+	put_cred(parent_cred);
+out:
+	if (parent_mm)
+		mmput(parent_mm);
+	put_task_struct(parent_tsk);
+
+	return ret;
+}
+#endif	/* End of CONFIG_SEC_RESTRICT_FORK */
+
 /* sys_execve() executes a new program.
  * This is called indirectly via a small wrapper
  */
@@ -73,6 +198,19 @@ asmlinkage int sys_execve(const char __user *filenamei,
 	error = PTR_ERR(filename);
 	if (IS_ERR(filename))
 		goto out;
+
+#if defined CONFIG_SEC_RESTRICT_FORK
+	if(CHECK_ROOT_UID(current))
+		if(sec_restrict_fork())
+		{
+			PRINT_LOG("Restricted making process. PID = %d(%s) "
+							"PPID = %d(%s)\n",
+				current->pid, current->comm,
+				current->parent->pid, current->parent->comm);
+			return -EACCES;
+		}
+#endif	// End of CONFIG_SEC_RESTRICT_FORK
+
 	error = do_execve(filename, argv, envp, regs);
 	putname(filename);
 out:
diff --git a/arch/arm/kernel/traps.c b/arch/arm/kernel/traps.c
index 63d402f7..a9b5ecd4 100644
--- a/arch/arm/kernel/traps.c
+++ b/arch/arm/kernel/traps.c
@@ -242,11 +242,6 @@ static int __die(const char *str, int err, struct thread_info *thread, struct pt
 	printk(KERN_EMERG "Internal error: %s: %x [#%d]" S_PREEMPT S_SMP
 	       S_ISA "\n", str, err, ++die_counter);
 
-	/* trap and error numbers are mostly meaningless on ARM */
-	ret = notify_die(DIE_OOPS, str, regs, err, tsk->thread.trap_no, SIGSEGV);
-	if (ret == NOTIFY_STOP)
-		return ret;
-
 	print_modules();
 	__show_regs(regs);
 	printk(KERN_EMERG "Process %.*s (pid: %d, stack limit = 0x%p)\n",
@@ -259,6 +254,11 @@ static int __die(const char *str, int err, struct thread_info *thread, struct pt
 		dump_instr(KERN_EMERG, regs);
 	}
 
+	/* trap and error numbers are mostly meaningless on ARM */
+	ret = notify_die(DIE_OOPS, str, regs, err, tsk->thread.trap_no, SIGSEGV);
+	if (ret == NOTIFY_STOP)
+		return ret;
+
 	return ret;
 }
 
@@ -292,10 +292,19 @@ void die(const char *str, struct pt_regs *regs, int err)
 	raw_spin_unlock_irq(&die_lock);
 	oops_exit();
 
+#ifdef CONFIG_SEC_DEBUG
+	if (in_interrupt())
+		panic("%-51s\nPC is at %-42pS\nLR is at %-42pS",
+				"Fatal exception in interrupt", (void *)regs->ARM_pc, (void *)regs->ARM_lr);
+	if (panic_on_oops)
+		panic("%-51s\nPC is at %-42pS\nLR is at %-42pS",
+				"Fatal exception", (void *)regs->ARM_pc, (void *)regs->ARM_lr);
+#else
 	if (in_interrupt())
 		panic("Fatal exception in interrupt");
 	if (panic_on_oops)
 		panic("Fatal exception");
+#endif
 	if (ret != NOTIFY_STOP)
 		do_exit(SIGSEGV);
 }
@@ -479,14 +488,14 @@ static int bad_syscall(int n, struct pt_regs *regs)
 	return regs->ARM_r0;
 }
 
-static inline void
+static inline int
 do_cache_op(unsigned long start, unsigned long end, int flags)
 {
 	struct mm_struct *mm = current->active_mm;
 	struct vm_area_struct *vma;
 
 	if (end < start || flags)
-		return;
+		return -EINVAL;
 
 	down_read(&mm->mmap_sem);
 	vma = find_vma(mm, start);
@@ -497,10 +506,10 @@ do_cache_op(unsigned long start, unsigned long end, int flags)
 			end = vma->vm_end;
 
 		up_read(&mm->mmap_sem);
-		flush_cache_user_range(start, end);
-		return;
+		return flush_cache_user_range(start, end);
 	}
 	up_read(&mm->mmap_sem);
+	return -EINVAL;
 }
 
 /*
@@ -546,8 +555,7 @@ asmlinkage int arm_syscall(int no, struct pt_regs *regs)
 	 * the specified region).
 	 */
 	case NR(cacheflush):
-		do_cache_op(regs->ARM_r0, regs->ARM_r1, regs->ARM_r2);
-		return 0;
+		return do_cache_op(regs->ARM_r0, regs->ARM_r1, regs->ARM_r2);
 
 	case NR(usr26):
 		if (!(elf_hwcap & HWCAP_26BIT))
diff --git a/arch/arm/lib/Makefile b/arch/arm/lib/Makefile
index 0ade0acc..8508e2d4 100644
--- a/arch/arm/lib/Makefile
+++ b/arch/arm/lib/Makefile
@@ -6,7 +6,7 @@
 
 lib-y		:= backtrace.o changebit.o csumipv6.o csumpartial.o   \
 		   csumpartialcopy.o csumpartialcopyuser.o clearbit.o \
-		   delay.o findbit.o memchr.o memcpy.o		      \
+		   findbit.o memchr.o memcpy.o                        \
 		   memmove.o memset.o memzero.o setbit.o              \
 		   strncpy_from_user.o strnlen_user.o                 \
 		   strchr.o strrchr.o                                 \
@@ -18,6 +18,10 @@ lib-y		:= backtrace.o changebit.o csumipv6.o csumpartial.o   \
 
 mmu-y	:= clear_user.o copy_page.o getuser.o putuser.o
 
+ifneq ($(CONFIG_ARCH_PROVIDES_UDELAY),y)
+  lib-y += delay.o
+endif
+
 # the code in uaccess.S is not preemption safe and
 # probably faster on ARMv3 only
 ifeq ($(CONFIG_PREEMPT),y)
diff --git a/arch/arm/lib/getuser.S b/arch/arm/lib/getuser.S
index 11093a7c..9b06bb41 100644
--- a/arch/arm/lib/getuser.S
+++ b/arch/arm/lib/getuser.S
@@ -16,8 +16,9 @@
  * __get_user_X
  *
  * Inputs:	r0 contains the address
+ *		r1 contains the address limit, which must be preserved
  * Outputs:	r0 is the error code
- *		r2, r3 contains the zero-extended value
+ *		r2 contains the zero-extended value
  *		lr corrupted
  *
  * No other registers must be altered.  (see <asm/uaccess.h>
@@ -27,33 +28,39 @@
  * Note also that it is intended that __get_user_bad is not global.
  */
 #include <linux/linkage.h>
+#include <asm/assembler.h>
 #include <asm/errno.h>
 #include <asm/domain.h>
 
 ENTRY(__get_user_1)
+	check_uaccess r0, 1, r1, r2, __get_user_bad
 1: TUSER(ldrb)	r2, [r0]
 	mov	r0, #0
 	mov	pc, lr
 ENDPROC(__get_user_1)
 
 ENTRY(__get_user_2)
-#ifdef CONFIG_THUMB2_KERNEL
-2: TUSER(ldrb)	r2, [r0]
-3: TUSER(ldrb)	r3, [r0, #1]
+	check_uaccess r0, 2, r1, r2, __get_user_bad
+#ifdef CONFIG_CPU_USE_DOMAINS
+rb	.req	ip
+2:	ldrbt	r2, [r0], #1
+3:	ldrbt	rb, [r0], #0
 #else
-2: TUSER(ldrb)	r2, [r0], #1
-3: TUSER(ldrb)	r3, [r0]
+rb	.req	r0
+2:	ldrb	r2, [r0]
+3:	ldrb	rb, [r0, #1]
 #endif
 #ifndef __ARMEB__
-	orr	r2, r2, r3, lsl #8
+	orr	r2, r2, rb, lsl #8
 #else
-	orr	r2, r3, r2, lsl #8
+	orr	r2, rb, r2, lsl #8
 #endif
 	mov	r0, #0
 	mov	pc, lr
 ENDPROC(__get_user_2)
 
 ENTRY(__get_user_4)
+	check_uaccess r0, 4, r1, r2, __get_user_bad
 4: TUSER(ldr)	r2, [r0]
 	mov	r0, #0
 	mov	pc, lr
diff --git a/arch/arm/lib/putuser.S b/arch/arm/lib/putuser.S
index 7db25990..3d73dcb9 100644
--- a/arch/arm/lib/putuser.S
+++ b/arch/arm/lib/putuser.S
@@ -16,6 +16,7 @@
  * __put_user_X
  *
  * Inputs:	r0 contains the address
+ *		r1 contains the address limit, which must be preserved
  *		r2, r3 contains the value
  * Outputs:	r0 is the error code
  *		lr corrupted
@@ -27,16 +28,19 @@
  * Note also that it is intended that __put_user_bad is not global.
  */
 #include <linux/linkage.h>
+#include <asm/assembler.h>
 #include <asm/errno.h>
 #include <asm/domain.h>
 
 ENTRY(__put_user_1)
+	check_uaccess r0, 1, r1, ip, __put_user_bad
 1: TUSER(strb)	r2, [r0]
 	mov	r0, #0
 	mov	pc, lr
 ENDPROC(__put_user_1)
 
 ENTRY(__put_user_2)
+	check_uaccess r0, 2, r1, ip, __put_user_bad
 	mov	ip, r2, lsr #8
 #ifdef CONFIG_THUMB2_KERNEL
 #ifndef __ARMEB__
@@ -60,12 +64,14 @@ ENTRY(__put_user_2)
 ENDPROC(__put_user_2)
 
 ENTRY(__put_user_4)
+	check_uaccess r0, 4, r1, ip, __put_user_bad
 4: TUSER(str)	r2, [r0]
 	mov	r0, #0
 	mov	pc, lr
 ENDPROC(__put_user_4)
 
 ENTRY(__put_user_8)
+	check_uaccess r0, 8, r1, ip, __put_user_bad
 #ifdef CONFIG_THUMB2_KERNEL
 5: TUSER(str)	r2, [r0]
 6: TUSER(str)	r3, [r0, #4]
diff --git a/arch/arm/mach-mmp/Kconfig b/arch/arm/mach-mmp/Kconfig
index 5a90b9a3..6503341c 100644
--- a/arch/arm/mach-mmp/Kconfig
+++ b/arch/arm/mach-mmp/Kconfig
@@ -2,16 +2,6 @@ if ARCH_MMP
 
 menu "Marvell PXA168/910/MMP2 Implmentations"
 
-config MACH_MMP_DT
-	bool "Support MMP2 platforms from device tree"
-	select CPU_PXA168
-	select CPU_PXA910
-	select USE_OF
-	help
-	  Include support for Marvell MMP2 based platforms using
-	  the device tree. Needn't select any other machine while
-	  MACH_MMP_DT is enabled.
-
 config MACH_ASPENITE
 	bool "Marvell's PXA168 Aspenite Development Board"
 	select CPU_PXA168
@@ -94,6 +84,224 @@ config MACH_GPLUGD
 	  Say 'Y' here if you want to support the Marvell PXA168-based
 	  GuruPlug Display (gplugD) Board
 
+config MACH_YELLOWSTONE
+	bool "Marvell's MMP3 YellowStone Development Board"
+	select CPU_MMP3
+	select HAVE_PWM
+	help
+	  Say 'Y' here if you want to support the Marvell MMP3-based
+	  YellowStone Development Board
+
+config MACH_MMP_DT
+	bool "Support MMP (ARMv5) platforms from device tree"
+	select CPU_PXA168
+	select CPU_PXA910
+	select USE_OF
+	help
+	  Include support for Marvell MMP2 based platforms using
+	  the device tree. Needn't select any other machine while
+	  MACH_MMP_DT is enabled.
+
+config MACH_MMP2_DT
+	bool "Support MMP2 (ARMv7) platforms from device tree"
+	depends on !CPU_MOHAWK
+	select CPU_MMP2
+	select USE_OF
+	help
+	  Include support for Marvell MMP2 based platforms using
+	  the device tree.
+
+config MACH_EMEIDKB
+	bool "Marvell's PXA988 Emei DKB Development Board"
+	select CPU_PXA988
+	select ARCH_NEEDS_CPU_IDLE_COUPLED
+	select HAVE_PWM
+	help
+	  Say 'Y' here if you want to support the Marvell PXA988-based
+	  EMEIDKB Development Board.
+	  EMEIDKB board is an evalutation board, not phone like.
+
+config MACH_ARUBA_TD
+	bool "Samsung's PXA988 ARUBA Development Board"
+	select CPU_PXA988
+	help
+	  Say 'Y' here if you want to support the Marvell PXA988-based
+	  ARUBA_TD Development Board.
+
+config MACH_WARUBA
+     bool "Samsung's PXA986 WARUBA Development Board"
+     select CPU_PXA988
+     help
+       Say 'Y' here if you want to support the Marvell PXA986-based
+       WARUBA Development Board.
+
+config MACH_HARRISON
+     bool "Samsung's PXA986 WARUBA Development Board"
+     select CPU_PXA988
+     select HAVE_PWM
+     help
+       Say 'Y' here if you want to support the Marvell PXA986-based
+       HARRISON Development Board.
+       
+ config MACH_LT02
+	bool "Samsung's PXA986 LT02 Development Board"
+	select CPU_PXA988
+	select HAVE_PWM
+	help
+		Say 'Y' here if you want to support the Marvell PXA986-based
+		LT02 Development Board.      
+
+config MACH_HELANDKB
+	bool "Marvell's PXA1088 Helan DKB Development Board"
+	select CPU_PXA1088
+	help
+	  Say 'Y' here if you want to support the Marvell PXA1088-based
+	  HELANDKB Development Board.
+	  HELANDKB board is an evalutation board, not phone like.
+
+config MACH_DELOS3GVIA
+	bool "Samsung's PXA1088 Helan DELOS Development Board"
+	select CPU_PXA1088
+	help
+	  Say 'Y' here if you want to support the Samsung PXA1088-based
+	  HELANDELOS Development Board.
+	  HELANDELOS board is an evalutation board, not phone like.
+	  
+config MACH_HELANDELOS
+	bool "Samsung's PXA1088 Helan DELOS Development Board"
+	select CPU_PXA1088
+	help
+	  Say 'Y' here if you want to support the Samsung PXA1088-based
+	  HELANDELOS Development Board.
+	  HELANDELOS board is an evalutation board, not phone like.
+
+config MACH_CS05
+	bool "Samsung's PXA1088 CS05 Development Board"
+	select CPU_PXA1088
+	help
+	  Say 'Y' here if you want to support the Samsung PXA1088-based
+	  CS05 Development Board.
+	  CS05 board is an evalutation board, not phone like.
+	  
+config CS05_CAMERA_REV02
+    bool "Samsung's PXA1088 CS05 Development Board"
+    select CPUX_PXA1088
+    help
+      Say 'Y' here if you want to support the Samsung PXA1088-based
+      CS05 Revision 02 Development Board for Camera.
+      CS05 board is an evalutation board, not phone like.
+
+config MACH_WILCOX
+	bool "Samsung's PXA1088 WILCOX Development Board"
+	select CPU_PXA1088
+	help
+	  Say 'Y' here if you want to support the Samsung PXA1088-based
+	  WILCOX Development Board.
+	  WILCOX board is an evalutation board, not phone like.
+
+config MACH_DEGAS
+	bool "Samsung's PXA1088 DEGAS Development Board"
+	select CPU_PXA1088
+	help
+	  Say 'Y' here if you want to support the Samsung PXA1088-based
+	  DEGAS Development Board.
+	  DEGAS board is an evalutation board, not phone like.	  
+
+config MACH_CT01
+	bool "Samsung's PXA1088 CT01 Development Board"
+	select CPU_PXA1088
+	help
+	  Say 'Y' here if you want to support the Samsung PXA1088-based
+	  CT01 Development Board.
+	  CT01 board is an evalutation board, not phone like.
+	  
+config MACH_WILCOX_CMCC
+	bool "Samsung's PXA1088 WILCOX Development Board"
+	select CPU_PXA1088
+	help
+	  Say 'Y' here if you want to support the Samsung PXA1088-based
+	  WILCOX Development Board.
+	  WILCOX board is an evalutation board, not phone like.
+	  
+config MACH_CS02
+	bool "Samsung's PXA986 CS02 Development Board"
+	select CPU_PXA988
+	select ARCH_NEEDS_CPU_IDLE_COUPLED
+	help
+	  Say 'Y' here if you want to support the Samsung PXA988-based
+	  CS02 Development Board.
+	  CS02 board is an evalutation board, not phone like.
+
+config MACH_GOLDEN
+	bool "Samsung's PXA986 GOLDEN Development Board"
+	select CPU_PXA988
+	select ARCH_NEEDS_CPU_IDLE_COUPLED
+	help
+	  Say 'Y' here if you want to support the Samsung PXA986-based
+	  GOLDEN Development Board.
+
+config MACH_GOYA
+	bool "Samsung's PXA986 GOYA Development Board"
+	select CPU_PXA988
+	select ARCH_NEEDS_CPU_IDLE_COUPLED
+	help
+	  Say 'Y' here if you want to support the Samsung PXA986-based
+	  GOYA Development Board.
+
+config MACH_GOYA_USA
+        bool "Samsung's PXA986 GOYA Development Board"
+        select CPU_PXA988
+        select ARCH_NEEDS_CPU_IDLE_COUPLED
+        help
+          Say 'Y' here if you want to support the Samsung PXA986-based
+          GOYA USA Development Board.
+	  
+config MACH_BAFFIN
+	bool "Samsung's PXA986 BAFFIN Development Board"
+	select CPU_PXA988
+	select ARCH_NEEDS_CPU_IDLE_COUPLED
+	help
+	  Say 'Y' here if you want to support the Samsung PXA1088-based
+	  BAFFIN Development Board.
+	  BAFFIN board is an evalutation board, not phone like.
+
+config MACH_BAFFINQ
+	bool "Samsung's PXA1088 BAFFIN Lite Development Board"
+	select CPU_PXA1088
+	help
+	  Say 'Y' here if you want to support the Samsung PXA1088-based
+	  BAFFIN Lite Development Board.
+	  BAFFIN Lite board is an evalutation board, not phone like.
+
+config MACH_BAFFINQ_CMCC
+	bool "Samsung's PXA1088 BAFFINQ Development Board"
+	select CPU_PXA1088
+	help
+	  Say 'Y' here if you want to support the Samsung PXA1088-based
+	  BAFFINQ Development Board.
+	  BAFFINQ board is an evalutation board, not phone like.
+
+config FAKE_SYSTEMOFF
+        bool "Marvell's MABOS support"
+        depends on SUSPEND
+        help
+	  MABOS: Marvell Android Bootup Optimization Solution
+	  It is used to support phone fast power on feature, this feature
+	  is based on system suspend.
+
+config MACH_EDEN_FPGA
+	bool "Marvell's EDEN FPGA Development Board"
+	select CPU_EDEN
+	help
+	  Say 'Y' here if you want to support the Marvell EDEN-based
+	  FPGA Board.
+
+config GIC_BYPASS
+	bool "Bypass GIC and use ICU as Primary Interrupt Controller"
+	depends on CPU_EDEN
+	help
+	  Say 'Y' here to use ICU as Primary Interrupt Controller
+
 endmenu
 
 config CPU_PXA168
@@ -108,9 +316,302 @@ config CPU_PXA910
 	help
 	  Select code specific to PXA910
 
+config CPU_PXA988
+	bool
+	select CPU_CA9MP
+	select SOC_LOCAL_TIMERS
+	select MIGHT_HAVE_CACHE_L2X0
+	select ARCH_PROVIDES_UDELAY
+	select ARM_HAS_SG_CHAIN
+	select EOF_FC_WORKAROUND
+	select DISP_DFC
+	select CORESIGHT_SUPPORT
+	select BOOST_SUPPORT
+	select SMP_HARDLOCKUP_DETECTOR
+	help
+	  Say 'Y' here if you want to support the Marvell pxa988-base
+	  platforms.
+	  The PXA988 is an SoC with dual-core Cotex-A9 and comunication
+	  processor, code name "Emei".
+
+config CPU_PXA1088
+	bool
+	select CPU_CA7MP
+	select ARCH_PROVIDES_UDELAY
+	select ARM_HAS_SG_CHAIN
+	select EOF_FC_WORKAROUND
+	select DISP_DFC
+	select CORESIGHT_SUPPORT
+	select DDR_FC_HARDWARE
+	select BOOST_SUPPORT
+	select SMP_HARDLOCKUP_DETECTOR
+	help
+	  Say 'Y' here if you want to support the Marvell pxa1088-base
+	  platforms.
+	  The PXA1088 is an SoC with quad-core Cotex-A7 and comunication
+	  processor, code name "Helan".
+
 config CPU_MMP2
 	bool
 	select CPU_PJ4
 	help
 	  Select code specific to MMP2. MMP2 is ARMv7 compatible.
+
+config CPU_MMP3
+	bool
+	select CACHE_TAUROS3
+	select CPU_PJ4B
+	select ARM_GIC
+	select HAVE_SMP
+	select LOCAL_TIMERS if SMP
+	help
+	  Select code specific to MMP3. MMP3 is ARMv7 compatible, and support SMP.
+
+config CPU_EDEN
+	bool
+	select CPU_CA7MP
+	select ARCH_PROVIDES_UDELAY
+	select ARM_HAS_SG_CHAIN
+	help
+	  Support for EDEN processors based on the ARM Cortex-A7 MP CPU.
+	  Select code specific to EDEN
+
+config CPU_CA9MP
+	bool
+	select CPU_V7
+	select ARM_GIC
+	select HAVE_SMP
+	help
+	  Select code specific to Cortex A9
+
+config CPU_CA7MP
+	bool
+	select CPU_V7
+	select ARM_GIC
+	select HAVE_SMP
+	help
+	  Select code specific to Cortex A7
+
+config USB_EHCI_MV_U2O
+        bool "EHCI support for PXA USB OTG controller"
+	depends on USB_EHCI_MV
+	help
+	  Enables support for OTG controller which can be switched to host mode.
+
+config EOF_FC_WORKAROUND
+	bool
+	help
+	  Enables EOF workaround for DDR freq-change.
+
+config DISP_DFC
+	bool
+	help
+	  Enables display dynamic frequency change to avoid EMI.
+
+config CORE_1248
+	bool "Enable 1248M cpu frequency"
+	help
+	  Support 1248M PLL1 cpu frequency or not
+
+config DDR_FC_HARDWARE
+	bool
+	help
+	  Enables hw DFC in LCD V-Blank feature
+
+config CORESIGHT_SUPPORT
+	bool "support coresight features"
+	depends on CPU_PM
+	help
+	  Support coresight features such as dump pcsr, trigger panic etc.
+
+config CORESIGHT_TRACE_SUPPORT
+	bool "support save/restore coresight trace setting when enter/exit LPM"
+	depends on CPU_PM && CORESIGHT_SUPPORT
+	help
+	  Enables support save/restore coresight trace setting when enter/exit LPM.
+
+config APB_LOCALTIMER
+        bool "Provide localtimer support using apb timers"
+        help
+          Enables localtimer using apb timers
+
+config TZ_HYPERVISOR
+	bool "Enable TrustZone security feature"
+	help
+	  This option enables TrustZone security feature. With TrustZone
+	  enabled, the kernel will run under non-secure state and access
+	  secure resources via TZLC (TrustZone light calling).
+
+config BOOST_SUPPORT
+	bool "support touch boost feature"
+	help
+	  Enables support touch boost feature.
+
+
+config RECOVERY_KERNEL
+        bool "reset reboot-recovery flag on each reboot"
+        help
+          Build a kernel that, by default, resets reboot-recovery flag
+          and prevent us to be stuck on recovery (useful for custom recoveries)
+
+choice
+	prompt "Support dynamic CPU Hotplug"
+	depends on HOTPLUG_CPU
+	default NO_HOTPLUG_POLICY
+
+config MMP_ORIGINAL_POLICY
+	bool "MMP dual core Hotplug policy"
+	depends on CPU_PXA988
+	help
+	  PM hotplug policy.
+	  This hotplug policy is first used policy on MMP platform.
+
+config STAND_ALONE_POLICY
+	bool "Stand alone CPU hotplug policy"
+	help
+	  PM hotplug policy.
+	  Enable to use pm hotplug, then it uses stand-hotplug.c file.
+	  Avg-load is calculated with both cpu frequency aspect
+	  and run queue status.
+
+config NO_HOTPLUG_POLICY
+	bool "NO automatic CPU hotplug policy"
+	help
+	  PM hotplug policy
+	  Do not select an automatic hotplug policy
+endchoice
+
+config SEC_MODEM
+	bool "Samsung Modem driver"
+
+if SEC_MODEM
+comment "Samsung Modem Feature"
+
+config SEC_MODEM_DELOS3GVIA
+	bool "PXA1088 with CBP82 PLD_SPI"
+
+config CDMA_MODEM_CBP82
+	bool "modem chip : VIA CBP8.2"
+
+config LINK_DEVICE_PLD
+	bool "modem driver link device PLD"
+
+config ONECHIP_DUAL_MODEM
+	bool "(AP+CP)+CP2"
+	default n
+endif
+
+endif
+
+comment "Debugging Feature"
+menuconfig SEC_DEBUG
+	bool "Samsung TN Ramdump Feature"
+	default y
+	help
+	  Samsung TN Ramdump Feature. Use INFORM3 and magic number at 0xc0000000.
+
+if SEC_DEBUG
+config SEC_DEBUG_SCHED_LOG
+	bool "Samsung Scheduler Logging Feature"
+	default n
+	help
+	  Samsung Scheduler Logging Feature for Debug use.
+
+config SEC_DEBUG_SOFTIRQ_LOG
+	bool "Samsung Softirq Logging Feature"
+	default n
+	depends on SEC_DEBUG_SCHED_LOG
+	help
+	  Samsung Softirq Logging Feature for Debug use.
+	  This option enables us to log softirq enter/exit.
+	  It is not only hard-irq which results in scheduler lockup,
+	  To be more clear we need to see also softirq logs.
+
+config SEC_DEBUG_TIMER_LOG
+	bool "Samsung Timer Logging Feature"
+	default n
+	help
+	  Samsung Timer Logging Feature for Debug use.
+
+config SEC_LOG
+	bool "Samsung log buffer"
+	default n
 endif
+
+comment "Samsung TN Power Management Options"
+menuconfig SEC_PM
+	bool "Samsung TN Power Management"
+	default n
+	help
+		Samsung TN Power Management.
+
+if SEC_PM
+config SEC_PM_DEBUG
+	bool "Enable Samsung TN Power Management debug support"
+	default n
+	help
+		Enable Samsung TN Power Management debug support.
+endif
+
+config SEC_THERMISTOR
+	bool "Use external thermistor with ADC"
+	depends on CPU_PXA1088
+	default n
+	help
+	  Use thermistor driver to check system temperature
+
+config SEC_THERMISTOR
+	bool "Use external thermistor with ADC"
+	depends on CPU_PXA988
+	default n
+	help
+	  Use thermistor driver to check system temperature
+
+config SEC_TEMP_BOARD
+	bool "Use TEMP_BOARD thermistor"
+	default n
+	depends on SEC_THERMISTOR
+	help
+	  Use TEMP_BOARD thermistor instead of TEMP_RF for temperature
+
+#
+# Near Field Communication (NFC) devices
+#
+
+config NFC_PN544
+        bool "NXP PN544 NFC Controller Driver"
+        default n
+        help
+          NXP PN544 Near Field Communication controller support.
+          This option enables device driver support for the NFC.
+          It is used by many services. NFC is fully controlled using I2C
+          to communicate the AP chip.
+
+config NFC_PN547
+        bool "NXP PN547 NFC Controller Driver"
+        default n
+        help
+          NXP PN547 Near Field Communication controller support.
+          This option enables device driver support for the NFC.
+          It is used by many services. NFC is fully controlled using I2C
+          to communicate the AP chip.
+          
+config GOYA_BD_00
+	bool "GOYA Galaxy tap3 rev00 common Board"
+	default n
+
+config GOYA_BD_01
+	bool "GOYA Galaxy tap3 common Board"
+	default n
+
+config GOYA_WIFI
+	bool "GOYA Galaxy tap3 WIFI Board"
+	default n	
+
+config CS05_BD_00
+	bool "SM-G3858 Lumiere rev00 board"
+	default n
+
+config CS05_BD_02
+	bool "SM-G3858 Lumiere rev02 board"
+	default n
diff --git a/arch/arm/mach-mmp/Makefile b/arch/arm/mach-mmp/Makefile
index 4fc0ff5d..b4d080c4 100644
--- a/arch/arm/mach-mmp/Makefile
+++ b/arch/arm/mach-mmp/Makefile
@@ -2,12 +2,63 @@
 # Makefile for Marvell's PXA168 processors line
 #
 
-obj-y				+= common.o clock.o devices.o time.o
+obj-y				+= common.o mmp_device.o devices.o pmu.o reset.o onboard/
+
+obj-$(CONFIG_TZ_HYPERVISOR)	+= tzlc/
 
 # SoC support
-obj-$(CONFIG_CPU_PXA168)	+= pxa168.o irq-pxa168.o
-obj-$(CONFIG_CPU_PXA910)	+= pxa910.o irq-pxa168.o
-obj-$(CONFIG_CPU_MMP2)		+= mmp2.o irq-mmp2.o sram.o
+obj-$(CONFIG_CPU_PXA168)	+= pxa168.o irq.o clock.o time.o
+obj-$(CONFIG_CPU_PXA910)	+= pxa910.o irq.o clock.o sram.o time.o
+obj-$(CONFIG_CPU_PXA988)	+= pxa988.o clock-pxa988.o wakeupgen.o sram.o time.o \
+acpuclock-pxa988.o dvfs-pxa988.o gpio-edge.o helpfunc_v7.o pxa988_lowpower.o reset-pxa988.o
+obj-$(CONFIG_CPU_PXA1088)	+= pxa988.o clock-pxa988.o wakeupgen.o sram.o \
+acpuclock-pxa988.o dvfs-pxa988.o gpio-edge.o helpfunc_v7.o pxa988_lowpower.o reset-pxa988.o
+
+ifeq ($(CONFIG_APB_LOCALTIMER),y)
+obj-$(CONFIG_CPU_PXA1088)       += time-apb.o
+else
+obj-$(CONFIG_CPU_PXA1088)       += time.o
+endif
+
+obj-$(CONFIG_CPU_MMP2)		+= mmp2.o sram.o irq.o clock.o time.o
+obj-$(CONFIG_CPU_MMP3)		+= mmp3.o irq-mmp3.o clock-mmp3.o time.o\
+sram.o
+obj-$(CONFIG_CPU_EDEN)		+= eden.o sram.o clock-eden.o reset-eden.o helpfunc_v7.o time-eden.o
+ifeq ($(CONFIG_CPU_EDEN),y)
+ifeq ($(CONFIG_GIC_BYPASS),y)
+obj-y				+= irq-eden-icu.o
+else
+obj-y				+= irq-eden.o
+endif
+endif
+
+ifeq ($(CONFIG_SMP),y)
+obj-$(CONFIG_CPU_MMP3)		+= platsmp.o mmp3_headsmp.o reset-mmp3.o
+obj-$(CONFIG_CPU_PXA988)	+= platsmp.o pxa988_headsmp.o
+obj-$(CONFIG_CPU_PXA1088)	+= platsmp.o pxa988_headsmp.o
+obj-$(CONFIG_CPU_EDEN)		+= platsmp.o eden_headsmp.o
+endif
+
+ifeq ($(CONFIG_PM),y)
+obj-$(CONFIG_CPU_PXA910)	+= pm-pxa910.o
+obj-$(CONFIG_CPU_MMP2)		+= pm-mmp2.o
+obj-$(CONFIG_CPU_PXA988)	+= sleep-pxa988.o
+obj-$(CONFIG_CPU_PXA1088)	+= sleep-pxa988.o
+obj-$(CONFIG_CPU_EDEN)		+= pm-eden.o
+endif
+
+ifeq ($(CONFIG_CPU_IDLE),y)
+obj-$(CONFIG_CPU_PXA988)	+= cpuidle-pxa988.o
+obj-$(CONFIG_CPU_PXA1088)	+= cpuidle-pxa988.o
+endif
+
+ifeq ($(CONFIG_SUSPEND),y)
+obj-$(CONFIG_CPU_PXA988)        += pm-pxa988.o
+obj-$(CONFIG_CPU_PXA1088)        += pm-pxa988.o
+endif
+
+# fake system off feature base on suspend
+obj-$(CONFIG_FAKE_SYSTEMOFF)	+= fake-sysoff.o
 
 # board support
 obj-$(CONFIG_MACH_ASPENITE)	+= aspenite.o
@@ -19,5 +70,90 @@ obj-$(CONFIG_MACH_BROWNSTONE)	+= brownstone.o
 obj-$(CONFIG_MACH_FLINT)	+= flint.o
 obj-$(CONFIG_MACH_MARVELL_JASPER) += jasper.o
 obj-$(CONFIG_MACH_MMP_DT)	+= mmp-dt.o
+obj-$(CONFIG_MACH_MMP2_DT)	+= mmp2-dt.o
 obj-$(CONFIG_MACH_TETON_BGA)	+= teton_bga.o
 obj-$(CONFIG_MACH_GPLUGD)	+= gplugd.o
+obj-$(CONFIG_MACH_YELLOWSTONE)	+= yellowstone.o
+obj-$(CONFIG_MACH_EMEIDKB)	+= board-emeidkb.o
+obj-$(CONFIG_MACH_ARUBA_TD)	+= board-aruba.o sec-common.o
+obj-$(CONFIG_MACH_WARUBA)	+= board-waruba.o sec-common.o
+obj-$(CONFIG_MACH_HARRISON)	+= board-harrison.o sec-common.o
+obj-$(CONFIG_MACH_HELANDKB)	+= board-helandkb.o
+obj-$(CONFIG_MACH_LT02)		+= board-lt02-pins.o board-lt02.o samsung_camera_lt02.o sec-common.o  \
+							   board-lt02-regulators.o  board-lt02-battery.o
+ifeq ($(CONFIG_MACH_DELOS3GVIA),y)
+obj-$(CONFIG_MACH_DELOS3GVIA)	+= board-delos3gvia.o sec-common.o samsung_camera_via.o
+else
+obj-$(CONFIG_MACH_HELANDELOS)	+= board-delos.o sec-common.o samsung_camera.o
+endif
+
+ifeq ($(CONFIG_MACH_CS05),y)
+obj-$(CONFIG_MACH_CS05)	+= board-cs05.o board-cs05-battery.o sec-common.o samsung_camera_cs05.o
+else
+ifeq ($(CONFIG_MACH_DEGAS),y)
+obj-$(CONFIG_MACH_DEGAS)	+= board-degas.o board-degas-battery.o board-degas-input.o sec-common.o samsung_camera_degas.o
+else
+obj-$(CONFIG_MACH_WILCOX)	+= board-wilcox.o board-wilcox-battery.o sec-common.o samsung_camera.o
+endif
+endif
+
+ifeq ($(CONFIG_MACH_CS02),y)
+obj-y		+= board-cs02.o board-cs02-battery.o sec-common.o
+obj-$(CONFIG_SOC_CAMERA_S5K4ECGX)	+=samsung_camera.o
+obj-$(CONFIG_SOC_CAMERA_SR352)	+= samsung_camera_cs02.o
+endif
+
+ifeq ($(CONFIG_MACH_GOLDEN),y)
+obj-y		+= board-golden.o board-golden-battery.o sec-common.o board-golden-input.o
+obj-$(CONFIG_SOC_CAMERA_S5K4ECGX)	+=samsung_camera_golden.o
+endif
+
+ifeq ($(CONFIG_MACH_GOYA),y)
+obj-y		+= board-goya.o board-goya-battery.o sec-common.o board-goya-input.o
+obj-$(CONFIG_SOC_CAMERA_SR200PC20M)	+=samsung_camera_goya.o
+endif
+
+ifeq ($(CONFIG_MACH_BAFFIN),y)
+obj-y		+= board-baffin.o board-baffin-battery.o sec-common.o samsung_camera.o
+obj-$(CONFIG_SOC_CAMERA_S5K4ECGX)	+=samsung_camera.o
+obj-$(CONFIG_SOC_CAMERA_SR352)	+= samsung_camera_baffin.o
+endif
+
+ifeq ($(CONFIG_MACH_BAFFINQ),y)
+obj-y		+= board-baffinq.o board-baffinq-battery.o sec-common.o
+obj-$(CONFIG_SOC_CAMERA_S5K4ECGX)	+=samsung_camera.o
+endif
+
+obj-$(CONFIG_MACH_EDEN_FPGA)	+= eden_fpga.o
+obj-$(CONFIG_GPU_RESERVE_MEM)   += gpu_mem.o
+
+# feature for tsp
+obj-$(CONFIG_TOUCHSCREEN_MXT336S)	+=board_input_mxt.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_TMA46X)	+=board-touch-cyttsp4_core.o
+obj-$(CONFIG_TOUCHSCREEN_MELFAS_MMS144)	+=board-tsp-mms144.o
+
+ifeq ($(CONFIG_HOTPLUG_CPU),y)
+obj-$(CONFIG_CPU_PXA988)        += pxa988_hotplug.o
+obj-$(CONFIG_CPU_PXA1088)        += pxa988_hotplug.o
+obj-$(CONFIG_CPU_MMP3)		+= mmp3_hotplug.o
+obj-$(CONFIG_CPU_EDEN)		+= eden_hotplug.o
+obj-$(CONFIG_MMP_ORIGINAL_POLICY)        += pm-hotplug-dual.o
+obj-$(CONFIG_STAND_ALONE_POLICY)        += stand-hotplug.o
+endif
+
+obj-$(CONFIG_MEMORY_HOTPLUG)	+= mem_hotplug_handler.o
+
+obj-$(CONFIG_MFD_RT5033)		+= board-golden-mfd.o
+
+# coresight support
+obj-$(CONFIG_CORESIGHT_SUPPORT)	+= coresight-v7.o
+obj-$(CONFIG_SEC_MODEM_DELOS3GVIA) += board-delos3gvia-modems.o
+
+# touchboost support
+obj-$(CONFIG_BOOST_SUPPORT)    += boost.o
+
+# sec debug support
+obj-$(CONFIG_SEC_DEBUG)		+= sec_debug.o
+obj-$(CONFIG_SEC_LOG)		+= sec_log.o
+
+obj-$(CONFIG_SEC_THERMISTOR) += sec_thermistor.o
diff --git a/arch/arm/mach-mmp/Makefile.boot b/arch/arm/mach-mmp/Makefile.boot
index 5edf03e2..be454dd2 100644
--- a/arch/arm/mach-mmp/Makefile.boot
+++ b/arch/arm/mach-mmp/Makefile.boot
@@ -1 +1,12 @@
-   zreladdr-y	+= 0x00008000
+ifeq ($(CONFIG_CRASH_DUMP),y)
+	__ADDRBASE := 0x06000000
+else ifeq ($(CONFIG_TZ_HYPERVISOR),y)
+	__ADDRBASE := 0x01000000
+else
+	__ADDRBASE := 0x00000000
+endif
+
+__ZRELADDR := $(shell /bin/bash -c 'printf "0x%08x" \
+	$$[$(TEXT_OFFSET) + $(__ADDRBASE)]')
+
+zreladdr-y := $(__ZRELADDR)
diff --git a/arch/arm/mach-mmp/acpuclock-pxa988.c b/arch/arm/mach-mmp/acpuclock-pxa988.c
new file mode 100644
index 00000000..746c0d83
--- /dev/null
+++ b/arch/arm/mach-mmp/acpuclock-pxa988.c
@@ -0,0 +1,3630 @@
+/*
+ *  linux/arch/arm/mach-mmp/acpuclock-pxa988.c
+ *
+ *  Author:	Zhoujie Wu <zjwu@marvell.com>
+ *			Qiming Wu <wuqm@marvell.com>
+ *  Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ *  based on arch/arm/mach-mmp/acpuclock-pxa910.c
+ *
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+ *
+ * (C) Copyright 2012 Marvell International Ltd.
+ * All Rights Reserved
+ */
+#include <linux/cpu.h>
+#include <linux/cpufreq.h>
+#include <linux/cpumask.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <linux/err.h>
+#include <linux/hrtimer.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include <asm/io.h>
+#include <mach/cputype.h>
+#include <mach/features.h>
+#include <mach/clock-pxa988.h>
+#include <mach/pxa988_ddr.h>
+#include <mach/pxa988_lowpower.h>
+#include <mach/regs-mpmu.h>
+#include <mach/regs-apmu.h>
+#include <mach/regs-ciu.h>
+#include <mach/regs-mcu.h>
+#include <plat/debugfs.h>
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+#include <video/mmpdisp_export_funcs.h>
+#endif
+#include <mach/pxa168fb.h>
+
+#define CREATE_TRACE_POINTS
+#include <plat/pxa_trace.h>
+
+#define PANIC_SCALING_CORE_DDRAXI_TO_MIN
+
+/* core,ddr,axi clk src sel set register desciption */
+union pmum_fccr {
+	struct {
+		unsigned int pll1fbd:9;
+		unsigned int pll1refd:5;
+		unsigned int pll1cen:1;
+		unsigned int mfc:1;
+		unsigned int reserved0:3;
+		unsigned int axiclksel0:1;
+		unsigned int reserved1:3;
+		unsigned int ddrclksel:2;
+		unsigned int axiclksel1:1;
+		unsigned int seaclksel:2;
+		unsigned int i2sclksel:1;
+		unsigned int mohclksel:3;
+	} b;
+	unsigned int v;
+};
+
+/* core,ddr,axi clk src sel status register description */
+union pmua_pllsel {
+	struct {
+		unsigned int cpclksel:2;
+		unsigned int apclksel:2;
+		unsigned int ddrclksel:2;
+		unsigned int axiclksel:2;
+		unsigned int reserved0:24;
+	} b;
+	unsigned int v;
+};
+
+/* core,ddr,axi clk div and fc trigger register description */
+union pmua_cc {
+	struct {
+		unsigned int core_clk_div:3;
+		unsigned int bus_mc_clk_div:3;
+		unsigned int biu_clk_div:3;
+		unsigned int l2_clk_div:3;
+		unsigned int ddr_clk_div:3;
+		unsigned int bus_clk_div:3;
+		unsigned int async1:1;
+		unsigned int async2:1;
+		unsigned int async3:1;
+		unsigned int async3_1:1;
+		unsigned int async4:1;
+		unsigned int async5:1;
+		unsigned int core_freq_chg_req:1;
+		unsigned int ddr_freq_chg_req:1;
+		unsigned int bus_freq_chg_req:1;
+		unsigned int core_allow_spd_chg:1;
+		unsigned int core_dyn_fc:1;
+		unsigned int dclk_dyn_fc:1;
+		unsigned int aclk_dyn_fc:1;
+		unsigned int core_rd_st_clear:1;
+	} b;
+	unsigned int v;
+};
+
+/* peri clk div set register description */
+union pmua_cc2 {
+	struct {
+		unsigned int peri_clk_div:3;
+		unsigned int peri_clk_dis:1;
+		unsigned int reserved0:12;
+		unsigned int cpu0_core_rst:1;
+		unsigned int reserved1:1;
+		unsigned int cpu0_dbg_rst:1;
+		unsigned int cpu0_wdt_rst:1;
+		unsigned int cpu1_core_rst:1;
+		unsigned int reserved2:1;
+		unsigned int cpu1_dbg_rst:1;
+		unsigned int cpu1_wdt_rst:1;
+		unsigned int reserved3:8;
+	} b;
+	unsigned int v;
+};
+
+/* core,ddr,axi div status register description */
+union pmua_dm_cc {
+	struct {
+		unsigned int core_clk_div:3;
+		unsigned int bus_mc_clk_div:3;
+		unsigned int biu_clk_div:3;
+		unsigned int l2_clk_div:3;
+		unsigned int ddr_clk_div:3;
+		unsigned int bus_clk_div:3;
+		unsigned int async1:1;
+		unsigned int async2:1;
+		unsigned int async3:1;
+		unsigned int async3_1:1;
+		unsigned int async4:1;
+		unsigned int async5:1;
+		unsigned int cp_rd_status:1;
+		unsigned int ap_rd_status:1;
+		unsigned int cp_fc_done:1;
+		unsigned int ap_fc_done:1;
+		unsigned int dclk_fc_done:1;
+		unsigned int aclk_fc_done:1;
+		unsigned int reserved:2;
+	} b;
+	unsigned int v;
+};
+
+/* peri clk src sel status register description */
+union pmua_dm_cc2 {
+	struct {
+		unsigned int peri_clk_div:3;
+		unsigned int reserved:29;
+	} b;
+	unsigned int v;
+};
+
+
+#define AP_SRC_SEL_MASK		0x7
+#define UNDEF_OP		-1
+#define MHZ			(1000 * 1000)
+#define MHZ_TO_KHZ		(1000)
+#define KHZ_TO_HZ		(1000)
+#define MAX_OP_NUM		8
+
+enum ddr_core_fc_type {
+	DDR_FC = 0,
+	CORE_FC,
+};
+
+/*
+ * AP clock source:
+ * 0x0 = PLL1 624 MHz
+ * 0x1 = PLL1 1248 MHz  or PLL3_CLKOUT
+ * (depending on PLL3_CR[18])
+ * 0x2 = PLL2_CLKOUT
+ * 0x3 = PLL2_CLKOUTP
+ */
+enum ap_clk_sel {
+	AP_CLK_SRC_PLL1_624 = 0x0,
+	AP_CLK_SRC_PLL1_1248 = 0x1,
+	AP_CLK_SRC_PLL2 = 0x2,
+	AP_CLK_SRC_PLL2P = 0x3,
+	AP_CLK_SRC_PLL3P = 0x11,
+};
+
+/*
+ * DDR/AXI clock source:
+ * 0x0 = PLL1 416 MHz
+ * 0x1 = PLL1 624 MHz
+ * 0x2 = PLL2_CLKOUT
+ * 0x3 = PLL2_CLKOUTP
+ */
+enum ddr_axi_clk_sel {
+	DDR_AXI_CLK_SRC_PLL1_416 = 0x0,
+	DDR_AXI_CLK_SRC_PLL1_624 = 0x1,
+	DDR_AXI_CLK_SRC_PLL2 = 0x2,
+	DDR_AXI_CLK_SRC_PLL2P = 0x3,
+};
+
+enum ddr_type {
+	LPDDR2_400M = 0,
+	LPDDR2_533M,
+	DDR3,
+};
+
+/* RTC/WTC table used for solution change rtc/wtc on the fly */
+struct cpu_rtcwtc {
+	unsigned int max_pclk;	/* max rate could be used by this rtc/wtc */
+	unsigned int l1_rtc;
+	unsigned int l2_rtc;
+};
+
+struct pxa988_cpu_opt {
+	unsigned int pclk;		/* core clock */
+	unsigned int l2clk;		/* L2 cache interface clock */
+	unsigned int pdclk;		/* DDR interface clock */
+	unsigned int baclk;		/* bus interface clock */
+	unsigned int periphclk;		/* PERIPHCLK */
+	enum ap_clk_sel ap_clk_sel;	/* core src sel val */
+	struct clk *parent;		/* core clk parent node */
+	unsigned int ap_clk_src;	/* core src rate */
+	unsigned int pclk_div;		/* core clk divider*/
+	unsigned int l2clk_div;		/* L2 clock divider */
+	unsigned int pdclk_div;		/* DDR interface clock divider */
+	unsigned int baclk_div;		/* bus interface clock divider */
+	unsigned int periphclk_div;	/* PERIPHCLK divider */
+	unsigned int l1_rtc;		/* L1 cache RTC/WTC */
+	unsigned int l2_rtc;		/* L2 cache RTC/WTC */
+	struct list_head node;
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+	unsigned int cp_pclk;		/* cp core clock */
+	unsigned int cp_busmc_clk;	/* cp bus mc clock */
+	enum ap_clk_sel cp_clk_sel;	/* cp core src sel val */
+	unsigned int cp_pclk_div;	/* cp core clk divider */
+	unsigned int cp_busmc_clk_div;	/* cp bus mc clk divider */
+	unsigned int combined_dclk;	/* combined ddr clock*/
+#endif
+};
+
+struct pxa988_ddr_axi_opt {
+	unsigned int dclk;		/* ddr clock */
+	unsigned int ddr_tbl_index;	/* ddr FC table index */
+	unsigned int aclk;		/* axi clock */
+	enum ddr_axi_clk_sel ddr_clk_sel;/* ddr src sel val */
+	enum ddr_axi_clk_sel axi_clk_sel;/* axi src sel val */
+	unsigned int ddr_clk_src;	/* ddr src rate */
+	unsigned int axi_clk_src;	/* axi src rate */
+	struct clk *ddr_parent;		/* ddr clk parent node */
+	struct clk *axi_parent;		/* axi clk parent node */
+	unsigned int dclk_div;		/* ddr clk divider */
+	unsigned int aclk_div;		/* axi clk divider */
+};
+
+/*
+ * Below struct is used to describe cpu, ddr type and the corresponding
+ * OPs used for the platform. chipid and ddrtype actually is SW flag.
+ * 1. As HW chipid maybe the same in different chips, fuseid and chipid
+ * is used to together to identify the differnet chip.
+ * SW could hack below chipid to any value, as long as we could match
+ * the chip and corresponding ops.
+ * 2. DDRtype is neccessary, as we may use the same chip with different
+ * DDR in different platform, such as LPDDR400 and LPDDR533. It also
+ * possible that we could NOT run up to 533M even we use LPDDR533
+ * due to silicon limitation. We could not only depend on the information
+ * read from HW. It is better that platform tell us the ddrtype. Then FC
+ * could know which DDR OPs could be used.
+ */
+struct platform_opt {
+	unsigned int cpuid;
+	unsigned int chipid;
+	enum ddr_type ddrtype;
+	char *cpu_name;
+	struct pxa988_cpu_opt *cpu_opt;
+	unsigned int cpu_opt_size;
+	/* the default max cpu rate could be supported */
+	unsigned int df_max_cpurate;
+	/* the plat rule for filter core ops */
+	bool (*is_cpuop_invalid_plt)(struct pxa988_cpu_opt *cop);
+	struct pxa988_ddr_axi_opt *ddr_axi_opt;
+	unsigned int ddr_axi_opt_size;
+};
+
+/* DDR fc table: 0 - non flag; 1 - pause flag; 2 - end flag */
+enum ddr_fc_table_flag {
+	DDR_FC_TABLE_NONE = 0,
+	DDR_FC_TABLE_PAUSE = 1,
+	DDR_FC_TABLE_END = 2,
+};
+
+struct ddr_fc_table_cmd {
+	unsigned int reg;
+	unsigned int val;
+	enum ddr_fc_table_flag flag;
+};
+
+/* mutex lock protecting frequency change */
+static DEFINE_MUTEX(core_freqs_mutex);
+static DEFINE_MUTEX(ddr_freqs_mutex);
+static DEFINE_SPINLOCK(fc_seq_lock);
+
+/* current platform OP struct */
+static struct platform_opt *cur_platform_opt;
+
+static LIST_HEAD(core_op_list);
+
+/* current core OP */
+static struct pxa988_cpu_opt *cur_cpu_op;
+
+/* current DDR/AXI OP */
+static struct pxa988_ddr_axi_opt *cur_ddraxi_op;
+
+/* record DDR request from CP, only for debugfs show function */
+static bool cp_reset_block_ddr_fc;
+
+static void get_cur_cpu_op(struct pxa988_cpu_opt *cop);
+static void get_cur_ddr_axi_op(struct pxa988_ddr_axi_opt *cop);
+
+static struct clk pxa988_ddr_clk;
+
+static unsigned int uichipProfile;
+int is_pxa988a0svc;
+int is_pxa986a0svc;
+
+#ifdef CONFIG_DEBUG_FS
+static DEFINE_PER_CPU(struct clk_dc_stat_info, cpu_dc_stat);
+static unsigned int pm_dro_status;
+static struct idle_dcstat_info idle_dcstat_info;
+static spinlock_t allidle_lock;
+static spinlock_t c1c2_enter_lock;
+static spinlock_t c1c2_exit_lock;
+#endif
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+static int ddr_fc_failure = 0;
+static struct pxa988_ddr_axi_opt *md_new_eof, *md_old_eof;
+DECLARE_COMPLETION(ddr_eof_complete);
+atomic_t ddr_fc_trigger = ATOMIC_INIT(0);
+atomic_t disable_c2 = ATOMIC_INIT(0);
+#endif
+
+#ifdef PANIC_SCALING_CORE_DDRAXI_TO_MIN
+static atomic_t panic_disable_fc = ATOMIC_INIT(0);
+#endif
+
+/* parameter passed from cmdline to identify DDR mode */
+int ddr_mode;
+
+/* parameter passed from cmdline to ignore some PPs */
+#define MAX_PP_NUM	10
+static unsigned int pp_disable[MAX_PP_NUM];
+static unsigned int pp_discnt;
+
+/*
+ * For 988:
+ * L2CLK = PCLK / (L2_CLK_DIV +1)
+ * BIU_CLK = L2_CLK / (BIU_CLK_DIV +1)
+ * MC_CLK = L2_CLK / (MC_CLK_DIV +1)
+ * Emei Zx:
+ * PERIPHCLK = PCLK /2 * (PERI_CLK_DIV+1)
+ * Emei Ax:
+ * PERIPHCLK = PCLK /4 * (PERI_CLK_DIV+1)
+ *
+ * FIXME:
+ * 1. pdclk/paclk can use 1:1 with l2clk when in low speed,
+ * and 1:2 when pclk is in high speed
+ * 2. For Emei Zx, PERIPHCLK is divided from pclk, the divider
+ * is even and ranges from 2~16. It is better to select a lower
+ * frequency for power saving since it does NOT have very higher
+ * frequency requirement. Current DE suggests to use pclk/8 as
+ * PERIPHCLK.
+ * 3. For Emei Ax, PERIPHCLK divider is from 4~32.
+ */
+
+/*
+ * PPs for z1z2, all are from pll2. According to DE's suggestion,
+ * PLL2 has smaller clock skew between DCLK and *_ACLK than pll1.
+ * Use safe PP combination for z1z2.
+ */
+static struct pxa988_cpu_opt pxa988_op_array_z1z2[] = {
+	{
+		.pclk = 150,
+		.l2clk = 150,
+		.pdclk = 75,
+		.baclk = 75,
+		.periphclk = 18,
+		.ap_clk_sel = AP_CLK_SRC_PLL2,
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+		.combined_dclk = 150,
+		.cp_pclk = 300,
+		.cp_busmc_clk = 150,
+		.cp_clk_sel = AP_CLK_SRC_PLL2,
+#endif
+	},
+	{
+		.pclk = 300,
+		.l2clk = 150,
+		.pdclk = 150,
+		.baclk = 150,
+		.periphclk = 37,
+		.ap_clk_sel = AP_CLK_SRC_PLL2,
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+		.combined_dclk = 150,
+		.cp_pclk = 300,
+		.cp_busmc_clk = 150,
+		.cp_clk_sel = AP_CLK_SRC_PLL2,
+#endif
+	},
+	{
+		.pclk = 600,
+		.l2clk = 300,
+		.pdclk = 300,
+		.baclk = 150,
+		.periphclk = 75,
+		.ap_clk_sel = AP_CLK_SRC_PLL2,
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+		.combined_dclk = 300,
+		.cp_pclk = 300,
+		.cp_busmc_clk = 150,
+		.cp_clk_sel = AP_CLK_SRC_PLL2,
+#endif
+	},
+	{
+		.pclk = 800,
+		.l2clk = 400,
+		.pdclk = 400,
+		.baclk = 200,
+		.periphclk = 100,
+		.ap_clk_sel = AP_CLK_SRC_PLL2P,
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+		.combined_dclk = 400,
+		.cp_pclk = 400,
+		.cp_busmc_clk = 200,
+		.cp_clk_sel = AP_CLK_SRC_PLL2,
+#endif
+	},
+#if 0
+	/*
+	 * pll3 has duty cycle issue on Z1 if its rate is higher than 800M,
+	 * disable 1G PP at first on Z1
+	 */
+	{
+		.pclk = 1000,
+		.l2clk = 500,
+		.pdclk = 250,
+		.baclk = 250,
+		.periphclk = 125,
+		.ap_clk_sel = AP_CLK_SRC_PLL3P,
+	},
+#endif
+	{
+		.pclk = 1200,
+		.l2clk = 600,
+		.pdclk = 300,
+		.baclk = 300,
+		.periphclk = 150,
+		.ap_clk_sel = AP_CLK_SRC_PLL2,
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+		.combined_dclk = 300,
+		.cp_pclk = 300,
+		.cp_busmc_clk = 150,
+		.cp_clk_sel = AP_CLK_SRC_PLL2,
+#endif
+	},
+};
+
+/* The PP table only list the possible op here */
+static struct pxa988_cpu_opt pxa988_op_array_z3ax[] = {
+	{
+		.pclk = 312,
+		.l2clk = 312,
+		.pdclk = 156,
+		.baclk = 156,
+		.periphclk = 39,
+		.ap_clk_sel = AP_CLK_SRC_PLL1_624,
+	},
+	{
+		.pclk = 624,
+		.l2clk = 312,
+		.pdclk = 312,
+		.baclk = 156,
+		.periphclk = 78,
+		.ap_clk_sel = AP_CLK_SRC_PLL1_624,
+	},
+	/*
+	* pll2 vco frequency is determined by DDR, so for core,
+	* only one of 800M/1066M could be valid according to the
+	* pll2 rate
+	*/
+	{
+		.pclk = 800,
+		.l2clk = 400,
+		.pdclk = 400,
+		.baclk = 200,
+		.periphclk = 100,
+		.ap_clk_sel = AP_CLK_SRC_PLL2,
+	},
+	{
+		.pclk = 1066,
+		.l2clk = 533,
+		.pdclk = 533,
+		.baclk = 266,
+		.periphclk = 133,
+		.ap_clk_sel = AP_CLK_SRC_PLL2,
+	},
+	/*
+	* As pll3 master frequency change is not supported, so
+	* will filter pp from pll3 according to pll3 frequency
+	*/
+#if !defined(CONFIG_CORE_1248)
+	{
+		.pclk = 1205,
+		.l2clk = 602,
+		.pdclk = 602,
+		.baclk = 301,
+		.periphclk = 150,
+		.ap_clk_sel = AP_CLK_SRC_PLL3P,
+		},		
+#else
+	
+	{
+		.pclk = 1248,
+		.l2clk = 624,
+		.pdclk = 624,
+		.baclk = 312,
+		.periphclk = 156,
+		.ap_clk_sel = AP_CLK_SRC_PLL1_1248,
+	},
+#endif	
+};
+
+static struct pxa988_cpu_opt pxa1088_op_array[] = {
+	{
+		.pclk = 156,
+		.pdclk = 78,
+		.baclk = 78,
+		.ap_clk_sel = AP_CLK_SRC_PLL1_624,
+	},
+	{
+		.pclk = 312,
+		.pdclk = 156,
+		.baclk = 156,
+		.ap_clk_sel = AP_CLK_SRC_PLL1_624,
+	},
+	{
+		.pclk = 624,
+		.pdclk = 312,
+		.baclk = 156,
+		.ap_clk_sel = AP_CLK_SRC_PLL1_624,
+	},
+	{
+		.pclk = 800,
+		.pdclk = 400,
+		.baclk = 200,
+		.ap_clk_sel = AP_CLK_SRC_PLL2,
+	},
+	{
+		.pclk = 1066,
+		.pdclk = 533,
+		.baclk = 266,
+		.ap_clk_sel = AP_CLK_SRC_PLL2,
+	},
+	{
+		.pclk = 1101,
+		.pdclk = 550,
+		.baclk = 275,
+		.ap_clk_sel = AP_CLK_SRC_PLL3P,
+	},
+	{
+		.pclk = 1183,
+		.pdclk = 591,
+		.baclk = 295,
+		.ap_clk_sel = AP_CLK_SRC_PLL3P,
+	},
+	{
+		.pclk = 1283,
+		.pdclk = 641,
+		.baclk = 320,
+		.ap_clk_sel = AP_CLK_SRC_PLL3P,
+	},
+
+};
+
+static bool is_invalid_pp_1088(struct pxa988_cpu_opt *cop)
+{
+	if (cop->pclk == 156)
+		return true;
+	return false;
+}
+
+/*
+ * 1) On Emei Z0, only support three ddr rates, be careful
+ * when changing the PP table. The table should only have
+ * three PPs and the PPs are ordered ascending.
+ * 2) Table base DDR FC is implemented. The corresponding
+ * ddr_tbl_index should be 1,3,5. If the PP tbl size is larger
+ * than 3, it will only fill the first three rates' timing to tbl 1,3,5
+ * 3) Make sure the ddr and axi rate's src sel is correct
+ * 4) FIXME: high ddr request means high axi is NOT
+ * very reasonable
+ * 5) For Z1/Z2, we use PP150/300/400 from pll2 due to MCK4
+ * sync issue. For Z3/Ax, we use PP156(pll1)/312(pll1)/400(pll2)
+ * for bringup, may have chance to support DDR533M.
+ */
+static struct pxa988_ddr_axi_opt lpddr400_axi_oparray_z1z2[] = {
+	{
+		.dclk = 150,
+		.ddr_tbl_index = 1,
+		.aclk = 150,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL2,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL2,
+	},
+	{
+		.dclk = 300,
+		.ddr_tbl_index = 3,
+		.aclk = 150,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL2,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL2,
+	},
+	{
+		.dclk = 400,
+		.ddr_tbl_index = 5,
+		.aclk = 208,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL2P,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL1_416,
+	},
+};
+
+static struct pxa988_ddr_axi_opt lpddr400_axi_oparray_z3ax[] = {
+	{
+		.dclk = 156,
+		.ddr_tbl_index = 1,
+		.aclk = 78,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+	},
+	{
+		.dclk = 312,
+		.ddr_tbl_index = 3,
+		.aclk = 156,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+	},
+	{
+		.dclk = 400,
+		.ddr_tbl_index = 5,
+		.aclk = 200,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL2P,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL2P,
+	},
+};
+
+static struct pxa988_ddr_axi_opt lpddr533_axi_oparray_z3ax[] = {
+	{
+		.dclk = 156,
+		.ddr_tbl_index = 1,
+		.aclk = 78,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+	},
+	{
+		.dclk = 312,
+		.ddr_tbl_index = 3,
+		.aclk = 156,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+	},
+	{
+		.dclk = 533,
+		.ddr_tbl_index = 5,
+		.aclk = 208,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL2P,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL1_416,
+	},
+};
+
+static struct pxa988_ddr_axi_opt lpddr400_axi_oparray_1088[] = {
+	{
+		.dclk = 156,
+		.ddr_tbl_index = 1,
+		.aclk = 78,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+	},
+	{
+		.dclk = 312,
+		.ddr_tbl_index = 3,
+		.aclk = 156,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+	},
+	{
+		.dclk = 400,
+		.ddr_tbl_index = 5,
+		.aclk = 200,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL2P,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL2P,
+	},
+};
+
+static struct pxa988_ddr_axi_opt lpddr533_axi_oparray_1088[] = {
+	{
+		.dclk = 156,
+		.ddr_tbl_index = 1,
+		.aclk = 78,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+	},
+	{
+		.dclk = 312,
+		.ddr_tbl_index = 3,
+		.aclk = 156,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL1_624,
+	},
+	{
+		.dclk = 533,
+		.ddr_tbl_index = 5,
+		.aclk = 266,
+		.ddr_clk_sel = DDR_AXI_CLK_SRC_PLL2P,
+		.axi_clk_sel = DDR_AXI_CLK_SRC_PLL2P,
+	},
+};
+static struct platform_opt platform_op_arrays[] = {
+	{
+		.cpuid = 0xc09,
+		.chipid = 0xc9280,	/* dummy chipid for Z1Z2 */
+		.ddrtype = LPDDR2_400M,
+		.cpu_name = "PXA988_Z1Z2",
+		.cpu_opt = pxa988_op_array_z1z2,
+		.cpu_opt_size = ARRAY_SIZE(pxa988_op_array_z1z2),
+		.ddr_axi_opt = lpddr400_axi_oparray_z1z2,
+		.ddr_axi_opt_size = ARRAY_SIZE(lpddr400_axi_oparray_z1z2),
+	},
+	{
+		.cpuid = 0xc09,
+		.chipid = 0xc9281,	/* dummy chipid for Z3Ax */
+		.ddrtype = LPDDR2_400M,
+		.cpu_name = "PXA988_Z3Ax",
+		.cpu_opt = pxa988_op_array_z3ax,
+		.cpu_opt_size = ARRAY_SIZE(pxa988_op_array_z3ax),
+#if !defined(CONFIG_CORE_1248)
+		.df_max_cpurate = 1205,
+#else
+		.df_max_cpurate = 1248,
+#endif
+		.ddr_axi_opt = lpddr400_axi_oparray_z3ax,
+		.ddr_axi_opt_size = ARRAY_SIZE(lpddr400_axi_oparray_z3ax),
+	},
+	{
+		.cpuid = 0xc09,
+		.chipid = 0xc9281,	/* dummy chipid for Z3Ax */
+		.ddrtype = LPDDR2_533M,
+		.cpu_name = "PXA988_Z3Ax",
+		.cpu_opt = pxa988_op_array_z3ax,
+		.cpu_opt_size = ARRAY_SIZE(pxa988_op_array_z3ax),
+#if !defined(CONFIG_CORE_1248)
+		.df_max_cpurate = 1205,
+#else
+		.df_max_cpurate = 1248,
+#endif
+		.ddr_axi_opt = lpddr533_axi_oparray_z3ax,
+		.ddr_axi_opt_size = ARRAY_SIZE(lpddr533_axi_oparray_z3ax),
+	},
+	{
+		.cpuid = 0xc07,
+		.chipid = 0xa01088,
+		.ddrtype = LPDDR2_400M,
+		.cpu_name = "PXA1088",
+		.cpu_opt = pxa1088_op_array,
+		.cpu_opt_size = ARRAY_SIZE(pxa1088_op_array),
+		.df_max_cpurate = 1183,
+		.ddr_axi_opt = lpddr400_axi_oparray_1088,
+		.ddr_axi_opt_size = ARRAY_SIZE(lpddr400_axi_oparray_1088),
+		.is_cpuop_invalid_plt = is_invalid_pp_1088,
+	},
+	{
+		.cpuid = 0xc07,
+		.chipid = 0xa01088,
+		.ddrtype = LPDDR2_533M,
+		.cpu_name = "PXA1088",
+		.cpu_opt = pxa1088_op_array,
+		.cpu_opt_size = ARRAY_SIZE(pxa1088_op_array),
+		.df_max_cpurate = 1183,
+		.ddr_axi_opt = lpddr533_axi_oparray_1088,
+		.ddr_axi_opt_size = ARRAY_SIZE(lpddr533_axi_oparray_1088),
+		.is_cpuop_invalid_plt = is_invalid_pp_1088,
+	},
+};
+
+static int __init __init_ddr_mode(char *arg)
+{
+	int n;
+	if (!get_option(&arg, &n))
+		return 0;
+	ddr_mode = n;
+	if ((ddr_mode != 0) && (ddr_mode != 1))
+		pr_info("WARNING: unknown DDR type!");
+	return 1;
+}
+__setup("ddr_mode=", __init_ddr_mode);
+
+static int removepp(char *s)
+{
+	int tbl_size = platform_op_arrays->cpu_opt_size;
+	int i, j, re_range = 0;
+	unsigned int tmp;
+
+	for (pp_discnt = 0; pp_discnt < tbl_size; pp_discnt++) {
+		pp_disable[pp_discnt] = simple_strtol(s, &s, 10);
+		s++;
+		if (!pp_disable[pp_discnt])
+			break;
+		if (pp_discnt)
+			if (pp_disable[pp_discnt] <
+				pp_disable[pp_discnt - 1])
+				re_range = 1;
+	}
+	if (!re_range)
+		return 1;
+	for (i = 0; i < pp_discnt; i++) {
+		for (j = 0; j < pp_discnt - i - 1; j++) {
+			if (pp_disable[j] > pp_disable[j + 1]) {
+				tmp = pp_disable[j];
+				pp_disable[j] = pp_disable[j + 1];
+				pp_disable[j + 1] = tmp;
+			}
+	       }
+	}
+	return 1;
+}
+__setup("core_nopp=", removepp);
+
+static struct clk *cpu_sel2parent(enum ap_clk_sel ap_sel)
+{
+	if (ap_sel == AP_CLK_SRC_PLL1_624)
+		return clk_get_sys(NULL, "pll1_624");
+	else if (ap_sel == AP_CLK_SRC_PLL1_1248)
+		return clk_get_sys(NULL, "pll1_1248");
+	else if (ap_sel == AP_CLK_SRC_PLL2)
+		return clk_get_sys(NULL, "pll2");
+	else if (ap_sel == AP_CLK_SRC_PLL2P)
+		return clk_get_sys(NULL, "pll2p");
+	else if (ap_sel == AP_CLK_SRC_PLL3P)
+		return clk_get_sys(NULL, "pll3p");
+	else
+		return ERR_PTR(-ENOENT);
+}
+
+static struct clk *ddr_axi_sel2parent(enum ddr_axi_clk_sel ddr_axi_sel)
+{
+	if (ddr_axi_sel == DDR_AXI_CLK_SRC_PLL1_416)
+		return clk_get_sys(NULL, "pll1_416");
+	else if (ddr_axi_sel == DDR_AXI_CLK_SRC_PLL1_624)
+		return clk_get_sys(NULL, "pll1_624");
+	else if (ddr_axi_sel == DDR_AXI_CLK_SRC_PLL2)
+		return clk_get_sys(NULL, "pll2");
+	else if (ddr_axi_sel == DDR_AXI_CLK_SRC_PLL2P)
+		return clk_get_sys(NULL, "pll2p");
+	else
+		return ERR_PTR(-ENOENT);
+}
+
+/*
+ * Sim card num
+ * 0: no card
+ * 1/2 one card
+ * 3: dual cards
+ */
+int simcard_num;
+static int __init simcard_num_setup(char *str)
+{
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	simcard_num = n;
+	return 1;
+}
+__setup("simcard=", simcard_num_setup);
+static int __init __init_platform_opt(void)
+{
+	unsigned int i, chipid = 0;
+	enum ddr_type ddrtype = LPDDR2_400M;
+	struct platform_opt *proc;
+
+	if (cpu_is_pxa988() || cpu_is_pxa986()) {
+		if (cpu_is_z1z2())
+			chipid = 0xc9280;
+		else
+			chipid = 0xc9281;
+	} else if (cpu_is_pxa1088()) {
+		chipid = 0xa01088;
+	}
+
+	/*
+	 * FIXME: ddr type is hacked here as it can not be read from
+	 * HW, but FC code needs this info to identify DDR OPs.
+	 */
+	if (ddr_mode == 0)
+		ddrtype = LPDDR2_400M;
+	else if (ddr_mode == 1)
+		ddrtype = LPDDR2_533M;
+
+	for (i = 0; i < ARRAY_SIZE(platform_op_arrays); i++) {
+		proc = platform_op_arrays + i;
+		if ((proc->chipid == chipid) &&
+			(proc->ddrtype == ddrtype))
+			break;
+	}
+	BUG_ON(i == ARRAY_SIZE(platform_op_arrays));
+	cur_platform_opt = proc;
+
+	/* TD dual sim card */
+	if ((simcard_num == 3) && cpu_is_pxa1088())
+		cur_platform_opt->ddr_axi_opt[0].aclk = 156;
+
+	if (max_freq > cur_platform_opt->df_max_cpurate)
+		cur_platform_opt->df_max_cpurate = max_freq;
+	pr_info("Platform default max frequency: %dMHZ\n",
+		cur_platform_opt->df_max_cpurate);
+	return 0;
+}
+pure_initcall(__init_platform_opt);
+
+int get_max_cpurate(void)
+{
+	return cur_platform_opt->df_max_cpurate;
+}
+
+static struct cpu_rtcwtc cpu_rtcwtc_z3[] = {
+	{.max_pclk = 800, .l1_rtc = 0x88888888, .l2_rtc = 0x00008444,},
+	{.max_pclk = 1205, .l1_rtc = 0x99999999, .l2_rtc = 0x00009555,},
+};
+
+static struct cpu_rtcwtc cpu_rtcwtc_ax[] = {
+	{.max_pclk = 800, .l1_rtc = 0x88888888, .l2_rtc = 0x00008444,},
+	{.max_pclk = 1066, .l1_rtc = 0x99999999, .l2_rtc = 0x00009555,},
+	{.max_pclk = 1205, .l1_rtc = 0xAAAAAAAA, .l2_rtc = 0x0000A555,},
+};
+
+static struct cpu_rtcwtc cpu_rtcwtc_1088[] = {
+	{.max_pclk = 312, .l1_rtc = 0x02222222, .l2_rtc = 0x00002221,},
+	{.max_pclk = 800, .l1_rtc = 0x02666666, .l2_rtc = 0x00006265,},
+	{.max_pclk = 1183, .l1_rtc = 0x2AAAAAA, .l2_rtc = 0x0000A2A9,},
+	{.max_pclk = 1300, .l1_rtc = 0x02EEEEEE, .l2_rtc = 0x0000E2ED,},
+	/*
+	 * 1283M will also use 1300 setting, if we use 1300Mhz later,
+	 * the code doesn't need to be changed.
+	*/
+};
+
+static void __init __init_cpu_rtcwtc(struct pxa988_cpu_opt *cpu_opt)
+{
+	struct cpu_rtcwtc *cpu_rtcwtc;
+	unsigned int size, index;
+
+	if (cpu_is_pxa988_z3() || cpu_is_pxa986_z3()) {
+		cpu_rtcwtc = cpu_rtcwtc_z3;
+		size = ARRAY_SIZE(cpu_rtcwtc_z3);
+	} else if (cpu_is_pxa988_a0() || cpu_is_pxa986_a0()) {
+		cpu_rtcwtc = cpu_rtcwtc_ax;
+		size = ARRAY_SIZE(cpu_rtcwtc_ax);
+	} else if (cpu_is_pxa1088()) {
+		cpu_rtcwtc = cpu_rtcwtc_1088;
+		size = ARRAY_SIZE(cpu_rtcwtc_1088);
+	} else
+		return;
+
+	for (index = 0; index < size; index++)
+		if (cpu_opt->pclk <= cpu_rtcwtc[index].max_pclk)
+			break;
+
+	if (index == size)
+		index = size - 1;
+
+	cpu_opt->l1_rtc = cpu_rtcwtc[index].l1_rtc;
+	cpu_opt->l2_rtc = cpu_rtcwtc[index].l2_rtc;
+};
+
+/* Add condition here if you want to filter the core ops */
+static bool __init __is_cpu_op_invalid(struct pxa988_cpu_opt *cop)
+{
+	unsigned int df_max_cpurate =
+		cur_platform_opt->df_max_cpurate;
+	unsigned int index;
+
+	/* If pclk could not drive from src, invalid it */
+	if (cop->ap_clk_src % cop->pclk)
+		return true;
+
+	/*
+	 * If pclk > default support max core frequency, invalid it
+	 */
+	if (df_max_cpurate && \
+		(cop->pclk > df_max_cpurate))
+		return true;
+
+	/*
+	 * Also ignore the PP if it is disabled from uboot cmd.
+	 */
+	for (index = 0; index < pp_discnt; index++)
+		if (pp_disable[index] == cop->pclk)
+			return true;
+	/* platform special requirement */
+	if (cur_platform_opt->is_cpuop_invalid_plt)
+		return cur_platform_opt->is_cpuop_invalid_plt(cop);
+
+	return false;
+};
+
+static void __init __init_cpu_opt(void)
+{
+	struct clk *parent = NULL;
+	struct pxa988_cpu_opt *cpu_opt, *cop;
+	unsigned int cpu_opt_size = 0, i;
+
+	cpu_opt = cur_platform_opt->cpu_opt;
+	cpu_opt_size = cur_platform_opt->cpu_opt_size;
+
+	pr_info("pclk(src:sel,div) l2clk(src,div)\t"\
+		"pdclk(src,div)\tbaclk(src,div)\t"\
+		"periphclk(src,div)\t l1_rtc:l2_rtc\n");
+
+	for (i = 0; i < cpu_opt_size; i++) {
+		cop = &cpu_opt[i];
+		parent = cpu_sel2parent(cop->ap_clk_sel);
+		BUG_ON(IS_ERR(parent));
+		cop->parent = parent;
+		if (!cop->ap_clk_src)
+			cop->ap_clk_src =
+				clk_get_rate(parent) / MHZ;
+		/* check the invalid condition of this op */
+		if (__is_cpu_op_invalid(cop))
+			continue;
+		/* add it into core op list */
+		list_add_tail(&cop->node, &core_op_list);
+
+		/* fill the opt related setting */
+		__init_cpu_rtcwtc(cop);
+		cop->pclk_div =
+			cop->ap_clk_src / cop->pclk - 1;
+		if (cop->l2clk) {
+			cop->l2clk_div =
+				cop->pclk / cop->l2clk - 1;
+			cop->pdclk_div =
+				cop->l2clk / cop->pdclk - 1;
+			cop->baclk_div =
+				cop->l2clk / cop->baclk - 1;
+		} else {
+			cop->pdclk_div =
+				cop->pclk / cop->pdclk - 1;
+			cop->baclk_div =
+				cop->pclk / cop->baclk - 1;
+		}
+		if (cop->periphclk) {
+			if (!has_feat_periclk_mult2())
+				cop->periphclk_div =
+					cop->pclk / (4 * cop->periphclk) - 1;
+			else
+				cop->periphclk_div =
+					cop->pclk / (2 * cop->periphclk) - 1;
+		}
+
+		pr_info("%d(%d:%d,%d)\t%d([%s],%d)\t"\
+			"%d([%s],%d)\t%d([%s],%d)\t%d([%s],%d)\t"\
+			"0x%x:0x%x\n",
+			cop->pclk, cop->ap_clk_src,
+			cop->ap_clk_sel & AP_SRC_SEL_MASK,
+			cop->pclk_div,
+			cop->l2clk, cop->l2clk ? "pclk" : "NULL",
+			cop->l2clk_div,
+			cop->pdclk, cop->l2clk ? "l2clk" : "pclk",
+			cop->pdclk_div,
+			cop->baclk, cop->l2clk ? "l2clk" : "pclk",
+			cop->baclk_div,
+			cop->periphclk,
+			cop->periphclk ? "pclk" : "NULL",
+			cop->periphclk_div,
+			cop->l1_rtc, cop->l2_rtc);
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+		if (mck4_wr_enabled) {
+			parent = cpu_sel2parent(cop->cp_clk_sel);
+			BUG_ON(IS_ERR(parent));
+			cop->cp_pclk_div =
+				clk_get_rate(parent) / MHZ /
+				cop->cp_pclk - 1;
+			cop->cp_busmc_clk_div =
+				clk_get_rate(parent) / MHZ /
+				cop->cp_busmc_clk - 1;
+			pr_info("%d(%lu:%d,%d)\t%d(%d)",\
+			cop->cp_pclk, clk_get_rate(parent) / MHZ,
+			cop->cp_clk_sel & AP_SRC_SEL_MASK,
+			cop->cp_pclk_div, cop->cp_busmc_clk,
+			cop->cp_busmc_clk_div);
+		}
+#endif
+		pr_info("\n");
+	}
+
+}
+
+static void __init __init_ddr_axi_opt(void)
+{
+	struct clk *parent = NULL;
+	struct pxa988_ddr_axi_opt *ddr_axi_opt, *cop;
+	unsigned int ddr_axi_opt_size = 0, i;
+
+	ddr_axi_opt = cur_platform_opt->ddr_axi_opt;
+	ddr_axi_opt_size = cur_platform_opt->ddr_axi_opt_size;
+
+	pr_info("dclk(src:sel,div,tblindex) aclk(src:sel,div)\n");
+	for (i = 0; i < ddr_axi_opt_size; i++) {
+		cop = &ddr_axi_opt[i];
+		parent = ddr_axi_sel2parent(cop->ddr_clk_sel);
+		BUG_ON(IS_ERR(parent));
+		cop->ddr_parent = parent;
+		cop->ddr_clk_src =
+			clk_get_rate(parent) / MHZ;
+		cop->dclk_div =
+			cop->ddr_clk_src / (2 * cop->dclk) - 1;
+
+		parent = ddr_axi_sel2parent(cop->axi_clk_sel);
+		BUG_ON(IS_ERR(parent));
+		cop->axi_parent = parent;
+		cop->axi_clk_src =
+			clk_get_rate(parent) / MHZ;
+		cop->aclk_div =
+			cop->axi_clk_src / cop->aclk - 1;
+
+		pr_info("%d(%d:%d,%d,%d)\t%d(%d:%d,%d)\n",
+			cop->dclk, cop->ddr_clk_src,
+			cop->ddr_clk_sel, cop->dclk_div,
+			cop->ddr_tbl_index,
+			cop->aclk, cop->axi_clk_src,
+			cop->axi_clk_sel, cop->aclk_div);
+	}
+}
+
+static void __init __init_fc_setting(void)
+{
+	unsigned int regval;
+	union pmua_cc cc_ap, cc_cp;
+	/*
+	 * enable AP FC done interrupt for one step,
+	 * while not use three interrupts by three steps
+	 */
+	__raw_writel((1 << 1), APMU_IMR);
+
+	/* always vote for CP allow AP FC */
+	cc_cp.v = __raw_readl(APMU_CP_CCR);
+	cc_cp.b.core_allow_spd_chg = 1;
+	__raw_writel(cc_cp.v, APMU_CP_CCR);
+
+	regval = __raw_readl(APMU_DEBUG);
+	/* CA9 doesn't support halt acknowledge, mask it */
+	regval |= (1 << 1);
+	/*
+	 * Always set AP_WFI_FC and CP_WFI_FC, then PMU will
+	 * automaticlly send out clk-off ack when core is WFI
+	 */
+	regval |= (1 << 21) | (1 << 22);
+	/*
+	 * mask CP clk-off ack and cp halt ack for DDR/AXI FC
+	 * this bits should be unmasked after cp is released
+	 */
+	regval |= (1 << 0) | (1 << 3);
+	__raw_writel(regval, APMU_DEBUG);
+
+	/*
+	 * Always use async for DDR, AXI interface,
+	 * and always vote for AP allow FC
+	 */
+	cc_ap.v = __raw_readl(APMU_CCR);
+	cc_ap.b.async5 = 1;
+	cc_ap.b.async4 = 1;
+	cc_ap.b.async3_1 = 1;
+	cc_ap.b.async3 = 1;
+	cc_ap.b.async2 = 1;
+	cc_ap.b.async1 = 1;
+	cc_ap.b.core_allow_spd_chg = 1;
+	__raw_writel(cc_ap.v, APMU_CCR);
+}
+
+static struct pxa988_cpu_opt *cpu_rate2_op_ptr
+	(unsigned int rate, unsigned int *index)
+{
+	unsigned int idx = 0;
+	struct pxa988_cpu_opt *cop;
+
+	list_for_each_entry(cop, &core_op_list, node) {
+		if ((cop->pclk >= rate) || \
+			list_is_last(&cop->node, &core_op_list))
+			break;
+		idx++;
+	}
+
+	*index = idx;
+	return cop;
+}
+
+static unsigned int ddr_rate2_op_index(unsigned int rate)
+{
+	unsigned int index;
+	struct pxa988_ddr_axi_opt *op_array =
+		cur_platform_opt->ddr_axi_opt;
+	unsigned int op_array_size =
+		cur_platform_opt->ddr_axi_opt_size;
+
+	if (unlikely(rate > op_array[op_array_size - 1].dclk))
+		return op_array_size - 1;
+
+	for (index = 0; index < op_array_size; index++)
+		if (op_array[index].dclk >= rate)
+			break;
+
+	return index;
+}
+
+static int fc_lock_ref_cnt;
+static int get_fc_lock(void)
+{
+	union pmua_dm_cc dm_cc_ap;
+
+	fc_lock_ref_cnt++;
+
+	if (fc_lock_ref_cnt == 1) {
+		int timeout = 100000;
+
+		/*
+		 * AP-CP FC mutual exclusion,
+		 * APMU_DM_CC_AP cp_rd_status = 0, ap_rd_status = 1
+		 */
+		dm_cc_ap.v = __raw_readl(APMU_CCSR);
+		while (timeout) {
+			if (!dm_cc_ap.b.cp_rd_status &&
+				dm_cc_ap.b.ap_rd_status)
+				break;
+			dm_cc_ap.v = __raw_readl(APMU_CCSR);
+			timeout--;
+		}
+
+		if (timeout <= 0) {
+			pr_err("cp does not release its fc lock\n");
+			pr_err("%s CCSR_AP when_lock:%x Now:%x CC_AP:%x\n",
+				__func__, dm_cc_ap.v, __raw_readl(APMU_CCSR),
+				__raw_readl(APMU_CCR));
+			WARN_ON(1);
+			return -EAGAIN;
+		}
+	}
+	return 0;
+}
+
+static void put_fc_lock(void)
+{
+	union pmua_cc cc_ap;
+
+	fc_lock_ref_cnt--;
+
+	if (fc_lock_ref_cnt < 0)
+		pr_err("unmatched put_fc_lock\n");
+
+	if (fc_lock_ref_cnt == 0) {
+		/* write 1 to MOH_RD_ST_CLEAR to clear MOH_RD_STATUS */
+		cc_ap.v = __raw_readl(APMU_CCR);
+		cc_ap.b.core_rd_st_clear = 1;
+		__raw_writel(cc_ap.v, APMU_CCR);
+		cc_ap.b.core_rd_st_clear = 0;
+		__raw_writel(cc_ap.v, APMU_CCR);
+	}
+}
+
+static void get_cur_cpu_op(struct pxa988_cpu_opt *cop)
+{
+	union pmua_pllsel pllsel;
+	union pmua_dm_cc dm_cc_ap;
+	union pmua_dm_cc2 dm_cc2_ap;
+	unsigned int pll1_pll3_sel;
+	struct clk *parent;
+
+	get_fc_lock();
+
+	dm_cc_ap.v = __raw_readl(APMU_CCSR);
+	dm_cc2_ap.v = __raw_readl(APMU_CC2SR);
+	pllsel.v = __raw_readl(APMU_PLL_SEL_STATUS);
+	pll1_pll3_sel = __raw_readl(MPMU_PLL3CR);
+
+	pr_debug("div%x sel%x\n", dm_cc_ap.v, pllsel.v);
+	BUG_ON(!cop->parent);
+
+	if (pllsel.b.apclksel == (cop->ap_clk_sel & AP_SRC_SEL_MASK))
+		cop->ap_clk_src = clk_get_rate(cop->parent) / MHZ;
+	else {
+		if ((pllsel.b.apclksel == 0x1) && \
+			(pll1_pll3_sel & (1 << 18))) {
+			parent = cpu_sel2parent(AP_CLK_SRC_PLL3P);
+			cop->ap_clk_sel = AP_CLK_SRC_PLL3P;
+			cop->ap_clk_src = clk_get_rate(parent) / MHZ;
+		} else {
+			/* err case : current src is NOT our target */
+			parent = cpu_sel2parent(pllsel.b.apclksel);
+			cop->parent = parent;
+			cop->ap_clk_sel = pllsel.b.apclksel;
+			cop->ap_clk_src = clk_get_rate(parent) / MHZ;
+			pr_err("%s cpu clk tsrc:%d csel:%d\n",
+				__func__, cop->ap_clk_src, pllsel.b.apclksel);
+		}
+	}
+	cop->pclk = cop->ap_clk_src / (dm_cc_ap.b.core_clk_div + 1);
+	if (cop->l2clk) {
+		cop->l2clk = cop->pclk / (dm_cc_ap.b.l2_clk_div + 1);
+		cop->pdclk = cop->l2clk / (dm_cc_ap.b.bus_mc_clk_div + 1);
+		cop->baclk = cop->l2clk / (dm_cc_ap.b.biu_clk_div + 1);
+	} else {
+		cop->pdclk = cop->pclk / (dm_cc_ap.b.bus_mc_clk_div + 1);
+		cop->baclk = cop->pclk / (dm_cc_ap.b.biu_clk_div + 1);
+	}
+	if (cop->periphclk) {
+		if (!has_feat_periclk_mult2())
+			cop->periphclk =
+				cop->pclk / (dm_cc2_ap.b.peri_clk_div + 1) / 4;
+		else
+			cop->periphclk =
+				cop->pclk / (dm_cc2_ap.b.peri_clk_div + 1) / 2;
+	}
+
+	put_fc_lock();
+}
+
+static void get_cur_ddr_axi_op(struct pxa988_ddr_axi_opt *cop)
+{
+	union pmua_pllsel pllsel;
+	union pmua_dm_cc dm_cc_ap;
+	struct clk *parent;
+
+	get_fc_lock();
+
+	dm_cc_ap.v = __raw_readl(APMU_CCSR);
+	pllsel.v = __raw_readl(APMU_PLL_SEL_STATUS);
+
+	pr_debug("div%x sel%x\n", dm_cc_ap.v, pllsel.v);
+	BUG_ON((!cop->ddr_parent) || (!cop->axi_parent));
+
+	if (likely(pllsel.b.ddrclksel == cop->ddr_clk_sel))
+		cop->ddr_clk_src = clk_get_rate(cop->ddr_parent) / MHZ;
+	else {
+		parent = ddr_axi_sel2parent(pllsel.b.ddrclksel);
+		cop->ddr_parent = parent;
+		cop->ddr_clk_sel = pllsel.b.ddrclksel;
+		cop->ddr_clk_src = clk_get_rate(parent) / MHZ;
+		pr_err("%s ddr clk tsrc:%d csel:%d parent:%s\n",
+			__func__, cop->ddr_clk_src,
+			pllsel.b.ddrclksel, cop->ddr_parent->name);
+	}
+	if (likely(pllsel.b.axiclksel == cop->axi_clk_sel))
+		cop->axi_clk_src = clk_get_rate(cop->axi_parent) / MHZ;
+	else {
+		parent = ddr_axi_sel2parent(pllsel.b.axiclksel);
+		cop->axi_parent = parent;
+		cop->axi_clk_sel = pllsel.b.axiclksel;
+		cop->axi_clk_src = clk_get_rate(parent) / MHZ;
+		pr_err("%s axi clk tsrc:%d csel:%d parent:%s\n",
+			__func__, cop->axi_clk_src,
+			pllsel.b.axiclksel, cop->axi_parent->name);
+	}
+	cop->dclk = cop->ddr_clk_src / (dm_cc_ap.b.ddr_clk_div + 1) / 2;
+	cop->aclk = cop->axi_clk_src / (dm_cc_ap.b.bus_clk_div + 1);
+
+	put_fc_lock();
+}
+
+static void wait_for_fc_done(int flag)
+{
+	int timeout = 1000;
+	while (!((1 << 1) & __raw_readl(APMU_ISR)) && timeout) {
+		timeout--;
+	/*	pmu hardware can trigger DDR freq-chg in lcd v-blank
+	 *	in pxa1088, ddr poll time wait a period of time.we test
+	 *	17ms, the freq change may timeout, so decide to use 20ms.
+	 */
+		if (is_fhd_lcd() && has_feat_enable_hw_vblank_DFC()
+			&& (flag == DDR_FC))
+			udelay(20);
+	}
+	if (timeout <= 0) {
+		WARN(1, "AP frequency change timeout!\n");
+		pr_err("APMU_ISR %x\n", __raw_readl(APMU_ISR));
+	}
+	/* only clear AP fc done signal */
+	__raw_writel(__raw_readl(APMU_ISR) & ~(1 << 1), APMU_ISR);
+}
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+static void wait_for_cp_fc_done(void)
+{
+	int timeout = 1000;
+	while (!((1 << 0) & __raw_readl(APMU_ISR)) && timeout)
+		timeout--;
+	if (timeout <= 0)
+		WARN(1, "CP frequency change timeout!\n");
+	__raw_writel(0x0, APMU_ISR);
+}
+#endif
+
+static void pll1_pll3_switch(enum ap_clk_sel sel)
+{
+	unsigned int regval;
+
+	if ((sel != AP_CLK_SRC_PLL3P) ||
+		(sel != AP_CLK_SRC_PLL1_1248))
+		return;
+
+	regval = __raw_readl(MPMU_PLL3CR);
+	if (sel == AP_CLK_SRC_PLL1_1248)
+		regval &= ~(1 << 18);
+	else
+		regval |= (1 << 18);
+	__raw_writel(regval, MPMU_PLL3CR);
+}
+
+static void set_ap_clk_sel(struct pxa988_cpu_opt *top)
+{
+	union pmum_fccr fccr;
+	unsigned int value;
+	pll1_pll3_switch(top->ap_clk_sel);
+
+	fccr.v = __raw_readl(MPMU_FCCR);
+	fccr.b.mohclksel =
+		top->ap_clk_sel & AP_SRC_SEL_MASK;
+	__raw_writel(fccr.v, MPMU_FCCR);
+	value = __raw_readl(MPMU_FCCR);
+	if (value != fccr.v)
+		pr_err("CORE FCCR Write failure: target 0x%X, final value 0x%X\n",
+		      fccr.v, value);
+}
+
+static void set_periph_clk_div(struct pxa988_cpu_opt *top)
+{
+	union pmua_cc2 cc_ap2;
+
+	cc_ap2.v = __raw_readl(APMU_CC2R);
+	cc_ap2.b.peri_clk_div = top->periphclk_div;
+	__raw_writel(cc_ap2.v, APMU_CC2R);
+}
+
+static void set_ddr_clk_sel(struct pxa988_ddr_axi_opt *top)
+{
+	union pmum_fccr fccr;
+	unsigned int value;
+
+	fccr.v = __raw_readl(MPMU_FCCR);
+	fccr.b.ddrclksel = top->ddr_clk_sel;
+	__raw_writel(fccr.v, MPMU_FCCR);
+	value = __raw_readl(MPMU_FCCR);
+	if (value != fccr.v)
+		pr_err("DDR FCCR Write failure: target 0x%x, final value 0x%X\n",
+		fccr.v, value);
+}
+
+static void set_axi_clk_sel(struct pxa988_ddr_axi_opt *top)
+{
+	union pmum_fccr fccr;
+	unsigned int value;
+
+	fccr.v = __raw_readl(MPMU_FCCR);
+	fccr.b.axiclksel0 = top->axi_clk_sel & 0x1;
+	fccr.b.axiclksel1 = (top->axi_clk_sel & 0x2) >> 1;
+	__raw_writel(fccr.v, MPMU_FCCR);
+	value = __raw_readl(MPMU_FCCR);
+	if (value != fccr.v)
+		pr_err("AXI FCCR Write failure: target 0x%x, final value 0x%X\n",
+		fccr.v, value);
+}
+
+static void set_ddr_tbl_index(unsigned int index)
+{
+	unsigned int regval;
+
+	/*
+	 * FIXME: pmu_register_lock has to be added here
+	 * to protect the register accessing of
+	 * APMU_MC_HW_SLP_TYPE, it also be access by D1P
+	 * low power mode workaround
+	 */
+	pmu_register_lock();
+	index = (index > 0x7) ? 0x7 : index;
+	regval = __raw_readl(APMU_MC_HW_SLP_TYPE);
+	regval &= ~(0x1 << 6);		/* enable tbl based FC */
+	regval &= ~(0x7 << 3);		/* clear ddr tbl index */
+	regval |= (index << 3);
+	__raw_writel(regval, APMU_MC_HW_SLP_TYPE);
+	pmu_register_unlock();
+}
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+static void cp_core_fc_seq(struct pxa988_cpu_opt *cop,
+			    struct pxa988_cpu_opt *top)
+{
+	union pmua_cc cc_cp;
+	union pmum_fccr fccr;
+	union pmua_pllsel pllsel;
+	union pmua_dm_cc dm_cc_ap;
+
+	/* Do not change CP rate if CP is in reset */
+	if ((cop->cp_pclk == top->cp_pclk) ||\
+		(__raw_readl(MPMU_APRR) & 0x1))
+		return;
+
+	/* 1) set CP pclk src */
+	fccr.v = __raw_readl(MPMU_FCCR);
+	fccr.b.seaclksel = top->cp_clk_sel & 0x3;
+	__raw_writel(fccr.v, MPMU_FCCR);
+
+	cc_cp.v = __raw_readl(APMU_CP_CCR);
+	/* 2.1) select div for pclk, busmc clk for seguall */
+	cc_cp.b.core_clk_div = top->cp_pclk_div;
+	cc_cp.b.bus_mc_clk_div = top->cp_busmc_clk_div;
+
+	/* 2.2) set div and FC req trigger core FC */
+	cc_cp.b.core_allow_spd_chg = 1;
+	cc_cp.b.core_freq_chg_req = 1;
+	pr_debug("CORE FC APMU_CCR[%x]\n", cc_cp.v);
+	__raw_writel(cc_cp.v, APMU_CP_CCR);
+	wait_for_cp_fc_done();
+
+	/* check sel and div */
+	pllsel.v = __raw_readl(APMU_PLL_SEL_STATUS);
+	dm_cc_ap.v = __raw_readl(APMU_CP_CCSR);
+	if ((pllsel.b.cpclksel != (top->cp_clk_sel & 0x3)) ||\
+		(dm_cc_ap.b.core_clk_div != top->cp_pclk_div) ||\
+		(dm_cc_ap.b.bus_mc_clk_div != top->cp_busmc_clk_div)) {
+		pr_info("sel %x, div %x\n", pllsel.v,
+			dm_cc_ap.v);
+		WARN_ON(1);
+	}
+}
+#endif
+
+atomic_t freqchg_disable_c2 = ATOMIC_INIT(0);
+#if defined(CONFIG_CPU_PXA988)
+
+static void do_nothing(void *data)
+{
+	;
+}
+
+static void smp_freqchg_pre(void)
+{
+	if (has_feat_freqchg_disable_c2()) {
+		atomic_set(&freqchg_disable_c2, 1);
+		/* send ipi to all others online cpu */
+		smp_call_function(do_nothing, NULL, 1);
+	}
+}
+
+static void smp_freqchg_post(void)
+{
+	if (has_feat_freqchg_disable_c2())
+		atomic_set(&freqchg_disable_c2, 0);
+}
+#endif
+
+/*
+ * Sequence of changing RTC on the fly
+ * RTC_lowpp means RTC is better for lowPP
+ * RTC_highpp means RTC is better for highPP
+ *
+ * lowPP -> highPP:
+ * 1) lowPP(RTC_lowpp) works at Vnom_lowPP(RTC_lowpp)
+ * 2) Voltage increases from Vnom_lowPP(RTC_lowpp) to
+ * Vnom_highPP(RTC_highpp)
+ * 3) RTC changes from RTC_lowpp to RTC_highpp, lowPP(RTC_highpp)
+ * could work at Vnom_highpp(RTC_highpp) as Vnom_highpp(RTC_highpp)
+ * >= Vnom_lowpp(RTC_highpp)
+ * 4) Core freq-chg from lowPP(RTC_highpp) to highPP(RTC_highpp)
+ *
+ * highPP -> lowPP:
+ * 1) highPP(RTC_highpp) works at Vnom_highPP(RTC_highpp)
+ * 2) Core freq-chg from highPP(RTC_highpp) to lowPP(RTC_highpp),
+ * voltage could meet requirement as Vnom_highPP(RTC_highpp) >=
+ * Vnom_lowpp(RTC_highpp)
+ * 3) RTC changes from RTC_highpp to RTC_lowpp. Vnom_lowpp(RTC_lowpp)
+ * < Vnom_lowpp(RTC_highpp), the voltage is ok
+ * 4) voltage decreases from Vnom_highPP(RTC_highpp) to
+ * Vnom_lowPP(RTC_lowpp)
+ */
+static void core_fc_seq(struct pxa988_cpu_opt *cop,
+			    struct pxa988_cpu_opt *top)
+{
+	union pmua_cc cc_ap, cc_cp;
+
+	trace_pxa_core_clk_chg(CLK_CHG_ENTRY, cop->pclk, top->pclk);
+
+	/* low -> high */
+	if ((!cpu_is_z1z2()) && \
+		(cop->pclk < top->pclk) && \
+		(top->l1_rtc != cop->l1_rtc)) {
+		writel_relaxed(top->l1_rtc, \
+			CIU_CPU_CONF_SRAM_0);
+		writel_relaxed(top->l2_rtc, \
+			CIU_CPU_CONF_SRAM_1);
+	}
+
+	/* 0) Pre FC : check CP allow AP FC voting */
+	cc_cp.v = __raw_readl(APMU_CP_CCR);
+	if (unlikely(!cc_cp.b.core_allow_spd_chg)) {
+		pr_warning("%s CP doesn't allow AP FC!\n",
+			__func__);
+		cc_cp.b.core_allow_spd_chg = 1;
+		__raw_writel(cc_cp.v, APMU_CP_CCR);
+	}
+
+	/* 1) Pre FC : AP votes allow FC */
+	cc_ap.v = __raw_readl(APMU_CCR);
+	cc_ap.b.core_allow_spd_chg = 1;
+
+	/* 2) issue core FC */
+	/* 2.1) set pclk src */
+	set_ap_clk_sel(top);
+	/* 2.2) select div for pclk, l2clk, pdclk, baclk */
+	cc_ap.b.core_clk_div = top->pclk_div;
+	if (top->l2clk)
+		cc_ap.b.l2_clk_div = top->l2clk_div;
+	cc_ap.b.bus_mc_clk_div = top->pdclk_div;
+	cc_ap.b.biu_clk_div = top->baclk_div;
+	/* 2.3) set periphclk div */
+	if (top->periphclk)
+		set_periph_clk_div(top);
+
+	cc_ap.b.core_freq_chg_req = 1;
+	/* used only for core FC, will NOT trigger fc_sm */
+	/* cc_ap.b.core_dyn_fc = 1; */
+
+	/* 2.4) set div and FC req trigger core FC */
+	pr_debug("CORE FC APMU_CCR[%x]\n", cc_ap.v);
+	__raw_writel(cc_ap.v, APMU_CCR);
+	wait_for_fc_done(CORE_FC);
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+	/* change CP clock here if mck4 wr enabled */
+	if (mck4_wr_enabled)
+		cp_core_fc_seq(cop, top);
+#endif
+
+	/* 3) Post FC : AP clear allow FC REQ */
+	cc_ap.v = __raw_readl(APMU_CCR);
+	cc_ap.b.core_freq_chg_req = 0;
+	__raw_writel(cc_ap.v, APMU_CCR);
+
+	/* high -> low */
+	if ((!cpu_is_z1z2()) && \
+		(cop->pclk > top->pclk) && \
+		(top->l1_rtc != cop->l1_rtc)) {
+		writel_relaxed(top->l1_rtc, \
+			CIU_CPU_CONF_SRAM_0);
+		writel_relaxed(top->l2_rtc, \
+			CIU_CPU_CONF_SRAM_1);
+	}
+
+	trace_pxa_core_clk_chg(CLK_CHG_EXIT, cop->pclk, top->pclk);
+}
+
+static int set_core_freq(struct pxa988_cpu_opt *old, struct pxa988_cpu_opt *new)
+{
+	struct pxa988_cpu_opt cop;
+	struct clk *old_parent;
+	int ret = 0;
+	unsigned long flags;
+
+	pr_debug("CORE set_freq start: old %u, new %u\n",
+		old->pclk, new->pclk);
+
+	memcpy(&cop, old, sizeof(struct pxa988_cpu_opt));
+	get_cur_cpu_op(&cop);
+	if (unlikely((cop.ap_clk_src != old->ap_clk_src) ||
+		(cop.pclk != old->pclk) ||
+		(cop.l2clk != old->l2clk) ||
+		(cop.pdclk != old->pdclk) ||
+		(cop.baclk != old->baclk) ||
+		(cop.periphclk != old->periphclk))) {
+		pr_err("psrc pclk l2clk pdclk baclk periphclk\n");
+		pr_err("OLD %d %d %d %d %d %d\n", old->ap_clk_src,
+		       old->pclk, old->l2clk, old->pdclk, old->baclk,
+		       old->periphclk);
+		pr_err("CUR %d %d %d %d %d %d\n", cop.ap_clk_src,
+		       cop.pclk, cop.l2clk, cop.pdclk, cop.baclk,
+		       cop.periphclk);
+		pr_err("NEW %d %d %d %d %d %d\n", new->ap_clk_src,
+		       new->pclk, new->l2clk, new->pdclk, new->baclk,
+		       new->periphclk);
+		dump_stack();
+	}
+
+	old_parent = cop.parent;
+	clk_enable(new->parent);
+
+#if defined(CONFIG_CPU_PXA988)
+	smp_freqchg_pre();
+#endif
+	/* Get lock in irq disable status to short AP hold lock time */
+	local_irq_save(flags);
+	ret = get_fc_lock();
+	if (ret) {
+		local_irq_restore(flags);
+		clk_disable(new->parent);
+#if defined(CONFIG_CPU_PXA988)
+		smp_freqchg_post();
+#endif
+		goto out;
+	}
+	core_fc_seq(&cop, new);
+	local_irq_restore(flags);
+#if defined(CONFIG_CPU_PXA988)
+	smp_freqchg_post();
+#endif
+
+	memcpy(&cop, new, sizeof(struct pxa988_cpu_opt));
+	get_cur_cpu_op(&cop);
+	if (unlikely((cop.ap_clk_src != new->ap_clk_src) ||
+		(cop.pclk != new->pclk) ||
+		(cop.l2clk != new->l2clk) ||
+		(cop.pdclk != new->pdclk) ||
+		(cop.baclk != new->baclk) ||
+		(cop.periphclk != new->periphclk))) {
+		pr_err("unsuccessful frequency change!\n");
+		pr_err("psrc pclk l2clk pdclk baclk periphclk\n");
+		pr_err("CUR %d %d %d %d %d %d\n", cop.ap_clk_src,
+		       cop.pclk, cop.l2clk, cop.pdclk, cop.baclk,
+		       cop.periphclk);
+		pr_err("NEW %d %d %d %d %d %d\n", new->ap_clk_src,
+			new->pclk, new->l2clk, new->pdclk, new->baclk,
+			new->periphclk);
+		pr_err("FCCR %x, CCAP %x, PLLSEL %x, DMCCAP %x, CCCP %x\n",
+			__raw_readl(MPMU_FCCR), __raw_readl(APMU_CCR),
+			__raw_readl(APMU_PLL_SEL_STATUS), __raw_readl(APMU_CCSR),
+			__raw_readl(APMU_CP_CCR));
+		ret = -EAGAIN;
+		if (cop.ap_clk_src != new->ap_clk_src) {
+			/* restore current src */
+			set_ap_clk_sel(&cop);
+			pr_info("Recovered FCCR: %x\n",
+				__raw_readl(MPMU_FCCR));
+			clk_disable(new->parent);
+		}
+		goto out;
+	}
+
+	clk_disable(old_parent);
+out:
+	put_fc_lock();
+	pr_debug("CORE set_freq end: old %u, new %u\n",
+		old->pclk, new->pclk);
+	return ret;
+}
+
+static void pxa988_cpu_init(struct clk *clk)
+{
+	unsigned int op_index;
+	struct pxa988_cpu_opt cur_op, *op;
+#ifdef CONFIG_DEBUG_FS
+	struct clk_dc_stat_info *cpu_dcstat;
+	unsigned int opt_size, i = 0, cpu;
+#endif
+	BUG_ON(!cur_platform_opt);
+
+	/* get cur core rate */
+	op = list_first_entry(&core_op_list,\
+		struct pxa988_cpu_opt, node);
+	memcpy(&cur_op, op, sizeof(struct pxa988_cpu_opt));
+	get_cur_cpu_op(&cur_op);
+	cur_cpu_op = cpu_rate2_op_ptr(cur_op.pclk, &op_index);
+
+	clk->rate = cur_cpu_op->pclk * MHZ;
+	clk->parent = cur_cpu_op->parent;
+	clk->dynamic_change = 1;
+
+	/* config the wtc/rtc value according to current frequency */
+	if (!cpu_is_z1z2()) {
+		writel_relaxed(cur_cpu_op->l1_rtc, \
+			CIU_CPU_CONF_SRAM_0);
+		writel_relaxed(cur_cpu_op->l2_rtc, \
+			CIU_CPU_CONF_SRAM_1);
+	}
+
+	pr_info(" CPU boot up @%luHZ\n", clk->rate);
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+	if (mck4_wr_enabled)
+		clk_set_rate(&pxa988_ddr_clk,\
+			cur_cpu_op->combined_dclk * MHZ);
+#endif
+
+#ifdef CONFIG_DEBUG_FS
+	opt_size = cur_platform_opt->cpu_opt_size;
+	for_each_possible_cpu(cpu) {
+		cpu_dcstat = &per_cpu(cpu_dc_stat, cpu);
+		cpu_dcstat->ops_dcstat = kzalloc(opt_size * \
+			sizeof(struct op_dcstat_info), GFP_KERNEL);
+		if (!cpu_dcstat->ops_dcstat) {
+			pr_err("%s clk %s memory allocate failed!\n",
+				__func__, clk->name);
+			return;
+		}
+		i = 0;
+		list_for_each_entry(op, &core_op_list, node) {
+			cpu_dcstat->ops_dcstat[i].ppindex = i;
+			cpu_dcstat->ops_dcstat[i].pprate = op->pclk;
+			i++;
+		}
+		cpu_dcstat->ops_stat_size = i;
+		cpu_dcstat->stat_start = false;
+		cpu_dcstat->curopindex = op_index;
+	}
+#endif
+}
+
+static long pxa988_cpu_round_rate(struct clk *clk, unsigned long rate)
+{
+	struct pxa988_cpu_opt *cop;
+
+	rate /= MHZ;
+	list_for_each_entry(cop, &core_op_list, node) {
+		if ((cop->pclk >= rate) || \
+			list_is_last(&cop->node, &core_op_list))
+			break;
+	}
+	return cop->pclk * MHZ;
+}
+
+static int pxa988_cpu_setrate(struct clk *clk, unsigned long rate)
+{
+	struct pxa988_cpu_opt *md_new, *md_old;
+	struct cpufreq_freqs freqs;
+	unsigned int index, cpu;
+	int ret = 0;
+	static struct pxa988_cpu_opt *bridge_op;
+
+	rate /= MHZ;
+	md_new = cpu_rate2_op_ptr(rate, &index);
+	if (md_new == cur_cpu_op)
+		return 0;
+
+	mutex_lock(&core_freqs_mutex);
+	md_old = cur_cpu_op;
+
+#ifdef CONFIG_CPU_FREQ
+	freqs.old = md_old->pclk * MHZ_TO_KHZ;
+	freqs.new = md_new->pclk * MHZ_TO_KHZ;
+	for_each_online_cpu(freqs.cpu)
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+#endif
+
+	/*
+	 * FIXME: we do NOT enable clk here because pll3
+	 * clk_enable and pll1_pll3_switch will do the
+	 * same thing, we should handle it carefully.
+	 * For example, pll1_1248 -> pll3, clk_enable(&pll3)
+	 * will switch src to pll3, which will cause issue.
+	 * clk_enable and disable will be handled in set_core_freq.
+	 */
+	/* clk_enable(md_new->parent); */
+
+	spin_lock(&fc_seq_lock);
+#ifdef PANIC_SCALING_CORE_DDRAXI_TO_MIN
+	if (has_feat_panic_freqscaling() && \
+		atomic_read(&panic_disable_fc)) {
+		spin_unlock(&fc_seq_lock);
+		goto out;
+	}
+#endif
+
+	/*
+	 * Switching pll1_1248 and pll3p may generate glitch
+	 * step 1),2),3) is neccessary
+	 */
+	if (((md_old->ap_clk_sel == AP_CLK_SRC_PLL3P) && \
+		(md_new->ap_clk_sel == AP_CLK_SRC_PLL1_1248)) || \
+		((md_old->ap_clk_sel == AP_CLK_SRC_PLL1_1248) && \
+		(md_new->ap_clk_sel == AP_CLK_SRC_PLL3P))) {
+		/* 1) op0 as bridge, must from pll1_624 */
+		if (unlikely(!bridge_op))
+			bridge_op = list_first_entry(&core_op_list,\
+			 struct pxa988_cpu_opt, node);
+		BUG_ON(bridge_op->ap_clk_sel != AP_CLK_SRC_PLL1_624);
+		/* 2) use startup op(op0) as a bridge */
+		ret = set_core_freq(md_old, bridge_op);
+		if (ret)
+			goto tmpout;
+		/* 3) change PLL3_CR[18] to select pll1_1248 or pll3p */
+		pll1_pll3_switch(md_new->ap_clk_sel);
+		/* 4) switch to op which uses pll1_1248/pll3p */
+		ret = set_core_freq(bridge_op, md_new);
+	} else {
+		ret = set_core_freq(md_old, md_new);
+	}
+
+tmpout:
+	spin_unlock(&fc_seq_lock);
+	if (ret)
+		goto out;
+	cur_cpu_op = md_new;
+
+	clk_reparent(clk, md_new->parent);
+	/*clk_disable(md_old->parent);*/
+
+	for_each_possible_cpu(cpu)
+		pxa988_cpu_dcstat_event(cpu, CLK_RATE_CHANGE, index);
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+	if (mck4_wr_enabled)
+		clk_set_rate(&pxa988_ddr_clk,\
+			cur_cpu_op->combined_dclk * MHZ);
+#endif
+
+out:
+#ifdef CONFIG_CPU_FREQ
+	freqs.new = cur_cpu_op->pclk * MHZ_TO_KHZ;
+	for_each_online_cpu(freqs.cpu)
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+#endif
+	mutex_unlock(&core_freqs_mutex);
+	return ret;
+}
+
+static unsigned long pxa988_cpu_getrate(struct clk *clk)
+{
+	if (cur_cpu_op)
+		return cur_cpu_op->pclk * MHZ;
+	else
+		pr_err("%s: cur_cpu_op NULL\n", __func__);
+
+	return 0;
+}
+
+/* do nothing only used to adjust proper clk->refcnt */
+static int clk_dummy_enable(struct clk *clk)
+{
+	return 0;
+}
+
+static void clk_dummy_disable(struct clk *clk)
+{
+}
+
+struct clkops cpu_clk_ops = {
+	.init = pxa988_cpu_init,
+	.enable = clk_dummy_enable,
+	.disable = clk_dummy_disable,
+	.round_rate = pxa988_cpu_round_rate,
+	.setrate = pxa988_cpu_setrate,
+	.getrate = pxa988_cpu_getrate,
+};
+
+static struct clk pxa988_cpu_clk = {
+	.name = "cpu",
+	.lookup = {
+		.con_id = "cpu",
+	},
+	.ops = &cpu_clk_ops,
+	.is_combined_fc = 1,
+};
+
+static void ddr_axi_fc_seq(struct pxa988_ddr_axi_opt *cop,
+			    struct pxa988_ddr_axi_opt *top)
+{
+	union pmua_cc cc_ap, cc_cp;
+
+	trace_pxa_ddraxi_clk_chg(CLK_CHG_ENTRY, cop->dclk, top->dclk);
+
+	/* 0) Pre FC : check CP allow AP FC voting */
+	cc_cp.v = __raw_readl(APMU_CP_CCR);
+	if (unlikely(!cc_cp.b.core_allow_spd_chg)) {
+		pr_warning("%s CP doesn't allow AP FC!\n",
+			__func__);
+		cc_cp.b.core_allow_spd_chg = 1;
+		__raw_writel(cc_cp.v, APMU_CP_CCR);
+	}
+
+	/* 1) Pre FC : AP votes allow FC */
+	cc_ap.v = __raw_readl(APMU_CCR);
+	cc_ap.b.core_allow_spd_chg = 1;
+
+	/* 2) issue DDR FC */
+	if ((cop->ddr_clk_src != top->ddr_clk_src) || \
+	    (cop->dclk != top->dclk)) {
+		/* 2.1) set dclk src */
+		set_ddr_clk_sel(top);
+		/* 2.2) enable tbl based FC and set DDR tbl num */
+		set_ddr_tbl_index(top->ddr_tbl_index);
+		/* 2.3) select div for dclk */
+		cc_ap.b.ddr_clk_div = top->dclk_div;
+		/* 2.4) select ddr FC req bit */
+		cc_ap.b.ddr_freq_chg_req = 1;
+	}
+
+	/* 3) issue AXI FC */
+	if ((cop->axi_clk_src != top->axi_clk_src) || \
+	    (cop->aclk != top->aclk)) {
+		/* 3.1) set aclk src */
+		set_axi_clk_sel(top);
+		/* 3.2) select div for aclk */
+		cc_ap.b.bus_clk_div = top->aclk_div;
+		/* 3.3) select axi FC req bit */
+		cc_ap.b.bus_freq_chg_req = 1;
+	}
+
+	/* 4) set div and FC req bit trigger DDR/AXI FC */
+	pr_debug("DDR FC APMU_CCR[%x]\n", cc_ap.v);
+	__raw_writel(cc_ap.v, APMU_CCR);
+	wait_for_fc_done(DDR_FC);
+
+	/* 5) Post FC : AP clear allow FC REQ */
+	cc_ap.v = __raw_readl(APMU_CCR);
+	cc_ap.b.ddr_freq_chg_req = 0;
+	cc_ap.b.bus_freq_chg_req = 0;
+	__raw_writel(cc_ap.v, APMU_CCR);
+
+	trace_pxa_ddraxi_clk_chg(CLK_CHG_EXIT, cop->dclk, top->dclk);
+}
+
+static int set_ddr_axi_freq(struct pxa988_ddr_axi_opt *old,
+	struct pxa988_ddr_axi_opt *new)
+{
+	struct pxa988_ddr_axi_opt cop;
+	struct clk *ddr_old_parent, *axi_old_parent;
+	int ret = 0, errflag = 0;
+	unsigned long flags;
+
+	pr_debug("DDR set_freq start: old %u, new %u\n",
+		old->dclk, new->dclk);
+
+	memcpy(&cop, old, sizeof(struct pxa988_ddr_axi_opt));
+	get_cur_ddr_axi_op(&cop);
+	if (unlikely((cop.ddr_clk_src != old->ddr_clk_src) ||
+		(cop.axi_clk_src != old->axi_clk_src) ||
+		(cop.dclk != old->dclk) ||
+		(cop.aclk != old->aclk))) {
+		pr_err(" dsrc dclk asrc aclk");
+		pr_err("OLD %d %d %d %d\n", old->ddr_clk_src,
+		       old->dclk, old->axi_clk_src, old->aclk);
+		pr_err("CUR %d %d %d %d\n", cop.ddr_clk_src,
+		       cop.dclk, cop.axi_clk_src, cop.aclk);
+		pr_err("NEW %d %d %d %d\n", new->ddr_clk_src,
+		       new->dclk, new->axi_clk_src, new->aclk);
+		dump_stack();
+	}
+
+	ddr_old_parent = cop.ddr_parent;
+	axi_old_parent = cop.axi_parent;
+	clk_enable(new->ddr_parent);
+	clk_enable(new->axi_parent);
+#if defined(CONFIG_CPU_PXA988)
+	smp_freqchg_pre();
+#endif
+	/* Get lock in irq disable status to short AP hold lock time */
+	local_irq_save(flags);
+	ret = get_fc_lock();
+	if (ret) {
+		local_irq_restore(flags);
+		clk_disable(new->ddr_parent);
+		clk_disable(new->axi_parent);
+#if defined(CONFIG_CPU_PXA988)
+		smp_freqchg_post();
+#endif
+		goto out;
+	}
+	ddr_axi_fc_seq(&cop, new);
+	local_irq_restore(flags);
+#if defined(CONFIG_CPU_PXA988)
+	smp_freqchg_post();
+#endif
+
+	memcpy(&cop, new, sizeof(struct pxa988_ddr_axi_opt));
+	get_cur_ddr_axi_op(&cop);
+	if (unlikely((cop.ddr_clk_src != new->ddr_clk_src) ||
+		(cop.dclk != new->dclk))) {
+		clk_disable(new->ddr_parent);
+		errflag = 1;
+	}
+	if (unlikely((cop.axi_clk_src != new->axi_clk_src) ||
+		(cop.aclk != new->aclk))) {
+		clk_disable(new->axi_parent);
+		errflag = 1;
+	}
+	if (unlikely(errflag)) {
+		pr_err("DDR_AXI:unsuccessful frequency change!\n");
+		pr_err(" dsrc dclk asrc aclk");
+		pr_err("CUR %d %d %d %d\n", cop.ddr_clk_src,
+		       cop.dclk, cop.axi_clk_src, cop.aclk);
+		pr_err("NEW %d %d %d %d\n", new->ddr_clk_src,
+		       new->dclk, new->axi_clk_src, new->aclk);
+		pr_err("FCCR %x, CCAP %x, PLLSEL %x, DMCCAP %x, CCCP %x\n",
+			__raw_readl(MPMU_FCCR), __raw_readl(APMU_CCR),
+			__raw_readl(APMU_PLL_SEL_STATUS), __raw_readl(APMU_CCSR),
+			__raw_readl(APMU_CP_CCR));
+		/* restore current src */
+		set_ddr_clk_sel(&cop);
+		set_axi_clk_sel(&cop);
+		pr_info("Recovered FCCR: %x\n", __raw_readl(MPMU_FCCR));
+		ret = -EAGAIN;
+		goto out;
+	}
+
+	clk_disable(ddr_old_parent);
+	clk_disable(axi_old_parent);
+out:
+	put_fc_lock();
+	pr_debug("DDR set_freq end: old %u, new %u\n",
+		old->dclk, new->dclk);
+	return ret;
+}
+
+static void ddr_lpm_tbl_update(int bypass)
+{
+	trace_pxa_ddr_lpm_tbl_update(bypass);
+
+	if (bypass) {
+		INSERT_ENTRY(0x0, 0xC, 0x0);
+		INSERT_ENTRY(PHY_CTRL14_PHY_SYNC, 0x2024C, 0x1);
+	} else {
+		INSERT_ENTRY(0x0, 0xC, 0x0);
+		INSERT_ENTRY(PHY_CTRL14_DLL_RESET, 0x24C, 0x1);
+		INSERT_ENTRY(PHY_CTRL14_DLL_UPDATE, 0x24C, 0x2);
+		INSERT_ENTRY(PHY_CTRL14_PHY_SYNC, 0x2024C, 0x3);
+	}
+}
+
+static void pxa988_ddraxi_init(struct clk *clk)
+{
+	struct pxa988_ddr_axi_opt cur_op;
+	struct pxa988_ddr_axi_opt *ddr_axi_opt;
+	unsigned int op_index;
+	unsigned long axi_rate;
+#ifdef CONFIG_DEBUG_FS
+	unsigned int op_array_size, i;
+	unsigned long op[MAX_OP_NUM];
+#ifdef CONFIG_DDR_FC_HARDWARE
+	unsigned int value;
+#endif
+#endif
+	BUG_ON(!cur_platform_opt);
+
+	/* get core cur frequency */
+	ddr_axi_opt = cur_platform_opt->ddr_axi_opt;
+	memcpy(&cur_op, &ddr_axi_opt[0],
+		sizeof(struct pxa988_ddr_axi_opt));
+	get_cur_ddr_axi_op(&cur_op);
+	op_index = ddr_rate2_op_index(cur_op.dclk);
+	cur_ddraxi_op = &ddr_axi_opt[op_index];
+
+	/*
+	 * If the init DDR freq is lower than 400Mhz, optimize the
+	 * DDR lpm table to bypass dll reset/update.
+	 */
+	if (has_feat_dll_bypass_opti()) {
+		if (ddr_axi_opt[op_index].dclk < 400)
+			ddr_lpm_tbl_update(1);
+		else
+			ddr_lpm_tbl_update(0);
+	}
+
+	clk->rate = ddr_axi_opt[op_index].dclk * MHZ;
+	clk->parent = ddr_axi_opt[op_index].ddr_parent;
+	clk->dynamic_change = 1;
+	axi_rate = ddr_axi_opt[op_index].aclk * MHZ;
+	/*
+	 * As axi has no seperate clock node, so have to adjust axi's
+	 * current parents' ref->cnt when system boots up
+	 */
+	clk_enable(ddr_axi_opt[op_index].axi_parent);
+
+	pr_info(" DDR boot up @%luHZ\n", clk->rate);
+	pr_info(" AXI boot up @%luHZ\n", axi_rate);
+
+#ifdef CONFIG_DDR_FC_HARDWARE
+	/* default disable the hardware feature */
+	value = __raw_readl(APMU_DEBUG);
+	if (is_fhd_lcd() && has_feat_enable_hw_vblank_DFC())
+		value &= ~(MASK_LCD_BLANK_CHECK);
+	else
+		value |= (MASK_LCD_BLANK_CHECK);
+	__raw_writel(value, APMU_DEBUG);
+#endif
+
+#ifdef CONFIG_DEBUG_FS
+	op_array_size = cur_platform_opt->ddr_axi_opt_size;
+	for (i = 0; i < op_array_size; i++)
+		op[i] = ddr_axi_opt[i].dclk * MHZ;
+	pxa988_clk_register_dcstat(clk, op, op_array_size);
+#endif
+}
+
+static long pxa988_ddraxi_round_rate(struct clk *clk, unsigned long rate)
+{
+	struct pxa988_ddr_axi_opt *op_array =
+		cur_platform_opt->ddr_axi_opt;
+	unsigned int op_array_size =
+		cur_platform_opt->ddr_axi_opt_size;
+	unsigned int index;
+
+	rate /= MHZ;
+
+	if (unlikely(rate > op_array[op_array_size - 1].dclk))
+		return op_array[op_array_size - 1].dclk;
+
+	for (index = 0; index < op_array_size; index++)
+		if (op_array[index].dclk >= rate)
+			break;
+
+	return op_array[index].dclk * MHZ;
+}
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+int wakeup_ddr_fc_seq(void)
+{
+	int ret = 0;
+	if (atomic_read(&ddr_fc_trigger)) {
+		atomic_set(&ddr_fc_trigger, 0);
+		pr_debug("EOF_FC: start ddr fc!\n");
+		spin_lock(&fc_seq_lock);
+		ret = set_ddr_axi_freq(md_old_eof, md_new_eof);
+		spin_unlock(&fc_seq_lock);
+		if (ret)
+			ddr_fc_failure = 1;
+
+		pr_debug("EOF_FC: ddr fc done\n");
+		complete(&ddr_eof_complete);
+	}
+
+	return 0;
+}
+#endif
+
+/*
+ * For the DDR freq < threshold, we use DLL bypass mode, so we could
+ * use optimized DDR table 0 to skip DLL reset and DLL update to
+ * save the DDR restore time when system exit from D1pp or deeper
+ * state.
+ */
+static void ddr_lpm_tbl_optimize(unsigned int old, unsigned int new,
+		unsigned int threshold)
+{
+	if (has_feat_dll_bypass_opti()) {
+		if ((old >= threshold) && (new < threshold))
+			ddr_lpm_tbl_update(1);
+		else if ((old < threshold) && (new >= threshold))
+			ddr_lpm_tbl_update(0);
+	}
+}
+
+static int pxa988_ddraxi_setrate(struct clk *clk, unsigned long rate)
+{
+	struct pxa988_ddr_axi_opt *md_new, *md_old;
+	unsigned int index;
+	int ret = 0;
+	struct pxa988_ddr_axi_opt *op_array =
+		cur_platform_opt->ddr_axi_opt;
+
+	rate /= MHZ;
+	index = ddr_rate2_op_index(rate);
+
+	md_new = &op_array[index];
+	if (md_new == cur_ddraxi_op)
+		return 0;
+
+	mutex_lock(&ddr_freqs_mutex);
+	md_old = cur_ddraxi_op;
+
+	/* clk_enable(md_new->ddr_parent); */
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+	pr_debug("EOF_FC: ddr freq to %d\n", md_new->dclk);
+
+	/*
+	 * Only use EOF workaournd when decreasing DDR frequency to 156Mhz
+	 * while LCD is on. And this workaround is only suitable for Z3 since
+	 * Z3 does not require safe PP.
+	 */
+	ddr_fc_failure = 0;
+
+	if ((cpu_is_pxa988_z3() || cpu_is_pxa986_z3())
+			&& ((md_new->dclk == 156) || (md_new->dclk == 312))
+			&& disp_is_on()) {
+		md_old_eof = md_old;
+		md_new_eof = md_new;
+		/* Enable LCD panel path EOF interrupt before DDR freq-chg */
+		disp_eofintr_onoff(1);
+		atomic_set(&disable_c2, 1);
+		atomic_set(&ddr_fc_trigger, 1);
+		/*
+		 * Now after the ddr fc is triggered, we will DO ddr freq-chg at
+		 * first EOF, so we should never meet the 50ms timeout case.
+		 */
+		if (!wait_for_completion_timeout(&ddr_eof_complete,
+				msecs_to_jiffies(50))) {
+			if (atomic_read(&ddr_fc_trigger)) {
+				atomic_set(&ddr_fc_trigger, 0);
+				pr_debug("EOF_FC: wait eof timeout! force ddr fc!\n");
+				spin_lock(&fc_seq_lock);
+				ret = set_ddr_axi_freq(md_old, md_new);
+				if (!ret)
+					ddr_lpm_tbl_optimize(md_old->dclk,
+						md_new->dclk, 400);
+				spin_unlock(&fc_seq_lock);
+				if (ret)
+					ddr_fc_failure = 1;
+			} else {
+				pr_debug("EOF_FC: ddr fc is running, wait!\n");
+				wait_for_completion(&ddr_eof_complete);
+			}
+		} else
+			pr_debug("EOF_FC: wait eof done!\n");
+		atomic_set(&disable_c2, 0);
+		/* Disable LCD panel path EOF interrupt after DDR freq-chg */
+		disp_eofintr_onoff(0);
+	} else {
+		spin_lock(&fc_seq_lock);
+#ifdef PANIC_SCALING_CORE_DDRAXI_TO_MIN
+		if (has_feat_panic_freqscaling() && \
+			atomic_read(&panic_disable_fc)) {
+			spin_unlock(&fc_seq_lock);
+			goto out;
+		}
+#endif
+		ret = set_ddr_axi_freq(md_old, md_new);
+		if (!ret)
+			ddr_lpm_tbl_optimize(md_old->dclk,
+				md_new->dclk, 400);
+
+		spin_unlock(&fc_seq_lock);
+	}
+
+	if (ret || (ddr_fc_failure == 1))
+		goto out;
+#else
+	spin_lock(&fc_seq_lock);
+	ret = set_ddr_axi_freq(md_old, md_new);
+	if (!ret)
+		ddr_lpm_tbl_optimize(md_old->dclk,
+			md_new->dclk, 400);
+
+	spin_unlock(&fc_seq_lock);
+	if (ret)
+		goto out;
+#endif
+	cur_ddraxi_op = md_new;
+
+	clk_reparent(clk, md_new->ddr_parent);
+	/* clk_disable(md_old->ddr_parent); */
+#ifdef CONFIG_DEBUG_FS
+	pxa988_clk_dcstat_event(clk, CLK_RATE_CHANGE, index);
+#endif
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+	trigger_bind2ddr_clk_rate(rate * MHZ);
+#endif
+out:
+	mutex_unlock(&ddr_freqs_mutex);
+	return ret;
+}
+
+static unsigned long pxa988_ddraxi_getrate(struct clk *clk)
+{
+	if (cur_ddraxi_op)
+		return cur_ddraxi_op->dclk * MHZ;
+	else
+		pr_err("%s: cur_ddraxi_op NULL\n", __func__);
+
+	return 0;
+}
+
+struct clkops ddr_clk_ops = {
+	.init = pxa988_ddraxi_init,
+	.enable = clk_dummy_enable,
+	.disable = clk_dummy_disable,
+	.round_rate = pxa988_ddraxi_round_rate,
+	.setrate = pxa988_ddraxi_setrate,
+	.getrate = pxa988_ddraxi_getrate,
+};
+
+static struct clk pxa988_ddr_clk = {
+	.name = "ddr",
+	.lookup = {
+		.con_id = "ddr",
+	},
+	.ops = &ddr_clk_ops,
+	.is_combined_fc = 1,
+};
+#ifdef PANIC_SCALING_CORE_DDRAXI_TO_MIN
+static int panic_scale_coreddraxi_freq2min(struct notifier_block *this,
+	unsigned long event, void *ptr)
+{
+	struct pxa988_cpu_opt *cpucop = NULL, *cputop = NULL;
+	struct pxa988_ddr_axi_opt *ddraxiop_array = cur_platform_opt->ddr_axi_opt;
+	struct pxa988_ddr_axi_opt *ddraxicop = NULL, *ddraxitop = NULL;
+	unsigned int index = 0;
+	unsigned long flag;
+
+	if (!has_feat_panic_freqscaling())
+		return NOTIFY_DONE;
+
+	/* core scaling to 312, ddr scaling to 156 */
+	cpucop = cur_cpu_op;
+	cputop = cpu_rate2_op_ptr(312, &index);
+	ddraxicop = cur_ddraxi_op;
+	ddraxitop = &ddraxiop_array[ddr_rate2_op_index(156)];
+	spin_lock_irqsave(&fc_seq_lock, flag);
+	atomic_set(&panic_disable_fc, 1);
+	if (cpucop != cputop)
+		set_core_freq(cpucop, cputop);
+	if (ddraxicop != ddraxitop)
+		set_ddr_axi_freq(ddraxicop, ddraxitop);
+	spin_unlock_irqrestore(&fc_seq_lock, flag);
+
+	printk(KERN_EMERG "%s core %d->%d, ddr/axi %d->%d/%d->%d\n",
+		__func__, cpucop->pclk, cputop->pclk,
+		ddraxicop->dclk, ddraxitop->dclk,
+		ddraxicop->aclk, ddraxitop->aclk);
+	return NOTIFY_OK;
+}
+
+static struct notifier_block panic_freqscaling_notifier = {
+	.notifier_call = panic_scale_coreddraxi_freq2min,
+	.priority = 100,
+};
+#endif
+
+/*
+ * Every ddr/axi FC, fc_sm will halt AP,CP and
+ * wait for the halt_ack from AP and CP.
+ * If CP is in reset state, CP can not send this ack.
+ * and system may hang. SW need to set a debug
+ * register to ignore the CP ack if CP is in reset.
+ */
+/*
+ * Interface used by telephony
+ * cp_holdcp:
+ * 1) acquire_fc_mutex
+ * 2) hold CP (write APRR)
+ * 3) mask the cp halt and clk-off of debug register
+ * 4) release_fc_mutex
+ * cp_releasecp:
+ * 1) acquire_fc_mutex
+ * 2) clear the cp halt and clk-off of debug register
+ * 3) Write APRR to release CP from reset
+ * 4) wait 10ms
+ * 5) release_fc_mutex
+ */
+void acquire_fc_mutex(void)
+{
+	mutex_lock(&ddr_freqs_mutex);
+	cp_reset_block_ddr_fc = true;
+}
+EXPORT_SYMBOL(acquire_fc_mutex);
+
+/* called after release cp */
+void release_fc_mutex(void)
+{
+	cp_reset_block_ddr_fc = false;
+	mutex_unlock(&ddr_freqs_mutex);
+}
+EXPORT_SYMBOL(release_fc_mutex);
+
+/* Interface used to get ddr op num */
+unsigned int pxa988_get_ddr_op_num(void)
+{
+	return cur_platform_opt->ddr_axi_opt_size;
+}
+
+/* Interface used to get ddr avaliable rate, unit khz */
+unsigned int pxa988_get_ddr_op_rate(unsigned int index)
+{
+	struct pxa988_ddr_axi_opt *ddr_opt;
+
+	if (index >= cur_platform_opt->ddr_axi_opt_size) {
+		pr_err("%s index out of range!\n", __func__);
+		return -EINVAL;
+	}
+
+	ddr_opt = cur_platform_opt->ddr_axi_opt;
+	return ddr_opt[index].dclk * MHZ_TO_KHZ;
+}
+
+
+#ifdef CONFIG_CPU_FREQ_TABLE
+static struct cpufreq_frequency_table *cpufreq_tbl;
+
+static void __init_cpufreq_table(void)
+{
+	struct pxa988_cpu_opt *cop;
+	unsigned int cpu_opt_size = 0, i = 0;
+
+	cpu_opt_size = cur_platform_opt->cpu_opt_size;
+	cpufreq_tbl =
+		kmalloc(sizeof(struct cpufreq_frequency_table) * \
+					(cpu_opt_size + 1), GFP_KERNEL);
+	if (!cpufreq_tbl)
+		return;
+
+	list_for_each_entry(cop, &core_op_list, node) {
+		cpufreq_tbl[i].index = i;
+		cpufreq_tbl[i].frequency = cop->pclk * MHZ_TO_KHZ;
+		i++;
+	}
+	cpufreq_tbl[i].index = i;
+	cpufreq_tbl[i].frequency = CPUFREQ_TABLE_END;
+
+	for_each_possible_cpu(i)
+		cpufreq_frequency_table_get_attr(cpufreq_tbl, i);
+}
+#else
+#define __init_cpufreq_table() do {} while (0);
+#endif
+
+#define NUM_PROFILES	9
+static unsigned int convert_FusesToProfile(unsigned int uiFuses)
+{
+	unsigned int uiProfile = 0;
+	unsigned int uiTemp = 3, uiTemp2 = 3;
+	unsigned int i;
+
+	for (i = 0; i < NUM_PROFILES; i++) {
+		uiTemp |= uiTemp2 << (i * 2);
+		if (uiTemp == uiFuses)
+			uiProfile = i + 1;
+	}
+
+	return uiProfile;
+}
+
+unsigned int get_profile(void)
+{
+	return uichipProfile;
+}
+
+#define UIMAINFUSE_31_00 (AXI_VIRT_BASE + 0x1410)
+#define UIMAINFUSE_63_32 (AXI_VIRT_BASE + 0x1414)
+#define UIMAINFUSE_95_64 (AXI_VIRT_BASE + 0x1418)
+#define BLOCK0_224_255	 (AXI_VIRT_BASE + 0x1420)
+static int __init __init_read_droinfo(void)
+{
+	unsigned int uiMainFuse_63_32 = 0;
+	unsigned int uiMainFuse_95_64 = 0;
+	unsigned int uiMainFuse_31_00 = 0;
+	unsigned int uiAllocRev;
+	unsigned int uiFab;
+	unsigned int uiRun;
+	unsigned int uiWafer;
+	unsigned int uiX;
+	unsigned int uiY;
+	unsigned int uiParity;
+	unsigned int uiDRO_Avg;
+	unsigned int uiGeuStatus;
+	unsigned int uiFuses;
+	is_pxa988a0svc = 0;
+
+	is_pxa986a0svc = 0;
+
+	/*
+	* Read out DRO value, need enable GEU clock, if already disable,
+	* need enable it firstly
+	*/
+	uiGeuStatus = __raw_readl(APMU_GEU);
+	if (!(uiGeuStatus & 0x08)) {
+		__raw_writel((uiGeuStatus | 0x09), APMU_GEU);
+		udelay(10);
+	}
+
+	uiMainFuse_31_00 = __raw_readl(UIMAINFUSE_31_00);
+	uiMainFuse_63_32 = __raw_readl(UIMAINFUSE_63_32);
+	uiMainFuse_95_64 = __raw_readl(UIMAINFUSE_95_64);
+	uiFuses = __raw_readl(BLOCK0_224_255);
+
+	__raw_writel(uiGeuStatus, APMU_GEU);
+
+	pr_info("  0x%x   0x%x   0x%x\n",
+		uiMainFuse_31_00, uiMainFuse_63_32,
+		uiMainFuse_95_64);
+
+	uiAllocRev	= uiMainFuse_31_00 & 0x7;
+	uiFab		= (uiMainFuse_31_00 >>  3) & 0x1f;
+	uiRun		= ((uiMainFuse_63_32 & 0x3) << 24)
+		| ((uiMainFuse_31_00 >> 8) & 0xffffff);
+	uiWafer		= (uiMainFuse_63_32 >>  2) & 0x1f;
+	uiX		= (uiMainFuse_63_32 >>  7) & 0xff;
+	uiY		= (uiMainFuse_63_32 >> 15) & 0xff;
+	uiParity	= (uiMainFuse_63_32 >> 23) & 0x1;
+	uiDRO_Avg	= (uiMainFuse_95_64 >>  4) & 0x3ff;
+	if (cpu_is_pxa988_z1() || cpu_is_pxa986_z1())
+		uiDRO_Avg = (uiDRO_Avg * 1254) / 1000;
+
+	if (cpu_is_pxa988_a0() || cpu_is_pxa986_a0()) {
+		is_pxa988a0svc = (((uiFuses >> 14) & 0x3) == 0x3) ? 1 : 0;
+		if (is_pxa988a0svc && (uiMainFuse_95_64 & (0x1 << 3)))
+			is_pxa988a0svc = 2;
+		pr_info("is_pxa988a0svc = %d\n", is_pxa988a0svc);
+	}
+
+	if (cpu_is_pxa986_a0()) {
+		is_pxa986a0svc = (((uiFuses >> 14) & 0x3) == 0x3) ? 1 : 0;
+		pr_info("is_pxa986a0svc = %d\n", is_pxa986a0svc);
+	}
+
+	if (!cpu_is_z1z2()) {
+		/* bit 240 ~ 255 for Profile information */
+		uiFuses = (uiFuses >> 16) & 0x0000FFFF;
+		uichipProfile = convert_FusesToProfile(uiFuses);
+	}
+
+	pm_dro_status = uiDRO_Avg;
+
+	pr_info(" ");
+	pr_info("	 *************************** ");
+	pr_info("	 *	ULT: %08X%08X  * ",
+		uiMainFuse_63_32, uiMainFuse_31_00);
+	pr_info("	 *************************** ");
+	pr_info("	 ULT decoded below ");
+	pr_info("		alloc_rev[2:0]	= %d", uiAllocRev);
+	pr_info("		fab [ 7: 3]	= %d", uiFab);
+	pr_info("		run [33: 8]	= %d (0x%X)", uiRun, uiRun);
+	pr_info("		 wafer [38:34]	= %d", uiWafer);
+	pr_info("		 x [46:39]	= %d", uiX);
+	pr_info("		 y [54:47]	= %d", uiY);
+	pr_info("		parity [55:55]	= %d", uiParity);
+	pr_info("   *************************** ");
+	pr_info("   *************************** ");
+	pr_info("		DRO [77:68]	= %d", uiDRO_Avg);
+	pr_info("		Profile	= %d", uichipProfile);
+	pr_info("   *************************** ");
+	pr_info(" ");
+
+	return uiDRO_Avg;
+}
+pure_initcall(__init_read_droinfo);
+
+static int __init pxa988_freq_init(void)
+{
+	__init_cpu_opt();
+	__init_ddr_axi_opt();
+	__init_fc_setting();
+
+	pxa988_init_one_clock(&pxa988_ddr_clk);
+	clk_enable(&pxa988_ddr_clk);
+	pxa988_init_one_clock(&pxa988_cpu_clk);
+	clk_enable(&pxa988_cpu_clk);
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+	trigger_bind2ddr_clk_rate(clk_get_rate(&pxa988_ddr_clk));
+#endif
+	__init_cpufreq_table();
+
+#ifdef PANIC_SCALING_CORE_DDRAXI_TO_MIN
+	atomic_notifier_chain_register(&panic_notifier_list,
+		&panic_freqscaling_notifier);
+#endif
+
+	return 0;
+}
+postcore_initcall_sync(pxa988_freq_init);
+
+#ifdef CONFIG_DEBUG_FS
+static ssize_t pxa988_pm_dro_read(struct file *filp, char __user *buffer,
+	size_t count, loff_t *ppos)
+{
+	char buf[256] = { 0 };
+	int len = 0;
+	size_t size = sizeof(buf) - 1;
+
+	len += snprintf(buf, size,
+		"DRO Fuse Value : %u MHz\n", pm_dro_status);
+	if (!cpu_is_z1z2())
+		len += snprintf(buf + len, size,
+			"Profile : %u \n", uichipProfile);
+
+	return simple_read_from_buffer(buffer, count, ppos, buf, len);
+}
+
+static const struct file_operations pxa988_pm_dro_ops = {
+	.read = pxa988_pm_dro_read,
+};
+
+static int __init __init_create_pm_dro_node(void)
+{
+	struct dentry *pm;
+	struct dentry *pm_dro_op;
+
+	pm = debugfs_create_dir("PM", NULL);
+	if (!pm)
+		return -ENOENT;
+
+	pm_dro_op = debugfs_create_file("DRO_Status", 0444,
+		pm, NULL, &pxa988_pm_dro_ops);
+	if (!pm_dro_op)
+		goto err_pm;
+
+	return 0;
+
+err_pm:
+	debugfs_remove(pm);
+	return -ENOENT;
+}
+
+static int dump_cpu_op(char *buf, size_t size,
+		struct pxa988_cpu_opt *q)
+{
+	return snprintf(buf, size, "pclk:%d pdclk:%d baclk:%d l2clk:%d "\
+			"periphclk:%d ap_clk_src:%d\n",
+			q->pclk, q->pdclk, q->baclk, q->l2clk,
+			q->periphclk, q->ap_clk_src);
+}
+
+static int dump_ddr_axi_op(char *buf, size_t size,
+		struct pxa988_ddr_axi_opt *q)
+{
+	return snprintf(buf, size, "dclk:%d aclk:%d ddr_clk_src:%d "\
+			"axi_clk_src:%d\n",
+			q->dclk, q->aclk, q->ddr_clk_src,
+			q->axi_clk_src);
+}
+
+#ifdef CONFIG_DDR_FC_HARDWARE
+static ssize_t lcd_blank_check_read(struct file *filp,
+	char __user *buffer, size_t count, loff_t *ppos)
+{
+	char buf[256] = { 0 };
+	int len = 0;
+	unsigned int value;
+	size_t size = sizeof(buf) - 1;
+	value = __raw_readl(APMU_DEBUG);
+	if (value & (MASK_LCD_BLANK_CHECK))
+		len = snprintf(buf, size,
+		"pxa1088 HW DFC in LCD v-Blank is disabled\n");
+	else
+		len = snprintf(buf, size,
+		"pxa1088 HW DFC in LCD v-Blank is enabled\n");
+	return simple_read_from_buffer(buffer, count, ppos, buf, len);
+}
+
+static ssize_t lcd_blank_check_write(struct file *filp,
+		const char __user *buffer, size_t count, loff_t *ppos)
+{
+	int start;
+	unsigned int value;
+	char buf[10] = { 0 };
+
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%d", &start);
+	value = __raw_readl(APMU_DEBUG);
+	if (start == 1)
+		value &= ~(MASK_LCD_BLANK_CHECK);
+	else if (start == 0)
+		value |= (MASK_LCD_BLANK_CHECK);
+	__raw_writel(value, APMU_DEBUG);
+	return count;
+}
+
+static const struct file_operations lcd_blank_check_fops = {
+	.read = lcd_blank_check_read,
+	.write = lcd_blank_check_write,
+};
+#endif
+
+/* Display current operating point */
+static ssize_t cur_cpu_op_show(struct file *filp, char __user *buffer,
+	size_t count, loff_t *ppos)
+{
+	char buf[256];
+	int len = 0;
+	size_t size = sizeof(buf) - 1;
+
+	len = dump_cpu_op(buf, size - len, cur_cpu_op);
+	return simple_read_from_buffer(buffer, count, ppos, buf, len);
+}
+
+const struct file_operations dp_cur_cpu_op_fops = {
+	.read = cur_cpu_op_show,
+};
+
+static ssize_t cur_ddr_axi_op_show(struct file *filp, char __user *buffer,
+	size_t count, loff_t *ppos)
+{
+	char buf[256];
+	int len = 0;
+	size_t size = sizeof(buf) - 1;
+
+	len = dump_ddr_axi_op(buf, size - len, cur_ddraxi_op);
+	return simple_read_from_buffer(buffer, count, ppos, buf, len);
+}
+
+const struct file_operations dp_cur_ddr_axi_op_fops = {
+	.read = cur_ddr_axi_op_show,
+};
+
+/* Dump all operating point */
+static ssize_t ops_show(struct file *filp, char __user *buffer,
+	size_t count, loff_t *ppos)
+{
+	char *p;
+	int len = 0;
+	size_t ret;
+	unsigned int i;
+	struct pxa988_cpu_opt *cpu_ops =
+		cur_platform_opt->cpu_opt;
+	unsigned int cpu_ops_size =
+		cur_platform_opt->cpu_opt_size;
+	struct pxa988_ddr_axi_opt *ddr_ops =
+		cur_platform_opt->ddr_axi_opt;
+	unsigned int ddr_ops_size =
+		cur_platform_opt->ddr_axi_opt_size;
+	size_t size = PAGE_SIZE - 1;
+
+	p = (char *)__get_free_pages(GFP_NOIO, 0);
+	if (!p)
+		return -ENOMEM;
+
+	len += snprintf(p + len, size - len, "CPU OP:\n");
+	for (i = 0; i < cpu_ops_size; i++)
+		len += dump_cpu_op(p + len, size - len, cpu_ops + i);
+	len += snprintf(p + len, size - len, "\n");
+
+	len += snprintf(p + len, size - len, "DDR_AXI OP:\n");
+	for (i = 0; i < ddr_ops_size; i++)
+		len += dump_ddr_axi_op(p + len, size - len, ddr_ops + i);
+	len += snprintf(p + len, size - len, "\n");
+
+	if (len == size)
+		pr_warn("%s The dump buf is not large enough!\n", __func__);
+
+	ret = simple_read_from_buffer(buffer, count, ppos, p, len);
+	free_pages((unsigned long)p, 0);
+
+	return ret;
+}
+
+const struct file_operations dp_ops_fops = {
+	.read = ops_show,
+};
+
+/* show CP block AP DDR FC status */
+static ssize_t cp_block_ddr_fc_show(struct file *filp,
+	char __user *buffer, size_t count, loff_t *ppos)
+{
+	char buf[32];
+	int len = 0;
+	size_t size = sizeof(buf) - 1;
+
+	len = snprintf(buf, size, "%d\n", cp_reset_block_ddr_fc);
+	return simple_read_from_buffer(buffer, count, ppos, buf, len);
+}
+
+const struct file_operations cp_block_ddr_fc_fops = {
+	.read = cp_block_ddr_fc_show,
+};
+
+/* detect the cpu is c1,c2 or active */
+static int pxa_powermode(u32 cpu)
+{
+	unsigned status_temp = 0;
+	if (cpu_is_pxa988()) {
+		if (has_feat_legacy_apmu_core_status()) {
+			status_temp = ((__raw_readl(APMU_CORE_STATUS)) &
+			((1 << (2 + 2 * cpu)) | (1 << (3 + 2 * cpu))));
+			if (!status_temp)
+				return PXA988_MAX_LPM_INDEX;
+			else if (status_temp & (1 << (2 + 2 * cpu)))
+				return PXA988_LPM_C1;
+			else if (status_temp & (1 << (3 + 2 * cpu)))
+				return PXA988_LPM_C2;
+		} else {
+			status_temp = ((__raw_readl(APMU_CORE_STATUS)) &
+			((1 << (3 + 3 * cpu)) | (1 << (4 + 3 * cpu))));
+			if (!status_temp)
+				return PXA988_MAX_LPM_INDEX;
+			if (status_temp & (1 << (3 + 3 * cpu)))
+				return PXA988_LPM_C1;
+			else if (status_temp & (1 << (4 + 3 * cpu)))
+				return PXA988_LPM_C2;
+		}
+	} else if (cpu_is_pxa1088()) {
+		status_temp = ((__raw_readl(APMU_CORE_STATUS)) &
+		((1 << (6 + 3 * cpu)) | (1 << (7 + 3 * cpu))));
+		if (!status_temp)
+			return PXA988_MAX_LPM_INDEX;
+		if (status_temp & (1 << (6 + 3 * cpu)))
+			return PXA988_LPM_C1;
+		else if (status_temp & (1 << (7 + 3 * cpu)))
+			return PXA988_LPM_C2;
+	}
+	return PXA988_MAX_LPM_INDEX;
+}
+
+
+void pxa988_cpu_dcstat_event(unsigned int cpu,
+	enum clk_stat_msg msg, unsigned int tgtop)
+{
+#ifdef CONFIG_DEBUG_FS
+	struct clk_dc_stat_info *dc_stat_info = NULL;
+	cputime64_t cur_wall, cur_idle;
+	cputime64_t prev_wall, prev_idle;
+	u32 idle_time_ms, total_time_ms;
+	struct op_dcstat_info *cur, *tgt;
+	unsigned int cpu_i;
+	bool mark_keytime;
+	ktime_t ktime_temp, ktime_temp1;
+	u32 i, temp_time = 0;
+
+	dc_stat_info = &per_cpu(cpu_dc_stat, cpu);
+	cur = &dc_stat_info->ops_dcstat[dc_stat_info->curopindex];
+	if (msg == CLK_RATE_CHANGE) {
+		BUG_ON(tgtop >= dc_stat_info->ops_stat_size);
+		dc_stat_info->curopindex = tgtop;
+	}
+	/* do nothing if no stat operation is issued */
+	if (!dc_stat_info->stat_start)
+		return ;
+
+	cur_idle = get_cpu_idle_time(cpu, &cur_wall);
+	prev_wall = cur->prev_cpu_wall;
+	prev_idle = cur->prev_cpu_idle;
+	idle_time_ms = (u32)(cur_idle - prev_idle);
+	total_time_ms = (u32)(cur_wall - prev_wall);
+	idle_time_ms /= 1000;
+	total_time_ms /= 1000;
+	if (idle_time_ms > total_time_ms)
+		idle_time_ms = total_time_ms;
+
+	switch (msg) {
+	case CLK_STAT_START:
+		cur->prev_cpu_wall = cur_wall;
+		cur->prev_cpu_idle = cur_idle;
+		if (0 == cpu) {
+			memset(&idle_dcstat_info, 0, sizeof(idle_dcstat_info));
+			ktime_temp = ktime_get();
+			idle_dcstat_info.all_idle_start = ktime_temp;
+			idle_dcstat_info.all_idle_end = ktime_temp;
+			idle_dcstat_info.all_active_start = ktime_temp;
+			idle_dcstat_info.all_active_end = ktime_temp;
+			idle_dcstat_info.cal_duration = ktime_to_us(ktime_temp);
+			ktime_temp = ktime_set(0, 0);
+			idle_dcstat_info.M2_idle_start = ktime_temp;
+			idle_dcstat_info.D1P_idle_start = ktime_temp;
+			idle_dcstat_info.D1_idle_start = ktime_temp;
+			idle_dcstat_info.D2_idle_start = ktime_temp;
+			for_each_possible_cpu(cpu_i) {
+				dc_stat_info = &per_cpu(cpu_dc_stat, cpu_i);
+				dc_stat_info->power_mode = pxa_powermode(cpu_i);
+				dc_stat_info->breakdown_start = ktime_temp;
+				for (i = 0; i < MAX_BREAKDOWN_TIME; i++) {
+					dc_stat_info->breakdown_time_total[i]\
+					= 0;
+					dc_stat_info->breakdown_time_count[i]\
+					= 0;
+				}
+				dc_stat_info->C1_idle_start = ktime_temp;
+				dc_stat_info->C2_idle_start = ktime_temp;
+				for (i = 0; i < MAX_LPM_INDEX_DC; i++) {
+					dc_stat_info->C1_op_total[i] = 0;
+					dc_stat_info->C1_count[i] = 0;
+					dc_stat_info->C2_op_total[i] = 0;
+					dc_stat_info->C2_count[i] = 0;
+				}
+			}
+			for (i = 0; i < MAX_LPM_INDEX_DC; i++) {
+				idle_dcstat_info.all_idle_op_total[i] = 0;
+				idle_dcstat_info.all_idle_count[i] = 0;
+			}
+		}
+		break;
+	case CLK_STAT_STOP:
+		if (idle_time_ms > total_time_ms)
+			cur->busy_time = 0;
+		else
+			cur->busy_time += (total_time_ms - idle_time_ms);
+		cur->idle_time += idle_time_ms;
+		if (0 == cpu) {
+			idle_dcstat_info.cal_duration = ktime_to_us(ktime_get())
+				- idle_dcstat_info.cal_duration;
+		}
+		break;
+	case CLK_RATE_CHANGE:
+
+		/* rate change from old->new */
+		cur->prev_cpu_idle = cur_idle;
+		cur->prev_cpu_wall = cur_wall;
+		if (idle_time_ms > total_time_ms)
+			cur->busy_time = 0;
+		else
+			cur->busy_time += (total_time_ms - idle_time_ms);
+		cur->idle_time += idle_time_ms;
+		tgt = &dc_stat_info->ops_dcstat[tgtop];
+		tgt->prev_cpu_idle = cur_idle;
+		tgt->prev_cpu_wall = cur_wall;
+		ktime_temp = ktime_get();
+
+		for_each_possible_cpu(cpu_i) {
+			if (cpu == cpu_i)
+				continue;
+			dc_stat_info = &per_cpu(cpu_dc_stat, cpu_i);
+			spin_lock(&c1c2_exit_lock);
+			if ((dc_stat_info->idle_flag == PXA988_LPM_C1) &&
+				((s64)0 !=
+				ktime_to_us(dc_stat_info->C1_idle_start))) {
+				dc_stat_info->C1_idle_end = ktime_temp;
+				dc_stat_info->C1_op_total\
+				[dc_stat_info->C1_op_index] +=
+				ktime_to_us(ktime_sub(dc_stat_info->C1_idle_end,
+				dc_stat_info->C1_idle_start));
+				dc_stat_info->C1_count\
+				[dc_stat_info->C1_op_index]++;
+				dc_stat_info->C1_idle_start = ktime_temp;
+				dc_stat_info->C1_op_index = tgtop;
+			} else if ((dc_stat_info->idle_flag == PXA988_LPM_C2) &&
+				((s64)0 !=
+				ktime_to_us(dc_stat_info->C2_idle_start))) {
+				dc_stat_info->C2_idle_end = ktime_temp;
+				dc_stat_info->C2_op_total\
+				[dc_stat_info->C2_op_index] +=
+				ktime_to_us(ktime_sub(dc_stat_info->C2_idle_end,
+				dc_stat_info->C2_idle_start));
+				dc_stat_info->C2_count\
+				[dc_stat_info->C2_op_index]++;
+				dc_stat_info->C2_idle_start = ktime_temp;
+				dc_stat_info->C2_op_index = tgtop;
+			}
+			spin_unlock(&c1c2_exit_lock);
+		}
+		break;
+	case CPU_IDLE_ENTER:
+		ktime_temp = ktime_get();
+		spin_lock(&c1c2_enter_lock);
+		if (PXA988_LPM_C1 == tgtop) {
+			dc_stat_info->C1_op_index = dc_stat_info->curopindex;
+			dc_stat_info->C1_idle_start = ktime_temp;
+			dc_stat_info->idle_flag = PXA988_LPM_C1;
+		} else if (tgtop >= PXA988_LPM_C2 &&
+			tgtop <= PXA988_LPM_D2_UDR) {
+			dc_stat_info->C2_op_index = dc_stat_info->curopindex;
+			dc_stat_info->C2_idle_start = ktime_temp;
+			dc_stat_info->idle_flag = PXA988_LPM_C2;
+		}
+		if ((tgtop >= PXA988_LPM_C1) && (tgtop <= PXA988_LPM_D2_UDR))
+			dc_stat_info->breakdown_start = ktime_temp;
+		spin_unlock(&c1c2_enter_lock);
+		dc_stat_info->power_mode = tgtop;
+		/*	this mark_keytime is flag indicate enter all idle mode,
+		 *	if two core both enter the idle,and power mode isn't
+		 *  eaqual to PXA988_MAX_LPM_INDEX, mean the other core don't
+		 *  exit idle.
+		 */
+		mark_keytime = true;
+		for_each_possible_cpu(cpu_i) {
+			if (cpu == cpu_i)
+				continue;
+			dc_stat_info = &per_cpu(cpu_dc_stat, cpu_i);
+			if (PXA988_MAX_LPM_INDEX == dc_stat_info->power_mode) {
+				mark_keytime = false;
+				break;
+			}
+		}
+
+		if (mark_keytime) {
+			idle_dcstat_info.all_idle_start = ktime_temp;
+			idle_dcstat_info.all_idle_op_index =
+			dc_stat_info->curopindex;
+		}
+
+		/*	this mark_keytime is flag indicate enter all active
+		 *	mode,if two core both exit the idle,and power mode
+		 *	is both eaqual to PXA988_MAX_LPM_INDEX, mean the other
+		 *	core both exit idle.
+		 */
+
+		mark_keytime = true;
+		for_each_possible_cpu(cpu_i) {
+			if (cpu == cpu_i)
+				continue;
+			dc_stat_info = &per_cpu(cpu_dc_stat, cpu_i);
+			if (PXA988_MAX_LPM_INDEX != dc_stat_info->power_mode) {
+				mark_keytime = false;
+				break;
+			}
+		}
+		if (mark_keytime) {
+			idle_dcstat_info.all_active_end = ktime_temp;
+			idle_dcstat_info.total_all_active += ktime_to_us
+			(ktime_sub(idle_dcstat_info.all_active_end,
+				idle_dcstat_info.all_active_start));
+			idle_dcstat_info.total_all_active_count++;
+		}
+		break;
+	case CPU_IDLE_EXIT:
+		ktime_temp = ktime_get();
+		spin_lock(&c1c2_exit_lock);
+		if ((dc_stat_info->idle_flag == PXA988_LPM_C1) &&
+		((s64)0 != ktime_to_us(dc_stat_info->C1_idle_start))) {
+			dc_stat_info->C1_idle_end = ktime_temp;
+			dc_stat_info->C1_op_total[dc_stat_info->C1_op_index] +=
+			ktime_to_us(ktime_sub(dc_stat_info->C1_idle_end,
+			dc_stat_info->C1_idle_start));
+			dc_stat_info->C1_count[dc_stat_info->C1_op_index]++;
+			dc_stat_info->C1_idle_start = ktime_set(0, 0);
+		} else if ((dc_stat_info->idle_flag == PXA988_LPM_C2) &&
+		((s64)0 != ktime_to_us(dc_stat_info->C2_idle_start))) {
+			dc_stat_info->C2_idle_end = ktime_temp;
+			dc_stat_info->C2_op_total[dc_stat_info->C2_op_index] +=
+			ktime_to_us(ktime_sub(dc_stat_info->C2_idle_end,
+			dc_stat_info->C2_idle_start));
+			dc_stat_info->C2_count[dc_stat_info->C2_op_index]++;
+			dc_stat_info->C2_idle_start = ktime_set(0, 0);
+		}
+		spin_unlock(&c1c2_exit_lock);
+		dc_stat_info->idle_flag = PXA988_MAX_LPM_INDEX;
+		if ((s64)0 != ktime_to_us(dc_stat_info->breakdown_start)) {
+			dc_stat_info->breakdown_end = ktime_temp;
+			temp_time = ktime_to_us(ktime_sub
+			(dc_stat_info->breakdown_end,
+			dc_stat_info->breakdown_start));
+			if (temp_time) {
+				if (temp_time >= 100 * 1000) {
+					dc_stat_info->breakdown_time_count\
+					[MAX_BREAKDOWN_TIME - 1]++;
+					dc_stat_info->breakdown_time_total\
+					[MAX_BREAKDOWN_TIME - 1] += temp_time;
+				} else {
+					i = (temp_time / (10 * 1000));
+					dc_stat_info->breakdown_time_count[i]++;
+					dc_stat_info->breakdown_time_total[i]\
+					+= temp_time;
+				}
+			}
+		}
+
+		dc_stat_info->power_mode = tgtop;
+		mark_keytime = true;
+		for_each_possible_cpu(cpu_i) {
+			if (cpu == cpu_i)
+				continue;
+			dc_stat_info = &per_cpu(cpu_dc_stat, cpu_i);
+			if (PXA988_MAX_LPM_INDEX == dc_stat_info->power_mode) {
+				mark_keytime = false;
+				break;
+			}
+		}
+		spin_lock(&allidle_lock);
+		if (mark_keytime) {
+			idle_dcstat_info.all_idle_end = ktime_temp;
+				idle_dcstat_info.total_all_idle += ktime_to_us
+				(ktime_sub(idle_dcstat_info.all_idle_end,
+					idle_dcstat_info.all_idle_start));
+				idle_dcstat_info.total_all_idle_count++;
+
+				if ((s64)0 != ktime_to_us
+					(idle_dcstat_info.all_idle_start)) {
+					idle_dcstat_info.all_idle_op_total\
+					[idle_dcstat_info.all_idle_op_index] +=
+					ktime_to_us(ktime_sub
+					(idle_dcstat_info.all_idle_end,
+					idle_dcstat_info.all_idle_start));
+					idle_dcstat_info.all_idle_count\
+					[idle_dcstat_info.all_idle_op_index]++;
+				}
+
+			if ((s64)0 != ktime_to_us
+				(idle_dcstat_info.M2_idle_start)) {
+				idle_dcstat_info.M2_idle_total +=
+				ktime_to_us(ktime_sub(
+				idle_dcstat_info.all_idle_end,
+				idle_dcstat_info.M2_idle_start));
+				idle_dcstat_info.M2_count++;
+			} else if ((s64)0 != ktime_to_us
+				(idle_dcstat_info.D1P_idle_start)) {
+				idle_dcstat_info.D1P_idle_total += ktime_to_us
+				(ktime_sub(idle_dcstat_info.all_idle_end,
+				idle_dcstat_info.D1P_idle_start));
+				idle_dcstat_info.D1p_count++;
+			} else if ((s64)0 != ktime_to_us
+				(idle_dcstat_info.D1_idle_start)) {
+				idle_dcstat_info.D1_idle_total += ktime_to_us
+				(ktime_sub(idle_dcstat_info.all_idle_end,
+				idle_dcstat_info.D1_idle_start));
+				idle_dcstat_info.D1_count++;
+			} else if ((s64)0 != ktime_to_us
+				(idle_dcstat_info.D2_idle_start)) {
+				idle_dcstat_info.D2_idle_total += ktime_to_us
+				(ktime_sub(idle_dcstat_info.all_idle_end,
+				idle_dcstat_info.D2_idle_start));
+				idle_dcstat_info.D2_count++;
+				}
+			ktime_temp1 = ktime_set(0, 0);
+			idle_dcstat_info.M2_idle_start = ktime_temp1;
+			idle_dcstat_info.D1P_idle_start = ktime_temp1;
+			idle_dcstat_info.D1_idle_start = ktime_temp1;
+			idle_dcstat_info.D2_idle_start = ktime_temp1;
+		}
+		spin_unlock(&allidle_lock);
+		mark_keytime = true;
+		for_each_possible_cpu(cpu_i) {
+			if (cpu == cpu_i)
+				continue;
+			dc_stat_info = &per_cpu(cpu_dc_stat, cpu_i);
+			if (PXA988_MAX_LPM_INDEX != dc_stat_info->power_mode) {
+				mark_keytime = false;
+				break;
+			}
+		}
+		if (mark_keytime)
+			idle_dcstat_info.all_active_start = ktime_temp;
+		break;
+	case CPU_M2_OR_DEEPER_ENTER:
+		ktime_temp = ktime_get();
+		if (PXA988_LPM_C2 == tgtop)
+			idle_dcstat_info.M2_idle_start = ktime_temp;
+		else if (PXA988_LPM_D1P == tgtop)
+			idle_dcstat_info.D1P_idle_start = ktime_temp;
+		else if (PXA988_LPM_D1 == tgtop)
+			idle_dcstat_info.D1_idle_start = ktime_temp;
+		else if (PXA988_LPM_D2 == tgtop)
+			idle_dcstat_info.D2_idle_start = ktime_temp;
+		break;
+	default:
+		break;
+	}
+#endif
+}
+
+static ssize_t pxa988_cpu_dc_read(struct file *filp,
+	char __user *buffer, size_t count, loff_t *ppos)
+{
+	char *buf;
+	int len = 0;
+	size_t ret, size = 2 * PAGE_SIZE - 1;
+	unsigned int cpu, i, dc_int = 0, dc_fra = 0;
+	struct clk_dc_stat_info *percpu_stat = NULL;
+	u64 total_time, run_total, idle_total, busy_time;
+	u64 av_mips;
+	u32 av_mips_l, av_mips_h;
+	u64 temp_total_time = 0, temp_total_count = 0;
+	char *lpm_time_string[12] = {"<10 ms", "<20 ms", "<30 ms",
+	"<40 ms", "<50 ms", "<60 ms", "<70 ms", "<80 ms",
+	"<90 ms", "<100 ms", ">100 ms"};
+
+
+	buf = (char *)__get_free_pages(GFP_NOIO, get_order(size));
+	if (!buf)
+		return -ENOMEM;
+
+	percpu_stat = &per_cpu(cpu_dc_stat, 0);
+	if (percpu_stat->stat_start) {
+		len += snprintf(buf + len, size - len,
+			"Please stop the cpu duty cycle stats at first\n");
+		goto out;
+	}
+
+	for_each_possible_cpu(cpu) {
+		percpu_stat = &per_cpu(cpu_dc_stat, cpu);
+		av_mips = run_total = idle_total = 0;
+		for (i = 0; i < percpu_stat->ops_stat_size; i++) {
+			idle_total += percpu_stat->ops_dcstat[i].idle_time;
+			run_total += percpu_stat->ops_dcstat[i].busy_time;
+			av_mips += (u64)(percpu_stat->ops_dcstat[i].pprate *\
+				percpu_stat->ops_dcstat[i].busy_time);
+		}
+		total_time = idle_total + run_total;
+		if (!total_time) {
+			len += snprintf(buf + len, size - len,
+				"No stat information! ");
+			len += snprintf(buf + len, size - len,
+				"Help information :\n");
+			len += snprintf(buf + len, size - len,
+				"1. echo 1 to start duty cycle stat:\n");
+			len += snprintf(buf + len, size - len,
+				"2. echo 0 to stop duty cycle stat:\n");
+			len += snprintf(buf + len, size - len,
+				"3. cat to check duty cycle info from start to stop:\n\n");
+			goto out;
+		}
+		av_mips_l = 0;
+		av_mips_h = div_u64_rem(av_mips, total_time, &av_mips_l);
+		av_mips_l = div_u64(av_mips_l * 100, total_time);
+		dc_int = calculate_dc(run_total, total_time, &dc_fra);
+		dc_fra = dc_fra;
+		len += snprintf(buf + len, size - len,
+			"\n| CPU %u | %10s %lldms| %10s %lldms|"\
+			"%10s %2u.%2u%%|%10s %u.%02uMHz |\n", cpu, "idle time",
+			idle_total, "total time", total_time,
+			"duty cycle", dc_int, dc_fra,
+			"average mips", av_mips_h, av_mips_l);
+		len += snprintf(buf + len, size - len,
+			"| %3s | %5s | %8s | %8s | %8s | %8s |"\
+			" %8s | %8s | %8s | %8s | %8s |\n",
+			"OP#", "rate", "run time",
+			"idle time", "rt ratio",
+			"All idle", "Aidle count",
+			"C1 ratio", "C1 count" , "C2 ratio", "C2 count");
+		for (i = 0; i < percpu_stat->ops_stat_size; i++) {
+			if (total_time) {
+				busy_time =
+					percpu_stat->ops_dcstat[i].busy_time;
+				dc_int = calculate_dc(busy_time, total_time,
+							&dc_fra);
+			}
+			len += snprintf(buf + len, size - len,
+				"| %3u | %5lu | %8lu | %9lu | %4u.%2u%% |"\
+				" %7lld%% | %11lld | %7lld%% | %8lld |"\
+				" %7lld%% | %8lld |\n",
+				percpu_stat->ops_dcstat[i].ppindex,
+				percpu_stat->ops_dcstat[i].pprate,
+				percpu_stat->ops_dcstat[i].busy_time,
+				percpu_stat->ops_dcstat[i].idle_time,
+				dc_int, dc_fra,
+				div64_u64
+				(idle_dcstat_info.all_idle_op_total[i] *
+				(u64)(100), idle_dcstat_info.cal_duration),
+				idle_dcstat_info.all_idle_count[i],
+				div64_u64(percpu_stat->C1_op_total[i] *
+				(u64)(100), idle_dcstat_info.cal_duration),
+				percpu_stat->C1_count[i],
+				div64_u64(percpu_stat->C2_op_total[i] *
+				(u64)(100), idle_dcstat_info.cal_duration),
+				percpu_stat->C2_count[i]
+				);
+		}
+	}
+
+	len += snprintf(buf + len, size - len, "| %10s | %15s |"\
+	" %15s | %15s |\n", "state", "ratio", "time(ms)", "count");
+	len += snprintf(buf + len, size - len, "| %10s | %14lld%% |"\
+	" %15lld | %15lld | === > Both core active\n", "All active",
+	div64_u64(idle_dcstat_info.total_all_active*(u64)(100),
+	idle_dcstat_info.cal_duration),
+	div64_u64(idle_dcstat_info.total_all_active, (u64)1000),
+	idle_dcstat_info.total_all_active_count);
+	len += snprintf(buf + len, size - len, "| %10s | %14lld%% |"\
+	" %15lld | %15lld | === > Both core idle\n", "All idle",
+	div64_u64(idle_dcstat_info.total_all_idle*(u64)(100),
+	idle_dcstat_info.cal_duration),
+	div64_u64(idle_dcstat_info.total_all_idle, (u64)1000),
+	idle_dcstat_info.total_all_idle_count);
+	len += snprintf(buf + len, size - len, "| %10s | %14lld%% | %15lld |"\
+	" %15lld |\n", "M2", div64_u64(idle_dcstat_info.M2_idle_total*
+	(u64)(100), idle_dcstat_info.cal_duration),
+	div64_u64(idle_dcstat_info.M2_idle_total,
+	(u64)1000), idle_dcstat_info.M2_count);
+	len += snprintf(buf + len, size - len, "| %10s | %14lld%% | %15lld |"\
+	" %15lld |\n", "D1P", div64_u64(idle_dcstat_info.D1P_idle_total*
+	(u64)(100), idle_dcstat_info.cal_duration),
+	div64_u64(idle_dcstat_info.D1P_idle_total,
+	(u64)1000), idle_dcstat_info.D1p_count);
+	len += snprintf(buf + len, size - len, "| %10s | %14lld%% | %15lld |"\
+	" %15lld |\n", "D1", div64_u64(idle_dcstat_info.D1_idle_total*
+	(u64)(100), idle_dcstat_info.cal_duration),
+	div64_u64(idle_dcstat_info.D1_idle_total,
+	(u64)1000), idle_dcstat_info.D1_count);
+	len += snprintf(buf + len, size - len, "| %10s | %14lld%% | %15lld |"\
+	" %15lld |\n", "D2", div64_u64(idle_dcstat_info.D2_idle_total*
+	(u64)(100), idle_dcstat_info.cal_duration),
+	div64_u64(idle_dcstat_info.D2_idle_total,
+	(u64)1000), idle_dcstat_info.D2_count);
+	len += snprintf(buf + len, size - len,
+	"| %10s | %14lld%% | %15lld |"\
+	" === > Total test time\n", "All time", (u64)100,
+	div64_u64(idle_dcstat_info.cal_duration, (u64)1000));
+
+	for_each_possible_cpu(cpu) {
+		percpu_stat = &per_cpu(cpu_dc_stat, cpu);
+		len += snprintf(buf + len, size - len,
+		"|  cpu%d idle | %15s |"\
+		" %15s |\n", cpu, "all time(ms)", "count");
+		temp_total_time = temp_total_count = 0;
+		for (i = 0; i < MAX_BREAKDOWN_TIME; i++) {
+			if (0 != percpu_stat->breakdown_time_total[i] ||
+			0 != percpu_stat->breakdown_time_count[i]) {
+				len += snprintf(buf + len, size - len,
+				"| %10s | %15lld | %15lld |\n",
+				lpm_time_string[i],
+				div64_u64(percpu_stat->breakdown_time_total[i],
+				(u64)1000),
+				percpu_stat->breakdown_time_count[i]);
+				temp_total_time += div64_u64
+				(percpu_stat->breakdown_time_total[i],
+				(u64)1000);
+				temp_total_count +=
+				percpu_stat->breakdown_time_count[i];
+			}
+		}
+		len += snprintf(buf + len, size - len,
+		"| %10s | %15lld | %15lld |"\
+		" === > Total 10~100ms time\n", "All time",
+		temp_total_time, temp_total_count);
+	}
+out:
+	if (len == size)
+		pr_warn("%s The dump buf is not large enough!\n", __func__);
+
+	ret = simple_read_from_buffer(buffer, count, ppos, buf, len);
+	free_pages((unsigned long)buf, get_order(size));
+	return ret;
+}
+
+static ssize_t pxa988_cpu_dc_write(struct file *filp,
+		const char __user *buffer, size_t count, loff_t *ppos)
+{
+	unsigned int start, cpu, i;
+	char buf[10] = { 0 };
+	struct clk_dc_stat_info *percpu_stat = NULL;
+
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%d", &start);
+	start = !!start;
+	percpu_stat = &per_cpu(cpu_dc_stat, 0);
+	if (start == percpu_stat->stat_start) {
+		pr_err("[WARNING]CPU stat is already %s\n",
+			percpu_stat->stat_start ?\
+			"started" : "stopped");
+		return -EINVAL;
+	}
+	/*
+	 * hold the same lock of clk_enable, disable, set_rate ops
+	 * here to avoid the status change when start/stop and lead
+	 * to incorrect stat info
+	 */
+	clk_get_lock(&pxa988_cpu_clk);
+	if (start) {
+		/* clear old stat information */
+		for_each_possible_cpu(cpu) {
+			percpu_stat = &per_cpu(cpu_dc_stat, cpu);
+			for (i = 0; i < percpu_stat->ops_stat_size; i++) {
+				percpu_stat->ops_dcstat[i].idle_time = 0;
+				percpu_stat->ops_dcstat[i].busy_time = 0;
+			}
+			percpu_stat->stat_start = true;
+			pxa988_cpu_dcstat_event(cpu, CLK_STAT_START, 0);
+		}
+	} else {
+		for_each_possible_cpu(cpu) {
+			percpu_stat = &per_cpu(cpu_dc_stat, cpu);
+			pxa988_cpu_dcstat_event(cpu, CLK_STAT_STOP, 0);
+			percpu_stat->stat_start = false;
+		}
+	}
+	clk_release_lock(&pxa988_cpu_clk);
+	return count;
+}
+
+static const struct file_operations pxa988_cpu_dc_ops = {
+	.owner = THIS_MODULE,
+	.read = pxa988_cpu_dc_read,
+	.write = pxa988_cpu_dc_write,
+};
+
+static ssize_t pxa988_ddr_dc_read(struct file *filp,
+	char __user *buffer, size_t count, loff_t *ppos)
+{
+	char *p;
+	int len = 0;
+	size_t ret, size = PAGE_SIZE - 1;
+
+	p = (char *)__get_free_pages(GFP_NOIO, 0);
+	if (!p)
+		return -ENOMEM;
+
+	len = pxa988_show_dc_stat_info(&pxa988_ddr_clk, p, size);
+	if (len < 0) {
+		free_pages((unsigned long)p, 0);
+		return -EINVAL;
+	}
+	if (len == size)
+		pr_warn("%s The dump buf is not large enough!\n", __func__);
+
+	ret = simple_read_from_buffer(buffer, count, ppos, p, len);
+	free_pages((unsigned long)p, 0);
+	return ret;
+}
+
+static ssize_t pxa988_ddr_dc_write(struct file *filp,
+		const char __user *buffer, size_t count, loff_t *ppos)
+{
+	unsigned int start;
+	char buf[10] = { 0 };
+	int ret = 0;
+
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%d", &start);
+	ret = pxa988_start_stop_dc_stat(&pxa988_ddr_clk, start);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+static const struct file_operations pxa988_ddr_dc_ops = {
+	.owner = THIS_MODULE,
+	.read = pxa988_ddr_dc_read,
+	.write = pxa988_ddr_dc_write,
+};
+
+static int __init __init_cpu_ddr_dcstat_node(void)
+{
+	struct dentry *cpu_dc_stat, *ddr_dc_stat;
+
+	cpu_dc_stat = debugfs_create_file("cpu_dc_stat", 0664,
+		stat, NULL, &pxa988_cpu_dc_ops);
+	if (!cpu_dc_stat)
+		return -ENOENT;
+	spin_lock_init(&allidle_lock);
+	spin_lock_init(&c1c2_enter_lock);
+	spin_lock_init(&c1c2_exit_lock);
+	ddr_dc_stat = debugfs_create_file("ddr_dc_stat", 0664,
+		stat, NULL, &pxa988_ddr_dc_ops);
+	if (!ddr_dc_stat)
+		goto err_cpu_dc_stat;
+	return 0;
+
+err_cpu_dc_stat:
+	debugfs_remove(cpu_dc_stat);
+	return -ENOENT;
+}
+
+static int __init __init_create_fc_debugfs_node(void)
+{
+	struct dentry *fc;
+	struct dentry *dp_cur_cpu_op, *dp_cur_ddraxi_op, *dp_ops;
+	struct dentry *dp_cp_block_ddr_fc;
+	int ret = 0;
+#ifdef CONFIG_DDR_FC_HARDWARE
+	struct dentry *dp_lcd_blank_check;
+#endif
+
+	fc = debugfs_create_dir("fc", pxa);
+	if (!fc)
+		return -ENOENT;
+
+	dp_cur_cpu_op = debugfs_create_file("cur_cpu_op", 0444,
+		fc, NULL, &dp_cur_cpu_op_fops);
+	if (!dp_cur_cpu_op)
+		goto err_cur_cpu_op;
+
+	dp_cur_ddraxi_op = debugfs_create_file("cur_ddr_axi_op", 0444,
+		fc, NULL, &dp_cur_ddr_axi_op_fops);
+	if (!dp_cur_ddraxi_op)
+		goto err_cur_ddraxi_op;
+
+	dp_ops = debugfs_create_file("ops", 0444,
+		fc, NULL, &dp_ops_fops);
+	if (!dp_ops)
+		goto err_dp_ops;
+
+	dp_cp_block_ddr_fc = debugfs_create_file("cp_block_ddr_fc", 0444,
+		fc, NULL, &cp_block_ddr_fc_fops);
+	if (!dp_cp_block_ddr_fc)
+		goto err_dp_cp_block_ddr_fc;
+
+#ifdef CONFIG_DDR_FC_HARDWARE
+	/* ddr_dfc_inlcdblk the interface is for hw control
+	 * DDR freq-chg in lcd v-blank
+	 */
+	dp_lcd_blank_check = debugfs_create_file("ddr_dfc_inlcdblk", 0664,
+		fc, NULL, &lcd_blank_check_fops);
+	if (!dp_lcd_blank_check)
+		goto err_lcd_blank_check;
+#endif
+	ret = __init_cpu_ddr_dcstat_node();
+	return ret;
+
+#ifdef CONFIG_DDR_FC_HARDWARE
+err_lcd_blank_check:
+	debugfs_remove(dp_cp_block_ddr_fc);
+	dp_lcd_blank_check = NULL;
+#endif
+err_dp_cp_block_ddr_fc:
+	debugfs_remove(dp_ops);
+	dp_ops = NULL;
+err_dp_ops:
+	debugfs_remove(dp_cur_ddraxi_op);
+	dp_cur_ddraxi_op = NULL;
+err_cur_ddraxi_op:
+	debugfs_remove(dp_cur_cpu_op);
+	dp_cur_cpu_op = NULL;
+err_cur_cpu_op:
+	debugfs_remove(fc);
+	fc = NULL;
+	return -ENOENT;
+}
+late_initcall(__init_create_fc_debugfs_node);
+late_initcall(__init_create_pm_dro_node);
+#endif
+
+static unsigned long pxa988_periph_getrate(struct clk *clk)
+{
+	unsigned long periph_rate;
+
+	if (likely(cur_cpu_op))
+		periph_rate = cur_cpu_op->periphclk * MHZ;
+	else
+		/*
+		* when cur_cpu_op is not ready yet, calculate it from lpj,
+		* it's [core freq] / 8.
+		*/
+		periph_rate = loops_per_jiffy * 2 * HZ / 8;
+
+	return periph_rate;
+}
+
+struct clkops periph_clk_ops = {
+	.getrate = pxa988_periph_getrate,
+};
+
+static struct clk pxa988_periph_clk = {
+	.name = "smp_twd",
+	.lookup = {
+		.dev_id = "smp_twd",
+	},
+	.ops = &periph_clk_ops,
+};
+
+void __init pxa988_init_early(void)
+{
+	pxa988_init_one_clock(&pxa988_periph_clk);
+}
diff --git a/arch/arm/mach-mmp/board-goya-battery.c b/arch/arm/mach-mmp/board-goya-battery.c
new file mode 100755
index 00000000..cf7918d1
--- /dev/null
+++ b/arch/arm/mach-mmp/board-goya-battery.c
@@ -0,0 +1,871 @@
+/* arch/arm/mach-mmp/board-wilcox-battery.c
+ *
+ * Copyright (C) 2012 Samsung Electronics Co, Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/switch.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/regulator/machine.h>
+#include <linux/platform_device.h>
+#include <mach/mfp-pxa986-goya.h>
+
+#include <linux/battery/sec_battery.h>
+#include <linux/battery/sec_fuelgauge.h>
+#include <linux/battery/sec_charger.h>
+#include <linux/gpio_event.h>
+#if defined(CONFIG_MFD_RT8973)
+#include <linux/mfd/rt8973.h>
+#endif
+#if defined(CONFIG_FUELGAUGE_RT5033)
+#include <linux/battery/fuelgauge/rt5033_fuelgauge.h>
+#include <linux/battery/fuelgauge/rt5033_fuelgauge_impl.h>
+#include <linux/mfd/rt5033.h>
+#endif
+#if defined(CONFIG_SM5502_MUIC)
+#include <mach/sm5502-muic.h>
+#endif
+
+#include <linux/mfd/88pm822.h>
+#if defined(CONFIG_FUELGAUGE_88PM822)
+#include <linux/battery/fuelgauge/88pm80x_fg.h>
+#endif
+
+#include "board-goya.h"
+#include "common.h"
+
+#if defined(CONFIG_BATTERY_SAMSUNG)
+
+#define SEC_STBC_I2C_ID		6
+#define SEC_CHARGER_I2C_ID	6
+#define SEC_FUELGAUGE_I2C_ID	6
+
+#define SEC_STBC_I2C_SLAVEADDR		0x71
+#define SEC_STBC_CHG_EN			mfp_to_gpio(GPIO008_GPIO_8)
+#define STBC_LOW_BATT				mfp_to_gpio(GPIO009_GPIO_9)
+
+#define SEC_BATTERY_PMIC_NAME ""
+
+#define TA_ADC_LOW              800
+#define TA_ADC_HIGH             2200
+
+/* cable state */
+bool is_cable_attached;
+unsigned int lpcharge;
+extern unsigned int system_rev;
+
+static sec_bat_adc_table_data_t golden_temp_table[] = {
+	{601, 600},
+	{621, 590},
+	{641, 580},
+	{661, 570},
+	{683, 560},
+	{705, 550},
+	{728, 540},
+	{753, 530},
+	{777, 520},
+	{803, 510},
+	{830, 500},
+	{858, 490},
+	{887, 480},
+	{917, 470},
+	{949, 460},
+	{981, 450},
+	{1015, 440},
+	{1050, 430},
+	{1087, 420},
+	{1125, 410},
+	{1164, 400},
+	{1205, 390},
+	{1248, 380},
+	{1292, 370},
+	{1338, 360},
+	{1386, 350},
+	{1436, 340},
+	{1489, 330},
+	{1543, 320},
+	{1600, 310},
+	{1659, 300},
+	{1721, 290},
+	{1785, 280},
+	{1852, 270},
+	{1922, 260},
+	{1995, 250},
+	{2071, 240},
+	{2151, 230},
+	{2234, 220},
+	{2320, 210},
+	{2410, 200},
+	{2505, 190},
+	{2604, 180},
+	{2707, 170},
+	{2815, 160},
+	{2928, 150},
+	{3046, 140},
+	{3170, 130},
+	{3299, 120},
+	{3435, 110},
+	{3577, 100},
+	{3725, 90},
+	{3881, 80},
+	{4044, 70},
+	{4215, 60},
+	{4394, 50},
+	{4582, 40},
+	{4779, 30},
+	{4986, 20},
+	{5203, 10},
+	{5431, 0},
+	{5671, -10},
+	{5924, -20},
+	{6190, -30},
+	{6469, -40},
+	{6763, -50},
+	{7072, -60},
+	{7397, -70},
+	{7740, -80},
+	{8101, -90},
+	{8481, -100},
+	{8880, -110},
+	{9301, -120},
+	{9744, -130},
+	{10212, -140},
+	{10705, -150},
+	{11225, -160},
+	{11775, -170},
+	{12355, -180},
+	{12968, -190},
+	{13616, -200},
+};
+
+static sec_bat_adc_region_t cable_adc_value_table[] = {
+	{ 0,    0 },    /* POWER_SUPPLY_TYPE_UNKNOWN */
+	{ 0,    500 },  /* POWER_SUPPLY_TYPE_BATTERY */
+	{ 0,    0 },    /* POWER_SUPPLY_TYPE_UPS */
+	{ 1000, 1500 }, /* POWER_SUPPLY_TYPE_MAINS */
+	{ 0,    0 },    /* POWER_SUPPLY_TYPE_USB */
+	{ 0,    0 },    /* POWER_SUPPLY_TYPE_OTG */
+	{ 0,    0 },    /* POWER_SUPPLY_TYPE_DOCK */
+	{ 0,    0 },    /* POWER_SUPPLY_TYPE_MISC */
+};
+
+static sec_charging_current_t charging_current_table[] = {
+	{0,     0,      0,      0},     /* POWER_SUPPLY_TYPE_UNKNOWN */
+	{0,     0,      0,      0},     /* POWER_SUPPLY_TYPE_BATTERY */
+	{0,     0,      0,      0},     /* POWER_SUPPLY_TYPE_UPS */
+	{1000,  1550,   200,    2400},     /* POWER_SUPPLY_TYPE_MAINS */
+	{550,   500,    200,    2400},     /* POWER_SUPPLY_TYPE_USB */
+	{550,   500,    200,    2400},     /* POWER_SUPPLY_TYPE_USB_DCP */
+	{550,   500,    200,    2400},     /* POWER_SUPPLY_TYPE_USB_CDP */
+	{550,   500,    200,    2400},     /* POWER_SUPPLY_TYPE_USB_ACA */
+	{550,   500,    200,    2400},     /* POWER_SUPPLY_TYPE_MISC */
+	{0,     0,      0,      0},     /* POWER_SUPPLY_TYPE_CARDOCK */
+	{550,   500,    200,    2400},     /* POWER_SUPPLY_TYPE_WPC */
+	{750,   750,   	200,    2400},     /* POWER_SUPPLY_TYPE_UARTOFF */
+};
+
+/* unit: seconds */
+static int polling_time_table[] = {
+	60,     /* BASIC */
+	60,     /* CHARGING */
+	60,     /* DISCHARGING */
+	60,     /* NOT_CHARGING */
+	1800,    /* SLEEP */
+};
+
+static struct power_supply *charger_supply;
+static bool is_jig_on;
+
+static bool sec_bat_gpio_init(void)
+{
+	return true;
+}
+
+static bool sec_fg_gpio_init(void)
+{
+	return true;
+}
+
+static bool sec_chg_gpio_init(void)
+{
+	int ret;
+
+	ret = gpio_request(mfp_to_gpio(GPIO098_GPIO_98), "bq24157_CD");
+	if(ret)
+		return false;
+
+	ret = gpio_request(mfp_to_gpio(GPIO008_GPIO_8), "charger-irq");
+	if(ret)
+		return false;
+
+	gpio_direction_input(mfp_to_gpio(GPIO008_GPIO_8));
+
+	return true;
+}
+
+/* Get LP charging mode state */
+
+static int battery_get_lpm_state(char *str)
+{
+	get_option(&str, &lpcharge);
+	pr_info("%s: Low power charging mode: %d\n", __func__, lpcharge);
+
+	return lpcharge;
+}
+__setup("lpcharge=", battery_get_lpm_state);
+
+static bool sec_bat_is_lpm(void)
+{
+	return lpcharge == 1 ? true : false;
+}
+
+void check_jig_status(int status)
+{
+	if (status) {
+		pr_info("%s: JIG On so reset fuel gauge capacity\n", __func__);
+		is_jig_on = true;
+	}
+
+}
+
+static bool sec_bat_check_jig_status(void)
+{
+	return is_jig_on;
+}
+
+int current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+u8 attached_cable;
+
+#if defined(CONFIG_MFD_RT8973)
+#if defined(CONFIG_SENSORS_GRIP_SX9500) && defined(CONFIG_MACH_GOYA)
+extern void charger_status_cb(int status);
+#endif
+void sec_charger_cb(u8 cable_type)
+{
+	pr_info("%s: cable type (0x%02x)\n", __func__, cable_type);
+
+	union power_supply_propval value;
+	struct power_supply *psy = power_supply_get_by_name("battery");
+
+	attached_cable = cable_type;
+	is_jig_on = false;
+
+	switch (cable_type) {
+	case MUIC_RT8973_CABLE_TYPE_NONE:
+	case MUIC_RT8973_CABLE_TYPE_0x1A:
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		break;
+	case MUIC_RT8973_CABLE_TYPE_USB:
+	case MUIC_RT8973_CABLE_TYPE_CDP:
+		current_cable_type = POWER_SUPPLY_TYPE_USB;
+		break;
+	case MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF_WITH_VBUS:
+	case MUIC_RT8973_CABLE_TYPE_JIG_UART_ON_WITH_VBUS:
+		is_jig_on = true;
+		current_cable_type = POWER_SUPPLY_TYPE_MAINS;
+		break;
+	case MUIC_RT8973_CABLE_TYPE_REGULAR_TA:
+	case MUIC_RT8973_CABLE_TYPE_ATT_TA:
+		current_cable_type = POWER_SUPPLY_TYPE_MAINS;
+		break;
+	case MUIC_RT8973_CABLE_TYPE_OTG:
+		goto skip;
+	case MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF:
+		is_jig_on = true;
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		break;
+	case MUIC_RT8973_CABLE_TYPE_JIG_USB_ON:
+	case MUIC_RT8973_CABLE_TYPE_JIG_USB_OFF:
+		is_jig_on = true;
+		current_cable_type = POWER_SUPPLY_TYPE_USB;
+		break;
+	case MUIC_RT8973_CABLE_TYPE_L_SPEC_USB:
+		current_cable_type = POWER_SUPPLY_TYPE_USB;
+		break;
+	case MUIC_RT8973_CABLE_TYPE_TYPE1_CHARGER:
+		current_cable_type = POWER_SUPPLY_TYPE_MAINS;
+		break;
+	case MUIC_RT8973_CABLE_TYPE_0x15:
+	case MUIC_RT8973_CABLE_TYPE_0x1A_VBUS:
+		current_cable_type = POWER_SUPPLY_TYPE_MISC;
+		break;
+	default:
+		pr_err("%s: invalid type for charger:%d\n",
+			__func__, cable_type);
+		current_cable_type = POWER_SUPPLY_TYPE_UNKNOWN;
+		goto skip;
+	}
+
+	if (!psy || !psy->set_property)
+		pr_err("%s: fail to get battery psy\n", __func__);
+	else {
+		value.intval = current_cable_type;
+		psy->set_property(psy, POWER_SUPPLY_PROP_ONLINE, &value);
+	}
+#if defined(CONFIG_SENSORS_GRIP_SX9500) && defined(CONFIG_MACH_GOYA)
+	/* for grip sensor threshold change at TA/USB status - sx9500.c */
+	charger_status_cb(current_cable_type);
+#endif
+skip:
+	return 0;
+}
+#else
+void sec_charger_cb(u8 cable_type)
+{
+
+	pr_info("%s: cable type (0x%02x)\n", __func__, cable_type);
+
+	union power_supply_propval value;
+	struct power_supply *psy = power_supply_get_by_name("battery");
+
+	attached_cable = cable_type;
+
+	switch (cable_type) {
+	case CABLE_TYPE_NONE_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		break;
+	case CABLE_TYPE1_USB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_USB;
+		break;
+	case CABLE_TYPE1_TA_MUIC:
+	case CABLE_TYPE3_U200CHG_MUIC:
+	case CABLE_TYPE2_JIG_UART_OFF_VB_MUIC:
+	case CABLE_TYPE2_JIG_UART_ON_VB_MUIC:
+		pr_info("%s: VBUS Online\n", __func__);
+		current_cable_type = POWER_SUPPLY_TYPE_MAINS;
+		break;
+	case CABLE_TYPE1_OTG_MUIC:
+		goto skip;
+	case CABLE_TYPE2_JIG_UART_OFF_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		break;
+	case CABLE_TYPE2_JIG_USB_ON_MUIC:
+	case CABLE_TYPE2_JIG_USB_OFF_MUIC:
+	case CABLE_TYPE1_CARKIT_T1OR2_MUIC:
+	case CABLE_TYPE3_DESKDOCK_VB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_USB;
+		break;
+	default:
+		pr_err("%s: invalid type for charger:%d\n",
+			__func__, cable_type);
+		current_cable_type = POWER_SUPPLY_TYPE_UNKNOWN;
+		goto skip;
+	}
+
+	if (!psy || !psy->set_property)
+		pr_err("%s: fail to get battery psy\n", __func__);
+	else {
+		value.intval = current_cable_type;
+		psy->set_property(psy, POWER_SUPPLY_PROP_ONLINE, &value);
+	}
+
+skip:
+	return;
+}
+#endif
+
+
+static int sec_bat_check_cable_callback(void)
+{
+	int ta_nconnected;
+	union power_supply_propval value;
+	struct power_supply *psy = power_supply_get_by_name("battery");
+
+	ta_nconnected = gpio_get_value(mfp_to_gpio(GPIO008_GPIO_8));
+
+	pr_info("%s : ta_nconnected : %d\n", __func__, ta_nconnected);
+
+	if (ta_nconnected)
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+	else
+		current_cable_type = POWER_SUPPLY_TYPE_MAINS;
+#if 0
+	if(attached_cable == MUIC_RT8973_CABLE_TYPE_0x1A) {
+		if (ta_nconnected)
+			current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		else
+			current_cable_type = POWER_SUPPLY_TYPE_MISC;
+	} else
+		return current_cable_type;
+#endif
+	if (!psy || !psy->set_property)
+		pr_err("%s: fail to get battery psy\n", __func__);
+	else {
+		value.intval = current_cable_type;
+		psy->set_property(psy, POWER_SUPPLY_PROP_ONLINE, &value);
+	}
+
+	return current_cable_type;
+}
+
+static void sec_bat_initial_check(void)
+{
+	union power_supply_propval value;
+
+	if (POWER_SUPPLY_TYPE_BATTERY < current_cable_type) {
+		value.intval = current_cable_type;
+		psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_ONLINE, value);
+	} else {
+		psy_do_property("sec-charger", get,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		if (value.intval == POWER_SUPPLY_TYPE_WPC) {
+			value.intval =
+				POWER_SUPPLY_TYPE_WPC;
+			psy_do_property("battery", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+		}
+/*
+		else {
+			value.intval =
+				POWER_SUPPLY_TYPE_BATTERY;
+				psy_do_property("sec-charger", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+		}
+*/
+	}
+}
+
+static bool sec_bat_check_cable_result_callback(int cable_type)
+{
+	bool ret = true;
+	current_cable_type = cable_type;
+
+	switch (cable_type) {
+	case POWER_SUPPLY_TYPE_USB:
+		pr_info("%s set vbus applied\n",
+				__func__);
+		break;
+	case POWER_SUPPLY_TYPE_BATTERY:
+		pr_info("%s set vbus cut\n",
+				__func__);
+		break;
+	case POWER_SUPPLY_TYPE_MAINS:
+		break;
+	default:
+		pr_err("%s cable type (%d)\n",
+				__func__, cable_type);
+		ret = false;
+		break;
+	}
+	/* omap4_tab3_tsp_ta_detect(cable_type); */
+
+	return ret;
+}
+
+/* callback for battery check
+ * return : bool
+ * true - battery detected, false battery NOT detected
+ */
+static bool sec_bat_check_callback(void) { return true; }
+static bool sec_bat_check_result_callback(void) { return true; }
+
+#if defined(CONFIG_STBC_SAMSUNG)
+static struct battery_data_t stbcfg01_battery_data[] = {
+	{
+		.Alm_en = 1,	         /* SOC and VBAT alarms enable, 0=disabled, 1=enabled */
+		.Alm_SOC = 1,         /* SOC alarm level % */
+		.Alm_Vbat = 3350,      /* Vbat alarm level mV */
+		.VM_cnf = 191,         /* nominal VM_cnf for discharging, coming from battery characterisation */
+		.VM_cnf_chg = 585,     /* nominal VM_cnf for charging, coming from battery characterisation */
+		.Cnom = 1500,          /* nominal capacity in mAh, coming from battery characterisation */
+
+		.CapDerating[6] = 0,   /* capacity derating in 0.1%, for temp = -20deg */
+		.CapDerating[5] = 0,   /* capacity derating in 0.1%, for temp = -10deg */
+		.CapDerating[4] = 0,   /* capacity derating in 0.1%, for temp = 0deg */
+		.CapDerating[3] = 0,   /* capacity derating in 0.1%, for temp = 10deg */
+		.CapDerating[2] = 0,   /* capacity derating in 0.1%, for temp = 25deg */
+		.CapDerating[1] = 0,   /* capacity derating in 0.1%, for temp = 40deg */
+		.CapDerating[0] = 0,   /* capacity derating in 0.1%, for temp = 60deg */
+
+		.VM_cnf_comp[6] = 1400, /* VM_cnf temperature compensation multiplicator in %, for temp = -20deg */
+		.VM_cnf_comp[5] = 1100, /* VM_cnf temperature compensation multiplicator in %, for temp = -10deg */
+		.VM_cnf_comp[4] = 620, /* VM_cnf temperature compensation multiplicator in %, for temp = 0deg */
+		.VM_cnf_comp[3] = 420, /* VM_cnf temperature compensation multiplicator in %, for temp = 10deg */
+		.VM_cnf_comp[2] = 120, /* VM_cnf temperature compensation multiplicator in %, for temp = 25deg */
+		.VM_cnf_comp[1] = 95,  /* VM_cnf temperature compensation multiplicator in %, for temp = 40deg */
+		.VM_cnf_comp[0] = 88,  /* VM_cnf temperature compensation multiplicator in %, for temp = 60deg */
+
+		.OCVOffset[15] = 20,    /* OCV curve adjustment */
+		.OCVOffset[14] = -18,  /* OCV curve adjustment */
+		.OCVOffset[13] = -23,  /* OCV curve adjustment */
+		.OCVOffset[12] = -12,  /* OCV curve adjustment */
+		.OCVOffset[11] = -20,  /* OCV curve adjustment */
+		.OCVOffset[10] = -23,  /* OCV curve adjustment */
+		.OCVOffset[9] = -15,   /* OCV curve adjustment */
+		.OCVOffset[8] = -10,   /* OCV curve adjustment */
+		.OCVOffset[7] = -8,    /* OCV curve adjustment */
+		.OCVOffset[6] = -7,    /* OCV curve adjustment */
+		.OCVOffset[5] = -22,   /* OCV curve adjustment */
+		.OCVOffset[4] = -35,   /* OCV curve adjustment */
+		.OCVOffset[3] = -46,   /* OCV curve adjustment */
+		.OCVOffset[2] = -82,   /* OCV curve adjustment */
+		.OCVOffset[1] = -103,  /* OCV curve adjustment */
+		.OCVOffset[0] = 83,     /* OCV curve adjustment */
+
+		.SysCutoffVolt = 3000, /* system cut-off voltage, system does not work under this voltage (platform UVLO) in mV */
+		.EarlyEmptyCmp = 0,	   /* difference vs SysCutoffVolt to start early empty compensation in mV, typically 200, 0 for disable */
+
+		.IFast = 0,            /* fast charge current, range 550-1250mA, value = IFast*100+550 mA */
+		.IFast_usb = 0,        /* fast charge current (another conf. for USB), range 550-1250mA, value = IFast*100+550 mA */
+		.IPre = 0,             /* pre-charge current, 0=450 mA, 1=100 mA */
+		.ITerm = 4,            /* termination current, range 50-300 mA, value = ITerm*25+50 mA */
+		.VFloat = 41,          /* floating voltage, range 3.52-4.78 V, value = VFloat*0.02+3.52 V */
+		.ARChg = 0,            /* automatic recharge, 0=disabled, 1=enabled */
+		.Iin_lim = 1,          /* input current limit, 0=100mA 1=500mA 2=800mA 3=1.2A 4=no limit */
+		.DICL_en = 1,          /* dynamic input current limit, 0=disabled, 1=enabled */
+		.VDICL = 2,            /* dynamic input curr lim thres, range 4.00-4.75V, value = VDICL*0.25+4.00 V */
+		.DIChg_adj = 1,        /* dynamic charging current adjust enable, 0=disabled, 1=enabled */
+		.TPre = 0,             /* pre-charge timer, 0=disabled, 1=enabled */
+		.TFast = 0,            /* fast charge timer, 0=disabled, 1=enabled */
+		.PreB_en = 1,          /* pre-bias function, 0=disabled, 1=enabled */
+		.LDO_UVLO_th = 0,      /* LDO UVLO threshold, 0=3.5V 1=4.65V */
+		.LDO_en = 1,           /* LDO output, 0=disabled, 1=enabled */
+		.IBat_lim = 2,         /* OTG average battery current limit, 0=350mA 1=450mA 2=550mA 3=950mA */
+		.WD = 0,               /* watchdog timer function, 0=disabled, 1=enabled */
+		.FSW = 0,              /* switching frequency selection, 0=2MHz, 1=3MHz */
+
+		.GPIO_cd = SEC_STBC_CHG_EN, /* charger disable GPIO */
+		.GPIO_shdn = 0,                          /* all charger circuitry shutdown GPIO or 0=not used */
+
+		.ExternalTemperature = 250,   /* external temperature function, return in 0.1deg */
+		.power_supply_register = NULL,           /* custom power supply structure registration function */
+		.power_supply_unregister = NULL,         /* custom power supply structure unregistration function */
+	}
+};
+#endif
+
+/* callback for OVP/UVLO check
+ * return : int
+ * battery health
+ */
+static int sec_bat_ovp_uvlo_callback(void)
+{
+	int health;
+	health = POWER_SUPPLY_HEALTH_GOOD;
+
+	return health;
+}
+
+static bool sec_bat_ovp_uvlo_result_callback(int health) { return true; }
+
+/*
+ * val.intval : temperature
+ */
+static bool sec_bat_get_temperature_callback(
+		enum power_supply_property psp,
+		union power_supply_propval *val) { return true; }
+
+static bool sec_fg_fuelalert_process(bool is_fuel_alerted) { return true; }
+
+static bool sec_bat_adc_none_init(struct platform_device *pdev) { return true; }
+static bool sec_bat_adc_none_exit(void) { return true; }
+static int sec_bat_adc_none_read(unsigned int channel) { return 0; }
+
+static bool sec_bat_adc_ap_init(struct platform_device *pdev) { return true; }
+static bool sec_bat_adc_ap_exit(void) { return true; }
+static int sec_bat_adc_ap_read(unsigned int channel) { return 0; }
+
+static bool sec_bat_adc_ic_init(struct platform_device *pdev) { return true; }
+static bool sec_bat_adc_ic_exit(void) { return true; }
+static int sec_bat_adc_ic_read(unsigned int channel) { return 0; }
+
+sec_battery_platform_data_t sec_battery_pdata = {
+	/* NO NEED TO BE CHANGED */
+	.initial_check = sec_bat_initial_check,
+	.bat_gpio_init = sec_bat_gpio_init,
+	.fg_gpio_init = sec_fg_gpio_init,
+	.chg_gpio_init = sec_chg_gpio_init,
+
+	.is_lpm = sec_bat_is_lpm,
+	.check_jig_status = sec_bat_check_jig_status,
+	.check_cable_callback =
+		sec_bat_check_cable_callback,
+//	.get_cable_from_extended_cable_type =
+//	        sec_bat_get_cable_from_extended_cable_type,
+	.check_cable_result_callback =
+		sec_bat_check_cable_result_callback,
+	.check_battery_callback =
+		sec_bat_check_callback,
+	.check_battery_result_callback =
+		sec_bat_check_result_callback,
+	.ovp_uvlo_callback = sec_bat_ovp_uvlo_callback,
+	.ovp_uvlo_result_callback =
+		sec_bat_ovp_uvlo_result_callback,
+	.fuelalert_process = sec_fg_fuelalert_process,
+	.get_temperature_callback =
+		sec_bat_get_temperature_callback,
+
+	.adc_api[SEC_BATTERY_ADC_TYPE_NONE] = {
+		.init = sec_bat_adc_none_init,
+		.exit = sec_bat_adc_none_exit,
+		.read = sec_bat_adc_none_read
+	},
+	.adc_api[SEC_BATTERY_ADC_TYPE_AP] = {
+		.init = sec_bat_adc_ap_init,
+		.exit = sec_bat_adc_ap_exit,
+//		.read = sec_bat_adc_ap_read
+	},
+	.adc_api[SEC_BATTERY_ADC_TYPE_IC] = {
+		.init = sec_bat_adc_ic_init,
+		.exit = sec_bat_adc_ic_exit,
+		.read = sec_bat_adc_ic_read
+	},
+	.cable_adc_value = cable_adc_value_table,
+	.charging_current = charging_current_table,
+	.polling_time = polling_time_table,
+	/* NO NEED TO BE CHANGED */
+
+	.pmic_name = SEC_BATTERY_PMIC_NAME,
+
+	.adc_check_count = 5,
+
+	.adc_type = {
+		SEC_BATTERY_ADC_TYPE_NONE,	/* CABLE_CHECK */
+		SEC_BATTERY_ADC_TYPE_NONE,      /* BAT_CHECK */
+		SEC_BATTERY_ADC_TYPE_NONE,	/* TEMP */
+		SEC_BATTERY_ADC_TYPE_NONE,	/* TEMP_AMB */
+		SEC_BATTERY_ADC_TYPE_NONE,      /* FULL_CHECK */
+	},
+
+	/* Battery */
+	.vendor = "SDI SDI",
+#if defined(CONFIG_STBC_SAMSUNG)
+	.battery_data = (void *)stbcfg01_battery_data,
+#endif
+	.technology = POWER_SUPPLY_TECHNOLOGY_LION,
+	.bat_polarity_ta_nconnected = 1,        /* active HIGH */
+	.bat_irq_attr = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+	.cable_check_type = SEC_BATTERY_CABLE_CHECK_INT |
+			SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE,
+	.cable_source_type = //SEC_BATTERY_CABLE_SOURCE_CALLBACK,
+		SEC_BATTERY_CABLE_SOURCE_EXTERNAL,
+//	SEC_BATTERY_CABLE_SOURCE_EXTENDED,
+
+	/* Monitor setting */
+	.polling_type = SEC_BATTERY_MONITOR_ALARM,
+	.monitor_initial_count = 3,
+
+	/* Battery check */
+	.battery_check_type = SEC_BATTERY_CHECK_FUELGAUGE,
+	.check_count = 3,
+
+	/* Battery check by ADC */
+	.check_adc_max = 600,
+	.check_adc_min = 50,
+
+	/* OVP/UVLO check */
+	.ovp_uvlo_check_type = SEC_BATTERY_OVP_UVLO_CHGPOLLING,
+
+#if defined(CONFIG_FUELGAUGE_88PM822)
+#if defined(CONFIG_MACH_GOYA_USA)
+	.event_check = true,
+	.event_waiting_time = 60,
+	.thermal_source = SEC_BATTERY_THERMAL_SOURCE_FG,
+	.temp_check_type = SEC_BATTERY_TEMP_CHECK_TEMP,
+	.temp_check_count = 1,
+	.temp_high_threshold_event = 600,
+	.temp_high_recovery_event = 460,
+	.temp_low_threshold_event = -50,
+	.temp_low_recovery_event = 0,
+	.temp_high_threshold_normal = 560,
+	.temp_high_recovery_normal = 460,
+	.temp_low_threshold_normal = 10,
+	.temp_low_recovery_normal = 40,
+	.temp_high_threshold_lpm = 560,
+	.temp_high_recovery_lpm = 460,
+	.temp_low_threshold_lpm = 10,
+	.temp_low_recovery_lpm = 40,
+#else
+	.event_check = false,
+	.event_waiting_time = 60,
+	.thermal_source = SEC_BATTERY_THERMAL_SOURCE_FG,
+	.temp_check_type = SEC_BATTERY_TEMP_CHECK_TEMP,
+	.temp_check_count = 1,
+	.temp_high_threshold_event = 600,
+	.temp_high_recovery_event = 460,
+	.temp_low_threshold_event = -50,
+	.temp_low_recovery_event = 0,
+	.temp_high_threshold_normal = 600,
+	.temp_high_recovery_normal = 460,
+	.temp_low_threshold_normal = -50,
+	.temp_low_recovery_normal = 0,
+	.temp_high_threshold_lpm = 600,
+	.temp_high_recovery_lpm = 460,
+	.temp_low_threshold_lpm = -50,
+	.temp_low_recovery_lpm = 0,
+#endif
+#else
+	.thermal_source = SEC_BATTERY_THERMAL_SOURCE_ADC,
+	.temp_adc_table = golden_temp_table,
+	.temp_adc_table_size =
+		sizeof(golden_temp_table)/sizeof(sec_bat_adc_table_data_t),
+	.temp_amb_adc_table = golden_temp_table,
+	.temp_amb_adc_table_size =
+		sizeof(golden_temp_table)/sizeof(sec_bat_adc_table_data_t),
+	.temp_check_type = SEC_BATTERY_TEMP_CHECK_TEMP,
+	.temp_check_count = 1,
+	.temp_high_threshold_event = 600,
+	.temp_high_recovery_event = 460,
+	.temp_low_threshold_event = -50,
+	.temp_low_recovery_event = 0,
+	.temp_high_threshold_normal = 600,
+	.temp_high_recovery_normal = 460,
+	.temp_low_threshold_normal = -50,
+	.temp_low_recovery_normal = 0,
+	.temp_high_threshold_lpm = 600,
+	.temp_high_recovery_lpm = 460,
+	.temp_low_threshold_lpm = -50,
+	.temp_low_recovery_lpm = 0,
+#endif
+
+	.full_check_type = SEC_BATTERY_FULLCHARGED_CHGPSY,
+	.full_check_type_2nd = SEC_BATTERY_FULLCHARGED_TIME,
+	.full_check_count = 1,
+	/* .full_check_adc_1st = 26500, */
+	/*.full_check_adc_2nd = 25800, */
+	.chg_polarity_full_check = 1,
+	.full_condition_type = SEC_BATTERY_FULL_CONDITION_SOC |
+		SEC_BATTERY_FULL_CONDITION_NOTIMEFULL |
+		SEC_BATTERY_FULL_CONDITION_VCELL,
+	.full_condition_soc = 100,
+	.full_condition_ocv = 4300,
+	.full_condition_vcell = 4300,
+
+	.recharge_condition_type =
+                SEC_BATTERY_RECHARGE_CONDITION_VCELL,
+
+	.recharge_condition_soc = 98,
+	.recharge_condition_avgvcell = 4280,
+	.recharge_condition_vcell = 4300,
+	.recharge_check_count = 1,
+
+	.charging_total_time = 6 * 60 * 60,
+        .recharging_total_time = 90 * 60,
+        .charging_reset_time = 10 * 60,
+
+	/* Fuel Gauge */
+	.fg_irq_attr = IRQF_TRIGGER_FALLING,
+	.fuel_alert_soc = 1,
+	.repeated_fuelalert = false,
+	.capacity_calculation_type =
+		/* SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE, */
+		SEC_FUELGAUGE_CAPACITY_TYPE_RAW,
+	.capacity_max = 970,
+	.capacity_min = 0,
+	.capacity_max_margin = 30,
+
+	/* Charger */
+	.chg_polarity_en = 0,   /* active LOW charge enable */
+	.chg_polarity_status = 0,
+	.chg_irq_attr = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+
+	.chg_float_voltage = 4330,
+};
+
+#if defined(CONFIG_STBC_SAMSUNG)
+static struct stbcfg01_platform_data stbc_battery_pdata = {
+	.charger_data = &sec_battery_pdata,
+	.fuelgauge_data = &sec_battery_pdata,
+};
+#endif
+
+static struct platform_device sec_device_battery = {
+	.name = "sec-battery",
+	.id = -1,
+	.dev = {
+		.platform_data = &sec_battery_pdata,
+	},
+};
+
+#if defined(CONFIG_STBC_SAMSUNG)
+static struct i2c_gpio_platform_data fuelgauge_gpio_i2c_pdata = {
+	.sda_pin = mfp_to_gpio(GPIO012_GPIO_12),
+	.scl_pin = mfp_to_gpio(GPIO011_GPIO_11),
+	.udelay = 10,
+	.timeout = 0,
+};
+
+static struct platform_device fuelgauge_gpio_i2c_device = {
+	.name = "i2c-gpio",
+	.id = SEC_FUELGAUGE_I2C_ID,
+	.dev = {
+		.platform_data = &fuelgauge_gpio_i2c_pdata,
+	},
+};
+
+static struct i2c_board_info sec_brdinfo_stbc[] __initdata = {
+	{
+		I2C_BOARD_INFO("sec-stbc",
+				SEC_STBC_I2C_SLAVEADDR),
+		.platform_data = &stbc_battery_pdata,
+	},
+};
+#endif
+
+#if defined(CONFIG_CHARGER_RT9455) || defined(CONFIG_CHARGER_SMB328)
+static struct i2c_gpio_platform_data charger_gpio_i2c_pdata = {
+        .sda_pin = mfp_to_gpio(GPIO017_GPIO_17),
+        .scl_pin = mfp_to_gpio(GPIO016_GPIO_16),
+        .udelay = 10,
+        .timeout = 0,
+};
+
+static struct platform_device charger_gpio_i2c_device = {
+        .name = "i2c-gpio",
+        .id = SEC_CHARGER_I2C_ID,
+        .dev = {
+                .platform_data = &charger_gpio_i2c_pdata,
+        },
+};
+
+static struct i2c_board_info sec_brdinfo_charger[] __initdata = {
+        {
+                I2C_BOARD_INFO("sec-charger",
+                                SEC_CHARGER_I2C_SLAVEADDR),
+                .platform_data = &sec_battery_pdata,
+        }
+};
+#endif
+
+static struct platform_device *sec_battery_devices[] __initdata = {
+	&sec_device_battery,
+#if defined(CONFIG_STBC_SAMSUNG)
+	&fuelgauge_gpio_i2c_device,
+#endif
+#if defined(CONFIG_CHARGER_RT9455) || defined(CONFIG_CHARGER_SMB328)
+	&charger_gpio_i2c_device,
+#endif
+};
+
+
+
+void __init pxa986_goya_battery_init(void)
+{
+	pr_info("%s: goya charger init\n", __func__);
+
+#if defined(CONFIG_STBC_SAMSUNG)
+	i2c_register_board_info(SEC_STBC_I2C_ID, sec_brdinfo_stbc,
+		ARRAY_SIZE(sec_brdinfo_stbc));
+#endif
+
+#if defined(CONFIG_CHARGER_RT9455) || defined(CONFIG_CHARGER_SMB328)
+	i2c_register_board_info(SEC_CHARGER_I2C_ID,
+		ARRAY_AND_SIZE(sec_brdinfo_charger));
+#endif
+	platform_add_devices(sec_battery_devices,
+		ARRAY_SIZE(sec_battery_devices));
+}
+#endif
diff --git a/arch/arm/mach-mmp/board-goya-input.c b/arch/arm/mach-mmp/board-goya-input.c
new file mode 100755
index 00000000..a2064934
--- /dev/null
+++ b/arch/arm/mach-mmp/board-goya-input.c
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2013 Samsung Electronics Co, Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/i2c-gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/input.h>
+#include <linux/input/bt532_ts.h>
+#include <linux/vibrator.h>
+#include <plat/mfp.h>
+#include <plat/pxa27x_keypad.h>
+#include <mach/pxa988.h>
+#include "common.h"
+
+
+#define KP_MKIN0_VOL_DOWN		MFP_CFG(GPIO0, AF1)
+#define KP_MKIN1_VOL_UP			MFP_CFG(GPIO2, AF1)
+#define KP_NKIN5_HOME_KEY		MFP_CFG(GPIO13, AF4)
+#define GPIO001_VOL_UP			MFP_CFG(GPIO1, AF0) | MFP_LPM_INPUT | MFP_PULL_HIGH
+#define GPIO002_VOL_DOWN		MFP_CFG(GPIO2, AF0) | MFP_LPM_INPUT | MFP_PULL_HIGH
+#define GPIO013_HOME_KEY			MFP_CFG(GPIO13, AF0) | MFP_PULL_NONE
+#define CI2C2_TSP_SCL			MFP_CFG(GPIO87, AF5) | MFP_LPM_FLOAT | MFP_PULL_NONE
+#define CI2C2_TSP_SDA			MFP_CFG(GPIO88, AF5) | MFP_LPM_FLOAT | MFP_PULL_NONE
+#define GPIO087_GPIO_87			MFP_CFG(GPIO87, AF0) | MFP_LPM_INPUT | MFP_LPM_FLOAT
+#define GPIO088_GPIO_88			MFP_CFG(GPIO88, AF0) | MFP_LPM_INPUT | MFP_LPM_FLOAT
+#define GPIO094_TOUCH_IRQ		MFP_CFG(GPIO94, AF0)
+#define GPIO096_MOTOR_EN		MFP_CFG(GPIO96, AF0) | MFP_LPM_PULL_LOW | MFP_PULL_LOW
+
+static unsigned long __initdata goya_input_pin_config_bring[] = {
+#ifdef CONFIG_KEYBOARD_PXA27x
+	KP_MKIN0_VOL_DOWN,
+	KP_MKIN1_VOL_UP,
+	KP_NKIN5_HOME_KEY,
+#else
+	GPIO001_VOL_UP,
+	GPIO002_VOL_DOWN,
+	GPIO013_HOME_KEY,
+#endif
+
+	CI2C2_TSP_SCL,
+	CI2C2_TSP_SDA,
+	GPIO094_TOUCH_IRQ,
+	GPIO096_MOTOR_EN,
+};
+
+
+#ifdef CONFIG_KEYBOARD_PXA27x
+/* Matrix keys */
+static unsigned int __initdata goya_matrix_key_map[] = {
+	KEY(0, 0, KEY_VOLUMEDOWN),
+	KEY(1, 0, KEY_VOLUMEUP),
+};
+
+static struct pxa27x_keypad_platform_data __initdata pxa27x_keypad_pdata = {
+	.matrix_key_rows		= 2,
+	.matrix_key_cols		= 1,
+	.matrix_key_map			= goya_matrix_key_map,
+	.matrix_key_map_size	= ARRAY_SIZE(goya_matrix_key_map),
+	.debounce_interval		= 30,
+
+	.direct_key_num			= 6,
+	.direct_key_map			= {
+			KEY_RESERVED,
+			KEY_RESERVED,
+			KEY_RESERVED,
+			KEY_RESERVED,
+			KEY_RESERVED,
+			KEY_HOME},
+	.direct_wakeup_pad		= {
+			0,0,0,0,0,
+			mfp_to_gpio(KP_NKIN5_HOME_KEY)},
+	.direct_key_low_active	= 1,
+};
+
+static void __init goya_input_keyboard_init(void)
+{
+	pxa988_add_keypad(&pxa27x_keypad_pdata);
+}
+#else
+struct gpio_keys_button gpio_keys[] =
+{
+	{
+		.code = KEY_VOLUMEUP,       /* input event code (KEY_*, SW_*) */
+		.gpio = mfp_to_gpio(GPIO001_VOL_UP),
+		.active_low = 1,
+		.desc = "key_volumeup",
+		.type = EV_KEY,     /* input event type (EV_KEY, EV_SW) */
+		.wakeup = 0,
+		.debounce_interval = 30,    /* debounce ticks interval in msecs */
+		.can_disable = false,
+	},
+	{
+		.code = KEY_VOLUMEDOWN,     /* input event code (KEY_*, SW_*) */
+		.gpio = mfp_to_gpio(GPIO002_VOL_DOWN),
+		.active_low = 1,
+		.desc = "key_volumedown",
+		.type = EV_KEY,     /* input event type (EV_KEY, EV_SW) */
+		.wakeup = 0,        /* configure the button as a wake-up source */
+		.debounce_interval = 30,    /* debounce ticks interval in msecs */
+		.can_disable = false,
+	},
+	{
+		.code = KEY_HOME,     /* input event code (KEY_*, SW_*) */
+		.gpio = mfp_to_gpio(GPIO013_HOME_KEY),
+		.active_low = 1,
+		.desc = "key_home",
+		.type = EV_KEY,     /* input event type (EV_KEY, EV_SW) */
+		.wakeup = 1,        /* configure the button as a wake-up source */
+		.debounce_interval = 30,    /* debounce ticks interval in msecs */
+		.can_disable = false,
+	},
+
+};
+
+struct gpio_keys_platform_data gpio_keys_data =
+{
+	.buttons = gpio_keys,
+	.nbuttons = ARRAY_SIZE(gpio_keys),
+};
+
+struct platform_device gpio_keys_device =
+{
+	.name = "gpio-keys",
+	.dev =
+	{
+		.platform_data = &gpio_keys_data,
+	},
+};
+#include <mach/addr-map.h>
+#include <mach/regs-apmu.h>
+static void __init goya_input_keyboard_init(void)
+{
+	u32 kpc;
+
+	/*disable keypad function*/
+	kpc = __raw_readl(APB_PHYS_BASE+0x12000);
+
+	__raw_writel(0, APB_PHYS_BASE+0x12000);
+	kpc = __raw_readl(APB_PHYS_BASE+0x12000);
+
+	/*close keypad clock*/
+	__raw_writel(0, APBC_PXA988_KPC);
+
+	kpc = __raw_readl(APBC_PXA988_KPC);
+
+	/*clear keypad wakeup source*/
+	kpc = __raw_readl(APMU_WAKE_CLR);
+	__raw_writel(kpc | (1<<3), APMU_WAKE_CLR);
+
+	platform_device_register(&gpio_keys_device);
+}
+#endif
+
+/* touch screen */
+#define TOUCH_IRQ		mfp_to_gpio(GPIO094_TOUCH_IRQ)
+
+static struct regulator *touch_regulator;
+extern void i2c1_pin_changed(int gpio);
+
+#define POWER_OFF 0
+#define POWER_ON 1
+#define POWER_ON_SEQUENCE 2
+#define PM_POWER_OFF 3
+
+static int bt532_power(int on)
+{
+	int ret = 0;
+	static u8 is_power_on;
+	if (touch_regulator == NULL) {
+		touch_regulator = regulator_get(NULL, "v_tsp_3v3");
+		if (IS_ERR(touch_regulator)) {
+			touch_regulator = NULL;
+			pr_info("[TSP]: %s: get touch_regulator error\n",
+				__func__);
+			return -EIO;
+		}
+	}
+	if ((on == POWER_OFF) || (on == PM_POWER_OFF)) {
+		if (is_power_on) {
+			is_power_on = 0;
+			if(on == POWER_OFF)
+				i2c1_pin_changed(1);
+			ret = regulator_disable(touch_regulator);
+			if (ret) {
+				is_power_on = 1;
+				pr_err("[TSP]: %s: touch_regulator disable " \
+					"failed  (%d)\n", __func__, ret);
+				return -EIO;
+			}
+			msleep(50);
+		}
+	} else {
+		if (!is_power_on) {
+			is_power_on = 1;
+			regulator_set_voltage(touch_regulator, 2800000,
+								2800000);
+			ret = regulator_enable(touch_regulator);
+			if (ret) {
+				is_power_on = 0;
+				pr_err("[TSP]: %s: touch_regulator enable "\
+					"failed (%d)\n", __func__, ret);
+				return -EIO;
+			}
+			i2c1_pin_changed(0);
+		}
+	}
+	pr_info("[TSP]: %s, expected power[%d], actural power[%d]\n",
+		__func__, on, is_power_on);
+	return 0;
+}
+
+static struct bt532_ts_platform_data bt532_ts_pdata = {
+	.tsp_power	= bt532_power,
+	.x_resolution	= 599,
+	.y_resolution	= 1023,
+	.page_size	= 128,
+	.orientation	= CONFIG_TOUCHSCREEN_BT532_TS_ORIENTATION,
+};
+
+static struct i2c_board_info __initdata bt532_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO(BT532_TS_DEVICE, 0x20),
+		.platform_data = &bt532_ts_pdata,
+	},
+};
+
+static void __init goya_input_tsp_init(void)
+{
+	int ret = 0;
+
+	ret = gpio_request(TOUCH_IRQ, "bt532_int");
+	if (ret < 0) {
+		pr_err("%s: Request GPIO failed, gpio %d (%d)\n", BT532_TS_DEVICE,
+			TOUCH_IRQ, ret);
+		return;
+	}
+
+	gpio_direction_input(TOUCH_IRQ);
+	bt532_ts_pdata.gpio_int = TOUCH_IRQ;
+	bt532_i2c_devices[0].irq  = gpio_to_irq(TOUCH_IRQ);
+
+	i2c_register_board_info(1, ARRAY_AND_SIZE(bt532_i2c_devices));
+}
+
+/* Vibrator */
+#define VIB_EN		mfp_to_gpio(GPIO096_MOTOR_EN)
+
+static struct vib_info vib_info = {
+	.gpio		= VIB_EN,
+};
+
+static struct platform_device android_vibrator_device = {
+	.name	= "android-vibrator",
+	.dev	= {
+		.platform_data = &vib_info,
+	},
+};
+
+static void __init goya_input_vibrator_init(void)
+{
+	int ret;
+
+	ret = gpio_request(VIB_EN, "vibrator_en");
+	if (ret < 0) {
+		pr_err("Vibrator: Request GPIO failed, gpio %d (%d)\n", VIB_EN, ret);
+		return;
+	}
+
+	platform_device_register(&android_vibrator_device);
+}
+
+void __init goya_input_init(void)
+{
+	mfp_config(ARRAY_AND_SIZE(goya_input_pin_config_bring));
+
+	goya_input_keyboard_init();
+	goya_input_tsp_init();
+	goya_input_vibrator_init();
+}
diff --git a/arch/arm/mach-mmp/board-goya.c b/arch/arm/mach-mmp/board-goya.c
new file mode 100755
index 00000000..6821d1e7
--- /dev/null
+++ b/arch/arm/mach-mmp/board-goya.c
@@ -0,0 +1,4880 @@
+/*
+ *  linux/arch/arm/mach-mmp/board-emeidkb.c
+ *
+ *  Support for the Marvell PXA988 Emei DKB Development Platform.
+ *
+ *  Copyright (C) 2012 Marvell International Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  publishhed by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/i2c.h>
+#include <linux/i2c/ft5306_touch.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/backlight.h>
+#include <linux/regulator/machine.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdhci.h>
+#include <linux/mmc/card.h>
+#include <linux/platform_data/pxa_sdhci.h>
+#include <linux/sd8x_rfkill.h>
+#include <linux/regmap.h>
+#include <linux/mfd/88pm822.h>
+#include <linux/platform_data/mv_usb.h>
+#include <linux/pm_qos.h>
+#include <linux/clk.h>
+#include <linux/lps331ap.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/i2c-gpio.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/uio_coda7542.h>
+#ifdef CONFIG_SEC_DEBUG
+#include "mach/sec_debug.h"
+#endif
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#endif
+
+#ifdef CONFIG_SENSORS_GP2A002S
+#include <linux/gp2a.h>
+#endif
+
+#ifdef CONFIG_SENSORS_GP2A_PROXIMITY
+#include <linux/sensor/gp2a.h>
+#endif
+
+#ifdef CONFIG_INPUT_MPU6500
+#include <linux/sensor/mpu6k_input.h>
+#endif
+
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/setup.h>
+#include <asm/system_info.h>
+#include <mach/addr-map.h>
+#include <mach/clock-pxa988.h>
+#include <mach/mmp_device.h>
+#include <mach/mfp-pxa986-goya.h>
+#include <mach/irqs.h>
+#include <mach/isl29043.h>
+#include <mach/pxa988.h>
+#include <mach/soc_coda7542.h>
+#include <mach/regs-rtc.h>
+#include <mach/regs-ciu.h>
+#include <plat/pm.h>
+#include <media/soc_camera.h>
+#include <mach/isp_dev.h>
+#include <mach/gpio-edge.h>
+#include <mach/dvfs.h>
+#include <mach/features.h>
+#include <mach/regs-mpmu.h>
+#if defined(CONFIG_SOC_CAMERA_SR352)
+#include <mach/samsung_camera_golden.h>
+#else
+#include <mach/samsung_camera.h>
+#endif
+
+#include "board-goya.h"
+
+#ifdef CONFIG_PM_DEVFREQ
+#include <plat/devfreq.h>
+#endif
+#include "common.h"
+#include "onboard.h"
+#if defined(CONFIG_SPA)
+#include <mach/spa.h>
+#endif
+#if defined(CONFIG_BQ24157_CHARGER)
+#include <mach/bq24157_charger.h>
+#endif
+#if defined(CONFIG_I2C_RT9455)
+#include <linux/power/rt9455.h>
+#endif
+#if defined(CONFIG_STC3115_FUELGAUGE)
+#include <mach/stc3115_fuelgauge.h>
+#endif
+#if defined(CONFIG_SM5502_MUIC)
+#include <mach/sm5502-muic.h>
+#endif
+#if defined(CONFIG_NFC_PN547)
+#include <linux/nfc/pn547.h>
+#endif
+
+#if defined(CONFIG_MFD_RT8973)
+#include <linux/mfd/rt8973.h>
+#endif
+#if defined(CONFIG_RT9450AC) || defined(CONFIG_RT9450B)
+#include <linux/platform_data/rtsmc.h>
+#endif
+#if defined(CONFIG_SENSORS_ACCELOMETER_BMA25X)
+#include <linux/sensor/bma255_platformdata.h>
+#endif
+#if defined(CONFIG_SENSORS_GRIP_SX9500)
+#include <linux/sensor/sx9500_platform_data.h>
+#endif
+
+#ifdef CONFIG_MFD_D2199
+#include <linux/d2199/core.h>
+#include <linux/d2199/pmic.h>
+#include <linux/d2199/d2199_reg.h>
+#include <linux/d2199/d2199_battery.h>
+#endif
+
+#ifdef CONFIG_LEDS_RT8547
+#include <linux/leds-rt8547.h>
+#endif /* #ifdef CONFIG_LEDS_RT8547 */
+
+#ifdef CONFIG_SEC_THERMISTOR
+#include <mach/sec_thermistor.h>
+#endif
+
+#ifdef CONFIG_SEC_GPIO_DVS
+#include <linux/secgpio_dvs.h>
+#endif
+
+#ifdef CONFIG_SAMSUNG_JACK
+#include <linux/mfd/sec_jack.h>
+#endif
+
+#define VER_1V0 0x10
+#define VER_1V1 0x11
+#define GPS_LDO_POWER
+static int board_id;
+static int recovery_mode;
+extern u32 panel_id;
+
+static int __init board_id_setup(char *str)
+{
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	system_rev = board_id = n;
+	return 1;
+}
+__setup("board_id=", board_id_setup);
+
+int get_board_id()
+{
+	return board_id;
+}
+
+static int __init recovery_mode_setup(char *str)
+{
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	recovery_mode = n;
+	return 1;
+}
+__setup("recovery_mode=", recovery_mode_setup);
+
+int get_recoverymode()
+{
+	return recovery_mode;
+}
+
+static unsigned long emeidkb_pin_config[] __initdata = {
+	MFP_VCXO_OUT | MFP_PULL_LOW,
+	GPIO000_GPIO_0 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO001_GPIO_1 | MFP_LPM_DRIVE_HIGH | MFP_LPM_PULL_HIGH
+			  | MFP_PULL_HIGH,	/* KP_MKOUT[0] */
+	GPIO002_GPIO_2 | MFP_LPM_PULL_HIGH | MFP_PULL_HIGH,/* KP_MKIN[1] */
+	GPIO003_GPIO_3 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO004_GPIO_4 | MFP_PULL_HIGH,
+
+#define GPIO005_AP_AGPS_RESET	(GPIO005_GPIO_5 | MFP_PULL_HIGH)
+	GPIO005_AP_AGPS_RESET,
+
+	GPIO006_GPIO_6 | MFP_LPM_INPUT | MFP_PULL_HIGH | MFP_LPM_DRIVE_HIGH,
+	GPIO007_GPIO_7 | MFP_LPM_INPUT | MFP_PULL_HIGH | MFP_LPM_DRIVE_HIGH,
+	GPIO008_GPIO_8 | MFP_LPM_INPUT | MFP_PULL_NONE,
+#define GPIO_LCD_3P3 (GPIO009_GPIO_9)
+	GPIO_LCD_3P3,
+
+#define GPIO010_ACC_INT	(GPIO010_GPIO_10 | MFP_LPM_INPUT | MFP_PULL_LOW)
+	GPIO010_ACC_INT,
+
+#define GPIO011_GPI0_SD_DETECT	(GPIO011_GPIO_11 | MFP_LPM_INPUT | MFP_PULL_NONE)
+		GPIO011_GPI0_SD_DETECT,
+
+	GPIO012_GPIO_12 | MFP_PULL_LOW | MFP_LPM_DRIVE_LOW,
+	GPIO013_GPIO_13,
+
+#define GPIO014_5M_CAM_STBY	(GPIO014_GPIO_14 | MFP_PULL_LOW | MFP_LPM_DRIVE_LOW)
+#define GPIO015_5M_CAM_RESET	(GPIO015_GPIO_15 | MFP_PULL_NONE)
+	GPIO014_5M_CAM_STBY,
+	GPIO015_5M_CAM_RESET,
+
+#define GPIO016_CHG_SCL	(GPIO016_GPIO_16 | MFP_PULL_HIGH )
+#define GPIO017_CHG_SDA	(GPIO017_GPIO_17 | MFP_PULL_HIGH )
+	GPIO016_CHG_SCL,
+	GPIO017_CHG_SDA,
+	GPIO018_GPIO_18,
+#define GPIO019_LVDS3P3	(GPIO019_GPIO_19)
+#define GPIO020_LVDS_RST (GPIO020_GPIO_20)
+	GPIO019_LVDS3P3,
+	GPIO020_LVDS_RST,
+
+	/*
+	 * configure to be GPIO input to avoid leakage in production
+	 * mode. would configure it to I2S MFP in sound start up
+	 * function.
+	 */
+	GPIO021_GPIO_21 | MFP_LPM_INPUT,
+	GPIO022_GPIO_22 | MFP_LPM_INPUT,
+	GPIO023_GPIO_23  | MFP_LPM_INPUT,
+	GPIO024_GPIO_24  | MFP_LPM_INPUT,
+
+	GPIO025_GSSP_SCLK,	/* PCM_CLK */
+	GPIO026_GSSP_SFRM,	/* PCM_SYNC */
+	GPIO027_GSSP_TXD,	/* PCM_TXD */
+	GPIO028_GSSP_RXD,	/* PCM_RXD */
+
+	GPIO029_GPIO_29 | MFP_LPM_INPUT | MFP_PULL_LOW, /* NC? */
+	GPIO030_GPIO_30 | MFP_LPM_INPUT | MFP_PULL_LOW, /* NC? */
+
+#define GPIO032_HW_REV_MOD_2	(GPIO032_GPIO_32 | MFP_PULL_FLOAT | MFP_LPM_INPUT)
+	GPIO031_GPIO_31 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO032_HW_REV_MOD_2,
+
+#if defined(CONFIG_GOYA_WIFI)
+	GPIO033_GPIO_33 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO034_GPIO_34 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+#else
+#define GPIO033_EN_RF_TOUCH	(GPIO033_GPIO_33 | MFP_PULL_LOW)
+	GPIO033_EN_RF_TOUCH,
+
+#define GPIO034_GRIP_INT	(GPIO034_GPIO_34 | MFP_PULL_HIGH)
+	GPIO034_GRIP_INT,
+#endif
+
+#define GPIO035_GPIO_SENSOR_I2C_SCL	(GPIO035_GPIO_35 | MFP_LPM_DRIVE_HIGH | MFP_LPM_INPUT)
+#define GPIO036_GPIO_SENSOR_I2C_SDA	(GPIO036_GPIO_36 | MFP_LPM_DRIVE_HIGH | MFP_LPM_INPUT)
+	GPIO035_GPIO_SENSOR_I2C_SCL,
+	GPIO036_GPIO_SENSOR_I2C_SDA,
+
+	/* MMC2 WIB */
+	GPIO037_MMC2_DATA3 | MFP_LPM_FLOAT,	/* WLAN_DAT3 */
+	GPIO038_MMC2_DATA2 | MFP_LPM_FLOAT,	/* WLAN_DAT2 */
+	GPIO039_MMC2_DATA1 | MFP_LPM_FLOAT,	/* WLAN_DAT1 */
+	GPIO040_MMC2_DATA0 | MFP_LPM_FLOAT,	/* WLAN_DAT0 */
+	GPIO041_MMC2_CMD,	/* WLAN_CMD */
+	GPIO042_MMC2_CLK | MFP_LPM_DRIVE_HIGH,	/* WLAN_CLK */
+
+#define GPIO043_GPIO_DVC1	(GPIO043_GPIO_43 | MFP_PULL_FLOAT)
+#define GPIO044_GPIO_DVC2	(GPIO044_GPIO_44 | MFP_PULL_FLOAT)
+	GPIO043_GPIO_DVC1,
+	GPIO044_GPIO_DVC2,
+
+	GPIO045_UART2_RXD,	/* GPS_UART_RXD */
+	GPIO046_UART2_TXD,	/* GPS_UART_TXD */
+
+	GPIO047_UART1_RXD,	/* AP_RXD */
+	GPIO048_UART1_TXD,	/* AP_TXD */
+
+#define GPIO049_GPIO_MUS_SCL	GPIO049_GPIO_49 | MFP_LPM_FLOAT
+#define GPIO050_GPIO_MUS_SDA	GPIO050_GPIO_50 | MFP_LPM_FLOAT
+#define GPIO051_WLAN_PD		GPIO051_GPIO_51
+#define GPIO052_AP_AGPS_ONOFF	(GPIO052_GPIO_52 | MFP_PULL_LOW)
+
+	GPIO049_GPIO_MUS_SCL,
+	GPIO050_GPIO_MUS_SDA,
+	GPIO051_WLAN_PD,
+	GPIO052_AP_AGPS_ONOFF,
+
+	GPIO053_CAM_SCL | MFP_LPM_FLOAT,
+	GPIO054_CAM_SDA | MFP_LPM_FLOAT,
+
+//	GPIO054_GPIO_54 | MFP_LPM_INPUT | MFP_PULL_HIGH,
+
+	GPIO067_GPIO_67 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO068_GPIO_68 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO069_GPIO_69 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO070_GPIO_70 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO071_GPIO_71 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO072_GPIO_72 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO073_GPIO_73 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO074_GPIO_74 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO075_GPIO_75 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO076_GPIO_76 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+
+	GPIO077_CAM_MCLK  | MFP_LPM_DRIVE_LOW | MFP_PULL_LOW, /* CAM_MCLK */
+	GPIO078_GPIO_78 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO079_GPIO_79 | MFP_PULL_NONE,
+	GPIO080_GPIO_80 | MFP_PULL_NONE,
+
+#define GPIO083_GPIO_HOST_WU_WLAN	(GPIO083_GPIO_83 | MFP_LPM_DRIVE_LOW)
+#define GPIO084_GPIO_WLAN_WU_HOST	(GPIO084_GPIO_84 | MFP_LPM_INPUT | MFP_PULL_LOW)
+#define GPIO085_GPIO_WL_REG_ON	GPIO085_GPIO_85
+#define GPIO086_GPIO_BT_REG_ON	GPIO086_GPIO_86
+#define GPIO085_HW_REV_MOD_1	(GPIO085_GPIO_85 | MFP_LPM_INPUT)
+#define GPIO086_HW_REV_MOD_0	(GPIO086_GPIO_86 | MFP_LPM_INPUT)
+
+	GPIO081_GPIO_81 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO082_GPIO_82 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO083_GPIO_HOST_WU_WLAN,
+	GPIO084_GPIO_WLAN_WU_HOST,
+	GPIO085_HW_REV_MOD_1,
+	GPIO086_HW_REV_MOD_0,
+
+#define GPIO087_TSP_SCL		(GPIO087_GPIO_87 | MFP_LPM_FLOAT | MFP_PULL_NONE )
+#define GPIO088_TSP_SDA		(GPIO088_GPIO_88 | MFP_LPM_FLOAT | MFP_PULL_NONE )
+	GPIO087_TSP_SCL,
+	GPIO088_TSP_SDA,
+
+#define GPIO089_AP_AGPS_CLK_DIS	(GPIO089_GPIO_89 | MFP_PULL_LOW)
+	GPIO089_AP_AGPS_CLK_DIS,
+	GPIO090_GPIO_90,
+
+#if defined(CONFIG_NFC_PN547)
+#define GPIO091_GPIO_NFC_IRQ		(GPIO091_GPIO_91 | MFP_LPM_INPUT | MFP_PULL_LOW)
+	GPIO091_GPIO_NFC_IRQ,
+#else
+	GPIO091_GPIO_91 | MFP_PULL_HIGH,
+#endif
+
+#define GPIO091_GPIO_NFC_IRQ	(GPIO091_GPIO_91 | MFP_LPM_INPUT | MFP_PULL_LOW)
+#define GPIO093_GPIO_MUIC_INT	GPIO093_GPIO_93
+#define GPIO094_GPIO_TSP_INT	(GPIO094_GPIO_94 | MFP_LPM_INPUT)
+	GPIO091_GPIO_91 | MFP_LPM_INPUT | MFP_LPM_DRIVE_HIGH,
+	GPIO092_GPIO_92 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO093_GPIO_MUIC_INT,
+	GPIO094_GPIO_TSP_INT,
+
+#if defined(CONFIG_GOYA_WIFI)
+	GPIO095_GPIO_95 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+#else
+#define GPIO095_COND_N	(GPIO095_GPIO_95 | MFP_LPM_INPUT | MFP_PULL_NONE)
+	GPIO095_COND_N,
+#endif
+
+#define GPIO096_GPIO_MOTOR_EN	GPIO096_GPIO_96 | MFP_LPM_PULL_LOW | MFP_PULL_LOW | MFP_LPM_INPUT
+	GPIO096_GPIO_MOTOR_EN,
+
+#define GPIO097_GPIO_HSGDET_INT	( GPIO097_GPIO_97 | MFP_LPM_INPUT | MFP_LPM_PULL_HIGH | MFP_PULL_HIGH)
+	GPIO097_GPIO_HSGDET_INT,
+	GPIO098_GPIO_98 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	CLK_REQ_GPIO_123 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+
+#define GPIO124_GPIO_CODEC_INT  (GPIO124_GPIO_124 | MFP_LPM_INPUT | MFP_PULL_HIGH)
+	GPIO124_GPIO_CODEC_INT,
+	GPIO126_GPIO_126 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO127_GPIO_127 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	/* MMC1 Micro SD */
+	MMC1_DAT7_MMC1_DAT7 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	MMC1_DAT6_MMC1_DAT6 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	MMC1_DAT5_MMC1_DAT5 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	MMC1_DAT4_MMC1_DAT4 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	MMC1_DAT3_MMC1_DAT3,
+	MMC1_DAT2_MMC1_DAT2,
+	MMC1_DAT1_MMC1_DAT1,
+	MMC1_DAT0_MMC1_DAT0,
+	MMC1_CMD_MMC1_CMD | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	MMC1_CLK_MMC1_CLK | MFP_LPM_PULL_HIGH,
+	MMC1_CD_MMC1_CD | MFP_PULL_LOW | MFP_LPM_FLOAT,
+	MMC1_WP_MMC1_WP | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+
+	/* MMC3 16GB EMMC */
+	ND_IO7_MMC3_DAT7 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO6_MMC3_DAT6 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO5_MMC3_DAT5 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO4_MMC3_DAT4 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO3_MMC3_DAT3 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO2_MMC3_DAT2 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO1_MMC3_DAT1 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO0_MMC3_DAT0 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_CLE_SM_OEN_MMC3_CMD | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	SM_SCLK_MMC3_CLK | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+
+#define GPIO_GPS_TIMER_SYNC	ANT_SW4_GPIO_28
+#define GPIO_RF_PDET_EN		SM_ADV_GPIO_0 | MFP_LPM_FLOAT
+#define GPIO_LED_B_CTRL		SM_ADVMUX_GPIO_2
+#define GPIO_LED_R_CTRL		SM_BEN1_GPIO_127
+#define GPIO_LED_G_CTRL		SM_CSN0_GPIO_103
+	GPIO_GPS_TIMER_SYNC,
+	SM_ADV_GPIO_0 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_CS1N3_GPIO_102 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	SM_CSN0_GPIO_103 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	SM_CSN1_GPIO_104 | MFP_PULL_HIGH |MFP_LPM_FLOAT,
+#if defined(CONFIG_GOYA_WIFI)
+	ND_CS0N2_GPIO_101 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+#else
+	ND_CS0N2_GPIO_101 | MFP_LPM_INPUT,				/* USIM1_DET */
+#endif
+	/* SM_RDY pin Low for download mode, High for normal boot */
+	SM_RDY_GPIO_3 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+
+	ND_IO15_ND_DAT15 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO14_ND_DAT14 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO13_ND_DAT13 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO12_ND_DAT12 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO11_ND_DAT11 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO10_ND_DAT10 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO9_ND_DAT9 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	ND_IO8_ND_DAT8 | MFP_PULL_HIGH |  MFP_LPM_FLOAT,
+	DF_ALE_SM_WEn_ND_ALE | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	DF_WEn_DF_WEn | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	DF_REn_DF_REn | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	DF_RDY0_DF_RDY0 | MFP_PULL_HIGH | MFP_LPM_FLOAT,
+	VCXO_REQ,/*vcxo en clock for lvds*/
+#if defined(CONFIG_GOYA_WIFI)
+	GPIO_SLAVE_RESET_OUT | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+#endif
+};
+
+static unsigned long dvc_pin_config[] __initdata = {
+
+#define GPIO043_GPIO_DVC1_Ax	(GPIO043_GPIO_43_Ax | MFP_PULL_FLOAT)
+#define GPIO044_GPIO_DVC2_Ax	(GPIO044_GPIO_44_Ax | MFP_PULL_FLOAT)
+
+	GPIO043_GPIO_DVC1_Ax,
+	GPIO044_GPIO_DVC2_Ax,
+};
+
+static unsigned long rev05_pin_config[] __initdata = {
+
+	GPIO018_GPIO_18 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO029_GPIO_29 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO030_GPIO_30 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+	GPIO031_GPIO_31 | MFP_LPM_INPUT | MFP_PULL_HIGH, /* NC */
+};
+
+static struct sram_platdata pxa988_asram_info = {
+	.pool_name = "asram",
+	.granularity = SRAM_GRANULARITY,
+};
+
+static struct platform_device pxa988_device_asoc_ssp1 = {
+	.name		= "pxa-ssp-dai",
+	.id		= 1,
+};
+
+static struct platform_device pxa988_device_asoc_gssp = {
+	.name		= "pxa-ssp-dai",
+	.id		= 4,
+};
+
+static struct platform_device pxa988_device_asoc_pcm = {
+	.name		= "pxa-pcm-audio",
+	.id		= -1,
+};
+
+static struct platform_device emei_dkb_audio_device = {
+	.name	= "emei-dkb-hifi",
+	.id	= -1,
+};
+
+#if defined(CONFIG_MFD_88PM822)
+static struct regulator_consumer_supply regulator_supplies[] = {
+	[PM822_ID_BUCK1] = REGULATOR_SUPPLY("vcc_main", NULL),
+	[PM822_ID_BUCK2] = REGULATOR_SUPPLY("v_buck2", NULL),
+	[PM822_ID_BUCK3] = REGULATOR_SUPPLY("v_buck3", NULL),
+	[PM822_ID_BUCK4] = REGULATOR_SUPPLY("v_rf_vdd", NULL),
+#if defined(CONFIG_GOYA_BD_00)
+	[PM822_ID_BUCK5] = REGULATOR_SUPPLY("vmmc", "sdhci-pxav3.0"),
+#else
+	[PM822_ID_BUCK5] = REGULATOR_SUPPLY("v_cam_c", NULL), /* Not used */
+#endif
+	[PM822_ID_LDO1]  = REGULATOR_SUPPLY("v_tsp_3v3", NULL),
+	[PM822_ID_LDO2]  = REGULATOR_SUPPLY("v_dig_1v8", NULL),
+	[PM822_ID_LDO3]  = REGULATOR_SUPPLY("v_cam_avdd", NULL),
+#if defined(CONFIG_GOYA_BD_00)
+	[PM822_ID_LDO4]  = REGULATOR_SUPPLY("v_lcd_3v3", NULL),
+#else
+	[PM822_ID_LDO4]  = REGULATOR_SUPPLY("vmmc", "sdhci-pxav3.0"),
+#endif
+	[PM822_ID_LDO5]  = REGULATOR_SUPPLY("vqmmc", "sdhci-pxav3.0"),
+	[PM822_ID_LDO6]  = REGULATOR_SUPPLY("v_usim1", NULL),
+	[PM822_ID_LDO7]  = REGULATOR_SUPPLY("v_ramp", NULL),
+	[PM822_ID_LDO8]  = REGULATOR_SUPPLY("v_usb_3v1", NULL),
+	[PM822_ID_LDO9]  = REGULATOR_SUPPLY("v_lvds_1v8", NULL),
+	[PM822_ID_LDO10] = REGULATOR_SUPPLY("v_wib_3v3", NULL),
+	[PM822_ID_LDO11] = REGULATOR_SUPPLY("v_sensor", NULL),
+	[PM822_ID_LDO12] = REGULATOR_SUPPLY("v_lvds_1v2", NULL),
+	[PM822_ID_LDO13] = REGULATOR_SUPPLY("v_gps_1v8", NULL),
+	[PM822_ID_LDO14] = REGULATOR_SUPPLY("v_micbias", NULL),
+	[PM822_ID_VOUTSW] = REGULATOR_SUPPLY("v_buck2_sw", NULL),
+
+	/* below 4 IDs are fake ids, they are only used in new dvc */
+	[PM822_ID_BUCK1_AP_ACTIVE]
+		= REGULATOR_SUPPLY("vcc_main_ap_active", NULL),
+	[PM822_ID_BUCK1_AP_LPM]
+		= REGULATOR_SUPPLY("vcc_main_ap_lpm", NULL),
+	[PM822_ID_BUCK1_APSUB_IDLE]
+		= REGULATOR_SUPPLY("vcc_main_apsub_idle", NULL),
+	[PM822_ID_BUCK1_APSUB_SLEEP]
+		= REGULATOR_SUPPLY("vcc_main_apsub_sleep", NULL),
+};
+static int regulator_index[] = {
+	PM822_ID_BUCK1,
+	PM822_ID_BUCK2,
+	PM822_ID_BUCK3,
+	PM822_ID_BUCK4,
+	PM822_ID_BUCK5,
+	PM822_ID_LDO1,
+	PM822_ID_LDO2,
+	PM822_ID_LDO3,
+	PM822_ID_LDO4,
+	PM822_ID_LDO5,
+	PM822_ID_LDO6,
+	PM822_ID_LDO7,
+	PM822_ID_LDO8,
+	PM822_ID_LDO9,
+	PM822_ID_LDO10,
+	PM822_ID_LDO11,
+	PM822_ID_LDO12,
+	PM822_ID_LDO13,
+	PM822_ID_LDO14,
+	PM822_ID_VOUTSW,
+
+	/* below 4 ids are fake id, they are only used in new dvc */
+	PM822_ID_BUCK1_AP_ACTIVE,
+	PM822_ID_BUCK1_AP_LPM,
+	PM822_ID_BUCK1_APSUB_IDLE,
+	PM822_ID_BUCK1_APSUB_SLEEP,
+};
+
+#define REG_INIT(_name, _min, _max, _always, _boot)	\
+{								\
+	.constraints = {					\
+		.name		= __stringify(_name),		\
+		.min_uV		= _min,				\
+		.max_uV		= _max,				\
+		.always_on	= _always,			\
+		.boot_on	= _boot,			\
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE	\
+				| REGULATOR_CHANGE_STATUS,	\
+	},							\
+	.num_consumer_supplies	= 1,				\
+	.consumer_supplies	= &regulator_supplies[PM822_ID_##_name], \
+	.driver_data = &regulator_index[PM822_ID_##_name],	\
+}
+
+static struct regulator_init_data pm822_regulator_data[] = {
+	[PM822_ID_BUCK1] = REG_INIT(BUCK1,  600000, 1800000, 1, 1),
+	[PM822_ID_BUCK2] = REG_INIT(BUCK2,  600000, 3300000, 1, 1),
+	[PM822_ID_BUCK3] = REG_INIT(BUCK3,  600000, 3300000, 1, 1),
+#if defined(CONFIG_GOYA_WIFI)
+	[PM822_ID_BUCK4] = REG_INIT(BUCK4,  600000, 3300000, 0, 0),
+#else
+	[PM822_ID_BUCK4] = REG_INIT(BUCK4,  600000, 3300000, 1, 1),
+#endif
+#if defined(CONFIG_GOYA_BD_00)
+	[PM822_ID_BUCK5] = REG_INIT(BUCK5, 1200000, 3300000, 1, 1),
+#else
+	[PM822_ID_BUCK5] = REG_INIT(BUCK5,  600000, 3950000, 0, 0),
+#endif
+
+	[PM822_ID_LDO1]  = REG_INIT(LDO1,  2800000, 2800000, 0, 0),
+	[PM822_ID_LDO2]  = REG_INIT(LDO2,  1700000, 3300000, 1, 1),
+	[PM822_ID_LDO3]  = REG_INIT(LDO3,  1200000, 3300000, 1, 1),
+	[PM822_ID_LDO4]  = REG_INIT(LDO4,  1200000, 3300000, 0, 0),
+	[PM822_ID_LDO5]  = REG_INIT(LDO5,  1200000, 3300000, 0, 0),
+#if defined(CONFIG_GOYA_WIFI)
+	[PM822_ID_LDO6]  = REG_INIT(LDO6,  1200000, 3300000, 0, 0),
+	[PM822_ID_LDO7]  = REG_INIT(LDO7,  1200000, 3300000, 0, 0),
+#else
+	[PM822_ID_LDO6]  = REG_INIT(LDO6,  1200000, 3300000, 0, 1),
+	[PM822_ID_LDO7]  = REG_INIT(LDO7,  1200000, 3300000, 1, 1),
+#endif
+	[PM822_ID_LDO8]  = REG_INIT(LDO8,  1200000, 3300000, 1, 1),
+	[PM822_ID_LDO9]  = REG_INIT(LDO9,  1200000, 3300000, 0, 1),
+	[PM822_ID_LDO10] = REG_INIT(LDO10, 1200000, 3300000, 1, 1),
+	[PM822_ID_LDO11] = REG_INIT(LDO11, 1200000, 3300000, 1, 1),
+	[PM822_ID_LDO12] = REG_INIT(LDO12,  600000, 1500000, 0, 1),
+	[PM822_ID_LDO13] = REG_INIT(LDO13, 1700000, 3300000, 1, 1),
+	[PM822_ID_LDO14] = REG_INIT(LDO14, 1700000, 2800000, 0, 0),
+	[PM822_ID_VOUTSW] = REG_INIT(VOUTSW, 0, 0, 0, 0),
+
+	/* below 4 items are fake, they are only used in new dvc */
+	[PM822_ID_BUCK1_AP_ACTIVE]
+		= REG_INIT(BUCK1_AP_ACTIVE,  1000, 10000, 1, 1),
+	[PM822_ID_BUCK1_AP_LPM]
+		= REG_INIT(BUCK1_AP_LPM,  1000, 10000, 1, 1),
+	[PM822_ID_BUCK1_APSUB_IDLE]
+		= REG_INIT(BUCK1_APSUB_IDLE,  1000, 10000, 1, 1),
+	[PM822_ID_BUCK1_APSUB_SLEEP]
+		= REG_INIT(BUCK1_APSUB_SLEEP,  1000, 10000, 1, 1),
+};
+
+static struct pm822_dvc_pdata pm822_dvc = {
+	.reg_dvc	= 1,
+};
+
+static int pm822_plat_config(struct pm822_chip *chip,
+				struct pm822_platform_data *pdata)
+{
+		int data;
+
+	if (!chip || !pdata || !chip->regmap || !chip->subchip
+	    || !chip->subchip->regmap_power) {
+		pr_err("%s:chip or pdata is not availiable!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* select 15pF internal capacitance on XTAL1 and XTAL2 */
+	regmap_read(chip->regmap, PM822_RTC_MISC6, &data);
+	data = (data & 0xf) |(0x5 << 4);
+	regmap_write(chip->regmap, PM822_RTC_MISC6, data);
+
+	/*
+	  * Enables Dynamic Voltage Control (DVC) for the internal PMIC digital circuitry only,
+	  * Enables low jitter version of the 32kHz clock
+	  * Gate BUCKs clocks
+	  */
+	regmap_write(chip->regmap, PM822_LOW_POWER2, 0x30);
+
+	/*base page:reg 0xd0.7 = 1 32kHZ generated from XO */
+	regmap_read(chip->regmap, PM822_RTC_CTRL, &data);
+	data |= (1 << 7);
+	regmap_write(chip->regmap, PM822_RTC_CTRL, data);
+
+	/* set oscillator running locked to 32kHZ*/
+	regmap_read(chip->regmap, PM822_OSC_CTRL1, &data);
+	data &= ~(1 << 1);
+	regmap_write(chip->regmap, PM822_OSC_CTRL1, data);
+
+	regmap_read(chip->regmap, PM822_OSC_CTRL6, &data);
+	data &= ~(1 << 1);
+	regmap_write(chip->regmap, PM822_OSC_CTRL6, data);
+
+	/* Set internal digital sleep voltage as 0.9V */
+	regmap_write(chip->regmap, PM822_LOW_POWER1, 0x00);
+
+	/* Enabele LDO and BUCK clock gating in lpm */
+	regmap_write(chip->regmap, PM822_LOW_POWER_CONFIG3, 0x80);
+	/* Enable reference group sleep mode */
+	regmap_write(chip->regmap, PM822_LOW_POWER_CONFIG4, 0x80);
+
+	/* Enable 32Khz-out-from XO 1, 2 all enabled */
+	regmap_write(chip->regmap, PM822_RTC_MISC2, 0xa);
+
+	/* Enable voltage change in pmic, POWER_HOLD = 1 */
+	regmap_write(chip->regmap, PM822_WAKEUP1, 0x80);
+
+	/*
+	 * Block wakeup attempts when VSYS rises above
+	 * VSYS_UNDER_RISE_TH1, or power off may fail
+	 */
+	regmap_read(chip->regmap, PM822_RTC_MISC5, &data);
+	data |= 0x1;
+	regmap_write(chip->regmap, PM822_RTC_MISC5, data);
+
+	/* Check shutdown reason and clear */
+	regmap_read(chip->regmap, PMIC_GENERAL_USE_REGISTER, &data);
+	data &= ~(PMIC_GENERAL_USE_SHUTDOWN_MASK);
+	regmap_write(chip->regmap, PMIC_GENERAL_USE_REGISTER, data);
+
+	regmap_write(chip->subchip->regmap_gpadc, PM822_GPADC_MEAS_OFF1, 0x80);
+
+	/* Enlarge GPADC off slots */
+	regmap_write(chip->subchip->regmap_gpadc, PM822_GPADC_MEAS_OFF2, 0x0f);
+
+	/* Enable GPADC2 */
+	regmap_read(chip->subchip->regmap_gpadc, PM822_GPADC_BIAS_EN1, &data);
+	data |= (0x1 << 6);
+	regmap_write(chip->subchip->regmap_gpadc, PM822_GPADC_BIAS_EN1, data);
+
+	/* Set Bias current fo GPADC2 as 31uA) */
+	regmap_read(chip->subchip->regmap_gpadc, PM822_GPADC_BIAS3, &data);
+	data = (data & 0xf) | 0x6;
+	regmap_write(chip->subchip->regmap_gpadc, PM822_GPADC_BIAS3, data);
+
+	/* Set sleep mode as 0.8V */
+	regmap_write(chip->subchip->regmap_power, PM822_BUCK1_SLP, 0x10);
+
+	/* Set buck1 audio mode as 0.8V */
+	regmap_write(chip->subchip->regmap_power, PM822_AUDIO_MODE, 0x10);
+
+	/* Enable buck sleep mode */
+	regmap_write(chip->subchip->regmap_power, PM822_BUCK_SLP1, 0xaa);
+	regmap_write(chip->subchip->regmap_power, PM822_BUCK_SLP2, 0x2);
+
+	/* Disalbe BUCK4 FPWM mode and LPFM setting*/
+        regmap_write(chip->subchip->regmap_power, PM822_BUCK4_MISC2, 0xae);
+
+	/*Set both buck4 runtime voltage and sleep voltage to 1.85*/
+	regmap_write(chip->subchip->regmap_power, PM822_BUCK4, 0x55);
+	regmap_write(chip->subchip->regmap_power, PM822_BUCK4_SLP, 0x55);
+
+	/* Enable ldo sleep mode */
+	regmap_write(chip->subchip->regmap_power, PM822_LDO_SLP1, 0xaa);
+#if defined(CONFIG_GOYA_WIFI)
+	regmap_write(chip->subchip->regmap_power, PM822_LDO_SLP2, 0xa2);
+#else
+	regmap_write(chip->subchip->regmap_power, PM822_LDO_SLP2, 0xaa);
+#endif
+	regmap_write(chip->subchip->regmap_power, PM822_LDO_SLP3, 0xae);
+	regmap_write(chip->subchip->regmap_power, PM822_LDO_SLP4, 0x0a);
+	regmap_write(chip->subchip->regmap_power, PM822_LDO8, 0xee);
+	/* Increase VDD_TCXO (PMIC LDO2) to 1.9v */
+	regmap_write(chip->subchip->regmap_power, PM822_LDO2, 0x22);
+
+	/*Disable Soft Start of LDO 1/4/13 */
+	regmap_read(chip->subchip->regmap_power, PM822_LDO_MISC1, &data);
+	data |= (1 << 3);
+	regmap_write(chip->subchip->regmap_power, PM822_LDO_MISC1, data);
+
+	regmap_read(chip->subchip->regmap_power, PM822_LDO_MISC2, &data);
+	data |= (1 << 7);
+	regmap_write(chip->subchip->regmap_power, PM822_LDO_MISC2, data);
+
+	regmap_read(chip->subchip->regmap_power, PM822_LDO_MISC8, &data);
+	data |= (1 << 3);
+	regmap_write(chip->subchip->regmap_power, PM822_LDO_MISC8, data);
+
+	/*
+	* Enables the automatic switch of the GPADC operating mode to duty cycle mode when in sleep
+	* Enable GPADC sleep duty cycle mode
+	* Automatic scaling of MEAS_OFF parameter when entering low power mode.
+	* Automatic scaling of MEAS_OFF parameter when entering low power Mode (8x0).
+	*/
+	regmap_read(chip->subchip->regmap_gpadc, PM822_GPADC_MISC_CONFIG2, &data);
+	data |= PM822_MEANS_EN_SLP | ( 1<<5 ) | PM822_GPADC_NON_STOP | PM822_GPADC_EN;
+	regmap_write(chip->subchip->regmap_gpadc, PM822_GPADC_MISC_CONFIG2, data);
+
+	/*2013-12-23 from pmic team*/
+	regmap_write(chip->subchip->regmap_power, PM822_BUCK_SHARED_CTRL, 0x06);
+
+	/* Dump power-down log */
+	regmap_read(chip->regmap, PM822_POWER_DOWN_LOG1, &data);
+	pr_info("PowerDW Log1 0x%x: 0x%x\n", PM822_POWER_DOWN_LOG1, data);
+	regmap_read(chip->regmap, PM822_POWER_DOWN_LOG2, &data);
+	pr_info("PowerDW Log2 0x%x: 0x%x\n", PM822_POWER_DOWN_LOG2, data);
+
+	/*
+	 * DO_NOT clear the power-down log register,
+	 * which are used by PMIC SW fuel gauge;
+	 */
+#if 0
+	/* Clear power-down log */
+	regmap_write(chip->regmap, PM822_POWER_DOWN_LOG1, 0xff);
+	regmap_write(chip->regmap, PM822_POWER_DOWN_LOG2, 0xff);
+#endif
+
+	/*set buck2 and buck4 driver selection to be full.
+	* this bit is now reserved and default value is 0, if want full
+	* drive possibility it should be set to 1.
+	* In next version it will be set to 1 by default.
+	*/
+	regmap_read(chip->subchip->regmap_power, 0x7c, &data);
+	data |= (1 << 2);
+	regmap_write(chip->subchip->regmap_power, 0x7c, data);
+
+	regmap_read(chip->subchip->regmap_power, 0x82, &data);
+	data |= (1 << 2);
+	regmap_write(chip->subchip->regmap_power, 0x82, data);
+
+	/* set buck3 all level to be 1.25v */
+	regmap_write(chip->subchip->regmap_power, PM822_BUCK3, 0x34);
+	regmap_write(chip->subchip->regmap_power, PM822_BUCK3_1, 0x34);
+	regmap_write(chip->subchip->regmap_power, PM822_BUCK3_2, 0x34);
+	regmap_write(chip->subchip->regmap_power, PM822_BUCK3_3, 0x34);
+
+	/*
+	 * Walkaround: there is a h/w issue that the default switching freq
+	 * of buck regulators is half than expected.
+	 */
+	regmap_write(chip->regmap, PM822_OSC_CTRL4, 0x1f);
+
+	return 0;
+}
+
+static int pm805_plat_config(struct pm822_chip *chip,
+				struct pm822_platform_data *pdata)
+{
+	int data;
+	if (!chip || !pdata || !chip->regmap) {
+		pr_err("%s:chip or pdata is not availiable!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* power up */
+	regmap_read(chip->regmap, 0x01, &data);
+	data |= 0x3;
+	regmap_write(chip->regmap, 0x01, data);
+	msleep(1);
+	regmap_write(chip->regmap, 0x30, 0x00);
+	/* power off */
+	data &= ~0x3;
+	regmap_write(chip->regmap, 0x01, data);
+	msleep(1);
+	return 0;
+}
+
+#elif defined(CONFIG_MFD_88PM800)
+/*
+ * PMIC Regulator 88PM800
+ * Power Supply ECOs:
+ * ECO#6: V_2P8(LDO14) is wired to LDO7, so LDO14 should keep off
+ */
+static struct regulator_consumer_supply regulator_supplies[] = {
+	/* BUCK power supplies: BUCK[1..5] */
+	[PM800_ID_BUCK1] = REGULATOR_SUPPLY("vcc_main", NULL),
+	[PM800_ID_BUCK2] = REGULATOR_SUPPLY("v_buck2", NULL),
+	[PM800_ID_BUCK3] = REGULATOR_SUPPLY("v_buck3", NULL),
+	[PM800_ID_BUCK4] = REGULATOR_SUPPLY("v_rf_vdd", NULL),
+	[PM800_ID_BUCK5] = REGULATOR_SUPPLY("v_cam_c", NULL),
+	/* LDO power supplies: LDO[1..19] */
+	[PM800_ID_LDO1]  = REGULATOR_SUPPLY("v_ldo1", NULL),
+	[PM800_ID_LDO2]  = REGULATOR_SUPPLY("v_micbias", NULL),
+	[PM800_ID_LDO3]  = REGULATOR_SUPPLY("v_analog_2v8", NULL),
+	[PM800_ID_LDO4]  = REGULATOR_SUPPLY("v_usim1", NULL),
+	[PM800_ID_LDO5]  = REGULATOR_SUPPLY("v_usb_3v1", NULL),
+	[PM800_ID_LDO6]  = REGULATOR_SUPPLY("v_motor_3v", NULL),
+	[PM800_ID_LDO7]  = REGULATOR_SUPPLY("v_vramp_2v8"/*V_LDO7*/, NULL),
+	[PM800_ID_LDO8]  = REGULATOR_SUPPLY("v_lcd_3V", NULL),
+	[PM800_ID_LDO9]  = REGULATOR_SUPPLY("v_wib_3v3", NULL),
+	[PM800_ID_LDO10] = REGULATOR_SUPPLY("v_proxy_3v", NULL),
+	[PM800_ID_LDO11] = REGULATOR_SUPPLY("v_cam_io", NULL),
+	[PM800_ID_LDO12] = REGULATOR_SUPPLY("vqmmc", "sdhci-pxav3.0"),
+	[PM800_ID_LDO13] = REGULATOR_SUPPLY("vmmc", "sdhci-pxav3.0"),
+	[PM800_ID_LDO14] = REGULATOR_SUPPLY("v_tsp_3v", NULL),
+	[PM800_ID_LDO15] = REGULATOR_SUPPLY("v_proxy_led_3v3", NULL),
+	[PM800_ID_LDO16] = REGULATOR_SUPPLY("v_cam_avdd", NULL),
+	[PM800_ID_LDO17] = REGULATOR_SUPPLY("v_cam_af", NULL),
+	[PM800_ID_LDO18] = REGULATOR_SUPPLY("v_ldo18", NULL),
+	[PM800_ID_LDO19] = REGULATOR_SUPPLY("v_usim2", NULL),
+
+	/* below 4 IDs are fake ids, they are only used in new dvc */
+	[PM800_ID_BUCK1_AP_ACTIVE] = REGULATOR_SUPPLY("vcc_main_ap_active", NULL),
+	[PM800_ID_BUCK1_AP_LPM] = REGULATOR_SUPPLY("vcc_main_ap_lpm", NULL),
+	[PM800_ID_BUCK1_APSUB_IDLE] = REGULATOR_SUPPLY("vcc_main_apsub_idle", NULL),
+	[PM800_ID_BUCK1_APSUB_SLEEP] = REGULATOR_SUPPLY("vcc_main_apsub_sleep", NULL),
+};
+
+static int regulator_index[] = {
+	PM800_ID_BUCK1,
+	PM800_ID_BUCK2,
+	PM800_ID_BUCK3,
+	PM800_ID_BUCK4,
+	PM800_ID_BUCK5,
+	PM800_ID_LDO1,
+	PM800_ID_LDO2,
+	PM800_ID_LDO3,
+	PM800_ID_LDO4,
+	PM800_ID_LDO5,
+	PM800_ID_LDO6,
+	PM800_ID_LDO7,
+	PM800_ID_LDO8,
+	PM800_ID_LDO9,
+	PM800_ID_LDO10,
+	PM800_ID_LDO11,
+	PM800_ID_LDO12,
+	PM800_ID_LDO13,
+	PM800_ID_LDO14,
+	PM800_ID_LDO15,
+	PM800_ID_LDO16,
+	PM800_ID_LDO17,
+	PM800_ID_LDO18,
+	PM800_ID_LDO19,
+
+	/* below 4 ids are fake id, they are only used in new dvc */
+	PM800_ID_BUCK1_AP_ACTIVE,
+	PM800_ID_BUCK1_AP_LPM,
+	PM800_ID_BUCK1_APSUB_IDLE,
+	PM800_ID_BUCK1_APSUB_SLEEP,
+};
+
+#define REG_INIT(_name, _min, _max, _always, _boot)	\
+{								\
+	.constraints = {					\
+		.name		= __stringify(_name),		\
+		.min_uV		= _min,				\
+		.max_uV		= _max,				\
+		.always_on	= _always,			\
+		.boot_on	= _boot,			\
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE	\
+				| REGULATOR_CHANGE_STATUS,	\
+	},							\
+	.num_consumer_supplies	= 1,				\
+	.consumer_supplies	= &regulator_supplies[PM800_ID_##_name], \
+	.driver_data = &regulator_index[PM800_ID_##_name],	\
+}
+static struct regulator_init_data pm800_regulator_data[] = {
+	/* BUCK power supplies: BUCK[1..5] */
+	[PM800_ID_BUCK1] = REG_INIT(BUCK1,  600000, 3950000, 1, 1),
+	[PM800_ID_BUCK2] = REG_INIT(BUCK2,  600000, 3950000, 1, 1),
+	[PM800_ID_BUCK3] = REG_INIT(BUCK3,  600000, 3950000, 1, 1),
+	[PM800_ID_BUCK4] = REG_INIT(BUCK4,  600000, 3950000, 1, 1),
+	[PM800_ID_BUCK5] = REG_INIT(BUCK5,  600000, 3950000, 0, 0),
+	/* LDO power supplies: LDO[1..19] */
+	[PM800_ID_LDO1]  = REG_INIT(LDO1,   600000, 1500000, 0, 0),
+	[PM800_ID_LDO2]  = REG_INIT(LDO2,  1700000, 2800000, 0, 1),
+	[PM800_ID_LDO3]  = REG_INIT(LDO3,  1200000, 3300000, 1, 1),
+	[PM800_ID_LDO4]  = REG_INIT(LDO4,  1200000, 3300000, 0, 0),
+	[PM800_ID_LDO5]  = REG_INIT(LDO5,  1200000, 3300000, 1, 1),
+	[PM800_ID_LDO6]  = REG_INIT(LDO6,  1200000, 3300000, 0, 0),
+	[PM800_ID_LDO7]  = REG_INIT(LDO7,  3300000, 3300000, 0, 1),
+	[PM800_ID_LDO8]  = REG_INIT(LDO8,  1200000, 3300000, 0, 1),
+	[PM800_ID_LDO9]  = REG_INIT(LDO9,  1200000, 3300000, 0, 0),
+	[PM800_ID_LDO10] = REG_INIT(LDO10, 1200000, 3300000, 0, 0),
+	[PM800_ID_LDO11] = REG_INIT(LDO11, 1200000, 3300000, 0, 0),
+	[PM800_ID_LDO12] = REG_INIT(LDO12, 1200000, 3300000, 0, 0),
+	[PM800_ID_LDO13] = REG_INIT(LDO13, 1200000, 3300000, 0, 0),
+	[PM800_ID_LDO14] = REG_INIT(LDO14, 1200000, 3300000, 1, 1),
+	[PM800_ID_LDO15] = REG_INIT(LDO15, 1200000, 3300000, 0, 0),
+	[PM800_ID_LDO16] = REG_INIT(LDO16, 1200000, 3300000, 0, 0),
+	[PM800_ID_LDO17] = REG_INIT(LDO17, 1200000, 3300000, 0, 0),
+	[PM800_ID_LDO18] = REG_INIT(LDO18, 1700000, 3300000, 1, 1),
+	[PM800_ID_LDO19] = REG_INIT(LDO19, 1700000, 3300000, 0, 0),
+
+	/* below 4 items are fake, they are only used in new dvc */
+	[PM800_ID_BUCK1_AP_ACTIVE] = REG_INIT(BUCK1_AP_ACTIVE,  1000, 10000, 1, 1),
+	[PM800_ID_BUCK1_AP_LPM] = REG_INIT(BUCK1_AP_LPM,  1000, 10000, 1, 1),
+	[PM800_ID_BUCK1_APSUB_IDLE] = REG_INIT(BUCK1_APSUB_IDLE,  1000, 10000, 1, 1),
+	[PM800_ID_BUCK1_APSUB_SLEEP] = REG_INIT(BUCK1_APSUB_SLEEP,  1000, 10000, 1, 1),
+};
+#elif defined (CONFIG_MFD_D2199)
+#define mV_to_uV(v)                 ((v) * 1000)
+#define uV_to_mV(v)                 ((v) / 1000)
+#define MAX_MILLI_VOLT              (3300)
+
+
+/* D2199 DC-DCs */
+// BUCK1
+static struct regulator_consumer_supply d2199_buck1_supplies[] = {
+	REGULATOR_SUPPLY("vcc_main", NULL),
+};
+
+static struct regulator_init_data d2199_buck1 = {
+	.constraints = {
+		.min_uV = D2199_BUCK1_VOLT_LOWER,
+		.max_uV = D2199_BUCK1_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_buck1_supplies),
+	.consumer_supplies = d2199_buck1_supplies,
+};
+
+// BUCK2
+static struct regulator_consumer_supply d2199_buck2_supplies[] = {
+	REGULATOR_SUPPLY("v_buck2", NULL),
+};
+
+static struct regulator_init_data d2199_buck2 = {
+	.constraints = {
+		.min_uV = D2199_BUCK2_VOLT_LOWER,
+		.max_uV = D2199_BUCK2_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_buck2_supplies),
+	.consumer_supplies = d2199_buck2_supplies,
+};
+
+// BUCK3
+static struct regulator_consumer_supply d2199_buck3_supplies[] = {
+	REGULATOR_SUPPLY("v_buck3", NULL),
+};
+
+static struct regulator_init_data d2199_buck3 = {
+	.constraints = {
+		.min_uV = D2199_BUCK3_VOLT_LOWER,
+		.max_uV = D2199_BUCK3_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+		.boot_on = 1,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_buck3_supplies),
+	.consumer_supplies = d2199_buck3_supplies,
+};
+
+// BUCK4
+static struct regulator_consumer_supply d2199_buck4_supplies[] = {
+	REGULATOR_SUPPLY("v_rf_vdd", NULL),
+};
+
+static struct regulator_init_data d2199_buck4 = {
+	.constraints = {
+		.min_uV = D2199_BUCK4_VOLT_LOWER,
+		.max_uV = D2199_BUCK4_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_buck4_supplies),
+	.consumer_supplies = d2199_buck4_supplies,
+};
+
+// BUCK5
+static struct regulator_consumer_supply d2199_buck5_supplies[] = {
+	REGULATOR_SUPPLY("v_cam_c", NULL),
+};
+
+static struct regulator_init_data d2199_buck5 = {
+	.constraints = {
+		.min_uV = D2199_BUCK5_VOLT_LOWER,
+		.max_uV = D2199_BUCK5_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_buck5_supplies),
+	.consumer_supplies = d2199_buck5_supplies,
+};
+
+// BUCK6 -> Not connected
+static struct regulator_consumer_supply d2199_buck6_supplies[] = {
+	REGULATOR_SUPPLY("v_BUCK6", NULL),
+};
+
+static struct regulator_init_data d2199_buck6 = {
+	.constraints = {
+		.min_uV = D2199_BUCK6_VOLT_LOWER,
+		.max_uV = D2199_BUCK6_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_buck6_supplies),
+	.consumer_supplies = d2199_buck6_supplies,
+};
+
+/* D2199 LDOs */
+// LDO1
+__weak struct regulator_consumer_supply d2199_ldo1_supplies[] = {
+	REGULATOR_SUPPLY("v_vramp_2v8", NULL),	// V_VRAMP_2.8V
+};
+
+static struct regulator_init_data d2199_ldo1 = {
+	.constraints = {
+		.min_uV = D2199_LDO1_VOLT_LOWER,
+		.max_uV = D2199_LDO1_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+		.boot_on = 1,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo1_supplies),
+	.consumer_supplies = d2199_ldo1_supplies,
+};
+
+
+// LDO2
+__weak struct regulator_consumer_supply d2199_ldo2_supplies[] = {
+	REGULATOR_SUPPLY("v_cam_io", NULL),	// VCAM_IO_1.8V
+};
+
+static struct regulator_init_data d2199_ldo2 = {
+	.constraints = {
+		.min_uV = D2199_LDO2_VOLT_LOWER,
+		.max_uV = D2199_LDO2_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo2_supplies),
+	.consumer_supplies = d2199_ldo2_supplies,
+};
+
+// LDO3
+__weak struct regulator_consumer_supply d2199_ldo3_supplies[] = {
+	REGULATOR_SUPPLY("v_analog_2v8", NULL),	// V_ANALOG_2.8V
+};
+
+static struct regulator_init_data d2199_ldo3 = {
+	.constraints = {
+		.min_uV = D2199_LDO3_VOLT_LOWER,
+		.max_uV = D2199_LDO3_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+		.boot_on = 1,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo3_supplies),
+	.consumer_supplies = d2199_ldo3_supplies,
+};
+
+
+
+// LDO4
+__weak struct regulator_consumer_supply d2199_ldo4_supplies[] = {
+	REGULATOR_SUPPLY("v_cam_avdd", NULL),	// VCAM_A_2.8V
+};
+
+static struct regulator_init_data d2199_ldo4 = {
+	.constraints = {
+		.min_uV = D2199_LDO4_VOLT_LOWER,
+		.max_uV = D2199_LDO4_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo4_supplies),
+	.consumer_supplies = d2199_ldo4_supplies,
+};
+
+
+// LDO5
+__weak struct regulator_consumer_supply d2199_ldo5_supplies[] = {
+	REGULATOR_SUPPLY("v_usb_3v1", NULL),	// v_usb_3v1
+};
+
+static struct regulator_init_data d2199_ldo5 = {
+	.constraints = {
+		.min_uV = D2199_LDO5_VOLT_LOWER,
+		.max_uV = D2199_LDO5_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+		.boot_on = 1,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo5_supplies),
+	.consumer_supplies = d2199_ldo5_supplies,
+};
+
+
+// LDO6
+__weak struct regulator_consumer_supply d2199_ldo6_supplies[] = {
+	REGULATOR_SUPPLY("v_ldo18", NULL),	// VDD_DIG_1.8V
+};
+
+static struct regulator_init_data d2199_ldo6 = {
+	.constraints = {
+		.min_uV = D2199_LDO6_VOLT_LOWER,
+		.max_uV = D2199_LDO6_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo6_supplies),
+	.consumer_supplies = d2199_ldo6_supplies,
+};
+
+// LDO7
+__weak struct regulator_consumer_supply d2199_ldo7_supplies[] = {
+	REGULATOR_SUPPLY("v_tsp_3v3", NULL),	// V_TSP_3.3V
+};
+
+static struct regulator_init_data d2199_ldo7 = {
+	.constraints = {
+		.min_uV = D2199_LDO7_VOLT_LOWER,
+		.max_uV = D2199_LDO7_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 0,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo7_supplies),
+	.consumer_supplies = d2199_ldo7_supplies,
+};
+
+
+// LDO8
+__weak struct regulator_consumer_supply d2199_ldo8_supplies[] = {
+	REGULATOR_SUPPLY("v_lcd_3V", NULL),	// V_LCD_3.0V
+};
+
+static struct regulator_init_data d2199_ldo8 = {
+	.constraints = {
+		.min_uV = D2199_LDO8_VOLT_LOWER,
+		.max_uV = D2199_LDO8_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 0,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo8_supplies),
+	.consumer_supplies = d2199_ldo8_supplies,
+};
+
+// LDO8_REV00
+__weak struct regulator_consumer_supply d2199_ldo8_supplies_rev00[] = {
+	REGULATOR_SUPPLY("v_proxy_led_3v3", NULL),	// V_PROXY_LED_3.3V
+};
+
+static struct regulator_init_data d2199_ldo8_rev00 = {
+	.constraints = {
+		.min_uV = D2199_LDO8_VOLT_LOWER,
+		.max_uV = D2199_LDO8_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo8_supplies_rev00),
+	.consumer_supplies = d2199_ldo8_supplies_rev00,
+};
+
+
+// LDO9
+__weak struct regulator_consumer_supply d2199_ldo9_supplies[] = {
+	REGULATOR_SUPPLY("v_proxy_3v", NULL),	// V_PROXY_3.0V
+};
+
+static struct regulator_init_data d2199_ldo9 = {
+	.constraints = {
+		.min_uV = D2199_LDO9_VOLT_LOWER,
+		.max_uV = D2199_LDO9_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo9_supplies),
+	.consumer_supplies = d2199_ldo9_supplies,
+};
+
+// LDO10
+__weak struct regulator_consumer_supply d2199_ldo10_supplies[] = {
+	REGULATOR_SUPPLY("v_wib_3v3", NULL),	// V_WIFI_3.3V
+};
+
+static struct regulator_init_data d2199_ldo10 = {
+	.constraints = {
+		.min_uV = D2199_LDO10_VOLT_LOWER,
+		.max_uV = D2199_LDO10_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo10_supplies),
+	.consumer_supplies = d2199_ldo10_supplies,
+};
+
+// LDO11
+__weak struct regulator_consumer_supply d2199_ldo11_supplies[] = {
+	REGULATOR_SUPPLY("v_cam_af", NULL),	// VCAM_AF_2.8V
+};
+
+static struct regulator_init_data d2199_ldo11 = {
+	.constraints = {
+		.min_uV = D2199_LDO11_VOLT_LOWER,
+		.max_uV = D2199_LDO11_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo11_supplies),
+	.consumer_supplies = d2199_ldo11_supplies,
+};
+
+// LDO12
+__weak struct regulator_consumer_supply d2199_ldo12_supplies[] = {
+	REGULATOR_SUPPLY("v_proxy_led_3v3", NULL),	// V_PROXY_LED_3.3V
+};
+
+static struct regulator_init_data d2199_ldo12 = {
+	.constraints = {
+		.min_uV = D2199_LDO12_VOLT_LOWER,
+		.max_uV = D2199_LDO12_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo12_supplies),
+	.consumer_supplies = d2199_ldo12_supplies,
+};
+
+// LDO12_REV00
+__weak struct regulator_consumer_supply d2199_ldo12_supplies_rev00[] = {
+	REGULATOR_SUPPLY("v_lcd_3V", NULL),	// V_LCD_3.0V
+};
+
+static struct regulator_init_data d2199_ldo12_rev00 = {
+	.constraints = {
+		.min_uV = D2199_LDO12_VOLT_LOWER,
+		.max_uV = D2199_LDO12_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 0,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo12_supplies_rev00),
+	.consumer_supplies = d2199_ldo12_supplies_rev00,
+};
+
+
+// LDO13
+__weak struct regulator_consumer_supply d2199_ldo13_supplies[] = {
+	REGULATOR_SUPPLY("v_usim1", NULL),	// V_SIM1_3.0V
+};
+
+static struct regulator_init_data d2199_ldo13 = {
+	.constraints = {
+		.min_uV = D2199_LDO13_VOLT_LOWER,
+		.max_uV = D2199_LDO13_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo13_supplies),
+	.consumer_supplies = d2199_ldo13_supplies,
+};
+
+
+// LDO14
+__weak struct regulator_consumer_supply d2199_ldo14_supplies[] = {
+	REGULATOR_SUPPLY("v_usim2", NULL),	// V_SIM2_3.1V
+};
+
+static struct regulator_init_data d2199_ldo14 = {
+	.constraints = {
+		.min_uV = D2199_LDO14_VOLT_LOWER,
+		.max_uV = D2199_LDO14_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo14_supplies),
+	.consumer_supplies = d2199_ldo14_supplies,
+};
+
+
+// LDO15
+__weak struct regulator_consumer_supply d2199_ldo15_supplies[] = {
+	REGULATOR_SUPPLY("vqmmc", "sdhci-pxav3.0"),	// V_MMC_3.3V
+};
+
+static struct regulator_init_data d2199_ldo15 = {
+	.constraints = {
+		.min_uV = D2199_LDO15_VOLT_LOWER,
+		.max_uV = D2199_LDO15_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo15_supplies),
+	.consumer_supplies = d2199_ldo15_supplies,
+};
+
+
+
+// LDO16
+__weak struct regulator_consumer_supply d2199_ldo16_supplies[] = {
+	REGULATOR_SUPPLY("vmmc", "sdhci-pxav3.0"),	// V_SD_3.3V
+};
+
+static struct regulator_init_data d2199_ldo16 = {
+	.constraints = {
+		.min_uV = D2199_LDO16_VOLT_LOWER,
+		.max_uV = D2199_LDO16_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo16_supplies),
+	.consumer_supplies = d2199_ldo16_supplies,
+};
+
+
+// LDO17
+__weak struct regulator_consumer_supply d2199_ldo17_supplies[] = {
+	REGULATOR_SUPPLY("v_ldo17_dummy", NULL),	// Not connected
+};
+
+static struct regulator_init_data d2199_ldo17 = {
+	.constraints = {
+		.min_uV = D2199_LDO17_VOLT_LOWER,
+		.max_uV = D2199_LDO17_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo17_supplies),
+	.consumer_supplies = d2199_ldo17_supplies,
+};
+
+// LDO18
+__weak struct regulator_consumer_supply d2199_ldo18_supplies[] = {
+	REGULATOR_SUPPLY("v_ldo18_dummy", NULL),	// Notconnected
+};
+
+static struct regulator_init_data d2199_ldo18 = {
+	.constraints = {
+		.min_uV = D2199_LDO18_VOLT_LOWER,
+		.max_uV = D2199_LDO18_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo18_supplies),
+	.consumer_supplies = d2199_ldo18_supplies,
+};
+
+
+// LDO19
+__weak struct regulator_consumer_supply d2199_ldo19_supplies[] = {
+	REGULATOR_SUPPLY("v_ldo19_dummy", NULL),	// Not connected
+};
+
+static struct regulator_init_data d2199_ldo19 = {
+	.constraints = {
+		.min_uV = D2199_LDO19_VOLT_LOWER,
+		.max_uV = D2199_LDO19_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo19_supplies),
+	.consumer_supplies = d2199_ldo19_supplies,
+};
+
+// LDO20
+__weak struct regulator_consumer_supply d2199_ldo20_supplies[] = {
+	REGULATOR_SUPPLY("v_ldo20_dummy", NULL),	// Notconnected
+};
+
+static struct regulator_init_data d2199_ldo20 = {
+	.constraints = {
+		.min_uV = D2199_LDO20_VOLT_LOWER,
+		.max_uV = D2199_LDO20_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldo20_supplies),
+	.consumer_supplies = d2199_ldo20_supplies,
+};
+
+// LDO_AUD_1
+__weak struct regulator_consumer_supply d2199_ldoaud1_supplies[] = {
+	REGULATOR_SUPPLY("aud1", NULL),	// aud1
+};
+
+static struct regulator_init_data d2199_ldoaud1 = {
+	.constraints = {
+		.min_uV = D2199_LDOAUD1_VOLT_LOWER,
+		.max_uV = D2199_LDOAUD1_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldoaud1_supplies),
+	.consumer_supplies = d2199_ldoaud1_supplies,
+};
+
+// LDO_AUD_2
+__weak struct regulator_consumer_supply d2199_ldoaud2_supplies[] = {
+	REGULATOR_SUPPLY("aud2", NULL),	// aud2
+};
+
+static struct regulator_init_data d2199_ldoaud2 = {
+	.constraints = {
+		.min_uV = D2199_LDOAUD2_VOLT_LOWER,
+		.max_uV = D2199_LDOAUD2_VOLT_UPPER,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_ldoaud2_supplies),
+	.consumer_supplies = d2199_ldoaud2_supplies,
+};
+
+
+#if defined(CONFIG_D2199_DVC)
+static struct regulator_consumer_supply d2199_buck1_ap_active_supplies[] = {
+	REGULATOR_SUPPLY("vcc_main_ap_active", NULL),
+};
+
+static struct regulator_init_data d2199_buck1_ap_active = {
+	.constraints = {
+		.min_uV = 1000,
+		.max_uV = 10000,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_buck1_ap_active_supplies),
+	.consumer_supplies = d2199_buck1_ap_active_supplies,
+};
+//---
+static struct regulator_consumer_supply d2199_buck1_ap_lpm_supplies[] = {
+	REGULATOR_SUPPLY("vcc_main_ap_lpm", NULL),
+};
+
+static struct regulator_init_data d2199_buck1_ap_lpm = {
+	.constraints = {
+		.min_uV = 1000,
+		.max_uV = 10000,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_buck1_ap_lpm_supplies),
+	.consumer_supplies = d2199_buck1_ap_lpm_supplies,
+};
+//---
+static struct regulator_consumer_supply d2199_buck1_apsub_idle_supplies[] = {
+	REGULATOR_SUPPLY("vcc_main_apsub_idle", NULL),
+};
+
+static struct regulator_init_data d2199_buck1_apsub_idle = {
+	.constraints = {
+		.min_uV = 1000,
+		.max_uV = 10000,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_buck1_apsub_idle_supplies),
+	.consumer_supplies = d2199_buck1_apsub_idle_supplies,
+};
+//---
+static struct regulator_consumer_supply d2199_buck1_apsub_sleep_supplies[] = {
+	REGULATOR_SUPPLY("vcc_main_apsub_sleep", NULL),
+};
+
+static struct regulator_init_data d2199_buck1_apsub_sleep = {
+	.constraints = {
+		.min_uV = 1000,
+		.max_uV = 10000,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(d2199_buck1_apsub_sleep_supplies),
+	.consumer_supplies = d2199_buck1_apsub_sleep_supplies,
+};
+
+#endif
+static struct d2199_regl_init_data d2199_regulators_init_data[D2199_NUMBER_OF_REGULATORS] = {
+	[D2199_BUCK_1] = { D2199_BUCK_1,  &d2199_buck1 },
+	[D2199_BUCK_2] = { D2199_BUCK_2,  &d2199_buck2 },
+	[D2199_BUCK_3] = { D2199_BUCK_3,  &d2199_buck3 },
+	[D2199_BUCK_4] = { D2199_BUCK_4,  &d2199_buck4 },
+	[D2199_BUCK_5] = { D2199_BUCK_5,  &d2199_buck5 },
+	[D2199_BUCK_6] = { D2199_BUCK_6,  &d2199_buck6 },
+
+	[D2199_LDO_1]  = { D2199_LDO_1, &d2199_ldo1 },
+	[D2199_LDO_2]  = { D2199_LDO_2, &d2199_ldo2 },
+	[D2199_LDO_3]  = { D2199_LDO_3, &d2199_ldo3 },
+	[D2199_LDO_4]  = { D2199_LDO_4, &d2199_ldo4 },
+	[D2199_LDO_5]  = { D2199_LDO_5, &d2199_ldo5 },
+	[D2199_LDO_6]  = { D2199_LDO_6, &d2199_ldo6 },
+	[D2199_LDO_7]  = { D2199_LDO_7, &d2199_ldo7 },
+	[D2199_LDO_8]  = { D2199_LDO_8, &d2199_ldo8 },
+	[D2199_LDO_9]  = { D2199_LDO_9, &d2199_ldo9 },
+	[D2199_LDO_10] = { D2199_LDO_10, &d2199_ldo10 },
+	[D2199_LDO_11] = { D2199_LDO_11, &d2199_ldo11 },
+	[D2199_LDO_12] = { D2199_LDO_12, &d2199_ldo12 },
+	[D2199_LDO_13] = { D2199_LDO_13, &d2199_ldo13 },
+	[D2199_LDO_14] = { D2199_LDO_14, &d2199_ldo14 },
+	[D2199_LDO_15] = { D2199_LDO_15, &d2199_ldo15 },
+	[D2199_LDO_16] = { D2199_LDO_16, &d2199_ldo16 },
+	[D2199_LDO_17] = { D2199_LDO_17, &d2199_ldo17 },
+	[D2199_LDO_18] = { D2199_LDO_15, &d2199_ldo18 },
+	[D2199_LDO_19] = { D2199_LDO_16, &d2199_ldo19 },
+	[D2199_LDO_20] = { D2199_LDO_17, &d2199_ldo20 },
+
+	[D2199_LDO_AUD1] = { D2199_LDO_AUD1, &d2199_ldoaud1 },
+	[D2199_LDO_AUD2] = { D2199_LDO_AUD2, &d2199_ldoaud2 },
+
+#if defined(CONFIG_D2199_DVC)
+	/* below 4 items are fake, they are only used in new dvc */
+	[D2199_ID_BUCK1_AP_ACTIVE] 	 = { D2199_ID_BUCK1_AP_ACTIVE, 	&d2199_buck1_ap_active },
+	[D2199_ID_BUCK1_AP_LPM] 	 = { D2199_ID_BUCK1_AP_LPM, 	&d2199_buck1_ap_lpm },
+	[D2199_ID_BUCK1_APSUB_IDLE]  = { D2199_ID_BUCK1_APSUB_IDLE, &d2199_buck1_apsub_idle },
+	[D2199_ID_BUCK1_APSUB_SLEEP] = { D2199_ID_BUCK1_APSUB_SLEEP,&d2199_buck1_apsub_sleep },
+#endif
+};
+
+static struct d2199_regl_init_data d2199_regulators_init_data_rev00[D2199_NUMBER_OF_REGULATORS] = {
+	[D2199_BUCK_1] = { D2199_BUCK_1,  &d2199_buck1 },
+	[D2199_BUCK_2] = { D2199_BUCK_2,  &d2199_buck2 },
+	[D2199_BUCK_3] = { D2199_BUCK_3,  &d2199_buck3 },
+	[D2199_BUCK_4] = { D2199_BUCK_4,  &d2199_buck4 },
+	[D2199_BUCK_5] = { D2199_BUCK_5,  &d2199_buck5 },
+	[D2199_BUCK_6] = { D2199_BUCK_6,  &d2199_buck6 },
+
+	[D2199_LDO_1]  = { D2199_LDO_1, &d2199_ldo1 },
+	[D2199_LDO_2]  = { D2199_LDO_2, &d2199_ldo2 },
+	[D2199_LDO_3]  = { D2199_LDO_3, &d2199_ldo3 },
+	[D2199_LDO_4]  = { D2199_LDO_4, &d2199_ldo4 },
+	[D2199_LDO_5]  = { D2199_LDO_5, &d2199_ldo5 },
+	[D2199_LDO_6]  = { D2199_LDO_6, &d2199_ldo6 },
+	[D2199_LDO_7]  = { D2199_LDO_7, &d2199_ldo7 },
+	[D2199_LDO_8]  = { D2199_LDO_8, &d2199_ldo8_rev00 },
+	[D2199_LDO_9]  = { D2199_LDO_9, &d2199_ldo9 },
+	[D2199_LDO_10] = { D2199_LDO_10, &d2199_ldo10 },
+	[D2199_LDO_11] = { D2199_LDO_11, &d2199_ldo11 },
+	[D2199_LDO_12] = { D2199_LDO_12, &d2199_ldo12_rev00 },
+	[D2199_LDO_13] = { D2199_LDO_13, &d2199_ldo13 },
+	[D2199_LDO_14] = { D2199_LDO_14, &d2199_ldo14 },
+	[D2199_LDO_15] = { D2199_LDO_15, &d2199_ldo15 },
+	[D2199_LDO_16] = { D2199_LDO_16, &d2199_ldo16 },
+	[D2199_LDO_17] = { D2199_LDO_17, &d2199_ldo17 },
+	[D2199_LDO_18] = { D2199_LDO_15, &d2199_ldo18 },
+	[D2199_LDO_19] = { D2199_LDO_16, &d2199_ldo19 },
+	[D2199_LDO_20] = { D2199_LDO_17, &d2199_ldo20 },
+
+	[D2199_LDO_AUD1] = { D2199_LDO_AUD1, &d2199_ldoaud1 },
+	[D2199_LDO_AUD2] = { D2199_LDO_AUD2, &d2199_ldoaud2 },
+
+#if defined(CONFIG_D2199_DVC)
+	/* below 4 items are fake, they are only used in new dvc */
+	[D2199_ID_BUCK1_AP_ACTIVE] 	 = { D2199_ID_BUCK1_AP_ACTIVE, 	&d2199_buck1_ap_active },
+	[D2199_ID_BUCK1_AP_LPM] 	 = { D2199_ID_BUCK1_AP_LPM, 	&d2199_buck1_ap_lpm },
+	[D2199_ID_BUCK1_APSUB_IDLE]  = { D2199_ID_BUCK1_APSUB_IDLE, &d2199_buck1_apsub_idle },
+	[D2199_ID_BUCK1_APSUB_SLEEP] = { D2199_ID_BUCK1_APSUB_SLEEP,&d2199_buck1_apsub_sleep },
+#endif
+};
+
+struct d2199_battery_platform_data pbat_pdata = {
+       .battery_technology = POWER_SUPPLY_TECHNOLOGY_LION,
+       .battery_capacity = 1300,
+       .vf_lower    = 250,
+       .vf_upper = 510,
+};
+
+#if defined(CONFIG_D2199_DVC)
+static struct d2199_dvc_pdata d2199_dvc = {
+	.dvc1		= MFP_PIN_GPIO43,
+	.dvc2		= MFP_PIN_GPIO44,
+	.gpio_dvc	= 1,
+};
+#endif
+
+static int sync_time_to_soc(unsigned int ticks);
+
+struct d2199_headset_pdata d2199_headset = {
+	/*
+	 * ADC Range 0 - 255
+	 */
+	.send_min = 0,
+	.send_max = 15,
+	.vol_up_min = 16,
+	.vol_up_max = 31,
+	.vol_down_min = 32,
+	.vol_down_max = 66,
+	.jack_3pole_max = 94,
+	.jack_4pole_max = 255
+};
+
+struct d2199_platform_data d2199_pdata = {
+	.headset = &d2199_headset,  // headset plaform data
+#if defined(CONFIG_BATTERY_SAMSUNG)
+	.pbat_platform = &sec_battery_pdata,
+#else
+	.pbat_platform  = &pbat_pdata,
+#endif
+#if defined(CONFIG_D2199_DVC)
+	.dvc = &d2199_dvc,
+#endif
+#ifdef CONFIG_RTC_DRV_SA1100
+	.sync	= sync_time_to_soc,
+#endif
+	.regulator_data = &d2199_regulators_init_data[0],
+	.regl_map = {
+		/*
+		 *		Define initial MCTL value of WILCOX with D2199
+		 *
+		 *	[ LDO ]	0x0 : Off	[ BUCK 2,3,4]	0x0 : Off
+		 *			0x1 : On					0x1 : On
+		 *			0x2 : Sleep - LPM			0x2 : Sleep(Force PFM mode) - LPM
+		 *	0x66 :	01		10		01		10	(ON , LPM, ON , LPM)
+		 *	0x44 :	01		00		01		00	(ON , OFF, ON , OFF)
+		 * ---------------------------------------------------------------
+		 *
+		*/
+	 // for WILCOX 20130426 -  should be connected to M_CTL1
+	D2199_MCTL_MODE_INIT(D2199_BUCK_1, 0x06, D2199_REGULATOR_LPM_IN_DSM), // VCORE_MAIN_1.2V
+	D2199_MCTL_MODE_INIT(D2199_BUCK_2, 0x06, D2199_REGULATOR_LPM_IN_DSM), // VREG_1.8V
+	D2199_MCTL_MODE_INIT(D2199_BUCK_3, 0x06, D2199_REGULATOR_LPM_IN_DSM), // VREG_1.2V
+	D2199_MCTL_MODE_INIT(D2199_BUCK_4, 0x06, D2199_REGULATOR_LPM_IN_DSM), // V_DIGRF_1.8V
+	D2199_MCTL_MODE_INIT(D2199_BUCK_5, 0x00, D2199_REGULATOR_OFF_IN_DSM), // VCAM_C_1.2V
+	D2199_MCTL_MODE_INIT(D2199_BUCK_6, 0x00, D2199_REGULATOR_OFF_IN_DSM), // -- Not connected
+	D2199_MCTL_MODE_INIT(D2199_LDO_1,  0x06, D2199_REGULATOR_LPM_IN_DSM), // V_VRAMP_2.8V
+	D2199_MCTL_MODE_INIT(D2199_LDO_2,  0x00, D2199_REGULATOR_OFF_IN_DSM), // VCAM_IO_1.8V
+	D2199_MCTL_MODE_INIT(D2199_LDO_3,  0x06, D2199_REGULATOR_LPM_IN_DSM), // V_ANALOG_2.8V
+	D2199_MCTL_MODE_INIT(D2199_LDO_4,  0x00, D2199_REGULATOR_OFF_IN_DSM), // VCAM_A_2.8V
+	D2199_MCTL_MODE_INIT(D2199_LDO_5,  0x06, D2199_REGULATOR_LPM_IN_DSM), // V_USB_3.1V
+	D2199_MCTL_MODE_INIT(D2199_LDO_6,  0x06, D2199_REGULATOR_LPM_IN_DSM), // VDD_DIG_1.8V
+	D2199_MCTL_MODE_INIT(D2199_LDO_7,  0x04, D2199_REGULATOR_OFF_IN_DSM), // V_TSP_3.3V
+	D2199_MCTL_MODE_INIT(D2199_LDO_8,  0x06, D2199_REGULATOR_LPM_IN_DSM), // V_LCD_3.0V
+	D2199_MCTL_MODE_INIT(D2199_LDO_9,  0x00, D2199_REGULATOR_OFF_IN_DSM), // V_PROXY_3.0V
+	D2199_MCTL_MODE_INIT(D2199_LDO_10, 0x02, D2199_REGULATOR_LPM_IN_DSM), // V_WIFI_3.3V
+	D2199_MCTL_MODE_INIT(D2199_LDO_11, 0x00, D2199_REGULATOR_OFF_IN_DSM), // VCAM_AF_2.8V
+	D2199_MCTL_MODE_INIT(D2199_LDO_12, 0x00, D2199_REGULATOR_OFF_IN_DSM), // V_PROXY_LED_3.3V
+	D2199_MCTL_MODE_INIT(D2199_LDO_13, 0x00, D2199_REGULATOR_OFF_IN_DSM), // V_SIM1_3.0V
+	D2199_MCTL_MODE_INIT(D2199_LDO_14, 0x00, D2199_REGULATOR_OFF_IN_DSM), // V_SIM2_3.1V
+	D2199_MCTL_MODE_INIT(D2199_LDO_15, 0x00, D2199_REGULATOR_OFF_IN_DSM), // V_MMC_3.3V
+	D2199_MCTL_MODE_INIT(D2199_LDO_16, 0x00, D2199_REGULATOR_OFF_IN_DSM), // V_SD_3.3V
+	D2199_MCTL_MODE_INIT(D2199_LDO_17, 0x00, D2199_REGULATOR_OFF_IN_DSM), // -- Not connected
+	D2199_MCTL_MODE_INIT(D2199_LDO_18, 0x00, D2199_REGULATOR_OFF_IN_DSM), // -- Not connected
+	D2199_MCTL_MODE_INIT(D2199_LDO_19, 0x00, D2199_REGULATOR_OFF_IN_DSM), // -- Not connected
+	D2199_MCTL_MODE_INIT(D2199_LDO_20, 0x00, D2199_REGULATOR_OFF_IN_DSM), // -- Not connected
+
+	D2199_MCTL_MODE_INIT(D2199_LDO_AUD1, 0x00, D2199_REGULATOR_OFF_IN_DSM), // LDO_AUD1 1.8
+	D2199_MCTL_MODE_INIT(D2199_LDO_AUD2, 0x00, D2199_REGULATOR_OFF_IN_DSM), // LDO_AUD2 3.3
+
+#if defined(CONFIG_D2199_DVC)
+	D2199_MCTL_MODE_INIT(D2199_ID_BUCK1_AP_ACTIVE, 	0xDE, D2199_REGULATOR_LPM_IN_DSM), // VCORE_MAIN_1.2V
+	D2199_MCTL_MODE_INIT(D2199_ID_BUCK1_AP_LPM, 	0xDE, D2199_REGULATOR_LPM_IN_DSM), // VCORE_MAIN_1.2V
+	D2199_MCTL_MODE_INIT(D2199_ID_BUCK1_APSUB_IDLE, 0xDE, D2199_REGULATOR_LPM_IN_DSM), // VCORE_MAIN_1.2V
+	D2199_MCTL_MODE_INIT(D2199_ID_BUCK1_APSUB_SLEEP,0xDE, D2199_REGULATOR_LPM_IN_DSM), // VCORE_MAIN_1.2V
+#endif
+	},
+};
+
+struct d2199_platform_data d2199_pdata_rev00 = {
+#if defined(CONFIG_BATTERY_SAMSUNG)
+	.pbat_platform = &sec_battery_pdata,
+#else
+	.pbat_platform  = &pbat_pdata,
+#endif
+#if defined(CONFIG_D2199_DVC)
+	.dvc = &d2199_dvc,
+#endif
+#ifdef CONFIG_RTC_DRV_SA1100
+	.sync	= sync_time_to_soc,
+#endif
+	.regulator_data = &d2199_regulators_init_data_rev00[0],
+	.regl_map = {
+		/*
+		 *		Define initial MCTL value of WILCOX with D2199
+		 *
+		 *	[ LDO ]	0x0 : Off	[ BUCK 2,3,4]	0x0 : Off
+		 *			0x1 : On					0x1 : On
+		 *			0x2 : Sleep - LPM			0x2 : Sleep(Force PFM mode) - LPM
+		 *	0x66 :	01		10		01		10	(ON , LPM, ON , LPM)
+		 *	0x44 :	01		00		01		00	(ON , OFF, ON , OFF)
+		 * ---------------------------------------------------------------
+		 *
+		*/
+	 // for WILCOX 20130426 -  should be connected to M_CTL1
+	D2199_MCTL_MODE_INIT(D2199_BUCK_1, 0x06, D2199_REGULATOR_LPM_IN_DSM), // VCORE_MAIN_1.2V
+	D2199_MCTL_MODE_INIT(D2199_BUCK_2, 0x06, D2199_REGULATOR_LPM_IN_DSM), // VREG_1.8V
+	D2199_MCTL_MODE_INIT(D2199_BUCK_3, 0x06, D2199_REGULATOR_LPM_IN_DSM), // VREG_1.2V
+	D2199_MCTL_MODE_INIT(D2199_BUCK_4, 0x06, D2199_REGULATOR_LPM_IN_DSM), // V_DIGRF_1.8V
+	D2199_MCTL_MODE_INIT(D2199_BUCK_5, 0x00, D2199_REGULATOR_OFF_IN_DSM), // VCAM_C_1.2V
+	D2199_MCTL_MODE_INIT(D2199_BUCK_6, 0x00, D2199_REGULATOR_OFF_IN_DSM), // -- Not connected
+	D2199_MCTL_MODE_INIT(D2199_LDO_1,  0x06, D2199_REGULATOR_LPM_IN_DSM), // V_VRAMP_2.8V
+	D2199_MCTL_MODE_INIT(D2199_LDO_2,  0x00, D2199_REGULATOR_OFF_IN_DSM), // VCAM_IO_1.8V
+	D2199_MCTL_MODE_INIT(D2199_LDO_3,  0x06, D2199_REGULATOR_LPM_IN_DSM), // V_ANALOG_2.8V
+	D2199_MCTL_MODE_INIT(D2199_LDO_4,  0x00, D2199_REGULATOR_OFF_IN_DSM), // VCAM_A_2.8V
+	D2199_MCTL_MODE_INIT(D2199_LDO_5,  0x06, D2199_REGULATOR_LPM_IN_DSM), // V_USB_3.1V
+	D2199_MCTL_MODE_INIT(D2199_LDO_6,  0x06, D2199_REGULATOR_LPM_IN_DSM), // VDD_DIG_1.8V
+	D2199_MCTL_MODE_INIT(D2199_LDO_7,  0x04, D2199_REGULATOR_OFF_IN_DSM), // V_TSP_3.3V
+	D2199_MCTL_MODE_INIT(D2199_LDO_8,  0x00, D2199_REGULATOR_OFF_IN_DSM), // V_PROXY_LED_3.3V
+	D2199_MCTL_MODE_INIT(D2199_LDO_9,  0x00, D2199_REGULATOR_OFF_IN_DSM), // V_PROXY_3.0V
+	D2199_MCTL_MODE_INIT(D2199_LDO_10, 0x02, D2199_REGULATOR_LPM_IN_DSM), // V_WIFI_3.3V
+	D2199_MCTL_MODE_INIT(D2199_LDO_11, 0x00, D2199_REGULATOR_OFF_IN_DSM), // VCAM_AF_2.8V
+	D2199_MCTL_MODE_INIT(D2199_LDO_12, 0x06, D2199_REGULATOR_LPM_IN_DSM), // V_LCD_3.0V
+	D2199_MCTL_MODE_INIT(D2199_LDO_13, 0x00, D2199_REGULATOR_OFF_IN_DSM), // V_SIM1_3.0V
+	D2199_MCTL_MODE_INIT(D2199_LDO_14, 0x00, D2199_REGULATOR_OFF_IN_DSM), // V_SIM2_3.1V
+	D2199_MCTL_MODE_INIT(D2199_LDO_15, 0x00, D2199_REGULATOR_OFF_IN_DSM), // V_MMC_3.3V
+	D2199_MCTL_MODE_INIT(D2199_LDO_16, 0x00, D2199_REGULATOR_OFF_IN_DSM), // V_SD_3.3V
+	D2199_MCTL_MODE_INIT(D2199_LDO_17, 0x00, D2199_REGULATOR_OFF_IN_DSM), // -- Not connected
+	D2199_MCTL_MODE_INIT(D2199_LDO_18, 0x00, D2199_REGULATOR_OFF_IN_DSM), // -- Not connected
+	D2199_MCTL_MODE_INIT(D2199_LDO_19, 0x00, D2199_REGULATOR_OFF_IN_DSM), // -- Not connected
+	D2199_MCTL_MODE_INIT(D2199_LDO_20, 0x00, D2199_REGULATOR_OFF_IN_DSM), // -- Not connected
+
+	D2199_MCTL_MODE_INIT(D2199_LDO_AUD1, 0x00, D2199_REGULATOR_OFF_IN_DSM), // LDO_AUD1 1.8
+	D2199_MCTL_MODE_INIT(D2199_LDO_AUD2, 0x00, D2199_REGULATOR_OFF_IN_DSM), // LDO_AUD2 3.3
+
+#if defined(CONFIG_D2199_DVC)
+	D2199_MCTL_MODE_INIT(D2199_ID_BUCK1_AP_ACTIVE, 	0xDE, D2199_REGULATOR_LPM_IN_DSM), // VCORE_MAIN_1.2V
+	D2199_MCTL_MODE_INIT(D2199_ID_BUCK1_AP_LPM, 	0xDE, D2199_REGULATOR_LPM_IN_DSM), // VCORE_MAIN_1.2V
+	D2199_MCTL_MODE_INIT(D2199_ID_BUCK1_APSUB_IDLE, 0xDE, D2199_REGULATOR_LPM_IN_DSM), // VCORE_MAIN_1.2V
+	D2199_MCTL_MODE_INIT(D2199_ID_BUCK1_APSUB_SLEEP,0xDE, D2199_REGULATOR_LPM_IN_DSM), // VCORE_MAIN_1.2V
+#endif
+	},
+};
+
+#if defined(CONFIG_D2199_DVC)
+static void d2199_dvctable_init(void)
+{
+	unsigned int *vol_table;
+	/* dvc only support 4 lvl voltage*/
+	unsigned int vol_tbsize = 4;
+	unsigned int index, max_vl, lowest_rate;
+
+	//printk("[WS][DVFS][%s]\n", __func__);
+
+	vol_table = kmalloc(vol_tbsize * sizeof(unsigned int), GFP_KERNEL);
+	if (!vol_table) {
+		pr_err("%s failed to malloc vol table!\n", __func__);
+		return ;
+	}
+
+	max_vl = pxa988_get_vl_num();
+	max_vl = (max_vl > 4) ? 4 : max_vl;
+	for (index = 0; index < max_vl; index++){
+		vol_table[index] = pxa988_get_vl(index) * 1000;
+		//printk("[WS][DVFS][%s], vol_table[%d] = [0x%x]\n", __func__, index, vol_table[index]);
+	}
+
+	lowest_rate = pxa988_get_vl(0);
+	while (index < 4)
+		vol_table[index++] = lowest_rate * 1000;
+
+	d2199_dvc.vol_val = vol_table;
+	d2199_dvc.size	= vol_tbsize;
+	return ;
+}
+#endif
+#endif
+
+#ifdef CONFIG_REGULATOR_RT5033
+#include <linux/mfd/rt5033.h>
+static struct regulator_consumer_supply rt5033_safe_ldo_consumers[] = {
+	REGULATOR_SUPPLY("vbus_5v_ldo",NULL),
+};
+
+static struct regulator_consumer_supply rt5033_ldo_consumers[] = {
+	REGULATOR_SUPPLY("v_touchkey_2v2",NULL),
+};
+
+static struct regulator_consumer_supply rt5033_buck_consumers[] = {
+	REGULATOR_SUPPLY("v_cam_c_1.2v",NULL),
+};
+
+static struct regulator_init_data rt5033_safe_ldo_data = {
+	.constraints = {
+		.name		= "VBUS_5V_LDO",
+		.min_uV = 3300000,
+		.max_uV = 4950000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.always_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(rt5033_safe_ldo_consumers),
+	.consumer_supplies = rt5033_safe_ldo_consumers,
+};
+
+static struct regulator_init_data rt5033_ldo_data = {
+	.constraints	= {
+		.name		= "V_TOUCHKEY_2V2",
+		.min_uV = 2200000,
+		.max_uV = 2200000,
+		.always_on = 0,
+		.boot_on = 0,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(rt5033_ldo_consumers),
+	.consumer_supplies = rt5033_ldo_consumers,
+};
+
+static struct regulator_init_data rt5033_buck_data = {
+	.constraints	= {
+		.name		= "V_CAM_C_1.2V",
+		.min_uV = 1200000,
+		.max_uV = 1200000,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(rt5033_buck_consumers),
+	.consumer_supplies = rt5033_buck_consumers,
+};
+
+struct rt5033_regulator_platform_data rv_pdata = {
+	.regulator = {
+		[RT5033_ID_LDO_SAFE] = &rt5033_safe_ldo_data,
+		[RT5033_ID_LDO1] = &rt5033_ldo_data,
+		[RT5033_ID_DCDC1] = &rt5033_buck_data,
+	},
+};
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_MXT336S)
+struct tsp_callbacks *charger_callbacks;
+struct tsp_callbacks {
+	void (*inform_charger)(struct tsp_callbacks *tsp_cb, bool mode);
+};
+#endif
+
+static void mic_set_power(int on)
+{
+	static int mic_power_flag = 0;
+	struct regulator *v_ldo = regulator_get(NULL, "v_micbias");
+	if (IS_ERR(v_ldo)) {
+		v_ldo = NULL;
+		pr_err("Get regulator error\n");
+		return;
+	}
+
+	if (on && (!mic_power_flag)) {
+		regulator_enable(v_ldo);
+		mic_power_flag = 1;
+	}
+
+	if (mic_power_flag && (!on)) {
+		regulator_disable(v_ldo);
+		mic_power_flag = 0;
+	}
+
+	regulator_put(v_ldo);
+	v_ldo = NULL;
+}
+
+#ifdef CONFIG_RTC_DRV_SA1100
+static int sync_time_to_soc(unsigned int ticks)
+{
+	RCNR = ticks;
+	udelay(200);
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_MFD_88PM822)
+static struct pm822_usb_pdata pm822_usb = {
+	.vbus_gpio = PM822_NO_GPIO,
+	.id_gpadc = PM822_NO_GPADC,
+};
+
+static struct pm822_rtc_pdata pm822_rtc = {
+	.vrtc	= 1,
+#ifdef CONFIG_RTC_DRV_SA1100
+	.sync	= sync_time_to_soc,
+#endif
+};
+
+static struct pm822_platform_data pm805_info = {
+	.irq_mode = 0,
+	.plat_config = pm805_plat_config,
+};
+
+#ifdef CONFIG_SAMSUNG_JACK
+/* Samsung headset driver data KSND */
+static struct sec_jack_zone sec_jack_zones[] = {
+	{
+		/* adc == 0, default to 3pole if it stays
+		 * in this range for 40ms (20ms delays, 2 samples)
+		 */
+		.adc_high = 0,
+		.delay_ms = 20,
+		.check_count = 2,
+		.jack_type = SEC_HEADSET_3POLE,
+	},
+	{
+		/* 0 < adc <= 341, unstable zone, default to 3pole if it stays
+		 * in this range for a 100ms (20ms delays, 5 samples)
+		 */
+		.adc_high = 341,
+		.delay_ms = 20,
+		.check_count = 5,
+		.jack_type = SEC_HEADSET_3POLE,
+	},
+	{
+		/* 342 < adc <= 1000, unstable zone, default to 4pole if it
+		 * stays in this range for 40ms (20ms delays, 2 samples)
+		 */
+		.adc_high = 1000,
+		.delay_ms = 20,
+		.check_count = 2,
+		.jack_type = SEC_HEADSET_4POLE,
+	},
+	{
+		/* 1000 < adc <= 1399, default to 4 pole if it stays */
+		/* in this range for 100ms (20ms delays, 5 samples)
+		 */
+		.adc_high = 1399,
+		.delay_ms = 20,
+		.check_count = 5,
+		.jack_type = SEC_HEADSET_4POLE,
+	},
+	{
+		/* adc > 1680, unstable zone, default to 3pole if it stays
+		 * in this range for a second (10ms delays, 100 samples)
+		 */
+		.adc_high = 0x7fffffff,
+		.delay_ms = 10,
+		.check_count = 100,
+		.jack_type = SEC_HEADSET_3POLE,
+	},
+};
+
+/* to support 3-buttons earjack */
+static struct sec_jack_buttons_zone sec_jack_buttons_zones[] = {
+	{
+		/* 0 <= adc <=60, stable zone */
+		.code		= KEY_MEDIA,
+		.adc_low	= 0,
+		.adc_high	= 60,
+	},
+	{
+		/* 61 <= adc <= 120, stable zone */
+		.code		= KEY_VOLUMEUP,
+		.adc_low	= 61,
+		.adc_high	= 120,
+	},
+	{
+		/* 121 <= adc <= 280, stable zone */
+		.code		= KEY_VOLUMEDOWN,
+		.adc_low	= 121,
+		.adc_high	= 280,
+	},
+};
+
+static struct sec_jack_platform_data sec_jack_pdata = {
+	.headset_flag = 0,
+	.mic_set_power = mic_set_power,
+	.zones = sec_jack_zones,
+	.num_zones = ARRAY_SIZE(sec_jack_zones),
+	.buttons_zones = sec_jack_buttons_zones,
+	.num_buttons_zones = ARRAY_SIZE(sec_jack_buttons_zones),
+	.press_release_th = 320,
+};
+#else
+static struct pm822_headset_pdata pm822_headset = {
+	.headset_flag = 0,
+	.mic_set_power = mic_set_power,
+	.hook_press_th = 115,
+	.vol_up_press_th = 225,
+	.vol_down_press_th = 447,
+	.mic_det_th = 690,
+	.press_release_th = 450,
+};
+#endif
+
+static struct pm822_vibrator_pdata vibrator_pdata = {
+	.min_timeout = 10,
+};
+
+#if defined(CONFIG_FUELGAUGE_88PM822)
+struct pm822_bat_pdata pm822_bat = {
+};
+
+static struct sec_battery_platform_data sec_pm80x_bat = {
+	.capacity_max = 1000,
+	.capacity_min = 0,
+};
+#endif
+
+static struct pm822_platform_data pm822_pdata = {
+	.regulator		= pm822_regulator_data,
+	.power_page_addr	= 0x31,
+	.gpadc_page_addr	= 0x32,
+	.num_regulators		= ARRAY_SIZE(pm822_regulator_data),
+	.rtc			= &pm822_rtc,
+	.vibrator		= &vibrator_pdata,
+	.dvc			= &pm822_dvc,
+#if defined(CONFIG_FUELGAUGE_88PM822)
+#if defined(CONFIG_BATTERY_SAMSUNG)
+	.fuelgauge_data		= &sec_battery_pdata,
+#else
+	.bat			= &pm822_bat,
+#endif
+#endif
+	.usb			= &pm822_usb,
+#ifdef CONFIG_SAMSUNG_JACK
+	.headset		= &sec_jack_pdata,
+#else
+	.headset		= &pm822_headset,
+#endif
+	.plat_config		= pm822_plat_config,
+	.irq_flags		= IRQF_ONESHOT,
+	.batt_gp_nr		= PM822_GPADC2,
+};
+
+static void pm822_dvctable_init(void)
+{
+	unsigned int *vol_table;
+	/* dvc only support 4 lvl voltage*/
+	unsigned int vol_tbsize = 4;
+	unsigned int index, max_vl, lowest_rate;
+
+	vol_table = kmalloc(vol_tbsize * sizeof(unsigned int), GFP_KERNEL);
+	if (!vol_table) {
+		pr_err("%s failed to malloc vol table!\n", __func__);
+		return ;
+	}
+
+	max_vl = pxa988_get_vl_num();
+	max_vl = (max_vl > 4) ? 4 : max_vl;
+	for (index = 0; index < max_vl; index++)
+		vol_table[index] = pxa988_get_vl(index) * 1000;
+
+	lowest_rate = pxa988_get_vl(0);
+	while (index < 4)
+		vol_table[index++] = lowest_rate * 1000;
+
+	pm822_dvc.vol_val = vol_table;
+	pm822_dvc.size = vol_tbsize;
+	return ;
+}
+
+#elif defined(CONFIG_MFD_88PM800)
+static struct pm80x_usb_pdata pm80x_usb = {
+	.vbus_gpio = PM800_GPIO2,
+	.id_gpadc = PM800_NO_GPADC,
+};
+
+
+static struct pm80x_rtc_pdata pm80x_rtc = {
+	.vrtc	= 1,
+#ifdef CONFIG_RTC_DRV_SA1100
+	.sync	= sync_time_to_soc,
+#endif
+};
+
+static struct pm80x_dvc_pdata pm80x_dvc = {
+	.dvc1		= MFP_PIN_GPIO43,
+	.dvc2		= MFP_PIN_GPIO44,
+	.gpio_dvc	= 1,
+};
+
+static struct pm80x_bat_pdata pm80x_bat = {
+};
+
+static int pm800_plat_config(struct pm80x_chip *chip,
+				struct pm80x_platform_data *pdata)
+{
+	int data;
+	u8 i;
+	if (!chip || !pdata || !chip->regmap || !chip->subchip
+	    || !chip->subchip->regmap_power) {
+		pr_err("%s:chip or pdata is not availiable!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* RESET_OUTn, RTC_RESET_MODE =0 */
+	regmap_write(chip->regmap, PM800_RTC_MISC1, 0xb0);
+
+	/* Set internal digital sleep voltage as 1.2V */
+	regmap_write(chip->regmap, PM800_LOW_POWER1, 0x0);
+	/* Enable 32Khz-out-3 low jitter XO_LJ = 1 */
+	regmap_write(chip->regmap, PM800_LOW_POWER2, 0x20);
+
+	/* Enabele LDO and BUCK clock gating in lpm */
+	regmap_write(chip->regmap, PM800_LOW_POWER_CONFIG3, 0x80);
+	/* Enable reference group sleep mode */
+	regmap_write(chip->regmap, PM800_LOW_POWER_CONFIG4, 0x80);
+
+	/* Enable 32Khz-out-from XO 1, 2, 3 all enabled */
+	regmap_write(chip->regmap, PM800_RTC_MISC2, 0x2a);
+
+	/* Enable voltage change in pmic, POWER_HOLD = 1 */
+	regmap_write(chip->regmap, PM800_WAKEUP1, 0x80);
+
+	/*
+	 * Block wakeup attempts when VSYS rises above
+	 * VSYS_UNDER_RISE_TH1, or power off may fail
+	 */
+	regmap_read(chip->regmap,PM800_RTC_MISC5, &data);
+	data |= 0x1;
+	regmap_write(chip->regmap,PM800_RTC_MISC5, data);
+
+	/* Enable GPADC sleep mode */
+	regmap_write(chip->subchip->regmap_gpadc,
+		     PM800_GPADC_MISC_CONFIG2, 0x71);
+	/* Enlarge GPADC off slots */
+	regmap_write(chip->subchip->regmap_gpadc, 0x08, 0x0f);
+
+	/* Set buck1 sleep mode as 0.8V */
+	regmap_write(chip->subchip->regmap_power, PM800_SLEEP_BUCK1, 0x10);
+	/* Set buck1 audio mode as 0.8V and trun on LDO(7 or 18)*/
+	regmap_write(chip->subchip->regmap_power, PM800_AUDIO_MODE_CONFIG1,
+			0x90);
+	/* Enable buck sleep mode */
+	regmap_write(chip->subchip->regmap_power, PM800_BUCK_SLP1, 0xaa);
+	regmap_write(chip->subchip->regmap_power, PM800_BUCK_SLP2, 0x2);
+
+	/* Enable LDO sleep mode */
+	regmap_write(chip->subchip->regmap_power, PM800_LDO_SLP1, 0xa8);
+	regmap_write(chip->subchip->regmap_power, PM800_LDO_SLP2, 0xaa);
+	regmap_write(chip->subchip->regmap_power, PM800_LDO_SLP3, 0xab);
+
+	regmap_write(chip->subchip->regmap_power, PM800_LDO_SLP4, 0xaa);
+	regmap_write(chip->subchip->regmap_power, PM800_LDO_SLP5, 0xaa);
+
+	/*WIFI may power on in sleep mode, so set sleep voltage 3.3V*/
+	regmap_write(chip->subchip->regmap_power, PM800_LDO9, 0xff);
+
+#ifdef GPS_LDO_POWER
+	/*set LDO19 for GPS sleep voltage 1.8V*/
+	regmap_write(chip->subchip->regmap_power, PM800_LDO19, 0x11);
+#endif
+	/*
+	 * Set buck4 as 2Mhz
+	 *  base page:reg 0xd0.7 = 1
+	 *            reg 0x50 = 0xc0
+	 *            reg 0x52 OSC_DIV_SEL[3] = 1,
+	 *            reg 0x53 OSC_2X_EN[3] = 0
+	 * buck4 voltage will be set by CP
+	 */
+	regmap_read(chip->regmap, PM800_RTC_CONTROL, &data);
+	data |= (1 << 7);
+	regmap_write(chip->regmap, PM800_RTC_CONTROL, data);
+
+	/*
+	 * Base page 0x50 and 0x55 should be set to 0x0C to allow PMIC
+	 * Buck clock and digital clocks to be locked to the 32KHz clock,
+	 * but make sure USE_XO field (Bas page 0xD0.7) is previously set.
+	 *
+	 * Once you set 0x0C, if you read back you will read 0x0D, as the
+	 * LSB is a Read Only bit representing the ..ock.?fla which will
+	 * be set shortly after bit 1 of the same register is set to 0.
+	 */
+	data = 0x0C;
+	regmap_write(chip->regmap, OSC_CNTRL1, data);
+	regmap_write(chip->regmap, OSC_CNTRL6, data);
+
+	/* Forcing the clock of the bucks to be active also during sleep */
+	regmap_read(chip->regmap, OSC_CNTRL3, &data);
+	data |= (1 << 4) | (1 << 7);
+	regmap_write(chip->regmap, OSC_CNTRL3, data);
+
+	if (cpu_is_pxa988()) {
+		/* Set the 4 regs of buck4 as 1.8v */
+		regmap_write(chip->subchip->regmap_power,
+			     PM800_BUCK4, 0x54);
+		regmap_write(chip->subchip->regmap_power,
+			     PM800_BUCK4_1, 0x54);
+		regmap_write(chip->subchip->regmap_power,
+			     PM800_BUCK4_2, 0x54);
+		regmap_write(chip->subchip->regmap_power,
+			     PM800_BUCK4_3, 0x54);
+	}
+
+	if (cpu_is_pxa986()) {
+		/* Set the 4 regs of buck4 as 1.85v */
+		regmap_write(chip->subchip->regmap_power,
+			     PM800_BUCK4, 0x55);
+		regmap_write(chip->subchip->regmap_power,
+			     PM800_BUCK4_1, 0x55);
+		regmap_write(chip->subchip->regmap_power,
+			     PM800_BUCK4_2, 0x55);
+		regmap_write(chip->subchip->regmap_power,
+			     PM800_BUCK4_3, 0x55);
+	}
+
+	/*
+	 * Set ldo5 as 3.3V in active and sleep mode
+	 * for pxa986
+	 */
+	if (cpu_is_pxa986()) {
+		regmap_read(chip->subchip->regmap_power,
+			    PM800_LDO5, &data);
+		data |= 0xff;
+		regmap_write(chip->subchip->regmap_power,
+			     PM800_LDO5, data);
+	}
+
+	/* BUCK enable 0x50, BUCK1, 2, 3, 4 */
+	regmap_write(chip->subchip->regmap_power, 0x50, 0x0f);
+	/* LDO enable 0x51, 0x52, 0x53, LDO1, 3, 5, 7, 8 */
+	regmap_write(chip->subchip->regmap_power, 0x51, 0xD4);
+	regmap_write(chip->subchip->regmap_power, 0x52, 0x20);
+	regmap_write(chip->subchip->regmap_power, 0x53, 0x02);
+
+	/* Dump power-down log */
+	regmap_read(chip->regmap, PM800_POWER_DOWN_LOG1, &data);
+	pr_info("PowerDW Log1 0x%x: 0x%x\n", PM800_POWER_DOWN_LOG1, data);
+	regmap_read(chip->regmap, PM800_POWER_DOWN_LOG2, &data);
+	pr_info("PowerDW Log2 0x%x: 0x%x\n", PM800_POWER_DOWN_LOG2, data);
+	/* Clear power-down log */
+	regmap_write(chip->regmap, PM800_POWER_DOWN_LOG1, 0xff);
+	regmap_write(chip->regmap, PM800_POWER_DOWN_LOG2, 0xff);
+
+	if (dvc_flag) {
+		int num = pxa988_get_vl_num();
+		/* Write svc level values except level 0 */
+		for (i = num - 1; i > 0 ; i--) {
+			data = pm800_extern_write(PM80X_POWER_PAGE,
+				0x3c + i, (pxa988_get_vl(i) - 600) * 10 / 125);
+			if (data < 0) {
+				printk(KERN_ERR "SVC table writting failed !\n");
+				return -1;
+			}
+		}
+	}
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_SENSORS_ACCELOMETER_BMA25X)
+static void bma255_get_position(int *pos)
+{
+	*pos = BMA255_BOTTOM_UPPER_RIGHT;
+}
+static struct bma255_platform_data bma255_pdata = {
+	.get_pos = bma255_get_position,
+	.acc_int1 = mfp_to_gpio(GPIO010_ACC_INT),
+	//.acc_int2 = NULL,
+};
+static struct i2c_board_info i2c_accelerometer_bma255[] __initdata = {
+
+	{
+		I2C_BOARD_INFO("bma255-i2c", 0x18),
+		.platform_data = &bma255_pdata,
+	},
+};
+#endif //CONFIG_SENSORS_ACCELOMETER_BMA25X
+
+#if defined(CONFIG_SENSORS_GRIP_SX9500)
+#define RF_TOUCH_EN	mfp_to_gpio(GPIO033_EN_RF_TOUCH)
+#define COND_N		mfp_to_gpio(GPIO095_COND_N)
+
+static struct sx9500_platform_data sx9500_pdata = {
+	.gpio_en_rf_touch = RF_TOUCH_EN,
+	.gpio_cond_n = COND_N,
+};
+
+static struct i2c_board_info i2c_grip_sx9500[] __initdata = {
+	{
+		I2C_BOARD_INFO("sx9500-i2c", 0x28),
+		.irq = mfp_to_gpio(GPIO034_GRIP_INT),
+		.platform_data = &sx9500_pdata,
+	},
+};
+#endif //CONFIG_SENSORS_ACCELOMETER_BMA25X
+
+#if defined(CONFIG_SENSORS_ACCELOMETER_BMA25X) \
+ || defined(CONFIG_SENSORS_BMM050) \
+ || defined(CONFIG_SENSORS_GP2A002S) \
+ || defined(CONFIG_SENSORS_GP2A030) \
+ || defined(CONFIG_INPUT_MPU6500) \
+ || defined(CONFIG_SENSORS_GP2A_PROXIMITY)
+static struct i2c_gpio_platform_data i2c_gpio_data = {
+	.sda_pin		= mfp_to_gpio(GPIO036_GPIO_SENSOR_I2C_SDA),
+	.scl_pin		= mfp_to_gpio(GPIO035_GPIO_SENSOR_I2C_SCL),
+	.udelay			= 0,
+};
+static struct platform_device i2c_gpio_device = {
+	.name	= "i2c-gpio",
+	.id	= 5,
+	.dev	= {
+		.platform_data = &i2c_gpio_data,
+	},
+};
+#endif
+
+#if defined(CONFIG_NFC_PN547)
+static struct i2c_gpio_platform_data i2c_gpio_data_nfc = {
+	.sda_pin		= mfp_to_gpio(GPIO034_GPIO_34),
+	.scl_pin		= mfp_to_gpio(GPIO033_GPIO_33),
+	.udelay			= 2,
+	.timeout = 100,
+};
+static struct platform_device i2c_gpio_device_nfc = {
+	.name	= "i2c-gpio",
+	.id	= 9,
+	.dev	= {
+		.platform_data	= &i2c_gpio_data_nfc,
+	},
+};
+#endif
+
+static struct pxa_i2c_board_gpio emeidkb_pwr_i2c_gpio[] = {
+	{
+		.type = "88PM805",
+		.gpio = mfp_to_gpio(GPIO124_GPIO_124),
+	},
+};
+
+static struct i2c_board_info emeidkb_pwr_i2c_info[] = {
+#if defined(CONFIG_MFD_88PM822)
+	{
+		.type		= "88PM822",
+		.addr		= 0x30,
+		.irq		= IRQ_PXA988_PMIC,
+		.platform_data	= &pm822_pdata,
+	},
+	{
+		.type = "88PM805",
+		.addr = 0x38,
+		.platform_data = &pm805_info,
+	},
+#elif defined(CONFIG_MFD_88PM800)
+	{
+		.type		= "88PM800",
+		.addr		= 0x30,
+		.irq		= IRQ_PXA988_PMIC,
+		.platform_data	= &pm800_info,
+	},
+	{
+		.type = "88PM805",
+		.addr = 0x38,
+		.platform_data = &pm805_info,
+	},
+#elif defined(CONFIG_MFD_D2199)
+	{
+		// for D2199 PMIC driver
+		.type		= "d2199",
+		.addr		= D2199_PMIC_I2C_ADDR,
+		.platform_data = &d2199_pdata,
+		.irq = IRQ_PXA988_PMIC,
+	},
+#endif
+};
+
+static struct i2c_board_info emeidkb_pwr_i2c_info_rev00[] = {
+#if defined(CONFIG_MFD_88PM822)
+	{
+		.type		= "88PM822",
+		.addr		= 0x30,
+		.irq		= IRQ_PXA988_PMIC,
+		.platform_data	= &pm822_pdata,
+	},
+	{
+		.type = "88PM805",
+		.addr = 0x38,
+		.platform_data = &pm805_info,
+	},
+#elif defined(CONFIG_MFD_88PM800)
+	{
+		.type		= "88PM800",
+		.addr		= 0x30,
+		.irq		= IRQ_PXA988_PMIC,
+		.platform_data	= &pm800_info,
+	},
+	{
+		.type = "88PM805",
+		.addr = 0x38,
+		.platform_data = &pm805_info,
+	},
+#elif defined(CONFIG_MFD_D2199)
+	{
+		// for D2199 PMIC driver
+		.type		= "d2199",
+		.addr		= D2199_PMIC_I2C_ADDR,
+		.platform_data = &d2199_pdata_rev00,
+		.irq = IRQ_PXA988_PMIC,
+	},
+#endif
+};
+
+#if defined(CONFIG_SM5502_MUIC)
+static struct i2c_gpio_platform_data i2c_sm5502_bus_data = {
+	.sda_pin = mfp_to_gpio(GPIO050_GPIO_50),
+	.scl_pin = mfp_to_gpio(GPIO049_GPIO_49),
+	.udelay  = 3,
+	.timeout = 100,
+};
+
+static struct platform_device i2c_sm5502_bus_device = {
+	.name		= "i2c-gpio",
+	.id		= 7, /* pxa92x-i2c are bus 0, 1 so start at 2 */
+	.dev = {
+		.platform_data = &i2c_sm5502_bus_data,
+	}
+};
+static struct sm5502_platform_data sm5502_info = {
+	.charger_cb = sec_charger_cb,
+};
+static struct i2c_board_info __initdata sm5502_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("sm5502", 0x25),
+		.platform_data	= &sm5502_info,
+	},
+};
+static struct pxa_i2c_board_gpio sm5502_i2c_gpio[] = {
+	{
+		.type = "sm5502",
+		.gpio = mfp_to_gpio(GPIO093_GPIO_93),
+	},
+};
+#endif
+
+
+#if defined(CONFIG_BQ24157_CHARGER)
+static struct i2c_gpio_platform_data i2c_bq24157_bus_data = {
+	.sda_pin = mfp_to_gpio(GPIO017_GPIO_17),
+	.scl_pin = mfp_to_gpio(GPIO016_GPIO_16),
+	.udelay  = 3,
+	.timeout = 100,
+};
+
+static struct platform_device i2c_bq24157_bus_device = {
+	.name		= "i2c-gpio",
+	.id		= 8, /* pxa92x-i2c are bus 0, 1 so start at 2 */
+	.dev = {
+		.platform_data = &i2c_bq24157_bus_data,
+	}
+};
+
+static struct bq24157_platform_data  bq24157_charger_info = {
+	.cd = mfp_to_gpio(GPIO098_GPIO_98),
+};
+
+static struct i2c_board_info __initdata bq24157_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("bq24157_6A", 0x6A),
+		.platform_data	= &bq24157_charger_info,
+	},
+};
+
+static struct pxa_i2c_board_gpio bq24157_i2c_gpio[] = {
+	{
+		.type = "bq24157_6A",
+		.gpio = mfp_to_gpio(GPIO008_GPIO_8),
+	},
+};
+#endif
+
+#if defined(CONFIG_I2C_RT9455)
+#define RT9455_INT_PIN (81)
+static void rt9455_general_callback(int event)
+{
+	pr_info("%s: general_callback event value = %02x\n", __func__, event);
+}
+
+static void rt9455_charger_callback(int event)
+{
+	pr_info("%s: charger_callback event value = %02x\n", __func__, event);
+}
+
+static void rt9455_boost_callback(int event)
+{
+	pr_info("%s: boost_callback event value = %02x\n", __func__, event);
+}
+
+static void rt9455_reset_callback(int event)
+{
+	RT_DBG("%s: reset_callback event value = %02x\n", __func__, event);
+	// Eventlist
+	// 0x80 RT9455_EVENT_BEFORE_RST
+	// 0x40 RT9455_EVENT_AFTER_RST
+}
+
+static struct rt9455_platform_data rt9455_platform_data = {
+	.intr_gpio = RT9455_INT_PIN,
+	// Default we dont't mask any thing
+	// If you change the default value, please also set write_irq_mask flag
+	// to 1, in the driver, it will write the irq_mask to chip register.
+	.write_irq_mask = 1,
+	.irq_mask = {
+		.mask1 = {
+			.bitfield = {
+				.BATABM = 0,
+				.VINOVPIM = 0,
+				.TSDM = 0,
+			},
+		},
+		.mask2 = {
+			.bitfield = {
+				.CHDPMIM = 1,
+				.CHTREGIM = 0,
+				.CH32MIM = 0,
+				.CHRCHGIM = 0,
+				.CHTERMIM = 0,
+				.CHBATOVIM = 0,
+				.CHRVPIM = 0,
+			},
+		},
+		.mask3 = {
+			.bitfield = {
+				.BST32SIM = 0,
+				.BSTLOWVIM = 0,
+				.BSTOLIM = 0,
+				.BSTVIMOVIM = 0,
+			},
+		},
+	},
+	// Below the default control register value
+	// If you change the default value, please also set write_init_ctrlval flag
+	// to 1, in driver it will write the init_ctrlval to chip register.
+	.write_init_ctrlval = 1,
+	.init_ctrlval = {
+		.ctrl2 = {
+			.bitfield = {
+				.OPA_MODE = OPA_CHARGER_MODE,
+				.HZ_BIT = 0,
+				.IAICR_INT = IAICR_INTERNAL,
+				.TE = 1,
+				.HIGH_OCP = OCP_2P5A,
+				.SEL_SWFREQ = SEL_FREQ_1P5MHz,
+				.IAICR = IAICR_LIMIT_1A,
+			},
+		},
+		.ctrl3 = {
+			.bitfield = {
+				.OTG_EN = 0,
+				.OTG_PL = OTGPL_ACTIVE_HIGH,
+				.VOREG = 0x2A,
+			},
+		},
+		.ctrl5 = {
+			.bitfield = {
+				.IEOC = IEOC_20P,
+				.IPREC = IPREC_60MA,
+				.VDPM = VDPM_4P5V,
+				.TMR_EN = 0,
+			},
+		},
+		.ctrl6 = {
+			.bitfield = {
+				.VPREC = VPREC_2P4V,
+				.ICHRG = ICHRG_20MV,
+			},
+		},
+		.ctrl7 = {
+			.bitfield = {
+				.VMREG = 0x0f,
+				.CHG_EN = 1,
+				.BATD_EN = 0,
+			},
+		},
+	},
+	.callbacks = {
+		.boost_callback = rt9455_boost_callback,
+		.charger_callback = rt9455_charger_callback,
+		.general_callback = rt9455_general_callback,
+		.reset_callback = rt9455_reset_callback,
+	},
+};
+
+static struct i2c_gpio_platform_data i2c_rt9455_bus_data = {
+	.sda_pin = mfp_to_gpio(GPIO017_GPIO_17),
+	.scl_pin = mfp_to_gpio(GPIO016_GPIO_16),
+	.udelay  = 3,
+	.timeout = 100,
+};
+
+static struct platform_device i2c_rt9455_bus_device = {
+	.name		= "i2c-gpio",
+	.id		= 8, /* pxa92x-i2c are bus 0, 1 so start at 2 */
+	.dev = {
+		.platform_data = &i2c_rt9455_bus_data,
+	}
+};
+
+static struct i2c_board_info __initdata rt9455_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO(RT9455_DEVICE_NAME, 0x22),
+		.platform_data	= &rt9455_platform_data,
+	},
+};
+
+static struct pxa_i2c_board_gpio rt9455_i2c_gpio[] = {
+	{
+		.type = RT9455_DEVICE_NAME,
+		.gpio = mfp_to_gpio(GPIO008_GPIO_8),
+	},
+};
+
+#endif /* CONFIG_I2C_RT9455 */
+
+
+#if defined(CONFIG_MFD_RT8973)
+static void muic_usb_cb(uint8_t attached)
+{
+	if (attached) {
+		pxa_usb_notify(PXA_USB_DEV_OTG, EVENT_VBUS, 0);
+	} else {
+		pxa_usb_notify(PXA_USB_DEV_OTG, EVENT_VBUS, 0);
+	}
+}
+
+static void muic_jig_cb(jig_type_t jig_type, int8_t attached)
+{
+	int usb_on = 0;
+	switch (jig_type) {
+	case JIG_UART_BOOT_OFF:
+		printk(KERN_INFO "JIG BOOT OFF UART\n");
+	break;
+	case JIG_USB_BOOT_OFF:
+		usb_on = 1;
+		printk(KERN_INFO "JIG BOOT OFF USB\n");
+	break;
+	case JIG_UART_BOOT_ON:
+		printk(KERN_INFO "JIG BOOT ON UART\n");
+	break;
+	case JIG_USB_BOOT_ON:
+		usb_on = 1;
+		printk(KERN_INFO "JIG BOOT ON USB\n");
+	break;
+	default:
+	;
+	}
+	if (attached) {
+		if (usb_on)
+			pxa_usb_notify(PXA_USB_DEV_OTG, EVENT_VBUS, 0);
+	} else {
+		if (usb_on)
+			pxa_usb_notify(PXA_USB_DEV_OTG, EVENT_VBUS, 0);
+	}
+}
+
+static struct rt8973_platform_data  rt8973_pdata = {
+	.irq_gpio = NULL,
+	.cable_chg_callback = NULL,
+	.usb_callback = NULL,
+	.ocp_callback = NULL,
+	.otp_callback = NULL,
+	.ovp_callback = NULL,
+	.usb_callback = muic_usb_cb,
+	.uart_callback = NULL,
+	.otg_callback = NULL,
+	.jig_callback = NULL,
+
+};
+
+static struct i2c_board_info rtmuic_i2c_boardinfo[] __initdata = {
+
+	{
+		I2C_BOARD_INFO("rt8973", 0x28>>1),
+		.platform_data = &rt8973_pdata,
+	},
+
+};
+
+
+static struct i2c_gpio_platform_data i2c_rt8973_bus_data = {
+        .sda_pin = mfp_to_gpio(GPIO050_GPIO_50),
+        .scl_pin = mfp_to_gpio(GPIO049_GPIO_49),
+        .udelay  = 3,
+        .timeout = 100,
+};
+
+
+static struct platform_device i2c_rt8973_bus_device = {
+        .name           = "i2c-gpio",
+        .id             = 7, /* pxa92x-i2c are bus 0, 1 so start at 2 */
+        .dev = {
+                .platform_data = &i2c_rt8973_bus_data,
+        }
+};
+
+
+static struct i2c_board_info __initdata rt8973_i2c_devices[] = {
+        {
+                I2C_BOARD_INFO("rt8973", 0x28>>1),
+                .platform_data  = &rt8973_pdata,
+                .irq = MMP_GPIO_TO_IRQ(mfp_to_gpio(GPIO093_GPIO_93)),
+        },
+};
+#endif
+
+
+
+
+#if defined(CONFIG_STC3115_FUELGAUGE)
+static struct stc311x_platform_data stc3115_platform_data = {
+        .battery_online = NULL,
+        .charger_online = NULL,		// used in stc311x_get_status()
+        .charger_enable = NULL,		// used in stc311x_get_status()
+        .power_supply_register = NULL,
+        .power_supply_unregister = NULL,
+		.Vmode= 0,       /*REG_MODE, BIT_VMODE 1=Voltage mode, 0=mixed mode */
+		.Alm_SOC = 10,      /* SOC alm level %*/
+		.Alm_Vbat = 3600,   /* Vbat alm level mV*/
+  		.CC_cnf = 400,      /* nominal CC_cnf, coming from battery characterisation*/
+  		.VM_cnf = 405,      /* nominal VM cnf , coming from battery characterisation*/
+  		.Cnom = 2000,       /* nominal capacity in mAh, coming from battery characterisation*/
+		.Rsense = 10,       /* sense resistor mOhms*/
+  		.RelaxCurrent = 100, /* current for relaxation in mA (< C/20) */
+		.Adaptive = 1,     /* 1=Adaptive mode enabled, 0=Adaptive mode disabled */
+
+		.CapDerating[6] = 190,   /* capacity derating in 0.1%, for temp = -20C */
+  		.CapDerating[5] = 70,   /* capacity derating in 0.1%, for temp = -10C */
+		.CapDerating[4] = 30,   /* capacity derating in 0.1%, for temp = 0C */
+		.CapDerating[3] = 0,   /* capacity derating in 0.1%, for temp = 10C */
+		.CapDerating[2] = 0,   /* capacity derating in 0.1%, for temp = 25C */
+		.CapDerating[1] = -20,   /* capacity derating in 0.1%, for temp = 40C */
+		.CapDerating[0] = -40,   /* capacity derating in 0.1%, for temp = 60C */
+
+  		.OCVOffset[15] = -123,    /* OCV curve adjustment */
+		.OCVOffset[14] = -30,   /* OCV curve adjustment */
+		.OCVOffset[13] = -12,    /* OCV curve adjustment */
+		.OCVOffset[12] = -27,    /* OCV curve adjustment */
+		.OCVOffset[11] = 0,    /* OCV curve adjustment */
+		.OCVOffset[10] = -27,    /* OCV curve adjustment */
+		.OCVOffset[9] = 4,     /* OCV curve adjustment */
+		.OCVOffset[8] = 1,      /* OCV curve adjustment */
+		.OCVOffset[7] = 7,      /* OCV curve adjustment */
+		.OCVOffset[6] = 9,    /* OCV curve adjustment */
+		.OCVOffset[5] = 9,    /* OCV curve adjustment */
+		.OCVOffset[4] = 16,     /* OCV curve adjustment */
+		.OCVOffset[3] = 33,    /* OCV curve adjustment */
+		.OCVOffset[2] = 34,     /* OCV curve adjustment */
+		.OCVOffset[1] = 46,    /* OCV curve adjustment */
+		.OCVOffset[0] = -3,     /* OCV curve adjustment */
+
+		 .OCVOffset2[15] = -109,    /* OCV curve adjustment */
+		.OCVOffset2[14] = -86,   /* OCV curve adjustment */
+		.OCVOffset2[13] = -59,    /* OCV curve adjustment */
+		.OCVOffset2[12] = -59,    /* OCV curve adjustment */
+		.OCVOffset2[11] = -29,    /* OCV curve adjustment */
+		.OCVOffset2[10] = -46,    /* OCV curve adjustment */
+		.OCVOffset2[9] = -8,     /* OCV curve adjustment */
+		.OCVOffset2[8] = 0,      /* OCV curve adjustment */
+		.OCVOffset2[7] = -2,      /* OCV curve adjustment */
+		.OCVOffset2[6] = -6,    /* OCV curve adjustment */
+		.OCVOffset2[5] = -7,    /* OCV curve adjustment */
+		.OCVOffset2[4] = -9,     /* OCV curve adjustment */
+		.OCVOffset2[3] = 19,    /* OCV curve adjustment */
+		.OCVOffset2[2] = 44,     /* OCV curve adjustment */
+		.OCVOffset2[1] = 81,    /* OCV curve adjustment */
+		.OCVOffset2[0] = 0,     /* OCV curve adjustment */
+		/*if the application temperature data is preferred than the STC3115 temperature*/
+		.ExternalTemperature = NULL, /*External temperature fonction, return C*/
+		.ForceExternalTemperature = 0, /* 1=External temperature, 0=STC3115 temperature */
+};
+static struct i2c_gpio_platform_data i2c_stc3115_bus_data = {
+      .sda_pin = mfp_to_gpio(MFP_PIN_GPIO88),
+	  .scl_pin = mfp_to_gpio(MFP_PIN_GPIO87),
+	  .udelay  = 3,  //// brian :3
+	  .timeout = 100,
+};
+static struct platform_device i2c_stc3115_bus_device = {
+	.name	= "i2c-gpio",
+	.id		= 6,
+	.dev		= {
+		.platform_data = &i2c_stc3115_bus_data,
+	}
+};
+static struct i2c_board_info __initdata stc3115_i2c_devices[] = {
+	{
+		.type		= "stc3115_fuelgauge",
+		.addr		= 0x70,
+		.platform_data = &stc3115_platform_data,
+	},
+};
+static struct pxa_i2c_board_gpio stc3115_i2c_gpio[] = {
+	{
+		.type = "stc3115_fuelgauge",
+		.gpio = mfp_to_gpio(GPIO095_GPIO_95),
+	},
+};
+#endif
+
+#if defined(CONFIG_SPA)
+static struct spa_platform_data spa_info = {
+	.use_fuelgauge = 1,
+	.battery_capacity = 1650,
+	.VF_low	= 50,
+	.VF_high = 600,
+};
+static struct platform_device Sec_BattMonitor = {
+	.name		= "Sec_BattMonitor",
+	.id		= -1,
+	.dev		= {
+		.platform_data = &spa_info,
+	},
+};
+#endif
+static struct i2c_board_info emeidkb_i2c_info[] = {
+};
+
+#ifdef CONFIG_PN547_NFC
+static struct pn544_i2c_platform_data pn547_pdata = {
+//	.conf_gpio = pn544_conf_gpio,
+	.irq_gpio = mfp_to_gpio(GPIO091_GPIO_NFC_IRQ),
+	.ven_gpio = mfp_to_gpio(GPIO126_GPIO_NFC_EN),
+	.firm_gpio = mfp_to_gpio(GPIO127_GPIO_NFC_FIRMWARE),
+};
+#endif
+static struct i2c_board_info emeidkb_i2c2_info[] = {
+#ifdef CONFIG_PN547_NFC
+	{
+		I2C_BOARD_INFO("pn547", 0x2b),
+		.irq = MMP_GPIO_TO_IRQ(mfp_to_gpio(GPIO091_GPIO_NFC_IRQ)),
+		.platform_data = &pn547_pdata,
+	},
+#endif
+#if defined(CONFIG_QUICKLOGIC_BRIDGE)
+	{
+		I2C_BOARD_INFO("QuickBridge", 0x64),
+		.platform_data = "QuickBridge",
+	},
+#endif
+};
+
+#if defined(CONFIG_NFC_PN547)
+static struct pn547_i2c_platform_data pn547_pdata = {
+	.irq_gpio = mfp_to_gpio(GPIO091_GPIO_91),
+	.ven_gpio = mfp_to_gpio(GPIO126_GPIO_126),
+	.firm_gpio = mfp_to_gpio(GPIO127_GPIO_127),
+};
+
+static struct i2c_board_info i2c_pn547={
+	I2C_BOARD_INFO("pn547", 0x2b),
+	.irq = MMP_GPIO_TO_IRQ(mfp_to_gpio(GPIO091_GPIO_NFC_IRQ)),
+	.platform_data = &pn547_pdata,
+};
+#endif
+
+/*
+ * workaround for reset i2c bus
+ * i2c0: GPIO53 -> SCL, GPIO54 -> SDA,
+ * i2c1: GPIO87 -> SCL, GPIO88 -> SDA,
+ */
+static void i2c_pxa_bus_reset(int i2c_adap_id)
+{
+	unsigned long mfp_pin[2];
+	int ccnt;
+	unsigned long scl, sda;
+
+	unsigned long i2c0_mfps[] = {
+		GPIO053_CAM_SCL,		/* SCL */
+		GPIO054_CAM_SDA,		/* SDA */
+	};
+
+	unsigned long i2c1_mfps[] = {
+		GPIO087_GPIO_87,		/* SCL */
+		GPIO088_GPIO_88,		/* SDA */
+	};
+	if (i2c_adap_id == 0) {
+		scl = MFP_PIN_GPIO53;
+		sda = MFP_PIN_GPIO54;
+	} else if (i2c_adap_id == 1) {
+		scl = MFP_PIN_GPIO87;
+		sda = MFP_PIN_GPIO88;
+	} else {
+		pr_err("i2c bus num error!\n");
+		return;
+	}
+	if (gpio_request(scl, "SCL")) {
+		pr_err("Failed to request GPIO for SCL pin!\n");
+		goto out0;
+	}
+	if (gpio_request(sda, "SDA")) {
+		pr_err("Failed to request GPIO for SDA pin!\n");
+		goto out_sda0;
+	}
+	/* set mfp pins to gpios */
+	mfp_pin[0] = mfp_read(scl);
+	mfp_pin[1] = mfp_read(sda);
+	if (i2c_adap_id == 0)
+		mfp_config(ARRAY_AND_SIZE(i2c0_mfps));
+	if (i2c_adap_id == 1)
+		mfp_config(ARRAY_AND_SIZE(i2c1_mfps));
+
+	gpio_direction_input(sda);
+	for (ccnt = 20; ccnt; ccnt--) {
+		gpio_direction_output(scl, ccnt & 0x01);
+		udelay(4);
+	}
+	gpio_direction_output(scl, 0);
+	udelay(4);
+	gpio_direction_output(sda, 0);
+	udelay(4);
+	/* stop signal */
+	gpio_direction_output(scl, 1);
+	udelay(4);
+	gpio_direction_output(sda, 1);
+	udelay(4);
+	if (i2c_adap_id == 0) {
+		mfp_write(MFP_PIN_GPIO53, mfp_pin[0]);
+		mfp_write(MFP_PIN_GPIO54, mfp_pin[1]);
+	}
+	if (i2c_adap_id == 1) {
+		mfp_write(MFP_PIN_GPIO87, mfp_pin[0]);
+		mfp_write(MFP_PIN_GPIO88, mfp_pin[1]);
+	}
+	gpio_free(sda);
+out_sda0:
+	gpio_free(scl);
+out0:
+	return;
+}
+// for TSP i2c operation (switch gpio or hw i2c func)
+void i2c1_pin_changed(int gpio)
+{
+	unsigned long i2c1_g_mfps[] = {
+		GPIO087_GPIO_87,		/* SCL */
+		GPIO088_GPIO_88,		/* SDA */
+	};
+
+	unsigned long i2c1_hw_mfps[] = {
+		GPIO087_CI2C_SCL_2,		/* SCL */
+		GPIO088_CI2C_SDA_2,		/* SDA */
+	};
+	usleep_range(8000, 10000);
+	if(gpio)
+		mfp_config(ARRAY_AND_SIZE(i2c1_g_mfps));
+	else
+		mfp_config(ARRAY_AND_SIZE(i2c1_hw_mfps));
+	usleep_range(8000, 10000);
+
+	return;
+}
+
+static struct i2c_pxa_platform_data emeidkb_ci2c_pdata = {
+	.fast_mode		 = 1,
+	/* ilcr:fs mode b17~9=0x23,about 390K, standard mode b8~0=0x9f,97K */
+	.ilcr		= 0x082C469F,
+	/* iwcr:b5~0=b01010 recommended value according to spec*/
+	.iwcr		= 0x0000142A,
+	.i2c_bus_reset		= i2c_pxa_bus_reset,
+};
+
+static struct i2c_pxa_platform_data emeidkb_ci2c2_pdata = {
+	.fast_mode		 = 1,
+	/* ilcr:fs mode b17~9=0x23,about 390K, standard mode b8~0=0x9f,97K */
+	.ilcr		= 0x082C469F,
+	/* iwcr:b5~0=b01010 recommended value according to spec*/
+	.iwcr		= 0x0000142A,
+	.i2c_bus_reset		= i2c_pxa_bus_reset,
+};
+
+static struct i2c_pxa_platform_data emeidkb_pwr_i2c_pdata = {
+	.fast_mode		 = 1,
+	/* ilcr:fs mode b17~9=0x23,about 390K, standard mode b8~0=0x9f,97K */
+	.ilcr		= 0x082C469F,
+	/* iwcr:b5~0=b01010 recommended value according to spec*/
+	.iwcr		= 0x0000142A,
+	.hardware_lock		= pxa988_ripc_lock,
+	.hardware_unlock	= pxa988_ripc_unlock,
+	.hardware_trylock	= pxa988_ripc_trylock,
+};
+
+static DEFINE_SPINLOCK(bl_lock);
+
+#if defined(CONFIG_BACKLIGHT_KTD253)
+static struct platform_device ktd253_device  = {
+	.name	= "panel",
+};
+#endif
+
+#ifdef CONFIG_USB_MV_UDC
+static char *pxa988_usb_clock_name[] = {
+	[0] = "UDCCLK",
+};
+
+static struct mv_usb_platform_data emeidkb_usb_pdata = {
+	.clknum		= 1,
+	.clkname	= pxa988_usb_clock_name,
+	.id		= PXA_USB_DEV_OTG,
+	.extern_attr	= MV_USB_HAS_VBUS_DETECTION,
+	.mode		= MV_USB_MODE_DEVICE,
+	.phy_init	= pxa_usb_phy_init,
+	.phy_deinit	= pxa_usb_phy_deinit,
+};
+#endif /* CONFIG_USB_MV_UDC */
+
+#ifdef CONFIG_MMC_SDHCI_PXAV3
+#define MFP_WIB_PDn		(GPIO051_GPIO_51 | MFP_PULL_FLOAT)
+#define MFP_WIB_RESETn		(GPIO095_GPIO_95 | MFP_PULL_FLOAT)
+
+static void emeidkb_sdcard_signal(unsigned int set)
+{
+	int vol = set;
+
+	pxa988_aib_mmc1_iodomain(vol);
+}
+
+static struct wakeup_source wlan_dat1_wakeup;
+static struct work_struct wlan_wk;
+
+static void wlan_edge_wakeup(struct work_struct *work)
+{
+	/*
+	 * it is handled in SDIO driver instead, so code not need now
+	 * but temparally keep the code here,it may be used for debug
+	 */
+#if 0
+	unsigned int sec = 3;
+
+	/*
+	 * Why use a workqueue to call this function?
+	 *
+	 * As now dat1_edge_wakeup is called just after CPU exist LPM,
+	 * and if __pm_wakeup_event is called before syscore_resume,
+	 * WARN_ON(timekeeping_suspended) will happen in ktime_get in
+	 * /kernel/time/timekeeping.c
+	 *
+	 * So we create a workqueue to fix this issue
+	 */
+	__pm_wakeup_event(&wlan_dat1_wakeup, 1000 * sec);
+	printk(KERN_INFO "SDIO wake up+++\n");
+#endif
+}
+
+static void dat1_edge_wakeup(int irq, void *pRsv)
+{
+	queue_work(system_wq, &wlan_wk);
+}
+
+static struct gpio_edge_desc gpio_edge_sdio_dat1 = {
+	.mfp = MFP_PIN_GPIO39,
+	.gpio = mfp_to_gpio(MFP_PIN_GPIO39),
+	/*
+	 * SDIO Spec difine falling as SDIO interrupt, but set BOTH edge
+	 * should be more safe to wake up.
+	 */
+	.type = MFP_LPM_EDGE_BOTH,
+	.handler = dat1_edge_wakeup,
+};
+
+static void wlan_wakeup_init(void)
+{
+	 INIT_WORK(&wlan_wk, wlan_edge_wakeup);
+	 wakeup_source_init(&wlan_dat1_wakeup,
+		"wifi_hs_wakeups");
+}
+
+#ifdef CONFIG_SD8XXX_RFKILL
+static void emeidkb_8787_set_power(unsigned int on)
+{
+	static struct regulator *wib_3v3;
+	static int enabled;
+	unsigned char data;
+
+
+	if (!wib_3v3) {
+		wib_3v3 = regulator_get(NULL, "v_wib_3v3");
+		if (IS_ERR(wib_3v3)) {
+			wib_3v3 = NULL;
+			printk(KERN_ERR "get v_wib_3v3 failed %s %d\n",
+				__func__, __LINE__);
+			return;
+		}
+	}
+
+	if (on && !enabled) {
+		regulator_set_voltage(wib_3v3, 3300000, 3300000);
+		regulator_enable(wib_3v3);
+		enabled = 1;
+
+		/* Only when SD8787 are active (power on),
+		 * it is meanful to enable the edge wakeup
+		 */
+		mmp_gpio_edge_add(&gpio_edge_sdio_dat1);
+
+		/*disable buck2 sleep mode when wifi power on*/
+#if !defined(CONFIG_MFD_D2199_BRINGUP_RECHECK) //DLG
+#if defined(CONFIG_MFD_88PM822)
+		pm822_extern_setbits(PM822_POWER_PAGE, PM822_BUCK_SLP1,
+					PM822_BUCK2_SLP1_MASK, PM822_BUCK2_SLP1_MASK);
+#else
+		pm800_extern_setbits(PM80X_POWER_PAGE, PM800_BUCK_SLP1,
+					PM800_BUCK2_SLP1_MASK, PM800_BUCK2_SLP1_MASK);
+#endif
+#endif
+	}
+
+	if (!on && enabled) {
+		regulator_disable(wib_3v3);
+		enabled = 0;
+
+		mmp_gpio_edge_del(&gpio_edge_sdio_dat1);
+
+		/*enable buck2 sleep mode when wifi power off*/
+#if !defined(CONFIG_MFD_D2199_BRINGUP_RECHECK) //DLG
+#if defined(CONFIG_MFD_88PM822)
+		pm822_extern_setbits(PM822_POWER_PAGE, PM822_BUCK_SLP1,
+					PM822_BUCK2_SLP1_MASK, PM822_BUCK2_SLP1_UNMASK);
+#else
+		pm800_extern_setbits(PM80X_POWER_PAGE, PM800_BUCK_SLP1,
+					PM800_BUCK2_SLP1_MASK, PM800_BUCK2_SLP1_UNMASK);
+#endif
+#endif
+	}
+}
+#endif
+
+static struct sdhci_pxa_dtr_data sd_dtr_data[] = {
+	{
+		.timing		= MMC_TIMING_LEGACY, /* < 25MHz */
+		.preset_rate	= PXA_SDH_DTR_26M,
+		.src_rate	= PXA_SDH_DTR_52M,
+	},
+	{
+		.timing		= MMC_TIMING_UHS_SDR12, /* 25MHz */
+		.preset_rate	= PXA_SDH_DTR_26M,
+		.src_rate	= PXA_SDH_DTR_104M,
+	},
+	{
+		.timing		= MMC_TIMING_UHS_SDR25, /* 50MHz */
+		.preset_rate	= PXA_SDH_DTR_52M,
+		.src_rate	= PXA_SDH_DTR_104M,
+	},
+	{
+		.timing		= MMC_TIMING_SD_HS, /* 50MHz */
+		.preset_rate	= PXA_SDH_DTR_52M,
+		.src_rate	= PXA_SDH_DTR_104M,
+	},
+	{
+		.timing		= MMC_TIMING_UHS_DDR50, /* 50MHz */
+		.preset_rate	= PXA_SDH_DTR_52M,
+		.src_rate	= PXA_SDH_DTR_104M,
+	},
+	{
+		.timing		= MMC_TIMING_UHS_SDR50, /* 100MHz */
+		.preset_rate	= PXA_SDH_DTR_104M,
+		.src_rate	= PXA_SDH_DTR_208M,
+	},
+	{
+		.timing		= MMC_TIMING_UHS_SDR104, /* 208MHz */
+		.preset_rate	= PXA_SDH_DTR_208M,
+		.src_rate	= PXA_SDH_DTR_416M,
+	},
+		/*
+		 * end of sdhc dtr table
+		 * set as the default src rate
+		 */
+	{
+		.timing		= MMC_TIMING_MAX,
+		.preset_rate	= PXA_SDH_DTR_PS_NONE,
+		.src_rate	= PXA_SDH_DTR_208M,
+	},
+};
+
+static struct sdhci_pxa_dtr_data sdio_dtr_data[] = {
+	{
+		.timing		= MMC_TIMING_LEGACY, /* < 25MHz */
+		.preset_rate	= PXA_SDH_DTR_26M,
+		.src_rate	= PXA_SDH_DTR_52M,
+	},
+	{
+		.timing		= MMC_TIMING_UHS_SDR12, /* 25MHz */
+		.preset_rate	= PXA_SDH_DTR_26M,
+		.src_rate	= PXA_SDH_DTR_104M,
+	},
+	{
+		.timing		= MMC_TIMING_UHS_SDR25, /* 50MHz */
+		.preset_rate	= PXA_SDH_DTR_52M,
+		.src_rate	= PXA_SDH_DTR_104M,
+	},
+	{
+		.timing		= MMC_TIMING_SD_HS, /* 50MHz */
+		.preset_rate	= PXA_SDH_DTR_45M,
+		.src_rate	= PXA_SDH_DTR_89M,
+	},
+	{
+		.timing		= MMC_TIMING_UHS_DDR50, /* 50MHz */
+		.preset_rate	= PXA_SDH_DTR_52M,
+		.src_rate	= PXA_SDH_DTR_104M,
+	},
+	{
+		.timing		= MMC_TIMING_UHS_SDR50, /* 100MHz */
+		.preset_rate	= PXA_SDH_DTR_104M,
+		.src_rate	= PXA_SDH_DTR_208M,
+	},
+	{
+		.timing		= MMC_TIMING_UHS_SDR104, /* 208MHz */
+		.preset_rate	= PXA_SDH_DTR_208M,
+		.src_rate	= PXA_SDH_DTR_416M,
+	},
+	{
+		.timing		= MMC_TIMING_MAX,
+		.preset_rate	= PXA_SDH_DTR_PS_NONE,
+		.src_rate	= PXA_SDH_DTR_89M,
+	},
+};
+static struct sdhci_pxa_dtr_data emmc_dtr_data[] = {
+	{
+		.timing		= MMC_TIMING_LEGACY, /* < 25MHz */
+		.preset_rate	= PXA_SDH_DTR_26M,
+		.src_rate	= PXA_SDH_DTR_52M,
+	},
+	{
+		.timing		= MMC_TIMING_MMC_HS, /* 50MHz */
+		.preset_rate	= PXA_SDH_DTR_52M,
+		.src_rate	= PXA_SDH_DTR_104M,
+	},
+	{
+		.timing		= MMC_TIMING_UHS_DDR50, /* 50MHz */
+		.preset_rate	= PXA_SDH_DTR_52M,
+		.src_rate	= PXA_SDH_DTR_104M,
+	},
+	{
+		.timing		= MMC_TIMING_MMC_HS200, /* 208MHz */
+		.preset_rate	= PXA_SDH_DTR_156M,
+		.src_rate	= PXA_SDH_DTR_156M,
+	},
+	{
+		.timing		= MMC_TIMING_MAX,
+		.preset_rate	= PXA_SDH_DTR_PS_NONE,
+		.src_rate	= PXA_SDH_DTR_208M,
+	},
+};
+
+
+
+/* For emeiDKB, MMC1(SDH1) used for SD/MMC Card slot */
+static struct sdhci_pxa_platdata pxa988_sdh_platdata_mmc1 = {
+	.flags		= PXA_FLAG_ENABLE_CLOCK_GATING,
+	.cd_type         = PXA_SDHCI_CD_GPIO,
+	.clk_delay_cycles	= 0x0,
+	.host_caps_disable	= MMC_CAP_UHS_SDR12
+					|MMC_CAP_UHS_SDR25
+					|MMC_CAP_UHS_SDR50
+					|MMC_CAP_UHS_DDR50
+					|MMC_CAP_UHS_SDR104,
+	.host_caps2	= MMC_CAP2_DETECT_ON_ERR,
+	.quirks			= SDHCI_QUIRK_INVERTED_WRITE_PROTECT,
+	.signal_vol_change	= emeidkb_sdcard_signal,
+#if defined(CONFIG_GOYA_BD_00)
+	.ext_cd_gpio         = mfp_to_gpio(MFP_PIN_GPIO16),
+#else
+	.ext_cd_gpio         = mfp_to_gpio(MFP_PIN_GPIO11),
+#endif
+	.ext_cd_gpio_invert =1,
+	.dtr_data		= sd_dtr_data,
+};
+
+/* For emeiDKB, MMC2(SDH2) used for WIB card */
+static struct sdhci_pxa_platdata pxa988_sdh_platdata_mmc2 = {
+	.flags          = PXA_FLAG_WAKEUP_HOST
+				| PXA_FLAG_EN_PM_RUNTIME
+				| PXA_FLAG_DISABLE_PROBE_CDSCAN,
+	.cd_type	 = PXA_SDHCI_CD_EXTERNAL,
+	.quirks2	= SDHCI_QUIRK2_HOLDSUSPEND_AFTER_REQUEST,
+	.pm_caps	= MMC_PM_KEEP_POWER,
+	.dtr_data	= sdio_dtr_data,
+};
+
+/* For emeiDKB, MMC3(SDH3) used for eMMC */
+static struct sdhci_pxa_platdata pxa988_sdh_platdata_mmc3 = {
+	.flags		= PXA_FLAG_ENABLE_CLOCK_GATING
+				| PXA_FLAG_SD_8_BIT_CAPABLE_SLOT
+				| PXA_FLAG_EN_PM_RUNTIME,
+	.cd_type	 = PXA_SDHCI_CD_PERMANENT,
+	.clk_delay_cycles	= 0xF,
+	.host_caps	= MMC_CAP_1_8V_DDR,
+	.dtr_data	= emmc_dtr_data,
+};
+
+static void __init emeidkb_init_mmc(void)
+{
+#ifdef CONFIG_SD8XXX_RFKILL
+	int WIB_PDn = mfp_to_gpio(MFP_WIB_PDn);
+	int WIB_RESETn = mfp_to_gpio(MFP_WIB_RESETn);
+
+	if (!gpio_request(WIB_PDn, "WIB_PDn")) {
+		gpio_direction_output(WIB_PDn, 0);
+		gpio_free(WIB_PDn);
+	}
+/*
+	if (!gpio_request(WIB_RESETn, "WIB_RSTn")) {
+		gpio_direction_output(WIB_RESETn, 0);
+		gpio_free(WIB_RESETn);
+	}
+*/
+	add_sd8x_rfkill_device(WIB_PDn, 0,
+			&pxa988_sdh_platdata_mmc2.pmmc,
+			emeidkb_8787_set_power);
+#endif
+
+	/*
+	 * Note!!
+	 *  The regulator can't be used here, as this is called in arch_init
+	 */
+
+	/* HW MMC3(sdh3) used for eMMC, and register first */
+	pxa988_add_sdh(3, &pxa988_sdh_platdata_mmc3);
+
+	/* HW MMC1(sdh1) used for SD/MMC card */
+	pxa988_sdh_platdata_mmc1.flags	 = PXA_FLAG_EN_PM_RUNTIME
+				| PXA_FLAG_ENABLE_CLOCK_GATING | PXA_FLAG_NEW_RX_CFG_REG;
+
+	pxa988_add_sdh(1, &pxa988_sdh_platdata_mmc1);
+
+	/* HW MMC2(sdh2) used for SDIO(WIFI/BT/FM module), and register last */
+	pxa988_add_sdh(2, &pxa988_sdh_platdata_mmc2);
+	wlan_wakeup_init();
+}
+#else
+static void __init emeidkb_init_mmc(void)
+{
+
+}
+#endif /* CONFIG_MMC_SDHCI_PXAV3 */
+
+
+#if defined(CONFIG_VIDEO_MMP)
+static int pxa988_cam_clk_init(struct device *dev)
+{
+	struct mmp_cam_pdata *data = dev->platform_data;
+	int ret;
+
+	data->clk[0] = devm_clk_get(dev, "CCICFUNCLK");
+	if (IS_ERR(data->clk[0])) {
+		dev_err(dev, "Could not get function clk\n");
+		ret = PTR_ERR(data->clk[0]);
+		return ret;
+	}
+
+	data->clk[1] = devm_clk_get(dev, "CCICAXICLK");
+	if (IS_ERR(data->clk[1])) {
+		dev_err(dev, "Could not get AXI clk\n");
+		ret = PTR_ERR(data->clk[1]);
+		return ret;
+	}
+
+	data->clk[2] = devm_clk_get(dev, "LCDCIHCLK");
+	if (IS_ERR(data->clk[2])) {
+		dev_err(dev, "Could not get lcd/ccic AHB clk\n");
+		ret = PTR_ERR(data->clk[2]);
+		return ret;
+	}
+
+	data->clk[3] = devm_clk_get(dev, "CCICPHYCLK");
+	if (IS_ERR(data->clk[3])) {
+		dev_err(dev, "Could not get PHY clk\n");
+		ret = PTR_ERR(data->clk[3]);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void pxa988_cam_set_clk(struct device *dev, int on)
+{
+	struct mmp_cam_pdata *data = dev->platform_data;
+	int mipi = on & MIPI_ENABLE;
+
+	on &= POWER_ON;
+	if (on) {
+		clk_enable(data->clk[2]);
+		clk_enable(data->clk[1]);
+		clk_enable(data->clk[0]);
+		if (mipi)
+			clk_enable(data->clk[3]);
+	} else {
+		if (mipi)
+			clk_disable(data->clk[3]);
+		clk_disable(data->clk[0]);
+		clk_disable(data->clk[1]);
+		clk_disable(data->clk[2]);
+	}
+}
+#endif
+
+#if 0
+struct mmp_cam_pdata mv_cam_data = {
+	.name = "EMEI",
+	.dma_burst = 64,
+	.mclk_min = 24,
+	.mclk_src = 3,
+	.mclk_div = 13,
+//	.init_pin = pxa988_cam_pin_init,
+	.init_clk = pxa988_cam_clk_init,
+	.enable_clk = pxa988_cam_set_clk,
+};
+
+static struct i2c_board_info dkb_i2c_camera[] = {
+	{
+		I2C_BOARD_INFO("ov2659", 0x30),
+	},
+	{
+		I2C_BOARD_INFO("ov5640", 0x3c),
+	},
+};
+
+
+static int camera_sensor_power(struct device *dev, int on)
+{
+	unsigned int cam_pwr;
+	unsigned int cam_reset;
+	static struct regulator *v_sensor;
+
+	if (!v_sensor) {
+		v_sensor = regulator_get(NULL, "v_cam_avdd");
+		if (IS_ERR(v_sensor)) {
+			v_sensor = NULL;
+			pr_err(KERN_ERR "Enable v_ldo16 failed!\n");
+			return -EIO;
+
+		}
+	}
+
+	cam_pwr = mfp_to_gpio(GPIO082_GPIO_CAM_PD_SUB);
+	cam_reset = mfp_to_gpio(GPIO083_GPIO_CAM_RST_SUB);
+
+	if (cam_pwr) {
+		if (gpio_request(cam_pwr, "CAM_PWR")) {
+			printk(KERN_ERR "Request GPIO failed,"
+					"gpio: %d\n", cam_pwr);
+			return -EIO;
+		}
+	}
+	if (gpio_request(cam_reset, "CAM_RESET")) {
+		printk(KERN_ERR "Request GPIO failed,"
+			"gpio: %d\n", cam_reset);
+		return -EIO;
+	}
+
+	if (on) {
+		regulator_set_voltage(v_sensor, 2800000, 2800000);
+		regulator_enable(v_sensor);
+		msleep(20);
+		gpio_direction_output(cam_pwr, 0);
+		mdelay(1);
+		gpio_direction_output(cam_reset, 0);
+		mdelay(1);
+		gpio_direction_output(cam_reset, 1);
+		mdelay(1);
+	} else {
+		gpio_direction_output(cam_reset, 0);
+		mdelay(1);
+		gpio_direction_output(cam_reset, 1);
+		gpio_direction_output(cam_pwr, 1);
+		regulator_disable(v_sensor);
+	}
+
+	gpio_free(cam_pwr);
+	gpio_free(cam_reset);
+
+	return 0;
+}
+
+static struct sensor_board_data ov2659_data = {
+	.mount_pos	= SENSOR_USED | SENSOR_POS_FRONT | SENSOR_RES_LOW,
+	.bus_type	= V4L2_MBUS_PARALLEL,
+	.bus_flag	= 0,	/* EMEI DKB connection don't change polarity of
+				 * PCLK/HSYNC/VSYNC signal */
+	.plat		= &mv_cam_data,
+};
+
+static struct soc_camera_link iclink_ov2659_dvp = {
+	.bus_id         = 0,            /* Must match with the camera ID */
+	.power          = camera_sensor_power,
+	.board_info     = &dkb_i2c_camera[0],
+	.i2c_adapter_id = 0,
+	.module_name    = "ov2659",
+	.priv		= &ov2659_data,
+	.flags		= 0,	/* controller driver should copy priv->bus_flag
+				 * here, so soc_camera_apply_board_flags can
+				 * take effect */
+};
+
+static struct platform_device dkb_ov2659_dvp = {
+	.name   = "soc-camera-pdrv",
+	.id     = 0,
+	.dev    = {
+		.platform_data = &iclink_ov2659_dvp,
+	},
+};
+
+#if defined(CONFIG_SOC_CAMERA_OV5640) || defined(CONFIG_SOC_CAMERA_OV5640_ECS)
+static int ov5640_sensor_power(struct device *dev, int on)
+{
+	static struct regulator *af_vcc;
+	static struct regulator *avdd;
+	int cam_reset;
+	int pwdn = mfp_to_gpio(GPIO080_GPIO_CAM_PD_MAIN);
+	int ret = 0;
+
+	cam_reset = mfp_to_gpio(GPIO081_GPIO_CAM_RST_MAIN);
+
+	if (gpio_request(pwdn, "CAM_ENABLE_LOW")) {
+		ret = -EIO;
+		goto out;
+	}
+
+	if (gpio_request(cam_reset, "CAM_RESET_LOW")) {
+		ret = -EIO;
+		goto out_rst;
+	}
+
+	if (!af_vcc) {
+		af_vcc = regulator_get(dev, "v_cam_af");
+		if (IS_ERR(af_vcc)) {
+			ret = -EIO;
+			goto out_af_vcc;
+		}
+	}
+
+	if (!avdd) {
+		avdd = regulator_get(dev, "v_cam_avdd");
+		if (IS_ERR(avdd)) {
+			ret =  -EIO;
+			goto out_avdd;
+		}
+	}
+
+	switch (on) {
+	case POWER_OFF:
+		gpio_direction_output(cam_reset, 0);
+		mdelay(1);
+		gpio_direction_output(cam_reset, 1);
+
+		regulator_disable(avdd);
+		regulator_disable(af_vcc);
+
+		gpio_direction_output(pwdn, 1);
+		mdelay(1);
+		break;
+	case POWER_ON:
+		regulator_set_voltage(af_vcc, 2800000, 2800000);
+		regulator_enable(af_vcc);
+		regulator_set_voltage(avdd, 2800000, 2800000);
+		regulator_enable(avdd);
+		mdelay(5);
+		gpio_direction_output(pwdn, 0);
+		mdelay(1);
+		gpio_direction_output(cam_reset, 0);
+		mdelay(1);
+		gpio_direction_output(cam_reset, 1);
+		mdelay(20);
+		break;
+	case POWER_SAVING:
+		gpio_direction_output(pwdn, 1);
+		mdelay(1);
+		break;
+	case POWER_RESTORE:
+		gpio_direction_output(pwdn, 0);
+		mdelay(1);
+		break;
+	default:
+		dev_err(dev, "unknown sensor power operation!\n");
+		break;
+	}
+
+	gpio_free(cam_reset);
+	gpio_free(pwdn);
+	return 0;
+
+out_avdd:
+	avdd = NULL;
+	regulator_put(af_vcc);
+out_af_vcc:
+	af_vcc = NULL;
+	gpio_free(cam_reset);
+out_rst:
+	gpio_free(pwdn);
+out:
+	return ret;
+}
+
+static struct sensor_board_data ov5640_data = {
+	.mount_pos	= SENSOR_USED | SENSOR_POS_BACK | SENSOR_RES_HIGH,
+	.bus_type	= V4L2_MBUS_CSI2,
+	.bus_flag	= V4L2_MBUS_CSI2_2_LANE, /* ov5640 used 2 lanes */
+	.dphy		= {0x0D06, 0x33, 0x0900},
+	.mipi_enabled	= 0,
+	.plat		= &mv_cam_data,
+};
+
+static struct soc_camera_link iclink_ov5640_mipi = {
+	.bus_id         = 0,            /* Must match with the camera ID */
+	.power          = ov5640_sensor_power,
+	.board_info     = &dkb_i2c_camera[1],
+	.i2c_adapter_id = 0,
+	.module_name    = "ov5640",
+	.priv		= &ov5640_data,
+};
+
+static struct platform_device dkb_ov5640_mipi = {
+	.name   = "soc-camera-pdrv",
+	.id     = 1,
+	.dev    = {
+		.platform_data = &iclink_ov5640_mipi,
+	},
+};
+#endif
+#endif
+static struct platform_device *dkb_platform_devices[] = {
+#if defined(CONFIG_SOC_CAMERA_OV2659)
+	&dkb_ov2659_dvp,
+#endif
+#if defined(CONFIG_SOC_CAMERA_OV5640) || defined(CONFIG_SOC_CAMERA_OV5640_ECS)
+	&dkb_ov5640_mipi,
+#endif
+};
+
+
+#ifdef CONFIG_VPU_DEVFREQ
+static struct devfreq_frequency_table *vpu_freq_table;
+
+static struct devfreq_platform_data devfreq_vpu_pdata = {
+	.clk_name = "VPUCLK",
+};
+
+static struct platform_device pxa988_device_vpudevfreq = {
+	.name = "devfreq-vpu",
+	.id = -1,
+};
+
+static void __init pxa988_init_device_vpudevfreq(void)
+{
+	u32 i = 0;
+	u32 vpu_freq_num = pxa988_get_vpu_op_num();
+
+	vpu_freq_table = kmalloc(sizeof(struct devfreq_frequency_table) * \
+					(vpu_freq_num + 1), GFP_KERNEL);
+	if (!vpu_freq_table)
+		return;
+
+	for (i = 0; i < vpu_freq_num; i++) {
+		vpu_freq_table[i].index = i;
+		vpu_freq_table[i].frequency = pxa988_get_vpu_op_rate(i);
+	}
+	vpu_freq_table[i].index = i;
+	vpu_freq_table[i].frequency = DEVFREQ_TABLE_END;
+
+	devfreq_vpu_pdata.freq_table = vpu_freq_table;
+
+	pxa988_device_vpudevfreq.dev.platform_data = (void *)&devfreq_vpu_pdata;
+	platform_device_register(&pxa988_device_vpudevfreq);
+}
+#endif
+
+#ifdef CONFIG_DDR_DEVFREQ
+static struct devfreq_frequency_table *ddr_freq_table;
+
+static struct devfreq_pm_qos_table ddr_freq_qos_table[] = {
+	/* list all possible frequency level here */
+	{
+		.freq = 208000,
+		.qos_value = DDR_CONSTRAINT_LVL0,
+	},
+	{
+		.freq = 312000,
+		.qos_value = DDR_CONSTRAINT_LVL1,
+	},
+	{
+		.freq = 400000,
+		.qos_value = DDR_CONSTRAINT_LVL2,
+	},
+	{
+		.freq = 533000,
+		.qos_value = DDR_CONSTRAINT_LVL3,
+	},
+	{0, 0},
+};
+
+
+static struct devfreq_platform_data devfreq_ddr_pdata = {
+	.clk_name = "ddr",
+	.interleave_is_on = 0,	/* only one mc */
+};
+
+static struct platform_device pxa988_device_ddrdevfreq = {
+	.name = "devfreq-ddr",
+	.id = -1,
+};
+
+static void __init pxa988_init_device_ddrdevfreq(void)
+{
+	u32 i = 0;
+	u32 ddr_freq_num = pxa988_get_ddr_op_num();
+
+	ddr_freq_table = kmalloc(sizeof(struct devfreq_frequency_table) * \
+					(ddr_freq_num + 1), GFP_KERNEL);
+	if (!ddr_freq_table)
+		return;
+
+	for (i = 0; i < ddr_freq_num; i++) {
+		ddr_freq_table[i].index = i;
+		ddr_freq_table[i].frequency = pxa988_get_ddr_op_rate(i);
+	}
+	ddr_freq_table[i].index = i;
+	ddr_freq_table[i].frequency = DEVFREQ_TABLE_END;
+
+	devfreq_ddr_pdata.freq_table = ddr_freq_table;
+	devfreq_ddr_pdata.hw_base[0] =  DMCU_VIRT_BASE;
+	devfreq_ddr_pdata.hw_base[1] =  DMCU_VIRT_BASE;
+
+	if (cpu_is_pxa986() && (!cpu_is_z1z2()))
+		devfreq_ddr_pdata.qos_list = ddr_freq_qos_table;
+
+	pxa988_device_ddrdevfreq.dev.platform_data = (void *)&devfreq_ddr_pdata;
+	platform_device_register(&pxa988_device_ddrdevfreq);
+}
+#endif
+
+#if defined(CONFIG_SEC_THERMISTOR)
+static struct sec_therm_adc_table adc_temp2_table[] = {
+	/* ADC, Temperature */
+	{ 1368,  -100 },
+	{ 1367,  -90 },
+	{ 1366,  -80 },
+	{ 1365,  -70 },
+	{ 1364,  -60 },
+	{ 1363,  -50 },
+	{ 1362,  -40 },
+	{ 1361,  -30 },
+	{ 1360,  -20 },
+	{ 1359,  -10 },
+	{ 1358,  0 },
+	{ 1357,  10 },
+	{ 1356,  20 },
+	{ 1355,  30 },
+	{ 1312,  40 },
+	{ 1263,  50 },
+	{ 1207,  60 },
+	{ 1170,  70 },
+	{ 1120,  80 },
+	{ 1075,  90 },
+	{ 1030,  100 },
+	{ 988,  110 },
+	{ 952,  120 },
+	{ 928,  130 },
+	{ 890,  140 },
+	{ 860,  150 },
+	{ 825,  160 },
+	{ 860,  170 },
+	{ 765,  180 },
+	{ 733,  190 },
+	{ 703,  200 },
+	{ 680,  210 },
+	{ 660,  220 },
+	{ 635,  230 },
+	{ 610,  240 },
+	{ 590,  250 },
+	{ 565,  260 },
+	{ 545,  270 },
+	{ 525,  280 },
+	{ 505,  290 },
+	{ 485,  300 },
+	{ 471,  310 },
+	{ 457,  320 },
+	{ 443,  330 },
+	{ 429,  340 },
+	{ 415,  350 },
+	{ 401,  360 },
+	{ 387,  370 },
+	{ 373,  380 },
+	{ 359,  390 },
+	{ 342,  400 },
+	{ 333,  410 },
+	{ 324,  420 },
+	{ 315,  430 },
+	{ 306,  440 },
+	{ 297,  450 },
+	{ 288,  460 },
+	{ 279,  470 },
+	{ 270,  480 },
+	{ 261,  490 },
+	{ 252,  500 },
+	{ 244,  510 },
+	{ 236,  520 },
+	{ 228,  530 },
+	{ 220,  540 },
+	{ 212,  550 },
+	{ 204,  560 },
+	{ 196,  570 },
+	{ 188,  580 },
+	{ 180,  590 },
+	{ 170,  600 },
+	{ 163,  610 },
+	{ 156,  620 },
+	{ 149,  630 },
+	{ 142,  640 },
+	{ 135,  650 },
+	{ 127,  660 },
+	{ 120,  670 },
+	{ 113,  680 },
+	{ 106,  690 },
+	{ 99,  700 },
+	{ 93,  710 },
+	{ 87,  720 },
+	{ 81,  730 },
+	{ 75,  740 },
+	{ 69,  750 },
+};
+
+static struct sec_therm_platform_data sec_therm_pdata = {
+	.adc_arr_size	= ARRAY_SIZE(adc_temp2_table),
+#if defined(CONFIG_MFD_D2199)
+	.adc_channel	= D2199_ADC_TEMPERATURE_2,
+#else
+	.adc_channel	= PM822_GPADC3_MEAS1,
+#endif
+	.adc_table	= adc_temp2_table,
+};
+
+static struct platform_device sec_device_thermistor = {
+	.name = "sec-thermistor",
+	.id = -1,
+	.dev.platform_data = &sec_therm_pdata,
+};
+#endif /* CONFIG_SEC_THERMISTOR */
+
+#ifdef CONFIG_LEDS_RT8547
+static struct rt8547_platform_data rt8547_pdata = {
+	.flen_gpio = 20,   /* GPIO_20 */
+	.flset_gpio = 97,  /* GPIO_97 */
+	.strobe_current = STROBE_CURRENT_1000MA,
+	.torch_current = TORCH_CURRENT_100MA,
+	.strobe_timing = 0x0f, //please refer to the data sheet
+};
+static struct platform_device leds_rt8547_device = {
+	.name = "leds-rt8547",
+	.id = -1,
+	.dev = {
+		.platform_data = &rt8547_pdata,
+	},
+};
+#endif /* #ifdef CONFIG_LEDS_RT8547 */
+
+/* clk usage desciption */
+MMP_HW_DESC(fb, "pxa168-fb", 0, PM_QOS_CPUIDLE_BLOCK_DDR_VALUE, "LCDCIHCLK");
+struct mmp_hw_desc *emei_dkb_hw_desc[] __initdata = {
+	&mmp_device_hw_fb,
+};
+
+#define MFP_RF_EN              GPIO010_GPIO_10
+static int waruba_enable_RF(void)
+{
+
+       int RF_EN = mfp_to_gpio(MFP_RF_EN);
+
+       if (!gpio_request(RF_EN, "RF_EN")) {
+               gpio_direction_output(RF_EN, 1);
+
+               gpio_free(RF_EN);
+       }
+	   else
+	   	return -1;
+
+	   return 0;
+
+}
+
+#ifdef CONFIG_PROC_FS
+
+#ifdef GPS_LDO_POWER
+static int gps_enable_control(int flag)
+{
+        static struct regulator *gps_regulator = NULL;
+        static int f_enabled = 0;
+        printk("[GPS] LDO control : %s\n", flag ? "ON" : "OFF");
+
+        if (flag && (!f_enabled)) {
+                      gps_regulator = regulator_get(NULL, "v_gps_1v8");
+                      if (IS_ERR(gps_regulator)) {
+                                   gps_regulator = NULL;
+                                   return EIO;
+                      } else {
+                                   regulator_set_voltage(gps_regulator, 1800000, 1800000);
+                                   regulator_enable(gps_regulator);
+                      }
+                      f_enabled = 1;
+        }
+        if (f_enabled && (!flag))
+        {
+                      if (gps_regulator) {
+                                   regulator_disable(gps_regulator);
+                                   regulator_put(gps_regulator);
+                                   gps_regulator = NULL;
+                      }
+                      f_enabled = 0;
+        }
+        return 0;
+}
+#endif
+
+static void gps_eclk_ctrl(int on)
+{
+	mfp_cfg_t gps_eclk_en = GPIO089_GPS_CLK;
+	mfp_cfg_t gps_eclk_dis = GPIO089_AP_AGPS_CLK_DIS;
+
+	if (on)
+		mfp_config(&gps_eclk_en, 1);
+	else
+		mfp_config(&gps_eclk_dis, 1);
+}
+
+/* GPS: power on/off control */
+static void gps_power_on(void)
+{
+	unsigned int gps_rst_n,gps_on, gps_clk;
+	gps_eclk_ctrl(0);
+#ifdef CONFIG_SEC_GPIO_DVS
+	static int is_initdvs_done = 0;
+#endif
+
+	gps_rst_n = mfp_to_gpio(GPIO005_AP_AGPS_RESET);
+	if (gpio_request(gps_rst_n, "gpio_gps_rst")) {
+		pr_err("Request GPIO failed, gpio: %d\n", gps_rst_n);
+		return;
+	}
+	gps_on = mfp_to_gpio(GPIO052_AP_AGPS_ONOFF);
+	if (gpio_request(gps_on, "gpio_gps_on")) {
+		pr_err("Request GPIO failed,gpio: %d\n", gps_on);
+		goto out;
+	}
+	gps_clk = mfp_to_gpio(GPIO089_AP_AGPS_CLK_DIS);
+	if (gpio_request(gps_clk, "gpio_gps_clk")) {
+		pr_err("Request GPIO failed,gpio: %d\n", gps_clk);
+		goto out3;
+	}
+
+	gpio_direction_output(gps_clk, 0);
+	gpio_direction_output(gps_rst_n, 0);
+	gpio_direction_output(gps_on, 0);
+#ifdef GPS_LDO_POWER
+	gps_enable_control(1);
+#endif
+	mdelay(10);
+	mdelay(10);
+
+	pr_info("gps chip powered on\n");
+
+	gpio_free(gps_clk);
+out3:
+	gpio_free(gps_on);
+out:
+	gpio_free(gps_rst_n);
+
+#ifdef CONFIG_SEC_GPIO_DVS
+	/************************ Caution !!! ****************************/
+	/* This function must be located in appropriate INIT position
+	 * in accordance with the specification of each BB vendor.
+	 */
+	/************************ Caution !!! ****************************/
+	if(!is_initdvs_done) {
+		gpio_dvs_check_initgpio();
+		is_initdvs_done = 1;
+	}
+#endif
+
+	return;
+}
+
+static void gps_power_off(void)
+{
+	unsigned int gps_rst_n, gps_on, gps_clk;
+	gps_eclk_ctrl(0);
+
+	gps_on = mfp_to_gpio(GPIO052_AP_AGPS_ONOFF);
+	if (gpio_request(gps_on, "gpio_gps_on")) {
+		pr_err("Request GPIO failed,gpio: %d\n", gps_on);
+		return;
+	}
+	gps_rst_n = mfp_to_gpio(GPIO005_AP_AGPS_RESET);
+	if (gpio_request(gps_rst_n, "gpio_gps_rst")) {
+		pr_debug("Request GPIO failed, gpio: %d\n", gps_rst_n);
+		goto out2;
+	}
+
+	gps_clk = mfp_to_gpio(GPIO089_AP_AGPS_CLK_DIS);
+	if (gpio_request(gps_clk, "gpio_gps_clk")) {
+		pr_debug("Request GPIO failed, gpio: %d\n", gps_clk);
+		goto out4;
+	}
+
+	gpio_direction_output(gps_clk, 0);
+	gpio_direction_output(gps_rst_n, 0);
+	gpio_direction_output(gps_on, 0);
+#ifdef GPS_LDO_POWER
+	gps_enable_control(0);
+#endif
+	pr_info("gps chip powered off\n");
+
+	gpio_free(gps_clk);
+out4:
+	gpio_free(gps_rst_n);
+out2:
+	gpio_free(gps_on);
+	return;
+}
+
+static void gps_reset(int flag)
+{
+	unsigned int gps_rst_n;
+
+	gps_rst_n = mfp_to_gpio(GPIO005_AP_AGPS_RESET);
+	if (gpio_request(gps_rst_n, "gpio_gps_rst")) {
+		pr_err("Request GPIO failed, gpio: %d\n", gps_rst_n);
+		return;
+	}
+
+	gpio_direction_output(gps_rst_n, flag);
+	gpio_free(gps_rst_n);
+	printk(KERN_INFO "gps chip reset with %s\n", flag ? "ON" : "OFF");
+}
+
+static void gps_on_off(int flag)
+{
+	unsigned int gps_on;
+
+	gps_on = mfp_to_gpio(GPIO052_AP_AGPS_ONOFF);
+	if (gpio_request(gps_on, "gpio_gps_on")) {
+		pr_err("Request GPIO failed, gpio: %d\n", gps_on);
+		return;
+	}
+
+	gpio_direction_output(gps_on, flag);
+	gpio_free(gps_on);
+	printk(KERN_INFO "gps chip onoff with %s\n", flag ? "ON" : "OFF");
+}
+
+#define SIRF_STATUS_LEN	16
+static char sirf_status[SIRF_STATUS_LEN] = "off";
+
+static ssize_t sirf_read_proc(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	int len = strlen(sirf_status);
+
+	sprintf(page, "%s\n", sirf_status);
+	return len + 1;
+}
+
+static ssize_t sirf_write_proc(struct file *filp,
+		const char *buff, size_t len, loff_t *off)
+{
+	char messages[256];
+	int flag, ret;
+	char buffer[7];
+
+	if (len > 255)
+		len = 255;
+
+	memset(messages, 0, sizeof(messages));
+
+	if (!buff || copy_from_user(messages, buff, len))
+		return -EFAULT;
+
+	if (strlen(messages) > (SIRF_STATUS_LEN - 1)) {
+		pr_warning("[ERROR] messages too long! (%d) %s\n",
+			strlen(messages), messages);
+		return -EFAULT;
+	}
+
+	if (strncmp(messages, "off", 3) == 0) {
+		strcpy(sirf_status, "off");
+		gps_power_off();
+	} else if (strncmp(messages, "on", 2) == 0) {
+		strcpy(sirf_status, "on");
+		gps_power_on();
+	} else if (strncmp(messages, "reset", 5) == 0) {
+		strcpy(sirf_status, messages);
+		ret = sscanf(messages, "%s %d", buffer, &flag);
+		if (ret == 2)
+			gps_reset(flag);
+	} else if (strncmp(messages, "sirfon", 6) == 0) {
+		strcpy(sirf_status, messages);
+		ret = sscanf(messages, "%s %d", buffer, &flag);
+		if (ret == 2)
+			gps_on_off(flag);
+	} else if (strncmp(messages, "eclk", 4) == 0) {
+		ret = sscanf(messages, "%s %d", buffer, &flag);
+		if (ret == 2)
+			gps_eclk_ctrl(flag);
+	} else
+		pr_info("usage: echo {on/off} > /proc/driver/sirf\n");
+
+	return len;
+}
+
+static void create_sirf_proc_file(void)
+{
+	struct proc_dir_entry *sirf_proc_file = NULL;
+
+	/*
+	 * CSR and Marvell GPS lib will both use this file
+	 * "/proc/drver/gps" may be modified in future
+	 */
+	sirf_proc_file = create_proc_entry("driver/sirf", 0644, NULL);
+	if (!sirf_proc_file) {
+		pr_err("sirf proc file create failed!\n");
+		return;
+	}
+
+	sirf_proc_file->read_proc = sirf_read_proc;
+	sirf_proc_file->write_proc = (write_proc_t  *)sirf_write_proc;
+	gps_power_off();
+}
+
+static ssize_t pcm_mfp_read_proc(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	int mfp = mfp_read(mfp_to_gpio(GPIO025_GPIO_INPUT));
+
+	mfp &= 0x7;
+
+	sprintf(page, "GPIO25~28 are configured to %s\n",
+			mfp ? "GSSP" : "GPIO input");
+
+	return strlen(page) + 1;
+}
+
+static ssize_t pcm_mfp_write_proc(struct file *filp,
+				const char *buff, size_t len, loff_t *off)
+{
+	char a;
+	unsigned long i, j, gpio;
+	unsigned long gssp_mfp[2][4] = {
+		{
+			GPIO025_GPIO_INPUT,
+			GPIO026_GPIO_INPUT,
+			GPIO027_GPIO_INPUT,
+			GPIO028_GPIO_INPUT,
+		},
+		{
+			GPIO025_GSSP_SCLK,	/* PCM_CLK */
+			GPIO026_GSSP_SFRM,	/* PCM_SYNC */
+			GPIO027_GSSP_TXD,	/* PCM_TXD */
+			GPIO028_GSSP_RXD,	/* PCM_RXD */
+		},
+	};
+
+	if (copy_from_user(&a, buff, 1))
+		return -EINVAL;
+	switch (a) {
+	case '0':
+		i = 0;
+		pr_debug("Switch GPIO25~28 to GPIO input\n");
+		break;
+	case '1':
+		i = 1;
+		pr_debug("Switch GPIO25~28 to GSSP function\n");
+		break;
+	default:
+		pr_err("[PCM_MFP] Error: invalid configuration\n");
+		return len;
+	}
+
+	mfp_config(ARRAY_AND_SIZE(gssp_mfp[i]));
+
+	for (j = 0; j < ARRAY_SIZE(gssp_mfp[i]); j++) {
+		gpio = mfp_to_gpio(gssp_mfp[i][j]);
+		gpio_request(gpio, NULL);
+		gpio_direction_input(gpio);
+		gpio_free(gpio);
+	}
+
+	return len;
+}
+
+static void create_pcm_mfp_proc_file(void)
+{
+	struct proc_dir_entry *proc_file = NULL;
+
+	proc_file = create_proc_entry("driver/pcm_mfp", 0644, NULL);
+	if (!proc_file) {
+		pr_err("%s: create proc file failed\n", __func__);
+		return;
+	}
+
+	proc_file->write_proc = (write_proc_t *)pcm_mfp_write_proc;
+	proc_file->read_proc = (read_proc_t *)pcm_mfp_read_proc;
+
+}
+
+#endif
+
+static struct timer_list uart_constraint_timer;
+static struct pm_qos_request uart_lpm_cons;
+static const char uart_cons_name[] = "uart rx pad";
+static void uart_add_constraint(int mfp, void *unused)
+{
+	if (!mod_timer(&uart_constraint_timer, jiffies + 3 * HZ))
+		pm_qos_update_request(&uart_lpm_cons,
+			PM_QOS_CPUIDLE_BLOCK_DDR_VALUE);
+}
+
+static void uart_timer_handler(unsigned long data)
+{
+	pm_qos_update_request(&uart_lpm_cons,
+		PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+}
+
+struct gpio_edge_desc uart_rx_pad = {
+	.mfp = MFP_PIN_GPIO47, /* ap UART rx */
+	.handler = uart_add_constraint,
+};
+
+#if defined(CONFIG_MFD_88PM822)
+#define PM822_SW_PDOWN			(1 << 5)
+extern unsigned int lpcharge;
+extern int i2c_set_pio_mode(void);
+static void emei_dkb_poweroff(void)
+{
+	unsigned char data;
+#ifdef CONFIG_BATTERY_SAMSUNG
+	static char *pss[] = {"battery"};
+	int i;
+	bool charger_present = false;
+	union power_supply_propval val;
+	struct power_supply *psy;
+	int ret;
+
+	/*
+	 * If we have a charger connected and we're powering off,
+	 * reboot into charge-only mode.
+	 */
+
+	for (i = 0; i < ARRAY_SIZE(pss); i++) {
+		psy = power_supply_get_by_name(pss[i]);
+		if (!psy)
+			continue;
+
+		ret = psy->get_property(psy, POWER_SUPPLY_PROP_ONLINE, &val);
+
+		if (!ret && (val.intval != POWER_SUPPLY_TYPE_BATTERY)) {
+			charger_present = true;
+			break;
+		}
+	}
+
+	preempt_enable();
+	if (charger_present) {
+		pr_info("Restarting Device with TA ....\n");
+		data = pm822_extern_read(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER);
+		data &= ~(PMIC_GENERAL_USE_REBOOT_DN_MASK);
+		data |= PMIC_GENERAL_USE_BOOT_BY_CHG;
+		data |= PMIC_GENERAL_USE_SHUTDOWN_BY_POWEROFF;
+		pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+
+		/* PMIC Watchdog Kick to prepare for AP Watchdog failure */
+		pr_info("%d; enable PMIC watchdog\n", __LINE__);
+		data = pm822_extern_read(PM822_BASE_PAGE, PM822_WAKEUP1);
+		pr_info("PM822_WAKEUP1 Reg(0x%02x) is 0x%02x\n", PM822_WAKEUP1,data);
+		data |= PM822_WAKEUP1_WD_MODE;
+		pm822_extern_write(PM822_BASE_PAGE, PM822_WAKEUP1, data);
+
+		data = pm822_extern_read(PM822_BASE_PAGE, PM822_WAKEUP2);
+		pr_info("PM822_WAKEUP2 Reg(0x%02x) is 0x%02x\n", PM822_WAKEUP2,data);
+		data &= ~(PM822_WD_TIMER_ACT_MASK);
+		data |= PM822_WD_TIMER_ACT_4S;
+		pm822_extern_write(PM822_BASE_PAGE, PM822_WAKEUP2, data);
+		pr_info("0x%02x is written to PM822_WAKEUP2 Reg(0x%02x)\n",data, PM822_WAKEUP2);
+
+		pm822_extern_write(PM822_BASE_PAGE, PM822_WATCHDOG_REG, PM822_WD_EN);
+		data = pm822_extern_read(PM822_BASE_PAGE, PM822_WATCHDOG_REG);
+		pr_info("WATCHDOG Reg(0x%02x) is 0x%02x\n", PM822_WATCHDOG_REG,data);
+
+		machine_restart("ta");
+	}
+#endif
+
+	pr_info("turning off power....\n");
+
+	/* save power off reason */
+	data = PMIC_GENERAL_USE_BOOT_BY_NONE | PMIC_GENERAL_USE_SHUTDOWN_BY_POWEROFF;
+	pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+	data = pm822_extern_read(PM822_BASE_PAGE, PM822_WAKEUP1);
+	pm822_extern_write(PM822_BASE_PAGE, PM822_WAKEUP1,
+			   data | PM822_SW_PDOWN);
+}
+#elif defined(CONFIG_MFD_88PM800)
+#define PM800_SW_PDOWN			(1 << 5)
+static void emei_dkb_poweroff(void)
+{
+	unsigned char data;
+	pr_info("turning off power....\n");
+
+	preempt_enable();
+        /* save power off reason */
+	pm800_extern_write(PM80X_BASE_PAGE, PM800_USER_DATA3, PMIC_GENERAL_USE_BOOT_BY_NONE);
+	data = pm800_extern_read(PM80X_BASE_PAGE, PM800_WAKEUP1);
+	pm800_extern_write(PM80X_BASE_PAGE, PM800_WAKEUP1,
+			   data | PM800_SW_PDOWN);
+}
+#endif
+
+#ifdef CONFIG_ANDROID_RAM_CONSOLE
+static struct platform_device pxa988_device_ramconsole = {
+	.name = "ram_console",
+	.id = -1,
+};
+#endif
+
+extern int is_panic;
+static int reboot_notifier_func(struct notifier_block *this,
+		unsigned long code, void *p)
+{
+	char *cmd = p;
+	unsigned char data;
+	unsigned char pmic_download_register = 0;
+	unsigned char pmic_register = 0;
+
+#if defined(CONFIG_MFD_88PM822)
+	data = pm822_extern_read(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER);
+	data &= ~(PMIC_GENERAL_USE_REBOOT_DN_MASK);
+	if (cmd) {
+                /* need to write reset reason according to cmd */
+                pr_info("reboot notifier: %s\n", cmd);
+		if (!strcmp(cmd, "recovery")) {
+			pr_info("Device will enter recovery mode on next booting\n");
+			data |= PMIC_GENERAL_USE_BOOT_BY_FULL_RESET;
+			pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+		} else if (!strcmp(cmd, "recovery_done")) {
+			data |= PMIC_GENERAL_USE_BOOT_BY_RECOVERY_DONE;
+			pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+		} else if (!strcmp(cmd, "arm11_fota")) {
+			data |= PMIC_GENERAL_USE_BOOT_BY_FOTA;
+			pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+		} else if (!strcmp(cmd, "alarm")) {
+			data |= PMIC_GENERAL_USE_BOOT_BY_RTC_ALARM;
+			pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+		} else if (!strcmp(cmd, "debug0x4f4c")) {
+			data |= PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_LOW;
+			pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+		} else if (!strcmp(cmd, "debug0x494d")) {
+			data |= PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_MID;
+			pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+		} else if(!strcmp(cmd, "debug0x4948")) {
+			data |= PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_HIGH;
+			pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+		} else if (!strcmp(cmd, "GlobalActions restart")) {
+			data |= PMIC_GENERAL_USE_BOOT_BY_INTENDED_RESET;
+			pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+		} else if (!strcmp(cmd,"download")) {
+			pmic_download_register = PMIC_GENERAL_DOWNLOAD_MODE_FUS + DOWNLOAD_FUS_SUD_BASE;
+			data |= pmic_download_register;
+			pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+			pr_info("pmic_download_register FUS : %d ,read result : 0x%02x \n",
+				pmic_download_register, pm822_extern_read(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER));
+		} else if (!strncmp(cmd,"sud", 3)) {
+			/* Value : 21 ~ 29 */
+			pmic_download_register = cmd[3] - '0' + DOWNLOAD_FUS_SUD_BASE;
+			data |= pmic_download_register;
+			pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+			pr_info("pmic_download_register SUDDLMOD : %d, read result : 0x%02x \n",
+				pmic_download_register, pm822_extern_read(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER));
+		} else {
+			data |= PMIC_GENERAL_USE_BOOT_BY_INTENDED_RESET;
+			pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+		}
+
+	} else {
+                #if !defined(CONFIG_RECOVERY_KERNEL)
+                data |= PMIC_GENERAL_USE_BOOT_BY_INTENDED_RESET;
+                pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+                #else
+                data |= PMIC_GENERAL_USE_BOOT_BY_RECOVERY_DONE;
+                pm822_extern_write(PM822_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, data);
+                #endif
+	}
+	if (code != SYS_POWER_OFF) {
+		pr_info("enable PMIC watchdog\n");
+		data = pm822_extern_read(PM822_BASE_PAGE, PM822_WAKEUP1);
+		pr_info("PM822_WAKEUP1 Reg(0x%02x) is 0x%02x\n", PM822_WAKEUP1,data);
+		data |= PM822_WAKEUP1_WD_MODE;
+		pm822_extern_write(PM822_BASE_PAGE, PM822_WAKEUP1, data);
+
+		data = pm822_extern_read(PM822_BASE_PAGE, PM822_WAKEUP2);
+		pr_info("PM822_WAKEUP2 Reg(0x%02x) is 0x%02x\n", PM822_WAKEUP2,data);
+		data &= ~(PM822_WD_TIMER_ACT_MASK);
+		data |= PM822_WD_TIMER_ACT_8S;
+		pm822_extern_write(PM822_BASE_PAGE, PM822_WAKEUP2, data);
+		pr_info("0x%02x is written to PM822_WAKEUP2 Reg(0x%02x)\n",data, PM822_WAKEUP2);
+
+		pm822_extern_write(PM822_BASE_PAGE, PM822_WATCHDOG_REG, PM822_WD_EN);
+		data = pm822_extern_read(PM822_BASE_PAGE, PM822_WATCHDOG_REG);
+		pr_info("WATCHDOG Reg(0x%02x) is 0x%02x\n", PM822_WATCHDOG_REG,data);
+	}
+#elif defined(CONFIG_MFD_88PM800)
+	if (cmd && !strcmp(cmd, "recovery")) {
+		data = pm800_extern_read(PM80X_BASE_PAGE, 0xef);
+		pm800_extern_write(PM80X_BASE_PAGE, 0xef, data | 0x1);
+	} else {
+		data = pm800_extern_read(PM80X_BASE_PAGE, 0xef);
+		pm800_extern_write(PM80X_BASE_PAGE, 0xef, data & 0xfe);
+	}
+
+	if (cmd) {
+		if (!strcmp(cmd, "recovery"))
+			pm800_extern_write(PM80X_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, PMIC_GENERAL_USE_BOOT_BY_FULL_RESET);
+		else if (!strcmp(cmd, "recovery_done"))
+			pm800_extern_write(PM80X_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, PMIC_GENERAL_USE_BOOT_BY_RECOVERY_DONE);
+		else if (!strcmp(cmd, "arm11_fota"))
+			pm800_extern_write(PM80X_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, PMIC_GENERAL_USE_BOOT_BY_FOTA);
+		else if (!strcmp(cmd, "alarm"))
+			pm800_extern_write(PM80X_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, PMIC_GENERAL_USE_BOOT_BY_RTC_ALARM);
+		else if(!strcmp(cmd, "debug0x4f4c"))
+			pm800_extern_write(PM80X_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_LOW);
+		else if(!strcmp(cmd, "debug0x494d"))
+			pm800_extern_write(PM80X_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_MID);
+		else if(!strcmp(cmd, "debug0x4948"))
+			pm800_extern_write(PM80X_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_HIGH);
+		else if (!strcmp(cmd, "GlobalActions restart"))
+			pm800_extern_write(PM80X_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, PMIC_GENERAL_USE_BOOT_BY_INTENDED_RESET);
+#ifdef CONFIG_ONECHIP_DUAL_MODEM
+		else if (!strncmp(cmd, "swsel",5))
+			pm800_extern_write(PM80X_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, PMIC_GENERAL_USE_BOOT_BY_SET_SWITCH_SEL | cmd[5]-'0');
+#endif
+		else if (!strcmp(cmd,"download"))
+		{
+			pmic_download_register = PMIC_GENERAL_DOWNLOAD_MODE_FUS;
+			pmic_register =(pmic_download_register<<4)&0xF0;
+			pm800_extern_write(PM80X_BASE_PAGE, PM800_USER_DATA6, pmic_register);
+			pr_info("pmic_download_register FUS : %d ,read result : 0x%02x \n",
+				pmic_download_register, pm800_extern_read(PM80X_BASE_PAGE, PM800_USER_DATA6));
+		}
+		else if (!strncmp(cmd,"sud", 3))
+		{
+			pmic_download_register = cmd[3] - '0';
+			pmic_register = (pmic_download_register << 4) & 0xF0;
+			pm800_extern_write(PM80X_BASE_PAGE, PM800_USER_DATA6, pmic_register);
+			pr_info("pmic_download_register SUDDLMOD : %d, read result : 0x%02x \n",
+				pmic_download_register, pm800_extern_read(PM80X_BASE_PAGE, PM800_USER_DATA6));
+		}
+		else
+			pm800_extern_write(PM80X_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, PMIC_GENERAL_USE_BOOT_BY_INTENDED_RESET);
+
+	}
+	else
+		pm800_extern_write(PM80X_BASE_PAGE, PMIC_GENERAL_USE_REGISTER, PMIC_GENERAL_USE_BOOT_BY_INTENDED_RESET);
+
+
+	if (code != SYS_POWER_OFF) {
+		data = pm800_extern_read(PM80X_BASE_PAGE, 0xef);
+		/* this bit is for charger server */
+		pm800_extern_write(PM80X_BASE_PAGE, 0xef, data | 0x2);
+	}
+
+#elif defined (CONFIG_MFD_D2199)
+	if (cmd && !strcmp(cmd, "recovery")) {
+		d2199_extern_reg_read(D2199_GP_ID_1_REG, &data);
+		d2199_extern_reg_write(D2199_GP_ID_1_REG, data | 0x1);
+	} else {
+		d2199_extern_reg_read(D2199_GP_ID_1_REG, &data);
+		d2199_extern_reg_write(D2199_GP_ID_1_REG, data & 0xfe);
+	}
+
+	if (cmd) {
+		if (!strcmp(cmd, "recovery"))
+			d2199_extern_reg_write(D2199_GP_ID_0_REG, PMIC_GENERAL_USE_BOOT_BY_FULL_RESET);
+		else if (!strcmp(cmd, "recovery_done"))
+			d2199_extern_reg_write(D2199_GP_ID_0_REG, PMIC_GENERAL_USE_BOOT_BY_RECOVERY_DONE);
+		else if (!strcmp(cmd, "arm11_fota"))
+			d2199_extern_reg_write(D2199_GP_ID_0_REG, PMIC_GENERAL_USE_BOOT_BY_FOTA);
+		else if (!strcmp(cmd, "alarm"))
+			d2199_extern_reg_write(D2199_GP_ID_0_REG, PMIC_GENERAL_USE_BOOT_BY_RTC_ALARM);
+		else if(!strcmp(cmd, "debug0x4f4c"))
+			d2199_extern_reg_write(D2199_GP_ID_0_REG, PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_LOW);
+		else if(!strcmp(cmd, "debug0x494d"))
+			d2199_extern_reg_write(D2199_GP_ID_0_REG, PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_MID);
+		else if(!strcmp(cmd, "debug0x4948"))
+			d2199_extern_reg_write(D2199_GP_ID_0_REG, PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_HIGH);
+		else if (!strcmp(cmd, "GlobalActions restart"))
+			d2199_extern_reg_write(D2199_GP_ID_0_REG, PMIC_GENERAL_USE_BOOT_BY_INTENDED_RESET);
+		else if (!strcmp(cmd,"download"))
+		{
+			pr_info("pmic_download_register FUS : %d \n",pmic_download_register);
+			pmic_download_register = PMIC_GENERAL_DOWNLOAD_MODE_FUS;
+			pmic_register =(pmic_download_register<<4)&0xF0;
+			d2199_extern_reg_write(D2199_GP_ID_1_REG, pmic_register);
+		}
+		else if (!strncmp(cmd,"sud", 3))
+		{
+			pmic_download_register = ((char*)cmd)[3] - '0';
+			pmic_register = (pmic_download_register << 4) & 0xF0;
+			d2199_extern_reg_write(D2199_GP_ID_1_REG, pmic_register);
+			pr_info("pmic_download_register SUDDLMOD : %d \n", pmic_download_register);
+		}
+		else
+			d2199_extern_reg_write(D2199_GP_ID_0_REG, PMIC_GENERAL_USE_BOOT_BY_INTENDED_RESET);
+
+	}
+	else
+		d2199_extern_reg_write(D2199_GP_ID_0_REG, PMIC_GENERAL_USE_BOOT_BY_INTENDED_RESET);
+
+	if (code != SYS_POWER_OFF) {
+		d2199_extern_reg_read(D2199_GP_ID_1_REG, &data);
+		/* this bit is for charger server */
+		d2199_extern_reg_write(D2199_GP_ID_1_REG, data | 0x2);
+	}
+#endif
+
+	is_panic = 0;
+
+	return 0;
+}
+
+static struct notifier_block reboot_notifier = {
+	.notifier_call = reboot_notifier_func,
+};
+
+#if defined(CONFIG_MFD_D2199)
+extern void d2199_system_poweroff(void);
+#endif
+
+void mfp_config_init_done(void)
+{
+	pr_info("%s\n", __func__);
+}
+
+static void __init emeidkb_init(void)
+{
+	int i;
+
+#ifdef CONFIG_SEC_DEBUG
+	sec_debug_init();
+#endif
+	for (i = 0; i < ARRAY_SIZE(emei_dkb_hw_desc); i++)
+		mmp_device_hw_register(emei_dkb_hw_desc[i]);
+
+	mfp_config(ARRAY_AND_SIZE(emeidkb_pin_config));
+
+	if (dvc_flag)
+		mfp_config(ARRAY_AND_SIZE(dvc_pin_config));
+
+	if (system_rev >= GOYA_R0_5)
+		mfp_config(ARRAY_AND_SIZE(rev05_pin_config));
+
+	mfp_config_init_done();
+
+#if defined(CONFIG_MFD_D2199)
+	pm_power_off = d2199_system_poweroff;
+#else
+	pm_power_off = emei_dkb_poweroff;
+#endif
+	register_reboot_notifier(&reboot_notifier);
+
+	/* Uart1, AP kernel console and debug */
+	pxa988_add_uart(1);
+	/* Uart2, GPS */
+	pxa988_add_uart(2);
+
+	emeidkb_init_mmc();
+
+	printk("system_rev is %d\n",  system_rev);
+
+#ifdef CONFIG_ANDROID_RAM_CONSOLE
+	platform_device_register(&pxa988_device_ramconsole);
+#endif
+
+	/* soc-rtc */
+	platform_device_register(&pxa988_device_rtc);
+	/* backlight */
+#ifdef CONFIG_BACKLIGHT_KTD253
+#define HX8369B_PANEL_BOE3	(0x55BCF0)
+	if (panel_id == HX8369B_PANEL_BOE3) {
+		ktd_lcd_backlight_data.brt_table = ktd_brt_table_boe;
+		ktd_lcd_backlight_data.sz_table = ARRAY_SIZE(ktd_brt_table_boe);
+	}
+	platform_device_register(&ktd_device);
+#endif
+
+
+#if defined(CONFIG_MFD_88PM822)
+	/* set pm822 dvc information,must before pm822 init */
+	if (!dvc_flag)
+		pm822_dvctable_init();
+	else {
+		pm822_dvc.reg_dvc = 1;
+		pm822_dvc.set_dvc = dvc_set_voltage;
+		pm822_dvc.write_reg = PMUM_DVC_AP;
+		pm822_dvc.read_reg = PMUM_DVC_STATUS;
+	}
+#elif defined(CONFIG_MFD_88PM800)
+	/* set pm800 dvc information,must before pm800 init */
+	if (!dvc_flag)
+		pm800_dvctable_init();
+	else {
+		pm80x_dvc.gpio_dvc = 0;
+		pm80x_dvc.reg_dvc = 1;
+		pm80x_dvc.set_dvc = dvc_set_voltage;
+		pm80x_dvc.write_reg = PMUM_DVC_AP;
+		pm80x_dvc.read_reg = PMUM_DVC_STATUS;
+	}
+#elif defined(CONFIG_D2199_DVC)
+	//printk("[WS][DVFS][%s]-dvc_flag[%d]\n", __func__, dvc_flag);
+
+	if (!dvc_flag)
+		d2199_dvctable_init();
+	else {
+		d2199_dvc.gpio_dvc = 0;
+		d2199_dvc.reg_dvc = 1;
+		d2199_dvc.set_dvc = d2199_dvc_set_voltage;
+		d2199_dvc.write_reg = PMUM_DVC_AP;
+		d2199_dvc.read_reg = PMUM_DVC_STATUS;
+	}
+#endif
+
+	pxa988_add_twsi(0, &emeidkb_ci2c_pdata,
+			ARRAY_AND_SIZE(emeidkb_i2c_info));
+	pxa988_add_twsi(1, &emeidkb_ci2c2_pdata,
+			ARRAY_AND_SIZE(emeidkb_i2c2_info));
+	if (system_rev == GOYA_R0_3) {
+		pxa_init_i2c_gpio_irq(ARRAY_AND_SIZE(emeidkb_pwr_i2c_gpio),
+			ARRAY_AND_SIZE(emeidkb_pwr_i2c_info_rev00));
+		pxa988_add_twsi(2, &emeidkb_pwr_i2c_pdata,
+				ARRAY_AND_SIZE(emeidkb_pwr_i2c_info_rev00));
+	} else {
+		pxa_init_i2c_gpio_irq(ARRAY_AND_SIZE(emeidkb_pwr_i2c_gpio),
+			ARRAY_AND_SIZE(emeidkb_pwr_i2c_info));
+		pxa988_add_twsi(2, &emeidkb_pwr_i2c_pdata,
+				ARRAY_AND_SIZE(emeidkb_pwr_i2c_info));
+	}
+
+#if defined(CONFIG_SENSORS_GP2A002S)
+	pxa_init_i2c_gpio_irq(ARRAY_AND_SIZE(i2c_gp2a_gpio),
+				ARRAY_AND_SIZE(i2c_gp2a));
+#endif
+#if defined (CONFIG_STC3115_FUELGAUGE)
+	 pxa_init_i2c_gpio_irq(ARRAY_AND_SIZE(stc3115_i2c_gpio),
+				ARRAY_AND_SIZE(stc3115_i2c_devices));
+#endif
+#if defined(CONFIG_SM5502_MUIC)
+	 pxa_init_i2c_gpio_irq(ARRAY_AND_SIZE(sm5502_i2c_gpio),
+				ARRAY_AND_SIZE(sm5502_i2c_devices));
+#endif
+#if defined(CONFIG_MFD_RT5033)
+	pxa986_golden_mfd_init();
+#endif
+#if defined(CONFIG_BATTERY_SAMSUNG)
+	pxa986_goya_battery_init();
+#endif
+	if ((board_id == 0x0) || (board_id >= 0x3)) {
+#if defined(CONFIG_BQ24157_CHARGER)
+         pxa_init_i2c_gpio_irq(ARRAY_AND_SIZE(bq24157_i2c_gpio),
+				ARRAY_AND_SIZE(bq24157_i2c_devices));
+#endif
+	} else {
+#if defined(CONFIG_I2C_RT9455)
+         pxa_init_i2c_gpio_irq(ARRAY_AND_SIZE(rt9455_i2c_gpio),
+				ARRAY_AND_SIZE(rt9455_i2c_devices));
+#endif
+	}
+
+	goya_input_init();
+
+#if defined (CONFIG_STC3115_FUELGAUGE)
+	platform_device_register(&i2c_stc3115_bus_device);
+	i2c_register_board_info(6, ARRAY_AND_SIZE(stc3115_i2c_devices));
+#endif
+#if defined(CONFIG_SM5502_MUIC)
+	platform_device_register(&i2c_sm5502_bus_device);
+	i2c_register_board_info(7, ARRAY_AND_SIZE(sm5502_i2c_devices));
+#endif
+
+#if defined(CONFIG_MFD_RT8973)
+        platform_device_register(&i2c_rt8973_bus_device);
+        i2c_register_board_info(7, ARRAY_AND_SIZE(rt8973_i2c_devices));
+#endif
+
+	if ((board_id == 0x0) || (board_id >= 0x3)) {
+#if defined(CONFIG_BQ24157_CHARGER)
+	platform_device_register(&i2c_bq24157_bus_device);
+	i2c_register_board_info(8, ARRAY_AND_SIZE(bq24157_i2c_devices));
+#endif
+	} else {
+#if defined(CONFIG_I2C_RT9455)
+	platform_device_register(&i2c_rt9455_bus_device);
+	i2c_register_board_info(8, ARRAY_AND_SIZE(rt9455_i2c_devices));
+#endif
+        }
+
+
+	/* add audio device: sram, ssp2, squ(tdma), pxa-ssp, mmp-pcm */
+	pxa988_add_asram(&pxa988_asram_info);
+	pxa988_add_ssp(1);
+	pxa988_add_ssp(4);
+	platform_device_register(&pxa988_device_squ);
+	platform_device_register(&pxa988_device_asoc_platform);
+	platform_device_register(&pxa988_device_asoc_ssp1);
+	platform_device_register(&pxa988_device_asoc_gssp);
+	platform_device_register(&pxa988_device_asoc_pcm);
+	platform_device_register(&emei_dkb_audio_device);
+#if 0
+	/* off-chip devices */
+	platform_add_devices(ARRAY_AND_SIZE(dkb_platform_devices));
+#endif
+#ifdef CONFIG_FB_PXA168
+	emeidkb_add_lcd_mipi();
+	if (has_feat_video_replace_graphics_dma())
+		emeidkb_add_tv_out();
+#endif
+
+#ifdef CONFIG_UIO_CODA7542
+	pxa_register_coda7542();
+#endif
+
+#ifdef CONFIG_USB_MV_UDC
+	pxa988_device_udc.dev.platform_data = &emeidkb_usb_pdata;
+	platform_device_register(&pxa988_device_udc);
+#endif
+
+#ifdef CONFIG_MACH_GOYA
+	/* For following apse codebase, I did not want to modify too many board-aruba files
+	 *  so I try to add a little code to apply to apse's code, such as mv_cam_pdata init.
+	 *  By Vincent Wan.
+	*/
+	//mv_cam_data_forssg.init_clk = pxa988_cam_clk_init,
+	//mv_cam_data_forssg.enable_clk = pxa988_cam_set_clk,
+	//init_samsung_cam();
+#endif
+
+#if 0
+#if defined(CONFIG_VIDEO_MMP)
+	pxa988_add_cam(&mv_cam_data);
+#endif
+
+#if defined(CONFIG_VIDEO_MVISP) && defined(CONFIG_UIO_MVISP)
+	pxa988_init_dxoisp();
+#endif
+#endif
+
+#ifdef CONFIG_LEDS_RT8547
+	platform_device_register(&leds_rt8547_device);
+#endif /* #ifdef CONFIG_LEDS_RT8547 */
+#if defined(CONFIG_SPA)
+        platform_device_register(&Sec_BattMonitor);
+#endif
+
+#if defined(CONFIG_SENSORS_ACCELOMETER_BMA25X) \
+ || defined(CONFIG_SENSORS_BMM050) \
+ || defined(CONFIG_SENSORS_GP2A002S) \
+ || defined(CONFIG_SENSORS_GP2A030) \
+ || defined(CONFIG_INPUT_MPU6500) \
+ || defined(CONFIG_SENSORS_HSCDTD008A) \
+ || defined(CONFIG_SENSORS_GP2A_PROXIMITY)
+	platform_device_register(&i2c_gpio_device);
+#endif
+
+#if defined(CONFIG_SENSORS_HSCDTD008A)
+	platform_device_register(&alps_pdata );
+#endif
+
+#if defined(CONFIG_SENSORS_ACCELOMETER_BMA25X)
+	i2c_register_board_info(5, &i2c_accelerometer_bma255, 1);
+#endif
+#if defined(CONFIG_SENSORS_GRIP_SX9500)
+	i2c_register_board_info(5, &i2c_grip_sx9500, 1);
+#endif
+#if defined(CONFIG_SENSORS_BMM050)
+	i2c_register_board_info(5, &i2c_bmm050, 1);
+#endif
+#if defined(CONFIG_SENSORS_GP2A002S) \
+ || defined(CONFIG_SENSORS_GP2A030) \
+ || defined(CONFIG_SENSORS_GP2A_PROXIMITY)
+	i2c_register_board_info(5, &i2c_gp2a, 1);
+#endif
+
+#if defined(CONFIG_INPUT_MPU6500)
+	pr_info("%s : system rev = %d\n", __func__, system_rev);
+	if (system_rev > 0)
+		i2c_mpu6500[0].platform_data = &mpu6500_pdata_rev01;
+	i2c_register_board_info(5, &i2c_mpu6500, 1);
+#endif
+#if defined(CONFIG_SENSORS_HSCDTD008A)
+	i2c_register_board_info(5, &i2c_hscd008a, 1);
+#endif
+
+#if defined(CONFIG_NFC_PN547)
+	platform_device_register(&i2c_gpio_device_nfc);
+	i2c_register_board_info(9, &i2c_pn547, 1);
+#endif
+
+#if !defined(CONFIG_INPUT_MPU6500)
+	waruba_enable_RF();
+#endif
+
+#ifdef CONFIG_VPU_DEVFREQ
+	pxa988_init_device_vpudevfreq();
+#endif
+
+#ifdef CONFIG_DDR_DEVFREQ
+	pxa988_init_device_ddrdevfreq();
+#endif
+
+#ifdef CONFIG_PXA9XX_ACIPC
+	platform_device_register(&pxa9xx_device_acipc);
+#endif
+#ifdef CONFIG_SEC_THERMISTOR
+	platform_device_register(&sec_device_thermistor);
+#endif
+	pxa988_add_thermal();
+
+#ifdef CONFIG_PROC_FS
+	/* create proc for gps GPS control */
+	create_sirf_proc_file();
+	/* create proc for gssp mfp control */
+	create_pcm_mfp_proc_file();
+#endif
+	/* add uart pad wakeup */
+	mmp_gpio_edge_add(&uart_rx_pad);
+	uart_lpm_cons.name = uart_cons_name;
+	pm_qos_add_request(&uart_lpm_cons,
+		PM_QOS_CPUIDLE_BLOCK, PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+	init_timer(&uart_constraint_timer);
+	uart_constraint_timer.function = uart_timer_handler;
+
+	/* If we have a full configuration then disable any regulators
+	 * which are not in use or always_on. */
+	regulator_has_full_constraints();
+}
+
+MACHINE_START(GOYA, "PXA988")
+	.map_io		= mmp_map_io,
+	.init_early	= pxa988_init_early,
+	.init_irq	= pxa988_init_irq,
+	.timer		= &pxa988_timer,
+	.reserve	= pxa988_reserve,
+	.handle_irq	= gic_handle_irq,
+	.init_machine	= emeidkb_init,
+	.restart	= mmp_arch_reset,
+MACHINE_END
diff --git a/arch/arm/mach-mmp/board-goya.h b/arch/arm/mach-mmp/board-goya.h
new file mode 100755
index 00000000..ebba3363
--- /dev/null
+++ b/arch/arm/mach-mmp/board-goya.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2012 Samsung Electronics Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __MACH_MARVELL_BOARD_GOYA_H
+#define __MACH_MARVELL_BOARD_GOYA_H
+
+/** @category input devices*/
+void goya_input_init(void);
+
+#if defined(CONFIG_BATTERY_SAMSUNG)
+#include <linux/battery/sec_charging_common.h>
+extern int current_cable_type;
+extern sec_battery_platform_data_t sec_battery_pdata;
+
+
+void pxa986_goya_battery_init(void);
+
+#ifdef CONFIG_MFD_RT5033
+void pxa986_golden_mfd_init(void);
+#endif
+
+void sec_charger_cb(u8 attached);
+
+extern sec_battery_platform_data_t sec_battery_pdata;
+#endif
+#endif
diff --git a/arch/arm/mach-mmp/boost.c b/arch/arm/mach-mmp/boost.c
new file mode 100644
index 00000000..6ce82262
--- /dev/null
+++ b/arch/arm/mach-mmp/boost.c
@@ -0,0 +1,200 @@
+/*
+ *  Input touch boost feature support
+ *
+ *  Copyright (c) 2012 Marvell
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/pm_qos.h>
+#include <linux/slab.h>
+#include <linux/debugfs.h>
+#ifdef CONFIG_PM_DEVFREQ
+#include <plat/devfreq.h>
+#endif
+
+/* boost cpu to max frequency 200ms by default */
+#define CPU_BOOST_TIME		100000
+static struct pm_qos_request touchboost_cpu_qos_min = {
+	.name = "touch_boost",
+};
+static struct pm_qos_request touchboost_ddr_qos_min = {
+	.name = "touch_boost",
+};
+static struct pm_qos_request touchboost_gpu2d_qos_min = {
+	.name = "touch_boost",
+};
+static struct pm_qos_request touchboost_gpu3d_qos_min = {
+	.name = "touch_boost",
+};
+
+static unsigned int touch_boost_enabled = 1;
+static struct work_struct touchboost_wk;
+
+/*
+ * The reason why we use workqueue here is input event report handler
+ * is called in irq disable content, but core freq-chg related function
+ * cpufreq_notify_transition request irq is enabled.
+ * Call chain as below:
+ * input_event(irq disable here) -> input_handle_event-> input_pass_event->
+ * handler->event(handle, type, code, value) = touchboost_event->
+ * touchboost_work
+ */
+static void touchboost_work(struct work_struct *w)
+{
+
+	pm_qos_update_request_timeout(&touchboost_cpu_qos_min,
+			LONG_MAX, CPU_BOOST_TIME);
+	pm_qos_update_request_timeout(&touchboost_ddr_qos_min,
+			DDR_CONSTRAINT_LVL2, CPU_BOOST_TIME);
+	/* boost gpu0(3D) to max frequency 624000KHz*/
+	pm_qos_update_request_timeout(&touchboost_gpu3d_qos_min,
+			624000, CPU_BOOST_TIME);
+	/* boost gpu1(2D) to max frequency 416000KHz*/
+	pm_qos_update_request_timeout(&touchboost_gpu2d_qos_min,
+			416000, CPU_BOOST_TIME);
+
+}
+
+static void keyboost_event(struct input_handle *handle, unsigned int type,
+		unsigned int code, int value)
+{
+	if (touch_boost_enabled && type == EV_KEY && value == 1)
+		schedule_work(&touchboost_wk);
+}
+
+static void touchboost_event(struct input_handle *handle, unsigned int type,
+		unsigned int code, int value)
+{
+	if (touch_boost_enabled && code == ABS_MT_TRACKING_ID && value != 0xffffffff)
+		schedule_work(&touchboost_wk);
+}
+
+static int touchboost_connect(struct input_handler *handler,
+				  struct input_dev *dev,
+				  const struct input_device_id *id)
+{
+	struct input_handle *handle;
+	int error;
+
+	pr_info("%s: connect to %s\n", __func__, dev->name);
+	handle = kzalloc(sizeof(struct input_handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = "touch_boost";
+
+	error = input_register_handle(handle);
+	if (error) {
+		pr_err("Failed to register touch boost handler, error %d\n",
+		       error);
+		goto err;
+	}
+
+	error = input_open_device(handle);
+	if (error) {
+		pr_err("Failed to open touch boost device, error %d\n", error);
+		input_unregister_handle(handle);
+		goto err;
+	}
+
+	return 0;
+err:
+	kfree(handle);
+	return error;
+}
+
+static void touchboost_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+static const struct input_device_id touchboost_ids[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
+		    INPUT_DEVICE_ID_MATCH_ABSBIT,
+		.evbit = { BIT_MASK(EV_ABS) },
+		.absbit = { [BIT_WORD(ABS_MT_POSITION_X)] =
+		       BIT_MASK(ABS_MT_POSITION_X) |
+		       BIT_MASK(ABS_MT_POSITION_Y) },
+	}, /* multi-touch touchscreen */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_KEYBIT |
+		    INPUT_DEVICE_ID_MATCH_ABSBIT,
+		.keybit = { [BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH) },
+		.absbit = { [BIT_WORD(ABS_X)] =
+		       BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) },
+	}, /* touchpad */
+	{ },
+};
+
+static const struct input_device_id keyboost_ids[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_KEYBIT |
+		    INPUT_DEVICE_ID_MATCH_ABSBIT,
+		.evbit = { BIT_MASK(EV_KEY)},
+	}, /* keyboard */
+};
+
+static struct input_handler touchboost_handler = {
+	.event =	touchboost_event,
+	.connect =	touchboost_connect,
+	.disconnect =	touchboost_disconnect,
+	.name =		"touch_boost",
+	.id_table =	touchboost_ids,
+};
+
+static struct input_handler keyboost_handler = {
+	.event =	keyboost_event,
+	.connect =	touchboost_connect,
+	.disconnect =	touchboost_disconnect,
+	.name =		"key_boost",
+	.id_table =	keyboost_ids,
+};
+
+static int __init boost_init(void)
+{
+	int ret;
+	pm_qos_add_request(&touchboost_cpu_qos_min,
+		PM_QOS_CPUFREQ_MIN, PM_QOS_DEFAULT_VALUE);
+	pm_qos_add_request(&touchboost_ddr_qos_min,
+		   PM_QOS_DDR_DEVFREQ_MIN, PM_QOS_DEFAULT_VALUE);
+	pm_qos_add_request(&touchboost_gpu3d_qos_min,
+		   PM_QOS_GPUFREQ_3D_MIN, PM_QOS_DEFAULT_VALUE);
+	pm_qos_add_request(&touchboost_gpu2d_qos_min,
+		   PM_QOS_GPUFREQ_2D_MIN, PM_QOS_DEFAULT_VALUE);
+	INIT_WORK(&touchboost_wk, touchboost_work);
+#ifdef CONFIG_DEBUG_FS
+	debugfs_create_u32("touchbst_enable", 0644, NULL,
+		&touch_boost_enabled);
+#endif
+	ret = input_register_handler(&touchboost_handler);
+	if (ret)
+		pr_err("touchboost_handler register failed");
+	return input_register_handler(&keyboost_handler);
+}
+
+static void __exit boost_exit(void)
+{
+	flush_work(&touchboost_wk);
+	input_unregister_handler(&touchboost_handler);
+	pm_qos_remove_request(&touchboost_cpu_qos_min);
+}
+
+module_init(boost_init);
+module_exit(boost_exit);
+
+MODULE_DESCRIPTION("Input touch boost feature support for Marvell MMP");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mmp/clock-pxa988.c b/arch/arm/mach-mmp/clock-pxa988.c
new file mode 100644
index 00000000..5e4e9560
--- /dev/null
+++ b/arch/arm/mach-mmp/clock-pxa988.c
@@ -0,0 +1,4955 @@
+/*
+ *  linux/arch/arm/mach-mmp/clock-pxa988.c
+ *
+ *  Author:	Zhoujie Wu <zjwu@marvell.com>
+ *		Raul Xiong <xjian@marvell.com>
+ *  Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ *  based on arch/arm/mach-tegra/tegra2_clocks.c
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+
+#include <mach/regs-apbc.h>
+#include <mach/regs-apmu.h>
+#include <mach/regs-mpmu.h>
+#include <mach/regs-ciu.h>
+#include <mach/cputype.h>
+#include <mach/features.h>
+#include <mach/clock-pxa988.h>
+#include <mach/pxa168fb.h>
+#include <plat/pxa_trace.h>
+#include <plat/clock.h>
+#include <plat/debugfs.h>
+#include <plat/pm.h>
+#include <plat/devfreq.h>
+
+#define MHZ_TO_HZ	(1000000UL)
+#define MHZ_TO_KHZ	(1000)
+static unsigned long pll2_vco_default;
+static unsigned long pll2_default;
+static unsigned long pll2p_default;
+static unsigned long pll3_vco_default;
+static unsigned long pll3_default;
+static unsigned long pll3p_default;
+
+unsigned long max_freq;
+
+static int __init max_freq_setup(char *str)
+{
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	max_freq = n;
+	return 1;
+}
+__setup("max_freq=", max_freq_setup);
+
+/*
+ * uboot pass pll3_vco = xxx (unit is Mhz), it is used
+ * to distinguish whether core and display can share pll3.
+ * if core can use it, core max_freq is setup, else core
+ * will not use pll3p, pll3 will only be used by display
+*/
+static int __init pll3_vco_value_setup(char *str)
+{
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	pll3_vco_default = n * MHZ_TO_HZ;
+	return 1;
+}
+__setup("pll3_vco=", pll3_vco_value_setup);
+
+static int __clk_periph_set_rate(struct clk *clk, unsigned long rate);
+static unsigned long __clk_periph_get_rate(struct clk *clk);
+/*
+ * README:
+ * 1. For clk which has fc_request bit, two step operation
+ * is safer to enable clock with taget frequency
+ * 1) set enable&rst bit
+ * 2) set mux, div and fc to do FC, get target rate.
+ */
+
+struct periph_clk_tbl {
+	unsigned long clk_rate;	/* clk rate */
+	struct clk	*parent;/* clk parent */
+	unsigned long src_val;	/* clk src field reg val */
+	unsigned long div_val;	/* clk div field reg val */
+
+	/* combined clck rate, such as bus clk that will changed with fclk */
+	unsigned long comclk_rate;
+	unsigned long rtcwtc;
+};
+
+struct xpu_rtcwtc {
+	unsigned long max_rate;
+	unsigned long rtcwtc;
+};
+
+
+union pmum_pll2cr {
+	struct {
+		unsigned int reserved0:6;
+		unsigned int reserved1:2;
+		unsigned int en:1;
+		unsigned int ctrl:1;
+		unsigned int pll2fbd:9;
+		unsigned int pll2refd:5;
+		unsigned int reserved2:8;
+	} b;
+	unsigned int v;
+};
+
+union pmum_pll3cr {
+	struct {
+		unsigned int pll3refd:5;
+		unsigned int pll3fbd:9;
+		unsigned int reserved0:4;
+		unsigned int pclk_1248_sel:1;
+		unsigned int pll3_pu:1;
+		unsigned int reserved1:12;
+	} b;
+	unsigned int v;
+};
+
+union apb_spare_pllswcr {
+	struct {
+		unsigned int lineupen:1;
+		unsigned int gatectl:1;
+		unsigned int bypassen:1;
+		unsigned int diffclken:1;
+		unsigned int divselse:4;
+		unsigned int divseldiff:4;
+		unsigned int ctune:2;
+		unsigned int vcovnrg:3;
+		unsigned int kvco:4;
+		unsigned int icp:3;
+		unsigned int vreg_ivreg:2;
+		unsigned int vddl:4;
+		unsigned int vddm:2;
+	} b;
+	unsigned int v;
+};
+
+/*
+ * peripheral clock source:
+ * 0x0 = PLL1 416 MHz
+ * 0x1 = PLL1 624 MHz
+ * 0x2 = PLL2_CLKOUT
+ * 0x3 = PLL2_CLKOUTP
+ */
+enum periph_clk_src {
+	CLK_PLL1_416 = 0x0,
+	CLK_PLL1_624 = 0x1,
+	CLK_PLL2 = 0x2,
+	CLK_PLL2P = 0x3,
+};
+
+struct pll_post_div {
+	unsigned int div;	/* PLL divider value */
+	unsigned int divselval;	/* PLL corresonding reg setting */
+};
+
+#define APB_SPARE_PLL2CR	(APB_VIRT_BASE + 0x90104)
+#define APB_SPARE_PLL3CR	(APB_VIRT_BASE + 0x90108)
+#define POSR_PLL2_LOCK		(1 << 29)
+#define POSR_PLL3_LOCK		(1 << 30)
+
+static DEFINE_SPINLOCK(ccic_lock);
+static DEFINE_SPINLOCK(lcd_ci_share_lock);
+static DEFINE_SPINLOCK(pll2_lock);
+static DEFINE_SPINLOCK(pll3_lock);
+static DEFINE_SPINLOCK(gc_lock);
+static DEFINE_SPINLOCK(vpu_lock);
+
+#ifdef CONFIG_DEBUG_FS
+static LIST_HEAD(clk_dcstat_list);
+#endif
+
+/* PLL post divider table */
+static struct pll_post_div pll_post_div_tbl[] = {
+	/* divider, reg vaule */
+	{1, 0},
+	{2, 2},
+	{3, 4},
+	{4, 5},
+	{6, 7},
+	{8, 8},
+};
+
+#define CLK_SET_BITS(set, clear)	{	\
+	unsigned long tmp;			\
+	tmp = __raw_readl(clk->clk_rst);	\
+	tmp &= ~(clear);			\
+	tmp |= (set);				\
+	__raw_writel(tmp, clk->clk_rst);	\
+}						\
+
+static struct clk ref_vco = {
+	.name = "ref_vco",
+	.rate = 26000000,
+	.ops = NULL,
+};
+
+static struct clk pll1_416 = {
+	.name = "pll1_416",
+	.rate = 416000000,
+	.ops = NULL,
+};
+
+static struct clk pll1_624 = {
+	.name = "pll1_624",
+	.rate = 624000000,
+	.ops = NULL,
+};
+
+static struct clk pll1_1248 = {
+	.name = "pll1_1248",
+	.rate = 1248000000,
+	.ops = NULL,
+};
+
+static int gate_clk_enable(struct clk *clk)
+{
+	CLK_SET_BITS(clk->enable_val, 0);
+	return 0;
+}
+
+static void gate_clk_disable(struct clk *clk)
+{
+	CLK_SET_BITS(0, clk->enable_val);
+}
+
+struct clkops gate_clk_ops = {
+	.enable		= gate_clk_enable,
+	.disable	= gate_clk_disable,
+};
+
+#define DEFINE_GATE_CLK(_name, _reg, _eval, _dev_id, _con_id)	\
+	static struct clk _name = {				\
+		.name = #_name,					\
+		.clk_rst = (void __iomem *)_reg,		\
+		.enable_val = _eval,				\
+		.ops = &gate_clk_ops,				\
+		.lookup = {					\
+			.dev_id = _dev_id,			\
+			.con_id = _con_id,			\
+		},						\
+	}							\
+
+static int apbc_clk_enable(struct clk *clk)
+{
+	unsigned int data;
+
+	data = __raw_readl(clk->clk_rst) & ~(APBC_FNCLKSEL(7));
+	data |= APBC_FNCLK | APBC_FNCLKSEL(clk->fnclksel);
+	__raw_writel(data, clk->clk_rst);
+
+	/*
+	 * delay two cycles of the solwest clock between the APB bus clock
+	 * and the functional module clock.
+	 */
+	udelay(10);
+
+	data |= APBC_APBCLK;
+	__raw_writel(data, clk->clk_rst);
+	udelay(10);
+
+	data &= ~APBC_RST;
+	__raw_writel(data, clk->clk_rst);
+
+	return 0;
+}
+
+static void apbc_clk_disable(struct clk *clk)
+{
+	unsigned int data;
+
+	data = __raw_readl(clk->clk_rst) & ~(APBC_FNCLK | APBC_FNCLKSEL(7));
+	__raw_writel(data, clk->clk_rst);
+	udelay(10);
+
+	data &= ~APBC_APBCLK;
+	__raw_writel(data, clk->clk_rst);
+}
+
+struct clkops apbc_clk_ops = {
+	.enable		= apbc_clk_enable,
+	.disable	= apbc_clk_disable,
+};
+
+static int apmu_clk_enable(struct clk *clk)
+{
+	__raw_writel(clk->enable_val, clk->clk_rst);
+	return 0;
+}
+
+static void apmu_clk_disable(struct clk *clk)
+{
+	__raw_writel(0, clk->clk_rst);
+}
+
+static int apmu_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	__raw_writel(rate, clk->clk_rst);
+	return 0;
+}
+
+struct clkops apmu_clk_ops = {
+	.enable = apmu_clk_enable,
+	.disable = apmu_clk_disable,
+	.setrate = apmu_clk_setrate,
+};
+
+/* convert post div reg setting to divider val */
+static unsigned int __pll_divsel2div(unsigned int divselval)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(pll_post_div_tbl); i++) {
+		if (divselval == pll_post_div_tbl[i].divselval)
+			return pll_post_div_tbl[i].div;
+	}
+	BUG_ON(i == ARRAY_SIZE(pll_post_div_tbl));
+	return 0;
+}
+
+/* PLL range 1.2G~2.5G, vco_vrng = kvco */
+static void __clk_pll_rate2rng(unsigned long rate,
+	unsigned int *kvco, unsigned int *vco_rng)
+{
+	if (rate >= 2400 && rate <= 2500)
+		*kvco = 7;
+	else if (rate >= 2150)
+		*kvco = 6;
+	else if (rate >= 1950)
+		*kvco = 5;
+	else if (rate >= 1750)
+		*kvco = 4;
+	else if (rate >= 1550)
+		*kvco = 3;
+	else if (rate >= 1350)
+		*kvco = 2;
+	else if (rate >= 1200)
+		*kvco = 1;
+	else
+		pr_info("%s rate %lu out of range!\n",
+			__func__, rate);
+
+	*vco_rng = *kvco;
+}
+
+static unsigned int __clk_pll_calc_div(unsigned long rate,
+	unsigned long parent_rate, unsigned int *div)
+{
+	unsigned int i;
+	*div = 0;
+
+	rate /= MHZ_TO_HZ;
+	parent_rate /= MHZ_TO_HZ;
+
+	for (i = 0; i < ARRAY_SIZE(pll_post_div_tbl); i++) {
+		if (rate == (parent_rate / pll_post_div_tbl[i].div)) {
+			*div = pll_post_div_tbl[i].div;
+			return pll_post_div_tbl[i].divselval;
+		}
+	}
+	BUG_ON(i == ARRAY_SIZE(pll_post_div_tbl));
+	return 0;
+}
+
+static unsigned int __pll2_is_enabled(void)
+{
+	union pmum_pll2cr pll2cr;
+	pll2cr.v = __raw_readl(MPMU_PLL2CR);
+
+	/* ctrl = 0(hw enable) or ctrl = 1&&en = 1(sw enable) */
+	/* ctrl = 1&&en = 0(sw disable) */
+	if (pll2cr.b.ctrl && (!pll2cr.b.en))
+		return 0;
+	else
+		return 1;
+}
+
+/* frequency unit Mhz, return pll2 vco freq */
+static unsigned int __get_pll2_freq(unsigned int *pll2_freq,
+			unsigned int *pll2p_freq)
+{
+	union pmum_pll2cr pll2cr;
+	union apb_spare_pllswcr pll2_sw_ctl;
+	unsigned int pll2_vco, pll2_div, pll2p_div, pll2refd;
+
+	/* return 0 if pll2 is disabled(ctrl = 1, en = 0) */
+	if (!__pll2_is_enabled()) {
+		pr_info("%s PLL2 is not enabled!\n", __func__);
+		*pll2_freq = 0;
+		*pll2p_freq = 0;
+		return 0;
+	}
+
+	pll2cr.v = __raw_readl(MPMU_PLL2CR);
+	pll2refd = pll2cr.b.pll2refd;
+	BUG_ON(pll2refd == 1);
+
+	if (pll2refd == 0)
+		pll2refd = 1;
+	pll2_vco = DIV_ROUND_UP(26 * pll2cr.b.pll2fbd, pll2refd);
+
+	pll2_sw_ctl.v = __raw_readl(APB_SPARE_PLL2CR);
+	pll2_div = __pll_divsel2div(pll2_sw_ctl.b.divselse);
+	pll2p_div = __pll_divsel2div(pll2_sw_ctl.b.divseldiff);
+	*pll2_freq = pll2_vco / pll2_div;
+	*pll2p_freq = pll2_vco / pll2p_div;
+
+	return pll2_vco;
+}
+
+/*
+ * 1. Whenever PLL2 is enabled, ensure it's set as HW activation.
+ * 2. When PLL2 is disabled (no one uses PLL2 as source),
+ * set it as SW activation.
+ */
+static void clk_pll2_vco_init(struct clk *clk)
+{
+	unsigned int pll2, pll2p, pll2vco;
+	unsigned int pll2_rngl, pll2_rngh, tmp;
+
+	BUG_ON(!pll2_vco_default);
+	clk->rate = pll2_vco_default;
+	if (__pll2_is_enabled()) {
+		pll2vco = __get_pll2_freq(&pll2, &pll2p);
+		pr_info("PLL2_VCO is already enabled @ %lu, Expected @ %lu\n",
+			pll2vco * MHZ_TO_HZ, pll2_vco_default);
+		/* check whether pll2 is in the range of 2% our expectation */
+		tmp = pll2_vco_default / MHZ_TO_HZ;
+		if (tmp != pll2vco) {
+			pll2_rngh = tmp + tmp * 2 / 100;
+			pll2_rngl = tmp - tmp * 2 / 100;
+			BUG_ON(!((pll2_rngl <= pll2vco) && \
+				(pll2vco <= pll2_rngh)));
+		}
+		return;
+	}
+	pr_info("PLL2 VCO default rate %lu\n", clk->rate);
+}
+
+static int clk_pll2_vco_enable(struct clk *clk)
+{
+	union pmum_pll2cr pll2cr;
+	unsigned long flags;
+	unsigned int delaytime = 14;
+
+	if (__pll2_is_enabled())
+		return 0;
+
+	spin_lock_irqsave(&pll2_lock, flags);
+
+	pll2cr.v = __raw_readl(MPMU_PLL2CR);
+	/* we must lock refd/fbd first before enabling PLL2 */
+	pll2cr.b.ctrl = 1;
+	__raw_writel(pll2cr.v, MPMU_PLL2CR);
+	pll2cr.b.ctrl = 0;	/* Let HW control PLL2 */
+	__raw_writel(pll2cr.v, MPMU_PLL2CR);
+
+	spin_unlock_irqrestore(&pll2_lock, flags);
+
+	if (has_feat_pll_lock_signal()) {
+		udelay(30);
+		while ((!(__raw_readl(MPMU_POSR) & POSR_PLL2_LOCK)) &&\
+			delaytime) {
+			udelay(5); delaytime--;
+		}
+		if (unlikely(!delaytime))
+			BUG_ON("PLL2 is NOT locked after 100us enable!\n");
+	} else
+		udelay(100);
+
+	trace_pxa_pll_vco_enable(2, __raw_readl(APB_SPARE_PLL2CR), pll2cr.v);
+	pr_debug("%s SWCR[%x] PLLCR[%x]\n", __func__, \
+		__raw_readl(APB_SPARE_PLL2CR), pll2cr.v);
+	return 0;
+}
+
+static void clk_pll2_vco_disable(struct clk *clk)
+{
+	union pmum_pll2cr pll2cr;
+
+	/* For Z1/2 safe PP solution, never shutdown pll2 */
+	if (cpu_is_z1z2())
+		return;
+
+	pr_debug("Disable pll2 as it is not used!\n");
+	trace_pxa_pll_vco_disable(2);
+
+	pll2cr.v = __raw_readl(MPMU_PLL2CR);
+	pll2cr.b.ctrl = 1;	/* Let SW control PLL2 */
+	pll2cr.b.en = 0;	/* disable PLL2 by en bit */
+	__raw_writel(pll2cr.v, MPMU_PLL2CR);
+}
+
+/*
+ * pll2 rate change requires sequence:
+ * clock off -> change rate setting -> clock on
+ * This function doesn't really change rate, but cache the config
+ */
+static int clk_pll2_vco_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned int kvco, vcovnrg;
+	union pmum_pll2cr pll2cr;
+	union apb_spare_pllswcr pll2_sw_ctrl;
+	unsigned long flags, cur_rate;
+
+	if (__pll2_is_enabled()) {
+		pr_info("%s pll2 vco is enabled, tgt rate %lu\n",\
+			__func__, rate);
+		return -EPERM;
+	}
+
+	rate = rate / MHZ_TO_HZ;
+	if (rate > 2500 || rate < 1200)	{
+		pr_err("%lu rate out of range!\n", rate);
+		return -EINVAL;
+	}
+
+	pr_debug("PLL2_VCO rate %lu -> %lu\n",
+		clk->rate/MHZ_TO_HZ, rate);
+
+	spin_lock_irqsave(&pll2_lock, flags);
+	__clk_pll_rate2rng(rate, &kvco, &vcovnrg);
+
+	/* The default configuration of pll2 */
+	pll2_sw_ctrl.v = __raw_readl(APB_SPARE_PLL2CR);
+	pll2_sw_ctrl.b.vddm = 1;
+	pll2_sw_ctrl.b.vddl = 9;
+	pll2_sw_ctrl.b.vreg_ivreg = 2;
+	pll2_sw_ctrl.b.icp = 4;
+	pll2_sw_ctrl.b.ctune = 1;
+	pll2_sw_ctrl.b.bypassen = 0;
+	pll2_sw_ctrl.b.gatectl = 0;
+	pll2_sw_ctrl.b.lineupen = 0;
+	pll2_sw_ctrl.b.diffclken = 1;
+	pll2_sw_ctrl.b.kvco = kvco;
+	pll2_sw_ctrl.b.vcovnrg = vcovnrg;
+	__raw_writel(pll2_sw_ctrl.v, APB_SPARE_PLL2CR);
+
+	/* Refclk/Refdiv = pll2freq/Fbdiv Refclk = 26M */
+	pll2cr.v = __raw_readl(MPMU_PLL2CR);
+	pll2cr.b.pll2refd = 3;
+	pll2cr.b.pll2fbd = rate * pll2cr.b.pll2refd / 26;
+	pll2cr.b.ctrl = 1;
+	pll2cr.b.en = 0;
+	__raw_writel(pll2cr.v, MPMU_PLL2CR);
+
+	clk->rate = rate * MHZ_TO_HZ;
+	spin_unlock_irqrestore(&pll2_lock, flags);
+
+	cur_rate = 26 * pll2cr.b.pll2fbd / pll2cr.b.pll2refd;
+	if (cur_rate != rate)
+		pr_warning("Real PLL2 rate %luMHZ\n", cur_rate);
+	return 0;
+}
+
+static unsigned long clk_pll2_vco_getrate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+static struct clkops clk_pll2_vco_ops = {
+	.init = clk_pll2_vco_init,
+	.enable = clk_pll2_vco_enable,
+	.disable = clk_pll2_vco_disable,
+	.setrate = clk_pll2_vco_setrate,
+	.getrate = clk_pll2_vco_getrate,
+};
+
+static struct clk pll2_vco = {
+	.name = "pll2_vco",
+	.parent = &ref_vco,
+	.ops = &clk_pll2_vco_ops,
+};
+
+/* do nothing only used to adjust proper clk->refcnt */
+static int clk_pll_dummy_enable(struct clk *clk)
+{
+	return 0;
+}
+
+static void clk_pll_dummy_disable(struct clk *clk)
+{
+}
+
+static void clk_pll2_init(struct clk *clk)
+{
+	unsigned int pll2, pll2p;
+
+	BUG_ON(!pll2_default);
+	clk->rate = pll2_default;
+	if (__pll2_is_enabled()) {
+		__get_pll2_freq(&pll2, &pll2p);
+		pr_info("PLL2 is already enabled @ %lu\n",
+			pll2 * MHZ_TO_HZ);
+		return;
+	}
+	pr_info("PLL2 default rate %lu\n", clk->rate);
+}
+
+static int clk_pll2_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned int div_val;
+	union apb_spare_pllswcr pll2_sw_ctrl;
+	unsigned long flags;
+
+	if (__pll2_is_enabled())
+		return -EPERM;
+
+	pr_debug("PLL2 rate %lu -> %lu\n", clk->rate, rate);
+
+	spin_lock_irqsave(&pll2_lock, flags);
+	div_val = __clk_pll_calc_div(rate, clk->parent->rate, &clk->div);
+	pll2_sw_ctrl.v = __raw_readl(APB_SPARE_PLL2CR);
+	pll2_sw_ctrl.b.divselse = div_val;
+	__raw_writel(pll2_sw_ctrl.v, APB_SPARE_PLL2CR);
+	clk->rate = rate;
+	spin_unlock_irqrestore(&pll2_lock, flags);
+	return 0;
+}
+
+static unsigned long clk_pll2_getrate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+static struct clkops clk_pll2_ops = {
+	.init = clk_pll2_init,
+	.enable = clk_pll_dummy_enable,
+	.disable = clk_pll_dummy_disable,
+	.setrate = clk_pll2_setrate,
+	.getrate = clk_pll2_getrate,
+};
+
+static struct clk pll2 = {
+	.name = "pll2",
+	.parent = &pll2_vco,
+	.ops = &clk_pll2_ops,
+};
+
+static void clk_pll2p_init(struct clk *clk)
+{
+	unsigned int pll2, pll2p;
+
+	BUG_ON(!pll2p_default);
+	clk->rate = pll2p_default;
+	if (__pll2_is_enabled()) {
+		__get_pll2_freq(&pll2, &pll2p);
+		pr_info("PLL2P is already enabled @ %lu\n",
+			pll2p * MHZ_TO_HZ);
+		return;
+	}
+	pr_info("PLL2P default rate %lu\n", clk->rate);
+}
+
+static int clk_pll2p_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned int div_val;
+	union apb_spare_pllswcr pll2_sw_ctrl;
+	unsigned long flags;
+
+	if (__pll2_is_enabled())
+		return -EPERM;
+
+	pr_debug("PLL2P rate %lu -> %lu\n", clk->rate, rate);
+
+	spin_lock_irqsave(&pll2_lock, flags);
+	div_val = __clk_pll_calc_div(rate, clk->parent->rate, &clk->div);
+	pll2_sw_ctrl.v = __raw_readl(APB_SPARE_PLL2CR);
+	pll2_sw_ctrl.b.divseldiff = div_val;
+	__raw_writel(pll2_sw_ctrl.v, APB_SPARE_PLL2CR);
+	clk->rate = rate;
+	spin_unlock_irqrestore(&pll2_lock, flags);
+	return 0;
+}
+
+static unsigned long clk_pll2p_getrate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+static struct clkops clk_pll2p_ops = {
+	.init = clk_pll2p_init,
+	.enable = clk_pll_dummy_enable,
+	.disable = clk_pll_dummy_disable,
+	.setrate = clk_pll2p_setrate,
+	.getrate = clk_pll2p_getrate,
+};
+
+static struct clk pll2p = {
+	.name = "pll2p",
+	.parent = &pll2_vco,
+	.ops = &clk_pll2p_ops,
+};
+
+static inline int pll3_best_mul(unsigned long rate)
+{
+	int i;
+	unsigned long vco;
+	for (i = 0; i < ARRAY_SIZE(pll_post_div_tbl); i++) {
+		vco = rate * pll_post_div_tbl[i].div;
+		if ((vco > 1200 * MHZ_TO_HZ) && (vco < 2500 * MHZ_TO_HZ))
+			break;
+	}
+	if (i == ARRAY_SIZE(pll_post_div_tbl)) {
+		printk(KERN_ERR "Multiplier is out of range!\n");
+		return -1;
+	}
+	return pll_post_div_tbl[i].div;
+}
+
+static unsigned int __pll3_is_enabled(void)
+{
+	union pmum_pll3cr pll3cr;
+	pll3cr.v = __raw_readl(MPMU_PLL3CR);
+
+	/*
+	 * PLL3CR[19:18] = 0x1, 0x2, 0x3 means PLL3 is enabled.
+	 * PLL3CR[19:18] = 0x0 means PLL3 is disabled
+	 */
+#if !defined(CONFIG_CORE_1248)
+	if ((!pll3cr.b.pll3_pu) && (!pll3cr.b.pclk_1248_sel))
+#else
+	if (!pll3cr.b.pll3_pu)
+#endif
+		return 0;
+	else
+		return 1;
+}
+
+/* frequency unit Mhz, return pll3 vco freq */
+static unsigned int __get_pll3_freq(unsigned int *pll3_freq,
+	unsigned int *pll3p_freq)
+{
+	union pmum_pll3cr pll3cr;
+	union apb_spare_pllswcr pll3_sw_ctl;
+	unsigned int pll3_vco, pll3_div, pll3p_div, pll3refd;
+
+	/* return 0 if pll3 is disabled */
+	if (!__pll3_is_enabled()) {
+		pr_info("%s PLL3 is not enabled!\n", __func__);
+		*pll3_freq = 0;
+		*pll3p_freq = 0;
+		return 0;
+	}
+
+	pll3cr.v = __raw_readl(MPMU_PLL3CR);
+	pll3refd = pll3cr.b.pll3refd;
+	BUG_ON(pll3refd == 1);
+	if (pll3refd == 0)
+		pll3refd = 1;
+	pll3_vco = 26 * pll3cr.b.pll3fbd / pll3refd;
+
+	pll3_sw_ctl.v = __raw_readl(APB_SPARE_PLL3CR);
+	pll3_div = __pll_divsel2div(pll3_sw_ctl.b.divselse);
+	pll3p_div = __pll_divsel2div(pll3_sw_ctl.b.divseldiff);
+	*pll3_freq = pll3_vco / pll3_div;
+	*pll3p_freq = pll3_vco / pll3p_div;
+
+	return pll3_vco;
+}
+
+static void clk_pll3_vco_init(struct clk *clk)
+{
+	unsigned int pll3, pll3p, pll3vco;
+
+	BUG_ON(!pll3_vco_default);
+	clk->rate = pll3_vco_default;
+	if (__pll3_is_enabled()) {
+		pll3vco = __get_pll3_freq(&pll3, &pll3p);
+		pr_info("PLL3_VCO is already enabled @ %lu\n",
+			pll3vco * MHZ_TO_HZ);
+		return;
+	}
+	pr_info("PLL3 VCO default rate %lu\n", clk->rate);
+}
+
+/* PLL3CR[19:18] = 0x0 shutdown */
+/* PLL3CR[19:18] = 0x3 enable */
+static int clk_pll3_vco_enable(struct clk *clk)
+{
+	union pmum_pll3cr pll3cr;
+	unsigned long flags;
+	unsigned int delaytime = 194, val; /* max delay 1000 us */
+
+	if (__pll3_is_enabled())
+		return 0;
+
+	spin_lock_irqsave(&pll3_lock, flags);
+	pll3cr.v = __raw_readl(MPMU_PLL3CR);
+#if !defined(CONFIG_CORE_1248)
+	pll3cr.b.pclk_1248_sel = 1;
+#endif
+	pll3cr.b.pll3_pu = 1;
+	__raw_writel(pll3cr.v, MPMU_PLL3CR);
+	spin_unlock_irqrestore(&pll3_lock, flags);
+
+	udelay(30);
+	val = __raw_readl(MPMU_POSR);
+	while ((!(val & POSR_PLL3_LOCK)) && delaytime) {
+		udelay(5);
+		delaytime--;
+		val = __raw_readl(MPMU_POSR);
+	}
+	if (unlikely(!delaytime)) {
+		pr_err("PLL3 is NOT locked after 1000us enable!\
+			MPMU_POSR: 0x%X\n", val);
+		BUG_ON(1);
+	}
+	trace_pxa_pll_vco_enable(3, __raw_readl(APB_SPARE_PLL3CR), pll3cr.v);
+	pr_debug("%s SWCR3[%x] PLL3CR[%x]\n", __func__, \
+		__raw_readl(APB_SPARE_PLL3CR), pll3cr.v);
+	return 0;
+}
+
+static void clk_pll3_vco_disable(struct clk *clk)
+{
+	union pmum_pll3cr pll3cr;
+
+	pr_debug("Disable pll3 as it is not used!\n");
+	trace_pxa_pll_vco_disable(3);
+
+	pll3cr.v = __raw_readl(MPMU_PLL3CR);
+	pll3cr.b.pclk_1248_sel = 0;
+	pll3cr.b.pll3_pu = 0;
+	__raw_writel(pll3cr.v, MPMU_PLL3CR);
+}
+
+static int clk_pll3_vco_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned int kvco, vcovnrg;
+	union pmum_pll3cr pll3cr;
+	union apb_spare_pllswcr pll3_sw_ctrl;
+	unsigned long flags, cur_rate;
+
+	/* do nothing if pll3 is already enabled or no rate change */
+	if (__pll3_is_enabled()) {
+		pr_info("%s pll3 vco is enabled, tgt rate %lu\n",\
+			__func__, rate);
+		return -EPERM;
+	}
+
+	rate = rate / MHZ_TO_HZ;
+	if (rate > 2500 || rate < 1200)	{
+		pr_err("%lu rate out of range!\n", rate);
+		return -EINVAL;
+	}
+
+	pr_debug("PLL3_VCO rate %lu -> %lu\n",
+		clk->rate/MHZ_TO_HZ, rate);
+
+	spin_lock_irqsave(&pll3_lock, flags);
+	__clk_pll_rate2rng(rate, &kvco, &vcovnrg);
+
+	/* The default configuration of pll3 */
+	pll3_sw_ctrl.v = __raw_readl(APB_SPARE_PLL3CR);
+	pll3_sw_ctrl.b.vddm = 1;
+	pll3_sw_ctrl.b.vddl = 9;
+	pll3_sw_ctrl.b.vreg_ivreg = 2;
+	pll3_sw_ctrl.b.icp = 4;
+	pll3_sw_ctrl.b.ctune = 1;
+	pll3_sw_ctrl.b.bypassen = 0;
+	pll3_sw_ctrl.b.gatectl = 0;
+	pll3_sw_ctrl.b.lineupen = 0;
+	pll3_sw_ctrl.b.kvco = kvco;
+	pll3_sw_ctrl.b.vcovnrg = vcovnrg;
+	pll3_sw_ctrl.b.diffclken = 1;
+	__raw_writel(pll3_sw_ctrl.v, APB_SPARE_PLL3CR);
+
+	/* Refclk/Refdiv = pll2freq/Fbdiv Refclk = 26M */
+	pll3cr.v = __raw_readl(MPMU_PLL3CR);
+	pll3cr.b.pll3refd = 3;
+	pll3cr.b.pll3fbd = rate * pll3cr.b.pll3refd / 26;
+	pll3cr.b.pclk_1248_sel = 0;
+	pll3cr.b.pll3_pu = 0;
+	__raw_writel(pll3cr.v, MPMU_PLL3CR);
+
+	clk->rate = rate * MHZ_TO_HZ;
+	spin_unlock_irqrestore(&pll3_lock, flags);
+
+	cur_rate = 26 * pll3cr.b.pll3fbd / pll3cr.b.pll3refd;
+	if (cur_rate != rate)
+		pr_warning("Real PLL3 rate %luMHZ\n", cur_rate);
+	return 0;
+}
+
+static unsigned long clk_pll3_vco_getrate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+static struct clkops clk_pll3_vco_ops = {
+	.init = clk_pll3_vco_init,
+	.enable = clk_pll3_vco_enable,
+	.disable = clk_pll3_vco_disable,
+	.setrate = clk_pll3_vco_setrate,
+	.getrate = clk_pll3_vco_getrate,
+};
+
+static struct clk pll3_vco = {
+	.name = "pll3_vco",
+	.parent = &ref_vco,
+	.ops = &clk_pll3_vco_ops,
+};
+
+static void clk_pll3_init(struct clk *clk)
+{
+	unsigned int pll3, pll3p;
+
+	BUG_ON(!pll3_default);
+	clk->rate = pll3_default;
+	if (__pll3_is_enabled()) {
+		__get_pll3_freq(&pll3, &pll3p);
+		pr_info("PLL3 is already enabled @ %lu\n",
+			pll3 * MHZ_TO_HZ);
+		return;
+	}
+	pr_info("PLL3 default rate %lu\n", clk->rate);
+}
+
+static int clk_pll3_setrate(struct clk *clk, unsigned long rate)
+{
+	union apb_spare_pllswcr pll3_sw_ctrl;
+	unsigned int div_val;
+	unsigned long flags;
+
+	if (__pll3_is_enabled())
+		return -EPERM;
+
+	pr_debug("PLL3 rate %lu -> %lu\n", clk->rate, rate);
+
+	spin_lock_irqsave(&pll3_lock, flags);
+	div_val = __clk_pll_calc_div(rate, clk->parent->rate, &clk->div);
+	pll3_sw_ctrl.v = __raw_readl(APB_SPARE_PLL3CR);
+	pll3_sw_ctrl.b.divselse = div_val;
+	__raw_writel(pll3_sw_ctrl.v, APB_SPARE_PLL3CR);
+	clk->rate = rate;
+	spin_unlock_irqrestore(&pll3_lock, flags);
+	return 0;
+}
+
+static unsigned long clk_pll3_getrate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+static struct clkops clk_pll3_ops = {
+	.init = clk_pll3_init,
+	.enable = clk_pll_dummy_enable,
+	.disable = clk_pll_dummy_disable,
+	.setrate = clk_pll3_setrate,
+	.getrate = clk_pll3_getrate,
+};
+
+static struct clk pll3 = {
+	.name = "pll3",
+	.parent = &pll3_vco,
+	.ops = &clk_pll3_ops,
+};
+
+static void clk_pll3p_init(struct clk *clk)
+{
+	unsigned int pll3, pll3p;
+
+	BUG_ON(!pll3p_default);
+	clk->rate = pll3p_default;
+	if (__pll3_is_enabled()) {
+		__get_pll3_freq(&pll3, &pll3p);
+		pr_info("PLL3P is already enabled @ %lu\n",
+			pll3p * MHZ_TO_HZ);
+		return;
+	}
+	pr_info("PLL3P default rate %lu\n", clk->rate);
+}
+
+static int clk_pll3p_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned int div_val;
+	union apb_spare_pllswcr pll3_sw_ctrl;
+	unsigned long flags;
+
+	if (__pll3_is_enabled())
+		return -EPERM;
+
+	pr_debug("PLL3P rate %lu -> %lu\n", clk->rate, rate);
+
+	spin_lock_irqsave(&pll3_lock, flags);
+	div_val = __clk_pll_calc_div(rate, clk->parent->rate, &clk->div);
+	pll3_sw_ctrl.v = __raw_readl(APB_SPARE_PLL3CR);
+	pll3_sw_ctrl.b.divseldiff = div_val;
+	__raw_writel(pll3_sw_ctrl.v, APB_SPARE_PLL3CR);
+	clk->rate = rate;
+	spin_unlock_irqrestore(&pll3_lock, flags);
+	return 0;
+}
+
+static unsigned long clk_pll3p_getrate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+static struct clkops clk_pll3p_ops = {
+	.init = clk_pll3p_init,
+	.enable = clk_pll_dummy_enable,
+	.disable = clk_pll_dummy_disable,
+	.setrate = clk_pll3p_setrate,
+	.getrate = clk_pll3p_getrate,
+};
+
+static struct clk pll3p = {
+	.name = "pll3p",
+	.parent = &pll3_vco,
+	.ops = &clk_pll3p_ops,
+};
+
+#define SDH_ACLK_EN		(1 << 3)
+/*
+ * SDH_ALL_RESET(1<<0) is only valid for APMU_SDH0
+ * But clear it can reset all 3 SD Hosts
+ * This bit need to be 1 when any SD Host is working
+ */
+#define SDH_ALL_RESET	(1 << 0)
+#define SDH_FCLK_EN		((1 << 4) | (1 << 1))
+#define SDH_FCLK_SEL(n)		((n & 0x1) << 6)
+#define SDH_FCLK_SEL_MASK	SDH_FCLK_SEL(0x1)
+#define SDH_FCLK_DIV(n)		((n & 0x7) << 8)
+#define SDH_FCLK_DIV_MASK	SDH_FCLK_DIV(0x7)
+#define SDH_FCLK_REQ		(1 << 11)
+#define SDH_CLK_RATE_MASK	\
+	(SDH_FCLK_SEL_MASK | SDH_FCLK_DIV_MASK)
+
+/* dummy clock used for 3 SDH shared AXI bus enable */
+DEFINE_GATE_CLK(sdh_shared_axi, APMU_SDH0, SDH_ACLK_EN, NULL, "sdh_shared_axi");
+
+static struct clk *sdhc_share_clk[] = {
+	&sdh_shared_axi,
+};
+
+static struct clk_mux_sel sdhc_clk_mux[] = {
+	{.input = &pll1_416, .value = CLK_PLL1_416},
+	{.input = &pll1_624, .value = CLK_PLL1_624},
+	{NULL, 0},
+};
+
+static void sdhc_reset_all(void)
+{
+	unsigned int reg_tmp;
+
+	reg_tmp = __raw_readl(APMU_SDH0);
+	/* set SDH_ALL_RESET bit to 0: reset all SD Hosts is enabled */
+	__raw_writel(reg_tmp & (~SDH_ALL_RESET), APMU_SDH0);
+	udelay(10);
+	/* set SDH_ALL_RESET bit to 1: reset all SD Hosts is disabled */
+	__raw_writel(reg_tmp | SDH_ALL_RESET, APMU_SDH0);
+}
+
+static void sdhc_clk_init(struct clk *clk)
+{
+	unsigned int mux, i;
+
+	clk->mul = 1;
+	clk->div = (clk->enable_val & SDH_FCLK_DIV_MASK) >> \
+		(__ffs(SDH_FCLK_DIV_MASK));
+	mux = (clk->enable_val & SDH_FCLK_SEL_MASK) >> \
+		(__ffs(SDH_FCLK_SEL_MASK));
+
+	i = 0;
+	while ((clk->inputs[i].input) && (clk->inputs[i].value != mux))
+		i++;
+	BUG_ON(!clk->inputs[i].input);
+
+	clk_reparent(clk, clk->inputs[i].input);
+	clk->div += 1;
+	clk->rate = clk_get_rate(clk->parent) * clk->mul / clk->div;
+	CLK_SET_BITS(clk->enable_val, SDH_CLK_RATE_MASK);
+	clk->enable_val = SDH_FCLK_REQ;
+	clk->dynamic_change = 1;
+}
+
+static int sdhc_clk_enable(struct clk *clk)
+{
+	CLK_SET_BITS(SDH_FCLK_EN, 0);
+	CLK_SET_BITS(SDH_FCLK_REQ, 0);
+	return 0;
+}
+
+static void sdhc_clk_disable(struct clk *clk)
+{
+	CLK_SET_BITS(0, SDH_FCLK_EN);
+
+}
+
+static int sdhc_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	__clk_periph_set_rate(clk, rate);
+	return 0;
+}
+
+static unsigned long sdhc_clk_getrate(struct clk *clk)
+{
+	return __clk_periph_get_rate(clk);
+}
+
+struct clkops sdhc_clk_ops = {
+	.init = sdhc_clk_init,
+	.enable = sdhc_clk_enable,
+	.disable = sdhc_clk_disable,
+	.setrate = sdhc_clk_setrate,
+	.getrate = sdhc_clk_getrate,
+};
+
+static struct clk pxa988_clk_sdh0 = {
+	.name = "sdh0",
+	.lookup = {
+		.dev_id = "sdhci-pxav3.0",
+		.con_id = "PXA-SDHCLK",
+	},
+	.clk_rst = (void __iomem *)APMU_SDH0,
+	/* SDcard 208M */
+	.enable_val =
+		SDH_FCLK_SEL(CLK_PLL1_416)|SDH_FCLK_DIV(1)|SDH_FCLK_REQ,
+	.ops = &sdhc_clk_ops,
+	.inputs = sdhc_clk_mux,
+	.dependence = sdhc_share_clk,
+	.dependence_count = 1,
+	.reg_data = {
+		{ {APMU_SDH0, 6, 0x1}, {APMU_SDH0, 6, 0x1} },
+		{ {APMU_SDH0, 8, 0x7}, {APMU_SDH0, 8, 0x7} }
+	}
+};
+
+static struct clk pxa988_clk_sdh1 = {
+	.name = "sdh1",
+	.lookup = {
+		.dev_id = "sdhci-pxav3.1",
+		.con_id = "PXA-SDHCLK",
+	},
+	.clk_rst = (void __iomem *)APMU_SDH1,
+	/* Wifi 89.1M */
+	.enable_val =
+		SDH_FCLK_SEL(CLK_PLL1_624)|SDH_FCLK_DIV(6)|SDH_FCLK_REQ,
+	.ops = &sdhc_clk_ops,
+	.inputs = sdhc_clk_mux,
+	.dependence = sdhc_share_clk,
+	.dependence_count = 1,
+	.reg_data = {
+		{ {APMU_SDH1, 6, 0x1}, {APMU_SDH1, 6, 0x1} },
+		{ {APMU_SDH1, 8, 0x7}, {APMU_SDH1, 8, 0x7} }
+	}
+};
+
+static struct clk pxa988_clk_sdh2 = {
+	.name = "sdh2",
+	.lookup = {
+		.dev_id = "sdhci-pxav3.2",
+		.con_id = "PXA-SDHCLK",
+	},
+	.clk_rst = (void __iomem *)APMU_SDH2,
+	/* Emmc 104M */
+	.enable_val =
+		SDH_FCLK_SEL(CLK_PLL1_416)|SDH_FCLK_DIV(3)|SDH_FCLK_REQ,
+	.ops = &sdhc_clk_ops,
+	.inputs = sdhc_clk_mux,
+	.dependence = sdhc_share_clk,
+	.dependence_count = 1,
+	.reg_data = {
+		{ {APMU_SDH2, 6, 0x1}, {APMU_SDH2, 6, 0x1} },
+		{ {APMU_SDH2, 8, 0x7}, {APMU_SDH2, 8, 0x7} }
+	}
+};
+
+static struct clk_mux_sel periph_mux_sel[] = {
+	{.input = &pll1_416, .value = CLK_PLL1_416},
+	{.input = &pll1_624, .value = CLK_PLL1_624},
+	{.input = &pll2, .value = CLK_PLL2},
+	{.input = &pll2p, .value = CLK_PLL2P},
+	{NULL, 0},
+};
+
+static void __clk_fill_periph_tbl(struct clk *clk,
+	struct periph_clk_tbl *clk_tbl, unsigned int clk_tbl_size)
+{
+	unsigned int i = 0;
+	unsigned long prate = 0;
+	const struct clk_mux_sel *sel;
+
+	pr_info("************** clk_%s_tbl  **************\n", clk->name);
+
+	for (i = 0; i < clk_tbl_size; i++) {
+		for (sel = clk->inputs; sel->input != NULL; sel++) {
+			if (sel->input == clk_tbl[i].parent) {
+				prate = clk_get_rate(sel->input);
+				if ((prate % clk_tbl[i].clk_rate) || !prate)
+					break;
+				clk_tbl[i].src_val = sel->value;
+				clk_tbl[i].div_val =
+					prate / clk_tbl[i].clk_rate - 1;
+				pr_info("clk[%lu] src[%lu:%lu] div[%lu]\n",
+					clk_tbl[i].clk_rate, prate, \
+					clk_tbl[i].src_val, \
+					clk_tbl[i].div_val);
+				break;
+			}
+		}
+	}
+}
+
+static void __clk_fill_periphtbl_xtc(struct periph_clk_tbl *tbl, int tbl_len,
+				     struct xpu_rtcwtc *xtc, int xtctbl_len)
+{
+	int i = 0;
+	int j = 0;
+	while (i < tbl_len) {
+		if (tbl[i].clk_rate <= xtc[j].max_rate) {
+			tbl[i].rtcwtc = xtc[j].rtcwtc;
+			i++;
+		} else if (j < xtctbl_len)
+			j++;
+		if (j == xtctbl_len)
+			tbl[i].rtcwtc = xtc[j - 1].rtcwtc;
+	}
+}
+
+static long __clk_round_rate_bytbl(struct clk *clk, unsigned long rate,
+	struct periph_clk_tbl *clk_tbl, unsigned int clk_tbl_size)
+{
+	unsigned int i;
+
+	if (unlikely(rate > clk_tbl[clk_tbl_size - 1].clk_rate))
+		return clk_tbl[clk_tbl_size - 1].clk_rate;
+
+	for (i = 0; i < clk_tbl_size; i++) {
+		if (rate <= clk_tbl[i].clk_rate)
+			return clk_tbl[i].clk_rate;
+	}
+
+	return clk->rate;
+}
+
+/*
+ * This help function can get the rate close to the required rate,
+ * we'd better not use it for clock which need to dynamic change
+ * as efficiency consideration.
+ */
+static long __clk_sel_mux_div(struct clk *clk, unsigned long rate,
+	unsigned int *mux, unsigned int *div, struct clk **best_parent)
+{
+	const struct clk_mux_sel *sel;
+	struct clk *parent_selh = NULL, *parent_sell = NULL;
+	unsigned long i, parent_rate, now, maxdiv;
+	unsigned long bestl = 0, besth = ULONG_MAX;
+	unsigned int bestdivl = 0, bestmuxl = 0, bestdivh = 0, bestmuxh = 0;
+
+	maxdiv = clk->reg_data[DIV][CONTROL].reg_mask + 1;
+	if (rate < (clk_get_rate(clk->inputs[0].input) / maxdiv))
+		rate = clk_get_rate(clk->inputs[0].input) / maxdiv;
+	/*
+	 * The maximum divider we can use without overflowing
+	 * unsigned long in rate * i below
+	 */
+	maxdiv = min(ULONG_MAX / rate, maxdiv);
+	for (sel = clk->inputs; sel->input != NULL; sel++) {
+		parent_rate = clk_get_rate(sel->input);
+		for (i = 1; i <= maxdiv; i++) {
+			now = parent_rate / i;
+			/* condition to select a best closest rate >= rate */
+			if (now >= rate && now < besth) {
+				bestdivh = i;
+				besth = now;
+				parent_selh = sel->input;
+				bestmuxh = sel->value;
+			/* condition to select a best closest rate <= rate */
+			} else if (now <= rate && now > bestl) {
+				bestdivl = i;
+				bestl = now;
+				parent_sell = sel->input;
+				bestmuxl = sel->value;
+			}
+		}
+	}
+
+	now = ((besth - rate) <= (rate - bestl)) ? besth : bestl;
+	if (now == besth) {
+		*div = bestdivh;
+		*mux = bestmuxh;
+		*best_parent = parent_selh;
+	} else {
+		*div = bestdivl;
+		*mux = bestmuxl;
+		*best_parent = parent_sell;
+	}
+	BUG_ON(!(*div));
+
+	pr_debug("%s clk:%s mux:%u div:%u, %lu\n", __func__, \
+		clk->name, *mux, *div, clk_get_rate(*best_parent));
+
+	return clk_get_rate(*best_parent)/(*div);
+}
+
+static void __clk_wait_fc_done(struct clk *clk)
+{
+	/* fc done should be asserted in several clk cycles */
+	unsigned int i = 50;
+	udelay(2);
+	while ((__raw_readl(clk->reg_data[SOURCE][CONTROL].reg)\
+		& clk->enable_val) && i) {
+		udelay(10);
+		i--;
+	}
+	if (i == 0) {
+		pr_info("CLK[%s] fc req failed![%x]= 0x%x,"\
+			"fc_req = 0x%x\n", clk->name,
+			(unsigned int)clk->reg_data[SOURCE][CONTROL].reg,
+			__raw_readl(clk->reg_data[SOURCE][CONTROL].reg),
+			clk->enable_val);
+		BUG_ON(1);
+	}
+}
+
+static long __clk_set_mux_div(struct clk *clk, struct clk *best_parent,
+	unsigned int mux, unsigned int div)
+{
+	unsigned int muxmask, divmask;
+	unsigned int muxval, divval;
+	unsigned int regval;
+
+	BUG_ON(!div);
+
+	clk->div = div;
+	clk->mul = 1;
+
+	div = div - 1;	/* rate = parent_rate / (div_regval + 1) */
+
+	muxval = (mux > clk->reg_data[SOURCE][CONTROL].reg_mask) ? \
+		clk->reg_data[SOURCE][CONTROL].reg_mask : mux;
+	divval = (div > clk->reg_data[DIV][CONTROL].reg_mask) ? \
+		clk->reg_data[DIV][CONTROL].reg_mask : div;
+
+	muxmask = clk->reg_data[SOURCE][CONTROL].reg_mask << \
+		clk->reg_data[SOURCE][CONTROL].reg_shift;
+	divmask = clk->reg_data[DIV][CONTROL].reg_mask << \
+		clk->reg_data[DIV][CONTROL].reg_shift;
+
+	muxval = muxval << clk->reg_data[SOURCE][CONTROL].reg_shift;
+	divval = divval << clk->reg_data[DIV][CONTROL].reg_shift;
+
+	/*
+	 * mux and div are from the same reg, if clk is enabled,
+	 * set mux, div and trigger(clk->enable_val) at the same time.
+	 * If clock is disabled, we still set mux, div and fc_request here.
+	 */
+	regval = __raw_readl(clk->reg_data[SOURCE][CONTROL].reg);
+	regval &= ~(muxmask | divmask);
+	regval |= (muxval | divval);
+
+	/*
+	 * For smooth mux clock src switch, must make sure both clocks on
+	 * or smooth mux can not finish clock switch.
+	 */
+	clk_enable(best_parent);
+	if (!clk->refcnt && clk->parent)
+		clk_enable(clk->parent);
+	regval |= clk->enable_val;
+	__raw_writel(regval, clk->reg_data[SOURCE][CONTROL].reg);
+	__clk_wait_fc_done(clk);
+
+	/*
+	 * disable its parent if clk change done, no matter clk is enabled
+	 * or not
+	 */
+	if (clk->parent)
+		clk_disable(clk->parent);
+	if (!clk->refcnt)
+		clk_disable(best_parent);
+	clk_reparent(clk, best_parent);
+
+	pr_debug("\n%s clk:%s [%x] = [%x]\n", __func__, clk->name, \
+		(unsigned int)clk->reg_data[SOURCE][CONTROL].reg, regval);
+
+	return 0;
+}
+
+static void __clk_get_mux_div(struct clk *clk,
+		unsigned int *mux, unsigned int *div)
+{
+	unsigned int muxmask, divmask;
+	unsigned int muxval, divval;
+	unsigned int regval;
+
+	regval = __raw_readl(clk->reg_data[SOURCE][CONTROL].reg);
+	muxmask = clk->reg_data[SOURCE][CONTROL].reg_mask << \
+		clk->reg_data[SOURCE][CONTROL].reg_shift;
+	divmask = clk->reg_data[DIV][CONTROL].reg_mask << \
+		clk->reg_data[DIV][CONTROL].reg_shift;
+
+	muxval = (regval & muxmask) >> __ffs(muxmask);
+	divval = (regval & divmask) >> __ffs(divmask);
+
+	pr_debug("\n%s clk:%s [%x]val%x mux[%d] div[%d]\n", __func__,
+		clk->name, (unsigned int)clk->reg_data[SOURCE][CONTROL].reg,
+		regval, muxval, divval+1);
+
+	*mux = muxval;
+	*div = divval + 1;
+}
+
+static struct clk *__clk_mux_to_parent(struct clk *clk, unsigned int mux)
+{
+	unsigned int i;
+
+	i = 0;
+	while ((clk->inputs[i].input) && (clk->inputs[i].value != mux))
+		i++;
+	BUG_ON(!clk->inputs[i].input);
+
+	return clk->inputs[i].input;
+}
+
+static unsigned int __clk_parent_to_mux(struct clk *clk, struct clk *parent)
+{
+	unsigned int i;
+
+	i = 0;
+	while ((clk->inputs[i].input) && (clk->inputs[i].input != parent))
+		i++;
+	BUG_ON(!clk->inputs[i].input);
+
+	return clk->inputs[i].value;
+}
+
+static void __clk_periph_init(struct clk *clk,
+	struct clk *parent, unsigned int div, bool dyn_chg)
+{
+	unsigned int mux = 0;
+
+	clk->dynamic_change = dyn_chg;
+	clk->mul = 1;
+	clk->div = div;
+	mux  = __clk_parent_to_mux(clk, parent);
+	__clk_set_mux_div(clk, parent, mux, div);
+	clk->rate = clk_get_rate(clk->parent) * clk->mul / clk->div;
+}
+
+static unsigned long __clk_periph_get_rate(struct clk *clk)
+{
+	struct clk *cur_parent;
+	unsigned int mux, div = 1;
+
+	__clk_get_mux_div(clk, &mux, &div);
+	cur_parent = __clk_mux_to_parent(clk, mux);
+
+	return clk_get_rate(cur_parent) / div;
+}
+
+static int __clk_periph_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long new_rate;
+	unsigned int mux, div;
+	struct clk *best_parent;
+
+	new_rate = __clk_sel_mux_div(clk, rate, &mux, &div, &best_parent);
+	if (rate != new_rate)
+		pr_warning("clk[%s] required rate %lu, set as %lu\n", \
+			clk->name, rate, new_rate);
+	__clk_set_mux_div(clk, best_parent, mux, div);
+	return 0;
+}
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+int mck4_wr_enabled = 1;
+static int __init mck4_wr_disable(char *str)
+{
+	mck4_wr_enabled = 0;
+	return 1;
+}
+__setup("no_mck4_wr", mck4_wr_disable);
+
+static LIST_HEAD(ddr_combined_clk_list);
+
+struct ddr_combclk_relation {
+	unsigned long dclk_rate;
+	unsigned long combclk_rate;
+};
+
+struct ddr_combined_clk {
+	struct clk *clk;
+	unsigned long maxrate;
+	struct list_head node;
+	/* Describe the relationship with Dclk */
+	struct ddr_combclk_relation *relationtbl;
+	unsigned int num_relationtbl;
+};
+
+static int register_clk_bind2ddr(struct clk *clk,
+	unsigned long max_freq,
+	struct ddr_combclk_relation *relationtbl,
+	unsigned int num_relationtbl)
+{
+	struct ddr_combined_clk *comclk;
+
+	/* search the list of the registation for this clk */
+	list_for_each_entry(comclk, &ddr_combined_clk_list, node)
+		if (comclk->clk == clk)
+			break;
+
+	/* if clk wasn't in the list, allocate new dcstat info */
+	if (comclk->clk != clk) {
+		comclk = kzalloc(sizeof(struct ddr_combined_clk), GFP_KERNEL);
+		if (!comclk)
+			return -ENOMEM;
+
+		comclk->clk = clk;
+		comclk->maxrate = max_freq;
+		comclk->relationtbl = relationtbl;
+		comclk->num_relationtbl = num_relationtbl;
+		list_add(&comclk->node, &ddr_combined_clk_list);
+	}
+	return 0;
+}
+
+int trigger_bind2ddr_clk_rate(unsigned long ddr_rate)
+{
+	struct ddr_combined_clk *comclk;
+	unsigned long tgt, cur;
+	int ret = 0, i = 0;
+
+	/*
+	 * For Z1/Z2 mck4 wr is default enabled, only could be
+	 * disabled for debug.
+	 * For Z3/A0, mck4 wr is always disabled.
+	 */
+	if ((!mck4_wr_enabled) && cpu_is_z1z2())
+		return 0;
+
+	list_for_each_entry(comclk, &ddr_combined_clk_list, node) {
+		if (comclk->relationtbl) {
+			i = 0;
+			while (i < comclk->num_relationtbl - 1) {
+				if ((ddr_rate >=
+					comclk->relationtbl[i].dclk_rate) &&\
+				    (ddr_rate <
+					comclk->relationtbl[i + 1].dclk_rate))
+					break;
+				i++;
+			}
+			tgt = comclk->relationtbl[i].combclk_rate;
+		} else {
+			/* For mck4 WR, DDR: ACLK = 1: 1/ 2:1 */
+			if (ddr_rate > comclk->maxrate)
+				tgt = ddr_rate / 2;
+			else
+				tgt = ddr_rate;
+		}
+		tgt = min(tgt, comclk->maxrate);
+		pr_debug("%s Start rate change to %lu\n",
+			comclk->clk->name, tgt);
+		ret = clk_set_rate(comclk->clk, tgt);
+		if (ret) {
+			pr_info("%s failed to change clk %s rate\n",
+				__func__, comclk->clk->name);
+			return ret;
+		}
+		cur = clk_get_rate(comclk->clk);
+		if (cur != tgt) {
+			pr_info("clk %s: cur %lu, tgt %lu, reg[%x]\n",
+					comclk->clk->name, cur, tgt,
+					__raw_readl(comclk->clk->clk_rst));
+			WARN_ON(1);
+		}
+	}
+
+	return ret;
+}
+#endif
+
+#define GC_ACLK_EN	(0x1 << 3)
+#define GC_FCLK_EN	(0x1 << 4)
+#define GC_HCLK_EN	(0x1 << 5)
+
+#define GC_FCLK_SEL(n)		((n & 0x3) << 6)
+#define GC_FCLK_SEL_MASK	GC_FCLK_SEL(0x3)
+#define GC_FCLK_DIV(n)		((n & 0x7) << 12)
+#define GC_FCLK_DIV_MASK	GC_FCLK_DIV(0x7)
+#define GC_FCLK_REQ		(0x1 << 15)
+
+#define GC_ACLK_SEL(n)		((n & 0x3) << 20)
+#define GC_ACLK_SEL_MASK	GC_ACLK_SEL(0x3)
+#define GC_ACLK_DIV(n)		((n & 0x7) << 17)
+#define GC_ACLK_DIV_MASK	GC_ACLK_DIV(0x7)
+#define GC_ACLK_REQ		(0x1 << 16)
+
+#define GC_FCLK_RATE(fsrc, fdiv)	\
+	(GC_FCLK_SEL(fsrc) | GC_FCLK_DIV(fdiv))
+
+#define GC_ACLK_RATE(asrc, adiv)	\
+	(GC_ACLK_SEL(asrc) | GC_ACLK_DIV(adiv))
+
+#define GC_FCLK_RATE_MSK				\
+	(GC_FCLK_SEL_MASK | GC_FCLK_DIV_MASK)		\
+
+#define GC_ACLK_RATE_MSK				\
+	(GC_ACLK_SEL_MASK | GC_ACLK_DIV_MASK)		\
+
+
+/*
+ * 1. sort ascending
+ * 2. FIXME: If DDR 533M is used, 400M bus clk could not be
+ * supported due to clk src issue.
+ * 3. For 988 Z1/Z2, only uses gc aclk 150/300/400
+ * 4. For 988 Z3/Ax, only uses gc aclk 156/312/416
+ * 5. For 1088, temporarily use 988 Z3/Ax table, will be updated
+ *    once DE/SV give the table
+ */
+static struct periph_clk_tbl gc_aclk_tbl[] = {
+	{.clk_rate = 78000000, .parent = &pll1_624},
+	{.clk_rate = 104000000, .parent = &pll1_416},
+	{.clk_rate = 150000000, .parent = &pll2},
+	{.clk_rate = 156000000, .parent = &pll1_624},
+	{.clk_rate = 208000000, .parent = &pll1_416},
+	{.clk_rate = 300000000, .parent = &pll2},
+	{.clk_rate = 312000000, .parent = &pll1_624},
+	{.clk_rate = 400000000, .parent = &pll2p},
+	{.clk_rate = 416000000, .parent = &pll1_416},
+};
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+struct ddr_combclk_relation gcaclk_dclk_relationtbl[] = {
+	{.dclk_rate = 104000000, .combclk_rate = 78000000},
+	{.dclk_rate = 156000000, .combclk_rate = 104000000},
+	{.dclk_rate = 312000000, .combclk_rate = 208000000},
+	{.dclk_rate = 400000000, .combclk_rate = 312000000},
+	{.dclk_rate = 533000000, .combclk_rate = 416000000},
+};
+#endif
+
+static void gc_aclk_init(struct clk *clk)
+{
+	__clk_fill_periph_tbl(clk, gc_aclk_tbl,
+		ARRAY_SIZE(gc_aclk_tbl));
+	/* default GC aclk = 312M sel = pll1_624, div = 2 */
+	__clk_periph_init(clk, &pll1_624, 2, 1);
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+	/* use default relationship for z1z2 */
+	if (cpu_is_z1z2())
+		register_clk_bind2ddr(clk,
+			gc_aclk_tbl[ARRAY_SIZE(gc_aclk_tbl) - 1].clk_rate,
+			NULL, 0);
+	/* Use defined relationship for z3Ax */
+	else
+		register_clk_bind2ddr(clk,
+			gc_aclk_tbl[ARRAY_SIZE(gc_aclk_tbl) - 1].clk_rate,
+			gcaclk_dclk_relationtbl,
+			ARRAY_SIZE(gcaclk_dclk_relationtbl));
+#endif
+}
+
+static int gc_aclk_enable(struct clk *clk)
+{
+	spin_lock(&gc_lock);
+	CLK_SET_BITS(GC_ACLK_EN, 0);
+	CLK_SET_BITS(GC_ACLK_REQ, 0);
+	__clk_wait_fc_done(clk);
+	spin_unlock(&gc_lock);
+	pr_debug("%s %s %x\n", __func__, clk->name, __raw_readl(clk->clk_rst));
+	return 0;
+}
+
+static void gc_aclk_disable(struct clk *clk)
+{
+	spin_lock(&gc_lock);
+	CLK_SET_BITS(0, GC_ACLK_EN);
+	spin_unlock(&gc_lock);
+	return;
+}
+
+static long gc_aclk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return __clk_round_rate_bytbl(clk, rate, \
+		gc_aclk_tbl, ARRAY_SIZE(gc_aclk_tbl));
+}
+
+static int gc_aclk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long old_rate;
+	unsigned int i;
+	struct clk *new_parent;
+
+	old_rate = clk->rate;
+	if (rate == old_rate)
+		return 0;
+
+	i = 0;
+	while (gc_aclk_tbl[i].clk_rate != rate)
+		i++;
+	BUG_ON(i == ARRAY_SIZE(gc_aclk_tbl));
+
+	new_parent = gc_aclk_tbl[i].parent;
+	spin_lock(&gc_lock);
+	__clk_set_mux_div(clk, new_parent,
+		gc_aclk_tbl[i].src_val, (gc_aclk_tbl[i].div_val + 1));
+	spin_unlock(&gc_lock);
+
+	pr_debug("%s rate %lu->%lu\n", clk->name, old_rate, rate);
+	return 0;
+}
+
+static unsigned long gc_aclk_getrate(struct clk *clk)
+{
+	return __clk_periph_get_rate(clk);
+}
+
+struct clkops gc_aclk_ops = {
+	.init		= gc_aclk_init,
+	.enable		= gc_aclk_enable,
+	.disable	= gc_aclk_disable,
+	.round_rate	= gc_aclk_round_rate,
+	.setrate	= gc_aclk_setrate,
+	.getrate	= gc_aclk_getrate,
+};
+
+/*
+ * GC aclk node is internal clk node, and
+ * can only be used by GC fclk
+ */
+static struct clk gc_aclk = {
+	.name = "gc_aclk",
+	.lookup = {
+		.con_id = "GC_ACLK",
+	},
+	.clk_rst = (void __iomem *)APMU_GC,
+	.enable_val = GC_ACLK_REQ,
+	.inputs = periph_mux_sel,
+	.ops = &gc_aclk_ops,
+	.reg_data = {
+		     { {APMU_GC, 20, 0x3}, {APMU_GC, 20, 0x3} },
+		     { {APMU_GC, 17, 0x7}, {APMU_GC, 17, 0x7} } }
+};
+
+static struct clk *gc_clk_depend[] = {
+	&gc_aclk,
+};
+
+/*
+ * GC2D aclk node is internal clk node, and
+ * can only be used by GC2D fclk
+ */
+static struct clk gc2d_aclk = {
+	.name = "gc2d_aclk",
+	.lookup = {
+		.con_id = "GC2D_ACLK",
+	},
+	.clk_rst = (void __iomem *)APMU_GC_2D,
+	.enable_val = GC_ACLK_REQ,
+	.inputs = periph_mux_sel,
+	.ops = &gc_aclk_ops,
+	.reg_data = {
+		     { {APMU_GC_2D, 20, 0x3}, {APMU_GC_2D, 20, 0x3} },
+		     { {APMU_GC_2D, 17, 0x7}, {APMU_GC_2D, 17, 0x7} } }
+};
+
+static struct clk *gc2d_clk_depend[] = {
+	&gc2d_aclk,
+};
+
+/* sort ascending */
+static struct periph_clk_tbl gc_fclk_tbl_z1z2[] = {
+	{
+		.clk_rate = 150000000,
+		.parent = &pll2,
+	},
+	{
+		.clk_rate = 300000000,
+		.parent = &pll2,
+	},
+	{
+		.clk_rate = 400000000,
+		.parent = &pll2p,
+	},
+	{
+		.clk_rate = 600000000,
+		.parent = &pll2,
+	},
+};
+
+static struct periph_clk_tbl gc_fclk_tbl[] = {
+	{
+		.clk_rate = 156000000,
+		.parent = &pll1_624,
+		.comclk_rate = 156000000,
+	},
+	{
+		.clk_rate = 312000000,
+		.parent = &pll1_624,
+		.comclk_rate = 312000000,
+	},
+	{
+		.clk_rate = 416000000,
+		.parent = &pll1_416,
+		.comclk_rate = 312000000,
+	},
+	{
+		.clk_rate = 624000000,
+		.parent = &pll1_624,
+		.comclk_rate = 416000000,
+	},
+};
+
+/* interface used by GC driver to get avaliable GC frequencies, unit HZ */
+int get_gcu_freqs_table(unsigned long *gcu_freqs_table,
+	unsigned int *item_counts, unsigned int max_item_counts)
+{
+	unsigned int index;
+	*item_counts = 0;
+
+	if (!gcu_freqs_table) {
+		pr_err("%s NULL ptr!\n", __func__);
+		return -EINVAL;
+	}
+
+	if (max_item_counts < ARRAY_SIZE(gc_fclk_tbl)) {
+		pr_err("%s Too many GC frequencies %u!\n", __func__,
+			max_item_counts);
+		return -EINVAL;
+	}
+
+	for (index = 0; index < ARRAY_SIZE(gc_fclk_tbl); index++)
+		gcu_freqs_table[index] = gc_fclk_tbl[index].clk_rate;
+	*item_counts = index;
+	return 0;
+}
+EXPORT_SYMBOL(get_gcu_freqs_table);
+
+/* rate unit is Mhz */
+void dynamic_change_pll3(unsigned int rate)
+{
+	struct clk *pll3, *pll3_vco;
+	unsigned long i, pll3_rate, pll3vco_rate;
+
+	pll3 = clk_get(NULL, "pll3");
+	pll3_vco = clk_get(NULL, "pll3_vco");
+
+	if (!rate) {
+		if (clk_get_rate(pll3_vco) == pll3_vco_default &&
+			(clk_get_rate(pll3) == pll3_default)) {
+			return;
+		}
+		pll3vco_rate = 	pll3_vco_default;
+		pll3_rate = pll3_default;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(pll_post_div_tbl); i++) {
+			pll3_rate = rate * pll_post_div_tbl[i].div;
+			if ((pll3_rate > 600) &&
+					(pll3_rate < 1000))
+				break;
+		}
+
+		if (i == ARRAY_SIZE(pll_post_div_tbl))
+			BUG_ON("Multiplier is out of range\n");
+		pll3_rate *=  MHZ_TO_HZ;
+		pll3vco_rate = pll3_rate * 2;
+	}
+
+	clk_set_rate(pll3_vco, pll3vco_rate);
+	clk_set_rate(pll3, pll3_rate);
+	udelay(50);
+	pr_info("%s: pll3_vco is %luMHz, pll3 is %luMHz", __func__,
+		 clk_get_rate(pll3_vco) / MHZ_TO_HZ,
+		 clk_get_rate(pll3) / MHZ_TO_HZ);
+}
+EXPORT_SYMBOL(dynamic_change_pll3);
+
+/* used for GC LPM constraint */
+static struct pm_qos_request gc_lpm_cons;
+
+static void gc_clk_init(struct clk *clk)
+{
+#ifdef CONFIG_DEBUG_FS
+	unsigned int i;
+	unsigned long op[ARRAY_SIZE(gc_fclk_tbl)];
+#endif
+	if (cpu_is_z1z2())
+		memcpy(&gc_fclk_tbl, &gc_fclk_tbl_z1z2,
+			sizeof(struct periph_clk_tbl) *\
+				ARRAY_SIZE(gc_fclk_tbl));
+
+	__clk_fill_periph_tbl(clk, gc_fclk_tbl, ARRAY_SIZE(gc_fclk_tbl));
+
+	if (cpu_is_z1z2())
+		/* default GC fclk = 400M sel = pll2 = 1200M, div = 4 */
+		__clk_periph_init(clk, &pll2, 4, 1);
+	else
+		/* default GC fclk = 416M sel = pll1_416, div = 1 */
+		__clk_periph_init(clk, &pll1_416, 1, 1);
+
+
+#ifdef CONFIG_DEBUG_FS
+	for (i = 0; i < ARRAY_SIZE(gc_fclk_tbl); i++)
+		op[i] = gc_fclk_tbl[i].clk_rate;
+	pxa988_clk_register_dcstat(clk, op, ARRAY_SIZE(gc_fclk_tbl));
+#endif
+
+	if (has_feat_disable_d1p_gc_on()) {
+		/* initialize the qos list at the first time */
+		gc_lpm_cons.name = "GC";
+		pm_qos_add_request(&gc_lpm_cons,
+				PM_QOS_CPUIDLE_BLOCK,
+				PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+	}
+}
+
+static int gc_clk_enable(struct clk *clk)
+{
+	if (has_feat_disable_d1p_gc_on()) {
+		/* block LPM D1P and deeper than D1P */
+		pm_qos_update_request(&gc_lpm_cons,
+				PM_QOS_CPUIDLE_BLOCK_AXI_VALUE);
+	}
+
+	spin_lock(&gc_lock);
+	CLK_SET_BITS((GC_FCLK_EN | GC_HCLK_EN), 0);
+	CLK_SET_BITS(GC_FCLK_REQ, 0);
+	__clk_wait_fc_done(clk);
+	spin_unlock(&gc_lock);
+	trace_pxa_gc_clk(CLK_ENABLE, __raw_readl(clk->clk_rst));
+	pr_debug("%s GC_CLK %x\n", __func__, __raw_readl(clk->clk_rst));
+#ifdef CONFIG_DEBUG_FS
+	pxa988_clk_dcstat_event(clk, CLK_STATE_ON, 0);
+#endif
+	return 0;
+}
+
+static void gc_clk_disable(struct clk *clk)
+{
+	spin_lock(&gc_lock);
+	CLK_SET_BITS(0, (GC_FCLK_EN | GC_HCLK_EN));
+	spin_unlock(&gc_lock);
+	trace_pxa_gc_clk(CLK_DISABLE, __raw_readl(clk->clk_rst));
+	pr_debug("%s GC_CLK : %x\n", __func__, __raw_readl(clk->clk_rst));
+#ifdef CONFIG_DEBUG_FS
+	pxa988_clk_dcstat_event(clk, CLK_STATE_OFF, 0);
+#endif
+
+	if (has_feat_disable_d1p_gc_on()) {
+		/* release D1P LPM constraint */
+		pm_qos_update_request(&gc_lpm_cons,
+				PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+	}
+}
+
+static long gc_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return __clk_round_rate_bytbl(clk, rate, \
+		gc_fclk_tbl, ARRAY_SIZE(gc_fclk_tbl));
+}
+
+static int gc_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long old_rate;
+	unsigned int i;
+	struct clk *new_fparent;
+
+	old_rate = clk->rate;
+	if (rate == old_rate)
+		return 0;
+
+	i = 0;
+	while (gc_fclk_tbl[i].clk_rate != rate)
+		i++;
+	BUG_ON(i == ARRAY_SIZE(gc_fclk_tbl));
+
+	/* set GC function clk rate */
+	new_fparent = gc_fclk_tbl[i].parent;
+	spin_lock(&gc_lock);
+	__clk_set_mux_div(clk, new_fparent,
+		gc_fclk_tbl[i].src_val, (gc_fclk_tbl[i].div_val + 1));
+	spin_unlock(&gc_lock);
+
+#ifndef DDR_COMBINDEDCLK_SOLUTION
+	/* set GC bus clk rate here if aclk is bound with fclk */
+	clk_set_rate(&gc_aclk, gc_fclk_tbl[i].comclk_rate);
+#endif
+	trace_pxa_gc_clk_chg(clk->rate, rate);
+	pr_debug("%s GC_CLK %x\n", __func__, __raw_readl(clk->clk_rst));
+	pr_debug("%s rate %lu->%lu\n", __func__, old_rate, rate);
+
+#ifdef CONFIG_DEBUG_FS
+	pxa988_clk_dcstat_event(clk, CLK_RATE_CHANGE, i);
+#endif
+	return 0;
+}
+
+static unsigned long gc_clk_getrate(struct clk *clk)
+{
+	/* can only get fclk here */
+	return __clk_periph_get_rate(clk);
+}
+
+struct clkops gc_clk_ops = {
+	.init		= gc_clk_init,
+	.enable		= gc_clk_enable,
+	.disable	= gc_clk_disable,
+	.round_rate	= gc_clk_round_rate,
+	.setrate	= gc_clk_setrate,
+	.getrate	= gc_clk_getrate,
+};
+
+static struct clk pxa988_clk_gc = {
+	.name = "gc",
+	.lookup = {
+		.con_id = "GCCLK",
+	},
+	.clk_rst = (void __iomem *)APMU_GC,
+	.enable_val = GC_FCLK_REQ,
+	.inputs = periph_mux_sel,
+	.ops = &gc_clk_ops,
+	.dependence = gc_clk_depend,
+	.dependence_count = 1,
+	.reg_data = {
+		     { {APMU_GC, 6, 0x3}, {APMU_GC, 6, 0x3} },
+		     { {APMU_GC, 12, 0x7}, {APMU_GC, 12, 0x7} } },
+	.is_combined_fc = 1,
+};
+
+static struct periph_clk_tbl gc2d_fclk_tbl[] = {
+	{
+		.clk_rate = 156000000,
+		.parent = &pll1_624,
+		.comclk_rate = 156000000,
+	},
+	{
+		.clk_rate = 312000000,
+		.parent = &pll1_624,
+		.comclk_rate = 312000000,
+	},
+	{
+		.clk_rate = 416000000,
+		.parent = &pll1_416,
+		.comclk_rate = 312000000,
+	},
+};
+
+static void gc2d_clk_init(struct clk *clk)
+{
+#ifdef CONFIG_DEBUG_FS
+	unsigned int i;
+	unsigned long op[ARRAY_SIZE(gc2d_fclk_tbl)];
+#endif
+	__clk_fill_periph_tbl(clk, gc2d_fclk_tbl, ARRAY_SIZE(gc2d_fclk_tbl));
+
+	/* default GC2D fclk = 416M sel = pll1_416, div = 1 */
+	__clk_periph_init(clk, &pll1_416, 1, 1);
+
+#ifdef CONFIG_DEBUG_FS
+	for (i = 0; i < ARRAY_SIZE(gc2d_fclk_tbl); i++)
+		op[i] = gc2d_fclk_tbl[i].clk_rate;
+	pxa988_clk_register_dcstat(clk, op, ARRAY_SIZE(gc2d_fclk_tbl));
+#endif
+
+}
+static int gc2d_clk_enable(struct clk *clk)
+{
+	spin_lock(&gc_lock);
+	CLK_SET_BITS((GC_FCLK_EN | GC_HCLK_EN), 0);
+	CLK_SET_BITS(GC_FCLK_REQ, 0);
+	__clk_wait_fc_done(clk);
+	spin_unlock(&gc_lock);
+	trace_pxa_gc2d_clk(CLK_ENABLE, __raw_readl(clk->clk_rst));
+	pr_debug("%s %s %x\n", __func__, clk->name, __raw_readl(clk->clk_rst));
+#ifdef CONFIG_DEBUG_FS
+	pxa988_clk_dcstat_event(clk, CLK_STATE_ON, 0);
+#endif
+	return 0;
+}
+
+static void gc2d_clk_disable(struct clk *clk)
+{
+	spin_lock(&gc_lock);
+	CLK_SET_BITS(0, (GC_FCLK_EN | GC_HCLK_EN));
+	spin_unlock(&gc_lock);
+	trace_pxa_gc2d_clk(CLK_DISABLE, __raw_readl(clk->clk_rst));
+	pr_debug("%s %s : %x\n", __func__, clk->name,
+		 __raw_readl(clk->clk_rst));
+#ifdef CONFIG_DEBUG_FS
+	pxa988_clk_dcstat_event(clk, CLK_STATE_OFF, 0);
+#endif
+}
+
+static long gc2d_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return __clk_round_rate_bytbl(clk, rate, \
+		gc2d_fclk_tbl, ARRAY_SIZE(gc2d_fclk_tbl));
+}
+
+static int gc2d_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long old_rate;
+	unsigned int i;
+	struct clk *new_fparent;
+
+	old_rate = clk->rate;
+	if (rate == old_rate)
+		return 0;
+
+	i = 0;
+	while (gc2d_fclk_tbl[i].clk_rate != rate)
+		i++;
+	BUG_ON(i == ARRAY_SIZE(gc2d_fclk_tbl));
+
+	/* set GC2D function clk rate */
+	new_fparent = gc2d_fclk_tbl[i].parent;
+	spin_lock(&gc_lock);
+	__clk_set_mux_div(clk, new_fparent,
+		gc2d_fclk_tbl[i].src_val, (gc2d_fclk_tbl[i].div_val + 1));
+	spin_unlock(&gc_lock);
+
+#ifndef DDR_COMBINDEDCLK_SOLUTION
+	/* set GC bus clk rate here if aclk is bound with fclk */
+	clk_set_rate(&gc2d_aclk, gc2d_fclk_tbl[i].comclk_rate);
+#endif
+
+	trace_pxa_gc2d_clk_chg(clk->rate, rate);
+	pr_debug("%s %s %x\n", __func__, clk->name, __raw_readl(clk->clk_rst));
+	pr_debug("%s rate %lu->%lu\n", __func__, old_rate, rate);
+
+#ifdef CONFIG_DEBUG_FS
+	pxa988_clk_dcstat_event(clk, CLK_RATE_CHANGE, i);
+#endif
+	return 0;
+}
+
+
+struct clkops gc2d_clk_ops = {
+	.init		= gc2d_clk_init,
+	.enable		= gc2d_clk_enable,
+	.disable	= gc2d_clk_disable,
+	.round_rate	= gc2d_clk_round_rate,
+	.setrate	= gc2d_clk_setrate,
+	.getrate	= gc_clk_getrate,
+};
+
+static struct clk pxa988_clk_gc2d = {
+	.name = "gc2d",
+	.lookup = {
+		.con_id = "GC2DCLK",
+	},
+	.clk_rst = (void __iomem *)APMU_GC_2D,
+	.enable_val = GC_FCLK_REQ,
+	.inputs = periph_mux_sel,
+	.ops = &gc2d_clk_ops,
+	.dependence = gc2d_clk_depend,
+	.dependence_count = 1,
+	.reg_data = {
+		     { {APMU_GC_2D, 6, 0x3}, {APMU_GC_2D, 6, 0x3} },
+		     { {APMU_GC_2D, 12, 0x7}, {APMU_GC_2D, 12, 0x7} } },
+	.is_combined_fc = 1,
+};
+
+/* interface used by GC driver to get avaliable GC2D frequencies, unit HZ */
+int get_gcu2d_freqs_table(unsigned long *gcu2d_freqs_table,
+	unsigned int *item_counts, unsigned int max_item_counts)
+{
+	unsigned int index;
+	*item_counts = 0;
+
+	if (!gcu2d_freqs_table) {
+		pr_err("%s NULL ptr!\n", __func__);
+		return -EINVAL;
+	}
+
+	if (max_item_counts < ARRAY_SIZE(gc2d_fclk_tbl)) {
+		pr_err("%s Too many GC2D frequencies %u!\n", __func__,
+			max_item_counts);
+		return -EINVAL;
+	}
+
+	for (index = 0; index < ARRAY_SIZE(gc2d_fclk_tbl); index++)
+		gcu2d_freqs_table[index] = gc2d_fclk_tbl[index].clk_rate;
+	*item_counts = index;
+	return 0;
+}
+EXPORT_SYMBOL(get_gcu2d_freqs_table);
+
+#define VPU_ACLK_EN	(0x1 << 3)
+#define VPU_FCLK_EN	(0x1 << 4)
+#define	VPU_AHBCLK_EN	(0x1 << 5)
+
+#define VPU_FCLK_SEL(n)		((n & 0x3) << 6)
+#define	VPU_FCLK_SEL_MASK	VPU_FCLK_SEL(0x3)
+#define VPU_FCLK_DIV(n)		((n & 0x7) << 8)
+#define VPU_FCLK_DIV_MASK	VPU_FCLK_DIV(0x7)
+#define VPU_FCLK_REQ		(0x1 << 20)
+
+#define VPU_ACLK_SEL(n)		((n & 0x3) << 11)
+#define VPU_ACLK_SEL_MASK	VPU_ACLK_SEL(0x3)
+#define VPU_ACLK_DIV(n)		((n & 0x7) << 13)
+#define VPU_ACLK_DIV_MASK	VPU_ACLK_DIV(0x7)
+#define VPU_ACLK_REQ		(0x1 << 21)
+
+#define VPU_FCLK_RATE(fsrc, fdiv) \
+	(VPU_FCLK_SEL(fsrc) | VPU_FCLK_DIV(fdiv))
+
+#define VPU_ACLK_RATE(asrc, adiv) \
+	(VPU_ACLK_SEL(asrc) | VPU_ACLK_DIV(adiv))
+
+#define VPU_CLK_RATE_MSK				\
+	(VPU_FCLK_SEL_MASK | VPU_FCLK_DIV_MASK		\
+	| VPU_ACLK_SEL_MASK | VPU_ACLK_DIV_MASK)	\
+
+struct xpu_rtcwtc vpu_rtcwtc_1088[] = {
+	{.max_rate = 156000000, .rtcwtc = 0x00B04444,},
+	{.max_rate = 208000000, .rtcwtc = 0x00B05544,},
+	{.max_rate = 416000000, .rtcwtc = 0x00B06655,},
+};
+
+/*
+ * 1. sort ascending
+ * 2. FIXME: If DDR 533M is used, 400M bus clk could not be
+ * supported due to clk src issue.
+ * 3. For 988 Z1/Z2, only uses vpu aclk 150/300/400
+ * 4. For 988 Z3, only uses vpu aclk 156/208/312/416
+ * 5. For 1088, temporarily use Z3 table, will be updated
+ *    once DE/SV table is given
+ */
+static struct periph_clk_tbl vpu_aclk_tbl[] = {
+	{.clk_rate = 150000000, .parent = &pll2},
+	{.clk_rate = 156000000, .parent = &pll1_624},
+	{.clk_rate = 208000000, .parent = &pll1_416},
+	{.clk_rate = 300000000, .parent = &pll2},
+	{.clk_rate = 312000000, .parent = &pll1_624},
+	{.clk_rate = 400000000, .parent = &pll2p},
+	{.clk_rate = 416000000, .parent = &pll1_416},
+};
+
+static void vpu_aclk_init(struct clk *clk)
+{
+	__clk_fill_periph_tbl(clk, vpu_aclk_tbl,
+		ARRAY_SIZE(vpu_aclk_tbl));
+	/* default VPU aclk = 416M sel = pll1_416, div = 1 */
+	__clk_periph_init(clk, &pll1_416, 1, 1);
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+	if (cpu_is_z1z2())
+		register_clk_bind2ddr(clk,
+			vpu_aclk_tbl[ARRAY_SIZE(vpu_aclk_tbl) - 1].clk_rate,
+			NULL, 0);
+#endif
+}
+
+static int vpu_aclk_enable(struct clk *clk)
+{
+	spin_lock(&vpu_lock);
+	CLK_SET_BITS(VPU_ACLK_EN, 0);
+	CLK_SET_BITS(VPU_ACLK_REQ, 0);
+	__clk_wait_fc_done(clk);
+	spin_unlock(&vpu_lock);
+	pr_debug("%s VPU_ACLK %x\n", __func__, __raw_readl(clk->clk_rst));
+	return 0;
+}
+
+static void vpu_aclk_disable(struct clk *clk)
+{
+	spin_lock(&vpu_lock);
+	CLK_SET_BITS(0, VPU_ACLK_EN);
+	spin_unlock(&vpu_lock);
+	return;
+}
+
+static long vpu_aclk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return __clk_round_rate_bytbl(clk, rate, \
+		vpu_aclk_tbl, ARRAY_SIZE(vpu_aclk_tbl));
+}
+
+static int vpu_aclk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long old_rate;
+	unsigned int i;
+	struct clk *new_parent;
+
+	old_rate = clk->rate;
+	if (rate == old_rate)
+		return 0;
+
+	i = 0;
+	while (vpu_aclk_tbl[i].clk_rate != rate)
+		i++;
+	BUG_ON(i == ARRAY_SIZE(vpu_aclk_tbl));
+
+	new_parent = vpu_aclk_tbl[i].parent;
+	spin_lock(&vpu_lock);
+	__clk_set_mux_div(clk, new_parent,
+		vpu_aclk_tbl[i].src_val, (vpu_aclk_tbl[i].div_val + 1));
+	spin_unlock(&vpu_lock);
+
+	pr_debug("%s rate %lu->%lu\n", clk->name, old_rate, rate);
+	return 0;
+}
+
+static unsigned long vpu_aclk_getrate(struct clk *clk)
+{
+	return __clk_periph_get_rate(clk);
+}
+
+struct clkops vpu_aclk_ops = {
+	.init		= vpu_aclk_init,
+	.enable		= vpu_aclk_enable,
+	.disable	= vpu_aclk_disable,
+	.round_rate	= vpu_aclk_round_rate,
+	.setrate	= vpu_aclk_setrate,
+	.getrate	= vpu_aclk_getrate,
+};
+
+/*
+ * VPU aclk node is internal clk node, and
+ * can only be used by VPU fclk
+ */
+static struct clk vpu_aclk = {
+	.name = "vpu_aclk",
+	.lookup = {
+		.con_id = "VPUACLK",
+	},
+	.clk_rst = (void __iomem *)APMU_VPU_CLK_RES_CTRL,
+	.enable_val = VPU_ACLK_REQ,
+	.inputs = periph_mux_sel,
+	.ops = &vpu_aclk_ops,
+	.reg_data = {
+		     { {APMU_VPU_CLK_RES_CTRL, 11, 0x3},
+			{APMU_VPU_CLK_RES_CTRL, 11, 0x3} },
+		     { {APMU_VPU_CLK_RES_CTRL, 13, 0x7},
+			{APMU_VPU_CLK_RES_CTRL, 13, 0x7} } }
+};
+
+static struct clk *vpu_clk_depend[] = {
+	&vpu_aclk,
+};
+
+/* sort ascending */
+static struct periph_clk_tbl vpu_fclk_tbl_z1z2[] = {
+	{
+		.clk_rate = 150000000,
+		.parent = &pll2,
+	},
+	{
+		.clk_rate = 200000000,
+		.parent = &pll2p,
+	},
+	{
+		.clk_rate = 300000000,
+		.parent = &pll2,
+	},
+	{
+		.clk_rate = 400000000,
+		.parent = &pll2p,
+	},
+};
+
+static struct periph_clk_tbl vpu_fclk_tbl[] = {
+	{
+		.clk_rate = 156000000,
+		.parent = &pll1_624,
+		.comclk_rate = 156000000,
+	},
+	{
+		.clk_rate = 208000000,
+		.parent = &pll1_416,
+		.comclk_rate = 208000000,
+	},
+	{
+		.clk_rate = 312000000,
+		.parent = &pll1_624,
+		.comclk_rate = 312000000,
+	},
+	{
+		.clk_rate = 416000000,
+		.parent = &pll1_416,
+		.comclk_rate = 416000000
+	},
+};
+
+unsigned int pxa988_get_vpu_op_num(void)
+{
+	return ARRAY_SIZE(vpu_fclk_tbl);
+}
+
+/* unit Khz */
+unsigned int pxa988_get_vpu_op_rate(unsigned int index)
+{
+	if (index >= ARRAY_SIZE(vpu_fclk_tbl)) {
+		pr_err("%s index out of range!\n", __func__);
+		return -EINVAL;
+	}
+
+	return vpu_fclk_tbl[index].clk_rate / MHZ_TO_KHZ;
+}
+
+static struct pm_qos_request vpu_qos_idle;
+static void vpu_clk_init(struct clk *clk)
+{
+#ifdef CONFIG_DEBUG_FS
+	unsigned int i;
+	unsigned long op[ARRAY_SIZE(vpu_fclk_tbl)];
+#endif
+	unsigned long cur_rate;
+	int index;
+
+	if (has_feat_disable_d1P_vpu_on()) {
+		vpu_qos_idle.name = "VPU";
+		pm_qos_add_request(&vpu_qos_idle, PM_QOS_CPUIDLE_BLOCK,
+				PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+	}
+
+	if (cpu_is_z1z2())
+		memcpy(&vpu_fclk_tbl, &vpu_fclk_tbl_z1z2,
+			sizeof(struct periph_clk_tbl) *\
+				ARRAY_SIZE(vpu_fclk_tbl));
+
+	__clk_fill_periph_tbl(clk, vpu_fclk_tbl, ARRAY_SIZE(vpu_fclk_tbl));
+	if (cpu_is_pxa1088())
+		__clk_fill_periphtbl_xtc(vpu_fclk_tbl, ARRAY_SIZE(vpu_fclk_tbl),
+				vpu_rtcwtc_1088, ARRAY_SIZE(vpu_rtcwtc_1088));
+
+	if (cpu_is_z1z2())
+		/* default VPU fclk = 300M sel = pll2 = 1200M, div = 4 */
+		__clk_periph_init(clk, &pll2, 4, 1);
+	else
+		/* default VPU fclk = 416M sel = pll1_416, div = 1 */
+		__clk_periph_init(clk, &pll1_416, 1, 1);
+
+	cur_rate  = __clk_periph_get_rate(clk);
+	for (index = 0; index < ARRAY_SIZE(vpu_fclk_tbl); index++)
+		if (vpu_fclk_tbl[index].clk_rate >= cur_rate)
+			break;
+	if (index == ARRAY_SIZE(vpu_fclk_tbl))
+		index--;
+	if (vpu_fclk_tbl[index].rtcwtc)
+		writel_relaxed(vpu_fclk_tbl[index].rtcwtc, CIU_VPU_XTC_REG);
+#ifdef CONFIG_DEBUG_FS
+	for (i = 0; i < ARRAY_SIZE(vpu_fclk_tbl); i++)
+		op[i] = vpu_fclk_tbl[i].clk_rate;
+	pxa988_clk_register_dcstat(clk, op, ARRAY_SIZE(vpu_fclk_tbl));
+#endif
+}
+
+static int vpu_clk_enable(struct clk *clk)
+{
+	if (has_feat_disable_d1P_vpu_on())
+		pm_qos_update_request(&vpu_qos_idle,
+				PM_QOS_CPUIDLE_BLOCK_AXI_VALUE);
+
+	spin_lock(&vpu_lock);
+	CLK_SET_BITS((VPU_FCLK_EN | VPU_AHBCLK_EN), 0);
+	CLK_SET_BITS(VPU_FCLK_REQ, 0);
+	__clk_wait_fc_done(clk);
+	spin_unlock(&vpu_lock);
+	trace_pxa_vpu_clk(CLK_ENABLE, __raw_readl(clk->clk_rst));
+	pr_debug("%s VPU_CLK %x\n", __func__, __raw_readl(clk->clk_rst));
+
+#ifdef CONFIG_DEBUG_FS
+	pxa988_clk_dcstat_event(clk, CLK_STATE_ON, 0);
+#endif
+	return 0;
+}
+
+static void vpu_clk_disable(struct clk *clk)
+{
+	spin_lock(&vpu_lock);
+	CLK_SET_BITS(0, (VPU_FCLK_EN | VPU_AHBCLK_EN));
+	spin_unlock(&vpu_lock);
+	trace_pxa_vpu_clk(CLK_DISABLE, __raw_readl(clk->clk_rst));
+	pr_debug("%s VPU_CLK %x\n", __func__, __raw_readl(clk->clk_rst));
+
+#ifdef CONFIG_DEBUG_FS
+	pxa988_clk_dcstat_event(clk, CLK_STATE_OFF, 0);
+#endif
+
+	if (has_feat_disable_d1P_vpu_on())
+		pm_qos_update_request(&vpu_qos_idle,
+				PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+}
+
+static long vpu_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return __clk_round_rate_bytbl(clk, rate, \
+		vpu_fclk_tbl, ARRAY_SIZE(vpu_fclk_tbl));
+}
+
+static int vpu_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long old_rate;
+	unsigned int i;
+	struct clk *new_fparent;
+
+	old_rate = clk->rate;
+	if (rate == old_rate)
+		return 0;
+
+	i = 0;
+	while (vpu_fclk_tbl[i].clk_rate != rate)
+		i++;
+	BUG_ON(i == ARRAY_SIZE(vpu_fclk_tbl));
+
+	if (vpu_fclk_tbl[i].rtcwtc && (clk->rate < rate))
+		writel_relaxed(vpu_fclk_tbl[i].rtcwtc, CIU_VPU_XTC_REG);
+
+	/* set VPU function clk rate */
+	new_fparent = vpu_fclk_tbl[i].parent;
+	spin_lock(&vpu_lock);
+	__clk_set_mux_div(clk, new_fparent,
+		vpu_fclk_tbl[i].src_val, (vpu_fclk_tbl[i].div_val + 1));
+	spin_unlock(&vpu_lock);
+
+	/* set VPU bus clk rate here if aclk is bound with fclk */
+	if (!cpu_is_z1z2())
+		clk_set_rate(&vpu_aclk, vpu_fclk_tbl[i].comclk_rate);
+
+	if (vpu_fclk_tbl[i].rtcwtc && (clk->rate > rate))
+		writel_relaxed(vpu_fclk_tbl[i].rtcwtc, CIU_VPU_XTC_REG);
+
+	trace_pxa_vpu_clk_chg(clk->rate, rate);
+	pr_debug("%s VPU_CLK : %x\n", __func__,  __raw_readl(clk->clk_rst));
+	pr_debug("%s rate %lu->%lu\n", __func__, clk->rate, rate);
+
+#ifdef CONFIG_DEBUG_FS
+	pxa988_clk_dcstat_event(clk, CLK_RATE_CHANGE, i);
+#endif
+	return 0;
+}
+
+static unsigned long vpu_clk_getrate(struct clk *clk)
+{
+	/* can only get fclk here */
+	return __clk_periph_get_rate(clk);
+}
+
+struct clkops vpu_clk_ops = {
+	.init		= vpu_clk_init,
+	.enable		= vpu_clk_enable,
+	.disable	= vpu_clk_disable,
+	.round_rate	= vpu_clk_round_rate,
+	.setrate	= vpu_clk_setrate,
+	.getrate	= vpu_clk_getrate,
+};
+
+static struct clk pxa988_clk_vpu = {
+	.name = "vpu",
+	.lookup = {
+		.con_id = "VPUCLK",
+	},
+	.inputs = periph_mux_sel,
+	.clk_rst = (void __iomem *)APMU_VPU_CLK_RES_CTRL,
+	.enable_val = VPU_FCLK_REQ,
+	.ops = &vpu_clk_ops,
+	.dependence = vpu_clk_depend,
+	.dependence_count = 1,
+	.reg_data = {
+		     { {APMU_VPU_CLK_RES_CTRL, 6, 0x3},
+			{APMU_VPU_CLK_RES_CTRL, 6, 0x3} },
+		     { {APMU_VPU_CLK_RES_CTRL, 8, 0x7},
+			{APMU_VPU_CLK_RES_CTRL, 8, 0x7} } },
+	.is_combined_fc = 1,
+};
+
+#define LCD_CI_ISP_ACLK_REQ		(1 << 22)
+#define LCD_CI_ISP_ACLK_EN		(1 << 3)
+#define LCD_CI_ISP_ACLK_RST		(1 << 16)
+
+/*
+ * 1. This AXI clock is shared by LCD/CI/ISP
+ * 2. Separate bit in LCD/CI/ISP_CLK_RES_REG is used
+ * to enable its own bus clock
+ * 3. Register setting is defined in LCD_CLK_RES_REG
+ * 4. The safe maximum rate is 312M per DE's suggestion on Z0
+ * 5. Use 208M for Z0 bringup at first
+ */
+static struct periph_clk_tbl lcd_ci_isp_axi_clk_tbl[] = {
+	{.clk_rate = 150000000, .parent = &pll2},
+	{.clk_rate = 156000000, .parent = &pll1_624},
+	{.clk_rate = 200000000, .parent = &pll2p},
+	{.clk_rate = 208000000, .parent = &pll1_416},
+	{.clk_rate = 300000000, .parent = &pll2},
+	{.clk_rate = 312000000, .parent = &pll1_624},
+};
+
+static void lcd_ci_isp_axi_clk_init(struct clk *clk)
+{
+	__clk_fill_periph_tbl(clk, lcd_ci_isp_axi_clk_tbl,\
+		ARRAY_SIZE(lcd_ci_isp_axi_clk_tbl));
+	__clk_periph_init(clk, &pll1_416, 2, 1);
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+	if (cpu_is_z1z2())
+		register_clk_bind2ddr(clk,
+			lcd_ci_isp_axi_clk_tbl[ARRAY_SIZE(lcd_ci_isp_axi_clk_tbl) - 1].clk_rate,
+			NULL, 0);
+#endif
+}
+
+static int lcd_ci_isp_axi_clk_enable(struct clk *clk)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&lcd_ci_share_lock, flags);
+	CLK_SET_BITS(LCD_CI_ISP_ACLK_RST | LCD_CI_ISP_ACLK_EN, 0);
+	CLK_SET_BITS(LCD_CI_ISP_ACLK_REQ, 0);
+	__clk_wait_fc_done(clk);
+	spin_unlock_irqrestore(&lcd_ci_share_lock, flags);
+	return 0;
+}
+
+static void lcd_ci_isp_axi_clk_disable(struct clk *clk)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&lcd_ci_share_lock, flags);
+	CLK_SET_BITS(0, LCD_CI_ISP_ACLK_EN);
+	spin_unlock_irqrestore(&lcd_ci_share_lock, flags);
+}
+
+static long lcd_ci_isp_axi_clk_roundrate(struct clk *clk, unsigned long rate)
+{
+	return __clk_round_rate_bytbl(clk, rate, \
+		lcd_ci_isp_axi_clk_tbl,
+		ARRAY_SIZE(lcd_ci_isp_axi_clk_tbl));
+}
+
+static int lcd_ci_isp_axi_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long flags;
+	unsigned int i;
+	struct clk *new_parent;
+
+	i = 0;
+	while (lcd_ci_isp_axi_clk_tbl[i].clk_rate != rate)
+		i++;
+	BUG_ON(i == ARRAY_SIZE(lcd_ci_isp_axi_clk_tbl));
+
+	new_parent = lcd_ci_isp_axi_clk_tbl[i].parent;
+	spin_lock_irqsave(&lcd_ci_share_lock, flags);
+	__clk_set_mux_div(clk, new_parent,
+		lcd_ci_isp_axi_clk_tbl[i].src_val,
+		(lcd_ci_isp_axi_clk_tbl[i].div_val + 1));
+	spin_unlock_irqrestore(&lcd_ci_share_lock, flags);
+	return 0;
+}
+
+static unsigned long lcd_ci_isp_axi_clk_getrate(struct clk *clk)
+{
+	unsigned long rate, flags;
+
+	spin_lock_irqsave(&lcd_ci_share_lock, flags);
+	rate = __clk_periph_get_rate(clk);
+	spin_unlock_irqrestore(&lcd_ci_share_lock, flags);
+	return rate;
+}
+
+struct clkops lcd_ci_isp_axi_clk_ops = {
+	.init		= lcd_ci_isp_axi_clk_init,
+	.enable		= lcd_ci_isp_axi_clk_enable,
+	.disable	= lcd_ci_isp_axi_clk_disable,
+	.round_rate	= lcd_ci_isp_axi_clk_roundrate,
+	.setrate	= lcd_ci_isp_axi_clk_setrate,
+	.getrate	= lcd_ci_isp_axi_clk_getrate,
+};
+
+/* bus clock shared by lcd, ci and isp */
+static struct clk lcd_ci_isp_axi_clk = {
+	.name = "lcd_ci_isp_axi",
+	.lookup = {
+		.con_id = "LCDCIISPAXI",
+	},
+	.clk_rst = (void __iomem *)APMU_LCD,
+	.enable_val = LCD_CI_ISP_ACLK_REQ,
+	.inputs = periph_mux_sel,
+	.ops = &lcd_ci_isp_axi_clk_ops,
+	.reg_data = {
+		     { {APMU_LCD, 17, 0x3}, {APMU_LCD, 17, 0x3} },
+		     { {APMU_LCD, 19, 0x7}, {APMU_LCD, 19, 0x7} } }
+};
+
+#define LCD_CI_HCLK_EN		(1 << 5)
+#define LCD_CI_HCLK_RST		(1 << 2)
+
+static int lcd_ci_hclk_enable(struct clk *clk)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&lcd_ci_share_lock, flags);
+	CLK_SET_BITS((LCD_CI_HCLK_EN | LCD_CI_HCLK_RST) , 0);
+	spin_unlock_irqrestore(&lcd_ci_share_lock, flags);
+	return 0;
+}
+
+static void lcd_ci_hclk_disable(struct clk *clk)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&lcd_ci_share_lock, flags);
+	CLK_SET_BITS(0, LCD_CI_HCLK_EN);
+	spin_unlock_irqrestore(&lcd_ci_share_lock, flags);
+}
+
+struct clkops  lcd_ci_hclk_ops = {
+	.enable		= lcd_ci_hclk_enable,
+	.disable	= lcd_ci_hclk_disable,
+};
+
+static struct clk pxa988_lcd_ci_hclk = {
+	.name = "lcd_ci_hclk",
+	.lookup = {
+		.con_id = "LCDCIHCLK",
+	},
+	.clk_rst = (void __iomem *)APMU_LCD,
+	.ops = &lcd_ci_hclk_ops,
+};
+
+static inline int __ccic_clk_common_enable(struct clk *clk, unsigned int bits)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&ccic_lock, flags);
+	CLK_SET_BITS(bits, 0);
+	spin_unlock_irqrestore(&ccic_lock, flags);
+	return 0;
+}
+
+static inline void __ccic_clk_common_disable(struct clk *clk, unsigned int bits)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&ccic_lock, flags);
+	CLK_SET_BITS(0, bits);
+	spin_unlock_irqrestore(&ccic_lock, flags);
+}
+
+#define CCIC_AXI_EN	((1 << 0) | (1 << 3))
+#define CCIC_AXI_DIS	(1 << 3)
+
+static int ccic_axi_clk_enable(struct clk *clk)
+{
+	return __ccic_clk_common_enable(clk, CCIC_AXI_EN);
+}
+
+static void ccic_axi_clk_disable(struct clk *clk)
+{
+	__ccic_clk_common_disable(clk, CCIC_AXI_DIS);
+}
+
+struct clkops ccic_axi_clk_ops = {
+	.enable		= ccic_axi_clk_enable,
+	.disable	= ccic_axi_clk_disable,
+};
+
+static struct clk pxa988_ccic_axi_clk = {
+	.name = "ccic_axi",
+	.lookup = {
+		.con_id = "CCICAXICLK",
+	},
+	.clk_rst = (void __iomem *)APMU_CCIC_RST,
+	.parent = &lcd_ci_isp_axi_clk,
+	.ops = &ccic_axi_clk_ops,
+};
+
+#define CCIC_PHYSLOW_PRER	(0x1A << 10)
+#define CCIC_PHYCLK_SEL		(0x1 << 7)
+#define CCIC_PHYCLK_SELDIV	\
+	(CCIC_PHYSLOW_PRER | CCIC_PHYCLK_SEL)
+#define CCIC_PHYCLK_SELDIV_MSK	((1 << 7) | (0x1f << 10))
+#define CCIC_PHY_EN	((1 << 5)|(1 << 8)|(1 << 9))
+#define CCIC_PHY_DIS	((1 << 5)|(1 << 9))
+#define CSI_DPHY_RST	(1 << 2)
+
+static void ccic_phy_clk_init(struct clk *clk)
+{
+	/* default sel:52M  div : 0x1f */
+	CLK_SET_BITS(CCIC_PHYCLK_SELDIV,
+		CCIC_PHYCLK_SELDIV_MSK);
+}
+
+static int ccic_phy_clk_enable(struct clk *clk)
+{
+	__ccic_clk_common_enable(clk, CSI_DPHY_RST);
+	__ccic_clk_common_enable(clk, CCIC_PHY_EN);
+	__raw_writel(0x06000000 | __raw_readl(APMU_CCIC_DBG),
+			APMU_CCIC_DBG);
+	return 0;
+}
+
+static void ccic_phy_clk_disable(struct clk *clk)
+{
+	__ccic_clk_common_disable(clk, CCIC_PHY_DIS);
+	__raw_writel((~0x06000000) & __raw_readl(APMU_CCIC_DBG),
+		APMU_CCIC_DBG);
+	__ccic_clk_common_disable(clk, CSI_DPHY_RST);
+}
+
+struct clkops ccic_phy_clk_ops = {
+	.init		= ccic_phy_clk_init,
+	.enable		= ccic_phy_clk_enable,
+	.disable	= ccic_phy_clk_disable,
+};
+
+static struct clk pxa988_ccic_phy_clk = {
+	.name = "ccic_phy",
+	.lookup = {
+		.con_id = "CCICPHYCLK",
+	},
+	.clk_rst = (void __iomem *)APMU_CCIC_RST,
+	.ops = &ccic_phy_clk_ops,
+};
+
+#define CI_FUNC_CLK_REQ		(1 << 15)
+#define CI_FUNC_CLK_EN		((1 << 1) | (1 << 4))
+#define CI_FUNC_CLK_DIS		(1 << 4)
+
+/* used for CCIC LPM constraint */
+static struct pm_qos_request ccic_lpm_cons;
+static void ccic_func_clk_init(struct clk *clk)
+{
+	/* initialize the qos list at the first time */
+	ccic_lpm_cons.name = "CCIC";
+	pm_qos_add_request(&ccic_lpm_cons, PM_QOS_CPUIDLE_BLOCK,
+			PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+
+	/* default 312M pll1_624/2 */
+	__clk_periph_init(clk, &pll1_624, 2, 0);
+}
+
+static int ccic_func_clk_enable(struct clk *clk)
+{
+	pm_qos_update_request(&ccic_lpm_cons, PM_QOS_CPUIDLE_BLOCK_AXI_VALUE);
+	__ccic_clk_common_enable(clk, CI_FUNC_CLK_EN);
+	return __ccic_clk_common_enable(clk, \
+		CI_FUNC_CLK_REQ);
+}
+
+static void ccic_func_clk_disable(struct clk *clk)
+{
+	__ccic_clk_common_disable(clk, CI_FUNC_CLK_DIS);
+	pm_qos_update_request(&ccic_lpm_cons,
+			PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+
+}
+
+static int ccic_func_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ccic_lock, flags);
+	__clk_periph_set_rate(clk, rate);
+	spin_unlock_irqrestore(&ccic_lock, flags);
+	return 0;
+}
+
+static unsigned long ccic_func_clk_getrate(struct clk *clk)
+{
+	unsigned long rate, flags;
+
+	spin_lock_irqsave(&ccic_lock, flags);
+	rate = __clk_periph_get_rate(clk);
+	spin_unlock_irqrestore(&ccic_lock, flags);
+	return rate;
+}
+
+struct clkops ccic_func_clk_ops = {
+	.init		= ccic_func_clk_init,
+	.enable		= ccic_func_clk_enable,
+	.disable	= ccic_func_clk_disable,
+	.setrate	= ccic_func_clk_setrate,
+	.getrate	= ccic_func_clk_getrate,
+};
+
+static struct clk pxa988_ccic_func_clk = {
+	.name = "ccic_func",
+	.lookup = {
+		.con_id = "CCICFUNCLK",
+	},
+	.clk_rst = (void __iomem *)APMU_CCIC_RST,
+	.inputs = periph_mux_sel,
+	.ops = &ccic_func_clk_ops,
+	.reg_data = {
+		     { {APMU_CCIC_RST, 16, 0x3}, {APMU_CCIC_RST, 16, 0x3} },
+		     { {APMU_CCIC_RST, 18, 0x7}, {APMU_CCIC_RST, 18, 0x7} } }
+};
+
+#define DSI_PHYSLOW_PRER	(0x1A << 6)
+#define DSI_ESC_SEL		(0x0)
+#define DSI_PHYESC_SELDIV	\
+	(DSI_PHYSLOW_PRER | DSI_ESC_SEL)
+#define DSI_PHYESC_SELDIV_MSK	((0x1f << 6) | 0x3)
+#define DSI_PHY_CLK_EN	((1 << 2) | (1 << 5))
+#define DSI_PHY_CLK_RST	((1 << 3) | (1 << 4))
+
+static void dsi_phy_clk_init(struct clk *clk)
+{
+	/* default sel 78M, div 0x1A */
+	CLK_SET_BITS(DSI_PHYESC_SELDIV,
+		DSI_PHYESC_SELDIV_MSK);
+}
+
+static int dsi_phy_clk_enable(struct clk *clk)
+{
+	CLK_SET_BITS(DSI_PHY_CLK_EN, 0);
+	CLK_SET_BITS(DSI_PHY_CLK_RST, 0);
+	return 0;
+}
+
+static void dsi_phy_clk_disable(struct clk *clk)
+{
+	CLK_SET_BITS(0, DSI_PHY_CLK_EN);
+}
+
+struct clkops dsi_phy_clk_ops = {
+	.init = dsi_phy_clk_init,
+	.enable = dsi_phy_clk_enable,
+	.disable = dsi_phy_clk_disable,
+};
+
+static struct clk lcd_dsi_phy_clk = {
+	.name = "lcd_dsi_phy",
+	.lookup = {
+		.con_id = "DSIPHYCLK",
+	},
+	.clk_rst = (void __iomem *)APMU_DSI,
+	.ops = &dsi_phy_clk_ops,
+};
+
+#define LCD_PST_CKEN		(1 << 9)
+#define LCD_PST_OUTDIS		(1 << 8)
+#define LCD_CLK_EN		(1 << 4)
+#define LCD_CLK_RST		(1 << 1 | 1 << 0)
+#define LCD_DEF_FCLK_SEL	(1 << 6)
+#define LCD_FCLK_SEL_MASK	(1 << 6)
+
+static struct pm_qos_request ddrfreq_qos_req_min;
+
+/* Actually this clock is the src of LCD controller and DSI */
+/* Will be further divided in LCD */
+static void lcd_func_clk_init(struct clk *clk)
+{
+
+#ifdef CONFIG_CORE_1248
+	clk_reparent(clk, &pll3);
+#elif defined(CONFIG_MACH_WILCOX) || defined(CONFIG_MACH_CT01) || defined(CONFIG_MACH_GOYA)
+	clk_reparent(clk, &pll1_624);
+#else
+	/* 1 --- 416M by default */
+	CLK_SET_BITS(LCD_DEF_FCLK_SEL, LCD_FCLK_SEL_MASK);
+	/* Default enable the post divider */
+	CLK_SET_BITS(LCD_PST_CKEN, LCD_PST_OUTDIS);
+	clk_reparent(clk, &pll1_416);
+#endif
+	clk->mul = clk->div = 1;
+	clk->rate = clk_get_rate(clk->parent);
+	if (has_feat_fhd_ddr_rqs()) {
+		ddrfreq_qos_req_min.name = "LCD";
+		pm_qos_add_request(&ddrfreq_qos_req_min,
+				PM_QOS_DDR_DEVFREQ_MIN,
+				PM_QOS_DEFAULT_VALUE);
+	}
+}
+
+static int lcd_func_clk_enable(struct clk *clk)
+{
+	unsigned long flags;
+	if (has_feat_fhd_ddr_rqs())
+		/* Request DDR at least 312M */
+		pm_qos_update_request(&ddrfreq_qos_req_min,
+					DDR_CONSTRAINT_LVL1);
+	spin_lock_irqsave(&lcd_ci_share_lock, flags);
+	CLK_SET_BITS((LCD_CLK_EN | LCD_CLK_RST), 0);
+	spin_unlock_irqrestore(&lcd_ci_share_lock, flags);
+	return 0;
+}
+
+static void lcd_func_clk_disable(struct clk *clk)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&lcd_ci_share_lock, flags);
+	CLK_SET_BITS(0, LCD_CLK_EN);
+	spin_unlock_irqrestore(&lcd_ci_share_lock, flags);
+	if (has_feat_fhd_ddr_rqs())
+		/* Release DDR freq constraint */
+		pm_qos_update_request(&ddrfreq_qos_req_min,
+					PM_QOS_DEFAULT_VALUE);
+}
+
+static long lcd_func_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	/* Do nothing here, but select the correct rate in set rate ops */
+	return rate;
+}
+
+/*
+ * LCD post divider is special one, div 0:
+ * input = output, div 2~16 output = input / div
+ */
+static int lcd_func_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned int mux = 0, div = 0;
+	struct clk *best_parent;
+	unsigned long new_rate;
+	unsigned int set, clear;
+
+	if (rate == clk->rate)
+		return 0;
+
+	new_rate =
+		__clk_sel_mux_div(clk, rate, &mux, &div, &best_parent);
+	if (best_parent != &pll3) {
+		set = mux << clk->reg_data[SOURCE][CONTROL].reg_shift;
+		clear = (clk->reg_data[SOURCE][CONTROL].reg_mask << \
+			clk->reg_data[SOURCE][CONTROL].reg_shift) | \
+                        (clk->reg_data[DIV][CONTROL].reg_mask << \
+                         clk->reg_data[DIV][CONTROL].reg_shift);
+		CLK_SET_BITS(set, clear);
+	}
+	clk_reparent(clk, best_parent);
+	if (new_rate != rate)
+		pr_debug("%s tgt%lu sel%lu\n", __func__, rate, new_rate);
+	return 0;
+}
+
+static unsigned long lcd_func_clk_getrate(struct clk *clk)
+{
+	unsigned int mux, div;
+	__clk_get_mux_div(clk, &mux, &div);
+	div = div - 1;
+	if (0 == div || (clk->parent == &pll3))
+		div = 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static struct clk *lcd_depend_clk[] = {
+	&lcd_ci_isp_axi_clk,
+	&lcd_dsi_phy_clk,
+	&pxa988_lcd_ci_hclk,
+};
+
+static struct clk_mux_sel lcd_fclk_clk_mux[] = {
+	{.input = &pll1_416, .value = 1},
+	{.input = &pll1_624, .value = 0},
+	{.input = &pll3, .value = 0},
+	{0, 0},
+};
+
+struct clkops lcd_fclk_clk_ops = {
+	.init = lcd_func_clk_init,
+	.enable = lcd_func_clk_enable,
+	.disable = lcd_func_clk_disable,
+	.round_rate = lcd_func_clk_round_rate,
+	.setrate = lcd_func_clk_setrate,
+	.getrate = lcd_func_clk_getrate,
+};
+
+static struct clk pxa988_lcd_clk = {
+	.name = "lcd",
+	.lookup = {
+		.con_id = "mmp_disp",
+	},
+	.clk_rst = (void __iomem *)APMU_LCD,
+	.dependence = lcd_depend_clk,
+	.dependence_count = ARRAY_SIZE(lcd_depend_clk),
+	.inputs = lcd_fclk_clk_mux,
+	.ops = &lcd_fclk_clk_ops,
+	.reg_data = {
+		{ {APMU_LCD, 6, 0x1}, {APMU_LCD, 6, 0x1} },
+		{ {APMU_LCD, 10, 0x1f}, {APMU_LCD, 10, 0x1f} } }
+};
+
+/* in 988/1088 TV/PN clk looks symmetric */
+#define LCD_PN_SCLK	(0xd420b1a8)
+#define LCD_TV_SCLK	(0xd420b09c)
+#define LCD_SCLK_SRC_PLL1	(1 << 30)
+#define LCD_SCLK_SRC_PLL3	(3 << 30)
+#define LCD_SCLK_SRC_MASK	(3 << 30)
+#define LCD_SCLK_DISABLE	(1 << 28)
+#define LCD_PATHCLK_DIV_MASK	(0xff)
+#define LCD_DSICLK_DIV_SHIFT	8
+#define LCD_DSICLK_DIV_MAX	0xf
+static DEFINE_SPINLOCK(mmp_disp_sclk_lock);
+
+static void disp_sclk_init(struct clk *clk)
+{
+	unsigned long flags;
+	u32 clk_src = LCD_SCLK_SRC_PLL1;
+
+	/* get clk rst */
+	if (!strcmp(clk->name, "disp_pn_sclk"))
+		clk->clk_rst = ioremap(LCD_PN_SCLK, 4);
+	else
+		clk->clk_rst = ioremap(LCD_TV_SCLK, 4);
+
+	clk_reparent(clk, clk->inputs[0].input);
+	if (clk->parent->parent == &pll3)
+		clk_src = LCD_SCLK_SRC_PLL3;
+	clk_enable(&pxa988_lcd_ci_hclk);
+	spin_lock_irqsave(&mmp_disp_sclk_lock, flags);
+	CLK_SET_BITS(clk_src, LCD_SCLK_SRC_MASK);
+	spin_unlock_irqrestore(&mmp_disp_sclk_lock, flags);
+	clk_disable(&pxa988_lcd_ci_hclk);
+
+	/* check rate */
+	clk->rate = clk_get_rate(clk->parent);
+}
+
+static int disp_sclk_enable(struct clk *clk)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&mmp_disp_sclk_lock, flags);
+	CLK_SET_BITS(0, LCD_SCLK_DISABLE);
+	spin_unlock_irqrestore(&mmp_disp_sclk_lock, flags);
+	return 0;
+}
+
+static void disp_sclk_disable(struct clk *clk)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&mmp_disp_sclk_lock, flags);
+	CLK_SET_BITS(LCD_SCLK_DISABLE, LCD_SCLK_DISABLE);
+	spin_unlock_irqrestore(&mmp_disp_sclk_lock, flags);
+}
+
+/* FIXME: possible higher rate period when set rate at clk is running */
+static int disp_sclk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long flags;
+	u32 clk_src = LCD_SCLK_SRC_PLL1;
+
+	if (rate == clk->rate)
+		return 0;
+
+	clk_set_rate(clk->parent, rate);
+	if (clk->parent->parent == &pll3)
+		clk_src = LCD_SCLK_SRC_PLL3;
+	clk_enable(&pxa988_lcd_ci_hclk);
+	spin_lock_irqsave(&mmp_disp_sclk_lock, flags);
+	CLK_SET_BITS(clk_src, LCD_SCLK_SRC_MASK);
+	spin_unlock_irqrestore(&mmp_disp_sclk_lock, flags);
+	clk_disable(&pxa988_lcd_ci_hclk);
+
+	return 0;
+}
+
+static unsigned long disp_sclk_getrate(struct clk *clk)
+{
+	return clk_get_rate(clk->parent);
+}
+
+struct clkops disp_sclk_ops = {
+	.init = disp_sclk_init,
+	.enable = disp_sclk_enable,
+	.disable = disp_sclk_disable,
+	.setrate = disp_sclk_setrate,
+	.getrate = disp_sclk_getrate,
+};
+
+static struct clk_mux_sel disp_sclk_mux[] = {
+	{.input = &pxa988_lcd_clk},
+	{0, 0},
+};
+
+/*
+ * lcd sclk
+ * descendant of LCDCLK
+ * parent of path clk and phy clk
+ * includes source selection and enable/disable
+ */
+static struct clk disp_pn_sclk = {
+	.name = "disp_pn_sclk",
+	.lookup = {
+		.con_id = "mmp_disp_pn_sclk",
+	},
+	.inputs = disp_sclk_mux,
+	.ops = &disp_sclk_ops,
+};
+
+static struct clk disp_tv_sclk = {
+	.name = "disp_tv_sclk",
+	.lookup = {
+		.con_id = "mmp_disp_tv_sclk",
+	},
+	.inputs = disp_sclk_mux,
+	.ops = &disp_sclk_ops,
+};
+
+static void disp_sclk_descendant_init(struct clk *clk)
+{
+	clk_reparent(clk, clk->inputs[0].input);
+	clk->clk_rst = clk->parent->clk_rst;
+	clk->rate = clk_get_rate(clk->parent);
+}
+
+/* FIXME: possible higher rate period when set rate at clk is running */
+static int disp_pathclk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long flags;
+	u32 div;
+
+	if (rate == clk->rate)
+		return 0;
+
+	/*
+	 * as pathclk source is shared with phy clock
+	 * path clk would not set sclk and its parent
+	 * path clk aways use default or phy setted source
+	 */
+	div = (clk_get_rate(clk->parent) + rate / 2) / rate;
+
+	if (!div)
+		div = 1;
+	if (div > LCD_PATHCLK_DIV_MASK)
+		div = LCD_PATHCLK_DIV_MASK;
+
+	clk_enable(&pxa988_lcd_ci_hclk);
+	spin_lock_irqsave(&mmp_disp_sclk_lock, flags);
+	CLK_SET_BITS(div, LCD_PATHCLK_DIV_MASK);
+	spin_unlock_irqrestore(&mmp_disp_sclk_lock, flags);
+	clk_disable(&pxa988_lcd_ci_hclk);
+
+	return 0;
+}
+
+static unsigned long disp_pathclk_getrate(struct clk *clk)
+{
+	u32 div;
+
+	clk_enable(&pxa988_lcd_ci_hclk);
+	div = __raw_readl(clk->clk_rst) & LCD_PATHCLK_DIV_MASK;
+	pr_info("%s:get_rate: source %s rate %dMhz, reg %x\n",
+		clk->name,
+		clk->parent->parent->parent->name,
+		(int) clk_get_rate(clk->parent) / 1000000,
+		__raw_readl(clk->clk_rst));
+	clk_disable(&pxa988_lcd_ci_hclk);
+	return clk_get_rate(clk->parent) / div;
+}
+
+struct clkops disp_pathclk_ops = {
+	.init = disp_sclk_descendant_init,
+	.setrate = disp_pathclk_setrate,
+	.getrate = disp_pathclk_getrate,
+	.enable = clk_pll_dummy_enable,
+	.disable = clk_pll_dummy_disable,
+};
+
+static struct clk_mux_sel disp_pn_sclk_descendant_mux[] = {
+	{.input = &disp_pn_sclk},
+	{0, 0},
+};
+
+static struct clk_mux_sel disp_tv_sclk_descendant_mux[] = {
+	{.input = &disp_tv_sclk},
+	{0, 0},
+};
+
+/*
+ * lcd sclk
+ * descendant of sclk
+ * includes divider
+ */
+static struct clk disp_pnclk = {
+	.name = "pnpath_clk",
+	.lookup = {
+		.con_id = "mmp_pnpath",
+	},
+	.inputs = disp_pn_sclk_descendant_mux,
+	.ops = &disp_pathclk_ops,
+};
+
+static struct clk disp_tvclk = {
+	.name = "tvpath_clk",
+	.lookup = {
+		.con_id = "mmp_tvpath",
+	},
+	.inputs = disp_tv_sclk_descendant_mux,
+	.ops = &disp_pathclk_ops,
+};
+
+static int disp_phyclk_setrate(struct clk *clk, unsigned long rate)
+{
+	u32 div, parent_rate;
+	unsigned long flags;
+
+	if (rate == clk->rate)
+		return 0;
+
+	clk_set_rate(clk->parent, rate);
+	parent_rate = clk_get_rate(clk->parent);
+
+	parent_rate+= rate/2;
+
+	/* multi 1M as pll3 are set in MHz, avoid align issue */
+	div = (parent_rate / 1000000) / (rate / 1000000);
+
+	if (!div)
+		div = 1;
+	if (div > LCD_DSICLK_DIV_MAX)
+		div = LCD_DSICLK_DIV_MAX;
+
+	clk_enable(&pxa988_lcd_ci_hclk);
+	spin_lock_irqsave(&mmp_disp_sclk_lock, flags);
+	CLK_SET_BITS(div << LCD_DSICLK_DIV_SHIFT,
+		LCD_DSICLK_DIV_MAX << LCD_DSICLK_DIV_SHIFT);
+	spin_unlock_irqrestore(&mmp_disp_sclk_lock, flags);
+	clk_disable(&pxa988_lcd_ci_hclk);
+	return 0;
+}
+
+static unsigned long disp_phyclk_getrate(struct clk *clk)
+{
+	u32 div;
+
+	clk_enable(&pxa988_lcd_ci_hclk);
+	div = (__raw_readl(clk->clk_rst) >> LCD_DSICLK_DIV_SHIFT)
+			& LCD_DSICLK_DIV_MAX;
+	pr_info("%s:get_rate: source %s, rate %dMhz, reg %x\n",
+		clk->name,
+		clk->parent->parent->parent->name,
+		(int) clk_get_rate(clk->parent) / 1000000,
+		__raw_readl(clk->clk_rst));
+	clk_disable(&pxa988_lcd_ci_hclk);
+
+	return clk_get_rate(clk->parent) / div;
+}
+
+struct clkops disp_phyclk_ops = {
+	.init = disp_sclk_descendant_init,
+	.setrate = disp_phyclk_setrate,
+	.getrate = disp_phyclk_getrate,
+	.enable = clk_pll_dummy_enable,
+	.disable = clk_pll_dummy_disable,
+};
+
+static struct clk disp_dsi1clk = {
+	.name = "dsi1_clk",
+	.lookup = {
+		.con_id = "mmp_dsi1",
+	},
+	.inputs = disp_pn_sclk_descendant_mux,
+	.ops = &disp_phyclk_ops,
+};
+
+#define ISP_DXO_CLK_EN		\
+	((1 << 1) | (1 << 9) | (1 << 11))
+#define ISP_DXO_CLK_RST		\
+	((1 << 0) | (1 << 8) | (1 << 10))
+#define ISP_DXO_CLK_REQ		(1 << 7)
+
+static void isp_dxo_clk_init(struct clk *clk)
+{
+	/* default 312M pll1_624/2 */
+	__clk_periph_init(clk, &pll1_624, 2, 0);
+	clk->dynamic_change = 1;
+}
+
+static int isp_dxo_clk_enable(struct clk *clk)
+{
+	CLK_SET_BITS(ISP_DXO_CLK_EN | ISP_DXO_CLK_RST, 0);
+	CLK_SET_BITS(ISP_DXO_CLK_REQ, 0);
+	trace_pxa_isp_dxo_clk(CLK_ENABLE);
+	return 0;
+}
+
+static void isp_dxo_clk_disable(struct clk *clk)
+{
+	CLK_SET_BITS(0, ISP_DXO_CLK_EN);
+	trace_pxa_isp_dxo_clk(CLK_DISABLE);
+}
+
+static int isp_dxo_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	__clk_periph_set_rate(clk, rate);
+	CLK_SET_BITS(ISP_DXO_CLK_REQ, 0);
+	trace_pxa_isp_dxo_clk_chg(rate);
+	return 0;
+}
+
+static unsigned long isp_dxo_clk_getrate(struct clk *clk)
+{
+	return __clk_periph_get_rate(clk);
+}
+
+struct clkops isp_dxo_clk_ops = {
+	.init		= isp_dxo_clk_init,
+	.enable		= isp_dxo_clk_enable,
+	.disable	= isp_dxo_clk_disable,
+	.setrate	= isp_dxo_clk_setrate,
+	.getrate	= isp_dxo_clk_getrate,
+};
+
+static struct clk *isp_dxo_depend_clk[] = {
+	&lcd_ci_isp_axi_clk,
+};
+
+static struct clk pxa988_isp_dxo_clk = {
+	.name = "isp_dxo",
+	.lookup = {
+		.con_id = "ISP-CLK",
+	},
+	.dependence = isp_dxo_depend_clk,
+	.dependence_count = ARRAY_SIZE(isp_dxo_depend_clk),
+	.clk_rst = (void __iomem *)APMU_ISPDXO,
+	.inputs = periph_mux_sel,
+	.ops = &isp_dxo_clk_ops,
+	.reg_data = {
+		     { {APMU_ISPDXO, 2, 0x3}, {APMU_ISPDXO, 2, 0x3} },
+		     { {APMU_ISPDXO, 4, 0x7}, {APMU_ISPDXO, 4, 0x7} } }
+};
+
+static int nand_clk_enable(struct clk *clk)
+{
+	__raw_writel(0x19b, clk->clk_rst);
+	return 0;
+}
+
+static void nand_clk_disable(struct clk *clk)
+{
+	/* only disable peripheral clock */
+	__raw_writel(0x18b, clk->clk_rst);
+}
+
+struct clkops nand_clk_ops = {
+	.enable = nand_clk_enable,
+	.disable = nand_clk_disable,
+};
+
+static int pwm_clk_enable(struct clk *clk)
+{
+	struct clk *clk_apb = NULL, *clk_share = NULL;
+	unsigned long data;
+
+	data = __raw_readl(clk->clk_rst) & ~(APBC_FNCLKSEL(7));
+	data |= APBC_FNCLK | APBC_FNCLKSEL(clk->fnclksel);
+	__raw_writel(data, clk->clk_rst);
+	/*
+	 * delay two cycles of the solwest clock between the APB bus clock
+	 * and the functional module clock.
+	 */
+	udelay(10);
+
+	if (!strcmp(clk->name, "pwm0")) {
+		clk_share = clk_get_sys("pxa910-pwm.1", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk;
+	} else if (!strcmp(clk->name, "pwm1")) {
+		clk_share = clk_get_sys("pxa910-pwm.0", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk_share;
+	} else if (!strcmp(clk->name, "pwm2")) {
+		clk_share = clk_get_sys("pxa910-pwm.3", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk;
+	} else if (!strcmp(clk->name, "pwm3")) {
+		clk_share = clk_get_sys("pxa910-pwm.2", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk_share;
+	} else
+		return -EINVAL;
+
+	if (clk_share && clk_apb && (clk->refcnt + clk_share->refcnt) == 0) {
+		data = __raw_readl(clk_apb->clk_rst);
+		data |= APBC_APBCLK;
+		__raw_writel(data, clk_apb->clk_rst);
+		udelay(10);
+		data = __raw_readl(clk_apb->clk_rst);
+		data &= ~APBC_RST;
+		__raw_writel(data, clk_apb->clk_rst);
+	}
+
+	/* slave pwm. eg. pwm1 apb bus clock depend on pwm0 */
+	if (clk_apb && strcmp(clk->name, clk_apb->name) && clk->refcnt == 0) {
+		data = __raw_readl(clk->clk_rst);
+		data &= ~APBC_RST;
+		__raw_writel(data, clk->clk_rst);
+	}
+	return 0;
+}
+
+static void pwm_clk_disable(struct clk *clk)
+{
+	struct clk *clk_apb = NULL, *clk_share = NULL;
+	unsigned long data;
+
+	data = __raw_readl(clk->clk_rst) & ~(APBC_FNCLK | APBC_FNCLKSEL(7));
+	__raw_writel(data, clk->clk_rst);
+	udelay(10);
+
+	if (!strcmp(clk->name, "pwm0")) {
+		clk_share = clk_get_sys("pxa910-pwm.1", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk;
+	} else if (!strcmp(clk->name, "pwm1")) {
+		clk_share = clk_get_sys("pxa910-pwm.0", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk_share;
+	} else if (!strcmp(clk->name, "pwm2")) {
+		clk_share = clk_get_sys("pxa910-pwm.3", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk;
+	} else if (!strcmp(clk->name, "pwm3")) {
+		clk_share = clk_get_sys("pxa910-pwm.2", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk_share;
+	} else
+		return;
+
+	if (clk_share && clk_apb && (clk->refcnt + clk_share->refcnt) == 1) {
+		data = __raw_readl(clk_apb->clk_rst);
+		data &= ~APBC_APBCLK;
+		__raw_writel(data, clk_apb->clk_rst);
+	}
+}
+
+struct clkops pwm_clk_ops = {
+	.enable = pwm_clk_enable,
+	.disable = pwm_clk_disable,
+};
+
+static void isccr1_clk_init(struct clk *clk)
+{
+	/*
+	 * ISCCR1: for low power mp3 playback.
+	 * Configure to 44.1K frame clock
+	 * BITCLK_DIV_468: value 1, bit clock is sysclk divided by 2.
+	 * DENOM: 0x529
+	 * NOM: 0xbe2
+	 */
+	__raw_writel(0x4a948be2, clk->clk_rst);
+}
+
+static int isccrx_clk_enable(struct clk *clk)
+{
+	unsigned int val;
+	val = __raw_readl(clk->clk_rst);
+	/* set bit 31 & 29 to enable sysclk & bitclk */
+	val |= (0x5 << 29);
+	__raw_writel(val, clk->clk_rst);
+
+	return 0;
+}
+
+static void isccrx_clk_disable(struct clk *clk)
+{
+	unsigned int val;
+	val = __raw_readl(clk->clk_rst);
+	/* clear bit 31 & 29 to disable sysclk & bitclk */
+	val &= ~(0x5 << 29);
+	__raw_writel(val, clk->clk_rst);
+}
+
+struct clkops isccr1_clk_ops = {
+	.init		= isccr1_clk_init,
+	.enable		= isccrx_clk_enable,
+	.disable	= isccrx_clk_disable,
+};
+
+static struct clk isccr1 = {
+	.name = "isccr1",
+	.lookup = {
+		.con_id = "ISCCR1",
+	},
+	.clk_rst = (void __iomem *)MPMU_ISCCRX1,
+	.ops = &isccr1_clk_ops,
+};
+
+static void isccr0_clk_init(struct clk *clk)
+{
+	/*
+	 * ISCCR0: gssp I2S clock generation control register.
+	 * Config to 8k frame clock.
+	 * BITCLK_DIV_468: value 0, bit clock is sysclk divided by 2.
+	 * DENOM: 0x180
+	 * NOM: 0x659
+	 */
+	__raw_writel(0x00c00659, clk->clk_rst);
+	/* enable gssp clock dynamic change */
+	clk->dynamic_change = 1;
+}
+
+static int isccr0_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned int val, nom, denom, factor;
+
+	nom = 0x659;
+	denom = 0x180;
+	factor = 1;
+
+	switch (rate) {
+	case 0:
+		break;
+	case 8000:
+		factor = 1;
+		break;
+	case 16000:
+		factor = 2;
+		break;
+	case 24000:
+		factor = 3;
+		break;
+	case 32000:
+		factor = 4;
+		break;
+	case 48000:
+		factor = 6;
+		break;
+	default:
+		pr_info("rate %ld is not supported, use 8k by default\n", rate);
+		break;
+	}
+
+	denom = (denom * factor) << 15;
+	val = __raw_readl(clk->clk_rst);
+	/* set ISCCRX0 since CP may modify*/
+	val = (val & (~0x5fffffff)) | denom  | nom;
+	__raw_writel(val, clk->clk_rst);
+
+	pr_debug("%s: ISCCRx0 %x\n", __func__, __raw_readl(clk->clk_rst));
+
+	return 0;
+}
+
+struct clkops isccr0_clk_ops = {
+	.init		= isccr0_clk_init,
+	.enable		= isccrx_clk_enable,
+	.disable	= isccrx_clk_disable,
+	.setrate	= isccr0_clk_setrate,
+};
+
+static struct clk isccr0 = {
+	.name = "isccr0",
+	.lookup = {
+		.con_id = "ISCCR0",
+	},
+	.clk_rst = (void __iomem *)MPMU_ISCCRX0,
+	.ops = &isccr0_clk_ops,
+};
+
+/* gssp clk ops: gssp is shared between AP and CP */
+static int gssp_clk_enable(struct clk *clk)
+{
+	unsigned int gcer;
+	/* GPB bus select: choose APB */
+	__raw_writel(0x1, APBC_PXA988_GBS);
+	/* GSSP clock control register: GCER */
+	gcer = __raw_readl(clk->clk_rst) & ~(0x3 << 8);
+	gcer |= APBC_RST;
+	__raw_writel(gcer, clk->clk_rst);
+	udelay(1);
+	gcer &= ~APBC_RST;
+	__raw_writel(gcer, clk->clk_rst);
+	udelay(1);
+	/* choose I2S clock */
+	gcer |= APBC_FNCLK | (0x0 << 8);
+	__raw_writel(gcer, clk->clk_rst);
+	udelay(10);
+	gcer |= APBC_APBCLK;
+	__raw_writel(gcer, clk->clk_rst);
+	udelay(10);
+	gcer &= ~APBC_RST;
+	__raw_writel(gcer, clk->clk_rst);
+	pr_debug("gssp clk is open\n");
+
+	return 0;
+}
+
+static void gssp_clk_disable(struct clk *clk)
+{
+	unsigned int gcer;
+	gcer = __raw_readl(clk->clk_rst);
+	gcer &= ~APBC_APBCLK;
+	__raw_writel(gcer, clk->clk_rst);
+	__raw_writel(0x0, APBC_PXA988_GBS);
+	pr_debug("gssp clk is closed\n");
+}
+
+struct clkops gssp_clk_ops = {
+	.enable = gssp_clk_enable,
+	.disable = gssp_clk_disable,
+};
+
+#define USB_AXICLK_EN	(1 << 3)
+#define USB_AXI_RST		(1 << 0)
+static int udc_clk_enable(struct clk *clk)
+{
+	__raw_writel((USB_AXICLK_EN | USB_AXI_RST),\
+				clk->clk_rst);
+	return 0;
+}
+
+static void udc_clk_disable(struct clk *clk)
+{
+	if (cpu_is_z1z2())
+		__raw_writel(USB_AXI_RST, clk->clk_rst);
+	else
+		__raw_writel(0x0, clk->clk_rst);
+}
+
+struct clkops udc_clk_ops = {
+	.enable = udc_clk_enable,
+	.disable = udc_clk_disable,
+};
+
+/* interface for I2C controller */
+static void twsi_clk_init(struct clk *clk)
+{
+	unsigned int regval;
+	unsigned int fnclkmask, fnclkval;
+
+	/*
+	 * i2c clock has been enable in uboot.
+	 * disable clk in case set clk rate is needed.
+	 */
+
+	regval = __raw_readl(clk->clk_rst) & ~APBC_FNCLK;
+	__raw_writel(regval, clk->clk_rst);
+	udelay(10);
+
+	regval &= ~APBC_APBCLK;
+	__raw_writel(regval, clk->clk_rst);
+
+	/* set i2c clk to default value */
+	fnclkmask = clk->reg_data[SOURCE][CONTROL].reg_mask << \
+		clk->reg_data[SOURCE][CONTROL].reg_shift;
+	fnclkval = clk->fnclksel << \
+		clk->reg_data[SOURCE][CONTROL].reg_shift;
+
+	regval = __raw_readl(clk->clk_rst) & ~fnclkmask;
+	regval |= fnclkval;
+	__raw_writel(regval, clk->clk_rst);
+}
+
+static int twsi_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long old_rate;
+	unsigned int fnclkmask, fnclkval;
+	unsigned int regval;
+
+	old_rate = clk->rate;
+	if (rate == old_rate)
+		return 0;
+
+	if ((rate != 33000000) && (rate != 52000000) && (rate != 62400000)) {
+		pr_warning("clk[%s] rate is invalid,make no change\n",
+				clk->name);
+		return 0;
+	}
+
+	if (rate == 33000000)
+		clk->fnclksel = 0;
+	else if (rate == 62400000)
+		clk->fnclksel = 2;
+	else
+		clk->fnclksel = 1;
+
+	fnclkmask = clk->reg_data[SOURCE][CONTROL].reg_mask << \
+		clk->reg_data[SOURCE][CONTROL].reg_shift;
+	fnclkval = clk->fnclksel << \
+		clk->reg_data[SOURCE][CONTROL].reg_shift;
+
+	regval = __raw_readl(clk->clk_rst) & ~fnclkmask;
+	regval |= fnclkval;
+	__raw_writel(regval, clk->clk_rst);
+
+	pr_debug("%s rate %lu->%lu\n", clk->name, old_rate, rate);
+	return 0;
+}
+
+static unsigned long twsi_clk_getrate(struct clk *clk)
+{
+	unsigned int fnclkmask, fnclkval;
+	unsigned int regval;
+
+	regval = __raw_readl(clk->clk_rst);
+	fnclkmask = clk->reg_data[SOURCE][CONTROL].reg_mask << \
+		clk->reg_data[SOURCE][CONTROL].reg_shift;
+	fnclkval = (regval & fnclkmask) >> \
+		clk->reg_data[SOURCE][CONTROL].reg_shift;
+
+	if (fnclkval == 0)
+		return 33000000;
+	else if (fnclkval == 2)
+		return 62400000;
+	else if (fnclkval == 1)
+		return 52000000;
+	else
+		return 0;
+}
+
+static int twsi_clk_enable(struct clk *clk)
+{
+	unsigned int regval;
+
+	regval = __raw_readl(clk->clk_rst) | APBC_FNCLK;
+	__raw_writel(regval, clk->clk_rst);
+
+	/*
+	 * delay two cycles of the solwest clock between the APB bus clock
+	 * and the functional module clock.
+	 */
+	udelay(10);
+
+	regval |= APBC_APBCLK;
+	__raw_writel(regval, clk->clk_rst);
+	udelay(10);
+
+	regval &= ~APBC_RST;
+	__raw_writel(regval, clk->clk_rst);
+
+	return 0;
+}
+
+static void twsi_clk_disable(struct clk *clk)
+{
+	unsigned int regval;
+
+	regval = __raw_readl(clk->clk_rst) & ~APBC_FNCLK;
+	__raw_writel(regval, clk->clk_rst);
+	udelay(10);
+
+	regval &= ~APBC_APBCLK;
+	__raw_writel(regval, clk->clk_rst);
+}
+
+struct clkops twsi_clk_ops = {
+	.init		= twsi_clk_init,
+	.enable		= twsi_clk_enable,
+	.disable	= twsi_clk_disable,
+	.setrate	= twsi_clk_setrate,
+	.getrate	= twsi_clk_getrate,
+};
+
+static struct clk twsi0_clk = {
+	.name = "twsi0",
+	.lookup = {
+		.dev_id = "pxa910-i2c.0",
+	},
+	.clk_rst = (void __iomem *)APBC_PXA988_TWSI0,
+	.fnclksel = 0,
+	.ops = &twsi_clk_ops,
+	.reg_data = {
+		{ {APBC_PXA988_TWSI0, 4, 0x7}, {APBC_PXA988_TWSI0, 4, 0x7} }
+	}
+};/* ci2c */
+
+static struct clk twsi1_clk = {
+	.name = "twsi1",
+	.lookup = {
+		.dev_id = "pxa910-i2c.1",
+	},
+	.clk_rst = (void __iomem *)APBC_PXA988_TWSI1,
+	.fnclksel = 0,
+	.ops = &twsi_clk_ops,
+	.reg_data = {
+		{ {APBC_PXA988_TWSI1, 4, 0x7}, {APBC_PXA988_TWSI1, 4, 0x7} }
+	}
+};/* ci2c1 */
+
+static struct clk twsi2_clk = {
+	.name = "twsi2",
+	.lookup = {
+		.dev_id = "pxa910-i2c.2",
+	},
+	.clk_rst = (void __iomem *)APBC_PXA988_PWRTWSI,
+	.fnclksel = 0,
+	.ops = &twsi_clk_ops,
+	.reg_data = {
+		{ {APBC_PXA988_PWRTWSI, 3, 0x3}, {APBC_PXA988_PWRTWSI, 3, 0x3} }
+	}
+};/* pwr_i2c */
+
+#define APBC_CLK(_name, _dev, _con, _reg, _fnclksel, _rate, _parent)\
+{							\
+	.name = _name,					\
+	.lookup = {					\
+		.dev_id = _dev,\
+		.con_id = _con,\
+	},						\
+	.clk_rst = (void __iomem *)_reg,		\
+	.fnclksel = _fnclksel,				\
+	.rate = _rate,					\
+	.ops = &apbc_clk_ops,				\
+	.parent = _parent,				\
+}
+
+#define APBC_CLK_OPS(_name, _dev, _con, _reg, _fnclksel, _rate, _parent, _ops)\
+{							\
+	.name = _name,					\
+	.lookup = {					\
+		.dev_id = _dev,\
+		.con_id = _con,\
+	},						\
+	.clk_rst = (void __iomem *)_reg,		\
+	.fnclksel = _fnclksel,				\
+	.rate = _rate,					\
+	.ops = _ops,					\
+	.parent = _parent,				\
+}
+
+#define APMU_CLK(_name, _dev, _con, _reg, _eval, _rate, _parent)\
+{								\
+	.name = _name,						\
+	.lookup = {						\
+		.dev_id = _dev,					\
+		.con_id = _con,					\
+	},							\
+	.clk_rst = (void __iomem *)_reg,			\
+	.enable_val = _eval,					\
+	.rate = _rate,						\
+	.ops = &apmu_clk_ops,					\
+	.parent = _parent,					\
+}
+
+#define APMU_CLK_OPS(_name, _dev, _con, _reg, _eval, _rate, _parent, _ops)\
+{								\
+	.name = _name,						\
+	.lookup = {						\
+		.dev_id = _dev,					\
+		.con_id = _con,					\
+	},							\
+	.clk_rst = (void __iomem *)_reg,			\
+	.enable_val = _eval,					\
+	.rate = _rate,						\
+	.parent = _parent,					\
+	.ops = _ops,						\
+}
+
+DEFINE_GATE_CLK(VCTCXO, MPMU_VRCR, 1, NULL, "VCTCXO");
+#if 1	// MCLK setting
+DEFINE_GATE_CLK(VCXO_OUT, MPMU_VRCR, (1 << 8), NULL, "VCXO_OUT");
+#endif
+DEFINE_GATE_CLK(dbgclk, APMU_TRACE, (1 << 3), NULL, "DBGCLK");
+DEFINE_GATE_CLK(traceclk, APMU_TRACE, (1 << 4), NULL, "TRACECLK");
+
+/* all clk src on the board */
+static struct clk *pxa988_clks_src[] = {
+	&VCTCXO,
+#if 1	// MCLK setting
+	&VCXO_OUT,
+#endif
+	&pll1_416,
+	&pll1_624,
+	&pll1_1248,
+	&pll2_vco,
+	&pll2,
+	&pll2p,
+	&pll3_vco,
+	&pll3,
+	&pll3p,
+};
+
+/* soc peripheral clk on the board */
+static struct clk *pxa988_clks_peri[] = {
+	&pxa988_clk_sdh0,
+	&pxa988_clk_sdh1,
+	&pxa988_clk_sdh2,
+	&gc_aclk,	/* internal clk node */
+	&pxa988_clk_gc,
+	&vpu_aclk,	/* internal clk node */
+	&pxa988_clk_vpu,
+	&lcd_ci_isp_axi_clk,
+	&pxa988_lcd_ci_hclk,
+	&pxa988_ccic_axi_clk,
+	&pxa988_ccic_phy_clk,
+	&pxa988_ccic_func_clk,
+	&lcd_dsi_phy_clk,
+	&pxa988_lcd_clk,
+	&disp_pn_sclk,
+	&disp_tv_sclk,
+	&disp_pnclk,
+	&disp_tvclk,
+	&disp_dsi1clk,
+	&pxa988_isp_dxo_clk,
+	&dbgclk,
+	&traceclk,
+	&twsi0_clk,
+	&twsi1_clk,
+	&twsi2_clk,
+	&isccr0,
+	&isccr1,
+};
+
+static struct clk *pxa1088_clks_peri_extra[] = {
+	&gc2d_aclk,	/* internal clk node */
+	&pxa988_clk_gc2d,
+};
+
+/* This clock is used to enable RTC module register r/w */
+DEFINE_GATE_CLK(rtc_pe, APBC_PXA988_RTC, (1 << 7), NULL, "rtc_pe");
+
+/* APB and some simple APMU clock */
+static struct clk pxa988_list_clks[] = {
+	/* APBC: _name, _dev, _con, _reg, _fnclksel, _rate, _parent*/
+	APBC_CLK("uart0", "pxa2xx-uart.0", NULL,
+		APBC_PXA988_UART0, 1, 14745600, NULL),/* CP uart */
+	APBC_CLK("uart1", "pxa2xx-uart.1", NULL,
+		APBC_PXA988_UART1, 1, 14745600, NULL),	/* AP uart0*/
+	APBC_CLK("uart2", "pxa2xx-uart.2", NULL,
+		APBC_PXA988_UART2, 1, 14745600, NULL),	/* AP uart1*/
+	APBC_CLK("gpio", "pxa-gpio", NULL,
+		APBC_PXA988_GPIO, 0, 13000000, NULL),
+	APBC_CLK("ssp0", "pxa988-ssp.0", NULL,
+		APBC_PXA988_SSP0, 4, 3250000, NULL),
+	APBC_CLK("ssp1", "pxa988-ssp.1", NULL,
+		APBC_PXA988_SSP1, 0, 26000000, &isccr1),
+	APBC_CLK("ssp2", "pxa988-ssp.2", NULL,
+		APBC_PXA988_SSP2, 2, 26000000, NULL),
+	APBC_CLK("keypad", "pxa27x-keypad", NULL,
+		APBC_PXA988_KPC, 0, 32000, NULL),
+	APBC_CLK("rtc", "sa1100-rtc", NULL,
+		APBC_PXA988_RTC, 0, 32000, &rtc_pe),
+	APBC_CLK("1wire", NULL, "PXA-W1",
+		APBC_PXA988_ONEWIRE, 0, 26000000, NULL),
+	APBC_CLK("thermal", NULL, "THERMALCLK",
+		APBC_PXA988_DROTS, 0, 13000000, NULL),
+
+	/* APBC_OPS: _name, _dev, _con, _reg, _fnclksel, _rate, _parent*/
+	APBC_CLK_OPS("pwm0", "pxa910-pwm.0", NULL,
+		APBC_PXA988_PWM0, 0, 13000000, NULL, &pwm_clk_ops),
+	APBC_CLK_OPS("pwm1", "pxa910-pwm.1", NULL,
+		APBC_PXA988_PWM1, 0, 13000000, NULL, &pwm_clk_ops),
+	APBC_CLK_OPS("pwm2", "pxa910-pwm.2", NULL,
+		APBC_PXA988_PWM2, 0, 13000000, NULL, &pwm_clk_ops),
+	APBC_CLK_OPS("pwm3", "pxa910-pwm.3", NULL,
+		APBC_PXA988_PWM3, 0, 13000000, NULL, &pwm_clk_ops),
+	APBC_CLK_OPS("gssp", "pxa988-ssp.4", NULL,
+		APBC_PXA988_GCER, 0, 0, &isccr0, &gssp_clk_ops),
+
+	/* APMU: _name, _dev, _con, _reg, _eval, _rate, _parent */
+	APBC_CLK_OPS("udc", NULL, "UDCCLK", APMU_USB,
+			0x9, 480000000, NULL, &udc_clk_ops),
+	APMU_CLK("ire", "pxa910-ire.0", NULL, APMU_IRE,
+			0x9, 480000000, NULL),
+	APMU_CLK("aes", NULL, "AESCLK", APMU_GEU,
+			0x9, 480000000, NULL),
+
+	/* APMU: _name, _dev, _con, _reg, _eval, _rate, _parent , ops */
+	APMU_CLK_OPS("nand", "pxa3xx-nand", NULL, APMU_NAND,
+			0x19b, 156000000, NULL, &nand_clk_ops),
+};
+
+/*
+ * max_freq could only be configured to predefined frequency
+ * round it to just use platform allowed frequency.
+ * For 988/986, it is 1205M or 1482M
+ * For 1088, it is 1101M, 1183M or 1283M
+*/
+static inline void round_max_freq(void)
+{
+	if (!max_freq)
+		max_freq = get_max_cpurate();
+
+	if (cpu_is_pxa1088()) {
+		if (max_freq <= CORE_1p1G)
+			max_freq = CORE_1p1G;
+		else if (max_freq <= CORE_1p18G)
+			max_freq = CORE_1p18G;
+		else
+			max_freq = CORE_1p3G;
+	} else if (cpu_is_pxa988() || cpu_is_pxa986()) {
+		if (max_freq <= CORE_1p2G)
+			max_freq = CORE_1p2G;
+		else
+			max_freq = CORE_1p5G;
+	} else
+		max_freq = CORE_1p2G;
+}
+
+/*
+ * uboot may pass pll3_vco value to kernel.
+ * pll3 may be shared between core and display.
+ * if it can be shared, core will use pll3p and it is set to max_freq
+ * or pll3 and pll3p will be set to be the same with pll3_vco
+*/
+static inline void setup_pll3_vco(void)
+{
+	int bestmul;
+	if (!pll3_vco_default) {
+		bestmul = pll3_best_mul(max_freq * MHZ_TO_HZ);
+		if (bestmul == -1) {
+			printk(KERN_ERR "Cannot use PLL3 as max freq!\n");
+			BUG_ON(1);
+		}
+		pll3_vco_default = max_freq * MHZ_TO_HZ * bestmul;
+		pll3_default = max_freq * MHZ_TO_HZ;
+		pll3p_default = max_freq * MHZ_TO_HZ;
+	} else {
+		if ((pll3_vco_default < 1200 * MHZ_TO_HZ) ||
+		   (pll3_vco_default > 2500 * MHZ_TO_HZ)) {
+			printk(KERN_ERR "PLL3 VCO value is out of range !\n");
+			BUG_ON(1);
+		}
+		pll3_default = pll3_vco_default;
+		if (!(pll3_vco_default % max_freq))
+			pll3p_default = max_freq * MHZ_TO_HZ;
+		else /* Core will not use pll3p */
+			pll3p_default = pll3_vco_default;
+	}
+}
+
+static void __init clk_misc_init(void)
+{
+	unsigned int dcg_regval = 0;
+	/*
+	 * pll2 default rate is different when using LPDDR400 and LPDDR533
+	 * For max DDR rate 400M case
+	 * 988 Z1/Z2 Safe PP solution:
+	 * pll2 1200M for PP150/300/600/1200M
+	 * pll2p 800M for PP800M
+	 * 988 Z3/Ax decoupled PP solution:
+	 * pll2 800M for CPU
+	 * pll2p 800M for DDR
+	 *
+	 * For max DDR rate 533M case
+	 * pll2 1066M for DDR and CPU
+	 * pll2p 533M for other peripherals
+	 * pll2/pll2p = pll2_vco/div (div = 1,2,3,4,6,8)
+	 *
+	 * pll3 VCO 2000M, pll3 500M for DSI, pll3p 1000M for CPU
+	 * pll3/pll3p = pll3_vco/div (div = 1,2,3,4,6,8)
+	 *
+	 *  1088 temproraily uses Z3/Ax setting.
+	 */
+	if (cpu_is_z1z2()) {
+		pll2_vco_default = 2400 * MHZ_TO_HZ;
+		pll2_default = 1200 * MHZ_TO_HZ;
+		pll2p_default = 800 * MHZ_TO_HZ;
+	} else {
+		if (ddr_mode == 0) {
+			pll2_vco_default = 1600 * MHZ_TO_HZ;
+			pll2_default = 800 * MHZ_TO_HZ;
+			pll2p_default = 800 * MHZ_TO_HZ;
+		} else if (ddr_mode == 1) {
+			pll2_vco_default = 2132 * MHZ_TO_HZ;
+			pll2_default = 1066 * MHZ_TO_HZ;
+			pll2p_default = 1066 * MHZ_TO_HZ;
+		} else {
+			/* use 800Mhz by default */
+			pll2_vco_default = 1600 * MHZ_TO_HZ;
+			pll2_default = 800 * MHZ_TO_HZ;
+			pll2p_default = 800 * MHZ_TO_HZ;
+		}
+	}
+
+	round_max_freq();
+	setup_pll3_vco();
+
+#if defined(CONFIG_CORE_1248)
+	pll3_vco_default = 1396 * MHZ_TO_HZ;
+	pll3_default = 698 * MHZ_TO_HZ;
+	pll3p_default = 698 * MHZ_TO_HZ;
+#endif
+	/* DE suggest:enable SQU MP3 playback sleep mode */
+	__raw_writel(__raw_readl(APMU_SQU_CLK_GATE_CTRL) | (1 << 30),
+			APMU_SQU_CLK_GATE_CTRL);
+
+	/* select i2s clock from VCTCXO , LP audio playback support */
+	__raw_writel(__raw_readl(MPMU_FCCR) | (1 << 28), MPMU_FCCR);
+
+	/* components' clock should always keep enabled */
+	__raw_writel(0x3, APBC_PXA988_IPC);	/* ACIPC */
+	__raw_writel(0x0, APBC_PXA988_RIPC);	/* RIPC */
+	__raw_writel(0x3, APMU_MCK4_CTL);	/* MCK4 AHB */
+
+	/* reset all SD Hosts to avoid protential IRQ storm */
+	sdhc_reset_all();
+
+	/* enable MC4 and AXI fabric dynamic clk gating */
+	dcg_regval = __raw_readl(CIU_MC_CONF);
+	/* disable cp fabric clk gating */
+	dcg_regval &= ~(1 << 16);
+	/* enable dclk gating */
+	dcg_regval &= ~(1 << 19);
+	/* enable 1x2 fabric AXI clock dynamic gating */
+	if (cpu_is_pxa1088())
+		dcg_regval |= (1 << 29) | (1 << 30);
+	if (has_feat_mck4_axi_clock_gate()) {
+		dcg_regval |= (0xff << 8) | /* MCK4 P0~P7*/
+			(1 << 17) | (1 << 18) | /* Fabric 0 */
+			(1 << 20) | (1 << 21) |	/* VPU fabric */
+			(1 << 26) | (1 << 27);  /* Fabric 0/1 */
+	} else {
+		dcg_regval |= (1 << 9) | (1 << 18) | /* Seagull */
+			(1 << 12) | (1 << 27) |  /* Fabric #2 */
+			(1 << 15) | (1 << 20) | (1 << 21) | /* VPU*/
+			(1 << 17) | (1 << 26); /* Fabric#1 CA9 */
+	}
+	__raw_writel(dcg_regval, CIU_MC_CONF);
+}
+
+static void __init clk_disable_unused_clock(void)
+{
+	/*
+	 * disable nand controller clock as it is not used
+	 * on 988
+	 */
+	__raw_writel(0, APMU_NAND);
+	/*
+	 * disable ase clock at init stage and security will
+	 * enable it prior to use it
+	 */
+	__raw_writel(0, APMU_GEU);
+}
+/*
+ * init pll default output that used for pxa988
+ * MUST call this function after pll2 and pll3 clock node is inited
+ */
+static void __init clk_pll_init(void)
+{
+	clk_set_rate(&pll2_vco, pll2_vco_default);
+	clk_set_rate(&pll2, pll2_default);
+	clk_set_rate(&pll2p, pll2p_default);
+
+	clk_set_rate(&pll3_vco, pll3_vco_default);
+	clk_set_rate(&pll3, pll3_default);
+	clk_set_rate(&pll3p, pll3p_default);
+
+	pr_info("PLL2 SWCR[%x] PLLCR[%x]\n",\
+		__raw_readl(APB_SPARE_PLL2CR),
+		__raw_readl(MPMU_PLL2CR));
+	pr_info("PLL3 SWCR[%x] PLLCR[%x]\n",
+		__raw_readl(APB_SPARE_PLL3CR),
+		__raw_readl(MPMU_PLL3CR));
+}
+
+void pxa988_init_one_clock(struct clk *c)
+{
+	clk_init(c);
+	INIT_LIST_HEAD(&c->shared_bus_list);
+	if (!c->lookup.dev_id && !c->lookup.con_id)
+		c->lookup.con_id = c->name;
+	c->lookup.clk = c;
+	clkdev_add(&c->lookup);
+}
+EXPORT_SYMBOL(pxa988_init_one_clock);
+
+static int __init pxa988_clk_init(void)
+{
+	int i;
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+	/*
+	 * Only Z1/Z2 needs mck4 workaround, disable this workaround
+	 * for other chips
+	 */
+	if (!cpu_is_z1z2())
+		mck4_wr_enabled = 0;
+#endif
+	clk_misc_init();
+
+	for (i = 0; i < ARRAY_SIZE(pxa988_clks_src); i++)
+		pxa988_init_one_clock(pxa988_clks_src[i]);
+	for (i = 0; i < ARRAY_SIZE(pxa988_clks_peri); i++)
+		pxa988_init_one_clock(pxa988_clks_peri[i]);
+	if (cpu_is_pxa1088()) {
+		for (i = 0; i < ARRAY_SIZE(pxa1088_clks_peri_extra); i++)
+			pxa988_init_one_clock(pxa1088_clks_peri_extra[i]);
+	}
+	for (i = 0; i < ARRAY_SIZE(pxa988_list_clks); i++)
+		pxa988_init_one_clock(&pxa988_list_clks[i]);
+	clk_pll_init();
+	clk_disable_unused_clock();
+	return 0;
+}
+core_initcall(pxa988_clk_init);
+
+#ifdef CONFIG_DEBUG_FS
+static void clk_dutycycle_stats(struct clk *clk,
+	enum clk_stat_msg msg,
+	struct clk_dc_stat_info *dc_stat_info,
+	unsigned int tgtstate)
+{
+	struct timespec cur_ts, prev_ts;
+	long time_ms;
+	struct op_dcstat_info *cur, *tgt;
+
+	/* do nothing if no stat operation is issued */
+	if (!dc_stat_info->stat_start)
+		return ;
+
+	cur = &dc_stat_info->ops_dcstat[dc_stat_info->curopindex];
+	getnstimeofday(&cur_ts);
+	prev_ts = cur->prev_ts;
+	time_ms = ts2ms(cur_ts, prev_ts);
+	switch (msg) {
+	case CLK_STAT_START:
+		/* duty cycle stat start */
+		cur->prev_ts = cur_ts;
+		break;
+	case CLK_STAT_STOP:
+		/* duty cycle stat stop */
+		if (clk->refcnt)
+			cur->busy_time += time_ms;
+		else
+			cur->idle_time += time_ms;
+		break;
+	case CLK_STATE_ON:
+		/* clk switch from off->on */
+		cur->prev_ts = cur_ts;
+		cur->idle_time += time_ms;
+		break;
+	case CLK_STATE_OFF:
+		/* clk switch from off->on */
+		cur->prev_ts = cur_ts;
+		cur->busy_time += time_ms;
+		break;
+	case CLK_RATE_CHANGE:
+		/* rate change from old->new */
+		cur->prev_ts = cur_ts;
+		if (clk->refcnt)
+			cur->busy_time += time_ms;
+		else
+			cur->idle_time += time_ms;
+		BUG_ON(tgtstate >= dc_stat_info->ops_stat_size);
+		tgt = &dc_stat_info->ops_dcstat[tgtstate];
+		tgt->prev_ts = cur_ts;
+		break;
+	default:
+		break;
+	}
+}
+
+int pxa988_clk_register_dcstat(struct clk *clk,
+	unsigned long *opt, unsigned int opt_size)
+{
+	struct clk_dcstat *cdcs;
+	struct clk_dc_stat_info *clk_dcstat;
+	unsigned int i, curpp_index = 0;
+
+	/* search the list of the registation for this clk */
+	list_for_each_entry(cdcs, &clk_dcstat_list, node)
+		if (cdcs->clk == clk)
+			break;
+
+	/* if clk wasn't in the list, allocate new dcstat info */
+	if (cdcs->clk != clk) {
+		cdcs = kzalloc(sizeof(struct clk_dcstat), GFP_KERNEL);
+		if (!cdcs)
+			goto out;
+
+		cdcs->clk = clk;
+		/* allocate and fill dc stat information */
+		clk_dcstat = &cdcs->clk_dcstat;
+		clk_dcstat->ops_dcstat = kzalloc(opt_size * \
+			sizeof(struct op_dcstat_info), GFP_KERNEL);
+		if (!clk_dcstat->ops_dcstat) {
+			pr_err("%s clk %s memory allocate failed!\n",
+				__func__, clk->name);
+			goto out1;
+		}
+		for (i = 0; i < opt_size; i++) {
+			clk_dcstat->ops_dcstat[i].ppindex = i;
+			clk_dcstat->ops_dcstat[i].pprate = opt[i];
+			if (clk->rate == opt[i])
+				curpp_index = i;
+		}
+		clk_dcstat->ops_stat_size = opt_size;
+		clk_dcstat->stat_start = false;
+		clk_dcstat->curopindex = curpp_index;
+
+		list_add(&cdcs->node, &clk_dcstat_list);
+	}
+
+	return 0;
+out1:
+	kfree(cdcs);
+out:
+	return -ENOMEM;
+}
+EXPORT_SYMBOL(pxa988_clk_register_dcstat);
+
+int pxa988_clk_dcstat_event(struct clk *clk,
+	enum clk_stat_msg msg, unsigned int tgtstate)
+{
+	struct clk_dcstat *cdcs;
+	struct clk_dc_stat_info *dcstat_info;
+	int ret = 0;
+
+	list_for_each_entry(cdcs, &clk_dcstat_list, node)
+		if (cdcs->clk == clk) {
+			dcstat_info = &cdcs->clk_dcstat;
+			clk_dutycycle_stats(clk, msg,
+				dcstat_info, tgtstate);
+			/*
+			 * always update curopindex, no matter stat
+			 * is started or not
+			 */
+			if (msg == CLK_RATE_CHANGE)
+				dcstat_info->curopindex = tgtstate;
+			break;
+		}
+	return ret;
+}
+EXPORT_SYMBOL(pxa988_clk_dcstat_event);
+
+int pxa988_show_dc_stat_info(struct clk *clk, char *buf, ssize_t size)
+{
+	int len = 0;
+	unsigned int i, dc_int, dc_fraction;
+	long total_time = 0, run_total = 0, idle_total = 0;
+	struct clk_dcstat *cdcs;
+	struct clk_dc_stat_info *dc_stat_info = NULL;
+
+	list_for_each_entry(cdcs, &clk_dcstat_list, node)
+		if (cdcs->clk == clk) {
+			dc_stat_info = &cdcs->clk_dcstat;
+			break;
+		}
+
+	if (!dc_stat_info) {
+		pr_err("clk %s NULL dc stat info\n", clk->name);
+		return -EINVAL;
+	}
+
+	if (dc_stat_info->stat_start) {
+		len += snprintf(buf + len, size - len,
+			"Please stop the %s duty cycle stats at first\n",
+			clk->name);
+		return len;
+	}
+
+	for (i = 0; i < dc_stat_info->ops_stat_size; i++) {
+		run_total += dc_stat_info->ops_dcstat[i].busy_time;
+		idle_total += dc_stat_info->ops_dcstat[i].idle_time;
+	}
+	total_time = run_total + idle_total;
+	if (!total_time) {
+		len += snprintf(buf + len, size - len,
+			"No stat information! ");
+		len += snprintf(buf + len, size - len,
+			"Help information :\n");
+		len += snprintf(buf + len, size - len,
+			"1. echo 1 to start duty cycle stat:\n");
+		len += snprintf(buf + len, size - len,
+			"2. echo 0 to stop duty cycle stat:\n");
+		len += snprintf(buf + len, size - len,
+			"3. cat to check duty cycle info from start to stop:\n\n");
+		return len;
+	}
+
+	len += snprintf(buf + len, size - len, "\n");
+	dc_int = calculate_dc(run_total, total_time, &dc_fraction);
+	dc_fraction = dc_fraction;
+	len += snprintf(buf + len, size - len,
+		"| CLK %s | %10s %lums| %10s %lums| %10s %2u.%2u%%|\n",
+		clk->name, "idle time", idle_total,
+		"total time",  total_time,
+		"duty cycle", dc_int, dc_fraction);
+	len += snprintf(buf + len, size - len,
+		"| %3s | %12s | %15s | %15s | %15s |\n", "OP#",
+		"rate(HZ)", "run time(ms)", "idle time(ms)", "rt ratio");
+	for (i = 0; i < dc_stat_info->ops_stat_size; i++) {
+		dc_int = calculate_dc(dc_stat_info->ops_dcstat[i].busy_time,
+			total_time, &dc_fraction);
+		dc_fraction = dc_fraction;
+		len += snprintf(buf + len, size - len,
+			"| %3u | %12lu | %15ld | %15ld | %12u.%2u%%|\n",
+			dc_stat_info->ops_dcstat[i].ppindex,
+			dc_stat_info->ops_dcstat[i].pprate,
+			dc_stat_info->ops_dcstat[i].busy_time,
+			dc_stat_info->ops_dcstat[i].idle_time,
+			dc_int, dc_fraction);
+	}
+	return len;
+}
+EXPORT_SYMBOL(pxa988_show_dc_stat_info);
+
+int pxa988_start_stop_dc_stat(struct clk *clk, unsigned int start)
+{
+	unsigned int i;
+	struct clk_dcstat *cdcs;
+	struct clk_dc_stat_info *dc_stat_info = NULL;
+
+	list_for_each_entry(cdcs, &clk_dcstat_list, node)
+		if (cdcs->clk == clk) {
+			dc_stat_info = &cdcs->clk_dcstat;
+			break;
+		}
+
+	if (!dc_stat_info) {
+		pr_err("clk %s NULL dc stat info\n", clk->name);
+		return -EINVAL;
+	}
+
+	start = !!start;
+	if (start == dc_stat_info->stat_start) {
+		pr_err("[WARNING]%s stat is already %s\n",
+			clk->name,
+			dc_stat_info->stat_start ?\
+			"started" : "stopped");
+		return -EINVAL;
+	}
+
+	/*
+	 * hold the same lock of clk_enable, disable, set_rate ops
+	 * here to avoid the status change when start/stop and lead
+	 * to incorrect stat info
+	 */
+	clk_get_lock(clk);
+	if (start) {
+		/* clear old stat information */
+		for (i = 0; i < dc_stat_info->ops_stat_size; i++) {
+			dc_stat_info->ops_dcstat[i].idle_time = 0;
+			dc_stat_info->ops_dcstat[i].busy_time = 0;
+		}
+		dc_stat_info->stat_start = true;
+		clk_dutycycle_stats(clk, CLK_STAT_START,
+			dc_stat_info, 0);
+	} else {
+		clk_dutycycle_stats(clk, CLK_STAT_STOP,
+			dc_stat_info, 0);
+		dc_stat_info->stat_start = false;
+	}
+	clk_release_lock(clk);
+	return 0;
+}
+EXPORT_SYMBOL(pxa988_start_stop_dc_stat);
+
+static ssize_t pxa988_gc_dc_read(struct file *filp,
+	char __user *buffer, size_t count, loff_t *ppos)
+{
+	char *p;
+	int len = 0;
+	size_t ret, size = PAGE_SIZE - 1;
+
+	p = (char *)__get_free_pages(GFP_NOIO, 0);
+	if (!p)
+		return -ENOMEM;
+
+	len = pxa988_show_dc_stat_info(&pxa988_clk_gc, p, size);
+	if (len < 0) {
+		free_pages((unsigned long)p, 0);
+		return -EINVAL;
+	}
+	if (len == size)
+		pr_warn("%s The dump buf is not large enough!\n", __func__);
+
+	ret = simple_read_from_buffer(buffer, count, ppos, p, len);
+	free_pages((unsigned long)p, 0);
+	return ret;
+}
+
+static ssize_t pxa988_gc_dc_write(struct file *filp,
+		const char __user *buffer, size_t count, loff_t *ppos)
+{
+	unsigned int start;
+	char buf[10] = { 0 };
+	int ret = 0;
+
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%d", &start);
+	ret = pxa988_start_stop_dc_stat(&pxa988_clk_gc, start);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+static const struct file_operations pxa988_gc_dc_ops = {
+	.owner = THIS_MODULE,
+	.read = pxa988_gc_dc_read,
+	.write = pxa988_gc_dc_write,
+};
+
+static ssize_t pxa988_gc2d_dc_read(struct file *filp,
+	char __user *buffer, size_t count, loff_t *ppos)
+{
+	char *p;
+	int len = 0;
+	size_t ret, size = PAGE_SIZE - 1;
+
+	p = (char *)__get_free_pages(GFP_NOIO, 0);
+	if (!p)
+		return -ENOMEM;
+
+	len = pxa988_show_dc_stat_info(&pxa988_clk_gc2d, p, size);
+	if (len < 0) {
+		free_pages((unsigned long)p, 0);
+		return -EINVAL;
+	}
+	if (len == size)
+		pr_warn("%s The dump buf is not large enough!\n", __func__);
+
+	ret = simple_read_from_buffer(buffer, count, ppos, p, len);
+	free_pages((unsigned long)p, 0);
+	return ret;
+}
+
+static ssize_t pxa988_gc2d_dc_write(struct file *filp,
+		const char __user *buffer, size_t count, loff_t *ppos)
+{
+	unsigned int start;
+	char buf[10] = { 0 };
+	int ret = 0;
+
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%d", &start);
+	ret = pxa988_start_stop_dc_stat(&pxa988_clk_gc2d, start);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+static const struct file_operations pxa988_gc2d_dc_ops = {
+	.owner = THIS_MODULE,
+	.read = pxa988_gc2d_dc_read,
+	.write = pxa988_gc2d_dc_write,
+};
+
+static ssize_t pxa988_vpu_dc_read(struct file *filp,
+	char __user *buffer, size_t count, loff_t *ppos)
+{
+	char *p;
+	int len = 0;
+	size_t ret, size = PAGE_SIZE - 1;
+
+	p = (char *)__get_free_pages(GFP_NOIO, 0);
+	if (!p)
+		return -ENOMEM;
+
+	len = pxa988_show_dc_stat_info(&pxa988_clk_vpu, p, size);
+	if (len < 0) {
+		free_pages((unsigned long)p, 0);
+		return -EINVAL;
+	}
+	if (len == size)
+		pr_warn("%s The dump buf is not large enough!\n", __func__);
+
+	ret = simple_read_from_buffer(buffer, count, ppos, p, len);
+	free_pages((unsigned long)p, 0);
+	return ret;
+}
+
+static ssize_t pxa988_vpu_dc_write(struct file *filp,
+		const char __user *buffer, size_t count, loff_t *ppos)
+{
+	unsigned int start;
+	char buf[10] = { 0 };
+	int ret = 0;
+
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%d", &start);
+	ret = pxa988_start_stop_dc_stat(&pxa988_clk_vpu, start);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+static const struct file_operations pxa988_vpu_dc_ops = {
+	.owner = THIS_MODULE,
+	.read = pxa988_vpu_dc_read,
+	.write = pxa988_vpu_dc_write,
+};
+
+static ssize_t pxa988_clk_stats_read(struct file *filp,
+	char __user *buffer, size_t count, loff_t *ppos)
+{
+	char *buf;
+	int len = 0, i, enabled, ret;
+	unsigned int reg, size = PAGE_SIZE - 1;
+	struct clk *temp;
+
+	buf = (char *)__get_free_pages(GFP_NOIO, 0);
+	if (!buf)
+		return -ENOMEM;
+
+	len += snprintf(buf + len, size,
+		       "|---------------|-------|\n|%14s\t|%s|\n"
+		       "|---------------|-------|\n", "Clock Name", " Status");
+
+	reg = __raw_readl(MPMU_PLL2CR);
+	if (((reg & (3 << 8)) >> 8) == 2)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "PLL2", "off");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "PLL2", "on");
+
+	reg = __raw_readl(MPMU_PLL3CR);
+	if (((reg & (3 << 18)) >> 18) == 0)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "PLL3", "off");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "PLL3", "on");
+
+	reg = __raw_readl(APMU_GC_CLK_RES_CTRL);
+	if (((reg & (3 << 4)) >> 4) == 3)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "GC FCLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "GC FCLK", "off");
+	if (((reg & (1 << 3)) >> 3) == 1)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "GC ACLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "GC ACLK", "off");
+
+	reg = __raw_readl(APMU_VPU_CLK_RES_CTRL);
+	if (((reg & (3 << 4)) >> 4) == 3)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "VPU FCLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "VPU FCLK", "off");
+	if (((reg & (1 << 3)) >> 3) == 1)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "VPU ACLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "VPU ACLK", "off");
+
+	reg = __raw_readl(APMU_LCD_CLK_RES_CTRL);
+	if ((((reg & (1 << 1)) >> 1) == 1) && (((reg & (1 << 4)) >> 4) == 1))
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "LCD FCLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "LCD FCLK", "off");
+	if (((reg & (1 << 3)) >> 3) == 1)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "LCD ACLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "LCD ACLK", "off");
+	if ((((reg & (1 << 5)) >> 5) == 1) && (((reg & (1 << 2)) >> 2) == 1))
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "LCD HCLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "LCD HCLK", "off");
+
+	reg = __raw_readl(APMU_SDH0);
+	if ((((reg & (1 << 3)) >> 3) == 1) && (((reg & (1 << 0)) >> 0) == 1))
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "SDH ACLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "SDH ACLK", "off");
+
+	if ((((reg & (1 << 4)) >> 4) == 1) && (((reg & (1 << 1)) >> 1) == 1))
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "SDH0 FCLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "SDH0 FCLK", "off");
+
+	reg = __raw_readl(APMU_SDH1);
+	if ((((reg & (1 << 4)) >> 4) == 1) && (((reg & (1 << 1)) >> 1) == 1))
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "SDH1 FCLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "SDH1 FCLK", "off");
+
+	reg = __raw_readl(APMU_SDH2);
+	if ((((reg & (1 << 4)) >> 4) == 1) && (((reg & (1 << 1)) >> 1) == 1))
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "SDH2 FCLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "SDH2 FCLK", "off");
+
+	reg = __raw_readl(APMU_CCIC_RST);
+	if ((((reg & (1 << 4)) >> 4) == 1) && (((reg & (1 << 1)) >> 1) == 1))
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "CCIC FCLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "CCIC FCLK", "off");
+
+	if ((((reg & (1 << 3)) >> 3) == 1) && (((reg & (1 << 0)) >> 0) == 1))
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "CCIC ACLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "CCIC ACLK", "off");
+	if ((((reg & (1 << 5)) >> 5) == 1) && (((reg & (1 << 2)) >> 2) == 1))
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "CCIC PHYCLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "CCIC PHYCLK", "off");
+
+	reg = __raw_readl(APMU_DSI);
+	if (((reg & (0xf << 2)) >> 2) == 0xf)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "DSI PHYCLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "DSI PHYCLK", "off");
+
+	reg = __raw_readl(APMU_ISPDXO);
+	if ((reg & 0xf03) == 0xf03)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "ISP_DXO CLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "ISP_DXO CLK", "off");
+
+	reg = __raw_readl(APMU_TRACE);
+	if (((reg & (1 << 3)) >> 3) == 1)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "DBG CLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "DBG CLK", "off");
+	if (((reg & (1 << 4)) >> 4) == 1)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "TRACE CLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "TRACE CLK", "off");
+
+	for (i = 0; i < ARRAY_SIZE(pxa988_list_clks); i++) {
+		temp = &pxa988_list_clks[i];
+		if (temp->ops == &apbc_clk_ops) {
+			enabled = ((__raw_readl(temp->clk_rst) & 0x5) == 0x1);
+			len += snprintf(buf + len, size,
+				"|%14s\t|%5s\t|\n", temp->name,
+				enabled ? "on" : "off");
+		} else if (temp->ops == &apmu_clk_ops) {
+			enabled = ((__raw_readl(temp->clk_rst) &
+				  (temp->enable_val)) == (temp->enable_val));
+			len += snprintf(buf + len, size,
+					"|%14s\t|%5s\t|\n", temp->name,
+					enabled ? "on" : "off");
+		}
+	}
+
+	reg = __raw_readl(APBC_PXA988_PWM0);
+	if ((reg & 0x1) == 0x1) {
+		if ((reg & 0x6) == 0x2)
+			len += snprintf(buf + len, size,
+					"|%14s\t|%5s\t|\n", "PWM0 CLK", "on");
+		else
+			len += snprintf(buf + len, size,
+					"|%14s\t|%5s\t|\n", "PWM0 CLK", "off");
+		reg = __raw_readl(APBC_PXA988_PWM1);
+		if ((reg & 0x6) == 0x2)
+			len += snprintf(buf + len, size,
+					"|%14s\t|%5s\t|\n", "PWM1 CLK", "on");
+		else
+			len += snprintf(buf + len, size,
+					"|%14s\t|%5s\t|\n", "PWM1 CLK", "off");
+	} else {
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "PWM0 CLK", "off");
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "PWM1 CLK", "off");
+	}
+
+	reg = __raw_readl(APBC_PXA988_PWM2);
+	if ((reg & 0x1) == 0x1) {
+		if ((reg & 0x6) == 0x2)
+			len += snprintf(buf + len, size,
+					"|%14s\t|%5s\t|\n", "PWM2 CLK", "on");
+		else
+			len += snprintf(buf + len, size,
+					"|%14s\t|%5s\t|\n", "PWM2 CLK", "off");
+		reg = __raw_readl(APBC_PXA988_PWM3);
+		if ((reg & 0x6) == 0x2)
+			len += snprintf(buf + len, size,
+					"|%14s\t|%5s\t|\n", "PWM3 CLK", "on");
+		else
+			len += snprintf(buf + len, size,
+					"|%14s\t|%5s\t|\n", "PWM3 CLK", "off");
+	} else {
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "PWM2 CLK", "off");
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "PWM3 CLK", "off");
+	}
+
+	reg = __raw_readl(APMU_USB);
+	if ((reg & 0x9) == 0x9)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "USB ACLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "USB ACLK", "off");
+
+	reg = __raw_readl(APMU_NAND);
+	if ((reg & 0x19b) == 0x19b)
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "NAND CLK", "on");
+	else
+		len += snprintf(buf + len, size,
+			       "|%14s\t|%5s\t|\n", "NAND CLK", "off");
+
+	len += snprintf(buf + len, size, "|---------------|-------|\n\n");
+
+	ret = simple_read_from_buffer(buffer, count, ppos, buf, len);
+	free_pages((unsigned long)buf, 0);
+	return ret;
+}
+
+static const struct file_operations pxa988_clk_stats_ops = {
+	.owner = THIS_MODULE,
+	.read = pxa988_clk_stats_read,
+};
+
+struct dentry *stat;
+static int __init __init_dcstat_debugfs_node(void)
+{
+	struct dentry *gc_dc_stat, *vpu_dc_stat, *clock_status;
+	struct dentry *gc2d_dc_stat;
+	stat = debugfs_create_dir("stat", pxa);
+	if (!stat)
+		return -ENOENT;
+
+	gc_dc_stat = debugfs_create_file("gc_dc_stat", 0664,
+		stat, NULL, &pxa988_gc_dc_ops);
+	if (!gc_dc_stat)
+		return -ENOENT;
+
+	vpu_dc_stat = debugfs_create_file("vpu_dc_stat", 0664,
+		stat, NULL, &pxa988_vpu_dc_ops);
+	if (!vpu_dc_stat)
+		goto err_vpu_dc_stat;
+	clock_status = debugfs_create_file("clock_status", 0444,
+					   pxa, NULL, &pxa988_clk_stats_ops);
+	if (!clock_status)
+		goto err_clk_stats;
+
+	if (cpu_is_pxa1088()) {
+		gc2d_dc_stat = debugfs_create_file("gc2d_dc_stat", 0664,
+			stat, NULL, &pxa988_gc2d_dc_ops);
+		if (!gc2d_dc_stat)
+			goto err_gc2d_dc_stat;
+	}
+
+	return 0;
+
+err_gc2d_dc_stat:
+	debugfs_remove(clock_status);
+err_clk_stats:
+	debugfs_remove(vpu_dc_stat);
+err_vpu_dc_stat:
+	debugfs_remove(gc_dc_stat);
+	return -ENOENT;
+}
+late_initcall(__init_dcstat_debugfs_node);
+#endif
diff --git a/arch/arm/mach-mmp/common.c b/arch/arm/mach-mmp/common.c
index 9292b796..15f9e2f7 100644
--- a/arch/arm/mach-mmp/common.c
+++ b/arch/arm/mach-mmp/common.c
@@ -36,6 +36,32 @@ static struct map_desc standard_io_desc[] __initdata = {
 		.virtual	= (unsigned long)AXI_VIRT_BASE,
 		.length		= AXI_PHYS_SIZE,
 		.type		= MT_DEVICE,
+#ifdef PERI_PHYS_BASE
+	}, {
+		.pfn		= __phys_to_pfn(PERI_PHYS_BASE),
+		.virtual	= (unsigned long)PERI_VIRT_BASE,
+		.length		= PERI_PHYS_SIZE,
+		.type		= MT_DEVICE,
+#endif /* PERI_PHYS_BASE */
+#ifdef DMCU_PHYS_BASE
+	}, {
+		.pfn		= __phys_to_pfn(DMCU_PHYS_BASE),
+		.virtual	= DMCU_VIRT_BASE,
+		.length		= DMCU_PHYS_SIZE,
+		.type		= MT_DEVICE,
+#endif
+#ifdef CONFIG_CPU_MMP3
+	}, {
+		.pfn		= __phys_to_pfn(AUD_PHYS_BASE),
+		.virtual	= (unsigned long)AUD_VIRT_BASE,
+		.length		= AUD_PHYS_SIZE,
+		.type		= MT_DEVICE,
+	}, {
+		.pfn		= __phys_to_pfn(AUD_PHYS_BASE2),
+		.virtual	= (unsigned long)AUD_VIRT_BASE2,
+		.length		= AUD_PHYS_SIZE2,
+		.type		= MT_DEVICE,
+#endif
 	},
 };
 
diff --git a/arch/arm/mach-mmp/common.h b/arch/arm/mach-mmp/common.h
index 1c9d6c1e..c039bf9c 100644
--- a/arch/arm/mach-mmp/common.h
+++ b/arch/arm/mach-mmp/common.h
@@ -1,9 +1,32 @@
+#include <linux/i2c.h>
+
 #define ARRAY_AND_SIZE(x)	(x), ARRAY_SIZE(x)
 
+struct pxa_i2c_board_gpio {
+	char		type[I2C_NAME_SIZE];
+	int		gpio;
+};
+
 struct sys_timer;
 
 extern void timer_init(int irq);
+extern void __init apb_timer_init(void);
 
 extern void __init icu_init_irq(void);
 extern void __init mmp_map_io(void);
+extern void __init mmp_wakeupgen_init(void);
 extern void mmp_restart(char, const char *);
+extern void mmp_arch_reset(char mode, const char *cmd);
+#ifdef CONFIG_HAVE_ARM_SCU
+extern void __iomem *pxa_scu_base_addr(void);
+#endif
+
+#define VER_1V0 0x10
+#define VER_1V1 0x11
+#define VER_T7  0x70
+
+extern int get_board_id(void);
+extern int get_recoverymode(void);
+
+extern void pxa_init_i2c_gpio_irq(struct pxa_i2c_board_gpio *, unsigned len,
+				struct i2c_board_info *, unsigned size);
diff --git a/arch/arm/mach-mmp/coresight-v7.c b/arch/arm/mach-mmp/coresight-v7.c
new file mode 100644
index 00000000..5c508551
--- /dev/null
+++ b/arch/arm/mach-mmp/coresight-v7.c
@@ -0,0 +1,417 @@
+/*
+ * linux/arch/arm/mach-mmp/coresight-v7.c
+ *
+ * Author:	Neil Zhang <zhangwm@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/cpu.h>
+#include <linux/smp.h>
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/percpu.h>
+#include <linux/cpu_pm.h>
+#include <linux/notifier.h>
+
+#include <asm/io.h>
+
+#include <mach/regs-coresight.h>
+
+struct ptm_info {
+	u32	ptm_ter;	/* offset: 0x8 */
+	u32	ptm_teer;	/* offset: 0x20 */
+	u32	ptm_tecr;	/* offset: 0x24 */
+	u32	ptm_cstidr;	/* offset: 0x200 */
+	u32	ptm_mcr;	/* offset: 0x0 */
+};
+
+struct coresight_info {
+	u32     tpiu_ffcr;	/* offset: 0x304 */
+	u32     etb_ffcr;	/* offset: 0x304 */
+	u32     etb_ctrl;	/* offset: 0x20 */
+	u32     cstf_pcr;	/* offset: 0x4 */
+	u32     cstf_fcr;	/* offset: 0x0 */
+};
+
+static struct clk *dbgclk;
+
+void coresight_dump_pcsr(u32 cpu)
+{
+	u32 val;
+	int i;
+
+	if (!dbgclk)
+		return;
+
+	clk_enable(dbgclk);
+
+	printk(KERN_EMERG "======== dump PCSR for cpu%d ========\n", cpu);
+	for (i = 0; i < 8; i++) {
+		val = readl(DBG_PCSR(cpu));
+		printk(KERN_EMERG "PCSR of cpu%d is 0x%x\n", cpu, val);
+		udelay(10);
+	}
+}
+
+void coresight_panic_locked_cpu(int cpu)
+{
+	unsigned int val, timeout = 10000;
+
+	if (!dbgclk)
+		return;
+
+	clk_enable(dbgclk);
+	coresight_dump_pcsr(cpu);
+
+	/* Unlock debug register access */
+	writel(0xC5ACCE55, DBG_LAR(cpu));
+
+	/* Enable Halt Debug and Instruction Transfer */
+	val = readl(DBG_DSCR(cpu));
+	val |= (0x1 << 14) | (0x1 << 13);
+	writel(val, DBG_DSCR(cpu));
+
+	/* Halt the dest cpu */
+	writel(0x1, DBG_DRCR(cpu));
+
+	/* Wait the cpu halted */
+	do {
+		val = readl(DBG_DSCR(cpu));
+		if (val & 0x1)
+			break;
+	}while(timeout--);
+
+	if (!timeout) {
+		printk(KERN_EMERG "Cannot stop cpu%d\n", cpu);
+		return;
+	}
+
+	/* Issue an instruction to change the PC of dest cpu to 0 */
+	writel(0xE3A0F000, DBG_ITR(cpu));
+
+	/* Wait until the instruction complete */
+	timeout = 10000;
+	do {
+		val = readl(DBG_DSCR(cpu));
+		if (val & (0x1 << 24))
+			break;
+	}while (timeout--);
+
+	if (!timeout)
+		printk(KERN_EMERG "Cannot execute instructions on cpu%d\n", cpu);
+
+	val = readl(DBG_DSCR(cpu));
+	val &= ~((0x1 << 14) | (0x1 << 13));
+	writel(val, DBG_DSCR(cpu));
+
+	/* Restart dest cpu */
+	printk(KERN_EMERG "Going to trigger panic on cpu%d\n", cpu);
+	writel(0x2, DBG_DRCR(cpu));
+
+	timeout = 10000;
+	do {
+		val = readl(DBG_DSCR(cpu));
+		if (val & (0x1 << 1))
+			break;
+	} while (timeout--);
+
+	if (!timeout)
+		printk(KERN_EMERG "Cannot restart cpu%d\n", cpu);
+}
+
+#ifdef CONFIG_CORESIGHT_TRACE_SUPPORT
+
+/* The following CTI related operations are needed by Pixiu */
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+struct cti_info {
+	u32	cti_ctrl;	/* offset: 0x0 */
+	u32	cti_en_in1;	/* offset: 0x24 */
+	u32	cti_en_out6;	/* offset: 0xb8 */
+};
+
+static DEFINE_PER_CPU(struct cti_info, cpu_cti_info);
+
+static inline void cti_enable_access(void)
+{
+	writel_relaxed(0xC5ACCE55, CTI_LOCK);
+}
+
+static void coresight_cti_save(void)
+{
+	struct cti_info *p_cti_info;
+	p_cti_info = &per_cpu(cpu_cti_info, smp_processor_id());
+
+	cti_enable_access();
+	p_cti_info->cti_ctrl = readl_relaxed(CTI_REG(0x0));
+	p_cti_info->cti_en_in1 = readl_relaxed(CTI_REG(0x24));
+	p_cti_info->cti_en_out6 = readl_relaxed(CTI_REG(0xb8));
+}
+
+static void coresight_cti_restore(void)
+{
+	struct cti_info *p_cti_info;
+	p_cti_info = &per_cpu(cpu_cti_info, smp_processor_id());
+
+	cti_enable_access();
+	writel_relaxed(p_cti_info->cti_ctrl, CTI_REG(0x0));
+	writel_relaxed(p_cti_info->cti_en_in1, CTI_REG(0x24));
+	writel_relaxed(p_cti_info->cti_en_out6, CTI_REG(0xB8));
+
+	dsb();
+	isb();
+}
+#endif
+
+static DEFINE_PER_CPU(struct ptm_info, cpu_ptm_info);
+
+static struct coresight_info cst_info;
+
+static u32 enable_etm_trace = (1 << CONFIG_NR_CPUS) - 1;
+static int __init __init_etm_trace(char *arg)
+{
+	u32 cpu_mask;
+
+	if (!get_option(&arg, &cpu_mask))
+		return 0;
+
+	enable_etm_trace &= cpu_mask;
+
+	return 1;
+}
+__setup("etm_trace=", __init_etm_trace);
+
+/* The following operations are needed by XDB */
+static inline void ptm_enable_access(void)
+{
+	writel_relaxed(0xC5ACCE55, PTM_LOCK);
+}
+
+static inline void ptm_disable_access(void)
+{
+	writel_relaxed(0x0, PTM_LOCK);
+}
+
+static void coresight_ptm_save(void)
+{
+	struct ptm_info *p_ptm_info;
+	p_ptm_info = &per_cpu(cpu_ptm_info, smp_processor_id());
+
+	ptm_enable_access();
+	p_ptm_info->ptm_ter = readl_relaxed(PTM_REG(0x8));
+	p_ptm_info->ptm_teer = readl_relaxed(PTM_REG(0x20));
+	p_ptm_info->ptm_tecr = readl_relaxed(PTM_REG(0x24));
+	p_ptm_info->ptm_cstidr = readl_relaxed(PTM_REG(0x200));
+	p_ptm_info->ptm_mcr = readl_relaxed(PTM_REG(0x0));
+	ptm_disable_access();
+}
+
+static void coresight_ptm_restore(void)
+{
+	struct ptm_info *p_ptm_info;
+	p_ptm_info = &per_cpu(cpu_ptm_info, smp_processor_id());
+
+	ptm_enable_access();
+
+	if (readl_relaxed(PTM_REG(0x0)) != p_ptm_info->ptm_mcr) {
+		writel_relaxed(0x400, PTM_REG(0x0));
+		writel_relaxed(p_ptm_info->ptm_ter, PTM_REG(0x8));
+		writel_relaxed(p_ptm_info->ptm_teer, PTM_REG(0x20));
+		writel_relaxed(p_ptm_info->ptm_tecr, PTM_REG(0x24));
+		writel_relaxed(p_ptm_info->ptm_cstidr, PTM_REG(0x200));
+		writel_relaxed(p_ptm_info->ptm_mcr, PTM_REG(0x0));
+	}
+
+	ptm_disable_access();
+
+	dsb();
+	isb();
+}
+
+static void coresight_core_save(void)
+{
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	coresight_cti_save();
+#endif
+
+	coresight_ptm_save();
+}
+
+static void coresight_core_restore(void)
+{
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	coresight_cti_restore();
+#endif
+
+	coresight_ptm_restore();
+}
+
+static inline void coresight_enable_access(void)
+{
+	writel_relaxed(0xC5ACCE55, CSTF_LOCK);
+	writel_relaxed(0xC5ACCE55, TPIU_LOCK);
+	writel_relaxed(0xC5ACCE55, ETB_LOCK);
+}
+
+static inline void coresight_disable_access(void)
+{
+	writel_relaxed(0x0, CSTF_LOCK);
+	writel_relaxed(0x0, TPIU_LOCK);
+	writel_relaxed(0x0, ETB_LOCK);
+}
+
+static void coresight_save(void)
+{
+	coresight_enable_access();
+	cst_info.tpiu_ffcr = readl_relaxed(TPIU_REG(0x304));
+	cst_info.etb_ffcr = readl_relaxed(ETB_REG(0x304));
+	cst_info.cstf_pcr = readl_relaxed(CSTF_REG(0x4));
+	cst_info.cstf_fcr = readl_relaxed(CSTF_REG(0x0));
+	cst_info.etb_ctrl = readl_relaxed(ETB_REG(0x20));
+	coresight_disable_access();
+}
+
+static void coresight_restore(void)
+{
+	coresight_enable_access();
+	writel_relaxed(cst_info.tpiu_ffcr, TPIU_REG(0x304));
+	writel_relaxed(cst_info.etb_ffcr, ETB_REG(0x304));
+	writel_relaxed(cst_info.cstf_pcr, CSTF_REG(0x4));
+	writel_relaxed(cst_info.cstf_fcr, CSTF_REG(0x0));
+	writel_relaxed(cst_info.etb_ctrl, ETB_REG(0x20));
+	coresight_disable_access();
+}
+
+
+static int coresight_notifier(struct notifier_block *self,
+				unsigned long cmd, void *v)
+{
+	switch (cmd) {
+	case CPU_PM_ENTER:
+		coresight_core_save();
+		break;
+	case CPU_PM_ENTER_FAILED:
+	case CPU_PM_EXIT:
+		coresight_core_restore();
+		break;
+	case CPU_CLUSTER_PM_ENTER:
+		coresight_save();
+		break;
+	case CPU_CLUSTER_PM_ENTER_FAILED:
+	case CPU_CLUSTER_PM_EXIT:
+		coresight_restore();
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block coresight_notifier_block = {
+	.notifier_call = coresight_notifier,
+};
+
+static int __cpuinit coresight_core_notifier(struct notifier_block *nfb,
+				      unsigned long action, void *hcpu)
+{
+	switch (action & ~CPU_TASKS_FROZEN) {
+	case CPU_STARTING:
+		coresight_core_restore();
+		return NOTIFY_OK;
+
+	case CPU_DYING:
+		coresight_core_save();
+		return NOTIFY_OK;
+
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+static void __init coresight_mp_init(void)
+{
+	coresight_enable_access();
+	writel_relaxed(0x1000, TPIU_REG(0x304));
+	writel_relaxed(0x1, ETB_REG(0x304));
+	writel_relaxed(0x0, CSTF_REG(0x4));
+	writel_relaxed(enable_etm_trace, CSTF_REG(0x0));
+	writel_relaxed(0x1, ETB_REG(0x20));
+	coresight_disable_access();
+}
+
+void coresight_ptm_disable(u32 cpu)
+{
+	void __iomem *ptm_base = PTM_CORE0_VIRT_BASE + 0x1000 * cpu;
+
+	writel_relaxed(0xC5ACCE55, (ptm_base + 0xFB0));
+	writel_relaxed(0x1, (ptm_base + 0x0));
+	writel_relaxed(0x0, (ptm_base + 0xFB0));
+
+	dsb();
+	isb();
+}
+
+static void coresight_ptm_enable(u32 cpu)
+{
+	void __iomem *ptm_base = PTM_CORE0_VIRT_BASE + 0x1000 * cpu;
+
+	/* enable PTM access first */
+	writel_relaxed(0xC5ACCE55, (ptm_base + 0xFB0));
+
+#ifdef CONFIG_CPU_CA7MP
+	writel_relaxed(0xFFFFFFFF, (ptm_base + 0x300));
+#endif
+	writel_relaxed(0x400, (ptm_base + 0x0));
+	writel_relaxed(0x406f, (ptm_base + 0x8));
+	writel_relaxed(0x6f, (ptm_base + 0x20));
+	writel_relaxed(0x1000000, (ptm_base + 0x24));
+	writel_relaxed((cpu + 0x1), (ptm_base + 0x200));
+#ifdef CONFIG_CPU_CA7MP
+	writel_relaxed(0xc940, (ptm_base + 0x0));
+#else
+	writel_relaxed(0xc000, (ptm_base + 0x0));
+#endif
+
+	/* disable PTM access */
+	writel_relaxed(0x0, (ptm_base + 0xFB0));
+
+	dsb();
+	isb();
+}
+
+static void __init coresight_ptm_init(void)
+{
+	int cpu;
+
+	for_each_possible_cpu(cpu)
+		if (test_bit(cpu, (void *)&enable_etm_trace))
+			coresight_ptm_enable(cpu);
+}
+#endif
+
+static int __init coresight_init(void)
+{
+	dbgclk = clk_get(NULL, "DBGCLK");
+	if (IS_ERR(dbgclk)) {
+		pr_warn("No DBGCLK is defined...\n");
+		dbgclk = NULL;
+	}
+
+#ifdef CONFIG_CORESIGHT_TRACE_SUPPORT
+	/* enable etm trace by default */
+	coresight_mp_init();
+	coresight_ptm_init();
+
+	cpu_notifier(coresight_core_notifier, 0);
+	cpu_pm_register_notifier(&coresight_notifier_block);
+#endif
+
+	return 0;
+}
+
+arch_initcall(coresight_init);
diff --git a/arch/arm/mach-mmp/cpuidle-pxa988.c b/arch/arm/mach-mmp/cpuidle-pxa988.c
new file mode 100644
index 00000000..601eb36f
--- /dev/null
+++ b/arch/arm/mach-mmp/cpuidle-pxa988.c
@@ -0,0 +1,229 @@
+/*
+ * linux/arch/arm/mach-mmp/cpuidle-pxa988.c
+ *
+ * Author:	Raul Xiong <xjian@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/cpu_pm.h>
+#include <linux/cpuidle.h>
+#include <linux/export.h>
+#include <linux/pm_qos.h>
+
+#include <mach/regs-apmu.h>
+#include <asm/io.h>
+#include <asm/proc-fns.h>
+#include <mach/pxa988_lowpower.h>
+#include <mach/features.h>
+
+static enum pxa988_lowpower_mode pxa988_idle_mode[] = {
+	PXA988_LPM_C1,
+	PXA988_LPM_C2,
+	PXA988_LPM_D1P,
+	PXA988_LPM_D1,
+	PXA988_LPM_D2,
+};
+
+struct cpuidle_params {
+	u32 exit_latency;	/* exit_latency = sleep + wake-up latencies */
+	u32 target_residency;
+};
+
+static struct cpuidle_params cpuidle_params_table[] = {
+	/* C1 */
+	{18, 36},
+	/* C2 */
+	{450, 900},
+	/* D1P */
+	{500, 1000},
+	/* D1 */
+	{600, 1200},
+};
+#define PXA988_NUM_STATES ARRAY_SIZE(cpuidle_params_table)
+
+static struct cpuidle_driver pxa988_idle_driver = {
+	.name = "pxa988_idle",
+	.owner = THIS_MODULE,
+	.state_count = PXA988_NUM_STATES,
+	.en_core_tk_irqen = 1,
+};
+
+static DEFINE_PER_CPU(struct cpuidle_device, pxa988_cpuidle_device);
+
+#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED
+static bool cpu_done[NR_CPUS];
+static atomic_t abort_barrier;
+
+static int pxa988_enter_lpm(struct cpuidle_device *dev,
+				struct cpuidle_driver *drv,
+				int index)
+{
+	enum pxa988_lowpower_mode *power_mode = \
+			cpuidle_get_statedata(&dev->states_usage[index]);
+	int real_mode;		/*indicate the actual */
+
+	if (*power_mode == PXA988_LPM_C1) {
+		pxa988_enter_c1(dev->cpu);
+		return index;
+	}
+
+	local_fiq_disable();
+	/*
+	 * CPU0 has to wait and stay ON until CPU1 is OFF state.
+	 */
+	if (dev->cpu == 0 && cpumask_test_cpu(1, cpu_online_mask)) {
+		u32 core_state;
+		do {
+			if (has_feat_legacy_apmu_core_status())
+				core_state = __raw_readl(APMU_CORE_STATUS) &
+					(1 << (3 + 2 * 1));
+			else
+				core_state = __raw_readl(APMU_CORE_STATUS) &
+					(1 << (4 + 3 * 1));
+			cpu_relax();
+			/*
+			 * CPU1 could have already entered & exited idle
+			 * without hitting off because of a failed attempt
+			 * to low power mode.  Check for that here, otherwise
+			 * we could spin forever waiting for CPU1 off.
+			 */
+			if (cpu_done[1]) {
+				real_mode = PXA988_LPM_C1;
+				goto fail;
+			}
+		} while (!core_state);
+	}
+
+	real_mode = pxa988_enter_lowpower(dev->cpu, *power_mode);
+
+	cpu_done[dev->cpu] = true;
+	/* Wakeup CPU1 only if it is not offlined */
+	if (dev->cpu == 0 && cpumask_test_cpu(1, cpu_online_mask))
+		smp_send_reschedule(1);
+fail:
+	cpuidle_coupled_parallel_barrier(dev, &abort_barrier);
+	cpu_done[dev->cpu] = false;
+
+	for (index = 0; index < CPUIDLE_STATE_MAX; index++) {
+		if (real_mode == INVALID_LPM) {
+			index = INVALID_LPM;
+			break;
+		}
+		if (real_mode == *(int *) \
+			cpuidle_get_statedata(&dev->states_usage[index]))
+			break;
+	}
+
+	local_fiq_enable();
+
+	return index;
+}
+#else
+static int pxa988_enter_lpm(struct cpuidle_device *dev,
+				struct cpuidle_driver *drv,
+				int index)
+{
+	enum pxa988_lowpower_mode *power_mode = cpuidle_get_statedata(&dev->states_usage[index]);
+
+	local_fiq_disable();
+
+	index = pxa988_enter_lowpower(dev->cpu, *power_mode);
+
+	local_fiq_enable();
+
+	return index;
+}
+#endif
+
+/* Helper to fill the C-state common data*/
+static inline void _fill_state(struct cpuidle_driver *drv,
+				int idx, const char *name, const char *descr)
+{
+	struct cpuidle_state *state = &drv->states[idx];
+
+	state->exit_latency	= cpuidle_params_table[idx].exit_latency;
+	state->target_residency	= cpuidle_params_table[idx].target_residency;
+#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED
+	if (idx <= drv->safe_state_index)
+		state->flags	= CPUIDLE_FLAG_TIME_VALID;
+	else
+		state->flags	= CPUIDLE_FLAG_TIME_VALID | \
+					CPUIDLE_FLAG_COUPLED;
+#else
+	state->flags		= CPUIDLE_FLAG_TIME_VALID;
+#endif
+	state->enter		= pxa988_enter_lpm;
+	strncpy(state->name, name, CPUIDLE_NAME_LEN - 1);
+	strncpy(state->desc, descr, CPUIDLE_DESC_LEN - 1);
+}
+
+static void fill_driver_state(void)
+{
+	struct cpuidle_driver *drv = &pxa988_idle_driver;
+	/* C1, internal WFI */
+	_fill_state(drv, 0, "C1", "C1: Core internal clock gated");
+	/* C2, core power down */
+	_fill_state(drv, 1, "C2", "C2: Core power down");
+	/* D1P, core power down, AXI shutdown */
+	_fill_state(drv, 2, "D1P", "D1P: AP subsystem idle");
+	/* D1, core power down, AXI, DDR, APB shutdown, chip sleep */
+	_fill_state(drv, 3, "D1", "D1: chip sleep");
+}
+static int pxa988_cpuidle_register_device(unsigned int cpu)
+{
+	struct cpuidle_device *device;
+
+	device = &per_cpu(pxa988_cpuidle_device, cpu);
+	device->cpu = cpu;
+#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED
+	device->coupled_cpus = *cpu_present_mask;
+	device->safe_state_index = 0;
+#endif
+
+	cpuidle_set_statedata(&device->states_usage[0],
+			&pxa988_idle_mode[0]);
+
+	cpuidle_set_statedata(&device->states_usage[1],
+			&pxa988_idle_mode[1]);
+
+	cpuidle_set_statedata(&device->states_usage[2],
+			&pxa988_idle_mode[2]);
+
+	cpuidle_set_statedata(&device->states_usage[3],
+			&pxa988_idle_mode[3]);
+
+	device->state_count = PXA988_NUM_STATES;
+
+	if (cpuidle_register_device(device)) {
+		pr_err("CPU%u: failed to register cpuidle device\n", cpu);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int __init pxa988_cpuidle_init(void)
+{
+	int ret, cpu;
+
+	ret = cpuidle_register_driver(&pxa988_idle_driver);
+	if (ret)
+		return ret;
+
+	fill_driver_state();
+	for_each_possible_cpu(cpu) {
+		if (pxa988_cpuidle_register_device(cpu))
+			pr_err("CPU%u: error registering cpuidle\n", cpu);
+	}
+
+	return 0;
+}
+
+module_init(pxa988_cpuidle_init);
diff --git a/arch/arm/mach-mmp/devices.c b/arch/arm/mach-mmp/devices.c
index 191d9dea..d79a9980 100644
--- a/arch/arm/mach-mmp/devices.c
+++ b/arch/arm/mach-mmp/devices.c
@@ -9,9 +9,21 @@
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
 
 #include <asm/irq.h>
+#include <mach/irqs.h>
 #include <mach/devices.h>
+#include <mach/cputype.h>
+#include <mach/regs-usb.h>
+#include <mach/soc_coda7542.h>
+#ifdef CONFIG_UIO_HANTRO
+#include <mach/soc_hantro.h>
+#endif
+#include <mach/addr-map.h>
+
+#include "common.h"
 
 int __init pxa_register_device(struct pxa_device_desc *desc,
 				void *data, size_t size)
@@ -67,3 +79,626 @@ int __init pxa_register_device(struct pxa_device_desc *desc,
 
 	return platform_device_add(pdev);
 }
+
+void __init
+pxa_init_i2c_gpio_irq(struct pxa_i2c_board_gpio *gpio_info, unsigned len,
+				struct i2c_board_info *i2c_info, unsigned size)
+{
+	int i, j;
+
+	for (i = 0; i < len; i++) {
+		for (j = 0; j < size; j++) {
+			if (!strcmp(i2c_info[j].type, gpio_info[i].type)) {
+				i2c_info[j].irq = gpio_to_irq(gpio_info[i].gpio);
+				break;
+			}
+		}
+
+		if (j == size)
+			pr_err("No i2c device named %s need to set irq!\n",
+				gpio_info[i].type);
+	}
+}
+
+#ifdef CONFIG_PXA9XX_ACIPC
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+static struct resource pxa9xx_resource_acipc[] = {
+	[0] = {
+		.start  = 0xD401D000,
+		.end    = 0xD401D0ff,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_PXA988_IPC_AP0,
+		.end    = IRQ_PXA988_IPC_AP0,
+		.flags  = IORESOURCE_IRQ,
+		.name   = "IPC_AP_DATAACK",
+	},
+	[2] = {
+		.start  = IRQ_PXA988_IPC_AP1,
+		.end    = IRQ_PXA988_IPC_AP1,
+		.flags  = IORESOURCE_IRQ,
+		.name   = "IPC_AP_SET_CMD",
+	},
+	[3] = {
+		.start  = IRQ_PXA988_IPC_AP2,
+		.end    = IRQ_PXA988_IPC_AP2,
+		.flags  = IORESOURCE_IRQ,
+		.name   = "IPC_AP_SET_MSG",
+	},
+};
+
+#elif defined(CONFIG_CPU_EDEN)
+static struct resource pxa9xx_resource_acipc[] = {
+	[0] = {
+		.start  = 0xD0220000,
+		.end    = 0xD02200ff,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_EDEN_IPC_CP,
+		.end    = IRQ_EDEN_IPC_CP,
+		.flags  = IORESOURCE_IRQ,
+		.name   = "IPC_CP2AP",
+	},
+};
+
+#else
+static struct resource pxa9xx_resource_acipc[] = {};
+#endif
+
+struct platform_device pxa9xx_device_acipc = {
+	.name           = "pxa9xx-acipc",
+	.id             = -1,
+	.resource       = pxa9xx_resource_acipc,
+	.num_resources  = ARRAY_SIZE(pxa9xx_resource_acipc),
+};
+#endif
+
+#if defined(CONFIG_USB) || defined(CONFIG_USB_GADGET)
+#if !defined(CONFIG_CPU_PXA988) && !defined(CONFIG_CPU_PXA1088)
+
+/*****************************************************************************
+ * The registers read/write routines
+ *****************************************************************************/
+
+static unsigned int u2o_get(void __iomem *base, unsigned int offset)
+{
+	return readl_relaxed(base + offset);
+}
+
+static void u2o_set(void __iomem *base, unsigned int offset,
+		unsigned int value)
+{
+	u32 reg;
+
+	reg = readl_relaxed(base + offset);
+	reg |= value;
+	writel_relaxed(reg, base + offset);
+	readl_relaxed(base + offset);
+}
+
+static void u2o_clear(void __iomem *base, unsigned int offset,
+		unsigned int value)
+{
+	u32 reg;
+
+	reg = readl_relaxed(base + offset);
+	reg &= ~value;
+	writel_relaxed(reg, base + offset);
+	readl_relaxed(base + offset);
+}
+
+static void u2o_write(void __iomem *base, unsigned int offset,
+		unsigned int value)
+{
+	writel_relaxed(value, base + offset);
+	readl_relaxed(base + offset);
+}
+#endif
+
+#if defined(CONFIG_USB_MV_UDC) || defined(CONFIG_USB_EHCI_MV)
+
+#ifdef CONFIG_CPU_MMP3
+
+static DEFINE_SPINLOCK(phy_lock);
+static int phy_init_cnt;
+
+static int usb_phy_init_internal(void __iomem *base)
+{
+	int loops = 0;
+	u32 temp;
+
+	pr_info("Init usb phy!!!\n");
+
+	temp = __raw_readl(APMU_REG(0x100));
+	temp &= ~0xF00;
+	temp |= 0xd00;
+	__raw_writel(temp, APMU_REG(0x100));
+
+	udelay(100);
+
+	u2o_clear(base, USB2_PLL_REG0,
+		USB2_PLL_REFDIV_MASK_MMP3_B0
+		| USB2_PLL_FBDIV_MASK_MMP3_B0);
+
+	u2o_set(base, USB2_PLL_REG0,
+		0xd << USB2_PLL_REFDIV_SHIFT_MMP3_B0
+		| 0xf0 << USB2_PLL_FBDIV_SHIFT_MMP3_B0);
+
+
+	/* USB2_PLL_REG1 = 0x3333 */
+	u2o_clear(base, USB2_PLL_REG1, USB2_PLL_PU_PLL_MASK
+		| USB2_PLL_ICP_MASK_MMP3
+		| USB2_PLL_KVCO_MASK_MMP3
+		| USB2_PLL_CALI12_MASK_MMP3);
+	u2o_set(base, USB2_PLL_REG1, 1 << USB2_PLL_PU_PLL_SHIFT_MMP3
+		| 1 << USB2_PLL_LOCK_BYPASS_SHIFT_MMP3
+		| 3 << USB2_PLL_ICP_SHIFT_MMP3
+		| 3 << USB2_PLL_KVCO_SHIFT_MMP3
+		| 3 << USB2_PLL_CAL12_SHIFT_MMP3);
+
+	/* USB2_TX_REG0 = 0x288 */
+	u2o_clear(base, USB2_TX_REG0, USB2_TX_IMPCAL_VTH_MASK_MMP3);
+	u2o_set(base, USB2_TX_REG0, 2 << USB2_TX_IMPCAL_VTH_SHIFT_MMP3);
+
+	/* USB2_TX_REG1 = 0x7c4 */
+	u2o_clear(base, USB2_TX_REG1, USB2_TX_VDD12_MASK_MMP3
+		| USB2_TX_AMP_MASK_MMP3
+		| USB2_TX_CK60_PHSEL_MASK_MMP3);
+	u2o_set(base, USB2_TX_REG1, 3 << USB2_TX_VDD12_SHIFT_MMP3
+		| 4 << USB2_TX_AMP_SHIFT_MMP3
+		| 4 << USB2_TX_CK60_PHSEL_SHIFT_MMP3);
+
+	/* USB2_TX_REG2 = 0xaff */
+	u2o_clear(base, USB2_TX_REG2, 3 << USB2_TX_DRV_SLEWRATE_SHIFT);
+	u2o_set(base, USB2_TX_REG2, 2 << USB2_TX_DRV_SLEWRATE_SHIFT);
+
+	/* USB2_RX_REG0 =  0xaaa1 */
+	u2o_clear(base, USB2_RX_REG0, USB2_RX_SQ_THRESH_MASK_MMP3);
+	u2o_set(base, USB2_RX_REG0, 0xa << USB2_RX_SQ_THRESH_SHIFT_MMP3);
+
+	/* USB2_ANA_REG1 =  0x5680 */
+	u2o_set(base, USB2_ANA_REG1, 0x1 << USB2_ANA_PU_ANA_SHIFT_MMP3);
+
+	/* USB2_OTG_REG0 =  0x8 */
+	u2o_set(base, USB2_OTG_REG0, 0x1 << USB2_OTG_PU_OTG_SHIFT_MMP3);
+
+	/* PLL Power up has been done in usb2CIEnableAppSubSysClocks routine
+	*  PLL VCO and TX Impedance Calibration Timing for Eshel & MMP3
+	*		   _____________________________________
+	*  PU   __________|
+	*			   ____________________________
+	*  VCOCAL START	__________|
+	*				  ___
+	*  REG_RCAL_START________________|   |________|_________
+	*		  | 200us |400us |40 | 400us  | USB PHY READY
+	* ------------------------------------------------------------------
+	*/
+	/* Calibrate PHY */
+	udelay(200);
+	u2o_set(base, USB2_PLL_REG1, 1 << USB2_PLL_VCOCAL_START_SHIFT_MMP3);
+	udelay(400);
+	u2o_set(base, USB2_TX_REG0, 1 << USB2_TX_RCAL_START_SHIFT_MMP3);
+	udelay(40);
+	u2o_clear(base, USB2_TX_REG0, 1 << USB2_TX_RCAL_START_SHIFT_MMP3);
+	udelay(400);
+
+	/* Make sure PHY PLL is ready */
+	loops = 0;
+	while ((u2o_get(base, USB2_PLL_REG1) & USB2_PLL_READY_MASK_MMP3) == 0) {
+		mdelay(1);
+		loops++;
+		if (loops > 100) {
+			pr_warn("PLL_READY not set after 100mS.");
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int usb_phy_deinit_internal(void __iomem *base)
+{
+	pr_info("Deinit usb phy!!!\n");
+	return 0;
+}
+
+int pxa_usb_phy_init(void __iomem *base)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&phy_lock, flags);
+	if (phy_init_cnt++ == 0)
+		usb_phy_init_internal(base);
+	spin_unlock_irqrestore(&phy_lock, flags);
+	return 0;
+}
+
+void pxa_usb_phy_deinit(void __iomem *base)
+{
+	unsigned long flags;
+
+	WARN_ON(phy_init_cnt == 0);
+
+	spin_lock_irqsave(&phy_lock, flags);
+	if (--phy_init_cnt == 0)
+		usb_phy_deinit_internal(base);
+	spin_unlock_irqrestore(&phy_lock, flags);
+}
+
+#endif
+
+#if defined(CONFIG_CPU_PXA910) || defined(CONFIG_CPU_PXA168)
+
+static DEFINE_MUTEX(phy_lock);
+static int phy_init_cnt;
+
+static int usb_phy_init_internal(void __iomem *base)
+{
+	int loops;
+
+	pr_info("Init usb phy!!!\n");
+
+	/* Initialize the USB PHY power */
+	if (cpu_is_pxa910()) {
+		u2o_set(base, UTMI_CTRL, (1<<UTMI_CTRL_INPKT_DELAY_SOF_SHIFT)
+			| (1<<UTMI_CTRL_PU_REF_SHIFT));
+	}
+
+	u2o_set(base, UTMI_CTRL, 1<<UTMI_CTRL_PLL_PWR_UP_SHIFT);
+	u2o_set(base, UTMI_CTRL, 1<<UTMI_CTRL_PWR_UP_SHIFT);
+
+	/* UTMI_PLL settings */
+	u2o_clear(base, UTMI_PLL, UTMI_PLL_PLLVDD18_MASK
+		| UTMI_PLL_PLLVDD12_MASK | UTMI_PLL_PLLCALI12_MASK
+		| UTMI_PLL_FBDIV_MASK | UTMI_PLL_REFDIV_MASK
+		| UTMI_PLL_ICP_MASK | UTMI_PLL_KVCO_MASK);
+
+	u2o_set(base, UTMI_PLL, 0xee<<UTMI_PLL_FBDIV_SHIFT
+		| 0xb<<UTMI_PLL_REFDIV_SHIFT | 3<<UTMI_PLL_PLLVDD18_SHIFT
+		| 3<<UTMI_PLL_PLLVDD12_SHIFT | 3<<UTMI_PLL_PLLCALI12_SHIFT
+		| 1<<UTMI_PLL_ICP_SHIFT | 3<<UTMI_PLL_KVCO_SHIFT);
+
+	/* UTMI_TX */
+	u2o_clear(base, UTMI_TX, UTMI_TX_REG_EXT_FS_RCAL_EN_MASK
+		| UTMI_TX_TXVDD12_MASK | UTMI_TX_CK60_PHSEL_MASK
+		| UTMI_TX_IMPCAL_VTH_MASK | UTMI_TX_REG_EXT_FS_RCAL_MASK
+		| UTMI_TX_AMP_MASK);
+	u2o_set(base, UTMI_TX, 3<<UTMI_TX_TXVDD12_SHIFT
+		| 4<<UTMI_TX_CK60_PHSEL_SHIFT | 4<<UTMI_TX_IMPCAL_VTH_SHIFT
+		| 8<<UTMI_TX_REG_EXT_FS_RCAL_SHIFT | 3<<UTMI_TX_AMP_SHIFT);
+
+	/* UTMI_RX */
+	u2o_clear(base, UTMI_RX, UTMI_RX_SQ_THRESH_MASK
+		| UTMI_REG_SQ_LENGTH_MASK);
+	u2o_set(base, UTMI_RX, 7<<UTMI_RX_SQ_THRESH_SHIFT
+		| 2<<UTMI_REG_SQ_LENGTH_SHIFT);
+
+	/* UTMI_IVREF */
+	if (cpu_is_pxa168())
+		/* fixing Microsoft Altair board interface with NEC hub issue -
+		 * Set UTMI_IVREF from 0x4a3 to 0x4bf */
+		u2o_write(base, UTMI_IVREF, 0x4bf);
+
+	/* toggle VCOCAL_START bit of UTMI_PLL */
+	udelay(200);
+	u2o_set(base, UTMI_PLL, VCOCAL_START);
+	udelay(40);
+	u2o_clear(base, UTMI_PLL, VCOCAL_START);
+
+	/* toggle REG_RCAL_START bit of UTMI_TX */
+	udelay(400);
+	u2o_set(base, UTMI_TX, REG_RCAL_START);
+	udelay(40);
+	u2o_clear(base, UTMI_TX, REG_RCAL_START);
+	udelay(400);
+
+	/* Make sure PHY PLL is ready */
+	loops = 0;
+	while ((u2o_get(base, UTMI_PLL) & PLL_READY) == 0) {
+		mdelay(1);
+		loops++;
+		if (loops > 100) {
+			printk(KERN_WARNING "calibrate timeout, UTMI_PLL %x\n",
+				u2o_get(base, UTMI_PLL));
+			break;
+		}
+	}
+
+	if (cpu_is_pxa168()) {
+		u2o_set(base, UTMI_RESERVE, 1 << 5);
+		/* Turn on UTMI PHY OTG extension */
+		u2o_write(base, UTMI_OTG_ADDON, 1);
+	}
+
+	return 0;
+}
+
+static int usb_phy_deinit_internal(void __iomem *base)
+{
+	pr_info("Deinit usb phy!!!\n");
+
+	if (cpu_is_pxa168())
+		u2o_clear(base, UTMI_OTG_ADDON, UTMI_OTG_ADDON_OTG_ON);
+
+	u2o_clear(base, UTMI_CTRL, UTMI_CTRL_RXBUF_PDWN);
+	u2o_clear(base, UTMI_CTRL, UTMI_CTRL_TXBUF_PDWN);
+	u2o_clear(base, UTMI_CTRL, UTMI_CTRL_USB_CLK_EN);
+	u2o_clear(base, UTMI_CTRL, 1<<UTMI_CTRL_PWR_UP_SHIFT);
+	u2o_clear(base, UTMI_CTRL, 1<<UTMI_CTRL_PLL_PWR_UP_SHIFT);
+
+	return 0;
+}
+
+int pxa_usb_phy_init(void __iomem *phy_reg)
+{
+	mutex_lock(&phy_lock);
+	if (phy_init_cnt++ == 0)
+		usb_phy_init_internal(phy_reg);
+	mutex_unlock(&phy_lock);
+	return 0;
+}
+
+void pxa_usb_phy_deinit(void __iomem *phy_reg)
+{
+	WARN_ON(phy_init_cnt == 0);
+
+	mutex_lock(&phy_lock);
+	if (--phy_init_cnt == 0)
+		usb_phy_deinit_internal(phy_reg);
+	mutex_unlock(&phy_lock);
+}
+#endif
+#endif
+#endif
+
+#if (defined(CONFIG_USB_SUPPORT) && !defined(CONFIG_CPU_PXA988) && !defined(CONFIG_CPU_PXA1088))
+static u64 usb_dma_mask = ~(u32)0;
+
+#ifdef CONFIG_USB_MV_UDC
+struct resource pxa168_u2o_resources[] = {
+	/* regbase */
+	[0] = {
+		.start	= PXA168_U2O_REGBASE + U2x_CAPREGS_OFFSET,
+		.end	= PXA168_U2O_REGBASE + USB_REG_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= PXA168_U2O_PHYBASE,
+		.end	= PXA168_U2O_PHYBASE + USB_PHY_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_PXA168_USB1,
+		.end	= IRQ_PXA168_USB1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa168_device_u2o = {
+	.name		= "mv-udc",
+	.id		= -1,
+	.resource	= pxa168_u2o_resources,
+	.num_resources	= ARRAY_SIZE(pxa168_u2o_resources),
+	.dev		=  {
+		.dma_mask	= &usb_dma_mask,
+		.coherent_dma_mask = 0xffffffff,
+	}
+};
+#endif /* CONFIG_USB_MV_UDC */
+
+#ifdef CONFIG_USB_EHCI_MV_U2O
+struct resource pxa168_u2oehci_resources[] = {
+	/* regbase */
+	[0] = {
+		.start	= PXA168_U2O_REGBASE + U2x_CAPREGS_OFFSET,
+		.end	= PXA168_U2O_REGBASE + USB_REG_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= PXA168_U2O_PHYBASE,
+		.end	= PXA168_U2O_PHYBASE + USB_PHY_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_PXA168_USB1,
+		.end	= IRQ_PXA168_USB1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa168_device_u2oehci = {
+	.name		= "pxa-u2oehci",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &usb_dma_mask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+
+	.num_resources	= ARRAY_SIZE(pxa168_u2oehci_resources),
+	.resource	= pxa168_u2oehci_resources,
+};
+#endif
+
+#if defined(CONFIG_USB_MV_OTG)
+struct resource pxa168_u2ootg_resources[] = {
+	/* regbase */
+	[0] = {
+		.start	= PXA168_U2O_REGBASE + U2x_CAPREGS_OFFSET,
+		.end	= PXA168_U2O_REGBASE + USB_REG_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= PXA168_U2O_PHYBASE,
+		.end	= PXA168_U2O_PHYBASE + USB_PHY_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_PXA168_USB1,
+		.end	= IRQ_PXA168_USB1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa168_device_u2ootg = {
+	.name		= "mv-otg",
+	.id		= -1,
+	.dev  = {
+		.dma_mask          = &usb_dma_mask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+
+	.num_resources	= ARRAY_SIZE(pxa168_u2ootg_resources),
+	.resource      = pxa168_u2ootg_resources,
+};
+#endif /* CONFIG_USB_MV_OTG */
+
+#endif
+
+#ifdef CONFIG_UIO_CODA7542
+static u64 pxa_coda7542_dam_mask = DMA_BIT_MASK(32);
+static struct resource pxa_coda7542_resources[] = {
+	[0] = {
+		.start = 0xD420D000,
+		.end   = 0xD420DFFF,
+		.flags = IORESOURCE_MEM,
+	},
+#ifndef CONFIG_CPU_PXA1088
+	[1] = {
+		.start = SRAM_VIDEO_BASE,
+		.end   = SRAM_VIDEO_BASE + SRAM_VIDEO_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+#endif
+	[2] = {
+		.start = IRQ_PXA988_CODA7542,
+		.end   = IRQ_PXA988_CODA7542,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa_device_coda7542 = {
+	.name		= UIO_CODA7542_NAME,
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &pxa_coda7542_dam_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource	= pxa_coda7542_resources,
+	.num_resources	= ARRAY_SIZE(pxa_coda7542_resources),
+};
+
+void __init pxa_register_coda7542(void)
+{
+	int ret;
+
+	ret = platform_device_register(&pxa_device_coda7542);
+	if (ret)
+		dev_err(&(pxa_device_coda7542.dev),
+			"unable to register coda7542 device: %d\n", ret);
+}
+
+#endif
+
+#ifdef CONFIG_UIO_HANTRO
+static u64 pxa_hantro_dam_mask = DMA_BIT_MASK(32);
+/* decoder resources */
+static struct resource pxa_hantro_dec_resources[] = {
+	[0] = {
+		.start = 0xF0400000,
+		.end   = 0xF04007FF,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_EDEN_VPU,
+		.end   = IRQ_EDEN_VPU,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/* post processor resources */
+static struct resource pxa_hantro_pp_resources[] = {
+	[0] = {
+		.start = 0xF0400000,
+		.end   = 0xF04007FF,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_EDEN_VPU,
+		.end   = IRQ_EDEN_VPU,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/* encoder resources */
+static struct resource pxa_hantro_enc_resources[] = {
+	[0] = {
+		.start = 0xF0400800,
+		.end   = 0xF07FFFFF,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_EDEN_VPU,
+		.end   = IRQ_EDEN_VPU,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa_device_hantro[] = {
+/* decoder */
+	{
+		.name		= UIO_HANTRO_NAME,
+		.id		= HANTRO_DEC,
+		.dev		= {
+			.dma_mask = &pxa_hantro_dam_mask,
+			.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+		.resource	= pxa_hantro_dec_resources,
+		.num_resources	= ARRAY_SIZE(pxa_hantro_dec_resources),
+	},
+/* post processor */
+	{
+		.name		= UIO_HANTRO_NAME,
+		.id		= HANTRO_PP,
+		.dev		= {
+			.dma_mask = &pxa_hantro_dam_mask,
+			.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+		.resource	= pxa_hantro_pp_resources,
+		.num_resources	= ARRAY_SIZE(pxa_hantro_pp_resources),
+	},
+/* encoder */
+	{
+		.name		= UIO_HANTRO_NAME,
+		.id		= HANTRO_ENC,
+		.dev		= {
+			.dma_mask = &pxa_hantro_dam_mask,
+			.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+		.resource	= pxa_hantro_enc_resources,
+		.num_resources	= ARRAY_SIZE(pxa_hantro_enc_resources),
+	},
+};
+
+void __init pxa_register_hantro(void)
+{
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(pxa_device_hantro); i++) {
+		ret = platform_device_register(&pxa_device_hantro[i]);
+		if (ret)
+			dev_err(&(pxa_device_hantro[i].dev),
+			"unable to register hantro device: %d\n", i);
+	}
+}
+#endif
diff --git a/arch/arm/mach-mmp/dvfs-pxa988.c b/arch/arm/mach-mmp/dvfs-pxa988.c
new file mode 100644
index 00000000..ed4ba942
--- /dev/null
+++ b/arch/arm/mach-mmp/dvfs-pxa988.c
@@ -0,0 +1,2039 @@
+/*
+ *  linux/arch/arm/mach-mmp/dvfs-pxa988.c
+ *
+ *  based on arch/arm/mach-tegra/tegra2_dvfs.c
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#if defined(CONFIG_MFD_88PM822)
+#include <linux/mfd/88pm822.h>
+#elif defined(CONFIG_MFD_88PM800)
+#include <linux/mfd/88pm80x.h>
+#endif
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <mach/regs-mpmu.h>
+#include <mach/cputype.h>
+#include <mach/clock-pxa988.h>
+#include <mach/dvfs.h>
+#include <mach/features.h>
+#include <plat/clock.h>
+#include <plat/debugfs.h>
+#include "common.h"
+
+#if defined(CONFIG_MFD_88PM822)
+#define BUCK1_AP_ACTIVE		PM822_ID_BUCK1_AP_ACTIVE
+#define BUCK1_AP_LPM		PM822_ID_BUCK1_AP_LPM
+#define BUCK1_APSUB_IDLE	PM822_ID_BUCK1_APSUB_IDLE
+#define BUCK1_APSUB_SLEEP	PM822_ID_BUCK1_APSUB_SLEEP
+#elif defined(CONFIG_MFD_88PM800)
+#define BUCK1_AP_ACTIVE		PM800_ID_BUCK1_AP_ACTIVE
+#define BUCK1_AP_LPM		PM800_ID_BUCK1_AP_LPM
+#define BUCK1_APSUB_IDLE	PM800_ID_BUCK1_APSUB_IDLE
+#define BUCK1_APSUB_SLEEP	PM800_ID_BUCK1_APSUB_SLEEP
+#else /* CONFIG_MFD_D2199 */
+#define BUCK1_AP_ACTIVE		D2199_ID_BUCK1_AP_ACTIVE
+#define BUCK1_AP_LPM		D2199_ID_BUCK1_AP_LPM
+#define BUCK1_APSUB_IDLE	D2199_ID_BUCK1_APSUB_IDLE
+#define BUCK1_APSUB_SLEEP	D2199_ID_BUCK1_APSUB_SLEEP
+#endif
+
+#if defined(CONFIG_D2199_DVC)
+#include <linux/d2199/core.h>
+#include <linux/d2199/pmic.h>
+#endif
+#ifdef CONFIG_MACH_WILCOX_CMCC
+#define BOARD_ID_CMCC_REV05 (0x7)
+#endif
+/*
+ * for PMU DVC, the GPIO pins are switched or not
+ * 1 - switched
+ * 0 - not switched
+ * set it as 1 by default
+ */
+#if defined(CONFIG_MFD_D2199)
+static int dvc_pin_switch = 0;
+#else
+static int dvc_pin_switch = 1;
+#endif
+
+int dvc_flag = 1;
+EXPORT_SYMBOL(dvc_flag);
+
+#if defined(CONFIG_MFD_D2199)	// DLG
+#define D2199_DVFS
+#define dlg_trace(fmt, ...) printk(KERN_INFO "[WS][DVFS][%s]-"fmt, __func__, ##__VA_ARGS__)
+
+extern int d2199_dvfs_get_voltage(int reg_addr);
+extern int d2199_dvfs_set_voltage(int reg_addr, unsigned int reg_val);
+
+#else
+#define dlg_trace(fmt, ...) 	do { } while(0);
+#endif
+static int __init dvc_flag_setup(char *str)
+{
+	int n;
+
+	dlg_trace("str : %s\n", str);
+
+	if (!get_option(&str, &n))
+		return 0;
+	dvc_flag = n;
+	return 1;
+}
+__setup("dvc_flag=", dvc_flag_setup);
+
+enum {
+	CORE = 0,
+	DDR_AXI,
+	GC,
+#ifdef CONFIG_CPU_PXA1088
+	GC2D,
+	ISP,
+#endif
+	VPU,
+	VM_RAIL_MAX,
+};
+
+/*
+ * NOTES: DVC is used to change voltage, currently use max
+ * voltage lvl 4, could add if has requirement
+ */
+enum {
+	VL0 = 0,
+	VL1,
+	VL2,
+	VL3,
+	VL_MAX,
+};
+
+#define KHZ_TO_HZ	1000
+#define PROFILE_NUM	9
+
+#define MAX_RAIL_NUM	4
+struct dvfs_rail_component {
+	const char *clk_name;
+	bool auto_dvfs;
+	const int *millivolts;
+	struct dvfs_rail *dvfs_rail;
+	unsigned int freqs_mult;
+	unsigned long *freqs;
+	/* used to save related clk_node and dvfs ptr */
+	struct clk *clk_node;
+	struct dvfs *dvfs;
+};
+
+enum {
+	DVC_AP,
+	DVC_CP,
+	DVC_DP,
+	DVC_APSUB,
+	DVC_CHIP,
+	DVC_END,
+};
+
+enum {
+	LEVEL_START,
+	LEVEL0,
+	LEVEL1,
+	LEVEL2,
+	LEVEL3,
+	LEVEL4,
+	LEVEL5,
+	LEVEL6,
+	LEVEL7,
+	LEVEL0_1, /* LEVEL0_x is used to replace level 0 */
+	LEVEL0_2,
+	LEVEL_END,
+};
+
+enum {
+	AP_ACTIVE,
+	AP_LPM,
+	APSUB_IDLE,
+	APSUB_SLEEP,
+};
+
+struct dvc_reg {
+	void __iomem *reg;
+	int offset_H;	/* offset of the high bits voltage */
+	int mask_H;	/* mask of the high bits voltage */
+	int offset_L;	/* offset of the low bits voltage */
+	int mask_L;	/* mask of the low bits voltage */
+	int offset_trig;/* The offset of triggering voltage change */
+	int allow_ap;	/* Whether allow AP to set this register */
+};
+
+struct voltage_item {
+	int volt_level_H; /* Active voltage or High bits voltage level */
+	int volt_level_L; /* Low power mode voltage or low bits voltage level */
+};
+
+#define INIT_DVFS(_clk_name, _auto, _rail, _millivolts,  _freqs)	\
+	{								\
+		.clk_name	= _clk_name,				\
+		.auto_dvfs	= _auto,				\
+		.millivolts	= _millivolts,				\
+		.freqs_mult	= KHZ_TO_HZ,				\
+		.dvfs_rail	= _rail,				\
+		.freqs		= _freqs,				\
+	}
+
+int *vm_millivolts;
+/* voltage tbl is sort ascending, it's default setting */
+#ifdef D2199_DVFS	// DLG DVFS
+static int vm_millivolts_default[VL_MAX] = {
+	1300, 1300, 1350, 1400,
+
+};
+#else
+static int vm_millivolts_default[VL_MAX] = {
+	1300, 1300, 1350, 1400,
+};
+#endif
+
+static int vm_millivolts_z1z2[VL_MAX] = {
+	1300, 1300, 1300
+};
+
+/* 988 Z3 SVC table */
+static int vm_millivolts_988z3_svc[PROFILE_NUM][VL_MAX] = {
+	/* PP <= 312, PP<=624, PP<=1066, PP<=1205 */
+	{1150, 1150, 1350, 1400},	/* profile 0 */
+	{1150, 1150, 1275, 1275},	/* profile 1 */
+	{1150, 1150, 1300, 1300},	/* profile 2 */
+	{1150, 1150, 1325, 1325},	/* profile 3 */
+	{1150, 1150, 1325, 1350},	/* profile 4 */  // --> TEST for 4 leves
+	{1150, 1150, 1325, 1375},	/* profile 5 */
+	{1150, 1150, 1325, 1400},	/* profile 6 */
+	{1150, 1150, 1325, 1400},	/* profile 7 */
+	{1150, 1150, 1350, 1400},	/* profile 8 */
+};
+
+/* 986 Z3 SVC table, as CP runs at 624M, higher than 988 416M */
+static int vm_millivolts_986z3_svc[PROFILE_NUM][VL_MAX] = {
+	/* PP <= 312, PP<=624, PP<=1066, PP<=1205 */
+	{1300, 1300, 1350, 1400},	/* profile 0 */
+	{1300, 1300, 1300, 1300},	/* profile 1 */
+	{1300, 1300, 1300, 1300},	/* profile 2 */
+	{1300, 1300, 1325, 1325},	/* profile 3 */
+	{1300, 1300, 1325, 1350},	/* profile 4 */
+	{1300, 1300, 1325, 1375},	/* profile 5 */
+	{1300, 1300, 1325, 1400},	/* profile 6 */
+	{1300, 1300, 1325, 1400},	/* profile 7 */
+	{1300, 1300, 1350, 1400},	/* profile 8 */
+};
+
+/* 988 Ax SVC table, CP 416M vote VL1 */
+static int vm_millivolts_988ax_svc[PROFILE_NUM][VL_MAX] = {
+	{1025, 1138, 1275, 1350},	/* profile 0 */
+	{1025, 1100, 1100, 1188},	/* profile 1 */
+	{1025, 1100, 1113, 1200},	/* profile 2 */
+	{1025, 1100, 1138, 1213},	/* profile 3 */
+	{1025, 1100, 1150, 1238},	/* profile 4 */
+	{1025, 1100, 1175, 1263},	/* profile 5 */
+	{1025, 1100, 1200, 1288},	/* profile 6 */
+	{1025, 1138, 1225, 1313},	/* profile 7 */
+	{1025, 1138, 1275, 1350},	/* profile 8 */
+};
+
+/* 986 Ax SVC table, CP 624M vote VL2 */
+static int vm_millivolts_986ax_svc[PROFILE_NUM][VL_MAX] = {
+	{1025, 1138, 1275, 1350},	/* profile 0 */
+	{1025, 1100, 1100, 1188},	/* profile 1 */
+	{1025, 1100, 1113, 1200},	/* profile 2 */
+	{1025, 1100, 1138, 1213},	/* profile 3 */
+	{1025, 1100, 1150, 1238},	/* profile 4 */
+	{1025, 1100, 1175, 1263},	/* profile 5 */
+	{1025, 1100, 1200, 1288},	/* profile 6 */
+	{1025, 1138, 1225, 1313},	/* profile 7 */
+	{1025, 1138, 1275, 1350},	/* profile 8 */
+};
+
+/* 988 Ax 1p5G SVC table, CP 416M vote VL1 */
+static int vm_millivolts_988ax_svc_1p5G[PROFILE_NUM][VL_MAX] = {
+	{1025, 1138, 1275, 1375},	/* profile 0 */
+	{1025, 1100, 1100, 1288},	/* profile 1 */
+	{1025, 1100, 1113, 1325},	/* profile 2 */
+	{1025, 1100, 1138, 1363},	/* profile 3 */
+	{1025, 1100, 1150, 1375},	/* profile 4 */
+	{1025, 1100, 1175, 1375},	/* profile 5 */
+	{1025, 1100, 1200, 1375},	/* profile 6 */
+	{1025, 1138, 1225, 1375},	/* profile 7 */
+	{1025, 1138, 1275, 1375},	/* profile 8 */
+};
+
+/* FIXME: hard coding svc of 986ax for harrison bringup*/
+static int vm_millivolts_986ax_1v4_svc[PROFILE_NUM][VL_MAX] = {
+    {1400, 1400, 1400, 1400},   /* profile 0 */
+    {1400, 1400, 1400, 1400},   /* profile 1 */
+    {1400, 1400, 1400, 1400},   /* profile 2 */
+    {1400, 1400, 1400, 1400},   /* profile 3 */
+    {1400, 1400, 1400, 1400},   /* profile 4 */
+    {1400, 1400, 1400, 1400},   /* profile 5 */
+    {1400, 1400, 1400, 1400},   /* profile 6 */
+    {1400, 1400, 1400, 1400},   /* profile 7 */
+    {1400, 1400, 1400, 1400},   /* profile 8 */
+};
+
+#if !defined(CONFIG_CORE_1248)
+/* 986 Ax 1p5G table, CP 624M vote VL2 */
+static int vm_millivolts_986ax_svc_1p5G[PROFILE_NUM][VL_MAX] = {
+	{1025, 1138, 1275, 1375},	/* profile 0 */
+	{1025, 1100, 1100, 1288},	/* profile 1 */
+	{1025, 1100, 1113, 1325},	/* profile 2 */
+	{1025, 1100, 1138, 1363},	/* profile 3 */
+	{1025, 1100, 1150, 1375},	/* profile 4 */
+	{1025, 1100, 1175, 1375},	/* profile 5 */
+	{1025, 1100, 1200, 1375},	/* profile 6 */
+	{1025, 1138, 1225, 1375},	/* profile 7 */
+	{1025, 1138, 1275, 1375},	/* profile 8 */
+};
+#else
+/* 986 Ax 1p5G table, CP 624M vote VL2 */
+static int vm_millivolts_986ax_svc_1p5G[PROFILE_NUM][VL_MAX] = {
+	{1025, 1138, 1275, 1400},	/* profile 0 */
+	{1025, 1100, 1100, 1188},	/* profile 1 */
+	{1025, 1100, 1113, 1213},	/* profile 2 */
+	{1025, 1100, 1138, 1238},	/* profile 3 */
+	{1025, 1100, 1150, 1263},	/* profile 4 */
+	{1025, 1100, 1175, 1300},	/* profile 5 */
+	{1025, 1100, 1200, 1338},	/* profile 6 */
+	{1025, 1138, 1225, 1363},	/* profile 7 */
+	{1025, 1138, 1275, 1400},	/* profile 8 */
+};
+#endif
+/*
+ * 1088 SVC table
+ */
+static int vm_mv_1088a0_svc_1p1G[PROFILE_NUM][VL_MAX] = {
+	{1000, 1075, 1300, 1375},	/* profile 0 */
+	{1000, 1075, 1100, 1138},	/* profile 1 */
+	{1000, 1075, 1100, 1175},	/* profile 2 */
+	{1000, 1075, 1125, 1225},	/* profile 3 */
+	{1000, 1075, 1163, 1238},	/* profile 4 */
+	{1000, 1075, 1200, 1275},	/* profile 5 */
+	{1000, 1075, 1238, 1325},	/* profile 6 */
+	{1000, 1075, 1275, 1350},	/* profile 7 */
+	{1000, 1075, 1300, 1375},	/* profile 8 */
+};
+
+static int vm_mv_1088a0_svc_1p2G[PROFILE_NUM][VL_MAX] = {
+	{1000, 1075, 1300, 1375},	/* profile 0 */
+	{1000, 1075, 1100, 1200},	/* profile 1 */
+	{1000, 1075, 1100, 1200},	/* profile 2 */
+	{1000, 1075, 1125, 1238},	/* profile 3 */
+	{1000, 1075, 1163, 1288},	/* profile 4 */
+	{1000, 1075, 1200, 1325},	/* profile 5 */
+	{1000, 1075, 1238, 1363},	/* profile 6 */
+	{1000, 1075, 1275, 1375},	/* profile 7 */
+	{1000, 1075, 1300, 1375},	/* profile 8 */
+};
+
+static int vm_mv_1088a0_svc_1p3G[PROFILE_NUM][VL_MAX] = {
+	{1000, 1075, 1300, 1375},	/* profile 0 */
+	{1000, 1075, 1100, 1238},	/* profile 1 */
+	{1000, 1075, 1100, 1288},	/* profile 2 */
+	{1000, 1075, 1125, 1338},	/* profile 3 */
+	{1000, 1075, 1163, 1375},	/* profile 4 */
+	{1000, 1075, 1200, 1375},	/* profile 5 */
+	{1000, 1075, 1238, 1375},	/* profile 6 */
+	{1000, 1075, 1275, 1375},	/* profile 7 */
+	{1000, 1075, 1300, 1375},	/* profile 8 */
+};
+
+static int vm_mv_1088a1_svc_1p1G[PROFILE_NUM][VL_MAX] = {
+	{1025, 1075, 1250, 1375},	/* profile 0 */
+	{1025, 1075, 1150, 1138},	/* profile 1 */
+	{1025, 1075, 1150, 1175},	/* profile 2 */
+	{1025, 1075, 1150, 1213},	/* profile 3 */
+	{1025, 1075, 1150, 1263},	/* profile 4 */
+	{1025, 1075, 1150, 1300},	/* profile 5 */
+	{1025, 1075, 1188, 1338},	/* profile 6 */
+	{1025, 1075, 1225, 1375},	/* profile 7 */
+	{1025, 1075, 1250, 1375},	/* profile 8 */
+};
+
+static int vm_mv_1088a1_svc_1p2G[PROFILE_NUM][VL_MAX] = {
+	{1075, 1075, 1250, 1375},	/* profile 0 */
+	{1075, 1075, 1100, 1225},	/* profile 1 */
+	{1075, 1075, 1100, 1225},	/* profile 2 */
+	{1075, 1075, 1100, 1238},	/* profile 3 */
+	{1075, 1075, 1125, 1288},	/* profile 4 */
+	{1075, 1075, 1150, 1325},	/* profile 5 */
+	{1075, 1075, 1188, 1363},	/* profile 6 */
+	{1075, 1075, 1225, 1375},	/* profile 7 */
+	{1075, 1075, 1250, 1375},	/* profile 8 */
+};
+static int vm_mv_1088a1_svc_1p3G[PROFILE_NUM][VL_MAX] = {
+	{1025, 1075, 1250, 1375},	/* profile 0 */
+	{1025, 1075, 1100, 1238},	/* profile 1 */
+	{1025, 1075, 1100, 1288},	/* profile 2 */
+	{1025, 1075, 1100, 1338},	/* profile 3 */
+	{1025, 1075, 1125, 1375},	/* profile 4 */
+	{1025, 1075, 1150, 1375},	/* profile 5 */
+	{1025, 1075, 1188, 1375},	/* profile 6 */
+	{1025, 1075, 1225, 1375},	/* profile 7 */
+	{1025, 1075, 1250, 1375},	/* profile 8 */
+};
+
+/* ptr used for components' freqs combination */
+static unsigned long (*component_freqs)[VL_MAX];
+
+/************************* GPIO DVC **************************/
+/*
+ * NOTES: we set step to 500mV here as we don't want
+ * voltage change step by step, as GPIO based DVC is
+ * used. This can avoid tmp voltage which is not in saved
+ * in 4 level regulator table.
+ */
+static struct dvfs_rail pxa988_dvfs_rail_vm = {
+	.reg_id = "vcc_main",
+	.max_millivolts = 1400,
+	.min_millivolts = 1000,
+	.nominal_millivolts = 1200,
+	.step = 500,
+};
+
+static unsigned long freqs_cmb_z1z2[VM_RAIL_MAX][VL_MAX] = {
+	{ 600000, 800000, 1200000 },	/* CORE */
+	{ 300000, 400000, 400000 },	/* DDR/AXI */
+	{ 600000, 600000, 600000 },	/* GC */
+	{ 400000, 400000, 400000 }	/* VPU */
+};
+
+static struct dvfs_rail_component *vm_rail_comp_tbl;
+static struct dvfs_rail_component vm_rail_comp_tbl_z1z2[VM_RAIL_MAX] = {
+	INIT_DVFS("cpu", true, &pxa988_dvfs_rail_vm, NULL,
+		  freqs_cmb_z1z2[CORE]),
+	INIT_DVFS("ddr", true, &pxa988_dvfs_rail_vm, NULL,
+		  freqs_cmb_z1z2[DDR_AXI]),
+	INIT_DVFS("GCCLK", false, &pxa988_dvfs_rail_vm, NULL,
+		  freqs_cmb_z1z2[GC]),
+	INIT_DVFS("VPUCLK", false, &pxa988_dvfs_rail_vm, NULL,
+		  freqs_cmb_z1z2[VPU]),
+};
+
+static unsigned long freqs_cmb_z3[VM_RAIL_MAX][VL_MAX] = {
+	{ 312000, 624000, 1066000, 1205000 },	/* CORE */
+	{ 312000, 312000, 533000, 533000 },	/* DDR/AXI */
+	{ 0	, 416000, 624000, 624000 },	/* GC */
+	{ 208000, 312000, 416000, 416000 }	/* VPU */
+};
+
+static unsigned long freqs_cmb_ax[VM_RAIL_MAX][VL_MAX] = {
+	{ 624000, 624000, 1066000, 1482000 },	/* CORE */
+	{ 312000, 312000, 312000, 533000 },	/* DDR/AXI */
+	{ 0, 416000, 624000, 624000 },	/* GC */
+	{ 0, 312000, 416000, 416000 }	/* VPU */
+};
+
+static unsigned long freqs_cmb_1088a0[VM_RAIL_MAX][VL_MAX] = {
+	{ 312000, 312000, 1066000, 1300000 },	/* CORE */
+	{ 156000, 156000, 312000, 533000 },	/* DDR/AXI */
+	{ 0, 416000, 624000, 624000 },		/* GC */
+#ifdef	CONFIG_CPU_PXA1088
+	{ 0, 312000, 416000, 624000 },		/* GC2D */
+	{ 312000, 416000, 416000, 416000 },	/* ISP */
+#endif
+	{ 0, 312000, 416000, 624000 }		/* VPU */
+};
+
+static unsigned long freqs_cmb_1088a1[VM_RAIL_MAX][VL_MAX] = {
+	{ 312000, 312000, 800000, 1300000 },	/* CORE */
+	{ 156000, 312000, 400000, 533000 },	/* DDR/AXI */
+	{ 0, 416000, 416000, 624000 },		/* GC */
+#ifdef	CONFIG_CPU_PXA1088
+	{ 0, 312000, 416000, 416000 },		/* GC2D */
+	{ 312000, 416000, 416000, 416000 },	/* ISP */
+#endif
+	{ 0, 312000, 416000, 416000 }		/* VPU */
+};
+
+static struct dvfs_rail_component vm_rail_comp_tbl_gpiodvc[VM_RAIL_MAX] = {
+	INIT_DVFS("cpu", true, &pxa988_dvfs_rail_vm, NULL, NULL),
+	INIT_DVFS("ddr", true, &pxa988_dvfs_rail_vm, NULL, NULL),
+	INIT_DVFS("GCCLK", true, &pxa988_dvfs_rail_vm, NULL, NULL),
+#ifdef CONFIG_CPU_PXA1088
+	INIT_DVFS("GC2DCLK", true,  &pxa988_dvfs_rail_vm, NULL, NULL),
+	INIT_DVFS("ISP-CLK", true,  &pxa988_dvfs_rail_vm, NULL, NULL),
+#endif
+	INIT_DVFS("VPUCLK", true, &pxa988_dvfs_rail_vm, NULL, NULL),
+};
+
+/************************* PMU DVC **************************/
+/* default CP/MSA required PMU DVC VL */
+static unsigned int cp_pmudvc_lvl = VL1;
+static unsigned int msa_pmudvc_lvl = VL1;
+
+/* Rails for pmu dvc */
+static struct dvfs_rail pxa988_dvfs_rail_ap_active = {
+	.reg_id = "vcc_main_ap_active",
+	.max_millivolts = LEVEL3,
+	.min_millivolts = LEVEL0,
+	.nominal_millivolts = LEVEL_START,
+	.step = 0xFF,
+};
+
+static struct dvfs_rail pxa988_dvfs_rail_ap_lpm = {
+	.reg_id = "vcc_main_ap_lpm",
+	.max_millivolts = LEVEL3,
+	.min_millivolts = LEVEL0,
+	.nominal_millivolts = LEVEL_START,
+	.step = 0xFF,
+};
+
+static struct dvfs_rail pxa988_dvfs_rail_apsub_idle = {
+	.reg_id = "vcc_main_apsub_idle",
+	.max_millivolts = LEVEL3,
+	.min_millivolts = LEVEL0,
+	.nominal_millivolts = LEVEL_START,
+	.step = 0xFF,
+};
+
+static struct dvfs_rail pxa988_dvfs_rail_apsub_sleep = {
+	.reg_id = "vcc_main_apsub_sleep",
+	.max_millivolts = LEVEL3,
+	.min_millivolts = LEVEL0,
+	.nominal_millivolts = LEVEL_START,
+	.step = 0xFF,
+};
+
+static struct dvfs_rail *pxa988_dvfs_rails_pmudvc[] = {
+	&pxa988_dvfs_rail_ap_active,
+	&pxa988_dvfs_rail_ap_lpm,
+	&pxa988_dvfs_rail_apsub_idle,
+	&pxa988_dvfs_rail_apsub_sleep,
+};
+
+/* component_voltage table and component_freqs combination is dynamic inited */
+static int component_voltage[][MAX_RAIL_NUM][LEVEL_END] = {
+	[CORE] = {
+	},
+	[DDR_AXI] = {
+	},
+	[GC] = {
+	},
+#ifdef	CONFIG_CPU_PXA1088
+	[GC2D] = {
+	},
+	[ISP] = {
+	},
+#endif
+	[VPU] = {
+	},
+};
+
+/* PMU DVC freq-combination to dynamic filled to support different platform */
+static struct dvfs_rail_component vm_rail_ap_active_tbl[VM_RAIL_MAX] = {
+	INIT_DVFS("cpu", true, &pxa988_dvfs_rail_ap_active,
+		component_voltage[CORE][AP_ACTIVE], NULL),
+	INIT_DVFS("ddr", true, &pxa988_dvfs_rail_ap_active,
+		component_voltage[DDR_AXI][AP_ACTIVE], NULL),
+	INIT_DVFS("GCCLK", true,  &pxa988_dvfs_rail_ap_active,
+		component_voltage[GC][AP_ACTIVE], NULL),
+#ifdef CONFIG_CPU_PXA1088
+	INIT_DVFS("GC2DCLK", true,  &pxa988_dvfs_rail_ap_active,
+		component_voltage[GC2D][AP_ACTIVE], NULL),
+	INIT_DVFS("ISP-CLK", true,  &pxa988_dvfs_rail_ap_active,
+		component_voltage[ISP][AP_ACTIVE], NULL),
+#endif
+	INIT_DVFS("VPUCLK", true, &pxa988_dvfs_rail_ap_active,
+		component_voltage[VPU][AP_ACTIVE], NULL),
+};
+
+static struct dvfs_rail_component vm_rail_ap_lpm_tbl[VM_RAIL_MAX] = {
+	INIT_DVFS("cpu", true, &pxa988_dvfs_rail_ap_lpm,
+		component_voltage[CORE][AP_LPM], NULL),
+	INIT_DVFS("ddr", true, &pxa988_dvfs_rail_ap_lpm,
+		component_voltage[DDR_AXI][AP_LPM], NULL),
+	INIT_DVFS("GCCLK", true, &pxa988_dvfs_rail_ap_lpm,
+		component_voltage[GC][AP_LPM], NULL),
+#ifdef CONFIG_CPU_PXA1088
+	INIT_DVFS("GC2DCLK", true,  &pxa988_dvfs_rail_ap_lpm,
+		component_voltage[GC2D][AP_LPM], NULL),
+	INIT_DVFS("ISP-CLK", true,  &pxa988_dvfs_rail_ap_lpm,
+		component_voltage[ISP][AP_LPM], NULL),
+#endif
+	INIT_DVFS("VPUCLK", true, &pxa988_dvfs_rail_ap_lpm,
+		component_voltage[VPU][AP_LPM], NULL),
+};
+
+static struct dvfs_rail_component vm_rail_apsub_idle_tbl[VM_RAIL_MAX] = {
+	INIT_DVFS("cpu", true, &pxa988_dvfs_rail_apsub_idle,
+		component_voltage[CORE][APSUB_IDLE], NULL),
+	INIT_DVFS("ddr", true, &pxa988_dvfs_rail_apsub_idle,
+		component_voltage[DDR_AXI][APSUB_IDLE], NULL),
+	INIT_DVFS("GCCLK", true, &pxa988_dvfs_rail_apsub_idle,
+		component_voltage[GC][APSUB_IDLE], NULL),
+#ifdef CONFIG_CPU_PXA1088
+	INIT_DVFS("GC2DCLK", true,  &pxa988_dvfs_rail_apsub_idle,
+		component_voltage[GC2D][APSUB_IDLE], NULL),
+	INIT_DVFS("ISP-CLK", true,  &pxa988_dvfs_rail_apsub_idle,
+		component_voltage[ISP][APSUB_IDLE], NULL),
+#endif
+	INIT_DVFS("VPUCLK", true, &pxa988_dvfs_rail_apsub_idle,
+		component_voltage[VPU][APSUB_IDLE], NULL),
+};
+
+static struct dvfs_rail_component vm_rail_apsub_sleep_tbl[VM_RAIL_MAX] = {
+	INIT_DVFS("cpu", true, &pxa988_dvfs_rail_apsub_sleep,
+		component_voltage[CORE][APSUB_SLEEP], NULL),
+	INIT_DVFS("ddr", true, &pxa988_dvfs_rail_apsub_sleep,
+		component_voltage[DDR_AXI][APSUB_SLEEP], NULL),
+	INIT_DVFS("GCCLK", true, &pxa988_dvfs_rail_apsub_sleep,
+		component_voltage[GC][APSUB_SLEEP], NULL),
+#ifdef CONFIG_CPU_PXA1088
+	INIT_DVFS("GC2DCLK", true,  &pxa988_dvfs_rail_apsub_sleep,
+		component_voltage[GC2D][APSUB_SLEEP], NULL),
+	INIT_DVFS("ISP-CLK", true,  &pxa988_dvfs_rail_apsub_sleep,
+		component_voltage[ISP][APSUB_SLEEP], NULL),
+#endif
+	INIT_DVFS("VPUCLK", true, &pxa988_dvfs_rail_apsub_sleep,
+		component_voltage[VPU][APSUB_SLEEP], NULL),
+};
+
+static struct dvfs_rail_component *dvfs_rail_component_list[] = {
+	vm_rail_ap_active_tbl,
+	vm_rail_ap_lpm_tbl,
+	vm_rail_apsub_idle_tbl,
+	vm_rail_apsub_sleep_tbl,
+};
+
+static void update_all_pmudvc_rails_info(void);
+
+static struct dvc_reg dvc_reg_table[DVC_END] = {
+	{
+		.reg = PMUM_DVC_AP,
+		.offset_H = 4,
+		.mask_H = 0x70,
+		.offset_L = 0,
+		.mask_L = 0x7,
+		.offset_trig = 7,
+		.allow_ap = 1,
+	},
+	{
+		.reg = PMUM_DVC_CP,
+		.offset_H = 4,
+		.mask_H = 0x70,
+		.offset_L = 0,
+		.mask_L = 0x7,
+		.offset_trig = 7,
+		.allow_ap = 0,
+	},
+	{
+		.reg = PMUM_DVC_DP,
+		.offset_H = 4,
+		.mask_H = 0x70,
+		.offset_L = 0,
+		.mask_L = 0x7,
+		.offset_trig = 7,
+		.allow_ap = 0,
+	},
+	{
+		.reg = PMUM_DVC_APSUB,
+		.offset_H = 8,
+		.mask_H = 0x700,
+		.offset_L = 0,
+		.mask_L = 0x7,
+		.allow_ap = 1,
+	},
+	{
+		.reg = PMUM_DVC_CHIP,
+		.offset_H = 4,
+		.mask_H = 0x70,
+		.offset_L = 0,
+		.mask_L = 0x7,
+		.allow_ap = 1,
+	},
+};
+
+#define PM800_BUCK1	(0x3C)
+static struct voltage_item current_volt_table[DVC_END];
+
+static inline int volt_to_reg(int millivolts)
+{
+	//dlg_trace("millivolts : %d, [%d]\n", millivolts, (millivolts - 600) * 100 / 625);
+#ifdef D2199_DVFS	// DLG DVFS
+	return (millivolts - 600) * 100 / 625;
+#else
+	return (millivolts - 600) * 10 / 125;
+#endif
+}
+
+static inline int reg_to_volt(int value)
+{
+	/* Round up to int value, eg, 1287.5 ==> 1288 */
+	//dlg_trace("value : %d, [%d]\n", value, (value * 625 + 60000 + 90) / 100);
+#ifdef D2199_DVFS	// DLG DVFS
+	return (value * 625 + 60000 + 90) / 100;
+#else
+	return (value * 125 + 6000 + 9) / 10;
+#endif
+}
+
+static inline int get_buck1_volt(int level)
+{
+#if defined(CONFIG_MFD_88PM822)
+	return pm822_extern_read(PM822_POWER_PAGE, PM822_BUCK1 + level);
+#elif defined(CONFIG_MFD_88PM800)
+	return pm800_extern_read(PM80X_POWER_PAGE, PM800_BUCK1 + level);
+#else /* CONFIG_MFD_D2199 */
+#ifdef D2199_DVFS
+#if defined(CONFIG_D2199_DVC)
+	return d2199_extern_dvc_read(level);
+#else
+	return d2199_dvfs_get_voltage(level);
+#endif /* CONFIG_D2199_DVC */
+#endif /* D2199_DVFS */
+#endif /* CONFIG_MFD_D2199 */
+}
+
+static inline int set_buck1_volt(int level, int val)
+{
+#if defined(CONFIG_MFD_88PM822)
+	return pm822_extern_write(PM822_POWER_PAGE, PM822_BUCK1 + level, val);
+#elif defined(CONFIG_MFD_88PM800)
+	return pm800_extern_write(PM80X_POWER_PAGE, PM800_BUCK1 + level, val);
+#else /* CONFIG_MFD_D2199 */
+#ifdef D2199_DVFS
+#if defined(CONFIG_D2199_DVC)
+	return d2199_extern_dvc_write(level, val);
+#else
+	return d2199_dvfs_set_voltage(level, val);
+#endif /* CONFIG_D2199_DVC */
+#endif /* D2199_DVFS */
+#endif /* CONFIG_MFD_D2199 */
+}
+
+static int get_stable_ticks(int millivolts1, int millivolts2)
+{
+	int max, min, ticks;
+	//dlg_trace("millivolts1[%d], millivolts2[%d]\n", millivolts1, millivolts2);
+
+	max = max(millivolts1, millivolts2);
+	min = min(millivolts1, millivolts2);
+	/*
+	 * clock is VCTCXO(26Mhz), 1us is 26 ticks
+	 * PMIC voltage change is 12.5mV/us
+	 * PMIC launch time is 8us(include 2us dvc pin sync time)
+	 * For safe consideration, add 2us in ramp up time
+	 * so the total latency is 10us
+	 */
+	ticks = ((max - min) * 10 / 125 + 10) * 26;
+	if (ticks > VLXX_ST_MASK)
+		ticks = VLXX_ST_MASK;
+
+	//dlg_trace("ticks[%d]\n", ticks);
+	return ticks;
+}
+
+static int stable_time_inited;
+
+/* Set PMIC voltage value of a specific level */
+static int set_voltage_value(int level, int value)
+{
+	unsigned int regval;
+	int ret = 0;
+	if (level < 0 || level > 3) {
+		printk(KERN_ERR "Wrong level! level should be between 0~3\n");
+		return -EINVAL;
+	}
+	regval = volt_to_reg(value);
+	//dlg_trace("level[%d], value[%d], regval[%d]\n", level, value, regval);
+
+	ret = set_buck1_volt(level, regval);
+	if (ret)
+		printk(KERN_ERR "PMIC voltage replacement failed!\n");
+	return ret;
+}
+
+/* Read PMIC to get voltage value according to level */
+static int get_voltage_value(int level)
+{
+	int reg, value;
+	if (level < 0 || level > 3) {
+		printk(KERN_ERR "Wrong level! level should be between 0~3\n");
+		return -EINVAL;
+	}
+	reg = get_buck1_volt(level);
+	if (reg < 0) {
+		printk(KERN_ERR "PMIC voltage reading failed !\n");
+		return -1;
+	}
+	value = reg_to_volt(reg);
+	dlg_trace("level[%d], value[%d]\n", level, value);
+	return value;
+}
+
+/* FIXME: add the real voltages here
+ * Note: the voltage should be indexed by LEVEL
+ * first value is useless, it is indexed by LEVEL_START
+ * Second value is LEVEL0, then LEVEL1, LEVEL2 ...
+ * Different level may have same voltage value
+*/
+static int voltage_millivolts[MAX_RAIL_NUM][LEVEL_END] = {
+	{ }, /* AP active voltages (in millivolts)*/
+	{ }, /* AP lpm voltages (in millivolts)*/
+	{ }, /* APSUB idle voltages (in millivolts)*/
+	{ }, /* APSUB sleep voltages (in millivolts)*/
+};
+
+
+
+/* pmu level to pmic level mapping
+ * Current setting:
+ * level 1 is mapped to level 1
+ * level 2 is mapped to level 2
+ * level 3~7 is mapped to level 3
+ * level 0 and level 0_x is mapped to level 0
+ */
+static int level_mapping[LEVEL_END];
+static void init_level_mapping(void)
+{
+	dlg_trace("\n");
+	level_mapping[LEVEL0] = 0;
+	level_mapping[LEVEL1] = 1;
+	level_mapping[LEVEL2] = 2;
+	level_mapping[LEVEL3] = 3;
+	level_mapping[LEVEL4] = 3;
+	level_mapping[LEVEL5] = 3;
+	level_mapping[LEVEL6] = 3;
+	level_mapping[LEVEL7] = 3;
+	level_mapping[LEVEL0_1] = 0;
+	level_mapping[LEVEL0_2] = 0;
+}
+
+#define PMIC_LEVEL_NUM	4
+static int cur_level_volt[PMIC_LEVEL_NUM];
+static int cur_volt_inited;
+/* Set a different level voltage according to the level value
+ * @level the actual level value that dvc wants to set.
+ * for example, if level == 4, and pmic only has level 0~3,
+ * it needs to replace one level with level4's voltage.
+*/
+static int replace_level_voltage(int buck_id, int *level)
+{
+	int value, ticks;
+	int pmic_level = level_mapping[*level];
+	int volt = voltage_millivolts[buck_id - BUCK1_AP_ACTIVE][*level];
+
+	//dlg_trace("buck_id[%d], level[%d], pmic_level[%d], volt[%d]\n", buck_id, *level, pmic_level, volt);
+	//dlg_trace("cur_volt_inited[%d], cur_level_volt[pmic_level][%d], volt[%d]\n",
+	//			cur_volt_inited, cur_level_volt[pmic_level], volt);
+
+#if defined(CONFIG_D2199_DVC)
+	if (cur_volt_inited) {
+#else
+	if (cur_volt_inited && (cur_level_volt[pmic_level] != volt)) {
+#endif
+		//dlg_trace("pmic_level[%d]\n", pmic_level);
+
+		set_voltage_value(pmic_level, volt);
+		pr_debug("Replace pmic level %d from %d -> %d!\n",
+			pmic_level, cur_level_volt[pmic_level], volt);
+		cur_level_volt[pmic_level] = volt;
+		/* Update voltage level change stable time */
+		if ((pmic_level == 0) || (pmic_level == 1)) {
+			value = __raw_readl(PMUM_VL01STR);
+			value &= ~VLXX_ST_MASK;
+			ticks = get_stable_ticks(cur_level_volt[0], cur_level_volt[1]);
+			value |= ticks;
+			__raw_writel(value, PMUM_VL01STR);
+		}
+
+		if ((pmic_level == 1) || (pmic_level == 2)) {
+			value = __raw_readl(PMUM_VL12STR);
+			value &= ~VLXX_ST_MASK;
+			ticks = get_stable_ticks(cur_level_volt[1], cur_level_volt[2]);
+			value |= ticks;
+			__raw_writel(value, PMUM_VL12STR);
+		}
+
+		if ((pmic_level == 2) || (pmic_level == 3)) {
+			value = __raw_readl(PMUM_VL23STR);
+			value &= ~VLXX_ST_MASK;
+			ticks = get_stable_ticks(cur_level_volt[2], cur_level_volt[3]);
+			value |= ticks;
+			__raw_writel(value, PMUM_VL23STR);
+		}
+	}
+
+	*level = pmic_level;
+	//dlg_trace("level[%d]\n", *level);
+	return 0;
+}
+
+#if defined(CONFIG_D2199_DVC)
+static int ramp_up_vol = 2500; /* unit : 100uV */
+int d2199_dvc_set_voltage(int buck_id, int level)
+{
+	unsigned int reg_val;
+	int reg_index = 0, high_bits; /* If this is high bits voltage */
+	static unsigned int pmic_vl_inited = 0;
+	static unsigned int lvl = 0;
+	/*
+	 * Max delay time, unit is us. : (ramp_up_vol / 12.5mv)
+	 * mode transition time = 18
+	 * add some buffer here = 4
+	 * default delay should be 0xFFFF * 1 tick(L2-->L3)
+	 */
+	int max_delay;
+	//dlg_trace("stable_time_inited[%d], buck_id[%d], level[%d]\n", stable_time_inited, buck_id, level);
+
+	/* updated lvl1 ~ lv3 during init stage */
+	if (unlikely(!pmic_vl_inited)) {
+		/* max vl to pmic leve 3 */
+		lvl = pxa988_get_vl_num() - 1;
+#if 1	// dlg
+		set_voltage_value(level_mapping[LEVEL3], pxa988_get_vl(lvl));
+		set_voltage_value(level_mapping[LEVEL1], pxa988_get_vl(1));
+		set_voltage_value(level_mapping[LEVEL2], pxa988_get_vl(2));
+#endif
+		pmic_vl_inited = 1;
+	}
+
+	if (stable_time_inited)
+		max_delay = ((ramp_up_vol / 125) + 18 + 4) * 1; /* pmic sync time may be accumulated */
+	else
+		max_delay = DIV_ROUND_UP(0xFFFF * 1, 26);
+
+	if ((buck_id < BUCK1_AP_ACTIVE) || (buck_id > BUCK1_APSUB_SLEEP)) {
+		printk(KERN_ERR "Not new dvc regulator, Can't use %s\n", __func__);
+		return 0;
+	}
+
+	replace_level_voltage(buck_id, &level);
+	//dlg_trace("buck_id[%d], level[%d]\n", buck_id, level);
+
+	if (buck_id == BUCK1_AP_ACTIVE) {
+		reg_index = DVC_AP;
+		high_bits = 1;
+	} else if (buck_id == BUCK1_AP_LPM) {
+		reg_index = DVC_AP;
+		high_bits = 0;
+	} else if (buck_id == BUCK1_APSUB_IDLE) {
+		reg_index = DVC_APSUB;
+		high_bits = 0;
+	} else if (buck_id == BUCK1_APSUB_SLEEP) {
+		reg_index = DVC_APSUB;
+		high_bits = 1;
+	}
+
+	if (!dvc_reg_table[reg_index].allow_ap) {
+		printk(KERN_ERR "AP can't set this register !\n");
+		return 0;
+	}
+
+	if (high_bits) {
+		//dlg_trace(" if high_bits\n");
+		/* Set high bits voltage */
+		if (current_volt_table[reg_index].volt_level_H == level)
+			return 0;
+
+		//////////////
+		d2199_dvfs_set_voltage(0,level);
+
+		//////////////
+		reg_val = __raw_readl(dvc_reg_table[reg_index].reg);
+		reg_val &= ~dvc_reg_table[reg_index].mask_H;
+		reg_val |= (level << dvc_reg_table[reg_index].offset_H);
+		if (dvc_reg_table[reg_index].offset_trig)
+			reg_val |= (1 << dvc_reg_table[reg_index].offset_trig);
+		pr_debug("%s Active VL[%x] = [%x]\n", __func__,
+			(unsigned int)dvc_reg_table[reg_index].reg, reg_val);
+		__raw_writel(reg_val, dvc_reg_table[reg_index].reg);
+
+		/* Only AP Active voltage change needs polling */
+		if (buck_id == BUCK1_AP_ACTIVE) {
+			if (stable_time_inited) {
+				if ( (level == lvl) &&
+					(level > current_volt_table[reg_index].volt_level_H) )
+					udelay(max_delay);
+			} else {
+				while (max_delay && !(__raw_readl(PMUM_DVC_ISR)
+				       & AP_VC_DONE_INTR_ISR)) {
+					udelay(1);
+					max_delay--;
+				}
+				if (!max_delay) {
+					printk(KERN_ERR "AP active voltage change can't finish!\n");
+					BUG_ON(1);
+				}
+				/*
+				 * Clear AP interrupt status
+				 * write 0 to clear, write 1 has no effect
+				 */
+				__raw_writel(0x6, PMUM_DVC_ISR);
+			}
+		}
+		current_volt_table[reg_index].volt_level_H = level;
+	} else {
+		//dlg_trace(" else high_bits\n");
+		/* Set low bits voltage, no need to poll status */
+		if (current_volt_table[reg_index].volt_level_L == level)
+			return 0;
+		///////////
+		d2199_dvfs_set_voltage(0,level);
+
+		/////////////
+		reg_val = __raw_readl(dvc_reg_table[reg_index].reg);
+		reg_val &= ~dvc_reg_table[reg_index].mask_L;
+		reg_val |= (level << dvc_reg_table[reg_index].offset_L);
+		pr_debug("%s LPM VL[%x] = [%x]\n", __func__,
+			(unsigned int)dvc_reg_table[reg_index].reg, reg_val);
+		__raw_writel(reg_val, dvc_reg_table[reg_index].reg);
+		current_volt_table[reg_index].volt_level_L = level;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(d2199_dvc_set_voltage);
+#endif	// DLG_DVFS
+
+int dvc_set_voltage(int buck_id, int level)
+{
+	unsigned int reg_val;
+	int reg_index = 0, high_bits; /* If this is high bits voltage */
+	static unsigned int pmic_vl_inited = 0;
+	unsigned int lvl = 0;
+	/*
+	 * Max delay time, unit is us. (1.5v - 1v) / 0.125v = 40
+	 * Also PMIC needs 10us to launch and sync dvc pins
+	 * default delay should be 0xFFFF * 3 ticks(L0-->L3 or L3-->L0)
+	 */
+	int max_delay;
+	dlg_trace("stable_time_inited[%d], buck_id[%d], level[%d]\n", stable_time_inited, buck_id, level);
+
+	/* updated lvl1 ~ lv3 during init stage */
+	if (unlikely(!pmic_vl_inited)) {
+		/* max vl to pmic leve 3 */
+		lvl = pxa988_get_vl_num() - 1;
+		set_voltage_value(level_mapping[LEVEL3], pxa988_get_vl(lvl));
+		set_voltage_value(level_mapping[LEVEL1], pxa988_get_vl(1));
+		set_voltage_value(level_mapping[LEVEL2], pxa988_get_vl(2));
+		pmic_vl_inited = 1;
+	}
+
+	if (stable_time_inited)
+		max_delay = 40 + 10 * 3; /* pmic sync time may be accumulated */
+	else
+		max_delay = DIV_ROUND_UP(0xFFFF * 3, 26);
+
+	if ((buck_id < BUCK1_AP_ACTIVE) || (buck_id > BUCK1_APSUB_SLEEP)) {
+		printk(KERN_ERR "Not new dvc regulator, Can't use %s\n", __func__);
+		return 0;
+	}
+	replace_level_voltage(buck_id, &level);
+	dlg_trace("buck_id[%d], level[%d]\n", buck_id, level);
+	if (buck_id == BUCK1_AP_ACTIVE) {
+		reg_index = DVC_AP;
+		high_bits = 1;
+	} else if (buck_id == BUCK1_AP_LPM) {
+		reg_index = DVC_AP;
+		high_bits = 0;
+	} else if (buck_id == BUCK1_APSUB_IDLE) {
+		reg_index = DVC_APSUB;
+		high_bits = 0;
+	} else if (buck_id == BUCK1_APSUB_SLEEP) {
+		reg_index = DVC_APSUB;
+		high_bits = 1;
+	}
+
+	if (!dvc_reg_table[reg_index].allow_ap) {
+		printk(KERN_ERR "AP can't set this register !\n");
+		return 0;
+	}
+
+	if (high_bits) {
+		dlg_trace(" if high_bits\n");
+		/* Set high bits voltage */
+		if (current_volt_table[reg_index].volt_level_H == level)
+			return 0;
+		/*
+		 * AP SW is the only client to trigger AP DVC.
+		 * Clear AP interrupt status to make sure no wrong signal is set
+		 * write 0 to clear, write 1 has no effect
+		 */
+		__raw_writel(0x6, PMUM_DVC_ISR);
+
+		reg_val = __raw_readl(dvc_reg_table[reg_index].reg);
+		reg_val &= ~dvc_reg_table[reg_index].mask_H;
+		reg_val |= (level << dvc_reg_table[reg_index].offset_H);
+		if (dvc_reg_table[reg_index].offset_trig)
+			reg_val |= (1 << dvc_reg_table[reg_index].offset_trig);
+		pr_debug("%s Active VL[%x] = [%x]\n", __func__,
+			(unsigned int)dvc_reg_table[reg_index].reg, reg_val);
+		__raw_writel(reg_val, dvc_reg_table[reg_index].reg);
+		/* Only AP Active voltage change needs polling */
+		if (buck_id == BUCK1_AP_ACTIVE) {
+			while (max_delay && !(__raw_readl(PMUM_DVC_ISR)
+			       & AP_VC_DONE_INTR_ISR)) {
+				udelay(1);
+				max_delay--;
+			}
+			if (!max_delay) {
+				printk(KERN_ERR "AP active voltage change can't finish!\n");
+				BUG_ON(1);
+			}
+			/*
+			 * Clear interrupt status
+			 * write 0 to clear, write 1 has no effect
+			 */
+			__raw_writel(0x6, PMUM_DVC_ISR);
+		}
+		current_volt_table[reg_index].volt_level_H = level;
+	} else {
+		dlg_trace(" else high_bits\n");
+		/* Set low bits voltage, no need to poll status */
+		if (current_volt_table[reg_index].volt_level_L == level)
+			return 0;
+		reg_val = __raw_readl(dvc_reg_table[reg_index].reg);
+		reg_val &= ~dvc_reg_table[reg_index].mask_L;
+		reg_val |= (level << dvc_reg_table[reg_index].offset_L);
+		pr_debug("%s LPM VL[%x] = [%x]\n", __func__,
+			(unsigned int)dvc_reg_table[reg_index].reg, reg_val);
+		__raw_writel(reg_val, dvc_reg_table[reg_index].reg);
+		current_volt_table[reg_index].volt_level_L = level;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dvc_set_voltage);
+
+/* init the voltage and rail/frequency tbl according to platform info */
+static int __init setup_dvfs_platinfo(void)
+{
+	unsigned int uiprofile = get_profile();
+	int i, j;
+	int min_cp_millivolts = 0;
+
+	dlg_trace(" cpu_is_pxa1088 [%d], uiprofile[%d]\n", cpu_is_pxa1088(), uiprofile);
+
+	if (get_board_id() == VER_T7)
+		dvc_pin_switch = 0;
+
+	vm_millivolts = vm_millivolts_default;
+
+	/* z1/z2/z3/Ax will use different voltage */
+	if (cpu_is_z1z2()) {
+		vm_millivolts = vm_millivolts_z1z2;
+		dvc_flag = 0;
+	} else if (cpu_is_pxa988_z3()) {
+		vm_millivolts = vm_millivolts_988z3_svc[uiprofile];
+		dvc_flag = 0;
+		component_freqs = freqs_cmb_z3;
+	} else if (cpu_is_pxa986_z3()) {
+		vm_millivolts = vm_millivolts_986z3_svc[uiprofile];
+		dvc_flag = 0;
+		component_freqs = freqs_cmb_z3;
+	} else if (cpu_is_pxa988_a0()) {
+		if (is_pxa988a0svc) {
+			vm_millivolts = vm_millivolts_988ax_svc[uiprofile];
+			if (max_freq > 1205)
+				vm_millivolts =
+					vm_millivolts_988ax_svc_1p5G[uiprofile];
+		} else
+			vm_millivolts = vm_millivolts_988z3_svc[uiprofile];
+		/*
+		 * 988 A0 CP/MSA/TD modem requires at least VL1 1.1V
+		 */
+		cp_pmudvc_lvl = msa_pmudvc_lvl = VL1;
+		component_freqs = freqs_cmb_ax;
+	} else if (cpu_is_pxa986_a0()) {
+		if (is_pxa988a0svc) {
+			vm_millivolts = vm_millivolts_986ax_svc[uiprofile];
+			if (max_freq > 1205)
+				vm_millivolts =
+					vm_millivolts_986ax_svc_1p5G[uiprofile];
+		} else
+			vm_millivolts = vm_millivolts_986z3_svc[uiprofile];
+		/*
+		 * 986 A0 CP/MSA/TD modem requires at least VL2
+		 */
+		cp_pmudvc_lvl = msa_pmudvc_lvl = VL2;
+		component_freqs = freqs_cmb_ax;
+	} else if (cpu_is_pxa1088()) {
+		if (has_feat_higher_ddr_vmin()) {
+			if (ddr_mode) {
+				pr_err("DDR 533M is not supported on this board!!!\n");
+				BUG_ON(1);
+			}
+
+			if (max_freq > CORE_1p18G)
+				vm_millivolts =
+					vm_mv_1088a0_svc_1p3G[uiprofile];
+			else if (max_freq > CORE_1p1G)
+				vm_millivolts =
+					vm_mv_1088a0_svc_1p2G[uiprofile];
+			else
+				vm_millivolts =
+					vm_mv_1088a0_svc_1p1G[uiprofile];
+
+			component_freqs = freqs_cmb_1088a0;
+		} else {
+			if (max_freq > CORE_1p18G)
+				vm_millivolts =
+					vm_mv_1088a1_svc_1p3G[uiprofile];
+			else if (max_freq > CORE_1p1G)
+				vm_millivolts =
+					vm_mv_1088a1_svc_1p2G[uiprofile];
+			else
+				vm_millivolts =
+					vm_mv_1088a1_svc_1p1G[uiprofile];
+			component_freqs = freqs_cmb_1088a1;
+		}
+		 /* CP 416M/624M are both using level 2 */
+		cp_pmudvc_lvl = msa_pmudvc_lvl = VL2;
+	}
+
+	/* z1/z2 and z3/ax use different PPs */
+	if (cpu_is_z1z2())
+		vm_rail_comp_tbl = vm_rail_comp_tbl_z1z2;
+	else {
+		vm_rail_comp_tbl = vm_rail_comp_tbl_gpiodvc;
+		/*
+		 * For GPIO dvc, make sure all voltages can meet
+		 * CP requirement.
+		 */
+		if (!dvc_flag) {
+			min_cp_millivolts =
+				max(vm_millivolts[cp_pmudvc_lvl],
+					vm_millivolts[msa_pmudvc_lvl]);
+			for (i = 0; i < VL_MAX; i++)
+				if (vm_millivolts[i] < min_cp_millivolts)
+					vm_millivolts[i] = min_cp_millivolts;
+		}
+	}
+	dlg_trace("dvc_flag[%d]\n", dvc_flag);
+	if (dvc_flag) {
+		/* update pmu dvc voltage table by max freq table */
+		update_all_pmudvc_rails_info();
+		/*
+		 * init voltage value for voltage_millivolts
+		 * Currently set it the same as svc table
+		 */
+		for (i = 0; i < MAX_RAIL_NUM; i++)
+			for (j = 1; j <= VL_MAX; j++)
+				voltage_millivolts[i][j] = vm_millivolts[j - 1];
+
+		if (dvc_pin_switch) {
+			/* Need to swap level 1 and level 2's voltage */
+			i = vm_millivolts[1];
+			vm_millivolts[1] = vm_millivolts[2];
+			vm_millivolts[2] = i;
+		}
+	}
+#if defined(CONFIG_D2199_DVC)
+	ramp_up_vol = (vm_millivolts[VL3] - vm_millivolts[VL2]) * 10;
+	dlg_trace("ramp_up_vol[%d]\n", ramp_up_vol);
+#endif
+	return 0;
+}
+core_initcall_sync(setup_dvfs_platinfo);
+
+unsigned int pxa988_get_vl_num(void)
+{
+	unsigned int i = 0;
+	while (i < VL_MAX && vm_millivolts[i])
+		i++;
+	return i;
+};
+
+unsigned int pxa988_get_vl(unsigned int vl)
+{
+	return vm_millivolts[vl];
+};
+
+static void update_component_voltage(unsigned int comp,
+	unsigned int num_volt)
+{
+	int i, j = 0;
+
+	for (i = 0; i < num_volt; i++) {
+		component_voltage[comp][AP_ACTIVE][i] = LEVEL0 + i;
+	}
+
+	if (has_feat_dvc_M2D1Pignorecore() && (comp == CORE)) {
+		for (i = AP_LPM; i <= APSUB_IDLE; i++)
+			for (j = 0; j < num_volt; j++)
+				component_voltage[comp][i][j] = LEVEL0;
+	} else {
+		for (i = AP_LPM; i <= APSUB_IDLE; i++)
+			for (j = 0; j < num_volt; j++)
+				component_voltage[comp][i][j] =
+					component_voltage[comp][AP_ACTIVE][j];
+	}
+
+	/* all Components have no request for APSUB_SLEEP */
+	for (j = 0; j < num_volt; j++)
+		component_voltage[comp][APSUB_SLEEP][j] = LEVEL0;
+}
+
+static void update_all_pmudvc_rails_info(void)
+{
+	unsigned int num_volt, idx;
+
+	/* Update all rails corresponding voltage */
+	num_volt = pxa988_get_vl_num();
+	for (idx = 0; idx < VM_RAIL_MAX; idx++)
+		update_component_voltage(idx, num_volt);
+}
+
+static struct dvfs *vcc_main_dvfs_init
+	(struct dvfs_rail_component *dvfs_component, int factor)
+{
+	struct dvfs *vm_dvfs = NULL;
+	struct vol_table *vt = NULL;
+	int i;
+	unsigned int vl_num = 0;
+	const char *clk_name;
+
+	dlg_trace("factor[%d], dvc_flag[%d]\n", factor, dvc_flag);
+	/* dvfs is not enabled for this factor in vcc_main_threshold */
+	if (!dvfs_component[factor].auto_dvfs)
+		goto err;
+
+	clk_name = dvfs_component[factor].clk_name;
+
+	vm_dvfs = kzalloc(sizeof(struct dvfs), GFP_KERNEL);
+	if (!vm_dvfs) {
+		pr_err("failed to request mem for vcc_main dvfs\n");
+		goto err;
+	}
+
+	vl_num = pxa988_get_vl_num();
+
+	vt = kzalloc(sizeof(struct vol_table) * vl_num, GFP_KERNEL);
+	if (!vt) {
+		pr_err("failed to request mem for vcc_main vol table\n");
+		goto err_vt;
+	}
+
+	for (i = 0; i < vl_num; i++) {
+		vt[i].freq = dvfs_component[factor].freqs[i] * \
+			dvfs_component[factor].freqs_mult;
+		vt[i].millivolts = dvfs_component[factor].millivolts[i];
+		dlg_trace("clk[%s] rate[%lu] volt[%d]\n", clk_name, vt[i].freq,
+					vt[i].millivolts);
+	}
+	vm_dvfs->vol_freq_table = vt;
+	vm_dvfs->clk_name = clk_name;
+	vm_dvfs->num_freqs = vl_num;
+	vm_dvfs->dvfs_rail = dvfs_component[factor].dvfs_rail;
+
+	dvfs_component[factor].clk_node =
+		clk_get_sys(NULL, clk_name);
+	dvfs_component[factor].dvfs = vm_dvfs;
+
+	dlg_trace("end of function\n");
+	return vm_dvfs;
+err_vt:
+	kzfree(vm_dvfs);
+	vm_dvfs = NULL;
+err:
+	return vm_dvfs;
+}
+
+static int get_frequency_from_dvfs(struct dvfs *dvfs, int millivolts)
+{
+	unsigned long max_freq = 0;
+	int i;
+	dlg_trace("millivolts[%d]\n", millivolts);
+	for (i = 0; i < dvfs->num_freqs; i++) {
+		if (dvfs->vol_freq_table[i].millivolts == millivolts) {
+			if (dvfs->vol_freq_table[i].freq > max_freq)
+				max_freq = dvfs->vol_freq_table[i].freq;
+		}
+	}
+
+	dlg_trace("max_freq[%d]\n", max_freq);
+	return max_freq;
+}
+
+static int global_notifier(struct dvfs *dvfs, int state,
+			   int old_rate, int new_rate)
+{
+	struct dvfs_freqs freqs;
+	dlg_trace("state[%d], old_rate[%d], new_rate[%d]\n", state, old_rate, new_rate);
+	freqs.old = old_rate / KHZ_TO_HZ;
+	freqs.new = new_rate / KHZ_TO_HZ;
+	freqs.dvfs = dvfs;
+	dvfs_notifier_frequency(&freqs, state);
+	return 0;
+}
+
+static DEFINE_MUTEX(solve_lock);
+/*
+ * dvfs_update_rail will call dvfs_solve_relationship when the rail's "from"
+ * list is not null. So the rail must be the fake rail since fake rail's "from"
+ * list is not null(real rail's "from" list is null).
+ *
+ * Return value is tricky here. it returns 0 always, this return value
+ * will be used as millivolts for the fake rail which keeps the millivolts
+ * and new_millivolts are both 0, which consequently prevent fake rail from
+ * calling its own dvfs_rail_set_voltage in dvfs_update_rail. so the fake
+ * rail's state is constant.
+ *
+*/
+static int vcc_main_solve(struct dvfs_rail *from, struct dvfs_rail *to)
+{
+	int old_millivolts, new_millivolts;
+	struct dvfs *temp;
+	/* whether frequency change is behind voltage change */
+	static int is_after_change;
+	if (from == NULL) {
+		printk(KERN_ERR "The \"from\" part of the relation is NULL\n");
+		return 0;
+	}
+
+	dlg_trace("millivolts[%d], new_millivolts[%d]\n", from->millivolts, from->new_millivolts);
+	mutex_lock(&solve_lock);
+
+	old_millivolts = from->millivolts;
+	new_millivolts = from->new_millivolts;
+
+	/*
+	 * this function is called before and after the real rail's
+	 * set voltage function.
+	 * a: when it is called before voltage change:
+	 * 1) if old < new,
+	 *    then we can't increase the frequencies of each component
+	 *    since voltage is not raised yet. return directly here.
+	 * 2) if old > new, then we lower the components's frequency
+	 * 3) if old == new, return directly
+	 * b: when it is called after frequency change, then there is only
+	 * one condition, that is old == new.
+	 * 1) previous voltage change is raise voltage, then raise
+	 *    frequencies of each component.
+	 * 2) previous voltage is not changed or lowered down, return directly
+	*/
+	if (old_millivolts < new_millivolts) {
+		is_after_change = 1;
+		mutex_unlock(&solve_lock);
+		return 0;
+	} else if (old_millivolts == new_millivolts) {
+		if (!is_after_change) {
+			mutex_unlock(&solve_lock);
+			return 0;
+		}
+	}
+	pr_debug("Voltage from %d to %d\n", old_millivolts, new_millivolts);
+	list_for_each_entry(temp, &from->dvfs, dvfs_node) {
+		struct clk *cur_clk = clk_get(NULL, temp->clk_name);
+		if ((cur_clk->refcnt > 0) && (cur_clk->is_combined_fc)) {
+			unsigned long frequency =
+				get_frequency_from_dvfs(temp, new_millivolts);
+			int cur_freq = cur_clk->ops->getrate(cur_clk);
+			pr_debug("clock: %s 's rate is set from %ld to %ld Hz,"
+				 " millivolts: %d\n", temp->clk_name,
+				 cur_clk->rate, frequency, temp->millivolts);
+			global_notifier(temp, DVFS_FREQ_PRECHANGE,
+					cur_freq, frequency);
+			cur_clk->ops->setrate(cur_clk, frequency);
+			global_notifier(temp, DVFS_FREQ_POSTCHANGE,
+					cur_freq, frequency);
+			cur_clk->rate = cur_clk->ops->getrate(cur_clk);
+		}
+	}
+	is_after_change = 0;
+	mutex_unlock(&solve_lock);
+	return 0;
+}
+
+/*
+ * Fake rail, use relationship to implement dvfs based dvfm
+ * only define reg_id to make rail->reg as non-null after
+ * rail is connected to regulator, all other components are 0
+ * and should be kept as 0 in further operations.
+ */
+static struct dvfs_rail pxa988_dvfs_rail_vm_dup = {
+	.reg_id = "vcc_main",
+};
+
+/*
+ * Real rail is the "from" in the relationship, its "to" list
+ * contains fake rail, but it has no "from" list.
+ * Fake rail is the "to" in the relationship. its "from" list
+ * contains real rail, but it has no "to" list.
+*/
+static struct dvfs_relationship pxa988_dvfs_relationships[] = {
+	{
+		.from = &pxa988_dvfs_rail_vm,
+		.to = &pxa988_dvfs_rail_vm_dup,
+		.solve = vcc_main_solve,
+	},
+};
+
+static struct dvfs_rail *pxa988_dvfs_rails[] = {
+	&pxa988_dvfs_rail_vm,
+	&pxa988_dvfs_rail_vm_dup,
+};
+
+/*
+ * "from" is the lpm rails, "to" is active rail
+*/
+static int vcc_main_solve_lpm(struct dvfs_rail *from, struct dvfs_rail *to)
+{
+	int millivolts = 0;
+	struct dvfs *d_to, *d_from, *d;
+	struct list_head *list_from, *list_to;
+	struct regulator *ori_reg = to->reg;
+
+	to->reg = NULL; /* hack here to avoid recursion of dvfs_rail_update */
+	//dlg_trace("\n");
+
+	for (list_from = from->dvfs.next, list_to = to->dvfs.next;
+	     (list_from != &from->dvfs) && (list_to != &to->dvfs);
+	     list_from = list_from->next, list_to = list_to->next) {
+		d_to = list_entry(list_to, struct dvfs, dvfs_node);
+		d_from = list_entry(list_from, struct dvfs, dvfs_node);
+		if (has_feat_dvc_M2D1Pignorecore()) {
+			/*
+			 * CPU won't request voltage on lpm rails
+			 * skip it from comparison
+			*/
+			if (!strcmp(d_to->clk_name, "cpu") &&
+			    !strcmp(d_from->clk_name, "cpu"))
+				continue;
+		}
+		if (d_to->millivolts != d_from->millivolts) {
+			d_from->millivolts = d_to->millivolts;
+			dvfs_rail_update(from);
+			break;
+		}
+	}
+	/* Solve function's return value will be used as the new_millivolts
+	 * for active rail, as our solve function will not affect active rail's
+	 * voltage, so only get the max value of each dvfs under active rail
+	*/
+	list_for_each_entry(d, &to->dvfs, dvfs_node)
+		millivolts = max(d->millivolts, millivolts);
+
+	to->reg = ori_reg;
+	//dlg_trace("millivolts[%d]\n", millivolts);
+
+	return millivolts;
+}
+
+static struct dvfs_relationship pxa988_dvfs_relationships_pmudvc[] = {
+	{
+		.from = &pxa988_dvfs_rail_ap_lpm,
+		.to = &pxa988_dvfs_rail_ap_active,
+		.solve = vcc_main_solve_lpm,
+	},
+	{
+		.from = &pxa988_dvfs_rail_apsub_idle,
+		.to = &pxa988_dvfs_rail_ap_active,
+		.solve = vcc_main_solve_lpm,
+	},
+};
+
+static void __init enable_ap_dvc(void)
+{
+	int value;
+	dlg_trace("\n");
+	value = __raw_readl(PMUM_DVCR);
+#ifdef CONFIG_MFD_D2199
+	value |= (DVCR_VC_EN);
+#else
+	value |= (DVCR_VC_EN | DVCR_LPM_AVC_EN);
+#endif
+	__raw_writel(value, PMUM_DVCR);
+
+	value = __raw_readl(PMUM_DVC_AP);
+	value |= DVC_AP_LPM_AVC_EN;
+	__raw_writel(value, PMUM_DVC_AP);
+
+	value = __raw_readl(PMUM_DVC_IMR);
+	value |= AP_VC_DONE_INTR_MASK;
+	__raw_writel(value, PMUM_DVC_IMR);
+
+	value = __raw_readl(PMUM_DVC_APSUB);
+	value |= (nUDR_AP_SLP_AVC_EN | AP_IDLE_DDRON_AVC_EN);
+	__raw_writel(value, PMUM_DVC_APSUB);
+
+	value = __raw_readl(PMUM_DVC_CHIP);
+	value |= (UDR_SLP_AVC_EN | nUDR_SLP_AVC_EN);
+	__raw_writel(value, PMUM_DVC_CHIP);
+}
+
+/* vote active and LPM voltage level request for CP */
+static void __init enable_cp_dvc(void)
+{
+	unsigned int value, mask, lvl;
+
+	dlg_trace("\n");
+	/*
+	 * cp_pmudvc_lvl and msa_pmudvc_lvl is set up during init,
+	 * default as VL1
+	 */
+
+	/*
+	 * Vote CP active cp_pmudvc_lvl and LPM VL0
+	 * and trigger CP frequency request
+	 */
+	value = __raw_readl(dvc_reg_table[DVC_CP].reg);
+	mask = (dvc_reg_table[DVC_CP].mask_H) | \
+		(dvc_reg_table[DVC_CP].mask_L);
+	value &= ~mask;
+	lvl = (cp_pmudvc_lvl << dvc_reg_table[DVC_CP].offset_H) |\
+		((LEVEL0 - LEVEL0) << dvc_reg_table[DVC_CP].offset_L);
+	value |= lvl | DVC_CP_LPM_AVC_EN | \
+		(1 << dvc_reg_table[DVC_CP].offset_trig);
+	__raw_writel(value, dvc_reg_table[DVC_CP].reg);
+
+	/*
+	 * Vote MSA active msa_pmudvc_lvl and LPM VL0
+	 * and trigger MSA frequency request
+	 */
+	value = __raw_readl(dvc_reg_table[DVC_DP].reg);
+	mask = (dvc_reg_table[DVC_DP].mask_H) | \
+		(dvc_reg_table[DVC_DP].mask_L);
+	value &= ~mask;
+	lvl = (msa_pmudvc_lvl << dvc_reg_table[DVC_DP].offset_H) |\
+		((LEVEL0 - LEVEL0) << dvc_reg_table[DVC_DP].offset_L);
+	value |= lvl | DVC_DP_LPM_AVC_EN | \
+		(1 << dvc_reg_table[DVC_DP].offset_trig);
+	__raw_writel(value, dvc_reg_table[DVC_DP].reg);
+
+	/* unmask cp/msa DVC done int */
+	value = __raw_readl(PMUM_DVC_IMR);
+	value |= (CP_VC_DONE_INTR_MASK | DP_VC_DONE_INTR_MASK);
+	__raw_writel(value, PMUM_DVC_IMR);
+}
+
+static int __init pxa988_init_dvfs(void)
+{
+	int i, ret, j, r;
+	struct dvfs *d;
+	struct clk *c;
+	unsigned long rate;
+
+	dlg_trace("dvc_flag[%d]\n", dvc_flag);
+	if (!dvc_flag) {
+		dvfs_init_rails(pxa988_dvfs_rails, ARRAY_SIZE(pxa988_dvfs_rails));
+		for (i = 0; i < VM_RAIL_MAX; i++) {
+			vm_rail_comp_tbl[i].freqs = component_freqs[i];
+			vm_rail_comp_tbl[i].millivolts = vm_millivolts;
+			d = vcc_main_dvfs_init(vm_rail_comp_tbl, i);
+			if (!d)
+				continue;
+			c = vm_rail_comp_tbl[i].clk_node;
+			if (!c) {
+				pr_err("pxa988_dvfs: no clock found for %s\n",
+					d->clk_name);
+				kzfree(d->vol_freq_table);
+				kzfree(d);
+				continue;
+			}
+			ret = enable_dvfs_on_clk(c, d);
+			if (ret) {
+				pr_err("pxa988_dvfs: failed to enable dvfs on %s\n",
+					c->name);
+				kzfree(d->vol_freq_table);
+				kzfree(d);
+			}
+			/*
+			* adjust the voltage request according to its current rate
+			* for those clk is always on
+			*/
+			if (c->refcnt) {
+				rate = clk_get_rate(c);
+				j = 0;
+				while (j < d->num_freqs && rate > d->vol_freq_table[j].freq)
+					j++;
+				d->millivolts = d->vol_freq_table[j].millivolts;
+			}
+		}
+	} else {
+		struct dvfs_rail_component *rail_component;
+		dvfs_init_rails(pxa988_dvfs_rails_pmudvc,
+			ARRAY_SIZE(pxa988_dvfs_rails_pmudvc));
+		dvfs_add_relationships(pxa988_dvfs_relationships_pmudvc,
+			ARRAY_SIZE(pxa988_dvfs_relationships_pmudvc));
+		init_level_mapping();
+		enable_ap_dvc();
+
+		for (r = 0; r < ARRAY_SIZE(pxa988_dvfs_rails_pmudvc); r++) {
+			rail_component = dvfs_rail_component_list[r];
+			for (i = 0; i < VM_RAIL_MAX; i++) {
+				rail_component[i].freqs = component_freqs[i];
+				vm_rail_comp_tbl[i].millivolts = vm_millivolts;
+				d = vcc_main_dvfs_init(rail_component, i);
+				if (!d)
+					continue;
+				c = rail_component[i].clk_node;
+				if (!c) {
+					pr_err("pxa988_dvfs: no clock found for %s\n",
+						d->clk_name);
+					kzfree(d->vol_freq_table);
+					kzfree(d);
+					continue;
+				}
+				if (r == 0) { /* only allow active rail's dvfs connect to clock */
+					ret = enable_dvfs_on_clk(c, d);
+					if (ret) {
+						pr_err("pxa988_dvfs: failed to enable dvfs on %s\n",
+							c->name);
+						kzfree(d->vol_freq_table);
+						kzfree(d);
+					}
+				} else
+					list_add_tail(&d->dvfs_node, &d->dvfs_rail->dvfs);
+				/*
+				* adjust the voltage request according to its current rate
+				* for those clk is always on
+				*/
+				if (c->refcnt) {
+					rate = clk_get_rate(c);
+					j = 0;
+					while (j < d->num_freqs && rate > d->vol_freq_table[j].freq)
+						j++;
+					d->millivolts = d->vol_freq_table[j].millivolts;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+subsys_initcall(pxa988_init_dvfs);
+
+static int __init pxa988_init_level_volt(void)
+{
+	int i, value, ticks;
+	u8 data;
+	dlg_trace("dvc_flag[%d]\n", dvc_flag);
+	if (!dvc_flag)
+		return 0;
+
+	/* Write level 0 svc values, level 1~3 are written after pm800 init */
+	value = set_buck1_volt(0, volt_to_reg(vm_millivolts[0]));
+	if (value < 0) {
+		printk(KERN_ERR "SVC table writting failed !\n");
+		return -1;
+	}
+#ifdef CONFIG_MACH_WILCOX_CMCC
+#if defined(CONFIG_MFD_D2199)	
+     if (get_board_id() <BOARD_ID_CMCC_REV05) {  
+	/* set ldo6 to be 1.7v only for rB1 Mynah Tranceiver */
+	d2199_extern_reg_read(D2199_LDO6_REG, &data);
+	data &= ~(0x3f);
+	data |= 0xa;
+	d2199_extern_reg_write(D2199_LDO6_REG,data);
+    }
+#endif
+#endif
+	for (i = 0; i < PMIC_LEVEL_NUM; i++) {
+		cur_level_volt[i] = get_voltage_value(i);
+		pr_info("PMIC level %d: %d mV\n", i, cur_level_volt[i]);
+	}
+
+	enable_cp_dvc();
+
+	/* Get the current level information */
+	for (i = DVC_AP; i < DVC_END; i++) {
+		value = __raw_readl(dvc_reg_table[i].reg);
+		current_volt_table[i].volt_level_H =
+			(value & dvc_reg_table[i].mask_H)
+			>> (dvc_reg_table[i].offset_H);
+		current_volt_table[i].volt_level_L =
+			(value & dvc_reg_table[i].mask_L)
+			>> (dvc_reg_table[i].offset_L);
+		pr_info("DVC Reg %d, volt high: %d, volt low: %d\n", i,
+			current_volt_table[i].volt_level_H,
+			current_volt_table[i].volt_level_L);
+	}
+	cur_volt_inited = 1;
+
+	if (dvc_pin_switch) {
+		value = cur_level_volt[1];
+		cur_level_volt[1] = cur_level_volt[2];
+		cur_level_volt[2] = value;
+	}
+
+	/* Fill the stable time for level transition
+	 * As pmic only supports 4 levels, so only init
+	 * 0->1, 1->2, 2->3 's stable time.
+	 */
+	value = __raw_readl(PMUM_VL01STR);
+	value &= ~VLXX_ST_MASK;
+	ticks = get_stable_ticks(cur_level_volt[0], cur_level_volt[1]);
+	value |= ticks;
+	__raw_writel(value, PMUM_VL01STR);
+
+	value = __raw_readl(PMUM_VL12STR);
+	value &= ~VLXX_ST_MASK;
+	ticks = get_stable_ticks(cur_level_volt[1], cur_level_volt[2]);
+	value |= ticks;
+	__raw_writel(value, PMUM_VL12STR);
+
+	value = __raw_readl(PMUM_VL23STR);
+	value &= ~VLXX_ST_MASK;
+	ticks = get_stable_ticks(cur_level_volt[2], cur_level_volt[3]);
+	value |= ticks;
+	__raw_writel(value, PMUM_VL23STR);
+	stable_time_inited = 1;
+
+	return 0;
+}
+/* the init must before cpufreq init(module_init)
+ * must before dvfs framework init(fs_initcall)
+ * must after 88pm800 init(subsys_initcall)
+ * must after dvfs init (fs_initcall)
+ */
+device_initcall(pxa988_init_level_volt);
+
+#ifdef CONFIG_DEBUG_FS
+static void attach_clk_auto_dvfs(const char *name, unsigned int endis)
+{
+	unsigned int i;
+
+	dlg_trace("endis[%d]\n", endis);
+
+	for (i = 0; i < VM_RAIL_MAX; i++) {
+		if ((vm_rail_comp_tbl[i].auto_dvfs) && \
+			(!strcmp(vm_rail_comp_tbl[i].clk_name, name)))
+			break;
+	}
+	if (i >= VM_RAIL_MAX) {
+		pr_err("clk %s doesn't support dvfs\n", name);
+		return;
+	}
+
+	if (!endis)
+		vm_rail_comp_tbl[i].clk_node->dvfs = NULL;
+	else
+		vm_rail_comp_tbl[i].clk_node->dvfs =
+			vm_rail_comp_tbl[i].dvfs;
+	pr_info("%s clk %s auto dvfs!\n",
+		endis ? "Enable" : "Disable", name);
+}
+
+static ssize_t dc_clk_dvfs_write(struct file *filp,
+	const char __user *buffer, size_t count, loff_t *ppos)
+{
+	char buf[32] = {0};
+	char name[10] = {0};
+	unsigned int enable_dvfs = 0;
+
+	dlg_trace("\n");
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	if (0x2 != sscanf(buf, "%9s %10u", name, &enable_dvfs)) {
+		pr_info("[cmd guide]echo clkname(cpu/ddr/GCCLK/VPUCLK) "\
+			"enable(0/1) > file node\n");
+		return count;
+	}
+	attach_clk_auto_dvfs(name, enable_dvfs);
+	return count;
+}
+
+static ssize_t dc_clk_dvfs_read(struct file *filp,
+	char __user *buffer, size_t count, loff_t *ppos)
+{
+	char buf[156];
+	int len = 0;
+	size_t size = sizeof(buf) - 1;
+	struct clk *clk_node;
+	unsigned int i;
+	const char *clk_name;
+	dlg_trace("\n");
+
+	len = snprintf(buf, size, "| name\t| auto_dvfs |\n");
+	for (i = 0; i < VM_RAIL_MAX; i++) {
+		if (vm_rail_comp_tbl[i].auto_dvfs) {
+			clk_name = vm_rail_comp_tbl[i].clk_name;
+			clk_node = vm_rail_comp_tbl[i].clk_node;
+			len += snprintf(buf + len, size - len,
+				"| %s\t| %d |\n", clk_name,
+				clk_is_dvfs(clk_node));
+		}
+	}
+	return simple_read_from_buffer(buffer, count, ppos, buf, len);
+}
+
+/*
+ * Disable clk auto dvfs function, only avaiable when
+ * has no corresponding clk FC
+ */
+const struct file_operations dc_clk_dvfs_fops = {
+	.write = dc_clk_dvfs_write,
+	.read = dc_clk_dvfs_read,
+};
+
+static ssize_t voltage_based__dvfm_write(struct file *filp,
+	const char __user *buffer, size_t count, loff_t *ppos)
+{
+	char buf[32] = {0};
+	int prevalue = enable_voltage_based_dvfm;
+	dlg_trace("\n");
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%10d", &enable_voltage_based_dvfm);
+
+	if (!prevalue && enable_voltage_based_dvfm)
+		dvfs_add_relationships(pxa988_dvfs_relationships,
+			ARRAY_SIZE(pxa988_dvfs_relationships));
+	else if (prevalue && !enable_voltage_based_dvfm)
+		dvfs_remove_relationship(&pxa988_dvfs_relationships[0]);
+
+	return count;
+}
+
+static ssize_t voltage_based_dvfm_read(struct file *filp,
+	char __user *buffer, size_t count, loff_t *ppos)
+{
+	char buf[20];
+	int len = 0;
+	size_t size = sizeof(buf) - 1;
+	dlg_trace("\n");
+	len = snprintf(buf, size, "%d\n", enable_voltage_based_dvfm);
+	return simple_read_from_buffer(buffer, count, ppos, buf, len);
+}
+
+/*
+ * Enable/disable voltage based dvfm solution
+ */
+const struct file_operations voltage_based_dvfm_fops = {
+	.write = voltage_based__dvfm_write,
+	.read = voltage_based_dvfm_read,
+};
+
+static ssize_t voltage_read(struct file *filp,
+	char __user *buffer, size_t count, loff_t *ppos)
+{
+	char buf[1000];
+	int len = 0, value, volt1, volt2;
+	unsigned int i;
+	struct dvfs *d;
+	unsigned long rate;
+
+	dlg_trace("\n");
+
+	size_t size = sizeof(buf) - 1;
+	value = __raw_readl(PMUM_DVC_AP);
+	volt1 = (value >> 4) & 0x7;
+	volt2 = value & 0x7;
+	len += snprintf(buf + len, size, "|DVC_AP:\t|Active: %d,\t"
+			"Lpm:   %d |\n",	volt1, volt2);
+
+	value = __raw_readl(PMUM_DVC_CP);
+	volt1 = (value >> 4) & 0x7;
+	volt2 = value & 0x7;
+	len += snprintf(buf + len, size, "|DVC_CP:\t|Active: %d,\t"
+			"Lpm:   %d |\n", volt1, volt2);
+
+	value = __raw_readl(PMUM_DVC_DP);
+	volt1 = (value >> 4) & 0x7;
+	volt2 = value & 0x7;
+	len += snprintf(buf + len, size, "|DVC_DP:\t|Active: %d,\t"
+			"Lpm:   %d |\n",	volt1, volt2);
+
+	value = __raw_readl(PMUM_DVC_APSUB);
+	volt1 = (value >> 8) & 0x7;
+	volt2 = value & 0x7;
+	len += snprintf(buf + len, size, "|DVC_APSUB:\t|IDLE:   %d,\t"
+			"SLEEP: %d |\n",	volt2, volt1);
+
+	value = __raw_readl(PMUM_DVC_CHIP);
+	volt1 = (value >> 4) & 0x7;
+	volt2 = value & 0x7;
+	len += snprintf(buf + len, size, "|DVC_CHIP:\t|UDR:    %d,\t"
+			"nUDR:  %d |\n",	volt1, volt2);
+
+	value = __raw_readl(PMUM_DVC_STATUS);
+	volt1 = (value >> 1) & 0x7;
+
+	len += snprintf(buf + len, size, "|DVC Voltage:    Level %d ",
+			volt1);
+
+	if (dvc_pin_switch) {
+		if (volt1 == 1)
+			volt1 = 2;
+		else if (volt1 == 2)
+			volt1 = 1;
+	}
+//	volt1 = 1250;
+	dlg_trace("volt1[%d]\n", volt1);
+	volt1 = get_buck1_volt(volt1);
+	volt1 = reg_to_volt(volt1);
+	len += snprintf(buf + len, size, "(%d mV)\t\t  |\n", volt1);
+
+	for (i = 0; i < VM_RAIL_MAX; i++) {
+		if (vm_rail_ap_active_tbl[i].auto_dvfs) {
+			d = vm_rail_ap_active_tbl[i].clk_node->dvfs;
+			rate = clk_get_rate(vm_rail_ap_active_tbl[i].clk_node);
+			if (d->millivolts > 0) {
+				len += snprintf(buf + len, size,
+				"|%-15s| freq %luMhz,\t voltage: Level %d |\n",
+				vm_rail_ap_active_tbl[i].clk_name,
+				rate / 1000000, level_mapping[d->millivolts]);
+			} else {
+				len += snprintf(buf + len, size,
+				"|%-15s| freq %luMhz,\t voltage: %d |\n",
+				vm_rail_ap_active_tbl[i].clk_name,
+				rate / 1000000, d->millivolts);
+			}
+		}
+	}
+
+	return simple_read_from_buffer(buffer, count, ppos, buf, len);
+}
+
+
+/* Get current voltage for each power mode */
+const struct file_operations voltage_fops = {
+	.read = voltage_read,
+};
+
+
+static int __init pxa988_dvfs_create_debug_node(void)
+{
+	struct dentry *dvfs_node;
+	struct dentry *dc_dvfs;
+	struct dentry *volt_dvfs;
+	struct dentry *volt_status;
+
+	dlg_trace("\n");
+	dvfs_node = debugfs_create_dir("dvfs", pxa);
+	if (!dvfs_node)
+		return -ENOENT;
+
+	dc_dvfs = debugfs_create_file("dc_clk_dvfs", 0664,
+		dvfs_node, NULL, &dc_clk_dvfs_fops);
+	if (!dc_dvfs)
+		goto err_dc_dvfs;
+	volt_dvfs = debugfs_create_file("enable_volt_based_dvfm", 0664,
+		dvfs_node, NULL, &voltage_based_dvfm_fops);
+	if (!volt_dvfs)
+		goto err_volt_dvfs;
+	if (dvc_flag) {
+		volt_status = debugfs_create_file("voltage", 0444,
+			dvfs_node, NULL, &voltage_fops);
+		if (!volt_status)
+			goto err_voltage;
+	}
+
+	return 0;
+
+err_voltage:
+	debugfs_remove(volt_dvfs);
+err_volt_dvfs:
+	debugfs_remove(dc_dvfs);
+err_dc_dvfs:
+	debugfs_remove(dvfs_node);
+	return -ENOENT;
+}
+late_initcall(pxa988_dvfs_create_debug_node);
+#endif
diff --git a/arch/arm/mach-mmp/gpio-edge.c b/arch/arm/mach-mmp/gpio-edge.c
new file mode 100644
index 00000000..d09610b5
--- /dev/null
+++ b/arch/arm/mach-mmp/gpio-edge.c
@@ -0,0 +1,216 @@
+/*
+ * linux/arch/arm/mach-mmp/gpio-edge.c
+ *
+ * The GPIO Edge is the edge detect signals coming from the I/O pads.
+ * Although the name of this module is the GPIO Edge Unit, it can be
+ * used by other I/Os as it is not necessarily for use only by the
+ * GPIOs. It's normally used to wake up the system from low power mode.
+ *
+ * Copyright:   (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <mach/regs-icu.h>
+#include <mach/gpio-edge.h>
+#include <mach/irqs.h>
+#include <plat/mfp.h>
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define ICU_IRQ_ENABLE	((1 << 6) | (1 << 4) | (1 << 0))
+#define ICU_IRQ_GPIO_EDGE (IRQ_PXA988_GPIO_EDGE - IRQ_PXA988_START)
+#endif
+
+/* The list head of the gpio edge wakeup sources */
+static struct list_head gpio_edge_list;
+/* The virtual address of the GPIO Edge Unit */
+static void __iomem *gpio_edge_base;
+/* The total number of GPIOs in the SoC */
+int gpio_edge_gpio_num;
+/* The total number of MFPs in the SoC */
+static int gpio_edge_mfp_num;
+/* The gpio edge detect is enabled */
+static int gpio_edge_enabled;
+
+static DEFINE_SPINLOCK(gpio_edge_lock);
+static unsigned long flags;
+
+static void gpio_edge_icu_enable(void)
+{
+	__raw_writel(ICU_IRQ_ENABLE, ICU_INT_CONF(ICU_IRQ_GPIO_EDGE));
+}
+
+static void gpio_edge_icu_disable(void)
+{
+	__raw_writel(0, ICU_INT_CONF(ICU_IRQ_GPIO_EDGE));
+}
+
+void gpio_edge_wakeup_enable_default(void)
+{
+}
+void gpio_edge_wakeup_enable(void)
+	__attribute__((weak, alias("gpio_edge_wakeup_enable_default")));
+
+void gpio_edge_wakeup_disable_default(void)
+{
+}
+void gpio_edge_wakeup_disable(void)
+	__attribute__((weak, alias("gpio_edge_wakeup_disable_default")));
+
+/* Add one gpio edge wakeup source to the list */
+int mmp_gpio_edge_add(struct gpio_edge_desc *edge)
+{
+	struct gpio_edge_desc *e;
+
+	if (!edge || edge->mfp >= gpio_edge_mfp_num) {
+		pr_err("error: gpio edge add: wrong param!\n");
+		return -EINVAL;
+	}
+
+	if (edge->mfp < gpio_edge_gpio_num)
+		edge->gpio = edge->mfp;
+	else
+		BUG_ON(edge->gpio == 0);
+
+	if (edge->gpio >= gpio_edge_gpio_num) {
+		pr_err("error: gpio edge add: wrong gpio %u\n", edge->gpio);
+		return -EINVAL;
+	}
+
+	if (edge->type == 0)
+		edge->type = MFP_LPM_EDGE_BOTH;
+
+	spin_lock_irqsave(&gpio_edge_lock, flags);
+
+	list_for_each_entry(e, &gpio_edge_list, list) {
+		if (e == edge) {
+			pr_err("error: gpio edge: adding exist gpio: %d\n",
+				edge->gpio);
+			spin_unlock_irqrestore(&gpio_edge_lock, flags);
+			return -EEXIST;
+		}
+	}
+
+	list_add(&edge->list, &gpio_edge_list);
+
+	spin_unlock_irqrestore(&gpio_edge_lock, flags);
+	return 0;
+}
+
+EXPORT_SYMBOL(mmp_gpio_edge_add);
+
+/* Remove one gpio edge wakeup source from the list */
+int mmp_gpio_edge_del(struct gpio_edge_desc *edge)
+{
+	struct gpio_edge_desc *e;
+
+	if (!edge) {
+		pr_err("error: gpio edge del: wrong param!\n");
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&gpio_edge_lock, flags);
+
+	list_for_each_entry(e, &gpio_edge_list, list) {
+		if (e == edge) {
+			list_del(&edge->list);
+			spin_unlock_irqrestore(&gpio_edge_lock, flags);
+			return 0;
+		}
+	}
+
+	spin_unlock_irqrestore(&gpio_edge_lock, flags);
+
+	pr_err("error: gpio edge: del none exist gpio: %d\n", edge->gpio);
+	return -ENXIO;
+}
+
+EXPORT_SYMBOL(mmp_gpio_edge_del);
+
+/*
+ * Enable each gpio edge wakeup source in the list, and enable the corresponing
+ * interrupt in the ICU so as to be able to wake up the core in low power mode.
+ * Call this function before entering low power mode.
+ */
+void mmp_gpio_edge_enable(void)
+{
+	struct gpio_edge_desc *e;
+
+	spin_lock_irqsave(&gpio_edge_lock, flags);
+
+	if (list_empty(&gpio_edge_list)) {
+		spin_unlock_irqrestore(&gpio_edge_lock, flags);
+		return;
+	}
+
+	list_for_each_entry(e, &gpio_edge_list, list) {
+		mfp_config_edge(e->mfp, e->type);
+	}
+
+	gpio_edge_icu_enable();
+	gpio_edge_wakeup_enable();
+
+	gpio_edge_enabled = 1;
+	spin_unlock_irqrestore(&gpio_edge_lock, flags);
+}
+
+/*
+ * Disable the corresponing interrupt in the ICU. Check the gpio edge status
+ * and call the handler if exist. Disable all the edge wakeup source in the
+ * list. Call the function after exit low power mode.
+ */
+unsigned long gpio_wp_stat[6];
+
+void mmp_gpio_edge_disable(void)
+{
+	struct gpio_edge_desc *e;
+	int i;
+
+	unsigned long gpioe_rer[6];
+
+	BUG_ON(!gpio_edge_base);
+
+	spin_lock_irqsave(&gpio_edge_lock, flags);
+
+	if (!gpio_edge_enabled) {
+		spin_unlock_irqrestore(&gpio_edge_lock, flags);
+		return;
+	}
+
+	gpio_edge_wakeup_disable();
+	gpio_edge_icu_disable();
+
+	for (i = 0; i < (gpio_edge_gpio_num / 32); i++) {
+		gpioe_rer[i] = __raw_readl(gpio_edge_base + i * 4);
+		gpio_wp_stat[i] = gpioe_rer[i];
+	}
+
+	list_for_each_entry(e, &gpio_edge_list, list) {
+		if (test_and_clear_bit(e->gpio, gpioe_rer) && e->handler)
+			e->handler(e->mfp, e->data);
+		mfp_config_edge(e->mfp, MFP_LPM_EDGE_NONE);
+	}
+
+	i = find_first_bit(gpioe_rer, gpio_edge_gpio_num);
+	while (i < gpio_edge_gpio_num) {
+		pr_err("error: gpio edge: unexpected detect: %d\n", i);
+		mfp_config_edge(i, MFP_LPM_EDGE_NONE);
+		i = find_next_bit(gpioe_rer, gpio_edge_gpio_num, i + 1);
+	}
+
+	gpio_edge_enabled = 0;
+	spin_unlock_irqrestore(&gpio_edge_lock, flags);
+}
+
+void mmp_gpio_edge_init(void __iomem *base, int mfp_num, int gpio_num)
+{
+	INIT_LIST_HEAD(&gpio_edge_list);
+	gpio_edge_base = base;
+	gpio_edge_mfp_num = mfp_num;
+	gpio_edge_gpio_num = gpio_num;
+}
diff --git a/arch/arm/mach-mmp/gpu_mem.c b/arch/arm/mach-mmp/gpu_mem.c
new file mode 100644
index 00000000..3b438de5
--- /dev/null
+++ b/arch/arm/mach-mmp/gpu_mem.c
@@ -0,0 +1,209 @@
+/*
+*  arch/arm/plat-pxa/gpu_mem.c
+*
+*  GPU reserved memory management
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License version 2 as
+*  published by the Free Software Foundation.
+*
+*  (C) Copyright 2011 Marvell International Ltd.
+*  All Rights Reserved
+*/
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/memblock.h>
+#include <mach/gpu_mem.h>
+
+#ifdef CONFIG_ARCH_MMP
+#include <mach/cputype.h>
+#elif defined(CONFIG_ARCH_PXA)
+#include <mach/hardware.h>
+#endif
+
+#define DEVICE_NAME_GC	   "galcore"
+
+#define MAKE_GPU_PARAM_X(plat, irq, regBase, regSize, memSize, memBase) \
+{							   \
+	.name = plat,			   \
+	.irqLine = irq,			 \
+	.registerMemBase = regBase, \
+	.registerMemSize = regSize, \
+	.contiguousSize  = memSize, \
+	.contiguousBase  = memBase, \
+}
+
+struct gpu_param_table {
+	const char *name;
+	int irqLine;
+	ulong registerMemBase;
+	ulong registerMemSize;
+	long contiguousSize;
+	ulong contiguousBase;
+};
+
+static struct gpu_param_table gpu_params[] = {
+	/* dkbttc, dkbtd */
+	MAKE_GPU_PARAM_X("ttctd", 8, 0xc0400000, 0x40000, 0x2000000, 0x0),
+	/* brownstone, g50 */
+	MAKE_GPU_PARAM_X("mmp2", 8, 0xd420d000, 0x40000, 0x4000000, 0x0),
+	/* abilene */
+	MAKE_GPU_PARAM_X("mmp3", 137, 0xd420d000, 0x40000, 0x2000000, 0x0),
+	/* 988 */
+	MAKE_GPU_PARAM_X("988", 40, 0xC0400000, 0x2000, 0x4000000, 0x0),
+	/* mg1, mg2, nevo */
+	MAKE_GPU_PARAM_X("mg", 70, 0x54000000, 0x40000, 0x2000000, 0x0),
+	/*1x88: 1T88/1L88*/
+	MAKE_GPU_PARAM_X("1x88", 40, 0xC0400000, 0x1000, 0x4000000, 0x0),
+};
+
+static struct resource gpu_resources[] = {
+	{
+		.name = "gpu_irq",
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.name = "gpu_base",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name   = "gpu_mem",
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+/*default reserve size:16MB*/
+static size_t  __initdata gpu_reserve_size = 0x1000000;
+static phys_addr_t __initdata gpu_reserve_pa;
+
+static int __init pxa_reserve_gpu_early_init(char *arg)
+{
+	gpu_reserve_size = memparse(arg, &arg);
+	return 0;
+}
+early_param("reserve_gpu", pxa_reserve_gpu_early_init);
+
+static int __init __prepare_gpu_resources(void)
+{
+	int index = -1;
+	ulong memSize = 0;
+
+#ifdef CONFIG_ARCH_MMP
+	if (cpu_is_pxa910()) {
+		index = 0;
+	} else if (cpu_is_mmp2()) {
+		index = 1;
+	} else if (cpu_is_mmp3()) {
+		index = 2;
+#ifdef CONFIG_CPU_PXA988
+	} else if (cpu_is_pxa988() || cpu_is_pxa986()) {
+		index = 3;
+#endif
+#ifdef CONFIG_CPU_PXA1088
+	} else if (cpu_is_pxa1088()) {
+		index = 5;
+#endif
+#ifdef CONFIG_CPU_PXA1L88
+	} else if (cpu_is_pxa1L88()) {
+		index = 5;
+#endif
+#elif defined(CONFIG_ARCH_PXA)
+	if (cpu_is_pxa95x()) {
+		index = 4;
+#endif
+	} else {
+		pr_err("%s: can't recognize chip!\n", __func__);
+		return -ENODEV;
+	}
+
+	memSize = gpu_reserve_size;
+
+	gpu_resources[0].start = gpu_params[index].irqLine;
+	gpu_resources[0].end   = gpu_params[index].irqLine;
+
+	gpu_resources[1].start = gpu_params[index].registerMemBase;
+	gpu_resources[1].end   = gpu_params[index].registerMemBase +
+				gpu_params[index].registerMemSize - 1;
+	gpu_resources[2].start = gpu_reserve_pa;
+	gpu_resources[2].end   = gpu_reserve_pa + gpu_reserve_size - 1;
+
+	return 0;
+}
+
+static int __init __pxa_add_gpu(
+			const char *name,
+			size_t size,
+			int cached,
+			int buffered
+)
+{
+	int ret = 0;
+	struct platform_device *gpu_device;
+
+	ret = __prepare_gpu_resources();
+	if (ret) {
+		pr_err("galcore: initialize gpu_resources failed.\n");
+		goto out;
+	}
+
+	/* Allocate device */
+	gpu_device = platform_device_alloc(name, -1);
+	if (!gpu_device) {
+		pr_err("galcore: platform_device_alloc failed.\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* Insert resource */
+	ret = platform_device_add_resources(gpu_device, gpu_resources, 3);
+	if (ret) {
+		pr_err("galcore: platform_device_add_resources failed.\n");
+		goto put_dev;
+	}
+
+	/* Add device */
+	ret = platform_device_add(gpu_device);
+	if (ret) {
+		pr_err("galcore: platform_device_add failed.\n");
+		goto del_dev;
+	}
+
+	goto out;
+
+del_dev:
+	platform_device_del(gpu_device);
+put_dev:
+	platform_device_put(gpu_device);
+
+out:
+	return ret;
+}
+
+void __init pxa_reserve_gpu_memblock(void)
+{
+	if (!gpu_reserve_size) {
+		pr_err("%s: gpu reserve size is 0\n", __func__);
+		return;
+	}
+
+	gpu_reserve_pa = memblock_alloc(gpu_reserve_size, PAGE_SIZE);
+	if (!gpu_reserve_pa) {
+		pr_err("%s: failed to reserve %dMB\n",
+			   __func__, (unsigned)gpu_reserve_size/0x100000);
+		return;
+	}
+
+	pr_info("Reserved GC memory: %dMB at %#.8x\n",
+		   (unsigned)gpu_reserve_size/0x100000,
+		   (unsigned)gpu_reserve_pa);
+}
+
+void __init pxa_add_gpu(void)
+{
+	__pxa_add_gpu(DEVICE_NAME_GC, gpu_reserve_size, 0, 0);
+}
diff --git a/arch/arm/mach-mmp/helpfunc_v7.S b/arch/arm/mach-mmp/helpfunc_v7.S
new file mode 100644
index 00000000..8a5fc53e
--- /dev/null
+++ b/arch/arm/mach-mmp/helpfunc_v7.S
@@ -0,0 +1,115 @@
+/*
+ * linux/arch/arm/mach-mmp/head_v7.S
+ *
+ * Copyright (C) 2012 Marvell, Inc.
+ *
+ * Author: Neil Zhang <zhangwm@marvell.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/linkage.h>
+#include <asm/cache.h>
+#include <asm/assembler.h>
+#include <asm/hardware/cache-l2x0.h>
+
+
+#ifdef CONFIG_CPU_CA9MP
+/*
+ * Marvell specific entry point for secondary CPUs.
+ * The secondary kernel init calls v7_flush_dcache_all before it enables
+ * the L1; however, the L1 comes out of reset in an undefined state, so
+ * the clean + invalidate performed by v7_flush_dcache_all causes a bunch
+ * of cache lines with uninitialized data and uninitialized tags to get
+ * written out to memory, which does really unpleasant things to the main
+ * processor.  We fix this by performing an invalidate, rather than a
+ * clean + invalidate for secondary core, before jumping into the kernel.
+ *
+ * This funciton is cloned from arch/arm/mach-tegra/headsmp.S, and needs
+ * to be called for both secondary cores startup and primary core resume
+ * procedures.
+ */
+	.align L1_CACHE_SHIFT
+
+ENTRY(v7_invalidate_l1)
+        mov     r0, #0
+        mcr     p15, 2, r0, c0, c0, 0
+        mrc     p15, 1, r0, c0, c0, 0
+
+        ldr     r1, =0x7fff
+        and     r2, r1, r0, lsr #13
+
+        ldr     r1, =0x3ff
+
+        and     r3, r1, r0, lsr #3  @ NumWays - 1
+        add     r2, r2, #1          @ NumSets
+
+        and     r0, r0, #0x7
+        add     r0, r0, #4          @ SetShift
+
+        clz     r1, r3              @ WayShift
+        add     r4, r3, #1          @ NumWays
+1:      sub     r2, r2, #1          @ NumSets--
+        mov     r3, r4              @ Temp = NumWays
+2:      subs    r3, r3, #1          @ Temp--
+        mov     r5, r3, lsl r1
+        mov     r6, r2, lsl r0
+        orr     r5, r5, r6          @ Reg = (Temp<<WayShift)|(NumSets<<SetShift)
+        mcr     p15, 0, r5, c7, c6, 2
+        bgt     2b
+        cmp     r2, #0
+        bgt     1b
+        dsb
+        isb
+        mov     pc, lr
+ENDPROC(v7_invalidate_l1)
+#endif
+
+#ifdef CONFIG_CACHE_L2X0
+/*
+ * Clean and invalidate the L2 cache and then disable it.
+ * Common cache-l2x0.c functions can't be used here since it
+ * uses spinlocks. We are out of coherency here with data cache
+ * disabled. The spinlock implementation uses exclusive load/store
+ * instruction which can fail without data cache being enabled.
+ * Because of this, CPU can lead to deadlock.
+ * We need to call this function with MMU on since l2x0_base is
+ * virtual adress.
+ */
+ENTRY(pl310_disable)
+	ldr	r2, =l2x0_base
+	ldr	r2, [r2]
+	/* Clean & invalidate */
+	ldr	r0, =0xffff
+	str	r0, [r2, #L2X0_CLEAN_INV_WAY]
+wait:
+	ldr	r0, [r2, #L2X0_CLEAN_INV_WAY]
+	ldr	r1, =0xffff
+	ands	r0, r0, r1
+	bne	wait
+	/* Sync */
+	mov	r0, #0x0
+	str	r0, [r2, #L2X0_CACHE_SYNC]
+	/* Disable L2 */
+	mov	r0, #0
+	str	r0, [r2, #L2X0_CTRL]
+	dsb
+	mov	pc, lr
+ENDPROC(pl310_disable)
+#endif
+
+#ifdef CONFIG_ARCH_PROVIDES_UDELAY
+ENTRY(__delay)
+	subs    r0, r0, #1
+	bhi     __delay
+	mov     pc, lr
+ENDPROC(__delay)
+#endif /* CONFIG_ARCH_PROVIDES_UDELAY */
diff --git a/arch/arm/mach-mmp/include/mach/Quicklogic_Vxbridge_interface.h b/arch/arm/mach-mmp/include/mach/Quicklogic_Vxbridge_interface.h
new file mode 100755
index 00000000..1a8feb2b
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/Quicklogic_Vxbridge_interface.h
@@ -0,0 +1,255 @@
+/*
+* Copyright (C) 2006-2013, Samsung Electronics Co., Ltd. All Rights Reserved.
+* Written by System S/W Group, Mobile Communication Division.
+*/
+
+#ifndef __VX6B3E_H
+#define __VX6B3E_H
+
+#if defined (CONFIG_MACH_CS05) || defined(CONFIG_MACH_DEGAS)
+extern int vx6b3e_brige_init(struct pxa168fb_info *fbi);
+extern int vx6b3e_reset(void);
+extern int vx6b3e_power(struct pxa168fb_info *fbi, int on);
+extern int hx8369_backlight_updata(void);
+extern int mpmu_vcxoen(void);
+extern int get_panel_id(void);
+
+/* CABC PWM */
+static char hx8369b_backlight_51h[] = {
+	0x51,
+	0x00, 0x3C
+};
+
+#define VX6B3E_CONTROL_BY_I2C
+
+#define VX6B3E_PWR_EN_VXE_1P8 64
+#define VX6B3E_PWR_EN_VXE_1P2 63
+#define VX6B3E_RESET 125
+/*13M_EN FOR F/F*/
+#define GPIO_13M_EN (30)
+/*LCD/VX Bridge HW switch*/
+#define GPIO18_LCD_RESET (18)
+#endif
+
+#if defined(CONFIG_MACH_GOYA)
+extern int vx5b3d_brige_init(struct pxa168fb_info *fbi);
+extern int vx5b3d_power(struct pxa168fb_info *fbi, int on);
+extern int lcd_power(struct pxa168fb_info * fbi, int on);
+extern int get_panel_id(void);
+
+/*Vee strenght*/
+#define V5D3BX_VEESTRENGHT		0x00001f07
+#define V5D3BX_VEEDEFAULTVAL		0
+#define V5D3BX_DEFAULT_STRENGHT		5
+#define V5D3BX_DEFAULT_LOW_STRENGHT	8
+#define V5D3BX_DEFAULT_HIGH_STRENGHT	10
+#define V5D3BX_MAX_STRENGHT		15
+
+#define V5D3BX_CABCBRIGHTNESSRATIO	815 /*18P5%*/
+
+#define LVDS_CLK_48P05Mhz		0
+#define LVDS_CLK_50P98Mhz		1
+#define V5D3BX_6P3KHZ_DEFAULT_RATIO	8000
+#define V5D3BX_6P3KHZ_REG_VALUE		2040
+
+/*VX Bridge Power*/
+#define VX5B3D_PWR_EN_VXE_3P3	19
+#define LED_BACK_LIGHT_RST	12
+#define VX5B3D_RST 20
+#define GOYA_LCD_3P3 9
+
+/*Panel type*/
+#define HX8282A_PANEL_BOE 0x0
+#define HX8282A_PANEL_SDC 0x1
+#define HX8282A_PANEL_CPT 0x2
+#define HX8282A_PANEL_HIMAX 0x3
+#define HX8282A_PANEL_NONE 0x4
+
+extern int board_version;
+extern unsigned int system_rev;
+#endif
+
+
+/**************************************************
+*	Common Interface of Quicklogic Bridge IC		*
+***************************************************/
+#if defined(CONFIG_QUICKLOGIC_BRIDGE)
+
+extern int Quicklogic_mipi_write(struct pxa168fb_info *fbi, \
+					u32 address, u32 value, u32 data_size);
+extern int Quicklogic_i2c_read32(u16 reg, u32 *pval);
+extern int Quicklogic_i2c_read(u32 addr, u32 *val, u32 data_size);
+extern int Quicklogic_i2c_write32(u16 reg, u32 val);
+extern int Quicklogic_i2c_release(void);
+extern int Quicklogic_i2cTomipi_write(int dtype, int vit_com, \
+					u8 data_size, u8 *ptr );
+extern int Quicklogic_i2cTomipi_read(int dtype, int vit_com, \
+					u8 data_size, u8 reg , u8 *pval);
+
+/*For shared I2C with Touch*/
+extern void i2c1_pin_changed(int gpio);
+#if  defined(CONFIG_SPA) || defined(CONFIG_SPA_LPM_MODE)
+extern int spa_lpm_charging_mode_get();
+#else
+extern unsigned int lpcharge;
+#endif
+#endif
+
+#define QUICKLOGIC_MIPI_VENDOR_ID_1		0x5
+#define QUICKLOGIC_MIPI_VENDOR_ID_2		0x1
+#define QUICKLOGIC_MIPI_COMMAND_CSR_WRITE	0x40
+#define QUICKLOGIC_MIPI_COMMAND_CSR_OFFSET	0x41
+
+#define QUICKLOGIC_IIC_READ_CONTROL 0x0E
+#define QUICKLOGIC_IIC_WRITE_CONTROL 0x0A
+#define QUICKLOGIC_BYTE_I2C_RELEASE (0x0u)
+#define QUICKLOGIC_IIC_RELEASE  {\
+		QUICKLOGIC_BYTE_I2C_RELEASE, \
+}
+
+#define QL_MIPI_PANEL_CMD_SIZE 255
+#define QL_VX_LCD_VC 0			/* dcs read/write */
+#define CONTROL_BYTE_DCS       (0x08u)
+#define CONTROL_BYTE_GEN       (0x09u)
+
+#define DTYPE_DCS_WRITE		0x05	/* short write, 0 parameter */
+#define DTYPE_DCS_WRITE1	0x15	/* short write, 1 parameter */
+#define DTYPE_DCS_READ		0x06	/* read */
+#define DTYPE_DCS_LWRITE	0x39	/* long write *//* generic read/write */
+#define DTYPE_GEN_WRITE		0x03	/* short write, 0 parameter */
+#define DTYPE_GEN_WRITE1	0x13	/* short write, 1 parameter */
+#define DTYPE_GEN_WRITE2	0x23	/* short write, 2 parameter */
+#define DTYPE_GEN_LWRITE	0x29	/* long write */
+#define DTYPE_GEN_READ		0x04	/* long read, 0 parameter */
+#define DTYPE_GEN_READ1		0x14	/* long read, 1 parameter */
+#define DTYPE_GEN_READ2		0x24	/* long read, 2 parameter */
+
+/*Brightness level*/
+#define MIN_BRIGHTNESS			0
+#define MAX_BRIGHTNESS_LEVEL		255
+#define MID_BRIGHTNESS_LEVEL		195
+#define LOW_BRIGHTNESS_LEVEL		20
+#define DIM_BRIGHTNESS_LEVEL		19
+#define DEFAULT_BRIGHTNESS		MID_BRIGHTNESS_LEVEL
+#define AUTOBRIGHTNESS_LIMIT_VALUE	207
+
+#define LOW_BATTERY_LEVEL		10
+#define MINIMUM_VISIBILITY_LEVEL	30
+
+/**************************************************
+*		QUICKLOGIC MACRO FOR MIPI		*
+***************************************************/
+static char quicklogic_csr_wr_payload[9] = {
+					QUICKLOGIC_MIPI_VENDOR_ID_1,
+					QUICKLOGIC_MIPI_VENDOR_ID_2,
+					QUICKLOGIC_MIPI_COMMAND_CSR_WRITE,
+					0x0, 0x0,	/* address 16bits */
+					0x0, 0x0, 0x0, 0x0 /* data max 32bits */
+};
+
+
+/**************************************************
+*		QUICKLOGIC MACRO FOR I2C			*
+***************************************************/
+#define GEN_QL_CSR_OFFSET_LENGTH  {\
+		CONTROL_BYTE_GEN, \
+        0x29,  /* Data ID */\
+        0x05,  /* Vendor Id 1 */\
+        0x01,  /* Vendor Id 2 */\
+        0x41,  /* Vendor Unique Command */\
+        0x00,  /* Address LS */\
+        0x00,  /* Address MS */\
+        0x00,  /* Length LS */\
+        0x00,  /* Length MS */\
+    }
+
+#define GEN_QL_CSR_WRITE  {\
+		CONTROL_BYTE_GEN, \
+        0x29,  /* Data ID */\
+        0x05,  /* Vendor Id 1 */\
+        0x01,  /* Vendor Id 2 */\
+        0x40,  /* Vendor Unique Command */\
+        0x00,  /* Address LS */\
+        0x00,  /* Address MS */\
+        0x00,  /* data LS */\
+	0x00, \
+	0x00, \
+        0x00,  /* data MS */\
+    }
+
+/**************************************************
+*		Structure for QUICKLOGIC Driver control	*
+***************************************************/
+enum CABC {
+	CABC_OFF,
+	CABC_ON,
+	CABC_MAX,
+};
+
+struct Quicklogic_backlight_value {
+	const unsigned int max;
+	const unsigned int mid;
+	const unsigned char low;
+	const unsigned char dim;
+};
+
+typedef struct Quicklogic_bridge_info {
+	enum CABC			cabc;
+
+	struct class			*mdnie;
+	struct device			*dev_mdnie;
+	struct device			*dev_bd;
+
+	struct backlight_device		*bd;
+	struct lcd_device		*lcd;
+	struct Quicklogic_backlight_value	*vee_lightValue;
+	struct mutex			lock;
+	struct mutex			pwr_lock;
+	struct mutex			lvds_clk_switch_lock;
+
+	unsigned int			auto_brightness;
+	unsigned int			vee_strenght;
+	unsigned int			prevee_strenght;
+	unsigned int			first_count;
+	unsigned int			lcd_panel;
+	unsigned int			lvds_clk;
+	unsigned int			orig_lvds_clk;
+	unsigned int			quick_bl_frq;
+	unsigned int			vx5b3d_backlight_frq;	
+	int				lvds_clk_switching;
+	int				vx5b3d_enable;
+	int				negative;
+	unsigned int			current_bl;
+};
+
+static struct Quicklogic_backlight_value backlight_table[5] = {
+	{	/*BOE*/
+	.max = 254,
+	.mid = 135,
+	.low = 2,
+	.dim = 1,
+	}, {	/*SDC*/
+	.max = 254,
+	.mid = 135,
+	.low = 2,
+	.dim = 1,
+	}, {	/*CPT*/
+	.max = 254,
+	.mid = 135,
+	.low = 2,
+	.dim = 1,
+	}, {	/*HIMAX*/
+	.max = 254,
+	.mid = 135,
+	.low = 2,
+	.dim = 1,
+	}, {	/*NONE*/
+	.max = 254,
+	.mid = 135,
+	.low = 2,
+	.dim = 1,
+	}
+};
+
+#endif
+
diff --git a/arch/arm/mach-mmp/include/mach/addr-map.h b/arch/arm/mach-mmp/include/mach/addr-map.h
index b1ece081..3cc85884 100644
--- a/arch/arm/mach-mmp/include/mach/addr-map.h
+++ b/arch/arm/mach-mmp/include/mach/addr-map.h
@@ -31,4 +31,79 @@
 #define SMC_CS1_PHYS_BASE	0x90000000
 #define SMC_CS1_PHYS_SIZE	0x10000000
 
+#define APMU_VIRT_BASE		(AXI_VIRT_BASE + 0x82800)
+#define APMU_REG(x)		(APMU_VIRT_BASE + (x))
+
+#define APBC_VIRT_BASE		(APB_VIRT_BASE + 0x015000)
+#define APBC_REG(x)		(APBC_VIRT_BASE + (x))
+
+#define APBCP_VIRT_BASE		(APB_VIRT_BASE + 0x03B000)
+#define APBCP_REG(x)		(APBCP_VIRT_BASE + (x))
+
+#define MPMU_VIRT_BASE		(APB_VIRT_BASE + 0x50000)
+#define MPMU_REG(x)		(MPMU_VIRT_BASE + (x))
+
+#define CIU_VIRT_BASE		(AXI_VIRT_BASE + 0x82c00)
+#define CIU_REG(x)		(CIU_VIRT_BASE + (x))
+
+#ifdef CONFIG_CPU_MMP3
+#define AUD_PHYS_BASE		0xc0ffd800
+#define AUD_VIRT_BASE		IOMEM(0xfeffd800)
+#define AUD_PHYS_SIZE		SZ_2K
+
+#define AUD_PHYS_BASE2		0xc0140000
+#define AUD_VIRT_BASE2		IOMEM(0xfef40000)
+#define AUD_PHYS_SIZE2		0x00010000
+#endif
+
+#if defined(CONFIG_CPU_PXA988)
+#define PERI_PHYS_BASE		0xd1dfe000
+#define SL2C_PHYS_BASE		0xd1dfb000
+#elif defined(CONFIG_CPU_PXA1088)
+#define PERI_PHYS_BASE		0xd1df8000
+#elif defined(CONFIG_CPU_MMP3)
+#define PERI_PHYS_BASE		0xe0000000
+#define SL2C_PHYS_BASE		0xd0020000
+#elif defined(CONFIG_CPU_EDEN)
+#define PERI_PHYS_BASE		0xd1e00000
+#endif
+#define PERI_VIRT_BASE		IOMEM(0xfe400000)
+
+#define GIC_DIST_VIRT_BASE	(PERI_VIRT_BASE + 0x1000)
+#if defined(CONFIG_CPU_CA9MP) || defined(CONFIG_CPU_PJ4B)
+#define SCU_PHYS_BASE		PERI_PHYS_BASE
+#define SCU_VIRT_BASE		PERI_VIRT_BASE
+#define GIC_CPU_VIRT_BASE	(PERI_VIRT_BASE + 0x0100)
+#define TWD_VIRT_BASE		(PERI_VIRT_BASE + 0x0600)
+#define TWD_PHYS_BASE		(PERI_PHYS_BASE + 0x0600)
+#define PERI_PHYS_SIZE		0x00002000
+#elif defined(CONFIG_CPU_CA7MP)
+#define GIC_CPU_VIRT_BASE	(PERI_VIRT_BASE + 0x2000)
+#define PERI_PHYS_SIZE		0x00008000
+#endif
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define DMCU_PHYS_BASE		0xc0100000
+#define DMCU_VIRT_BASE		0xfe500000
+#define DMCU_PHYS_SIZE		0x00010000
+#endif
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_MMP3)
+#define SL2C_VIRT_BASE		0xfe800000
+#define SL2C_PHYS_SIZE		SZ_8K
+#endif
+
+#define SRAM_PHYS_BASE		0xd1000000
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define SRAM_CP_BASE		SRAM_PHYS_BASE
+#define SRAM_CP_SIZE		0x4000
+
+#define SRAM_AUDIO_BASE		(SRAM_CP_BASE + SRAM_CP_SIZE)
+#define SRAM_AUDIO_SIZE		0xaa00
+
+#define SRAM_VIDEO_BASE		(SRAM_AUDIO_BASE + SRAM_AUDIO_SIZE)
+#define SRAM_VIDEO_SIZE		0x11600
+#endif
+
 #endif /* __ASM_MACH_ADDR_MAP_H */
diff --git a/arch/arm/mach-mmp/include/mach/camera.h b/arch/arm/mach-mmp/include/mach/camera.h
new file mode 100644
index 00000000..75bf0f0b
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/camera.h
@@ -0,0 +1,118 @@
+#ifndef __ASM_ARCH_CAMERA_H__
+#define __ASM_ARCH_CAMERA_H__
+
+#include <media/mrvl-camera.h>
+#ifdef CONFIG_VIDEO_MRVL_CAM_DEBUG
+#include <media/mc_debug.h>
+#endif
+#if defined(CONFIG_MACH_LT02)
+struct mmp_cam_pdata {
+	/* CCIC_GATE, CCIC_RST, CCIC_DBG, CCIC_DPHY clocks */
+	struct clk *clk[4];
+	char *name;
+	int clk_enabled;
+	int dphy[3];		/* DPHY: CSI2_DPHY3, CSI2_DPHY5, CSI2_DPHY6 */
+	int dphy3_algo;		/* Exist 2 algos for calculate CSI2_DPHY3 */
+	int bus_type;
+	int mipi_enabled;	/* MIPI enabled flag */
+	int lane;		/* ccic used lane number; 0 means DVP mode */
+	int dma_burst;
+	int mclk_min;
+	int mclk_src;
+	int mclk_div;
+	void (*init_pin)(struct device *dev, int on);
+	int (*init_clk)(struct device *dev, int init);
+	void (*enable_clk)(struct device *dev, int on);
+};
+
+#else
+
+struct mmp_cam_pdata {
+	/* CCIC_GATE, CCIC_RST, CCIC_DBG, CCIC_DPHY clocks */
+	struct clk *clk[4];
+	char *name;
+	int dma_burst;
+	int mclk_min;
+	int mclk_src;
+	int mclk_div;
+	int (*init_pin)(struct device *dev, int on);
+	int (*init_clk)(struct device *dev);
+	/*
+	 * @on use 2 bits descript:
+	 * bit 0: 1 - enable;	0 - disable
+	 * bit 1: 1 - mipi;	0 - parallel
+	 */
+	void (*enable_clk)(struct device *dev, int on);
+};
+#endif
+
+
+struct sensor_power_data {
+	unsigned char *sensor_name; /*row sensor name  */
+	int rst_gpio; /* sensor reset GPIO */
+	int pwdn_gpio;  /* sensor power enable GPIO*/
+	int rst_en; /* sensor reset value: 0 or 1 */
+	int pwdn_en; /* sensor power value: 0 or 1*/
+	const char *afvcc;
+	const char *avdd;
+	int afvcc_uV;
+	int avdd_uV;
+};
+
+struct sensor_type {
+	unsigned char chip_id;
+	unsigned char *sensor_name;
+	unsigned int reg_num;
+	long reg_pid[3];/* REG_PIDH REG_PIDM REG_PIDL */
+	/* REG_PIDH_VALUE REG_PIDM_VALUE REG_PIDL_VALUE */
+	unsigned char reg_pid_val[3];
+};
+
+struct sensor_platform_data {
+	int *chip_ident_id;
+	struct sensor_power_data *sensor_pwd;
+	struct sensor_type *sensor_cid;
+	int sensor_num;
+	int flash_enable;	/* Flash enable data; -1 means invalid */
+	int (*power_on)(int);
+};
+
+//extern int camera_power_reset;
+//extern int camera_power_standby;
+extern int camera_flash_en;
+extern int camera_flash_set;
+
+/*++ Marvell_VIA Flash Setting(KTD2692) : dhee79.lee@samsung.com ++*/
+#ifdef CONFIG_MACH_DELOS3GVIA
+/* KTD2692 : command time delay(us) */
+#define T_DS		12
+#define T_EOD_H		350
+#define T_EOD_L		4
+#define T_H_LB		3
+#define T_L_LB		2*T_H_LB
+#define T_L_HB		3
+#define T_H_HB		2*T_L_HB
+#define T_RESET		700
+/* KTD2692 : command address(A2:A0) */
+#define LVP_SETTING		0x0 << 5
+#define FLASH_TIMEOUT	0x1 << 5
+#define MIN_CURRENT		0x2 << 5
+#define MOVIE_CURRENT	0x3 << 5
+#define FLASH_CURRENT	0x4 << 5
+#define MODE_CONTROL	0x5 << 5
+
+extern void KTD2692_ctrl_cmd(unsigned int ctl_cmd);
+#endif
+/*-- Marvell_VIA Flash Setting(KTD2692) : dhee79.lee@samsung.com --*/
+
+
+int isppwr_power_control(int on);
+
+#ifdef CONFIG_VIDEO_MRVL_CAM_DEBUG
+struct ccic_mcd {
+	struct mcd              mcd;
+	struct mcd_entity       *pitem[MCD_ENTITY_END];
+};
+#endif /* CONFIG_VIDEO_MRVL_CAM_DEBUG */
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/clock-pxa988.h b/arch/arm/mach-mmp/include/mach/clock-pxa988.h
new file mode 100644
index 00000000..ab87f681
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/clock-pxa988.h
@@ -0,0 +1,219 @@
+#ifndef __MACH_CLK_PXA988_H
+#define __MACH_CLK_PXA988_H
+
+#include <linux/clk.h>
+#include <linux/kernel_stat.h>
+#include <linux/tick.h>
+#include <plat/clock.h>
+#include <linux/time.h>
+#include <asm/cputime.h>
+
+enum {
+	CORE_900M = 902,
+	CORE_1p1G = 1101,
+	CORE_1p3G = 1283,
+#if !defined(CONFIG_CORE_1248)
+	CORE_1p2G = 1205,
+#else
+	CORE_1p2G = 1248,
+#endif
+	CORE_1p18G = 1183,
+	CORE_1p5G = 1482,
+};
+
+extern unsigned long max_freq;
+extern void pxa988_init_one_clock(struct clk *c);
+extern int is_pxa988a0svc;
+extern int is_pxa986a0svc;
+
+extern int ddr_mode;
+extern int is_pxa988a0svc;
+/* Interface used to get components avaliable rates, unit Khz */
+extern unsigned int pxa988_get_vpu_op_num(void);
+extern unsigned int pxa988_get_vpu_op_rate(unsigned int index);
+
+extern unsigned int pxa988_get_ddr_op_num(void);
+extern unsigned int pxa988_get_ddr_op_rate(unsigned int index);
+
+extern unsigned int get_profile(void);
+extern int get_max_cpurate(void);
+
+#ifdef CONFIG_DEBUG_FS
+#define MAX_BREAKDOWN_TIME 11
+/* use the largest possible number is 10 */
+#define MAX_LPM_INDEX_DC  10
+
+struct op_dcstat_info {
+	unsigned int ppindex;
+	unsigned long pprate;
+	struct timespec prev_ts;
+	long idle_time;		/* ms */
+	long busy_time;		/* ms */
+	/* used for core stat */
+	cputime64_t prev_cpu_idle;
+	cputime64_t prev_cpu_wall;
+};
+
+struct idle_dcstat_info {
+	ktime_t all_idle_start;
+	ktime_t all_idle_end;
+	s64 total_all_idle;
+	s64 total_all_idle_count;
+	ktime_t all_active_start;
+	ktime_t all_active_end;
+	s64 total_all_active;
+	s64 total_all_active_count;
+	ktime_t M2_idle_start;
+	s64 M2_idle_total;
+	s64 M2_count;
+	ktime_t D1P_idle_start;
+	s64 D1P_idle_total;
+	s64 D1p_count;
+	ktime_t D1_idle_start;
+	s64 D1_idle_total;
+	s64 D1_count;
+	ktime_t D2_idle_start;
+	s64 D2_idle_total;
+	s64 D2_count;
+	s64 cal_duration;
+	s64 all_idle_op_total[MAX_LPM_INDEX_DC];
+	int all_idle_op_index;
+	u64 all_idle_count[MAX_LPM_INDEX_DC];
+};
+
+struct clk_dc_stat_info {
+	bool stat_start;
+	struct op_dcstat_info *ops_dcstat;
+	u32 power_mode;
+	unsigned int idle_flag;
+	unsigned int ops_stat_size;
+	unsigned int curopindex;
+	ktime_t C1_idle_start;
+	ktime_t C1_idle_end;
+	s64 C1_op_total[MAX_LPM_INDEX_DC];
+	int C1_op_index;
+	u64 C1_count[MAX_LPM_INDEX_DC];
+	ktime_t C2_idle_start;
+	ktime_t C2_idle_end;
+	s64 C2_op_total[MAX_LPM_INDEX_DC];
+	int C2_op_index;
+	u64 C2_count[MAX_LPM_INDEX_DC];
+	ktime_t breakdown_start;
+	ktime_t breakdown_end;
+	s64 breakdown_time_total[MAX_BREAKDOWN_TIME+1];
+	s64 breakdown_time_count[MAX_BREAKDOWN_TIME+1];
+};
+
+struct clk_dcstat {
+	struct clk *clk;
+	struct clk_dc_stat_info clk_dcstat;
+	struct list_head node;
+};
+
+enum clk_stat_msg {
+	CLK_STAT_START = 0,
+	CLK_STAT_STOP,
+	CLK_STATE_ON,
+	CLK_STATE_OFF,
+	CLK_RATE_CHANGE,
+	CLK_DYNVOL_CHANGE,
+	CPU_IDLE_ENTER,
+	CPU_IDLE_EXIT,
+	CPU_M2_OR_DEEPER_ENTER,
+};
+
+static inline void clk_get_lock(struct clk *clk)
+{
+	if (clk->cansleep)
+		mutex_lock(&clk->mutex);
+	else
+		spin_lock(&clk->spinlock);
+}
+
+static inline void clk_release_lock(struct clk *clk)
+{
+	if (clk->cansleep)
+		mutex_unlock(&clk->mutex);
+	else
+		spin_unlock(&clk->spinlock);
+}
+
+
+/* function used for clk duty cycle stat */
+static inline long ts2ms(struct timespec cur, struct timespec prev)
+{
+	return (cur.tv_sec - prev.tv_sec) * MSEC_PER_SEC + \
+		(cur.tv_nsec - prev.tv_nsec) / NSEC_PER_MSEC;
+}
+
+static inline u32 calculate_dc(u32 busy, u32 total, u32 *fraction)
+{
+	u32 result, remainder;
+	result = div_u64_rem((u64)(busy * 100), total, &remainder);
+	*fraction = remainder * 100 / total;
+	return result;
+}
+
+static inline u64 get_cpu_idle_time_jiffy(unsigned int cpu,
+		u64 *wall)
+{
+	u64 idle_time;
+	u64 cur_wall_time;
+	u64 busy_time;
+
+	cur_wall_time = jiffies64_to_cputime64(get_jiffies_64());
+
+	busy_time  = kcpustat_cpu(cpu).cpustat[CPUTIME_USER];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_SYSTEM];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_IRQ];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_SOFTIRQ];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_STEAL];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_NICE];
+
+	idle_time = cur_wall_time - busy_time;
+	if (wall)
+		*wall = jiffies_to_usecs(cur_wall_time);
+
+	return jiffies_to_usecs(idle_time);
+}
+
+static inline cputime64_t get_cpu_idle_time(unsigned int cpu,
+		cputime64_t *wall)
+{
+	u64 idle_time = get_cpu_idle_time_us(cpu, NULL);
+
+	if (idle_time == -1ULL)
+		return get_cpu_idle_time_jiffy(cpu, wall);
+	else
+		idle_time += get_cpu_iowait_time_us(cpu, wall);
+
+	return idle_time;
+}
+
+extern struct dentry *stat;
+extern int pxa988_clk_register_dcstat(struct clk *clk,
+	unsigned long *opt, unsigned int opt_size);
+extern int pxa988_clk_dcstat_event(struct clk *clk,
+	enum clk_stat_msg msg, unsigned int tgtstate);
+extern int pxa988_show_dc_stat_info(struct clk *clk,
+	char *buf, ssize_t size);
+extern int pxa988_start_stop_dc_stat(struct clk *clk,
+	unsigned int start);
+extern void pxa988_cpu_dcstat_event(unsigned int cpu,
+		enum clk_stat_msg msg, unsigned int tgtop);
+#endif
+
+#ifdef CONFIG_CPU_PXA988
+#define DDR_COMBINDEDCLK_SOLUTION	1
+#endif
+
+#ifdef DDR_COMBINDEDCLK_SOLUTION
+extern int mck4_wr_enabled;
+extern int trigger_bind2ddr_clk_rate(unsigned long ddr_rate);
+#endif
+
+#define cpu_is_z1z2() \
+	((cpu_is_pxa988_z1() || cpu_is_pxa988_z2()\
+	|| cpu_is_pxa986_z1() || cpu_is_pxa986_z2()))
+
+#endif /* __MACH_CLK_PXA988_H */
diff --git a/arch/arm/mach-mmp/include/mach/cputype.h b/arch/arm/mach-mmp/include/mach/cputype.h
index 8a3b56df..f7bc8398 100644
--- a/arch/arm/mach-mmp/include/mach/cputype.h
+++ b/arch/arm/mach-mmp/include/mach/cputype.h
@@ -2,6 +2,7 @@
 #define __ASM_MACH_CPUTYPE_H
 
 #include <asm/cputype.h>
+#include <asm/io.h>
 
 /*
  *  CPU   Stepping   CPU_ID      CHIP_ID
@@ -17,6 +18,8 @@
  * MMP2	     Z0	   0x560f5811   0x00F00410
  * MMP2      Z1    0x560f5811   0x00E00410
  * MMP2      A0    0x560f5811   0x00A0A610
+ * MMP3	     A0    0x562f5840   0x00A0A620
+ * MMP3	     B0    0x562f5840   0x00B0A620
  */
 
 extern unsigned int mmp_chip_id;
@@ -43,6 +46,126 @@ static inline int cpu_is_pxa910(void)
 #define cpu_is_pxa910()	(0)
 #endif
 
+#ifdef CONFIG_CPU_PXA988
+static inline int cpu_is_pxa988(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09) &&
+		(((mmp_chip_id & 0xffff) == 0xc988) ||
+		((mmp_chip_id & 0xffff) == 0xc928));
+}
+static inline int cpu_is_pxa988_z1(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09) &&
+		((mmp_chip_id & 0xffffff) == 0xf0c928);
+}
+static inline int cpu_is_pxa988_z2(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09) &&
+		((mmp_chip_id & 0xffffff) == 0xf1c988);
+}
+static inline int cpu_is_pxa988_z3(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09) &&
+		((mmp_chip_id & 0xffffff) == 0xf2c988);
+}
+static inline int cpu_is_pxa988_a0(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09) &&
+		((mmp_chip_id & 0xffffff) == 0xa0c928);
+}
+static inline int cpu_is_pxa986(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09) &&
+		(((mmp_chip_id & 0xffff) == 0xc986) ||
+		((mmp_chip_id & 0xffff) == 0xc926));
+}
+static inline int cpu_is_pxa986_z1(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09) &&
+		((mmp_chip_id & 0xffffff) == 0xf0c926);
+}
+static inline int cpu_is_pxa986_z2(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09) &&
+		((mmp_chip_id & 0xffffff) == 0xf1c986);
+}
+static inline int cpu_is_pxa986_z3(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09) &&
+		((mmp_chip_id & 0xffffff) == 0xf2c986);
+}
+static inline int cpu_is_pxa986_a0(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09) &&
+		((mmp_chip_id & 0xffffff) == 0xa0c926);
+}
+
+#else
+#define cpu_is_pxa988()	(0)
+#define cpu_is_pxa988_z1()	(0)
+#define cpu_is_pxa988_z2()	(0)
+#define cpu_is_pxa988_z3()	(0)
+#define cpu_is_pxa988_a0()	(0)
+#define cpu_is_pxa986()	(0)
+#define cpu_is_pxa986_z1()	(0)
+#define cpu_is_pxa986_z2()	(0)
+#define cpu_is_pxa986_z3()	(0)
+#define cpu_is_pxa986_a0()	(0)
+#endif
+
+#ifdef CONFIG_CPU_PXA1088
+static inline int cpu_is_pxa1088(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc07) &&
+		(((mmp_chip_id & 0xffff) == 0x1088));
+}
+
+static inline int cpu_is_pxa1920(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc07) &&
+		(((mmp_chip_id & 0xffff) == 0x1188));
+}
+
+#define BOOT_ROM_VER 0xFFE00028
+#define BOOT_ROM_A0 0x11122012
+#define BOOT_ROM_A1 0x01282013
+
+static inline unsigned long get_bootrom_ver(void)
+{
+	volatile u32 *bootrom_ver_p;
+	static u32 bootrom_ver;
+	static int first_n;
+
+	if (!first_n) {
+		first_n = 1;
+		bootrom_ver_p = ioremap(BOOT_ROM_VER, 4);
+		bootrom_ver = __raw_readl(bootrom_ver_p);
+		iounmap(bootrom_ver_p);
+	}
+
+	return bootrom_ver;
+}
+
+static inline int cpu_is_pxa1088_a0(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc07) &&
+		(((mmp_chip_id & 0xffff) == 0x1088)) &&
+		(get_bootrom_ver() == BOOT_ROM_A0);
+}
+
+static inline int cpu_is_pxa1088_a1(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc07) &&
+		(((mmp_chip_id & 0xffff) == 0x1088)) &&
+		(get_bootrom_ver() == BOOT_ROM_A1);
+}
+#else
+#define cpu_is_pxa1088()	(0)
+#define cpu_is_pxa1088_a0()	(0)
+#define cpu_is_pxa1088_a1()	(0)
+#define cpu_is_pxa1920()	(0)
+#endif
+
 #ifdef CONFIG_CPU_MMP2
 static inline int cpu_is_mmp2(void)
 {
@@ -52,4 +175,59 @@ static inline int cpu_is_mmp2(void)
 #define cpu_is_mmp2()	(0)
 #endif
 
+#ifdef CONFIG_CPU_MMP3
+static inline int cpu_is_mmp3(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0x584);
+}
+static inline int cpu_is_mmp3_a0(void)
+{
+	if (cpu_is_mmp3() && ((mmp_chip_id & 0x00ff0000) == 0x00a00000))
+		return 1;
+	else
+		return 0;
+}
+
+static inline int cpu_is_mmp3_b0(void)
+{
+	if (cpu_is_mmp3() && ((mmp_chip_id & 0x00ff0000) == 0x00b00000))
+		return 1;
+	else
+		return 0;
+}
+#else
+#define cpu_is_mmp3()	(0)
+#endif
+
+#ifdef CONFIG_CPU_MMP3FPGASOC
+static inline int cpu_is_mmp3fpgasoc(void)
+{
+	return ((((read_cpuid_id() >> 4) & 0xfff) == 0xc07) &&
+		((mmp_chip_id & 0xffff) == 0xa620));
+}
+#else
+#define cpu_is_mmp3fpgasoc()	(0)
+#endif
+
+#ifdef CONFIG_CPU_EDEN
+static inline int cpu_is_eden(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc07) &&
+		((mmp_chip_id & 0xffff) == 0xc192);
+}
+#else
+#define cpu_is_eden(id)	(0)
+#endif
+
+static inline int cpu_is_armv7_a7(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc07);
+}
+
+static inline int cpu_is_armv7_a9(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09);
+}
+
+
 #endif /* __ASM_MACH_CPUTYPE_H */
diff --git a/arch/arm/mach-mmp/include/mach/delay.h b/arch/arm/mach-mmp/include/mach/delay.h
new file mode 100644
index 00000000..bd2390c0
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/delay.h
@@ -0,0 +1,41 @@
+/*
+ * arch/arm/mach-mmp/include/mach/delay.h
+ *
+ * Copyright (C) 2011 Marvell, Inc.
+ *
+ * Author:
+ *  Raul Xiong <xjian@marvell.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __MACH_MMP_DELAY_H
+#define __MACH_MMP_DELAY_H
+
+/* needed by loops_per_jiffy calculations */
+extern void __delay(int loops);
+
+extern void __udelay(unsigned long usecs);
+extern void __const_udelay(unsigned long usecs);
+
+/* we don't have any restrictions on maximum udelay length, but we'll enforce
+ * the same restriction as the ARM default so we don't introduce any
+ * incompatibilties in drivers.
+ */
+extern void __bad_udelay(void);
+
+#define MAX_UDELAY_MS 2
+
+#define udelay(n)							\
+	((__builtin_constant_p(n) && (n) > (MAX_UDELAY_MS * 1000)) ?	\
+		__bad_udelay() :					\
+		__udelay(n))
+
+#endif /* defined(__MACH_MMP_DELAY_H) */
diff --git a/arch/arm/mach-mmp/include/mach/devices.h b/arch/arm/mach-mmp/include/mach/devices.h
index d0ec7dae..f2d04fd9 100644
--- a/arch/arm/mach-mmp/include/mach/devices.h
+++ b/arch/arm/mach-mmp/include/mach/devices.h
@@ -38,6 +38,28 @@ struct pxa_device_desc pxa910_device_##_name __initdata = {		\
 	.dma		= { _dma },					\
 };
 
+#define PXA988_DEVICE(_name, _drv, _id, _irq, _start, _size, _dma...)	\
+struct pxa_device_desc pxa988_device_##_name __initdata = {		\
+	.dev_name	= "pxa988-" #_name,				\
+	.drv_name	= _drv,						\
+	.id		= _id,						\
+	.irq		= IRQ_PXA988_##_irq,				\
+	.start		= _start,					\
+	.size		= _size,					\
+	.dma		= { _dma },					\
+}
+
+#define PXA1088_DEVICE(_name, _drv, _id, _irq, _start, _size, _dma...)	\
+struct pxa_device_desc pxa1088_device_##_name __initdata = {		\
+	.dev_name	= "pxa1088-" #_name,				\
+	.drv_name	= _drv,						\
+	.id		= _id,						\
+	.irq		= IRQ_PXA1088_##_irq,				\
+	.start		= _start,					\
+	.size		= _size,					\
+	.dma		= { _dma },					\
+}
+
 #define MMP2_DEVICE(_name, _drv, _id, _irq, _start, _size, _dma...)	\
 struct pxa_device_desc mmp2_device_##_name __initdata = {		\
 	.dev_name	= "mmp2-" #_name,				\
@@ -49,5 +71,30 @@ struct pxa_device_desc mmp2_device_##_name __initdata = {		\
 	.dma		= { _dma },					\
 }
 
+#define MMP3_DEVICE(_name, _drv, _id, _irq, _start, _size, _dma...)	\
+struct pxa_device_desc mmp3_device_##_name __initdata = {		\
+	.dev_name	= "mmp3-" #_name,				\
+	.drv_name	= _drv,						\
+	.id		= _id,						\
+	.irq		= IRQ_MMP3_##_irq,				\
+	.start		= _start,					\
+	.size		= _size,					\
+	.dma		= { _dma },					\
+}
+
+#define EDEN_DEVICE(_name, _drv, _id, _irq, _start, _size, _dma...)	\
+struct pxa_device_desc eden_device_##_name __initdata = {		\
+	.dev_name	= "eden-" #_name,				\
+	.drv_name	= _drv,						\
+	.id		= _id,						\
+	.irq		= IRQ_EDEN_##_irq,				\
+	.start		= _start,					\
+	.size		= _size,					\
+	.dma		= { _dma },					\
+}
+
 extern int pxa_register_device(struct pxa_device_desc *, void *, size_t);
+extern int pxa_usb_phy_init(void __iomem *phy_reg);
+extern void pxa_usb_phy_deinit(void __iomem *phy_reg);
+
 #endif /* __MACH_DEVICE_H */
diff --git a/arch/arm/mach-mmp/include/mach/dvfs.h b/arch/arm/mach-mmp/include/mach/dvfs.h
new file mode 100644
index 00000000..991297f1
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/dvfs.h
@@ -0,0 +1,19 @@
+/*
+ *  linux/arch/arm/mach-mmp/include/mach/dvfs.h
+ *
+ *  Author: Xiaoguang Chen chenxg@marvell.com
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _MACH_MMP_DVFS_H_
+#define _MACH_MMP_DVFS_H_
+#include <plat/dvfs.h>
+
+extern int dvc_flag;
+extern unsigned int pxa988_get_vl_num(void);
+extern unsigned int pxa988_get_vl(unsigned int vl);
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/features.h b/arch/arm/mach-mmp/include/mach/features.h
new file mode 100644
index 00000000..7eaa9a45
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/features.h
@@ -0,0 +1,157 @@
+#ifndef __MACH_FEATURES_H
+#define __MACH_FEATURES_H
+
+#include <mach/cputype.h>
+#include <mach/pxa168fb.h>
+
+static inline int has_feat_fhd_ddr_rqs(void)
+{
+	return is_fhd_lcd();
+}
+
+/* This is a feature to use SDIO_DAT1 edge wakeup */
+static inline int has_feat_sdio_edge_wakeup_only(void)
+{
+	return cpu_is_pxa988_z1() || cpu_is_pxa986_z1() ||
+		cpu_is_pxa988_z2() || cpu_is_pxa986_z2() ||
+		cpu_is_pxa986_z3();
+}
+
+/* A new feature to indicate pll lock status */
+static inline int has_feat_pll_lock_signal(void)
+{
+	return !(cpu_is_pxa988_z1() || cpu_is_pxa986_z1() ||
+			cpu_is_pxa988_z2() || cpu_is_pxa986_z2() ||
+			cpu_is_pxa988_z3() || cpu_is_pxa986_z3());
+}
+
+/* A new feature to enable MCK4/AXI clock gating */
+static inline int has_feat_mck4_axi_clock_gate(void)
+{
+	return !(cpu_is_pxa988_z1() || cpu_is_pxa986_z1() ||
+			cpu_is_pxa988_z2() || cpu_is_pxa986_z2() ||
+			cpu_is_pxa988_z3() || cpu_is_pxa986_z3());
+}
+
+/* l2 and scu power connected, so must be enable/disable together */
+static inline int has_feat_scu_l2_power_connection(void)
+{
+	return cpu_is_pxa988_z1() || cpu_is_pxa986_z1() ||
+		cpu_is_pxa988_z2() || cpu_is_pxa986_z2() ||
+		cpu_is_pxa988_z3() || cpu_is_pxa986_z3();
+}
+
+/* Disable c2 on other cpus when freq change to avoid conflict */
+static inline int has_feat_freqchg_disable_c2(void)
+{
+	return cpu_is_pxa988_a0() || cpu_is_pxa986_a0();
+}
+
+/* This feature allow SW to use IPC to wakeup another core */
+static inline int has_feat_ipc_wakeup_core(void)
+{
+	return cpu_is_pxa988_z1() || cpu_is_pxa986_z1() ||
+		cpu_is_pxa988_z2() || cpu_is_pxa986_z2() ||
+		cpu_is_pxa988_z3() || cpu_is_pxa986_z3();
+}
+
+/* mck4 table0 will be triggered when exit D1P */
+static inline int has_feat_mck4_table0_trigger(void)
+{
+	return cpu_is_pxa988_z1() || cpu_is_pxa986_z1() ||
+		cpu_is_pxa988_z2() || cpu_is_pxa986_z2() ||
+		cpu_is_pxa988_z3() || cpu_is_pxa986_z3();
+}
+
+/* Use vdma as overlay */
+static inline int has_feat_video_replace_graphics_dma(void)
+{
+	return cpu_is_pxa988_z1() || cpu_is_pxa986_z1() ||
+		cpu_is_pxa988_z2() || cpu_is_pxa986_z2();
+}
+
+static inline int has_feat_isp_reset(void)
+{
+	return cpu_is_pxa988_z1() || cpu_is_pxa986_z1() ||
+		cpu_is_pxa988_z2() || cpu_is_pxa986_z2() ||
+		cpu_is_pxa988_z3() || cpu_is_pxa986_z3();
+}
+
+static inline int has_feat_legacy_apmu_core_status(void)
+{
+	return cpu_is_pxa988_z1() || cpu_is_pxa986_z1() ||
+		cpu_is_pxa988_z2() || cpu_is_pxa986_z2() ||
+		cpu_is_pxa988_z3() || cpu_is_pxa986_z3();
+}
+
+static inline int has_feat_d1p_hipwr(void)
+{
+	return cpu_is_pxa988_z1() || cpu_is_pxa988_z2() ||
+		cpu_is_pxa986_z1() || cpu_is_pxa986_z2();
+}
+
+static inline int has_feat_debugreg_in_d1p(void)
+{
+	return cpu_is_pxa988_z1() || cpu_is_pxa988_z2() ||
+		cpu_is_pxa988_z3() || cpu_is_pxa986_z1() ||
+		cpu_is_pxa986_z2() || cpu_is_pxa986_z3();
+}
+
+static inline int has_feat_dll_bypass_opti(void)
+{
+	return cpu_is_pxa988() || cpu_is_pxa986() ||
+		cpu_is_pxa1088();
+}
+
+/* PMU DVC feature to ignore core volt request in M2 */
+static inline int has_feat_dvc_M2D1Pignorecore(void)
+{
+	return !(cpu_is_pxa988() || cpu_is_pxa986() || cpu_is_pxa1088());
+}
+
+/* default peri_clk = div_value *4, for Zx, peri_clk = div_value *2  */
+static inline int has_feat_periclk_mult2(void)
+{
+	return cpu_is_pxa988_z1() || cpu_is_pxa986_z1() ||
+		cpu_is_pxa988_z2() || cpu_is_pxa986_z2() ||
+		cpu_is_pxa988_z3() || cpu_is_pxa986_z3();
+}
+
+/* when GC is clock on, D1P is disabled. */
+static inline int has_feat_disable_d1p_gc_on(void)
+{
+	return cpu_is_pxa988() || cpu_is_pxa986();
+}
+/* When VPU is clock on, D1P can't be entered */
+static inline int has_feat_disable_d1P_vpu_on(void)
+{
+	return cpu_is_pxa988() || cpu_is_pxa986();
+}
+
+/* enable hardware v-blank DFC feature in pxa1088 */
+static inline int has_feat_enable_hw_vblank_DFC(void)
+{
+	return cpu_is_pxa1088();
+}
+
+/* Higher Vmin of DDR feature on 1088 */
+static inline int has_feat_higher_ddr_vmin(void)
+{
+	return cpu_is_pxa1088_a0();
+}
+
+static inline int has_feat_pmu_support(void)
+{
+	return cpu_is_pxa988() || cpu_is_pxa986() ||
+		cpu_is_pxa1088_a0();
+}
+static inline int has_feat_panic_freqscaling(void)
+{
+	return cpu_is_pxa988() || cpu_is_pxa986();
+}
+
+static inline int has_feat_thermal_only_support_polling(void)
+{
+	return cpu_is_pxa988() || cpu_is_pxa986() || cpu_is_pxa1088();
+}
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/gpio-edge.h b/arch/arm/mach-mmp/include/mach/gpio-edge.h
new file mode 100644
index 00000000..adeaa69e
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/gpio-edge.h
@@ -0,0 +1,42 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/gpio-edge.h
+ *
+ * Copyright:   (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef MMP_ARCH_GPIO_EDGE_H
+#define MMP_ARCH_GPIO_EDGE_H
+
+/*
+ * struct gpio_edge_desc - gpio edge wakeup source descriptor
+ * @list:	list control of the descriptors
+ * @gpio:	the gpio number of the wakeup source
+ * @mfp:	the mfp pin index of the wakeup source
+ * @type:      the type of edge detect for the pin, rising/falling/both
+ * @data:	any kind private data passed to the handler
+ * @handler:	optional, the handler for the certain wakeup source detected
+ */
+struct gpio_edge_desc {
+	struct list_head list;
+	int gpio;
+	int mfp;
+	unsigned int type;
+	void *data;
+	void (*handler)(int, void *);
+};
+
+extern unsigned long gpio_wp_stat[];
+extern int gpio_edge_gpio_num;
+
+extern int mmp_gpio_edge_add(struct gpio_edge_desc *edge);
+extern int mmp_gpio_edge_del(struct gpio_edge_desc *edge);
+extern void mmp_gpio_edge_enable(void);
+extern void mmp_gpio_edge_disable(void);
+extern void mmp_gpio_edge_init(void __iomem *base, int mfp_num, int gpio_num);
+
+#endif /* MMP_ARCH_GPIO_EDGE_H */
diff --git a/arch/arm/mach-mmp/include/mach/gpio.h b/arch/arm/mach-mmp/include/mach/gpio.h
index 13219ebf..5ffa95b3 100644
--- a/arch/arm/mach-mmp/include/mach/gpio.h
+++ b/arch/arm/mach-mmp/include/mach/gpio.h
@@ -1,8 +1,15 @@
 #ifndef __ASM_MACH_GPIO_H
 #define __ASM_MACH_GPIO_H
 
+#include <mach/addr-map.h>
+#include <mach/irqs.h>
 #include <asm-generic/gpio.h>
 
 #include <mach/cputype.h>
 
+#define NR_BUILTIN_GPIO		MMP_NR_BUILTIN_GPIO
+
+#define GPIO_EXT0(x)	(NR_BUILTIN_GPIO + (x))
+#define GPIO_EXT1(x)	(NR_BUILTIN_GPIO + 16 + (x))
+
 #endif /* __ASM_MACH_GPIO_H */
diff --git a/arch/arm/mach-mmp/include/mach/gpu_mem.h b/arch/arm/mach-mmp/include/mach/gpu_mem.h
new file mode 100644
index 00000000..54518ad3
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/gpu_mem.h
@@ -0,0 +1,19 @@
+/*
+*  arch/arm/plat-pxa/include/plat/gpu_mem.h
+*
+*  GPU reserved memory management
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License version 2 as
+*  published by the Free Software Foundation.
+*  (C) Copyright 2011 Marvell International Ltd.
+*  All Rights Reserved
+*/
+
+#ifndef _PXA_GPU_MEM_H_
+#define _PXA_GPU_MEM_H_
+
+extern void __init pxa_reserve_gpu_memblock(void);
+extern void __init pxa_add_gpu(void);
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/io.h b/arch/arm/mach-mmp/include/mach/io.h
new file mode 100644
index 00000000..e7adf3d0
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/io.h
@@ -0,0 +1,21 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/io.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_IO_H
+#define __ASM_MACH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many
+ * drivers out there that might just work if we fake them...
+ */
+#define __io(a)		__typesafe_io(a)
+#define __mem_pci(a)	(a)
+
+#endif /* __ASM_MACH_IO_H */
diff --git a/arch/arm/mach-mmp/include/mach/irqs.h b/arch/arm/mach-mmp/include/mach/irqs.h
index d0e74662..f9da3d5b 100644
--- a/arch/arm/mach-mmp/include/mach/irqs.h
+++ b/arch/arm/mach-mmp/include/mach/irqs.h
@@ -80,7 +80,7 @@
 #define IRQ_PXA910_IPC_CP1		22
 #define IRQ_PXA910_IPC_CP2		23
 #define IRQ_PXA910_IPC_CP3		24
-#define IRQ_PXA910_IPC_CP4		25
+#define IRQ_PXA910_CNM			25
 #define IRQ_PXA910_L2_DDR		26
 #define IRQ_PXA910_UART2		27
 #define IRQ_PXA910_UART3		28
@@ -113,6 +113,105 @@
 #define IRQ_PXA910_AP_PMU		60
 #define IRQ_PXA910_SM_INT		63	/* from PinMux */
 
+/*
+ * Interrupt numbers for PXA988
+ */
+#define IRQ_PXA988_START		32
+#define IRQ_PXA988_NONE			(-1)
+#define IRQ_PXA988_AIRQ			(IRQ_PXA988_START + 0)
+#define IRQ_PXA988_SSP2			(IRQ_PXA988_START + 1)
+#define IRQ_PXA988_SSP1			(IRQ_PXA988_START + 2)
+#define IRQ_PXA988_SSP0			(IRQ_PXA988_START + 3)
+#define IRQ_PXA988_PMIC			(IRQ_PXA988_START + 4)
+#define IRQ_PXA988_RTC			(IRQ_PXA988_START + 5)
+#define IRQ_PXA988_RTC_ALARM		(IRQ_PXA988_START + 6)
+#define IRQ_PXA988_I2C0			(IRQ_PXA988_START + 7) /* I2C_AP */
+#define IRQ_PXA988_GPU			(IRQ_PXA988_START + 8)
+#define IRQ_PXA988_KEYPAD		(IRQ_PXA988_START + 9)
+#define IRQ_PXA988_DMA_INT2		(IRQ_PXA988_START + 10)
+#define IRQ_PXA988_DXO			(IRQ_PXA988_START + 11)
+#define IRQ_PXA988_ONEWIRE		(IRQ_PXA988_START + 12)
+#define IRQ_PXA988_AP_TIMER1		(IRQ_PXA988_START + 13)
+#define IRQ_PXA988_AP_TIMER2_3		(IRQ_PXA988_START + 14)
+#define IRQ_PXA988_ISP_DMA		(IRQ_PXA988_START + 15)
+#define IRQ_PXA988_IPC_AP0		(IRQ_PXA988_START + 16)
+#define IRQ_PXA988_IPC_AP1		(IRQ_PXA988_START + 17)
+#define IRQ_PXA988_IPC_AP2		(IRQ_PXA988_START + 18)
+#define IRQ_PXA988_IPC_AP3		(IRQ_PXA988_START + 19)
+#define IRQ_PXA988_IPC_AP4		(IRQ_PXA988_START + 20)
+#define IRQ_PXA988_IPC_CP0		(IRQ_PXA988_START + 21)
+#define IRQ_PXA988_IPC_CP1		(IRQ_PXA988_START + 22)
+#define IRQ_PXA988_IPC_CP2		(IRQ_PXA988_START + 23)
+#define IRQ_PXA988_IPC_CP3		(IRQ_PXA988_START + 24)
+#define IRQ_PXA988_CODA7542		(IRQ_PXA988_START + 25)
+#define IRQ_PXA988_L2_DDR		(IRQ_PXA988_START + 26)
+#define IRQ_PXA988_UART1		(IRQ_PXA988_START + 27)
+#define IRQ_PXA988_UART2		(IRQ_PXA988_START + 28)
+#define IRQ_PXA988_AP2_TIMER1		(IRQ_PXA988_START + 29)
+#define IRQ_PXA988_AP2_TIMER2_3		(IRQ_PXA988_START + 30)
+#define IRQ_PXA988_CP_TIMER1		(IRQ_PXA988_START + 31)
+#define IRQ_PXA988_CP_TIMER2_3		(IRQ_PXA988_START + 32)
+#define IRQ_PXA988_I2C1			(IRQ_PXA988_START + 33) /* I2C_INT */
+#define IRQ_PXA988_GSSP			(IRQ_PXA988_START + 34)
+#define IRQ_PXA988_WDT			(IRQ_PXA988_START + 35)
+#define IRQ_PXA988_MPMU			(IRQ_PXA988_START + 36)
+#define IRQ_PXA988_SEAGULL_FRQ		(IRQ_PXA988_START + 37)
+#define IRQ_PXA988_MOHAWK_FRQ		(IRQ_PXA988_START + 38)
+#define IRQ_PXA988_MMC			(IRQ_PXA988_START + 39)
+#define IRQ_PXA988_AEU			(IRQ_PXA988_START + 40)
+#define IRQ_PXA988_LCD			(IRQ_PXA988_START + 41)
+#define IRQ_PXA988_CI			(IRQ_PXA988_START + 42)
+#define IRQ_PXA988_IRE			(IRQ_PXA988_START + 43)
+#define IRQ_PXA988_USB1			(IRQ_PXA988_START + 44)
+#define IRQ_PXA988_NAND			(IRQ_PXA988_START + 45)
+#define IRQ_PXA988_HIFI_DMA		(IRQ_PXA988_START + 46)
+#define IRQ_PXA988_DMA_INT0		(IRQ_PXA988_START + 47)
+#define IRQ_PXA988_DMA_INT1		(IRQ_PXA988_START + 48)
+#define IRQ_PXA988_GPIO_AP		(IRQ_PXA988_START + 49)
+#define IRQ_PXA988_GPIO_EDGE		(IRQ_PXA988_START + 50)
+#define IRQ_PXA988_SPH			(IRQ_PXA988_START + 51)
+#define IRQ_PXA988_IPC_SRV0_SE		(IRQ_PXA988_START + 52)
+#define IRQ_PXA988_DSI			(IRQ_PXA988_START + 53)
+#define IRQ_PXA988_I2C2			(IRQ_PXA988_START + 54) /* I2C_CP */
+#define IRQ_PXA988_GPIO_CP		(IRQ_PXA988_START + 55)
+#define IRQ_PXA988_IPC_SRV0_MO		(IRQ_PXA988_START + 56)
+#define IRQ_PXA988_PC_CP		(IRQ_PXA988_START + 57)
+#define IRQ_PXA988_CORESIGHT		(IRQ_PXA988_START + 58)
+#define IRQ_PXA988_UART0		(IRQ_PXA988_START + 59)
+#define IRQ_PXA988_DRO_SENSOR		(IRQ_PXA988_START + 60)
+#define IRQ_PXA988_CORESIGHT2		(IRQ_PXA988_START + 61)
+#define IRQ_PXA988_FABRIC_TO		(IRQ_PXA988_START + 62)
+#define IRQ_PXA988_SM_INT		(IRQ_PXA988_START + 63)
+#define IRQ_PXA988_END			(IRQ_PXA988_SM_INT + 1)
+
+/*
+ * Interrupt numbers for PXA1088.
+ * The interrupt 0 ~ 31 assign to GIC
+ * 0~15 : SGI0~SGI15
+ * 16~25: reserved
+ * 26~31: PPI5, PPI4, PPI0, PPI1, PPI2, PPI3
+ */
+#define IRQ_PXA1088_START		32
+#define IRQ_PXA1088_NONE		(-1)
+#define IRQ_PXA1088_CA7MP_FRQ		(IRQ_PXA1088_START + 37)
+#define IRQ_PXA1088_SEAGULL_FRQ		(IRQ_PXA1088_START + 38)
+#define IRQ_PXA1088_AP3_TIMER1		(IRQ_PXA1088_START + 64)
+#define IRQ_PXA1088_AP3_TIMER2_3	(IRQ_PXA1088_START + 65)
+#define IRQ_PXA1088_CORESIGHT3		(IRQ_PXA1088_START + 66)
+#define IRQ_PXA1088_DMA_INT3		(IRQ_PXA1088_START + 67)
+#define IRQ_PXA1088_CORESIGHT4		(IRQ_PXA1088_START + 68)
+#define IRQ_PXA1088_DMA_INT4		(IRQ_PXA1088_START + 69)
+#define IRQ_PXA1088_HSI_IRQ		(IRQ_PXA1088_START + 70)
+#define IRQ_PXA1088_HSI_WAKE_WAKEUP	(IRQ_PXA1088_START + 71)
+#define IRQ_PXA1088_GC320		(IRQ_PXA1088_START + 72)
+#define IRQ_PXA1088_DMA_SECURE_INT	(IRQ_PXA1088_START + 73)
+#define IRQ_PXA1088_DMA_SECURE_INT2	(IRQ_PXA1088_START + 74)
+#define IRQ_PXA1088_DMA_SECURE_INT3	(IRQ_PXA1088_START + 75)
+#define IRQ_PXA1088_DMA_SECURE_INT4	(IRQ_PXA1088_START + 76)
+#define IRQ_PXA1088_END			(IRQ_PXA1088_DMA_SECURE_INT4 + 1)
+/* PXA1088 reserve irq 77~95 */
+#define IRQ_PXA1088_REV_END		(IRQ_PXA1088_START + 96)
+
 /*
  * Interrupt numbers for MMP2
  */
@@ -125,7 +224,7 @@
 #define IRQ_MMP2_RTC_MUX		5
 #define IRQ_MMP2_TWSI1			7
 #define IRQ_MMP2_GPU			8
-#define IRQ_MMP2_KEYPAD			9
+#define IRQ_MMP2_KEYPAD_MUX		9
 #define IRQ_MMP2_ROTARY			10
 #define IRQ_MMP2_TRACKBALL		11
 #define IRQ_MMP2_ONEWIRE		12
@@ -163,11 +262,11 @@
 #define IRQ_MMP2_DMA_FIQ		47
 #define IRQ_MMP2_DMA_RIQ		48
 #define IRQ_MMP2_GPIO			49
-#define IRQ_MMP2_SSP_MUX		51
+#define IRQ_MMP2_MIPI_HSI1_MUX		51
 #define IRQ_MMP2_MMC2			52
 #define IRQ_MMP2_MMC3			53
 #define IRQ_MMP2_MMC4			54
-#define IRQ_MMP2_MIPI_HSI		55
+#define IRQ_MMP2_MIPI_HSI0_MUX		55
 #define IRQ_MMP2_MSP			58
 #define IRQ_MMP2_MIPI_SLIM_DMA		59
 #define IRQ_MMP2_PJ4_FREQ_CHG		60
@@ -186,8 +285,14 @@
 #define IRQ_MMP2_RTC_ALARM		(IRQ_MMP2_RTC_BASE + 0)
 #define IRQ_MMP2_RTC			(IRQ_MMP2_RTC_BASE + 1)
 
+/* secondary interrupt of INT #9 */
+#define IRQ_MMP2_KEYPAD_BASE		(IRQ_MMP2_RTC_BASE + 2)
+#define IRQ_MMP2_KPC			(IRQ_MMP2_KEYPAD_BASE + 0)
+#define IRQ_MMP2_ROTORY			(IRQ_MMP2_KEYPAD_BASE + 1)
+#define IRQ_MMP2_TBALL			(IRQ_MMP2_KEYPAD_BASE + 2)
+
 /* secondary interrupt of INT #17 */
-#define IRQ_MMP2_TWSI_BASE		(IRQ_MMP2_RTC_BASE + 2)
+#define IRQ_MMP2_TWSI_BASE		(IRQ_MMP2_KEYPAD_BASE + 3)
 #define IRQ_MMP2_TWSI2			(IRQ_MMP2_TWSI_BASE + 0)
 #define IRQ_MMP2_TWSI3			(IRQ_MMP2_TWSI_BASE + 1)
 #define IRQ_MMP2_TWSI4			(IRQ_MMP2_TWSI_BASE + 2)
@@ -212,15 +317,532 @@
 #define IRQ_MMP2_COMMRX			(IRQ_MMP2_MISC_BASE + 14)
 
 /* secondary interrupt of INT #51 */
-#define IRQ_MMP2_SSP_BASE		(IRQ_MMP2_MISC_BASE + 15)
-#define IRQ_MMP2_SSP1_SRDY		(IRQ_MMP2_SSP_BASE + 0)
-#define IRQ_MMP2_SSP3_SRDY		(IRQ_MMP2_SSP_BASE + 1)
+#define IRQ_MMP2_MIPI_HSI1_BASE		(IRQ_MMP2_MISC_BASE + 15)
+#define IRQ_MMP2_HSI1_CAWAKE		(IRQ_MMP2_MIPI_HSI1_BASE + 0)
+#define IRQ_MMP2_MIPI_HSI_INT1		(IRQ_MMP2_MIPI_HSI1_BASE + 1)
+
+/* secondary interrupt of INT #55 */
+#define IRQ_MMP2_MIPI_HSI0_BASE		(IRQ_MMP2_MIPI_HSI1_BASE + 2)
+#define IRQ_MMP2_HSI0_CAWAKE		(IRQ_MMP2_MIPI_HSI0_BASE + 0)
+#define IRQ_MMP2_MIPI_HSI_INT0		(IRQ_MMP2_MIPI_HSI0_BASE + 1)
+
+#define IRQ_MMP2_MUX_END		(IRQ_MMP2_MIPI_HSI0_BASE + 2)
+
+/*
+ * Interrupt numbers for MMP3
+ */
+#define IRQ_LOCALTIMER			29
+#define IRQ_LOCALWDOG			30
+#define IRQ_LEGACYIRQ			31
+
+#define IRQ_MMP3_START			32
+#define IRQ_MMP3_NONE			(-1)
+#define IRQ_MMP3_SSP1			(IRQ_MMP3_START + 0)
+#define IRQ_MMP3_SSP2			(IRQ_MMP3_START + 1)
+#define IRQ_MMP3_SSPA1			(IRQ_MMP3_START + 2)
+#define IRQ_MMP3_SSPA2			(IRQ_MMP3_START + 3)
+#define IRQ_MMP3_PMIC_MUX		(IRQ_MMP3_START + 4)
+#define IRQ_MMP3_RTC_MUX		(IRQ_MMP3_START + 5)
+#define IRQ_MMP3_HSI3_MUX		(IRQ_MMP3_START + 6)
+#define IRQ_MMP3_TWSI1			(IRQ_MMP3_START + 7)
+#define IRQ_MMP3_GPU_MUX		(IRQ_MMP3_START + 8)
+#define IRQ_MMP3_KEYPAD			(IRQ_MMP3_START + 9)
+#define IRQ_MMP3_ROTARY			(IRQ_MMP3_START + 10)
+#define IRQ_MMP3_TRACKBALL		(IRQ_MMP3_START + 11)
+#define IRQ_MMP3_ONEWIRE		(IRQ_MMP3_START + 12)
+#define IRQ_MMP3_TIMER1			(IRQ_MMP3_START + 13)
+#define IRQ_MMP3_TIMER2			(IRQ_MMP3_START + 14)
+#define IRQ_MMP3_TIMER3			(IRQ_MMP3_START + 15)
+#define IRQ_MMP3_RIPC			(IRQ_MMP3_START + 16)
+#define IRQ_MMP3_TWSI_MUX		(IRQ_MMP3_START + 17)
+#define IRQ_MMP3_HSI2_MUX		(IRQ_MMP3_START + 18)
+#define IRQ_MMP3_HDMI			(IRQ_MMP3_START + 19)
+#define IRQ_MMP3_SSP3			(IRQ_MMP3_START + 20)
+#define IRQ_MMP3_SSP4			(IRQ_MMP3_START + 21)
+#define IRQ_MMP3_USB_HS1		(IRQ_MMP3_START + 22)
+#define IRQ_MMP3_USB_HS2		(IRQ_MMP3_START + 23)
+#define IRQ_MMP3_UART3			(IRQ_MMP3_START + 24)
+#define IRQ_MMP3_VMETA			(IRQ_MMP3_START + 26)
+#define IRQ_MMP3_UART1			(IRQ_MMP3_START + 27)
+#define IRQ_MMP3_UART2			(IRQ_MMP3_START + 28)
+#define IRQ_MMP3_MIPI_DSI		(IRQ_MMP3_START + 29)
+#define IRQ_MMP3_DXO_MUX		(IRQ_MMP3_START + 30)
+#define IRQ_MMP3_PMU_TIMER1		(IRQ_MMP3_START + 31)
+#define IRQ_MMP3_PMU_TIMER2		(IRQ_MMP3_START + 32)
+#define IRQ_MMP3_PMU_TIMER3		(IRQ_MMP3_START + 33)
+#define IRQ_MMP3_USB_FS			(IRQ_MMP3_START + 34)
+#define IRQ_MMP3_MISC1_MUX		(IRQ_MMP3_START + 35)
+#define IRQ_MMP3_WDT1			(IRQ_MMP3_START + 36)
+#define IRQ_MMP3_NAND_DMA		(IRQ_MMP3_START + 37)
+#define IRQ_MMP3_USIM			(IRQ_MMP3_START + 38)
+#define IRQ_MMP3_MMC			(IRQ_MMP3_START + 39)
+#define IRQ_MMP3_WTM			(IRQ_MMP3_START + 40)
+#define IRQ_MMP3_LCD			(IRQ_MMP3_START + 41)
+#define IRQ_MMP3_CI_MUX			(IRQ_MMP3_START + 42)
+#define IRQ_MMP3_IRE			(IRQ_MMP3_START + 43)
+#define IRQ_MMP3_USB_OTG		(IRQ_MMP3_START + 44)
+#define IRQ_MMP3_NAND			(IRQ_MMP3_START + 45)
+#define IRQ_MMP3_UART4			(IRQ_MMP3_START + 46)
+#define IRQ_MMP3_DMA_FIQ		(IRQ_MMP3_START + 47)
+#define IRQ_MMP3_DMA_RIQ		(IRQ_MMP3_START + 48)
+#define IRQ_MMP3_GPIO			(IRQ_MMP3_START + 49)
+#define IRQ_MMP3_SECURITY		(IRQ_MMP3_START + 50)
+#define IRQ_MMP3_SSP_MUX		(IRQ_MMP3_START + 51)
+#define IRQ_MMP3_MMC2			(IRQ_MMP3_START + 52)
+#define IRQ_MMP3_MMC3			(IRQ_MMP3_START + 53)
+#define IRQ_MMP3_MMC4			(IRQ_MMP3_START + 54)
+#define IRQ_MMP3_HSI1_MUX		(IRQ_MMP3_START + 55)
+#define IRQ_MMP3_IPC2			(IRQ_MMP3_START + 56)
+#define IRQ_MMP3_MISC2_MUX		(IRQ_MMP3_START + 57)
+#define IRQ_MMP3_HSI0_MUX		(IRQ_MMP3_START + 58)
+#define IRQ_MMP3_MIPI_SLIM_DMA		(IRQ_MMP3_START + 59)
+#define IRQ_MMP3_PJ4_FREQ_CHG		(IRQ_MMP3_START + 60)
+#define IRQ_MMP3_MIPI_SLIM		(IRQ_MMP3_START + 62)
+#define IRQ_MMP3_SMC			(IRQ_MMP3_START + 63)
+#define IRQ_MMP3_PMU_INT0		(IRQ_MMP3_START + 86)
+#define IRQ_MMP3_PMU_INT1		(IRQ_MMP3_START + 87)
+#define IRQ_MMP3_PMU_INT2		(IRQ_MMP3_START + 88)
+#ifdef CONFIG_ARM_GIC
+#define IRQ_MMP3_END			(IRQ_MMP3_START + 96)
+#else
+#define IRQ_MMP3_END			(IRQ_MMP3_START + 64)
+#endif
+
+/* secondary interrupt of INT #4 */
+#define IRQ_MMP3_PMIC_BASE		(IRQ_MMP3_END)
+#define IRQ_MMP3_CHARGER		(IRQ_MMP3_PMIC_BASE + 0)
+#define IRQ_MMP3_PMIC			(IRQ_MMP3_PMIC_BASE + 1)
+#define IRQ_MMP3_SPMI			(IRQ_MMP3_PMIC_BASE + 2)
+#define IRQ_MMP3_CHRG_DTC_OUT		(IRQ_MMP3_PMIC_BASE + 3)
+
+/* secondary interrupt of INT #5 */
+#define IRQ_MMP3_RTC_BASE		(IRQ_MMP3_PMIC_BASE + 4)
+#define IRQ_MMP3_RTC_ALARM		(IRQ_MMP3_RTC_BASE + 0)
+#define IRQ_MMP3_RTC			(IRQ_MMP3_RTC_BASE + 1)
+
+/* secondary interrupt of INT #6 */
+#define IRQ_MMP3_HSI3_BASE		(IRQ_MMP3_RTC_BASE + 2)
+#define IRQ_MMP3_ETHER			(IRQ_MMP3_HSI3_BASE + 0)
+#define IRQ_MMP3_UNIPRO3		(IRQ_MMP3_HSI3_BASE + 1)
+#define IRQ_MMP3_HSI3			(IRQ_MMP3_HSI3_BASE + 2)
+
+/* secondary interrupt of INT #8 */
+#define IRQ_MMP3_GPU_BASE		(IRQ_MMP3_HSI3_BASE + 3)
+#define IRQ_MMP3_GC2000			(IRQ_MMP3_GPU_BASE + 0)
+#define IRQ_MMP3_GC360			(IRQ_MMP3_GPU_BASE + 1)
+#define IRQ_MMP3_GC300			(IRQ_MMP3_GPU_BASE + 2)
+
+/* secondary interrupt of INT #17 */
+#define IRQ_MMP3_TWSI_BASE		(IRQ_MMP3_GPU_BASE + 3)
+#define IRQ_MMP3_TWSI2			(IRQ_MMP3_TWSI_BASE + 0)
+#define IRQ_MMP3_TWSI3			(IRQ_MMP3_TWSI_BASE + 1)
+#define IRQ_MMP3_TWSI4			(IRQ_MMP3_TWSI_BASE + 2)
+#define IRQ_MMP3_TWSI5			(IRQ_MMP3_TWSI_BASE + 3)
+#define IRQ_MMP3_TWSI6			(IRQ_MMP3_TWSI_BASE + 4)
+
+/* secondary interrupt of INT #18 */
+#define IRQ_MMP3_HSI2_BASE		(IRQ_MMP3_TWSI_BASE + 5)
+#define IRQ_MMP3_UNIPRO2		(IRQ_MMP3_HSI3_BASE + 0)
+#define IRQ_MMP3_HSI2			(IRQ_MMP3_HSI3_BASE + 1)
+
+/* secondary interrupt of INT #30 */
+#define IRQ_MMP3_DXO_BASE		(IRQ_MMP3_HSI2_BASE + 2)
+#define IRQ_MMP3_ISP_DMA		(IRQ_MMP3_DXO_BASE + 0)
+#define IRQ_MMP3_DXO_ISP		(IRQ_MMP3_DXO_BASE + 1)
+
+/* secondary interrupt of INT #35 */
+#define IRQ_MMP3_MISC1_BASE		(IRQ_MMP3_DXO_BASE + 2)
+#define IRQ_MMP3_MOLTRES_TRIGGER	(IRQ_MMP3_MISC1_BASE + 0)
+#define IRQ_MMP3_MOLTRES_SNP_PERR0	(IRQ_MMP3_MISC1_BASE + 1)
+#define IRQ_MMP3_MOLTRES_SNP_PERR1	(IRQ_MMP3_MISC1_BASE + 2)
+#define IRQ_MMP3_MOLTRES_SNP_PERR2	(IRQ_MMP3_MISC1_BASE + 3)
+#define IRQ_MMP3_MOLTRES_L2CCINTR_MASK	(IRQ_MMP3_MISC1_BASE + 4)
+#define IRQ_MMP3_MOLTRES_L2C_PA_ERR	(IRQ_MMP3_MISC1_BASE + 5)
+#define IRQ_MMP3_MOLTRES_L2C_UERR	(IRQ_MMP3_MISC1_BASE + 6)
+#define IRQ_MMP3_MOLTRES_L2C_CERR	(IRQ_MMP3_MISC1_BASE + 7)
+#define IRQ_MMP3_MOLTRES_ECNTRINTR	(IRQ_MMP3_MISC1_BASE + 8)
+#define IRQ_MMP3_MOLTRES_PARRTINTR	(IRQ_MMP3_MISC1_BASE + 9)
+#define IRQ_MMP3_MOLTRES_PARRDINTR	(IRQ_MMP3_MISC1_BASE + 10)
+#define IRQ_MMP3_MOLTRES_ERRWTINTR	(IRQ_MMP3_MISC1_BASE + 11)
+#define IRQ_MMP3_MOLTRES_ERRWDINTR	(IRQ_MMP3_MISC1_BASE + 12)
+#define IRQ_MMP3_MOLTRES_COMMTX_2_0	(IRQ_MMP3_MISC1_BASE + 13)
+#define IRQ_MMP3_MOLTRES_COMMRX_2_0	(IRQ_MMP3_MISC1_BASE + 14)
+#define IRQ_MMP3_MOLTRES_ERRRTINTR	(IRQ_MMP3_MISC1_BASE + 15)
+#define IRQ_MMP3_MOLTRES_ERRRDINTR	(IRQ_MMP3_MISC1_BASE + 16)
+#define IRQ_MMP3_MOLTRES_SLVERRINTR	(IRQ_MMP3_MISC1_BASE + 17)
+#define IRQ_MMP3_MOLTRES_DECERRINTR	(IRQ_MMP3_MISC1_BASE + 18)
+#define IRQ_MMP3_MOLTRES_CTI_NCTIIRQ_0	(IRQ_MMP3_MISC1_BASE + 19)
+#define IRQ_MMP3_MOLTRES_CTI_NCTIIRQ_1	(IRQ_MMP3_MISC1_BASE + 20)
+#define IRQ_MMP3_MOLTRES_CTI_NCTIIRQ_2	(IRQ_MMP3_MISC1_BASE + 21)
+#define IRQ_MMP3_MOLTRES_NPMUIRQ_0	(IRQ_MMP3_MISC1_BASE + 22)
+#define IRQ_MMP3_MOLTRES_NPMUIRQ_1	(IRQ_MMP3_MISC1_BASE + 23)
+#define IRQ_MMP3_MOLTRES_NPMUIRQ_2	(IRQ_MMP3_MISC1_BASE + 24)
+#define IRQ_MMP3_MOLTRES_DC_PERR	(IRQ_MMP3_MISC1_BASE + 25)
+#define IRQ_MMP3_MOLTRES_IC_PERR	(IRQ_MMP3_MISC1_BASE + 26)
+#define IRQ_MMP3_PJ4_PMU_INT_0		(IRQ_MMP3_MISC1_BASE + 27)
+#define IRQ_MMP3_PJ4_PMU_INT_1		(IRQ_MMP3_MISC1_BASE + 28)
+#define IRQ_MMP3_PJ4_PMU_INT_2		(IRQ_MMP3_MISC1_BASE + 29)
+#define IRQ_MMP3_USB3_DMA_INTR		(IRQ_MMP3_MISC1_BASE + 30)
+
+/* secondary interrupt of INT #42 */
+#define IRQ_MMP3_CI_BASE		(IRQ_MMP3_MISC1_BASE + 31)
+#define IRQ_MMP3_CCIC2			(IRQ_MMP3_CI_BASE + 0)
+#define IRQ_MMP3_CCIC1			(IRQ_MMP3_CI_BASE + 1)
+
+/* secondary interrupt of INT #51 */
+#define IRQ_MMP3_SSP_BASE		(IRQ_MMP3_CI_BASE + 2)
+#define IRQ_MMP3_SSP1_SRDY		(IRQ_MMP3_SSP_BASE + 0)
+#define IRQ_MMP3_SSP3_SRDY		(IRQ_MMP3_SSP_BASE + 1)
+
+/* secondary interrupt of INT #55 */
+#define IRQ_MMP3_HSI1_BASE		(IRQ_MMP3_SSP_BASE + 2)
+#define IRQ_MMP3_MMC5			(IRQ_MMP3_HSI1_BASE + 0)
+#define IRQ_MMP3_HSI1_RSVD		(IRQ_MMP3_HSI1_BASE + 1)
+#define IRQ_MMP3_UNIPRO1		(IRQ_MMP3_HSI1_BASE + 2)
+#define IRQ_MMP3_HSI1			(IRQ_MMP3_HSI1_BASE + 3)
+
+/* secondary interrupt of INT #57 */
+#define IRQ_MMP3_MISC2_BASE		(IRQ_MMP3_HSI1_BASE + 4)
+#define IRQ_MMP3_DSP_AUDIO_0		(IRQ_MMP3_MISC2_BASE + 0)
+#define IRQ_MMP3_DSP_AUDIO_1		(IRQ_MMP3_MISC2_BASE + 1)
+#define IRQ_MMP3_DSP_AUDIO_2		(IRQ_MMP3_MISC2_BASE + 2)
+#define IRQ_MMP3_DSP_AUDIO_3		(IRQ_MMP3_MISC2_BASE + 3)
+#define IRQ_MMP3_DSP_AUDIO_4		(IRQ_MMP3_MISC2_BASE + 4)
+#define IRQ_MMP3_DSP_AUDIO_5		(IRQ_MMP3_MISC2_BASE + 5)
+#define IRQ_MMP3_DSP_AUDIO_6		(IRQ_MMP3_MISC2_BASE + 6)
+#define IRQ_MMP3_DSP_AUDIO_7		(IRQ_MMP3_MISC2_BASE + 7)
+#define IRQ_MMP3_DSP_AUDIO_8		(IRQ_MMP3_MISC2_BASE + 8)
+#define IRQ_MMP3_DSP_AUDIO_9		(IRQ_MMP3_MISC2_BASE + 9)
+#define IRQ_MMP3_FABRIC_TIMEOUT		(IRQ_MMP3_MISC2_BASE + 10)
+#define IRQ_MMP3_THERMAL_SENSOR		(IRQ_MMP3_MISC2_BASE + 11)
+#define IRQ_MMP3_MPMU			(IRQ_MMP3_MISC2_BASE + 12)
+#define IRQ_MMP3_WDT2			(IRQ_MMP3_MISC2_BASE + 13)
+#define IRQ_MMP3_CORESIGHT		(IRQ_MMP3_MISC2_BASE + 14)
+#define IRQ_MMP3_DDR			(IRQ_MMP3_MISC2_BASE + 15)
+#define IRQ_MMP3_DDR2			(IRQ_MMP3_MISC2_BASE + 16)
+#define IRQ_MMP3_MOLTRES_NHWAFIRQ	(IRQ_MMP3_MISC2_BASE + 17)
+#define IRQ_MMP3_MOLTRES_SF_PERR	(IRQ_MMP3_MISC2_BASE + 18)
+#define IRQ_MMP3_MOLTRES_MMU_PERR	(IRQ_MMP3_MISC2_BASE + 19)
+
+/* secondary interrupt of INT #58 */
+#define IRQ_MMP3_HSI0_BASE		(IRQ_MMP3_MISC2_BASE + 20)
+#define IRQ_MMP3_MSP_CARD		(IRQ_MMP3_HSI0_BASE + 0)
+#define IRQ_MMP3_KERMIT_INT_0		(IRQ_MMP3_HSI0_BASE + 1)
+#define IRQ_MMP3_KERMIT_INT_1		(IRQ_MMP3_HSI0_BASE + 2)
+#define IRQ_MMP3_UNIPRO_INT_0		(IRQ_MMP3_HSI0_BASE + 3)
+#define IRQ_MMP3_HSI0			(IRQ_MMP3_HSI0_BASE + 4)
+
+/* secondary interrupt of dma: vdma, adma, mdma, pdma */
+#define IRQ_MMP3_DMA_BASE		(IRQ_MMP3_HSI0_BASE + 5)
+#define IRQ_MMP3_PDMA_0		(IRQ_MMP3_DMA_BASE + 0)
+#define IRQ_MMP3_PDMA_1		(IRQ_MMP3_DMA_BASE + 1)
+#define IRQ_MMP3_PDMA_2		(IRQ_MMP3_DMA_BASE + 2)
+#define IRQ_MMP3_PDMA_3		(IRQ_MMP3_DMA_BASE + 3)
+#define IRQ_MMP3_PDMA_4		(IRQ_MMP3_DMA_BASE + 4)
+#define IRQ_MMP3_PDMA_5		(IRQ_MMP3_DMA_BASE + 5)
+#define IRQ_MMP3_PDMA_6		(IRQ_MMP3_DMA_BASE + 6)
+#define IRQ_MMP3_PDMA_7		(IRQ_MMP3_DMA_BASE + 7)
+#define IRQ_MMP3_PDMA_8		(IRQ_MMP3_DMA_BASE + 8)
+#define IRQ_MMP3_PDMA_9		(IRQ_MMP3_DMA_BASE + 9)
+#define IRQ_MMP3_PDMA_10		(IRQ_MMP3_DMA_BASE + 10)
+#define IRQ_MMP3_PDMA_11		(IRQ_MMP3_DMA_BASE + 11)
+#define IRQ_MMP3_PDMA_12		(IRQ_MMP3_DMA_BASE + 12)
+#define IRQ_MMP3_PDMA_13		(IRQ_MMP3_DMA_BASE + 13)
+#define IRQ_MMP3_PDMA_14		(IRQ_MMP3_DMA_BASE + 14)
+#define IRQ_MMP3_PDMA_15		(IRQ_MMP3_DMA_BASE + 15)
+#define IRQ_MMP3_MDMA_0		(IRQ_MMP3_DMA_BASE + 16)
+#define IRQ_MMP3_MDMA_1		(IRQ_MMP3_DMA_BASE + 17)
+#define IRQ_MMP3_ADMA_0		(IRQ_MMP3_DMA_BASE + 18)
+#define IRQ_MMP3_ADMA_1		(IRQ_MMP3_DMA_BASE + 19)
+#define IRQ_MMP3_ADMA_2		(IRQ_MMP3_DMA_BASE + 20)
+#define IRQ_MMP3_ADMA_3		(IRQ_MMP3_DMA_BASE + 21)
+#define IRQ_MMP3_VDMA_0		(IRQ_MMP3_DMA_BASE + 22)
+#define IRQ_MMP3_VDMA_1		(IRQ_MMP3_DMA_BASE + 23)
+
+#define IRQ_MMP3_MUX_END		(IRQ_MMP3_DMA_BASE + 24)
+
+/*
+ * Interrupt numbers for EDEN
+ */
+
+#if defined(CONFIG_GIC_BYPASS)		/* Use ICU for Interrupt Handling */
+#if defined(CONFIG_SMP)			/* Use GIC+ICU */
+#define IRQ_EDEN_START			32
+#else					/* ICU Only */
+#define IRQ_EDEN_START			0
+#endif
+#else					/* GIC Only Mode */
+#define IRQ_EDEN_START			32
+#endif
+
+#define IRQ_EDEN_NONE			(-1)
+#define IRQ_EDEN_SSP1			(IRQ_EDEN_START + 0)
+#define IRQ_EDEN_SSP2			(IRQ_EDEN_START + 1)
+#define IRQ_EDEN_SSPA1			(IRQ_EDEN_START + 2)
+#define IRQ_EDEN_SSPA2			(IRQ_EDEN_START + 3)
+#define IRQ_EDEN_INT4			(IRQ_EDEN_START + 4)	/* PMIC & USB Charger Intr. Mux */
+#define IRQ_EDEN_INT5			(IRQ_EDEN_START + 5)	/* RTC Intr. Mux */
+#define IRQ_EDEN_TWSI1			(IRQ_EDEN_START + 7)
+#define IRQ_EDEN_INT8			(IRQ_EDEN_START + 8)	/* GPU Intr. Mux */
+#define IRQ_EDEN_KEYPAD			(IRQ_EDEN_START + 9)
+#define IRQ_EDEN_ROTARY			(IRQ_EDEN_START + 10)
+#define IRQ_EDEN_TRACKBALL		(IRQ_EDEN_START + 11)
+#define IRQ_EDEN_ONEWIRE		(IRQ_EDEN_START + 12)
+#define IRQ_EDEN_TIMER1			(IRQ_EDEN_START + 13)
+#define IRQ_EDEN_TIMER2			(IRQ_EDEN_START + 14)
+#define IRQ_EDEN_TIMER3			(IRQ_EDEN_START + 15)
+#define IRQ_EDEN_IPC1			(IRQ_EDEN_START + 16)
+#define IRQ_EDEN_INT17			(IRQ_EDEN_START + 17)	/* TWSI2 ~ TWSI6 Intr. Mux */
+#define IRQ_EDEN_INT18			(IRQ_EDEN_START + 18)	/* Multicore cpu1 (IRQ & FIQ) Intr. */
+#define IRQ_EDEN_HDMI			(IRQ_EDEN_START + 19)
+#define IRQ_EDEN_SSP3			(IRQ_EDEN_START + 20)
+#define IRQ_EDEN_USB_HS1		(IRQ_EDEN_START + 22)
+#define IRQ_EDEN_UART3			(IRQ_EDEN_START + 24)
+#define IRQ_EDEN_VPU			(IRQ_EDEN_START + 26)
+#define IRQ_EDEN_UART1			(IRQ_EDEN_START + 27)
+#define IRQ_EDEN_UART2			(IRQ_EDEN_START + 28)
+#define IRQ_EDEN_MIPI_DSI		(IRQ_EDEN_START + 29)
+#define IRQ_EDEN_INT30			(IRQ_EDEN_START + 30)	/* ISP & Multicore cpu0 (IRQ & FIQ) Intr. Mux */
+#define IRQ_EDEN_PMU_TIMER1		(IRQ_EDEN_START + 31)
+#define IRQ_EDEN_PMU_TIMER2		(IRQ_EDEN_START + 32)
+#define IRQ_EDEN_PMU_TIMER3		(IRQ_EDEN_START + 33)
+#define IRQ_EDEN_INT35			(IRQ_EDEN_START + 35)	/* Miscellaneous Intr. Mux */
+#define IRQ_EDEN_WDT1			(IRQ_EDEN_START + 36)
+#define IRQ_EDEN_NAND_DMA		(IRQ_EDEN_START + 37)
+#define IRQ_EDEN_USIM			(IRQ_EDEN_START + 38)
+#define IRQ_EDEN_MMC			(IRQ_EDEN_START + 39)
+#define IRQ_EDEN_WTM			(IRQ_EDEN_START + 40)
+#define IRQ_EDEN_LCD			(IRQ_EDEN_START + 41)
+#define IRQ_EDEN_INT42			(IRQ_EDEN_START + 42)	/* CCIC Intr. Mux */
+#define IRQ_EDEN_IRE			(IRQ_EDEN_START + 43)
+#define IRQ_EDEN_USB_OTG		(IRQ_EDEN_START + 44)
+#define IRQ_EDEN_NAND			(IRQ_EDEN_START + 45)
+#define IRQ_EDEN_UART4			(IRQ_EDEN_START + 46)
+#define IRQ_EDEN_DMA_FIQ		(IRQ_EDEN_START + 47)
+#define IRQ_EDEN_DMA_RIQ		(IRQ_EDEN_START + 48)
+#define IRQ_EDEN_GPIO			(IRQ_EDEN_START + 49)
+#define IRQ_EDEN_SECURITY		(IRQ_EDEN_START + 50)
+#define IRQ_EDEN_INT51			(IRQ_EDEN_START + 51)	/* SSP Intr. Mux */
+#define IRQ_EDEN_MMC2			(IRQ_EDEN_START + 52)
+#define IRQ_EDEN_MMC3			(IRQ_EDEN_START + 53)
+#define IRQ_EDEN_MMC4			(IRQ_EDEN_START + 54)
+#define IRQ_EDEN_IPC2			(IRQ_EDEN_START + 56)
+#define IRQ_EDEN_INT57			(IRQ_EDEN_START + 57)	/* DSP & Thermal Intr. Mux */
+#define IRQ_EDEN_IPC_CP			(IRQ_EDEN_START + 59)
+#define IRQ_EDEN_CA7_FREQ_CHG		(IRQ_EDEN_START + 60)
+#define IRQ_EDEN_SMC			(IRQ_EDEN_START + 63)
+
+#if defined(CONFIG_GIC_BYPASS)
+
+#define IRQ_EDEN_MUX_START		(IRQ_EDEN_START + 64)
+
+/* secondary interrupt of INT #4 */
+#define IRQ_EDEN_INT4_BASE		(IRQ_EDEN_MUX_START)
+#define IRQ_EDEN_CHARGER		(IRQ_EDEN_INT4_BASE + 0)
+#define IRQ_EDEN_PMIC			(IRQ_EDEN_INT4_BASE + 1)
+#define IRQ_EDEN_CHRG_DTC_OUT		(IRQ_EDEN_INT4_BASE + 3)
+
+/* secondary interrupt of INT #5 */
+#define IRQ_EDEN_INT5_BASE		(IRQ_EDEN_INT4_BASE + 4)
+#define IRQ_EDEN_RTC_ALARM		(IRQ_EDEN_INT5_BASE + 0)
+#define IRQ_EDEN_RTC			(IRQ_EDEN_INT5_BASE + 1)
+
+/* secondary interrupt of INT #8 */
+#define IRQ_EDEN_INT8_BASE		(IRQ_EDEN_INT5_BASE + 2)
+#define IRQ_EDEN_GC2200			(IRQ_EDEN_INT8_BASE + 0)
+#define IRQ_EDEN_GC320			(IRQ_EDEN_INT8_BASE + 2)
+#define IRQ_EDEN_MULTICORE_INT_CPU3	(IRQ_EDEN_INT8_BASE + 3)
+
+/* secondary interrupt of INT #17 */
+#define IRQ_EDEN_INT17_BASE		(IRQ_EDEN_INT8_BASE + 4)
+#define IRQ_EDEN_TWSI2			(IRQ_EDEN_INT17_BASE + 0)
+#define IRQ_EDEN_TWSI3			(IRQ_EDEN_INT17_BASE + 1)
+#define IRQ_EDEN_TWSI4			(IRQ_EDEN_INT17_BASE + 2)
+#define IRQ_EDEN_TWSI5			(IRQ_EDEN_INT17_BASE + 3)
+#define IRQ_EDEN_TWSI6			(IRQ_EDEN_INT17_BASE + 4)
+#define IRQ_EDEN_MULTICORE_INT_CPU2	(IRQ_EDEN_INT17_BASE + 5)
+
+/* secondary interrupt of INT #18 */
+#define IRQ_EDEN_INT18_BASE		(IRQ_EDEN_INT17_BASE + 6)
+#define IRQ_EDEN_MULTICORE_INT_CPU1	(IRQ_EDEN_INT18_BASE + 2)
+
+/* secondary interrupt of INT #30 */
+#define IRQ_EDEN_INT30_BASE		(IRQ_EDEN_INT18_BASE + 3)
+#define IRQ_EDEN_ISP_DMA		(IRQ_EDEN_INT30_BASE + 0)
+#define IRQ_EDEN_DXO_ISP		(IRQ_EDEN_INT30_BASE + 1)
+#define IRQ_EDEN_MULTICORE_INT_CPU0	(IRQ_EDEN_INT30_BASE + 2)
+
+/* secondary interrupt of INT #35 */
+#define IRQ_EDEN_INT35_BASE		(IRQ_EDEN_INT30_BASE + 3)
+#define IRQ_EDEN_CA7_MP_TRIGGER0	(IRQ_EDEN_INT35_BASE + 0)
+#define IRQ_EDEN_CA7_MP_TRIGGER1	(IRQ_EDEN_INT35_BASE + 1)
+#define IRQ_EDEN_CA7_MP_TRIGGER2	(IRQ_EDEN_INT35_BASE + 2)
+#define IRQ_EDEN_CA7_MP_TRIGGER3	(IRQ_EDEN_INT35_BASE + 3)
+#define IRQ_EDEN_CA7_MP_COMMTX0		(IRQ_EDEN_INT35_BASE + 4)
+#define IRQ_EDEN_CA7_MP_COMMTX1		(IRQ_EDEN_INT35_BASE + 5)
+#define IRQ_EDEN_CA7_MP_COMMTX2		(IRQ_EDEN_INT35_BASE + 6)
+#define IRQ_EDEN_CA7_MP_COMMTX3		(IRQ_EDEN_INT35_BASE + 7)
+#define IRQ_EDEN_CA7_MP_COMMRX0		(IRQ_EDEN_INT35_BASE + 8)
+#define IRQ_EDEN_CA7_MP_COMMRX1		(IRQ_EDEN_INT35_BASE + 9)
+#define IRQ_EDEN_CA7_MP_COMMRX2		(IRQ_EDEN_INT35_BASE + 10)
+#define IRQ_EDEN_CA7_MP_COMMRX3		(IRQ_EDEN_INT35_BASE + 11)
+#define IRQ_EDEN_MULTICORE_CTI_NCTIIRQ0	(IRQ_EDEN_INT35_BASE + 12)
+#define IRQ_EDEN_MULTICORE_CTI_NCTIIRQ1	(IRQ_EDEN_INT35_BASE + 13)
+#define IRQ_EDEN_MULTICORE_CTI_NCTIIRQ2	(IRQ_EDEN_INT35_BASE + 14)
+#define IRQ_EDEN_MULTICORE_CTI_NCTIIRQ3	(IRQ_EDEN_INT35_BASE + 15)
+#define IRQ_EDEN_MULTICORE_NPMUIRQ0	(IRQ_EDEN_INT35_BASE + 17)
+#define IRQ_EDEN_MULTICORE_NPMUIRQ1	(IRQ_EDEN_INT35_BASE + 18)
+#define IRQ_EDEN_MULTICORE_NPMUIRQ2	(IRQ_EDEN_INT35_BASE + 19)
+#define IRQ_EDEN_MULTICORE_NPMUIRQ3	(IRQ_EDEN_INT35_BASE + 20)
+#define IRQ_EDEN_CORE_MP_NAXIERRIRQ	(IRQ_EDEN_INT35_BASE + 20)
+#define IRQ_EDEN_WDT2_INT		(IRQ_EDEN_INT35_BASE + 21)
+#define IRQ_EDEN_MULTICORE_NCNTPNSIRQ0	(IRQ_EDEN_INT35_BASE + 23)
+#define IRQ_EDEN_MULTICORE_NCNTPNSIRQ1	(IRQ_EDEN_INT35_BASE + 24)
+#define IRQ_EDEN_MULTICORE_NCNTPNSIRQ2	(IRQ_EDEN_INT35_BASE + 25)
+#define IRQ_EDEN_MULTICORE_NCNTPNSIRQ3	(IRQ_EDEN_INT35_BASE + 26)
+#define IRQ_EDEN_MULTICORE_NCNTPSIRQ0	(IRQ_EDEN_INT35_BASE + 27)
+#define IRQ_EDEN_MULTICORE_NCNTPSIRQ1	(IRQ_EDEN_INT35_BASE + 28)
+#define IRQ_EDEN_MULTICORE_NCNTPSIRQ2	(IRQ_EDEN_INT35_BASE + 29)
+#define IRQ_EDEN_MULTICORE_NCNTPSIRQ3	(IRQ_EDEN_INT35_BASE + 30)
+#define IRQ_EDEN_MCK_PML_OVERFLOW	(IRQ_EDEN_INT35_BASE + 31)
+
+/* secondary interrupt of INT #42 */
+#define IRQ_EDEN_INT42_BASE		(IRQ_EDEN_INT35_BASE + 32)
+#define IRQ_EDEN_CCIC2			(IRQ_EDEN_INT42_BASE + 0)
+#define IRQ_EDEN_CCIC1			(IRQ_EDEN_INT42_BASE + 1)
+
+/* secondary interrupt of INT #51 */
+#define IRQ_EDEN_INT51_BASE		(IRQ_EDEN_INT42_BASE + 2)
+#define IRQ_EDEN_SSP1_SRDY		(IRQ_EDEN_INT51_BASE + 0)
+#define IRQ_EDEN_SSP3_SRDY		(IRQ_EDEN_INT51_BASE + 1)
+
+/* secondary interrupt of INT #57 */
+#define IRQ_EDEN_INT57_BASE		(IRQ_EDEN_INT51_BASE + 2)
+#define IRQ_EDEN_DSP_INT_2		(IRQ_EDEN_INT57_BASE + 2)
+#define IRQ_EDEN_DSP_INT_3		(IRQ_EDEN_INT57_BASE + 3)
+#define IRQ_EDEN_DSP_INT_4		(IRQ_EDEN_INT57_BASE + 4)
+#define IRQ_EDEN_DSP_INT_5		(IRQ_EDEN_INT57_BASE + 5)
+#define IRQ_EDEN_DSP_INT_6		(IRQ_EDEN_INT57_BASE + 6)
+#define IRQ_EDEN_DSP_INT_7		(IRQ_EDEN_INT57_BASE + 7)
+#define IRQ_EDEN_DSP_INT_9		(IRQ_EDEN_INT57_BASE + 9)
+#define IRQ_EDEN_DSP_INT_10		(IRQ_EDEN_INT57_BASE + 10)
+#define IRQ_EDEN_DSP_INT_11		(IRQ_EDEN_INT57_BASE + 11)
+#define IRQ_EDEN_THERMAL_SENSOR		(IRQ_EDEN_INT57_BASE + 13)
+#define IRQ_EDEN_MAIN_PMU_INT		(IRQ_EDEN_INT57_BASE + 14)
+#define IRQ_EDEN_MULTICORE_NCNTVIRQ0	(IRQ_EDEN_INT57_BASE + 15)
+#define IRQ_EDEN_MULTICORE_NCNTVIRQ1	(IRQ_EDEN_INT57_BASE + 16)
+#define IRQ_EDEN_MULTICORE_NCNTVIRQ2	(IRQ_EDEN_INT57_BASE + 17)
+#define IRQ_EDEN_MULTICORE_NCNTVIRQ3	(IRQ_EDEN_INT57_BASE + 18)
+#define IRQ_EDEN_MULTICORE_NCNTHPIRQ0	(IRQ_EDEN_INT57_BASE + 19)
+#define IRQ_EDEN_MULTICORE_NCNTHPIRQ1	(IRQ_EDEN_INT57_BASE + 20)
+#define IRQ_EDEN_MULTICORE_NCNTHPIRQ2	(IRQ_EDEN_INT57_BASE + 21)
+#define IRQ_EDEN_MULTICORE_NCNTHPIRQ3	(IRQ_EDEN_INT57_BASE + 22)
+#define IRQ_EDEN_APMU_INT		(IRQ_EDEN_INT57_BASE + 23)
+
+#define IRQ_EDEN_END			(IRQ_EDEN_INT57_BASE + 24)
+
+#else	/* Use GIC Only Mode */
+
+#define IRQ_EDEN_KEYPAD_WAKEUP		(IRQ_EDEN_START + 64)
+#define IRQ_EDEN_USB_OTG_WAKEUP		(IRQ_EDEN_START + 66)
+#define IRQ_EDEN_USB_MMC1_WAKEUP	(IRQ_EDEN_START + 68)
+#define IRQ_EDEN_USB_MMC2_WAKEUP	(IRQ_EDEN_START + 70)
+#define IRQ_EDEN_USB_MMC3_WAKEUP	(IRQ_EDEN_START + 72)
+#define IRQ_EDEN_USB_MMC4_WAKEUP	(IRQ_EDEN_START + 74)
+#define IRQ_EDEN_CHARGER		(IRQ_EDEN_START + 76)
+#define IRQ_EDEN_PMIC			(IRQ_EDEN_START + 77)
+#define IRQ_EDEN_CHRG_DTC_OUT		(IRQ_EDEN_START + 78)
+#define IRQ_EDEN_RTC_ALARM		(IRQ_EDEN_START + 79)
+#define IRQ_EDEN_RTC			(IRQ_EDEN_START + 80)
+#define IRQ_EDEN_GC2200			(IRQ_EDEN_START + 81)
+#define IRQ_EDEN_GC320			(IRQ_EDEN_START + 82)
+#define IRQ_EDEN_MULTICORE_INT_CPU3	(IRQ_EDEN_START + 83)
+#define IRQ_EDEN_TWSI2			(IRQ_EDEN_START + 84)
+#define IRQ_EDEN_TWSI3			(IRQ_EDEN_START + 85)
+#define IRQ_EDEN_TWSI4			(IRQ_EDEN_START + 86)
+#define IRQ_EDEN_TWSI5			(IRQ_EDEN_START + 87)
+#define IRQ_EDEN_TWSI6			(IRQ_EDEN_START + 88)
+#define IRQ_EDEN_MULTICORE_INT_CPU2	(IRQ_EDEN_START + 89)
+#define IRQ_EDEN_MULTICORE_INT_CPU1	(IRQ_EDEN_START + 90)
+#define IRQ_EDEN_ISP_DMA		(IRQ_EDEN_START + 91)
+#define IRQ_EDEN_DXO_ISP		(IRQ_EDEN_START + 92)
+#define IRQ_EDEN_MULTICORE_INT_CPU0	(IRQ_EDEN_START + 93)
+#define IRQ_EDEN_CA7_MP_TRIGGER0	(IRQ_EDEN_START + 94)
+#define IRQ_EDEN_CA7_MP_TRIGGER1	(IRQ_EDEN_START + 95)
+#define IRQ_EDEN_CA7_MP_TRIGGER2	(IRQ_EDEN_START + 96)
+#define IRQ_EDEN_CA7_MP_TRIGGER3	(IRQ_EDEN_START + 97)
+#define IRQ_EDEN_CA7_MP_COMMTX0		(IRQ_EDEN_START + 98)
+#define IRQ_EDEN_CA7_MP_COMMTX1		(IRQ_EDEN_START + 99)
+#define IRQ_EDEN_CA7_MP_COMMTX2		(IRQ_EDEN_START + 100)
+#define IRQ_EDEN_CA7_MP_COMMTX3		(IRQ_EDEN_START + 101)
+#define IRQ_EDEN_CA7_MP_COMMRX0		(IRQ_EDEN_START + 102)
+#define IRQ_EDEN_CA7_MP_COMMRX1		(IRQ_EDEN_START + 103)
+#define IRQ_EDEN_CA7_MP_COMMRX2		(IRQ_EDEN_START + 104)
+#define IRQ_EDEN_CA7_MP_COMMRX3		(IRQ_EDEN_START + 105)
+#define IRQ_EDEN_MULTICORE_CTI_NCTIIRQ0	(IRQ_EDEN_START + 106)
+#define IRQ_EDEN_MULTICORE_CTI_NCTIIRQ1	(IRQ_EDEN_START + 107)
+#define IRQ_EDEN_MULTICORE_CTI_NCTIIRQ2	(IRQ_EDEN_START + 108)
+#define IRQ_EDEN_MULTICORE_CTI_NCTIIRQ3	(IRQ_EDEN_START + 109)
+#define IRQ_EDEN_MULTICORE_NPMUIRQ0	(IRQ_EDEN_START + 110)
+#define IRQ_EDEN_MULTICORE_NPMUIRQ1	(IRQ_EDEN_START + 111)
+#define IRQ_EDEN_MULTICORE_NPMUIRQ2	(IRQ_EDEN_START + 112)
+#define IRQ_EDEN_MULTICORE_NPMUIRQ3	(IRQ_EDEN_START + 113)
+#define IRQ_EDEN_CORE_MP_NAXIERRIRQ	(IRQ_EDEN_START + 114)
+#define IRQ_EDEN_WDT2_INT		(IRQ_EDEN_START + 115)
+#define IRQ_EDEN_MCK_PML_OVERFLOW	(IRQ_EDEN_START + 118)
+#define IRQ_EDEN_CCIC2			(IRQ_EDEN_START + 119)
+#define IRQ_EDEN_CCIC1			(IRQ_EDEN_START + 120)
+#define IRQ_EDEN_SSP1_SRDY		(IRQ_EDEN_START + 121)
+#define IRQ_EDEN_SSP3_SRDY		(IRQ_EDEN_START + 122)
+#define IRQ_EDEN_DSP_INT_2		(IRQ_EDEN_START + 123)
+#define IRQ_EDEN_DSP_INT_3		(IRQ_EDEN_START + 124)
+#define IRQ_EDEN_DSP_INT_4		(IRQ_EDEN_START + 125)
+#define IRQ_EDEN_DSP_INT_5		(IRQ_EDEN_START + 126)
+#define IRQ_EDEN_DSP_INT_6		(IRQ_EDEN_START + 127)
+#define IRQ_EDEN_DSP_INT_7		(IRQ_EDEN_START + 128)
+#define IRQ_EDEN_DSP_INT_9		(IRQ_EDEN_START + 129)
+#define IRQ_EDEN_DSP_INT_10		(IRQ_EDEN_START + 130)
+#define IRQ_EDEN_DSP_INT_11		(IRQ_EDEN_START + 131)
+#define IRQ_EDEN_THERMAL_SENSOR		(IRQ_EDEN_START + 132)
+#define IRQ_EDEN_MAIN_PMU_INT		(IRQ_EDEN_START + 133)
+#define IRQ_EDEN_APMU_INT		(IRQ_EDEN_START + 134)
+#define IRQ_EDEN_DMA_CHNL_INT0		(IRQ_EDEN_START + 135)
+#define IRQ_EDEN_DMA_CHNL_INT1		(IRQ_EDEN_START + 136)
+#define IRQ_EDEN_DMA_CHNL_INT2		(IRQ_EDEN_START + 137)
+#define IRQ_EDEN_DMA_CHNL_INT3		(IRQ_EDEN_START + 138)
+#define IRQ_EDEN_DMA_CHNL_INT4		(IRQ_EDEN_START + 139)
+#define IRQ_EDEN_DMA_CHNL_INT5		(IRQ_EDEN_START + 140)
+#define IRQ_EDEN_DMA_CHNL_INT6		(IRQ_EDEN_START + 141)
+#define IRQ_EDEN_DMA_CHNL_INT7		(IRQ_EDEN_START + 142)
+#define IRQ_EDEN_DMA_CHNL_INT8		(IRQ_EDEN_START + 143)
+#define IRQ_EDEN_DMA_CHNL_INT9		(IRQ_EDEN_START + 144)
+#define IRQ_EDEN_DMA_CHNL_INT10		(IRQ_EDEN_START + 145)
+#define IRQ_EDEN_DMA_CHNL_INT11		(IRQ_EDEN_START + 146)
+#define IRQ_EDEN_DMA_CHNL_INT12		(IRQ_EDEN_START + 147)
+#define IRQ_EDEN_DMA_CHNL_INT13		(IRQ_EDEN_START + 148)
+#define IRQ_EDEN_DMA_CHNL_INT14		(IRQ_EDEN_START + 149)
+#define IRQ_EDEN_DMA_CHNL_INT15		(IRQ_EDEN_START + 150)
+#define IRQ_EDEN_MDMA_CHNL_INT0		(IRQ_EDEN_START + 151)
+#define IRQ_EDEN_MDMA_CHNL_INT1		(IRQ_EDEN_START + 152)
+#define IRQ_EDEN_ADMA_CHNL_INT0		(IRQ_EDEN_START + 153)
+#define IRQ_EDEN_ADMA_CHNL_INT1		(IRQ_EDEN_START + 154)
+#define IRQ_EDEN_ADMA_CHNL_INT3		(IRQ_EDEN_START + 155)
+#define IRQ_EDEN_ADMA_CHNL_INT4		(IRQ_EDEN_START + 156)
+#define IRQ_EDEN_VDMA_INT		(IRQ_EDEN_START + 157)
 
-#define IRQ_MMP2_MUX_END		(IRQ_MMP2_SSP_BASE + 2)
+#define IRQ_EDEN_END			(IRQ_EDEN_START + 160)
+#endif
 
+#if defined(CONFIG_CPU_MMP3)
+#define IRQ_GPIO_START			IRQ_MMP3_MUX_END
+#elif defined(CONFIG_CPU_EDEN)
+#define IRQ_GPIO_START			IRQ_EDEN_END
+#else
 #define IRQ_GPIO_START			128
+#endif
 #define MMP_NR_BUILTIN_GPIO		192
 #define MMP_GPIO_TO_IRQ(gpio)		(IRQ_GPIO_START + (gpio))
+#define MMP_TRQ_TO_GPIO(gpio)		((gpio) - IRQ_GPIO_START)
 
 #define IRQ_BOARD_START			(IRQ_GPIO_START + MMP_NR_BUILTIN_GPIO)
 #define MMP_NR_IRQS			IRQ_BOARD_START
diff --git a/arch/arm/mach-mmp/include/mach/isl29043.h b/arch/arm/mach-mmp/include/mach/isl29043.h
new file mode 100644
index 00000000..d0057ff4
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/isl29043.h
@@ -0,0 +1,19 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/isl29043.h
+ *
+ *  Copyright (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _ISL29043_H_
+#define _ISL29043_H_
+
+struct isl29043_platform_data {
+	int wakup_gpio;
+	int (*set_power)(int);
+};
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/isp_dev.h b/arch/arm/mach-mmp/include/mach/isp_dev.h
new file mode 100644
index 00000000..31fee6bd
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/isp_dev.h
@@ -0,0 +1,94 @@
+/*
+ * isp_dev.h
+ *
+ * Marvell DxO ISP - Top level module
+ *	Based on omap3isp
+ *
+ * Copyright:  (C) Copyright 2011 Marvell International Ltd.
+ *              Henry Zhao <xzhao10@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+
+#ifndef ISP_DEV_H
+#define ISP_DEV_H
+
+#include <media/map_camera.h>
+#include <media/mrvl-camera.h>
+#include <linux/mvisp.h>
+
+enum mvisp_interface_type {
+	ISP_INTERFACE_PARALLEL_0,
+	ISP_INTERFACE_PARALLEL_1,
+	ISP_INTERFACE_CCIC_1,
+	ISP_INTERFACE_CCIC_2,
+};
+
+enum {
+	PCAM_IP_CCIC	= 0,
+	PCAM_IP_DXO,
+	PCAM_IP_SENSOR,
+	PCAM_IP_CNT,
+	PCAM_DEV_CCIC_END	= 2,
+	PCAM_DEV_DXO_END	= 1,
+};
+
+int plat_agent_register(struct hw_agent *agent);
+int plat_resrc_register(struct device *dev, struct resource *res,
+	const char *name, union agent_id mask,
+	int res_id, void *handle, void *priv);
+int sensor_set_clock(struct hw_agent *agent, int rate);
+
+struct mvisp_subdev_i2c_board_info {
+	struct i2c_board_info *board_info;
+	int i2c_adapter_id;
+};
+
+struct mvisp_v4l2_subdevs_group {
+	char name[20];
+	struct mvisp_subdev_i2c_board_info *i2c_board_info;
+	enum mvisp_interface_type if_type;
+};
+
+struct mvisp_platform_data {
+	struct mvisp_v4l2_subdevs_group *subdev_group;
+	bool ccic_dummy_ena;
+	bool ispdma_dummy_ena;
+	unsigned int isp_clknum;
+	unsigned int ccic_clknum;
+	unsigned int isp_clk_rate_num;
+	unsigned long isp_clk_rate[CLK_RATE_NUM];
+	unsigned int ccic_clk_rate_num;
+	unsigned long ccic_clk_rate[CLK_RATE_NUM];
+	char **clkname;
+	int (*init_pin)(struct device *dev, int on);
+	int (*mvisp_reset)(void *param);
+	int (*isp_pwr_ctrl)(int);
+};
+
+#ifdef CONFIG_CPU_MMP3
+void __init mmp3_register_dxoisp(struct mvisp_platform_data *pdata);
+int mmp3_isp_reset_hw(void *param);
+int isppwr_power_control(int on);
+#endif
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+void __init pxa988_register_dxoisp(struct mvisp_platform_data *pdata);
+int pxa988_isp_reset_hw(void *param);
+int pxa988_isp_power_control(int on);
+#endif
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/memory.h b/arch/arm/mach-mmp/include/mach/memory.h
new file mode 100644
index 00000000..f1f38ed0
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/memory.h
@@ -0,0 +1,29 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/memory.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_MEMORY_H
+#define __ASM_MACH_MEMORY_H
+
+#if defined(CONFIG_CRASH_DUMP)
+#define PLAT_PHYS_OFFSET	UL(0x06000000)
+#elif defined(CONFIG_TZ_HYPERVISOR)
+#define PLAT_PHYS_OFFSET	UL(0x01000000)
+#else
+#define PLAT_PHYS_OFFSET	UL(0x00000000)
+#endif
+
+/*
+ * Restrict DMA-able region to workaround silicon bug.  The bug
+ * restricts buffers available for DMA to AXI fabric 2 to be
+ * below 64M
+ */
+#ifdef CONFIG_ZONE_DMA
+#define ARM_DMA_ZONE_SIZE      SZ_64M
+#endif
+
+#endif /* __ASM_MACH_MEMORY_H */
diff --git a/arch/arm/mach-mmp/include/mach/mfp-mmp2.h b/arch/arm/mach-mmp/include/mach/mfp-mmp2.h
index 4ad38629..cbb73323 100644
--- a/arch/arm/mach-mmp/include/mach/mfp-mmp2.h
+++ b/arch/arm/mach-mmp/include/mach/mfp-mmp2.h
@@ -237,6 +237,9 @@
 #define GPIO53_UART3_CTS	MFP_CFG(GPIO53, AF1)
 #define GPIO54_UART3_RTS	MFP_CFG(GPIO54, AF1)
 
+/*PWM3*/
+#define GPIO53_PWM3		MFP_CFG_X(GPIO53, AF5, SLOW, PULL_LOW)
+
 /* MMC1 */
 #define GPIO124_MMC1_DAT7	MFP_CFG_DRV(GPIO124, AF1, FAST)
 #define GPIO125_MMC1_DAT6	MFP_CFG_DRV(GPIO125, AF1, FAST)
@@ -250,6 +253,8 @@
 #define GPIO139_MMC1_CLK	MFP_CFG_DRV(GPIO139, AF1, FAST)
 #define GPIO140_MMC1_CD		MFP_CFG_DRV(GPIO140, AF1, FAST)
 #define GPIO141_MMC1_WP		MFP_CFG_DRV(GPIO141, AF1, FAST)
+/* for MMP3 */
+#define GPIO135_MMC1_CLK	MFP_CFG_DRV(GPIO135, AF1, FAST)
 
 /*MMC2*/
 #define GPIO37_MMC2_DAT3	MFP_CFG_DRV(GPIO37, AF1, FAST)
@@ -271,6 +276,18 @@
 #define GPIO112_MMC3_CMD	MFP_CFG_DRV(GPIO112, AF2, FAST)
 #define GPIO151_MMC3_CLK	MFP_CFG_DRV(GPIO151, AF2, FAST)
 
+/* MMC3 for MMP3 */
+#define GPIO108_MMC3_DAT7	MFP_CFG_DRV(GPIO108, AF2, FAST)
+#define GPIO109_MMC3_DAT6	MFP_CFG_DRV(GPIO109, AF2, FAST)
+#define GPIO161_MMC3_DAT5	MFP_CFG_DRV(GPIO161, AF2, FAST)
+#define GPIO163_MMC3_DAT4	MFP_CFG_DRV(GPIO163, AF2, FAST)
+#define GPIO111_MMC3_DAT3	MFP_CFG_DRV(GPIO111, AF2, FAST)
+#define GPIO110_MMC3_DAT2	MFP_CFG_DRV(GPIO110, AF2, FAST)
+#define GPIO162_MMC3_DAT1	MFP_CFG_DRV(GPIO162, AF2, FAST)
+#define GPIO164_MMC3_DAT0	MFP_CFG_DRV(GPIO164, AF2, FAST)
+#define GPIO145_MMC3_CMD	MFP_CFG_DRV(GPIO145, AF2, FAST)
+#define GPIO146_MMC3_CLK	MFP_CFG_DRV(GPIO146, AF2, FAST)
+
 /* LCD */
 #define GPIO74_LCD_FCLK		MFP_CFG_DRV(GPIO74, AF1, FAST)
 #define GPIO75_LCD_LCLK		MFP_CFG_DRV(GPIO75, AF1, FAST)
@@ -314,6 +331,7 @@
 #define GPIO126_LCD_DD33	MFP_CFG_DRV(GPIO126, AF2, FAST)
 #define GPIO127_LCD_DD26	MFP_CFG_DRV(GPIO127, AF2, FAST)
 #define GPIO128_LCD_DD27	MFP_CFG_DRV(GPIO128, AF2, FAST)
+#define GPIO128_LCD_RST		MFP_CFG_DRV(GPIO128, AF0, FAST) /* MMP3 */
 #define GPIO129_LCD_DD28	MFP_CFG_DRV(GPIO129, AF2, FAST)
 #define GPIO130_LCD_DD29	MFP_CFG_DRV(GPIO130, AF2, FAST)
 #define GPIO135_LCD_DD30	MFP_CFG_DRV(GPIO135, AF2, FAST)
@@ -387,9 +405,13 @@
 #define GPIO68_CAM_VSYNC	MFP_CFG_DRV(GPIO68, AF1, FAST)
 #define GPIO69_CAM_MCLK		MFP_CFG_DRV(GPIO69, AF1, FAST)
 #define GPIO70_CAM_PCLK		MFP_CFG_DRV(GPIO70, AF1, FAST)
+#define GPIO73_CAM_MCLK		MFP_CFG_DRV(GPIO73, AF4, FAST)
 
 /* PMIC */
 #define PMIC_PMIC_INT		MFP_CFG(PMIC_INT, AF0)
 
+#define GPIO59_HDMI_DET         MFP_CFG(GPIO59, AF0)
+#define GPIO54_HDMI_CEC         MFP_CFG(GPIO54, AF4) | MFP_PULL_HIGH
+
 #endif /* __ASM_MACH_MFP_MMP2_H */
 
diff --git a/arch/arm/mach-mmp/include/mach/mfp-pxa986-goya.h b/arch/arm/mach-mmp/include/mach/mfp-pxa986-goya.h
new file mode 100755
index 00000000..72c4dbeb
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mfp-pxa986-goya.h
@@ -0,0 +1,228 @@
+#ifndef __ASM_MACH_MFP_PXA988_H
+#define __ASM_MACH_MFP_PXA988_H
+
+#include <plat/mfp.h>
+
+#define GOYA_R0_3		0
+#define GOYA_R0_4		1
+#define GOYA_R0_5		2
+#define GOYA_R0_6		3
+#define GOYA_R0_7		4
+#define GOYA_R0_8		5
+#define GOYA_R0_9		6
+#define GOYA_R1_0		7
+
+#define GPIO000_KP_MKIN0		MFP_CFG(GPIO0, AF1)
+#define GPIO001_KP_MKOUT0		MFP_CFG(GPIO1, AF1)
+#define GPIO002_KP_MKIN1		MFP_CFG(GPIO2, AF1)
+#define GPIO000_GPIO_0			MFP_CFG(GPIO0, AF0)
+#define GPIO001_GPIO_1			MFP_CFG(GPIO1, AF0)
+#define GPIO002_GPIO_2			MFP_CFG(GPIO2, AF0)
+#define GPIO003_GPIO_3			MFP_CFG(GPIO3, AF0)
+#define GPIO004_GPIO_4			MFP_CFG(GPIO4, AF0)
+#define GPIO005_GPIO_5			MFP_CFG(GPIO5, AF0)
+#define GPIO006_GPIO_6			MFP_CFG(GPIO6, AF0)
+
+#define GPIO007_GPIO_7			MFP_CFG(GPIO7, AF0)
+#define GPIO008_GPIO_8			MFP_CFG(GPIO8, AF0)
+#define GPIO009_GPIO_9			MFP_CFG(GPIO9, AF0)
+#define GPIO010_GPIO_10			MFP_CFG(GPIO10, AF0)
+#define GPIO011_GPIO_11			MFP_CFG(GPIO11, AF0)
+#define GPIO012_GPIO_12			MFP_CFG(GPIO12, AF0)
+#define GPIO013_KP_DKIN4		MFP_CFG(GPIO13, AF4)
+#define GPIO013_GPIO_13			MFP_CFG(GPIO13, AF0)
+#define GPIO014_GPIO_14			MFP_CFG(GPIO14, AF0)
+#define GPIO015_GPIO_15			MFP_CFG(GPIO15, AF0)
+#define GPIO016_GPIO_16			MFP_CFG(GPIO16, AF0)
+#define GPIO017_GPIO_17			MFP_CFG(GPIO17, AF0)
+#define GPIO018_GPIO_18			MFP_CFG(GPIO18, AF0)
+#define GPIO019_GPIO_19			MFP_CFG(GPIO19, AF0)
+#define GPIO020_GPIO_20			MFP_CFG(GPIO20, AF0)
+
+#define GPIO021_I2S_BITCLK		MFP_CFG(GPIO21, AF1)
+#define GPIO022_I2S_SYNC		MFP_CFG(GPIO22, AF1)
+#define GPIO023_I2S_DATA_OUT		MFP_CFG(GPIO23, AF1)
+#define GPIO024_I2S_SDATA_IN		MFP_CFG(GPIO24, AF1)
+
+#define GPIO021_GPIO_21			MFP_CFG(GPIO21, AF0)
+#define GPIO022_GPIO_22			MFP_CFG(GPIO22, AF0)
+#define GPIO023_GPIO_23                 MFP_CFG(GPIO23, AF0)
+#define GPIO024_GPIO_24                 MFP_CFG(GPIO24, AF0)
+
+#define GPIO025_GPIO_INPUT		(MFP_CFG(GPIO25, AF0) | MFP_LPM_INPUT)
+#define GPIO026_GPIO_INPUT		(MFP_CFG(GPIO26, AF0) | MFP_LPM_INPUT)
+#define GPIO027_GPIO_INPUT		(MFP_CFG(GPIO27, AF0) | MFP_LPM_INPUT)
+#define GPIO028_GPIO_INPUT		(MFP_CFG(GPIO28, AF0) | MFP_LPM_INPUT)
+
+#define GPIO025_GSSP_SCLK		MFP_CFG(GPIO25, AF1)
+#define GPIO026_GSSP_SFRM		MFP_CFG(GPIO26, AF1)
+#define GPIO027_GSSP_TXD		MFP_CFG(GPIO27, AF1)
+#define GPIO028_GSSP_RXD		MFP_CFG(GPIO28, AF1)
+
+#define GPIO029_1M3_SCL		MFP_CFG(GPIO29, AF0)
+#define GPIO030_1M3_SDA		MFP_CFG(GPIO30, AF0)
+#define GPIO029_GPIO_29			MFP_CFG(GPIO29, AF0)
+#define GPIO030_GPIO_30			MFP_CFG(GPIO30, AF0)
+
+#define GPIO031_GPIO_31			MFP_CFG(GPIO31, AF0)
+#define GPIO032_GPIO_32			MFP_CFG(GPIO32, AF0)
+
+#define GPIO033_GPIO_33			MFP_CFG(GPIO33, AF0)
+#define GPIO034_GPIO_34			MFP_CFG(GPIO34, AF0)
+#define GPIO035_GPIO_35			MFP_CFG(GPIO35, AF0)
+#define GPIO036_GPIO_36			MFP_CFG(GPIO36, AF0)
+
+#define GPIO037_MMC2_DATA3		MFP_CFG(GPIO37, AF1)
+#define GPIO038_MMC2_DATA2		MFP_CFG(GPIO38, AF1)
+#define GPIO039_MMC2_DATA1		MFP_CFG(GPIO39, AF1)
+#define GPIO040_MMC2_DATA0		MFP_CFG(GPIO40, AF1)
+#define GPIO041_MMC2_CMD		MFP_CFG_DRV (GPIO41, AF1, DS01X)
+#define GPIO042_MMC2_CLK		MFP_CFG_DRV (GPIO42, AF1, DS01X)
+
+#define GPIO043_GPIO_43			MFP_CFG(GPIO43, AF0)
+#define GPIO044_GPIO_44			MFP_CFG(GPIO44, AF0)
+
+#define GPIO043_GPIO_43_Ax		MFP_CFG(GPIO43, AF6)
+#define GPIO044_GPIO_44_Ax		MFP_CFG(GPIO44, AF6)
+
+#define GPIO045_UART2_RXD		MFP_CFG(GPIO45, AF1)
+#define GPIO046_UART2_TXD		MFP_CFG(GPIO46, AF1)
+
+#define GPIO047_UART1_RXD		MFP_CFG(GPIO47, AF6)
+#define GPIO048_UART1_TXD		MFP_CFG(GPIO48, AF6)
+
+#define GPIO049_GPIO_49			MFP_CFG(GPIO49, AF0)
+#define GPIO050_GPIO_50			MFP_CFG(GPIO50, AF0)
+
+#define GPIO053_CAM_SCL		MFP_CFG(GPIO53, AF2)
+#define GPIO054_CAM_SDA		MFP_CFG(GPIO54, AF2)
+#define GPIO051_GPIO_51			MFP_CFG(GPIO51, AF0)
+#define GPIO052_GPIO_52			MFP_CFG(GPIO52, AF0)
+#define GPIO053_GPIO_53			MFP_CFG(GPIO53, AF0)
+#define GPIO054_GPIO_54			MFP_CFG(GPIO54, AF0)
+
+#define GPIO067_CCIC_IN7		MFP_CFG(GPIO67, AF1)
+#define GPIO068_CCIC_IN6		MFP_CFG(GPIO68, AF1)
+#define GPIO069_CCIC_IN5		MFP_CFG(GPIO69, AF1)
+#define GPIO067_GPIO_67		MFP_CFG(GPIO67, AF0)
+#define GPIO068_GPIO_68		MFP_CFG(GPIO68, AF0)
+#define GPIO069_GPIO_69		MFP_CFG(GPIO69, AF0)
+
+#define GPIO070_GPIO_70			MFP_CFG(GPIO70, AF0)
+#define GPIO071_GPIO_71			MFP_CFG(GPIO71, AF0)
+
+#define GPIO070_CCIC_IN4		MFP_CFG(GPIO70, AF1)
+#define GPIO071_CCIC_IN3		MFP_CFG(GPIO71, AF1)
+
+#define GPIO072_CCIC_IN2		MFP_CFG(GPIO72, AF1)
+#define GPIO073_CCIC_IN1		MFP_CFG(GPIO73, AF1)
+#define GPIO074_CCIC_IN0		MFP_CFG(GPIO74, AF1)
+#define GPIO072_GPIO_72		MFP_CFG(GPIO72, AF0)
+#define GPIO073_GPIO_73		MFP_CFG(GPIO73, AF0)
+#define GPIO074_GPIO_74		MFP_CFG(GPIO74, AF0)
+#define GPIO075_CAM_HSYNC		MFP_CFG(GPIO75, AF1)
+#define GPIO076_CAM_VSYNC		MFP_CFG(GPIO76, AF1)
+#define GPIO077_CAM_MCLK		MFP_CFG(GPIO77, AF1)
+#define GPIO078_CAM_PCLK		MFP_CFG(GPIO78, AF1)
+
+#define GPIO075_GPIO_75		MFP_CFG(GPIO75, AF0)
+#define GPIO076_GPIO_76		MFP_CFG(GPIO76, AF0)
+#define GPIO077_GPIO_77		MFP_CFG(GPIO77, AF0)
+#define GPIO078_GPIO_78		MFP_CFG(GPIO78, AF0)
+#define GPIO079_GPIO_79			MFP_CFG(GPIO79, AF0)
+#define GPIO080_GPIO_80			MFP_CFG(GPIO80, AF0)
+
+
+#define GPIO081_GPIO_81			MFP_CFG(GPIO81, AF0)
+#define GPIO082_GPIO_82			MFP_CFG(GPIO82, AF0)
+#define GPIO083_GPIO_83			MFP_CFG(GPIO83, AF0)
+#define GPIO084_GPIO_84			MFP_CFG(GPIO84, AF0)
+#define GPIO085_GPIO_85			MFP_CFG(GPIO85, AF0)
+#define GPIO086_GPIO_86			MFP_CFG(GPIO86, AF0)
+
+#define GPIO087_CI2C_SCL_2		MFP_CFG(GPIO87, AF5)
+#define GPIO088_CI2C_SDA_2		MFP_CFG(GPIO88, AF5)
+#define GPIO087_GPIO_87			MFP_CFG(GPIO87, AF0)
+#define GPIO088_GPIO_88			MFP_CFG(GPIO88, AF0)
+
+#define GPIO089_GPIO_89			MFP_CFG(GPIO89, AF0)
+#define GPIO089_GPS_CLK		    MFP_CFG(GPIO89, AF5)
+#define GPIO090_GPIO_90			MFP_CFG(GPIO90, AF0)
+
+#define GPIO091_GPIO_91			MFP_CFG(GPIO91, AF0)
+#define GPIO092_GPIO_92			MFP_CFG(GPIO92, AF0)
+#define GPIO093_GPIO_93			MFP_CFG(GPIO93, AF0)
+#define GPIO094_GPIO_94			MFP_CFG(GPIO94, AF0)
+#define GPIO095_GPIO_95			MFP_CFG(GPIO95, AF0)
+#define GPIO096_GPIO_96			MFP_CFG(GPIO96, AF0)
+#define GPIO097_GPIO_97			MFP_CFG(GPIO97, AF0)
+#define GPIO098_GPIO_98			MFP_CFG(GPIO98, AF0)
+#define GPIO104_FIX_NONE		MFP_CFG(GPIO104, AF7)
+#define CLK_REQ_GPIO_123		MFP_CFG(CLK_REQ, AF1)
+#define GPIO124_GPIO_124		MFP_CFG(GPIO124, AF0)
+#define GPIO126_GPIO_126		MFP_CFG(GPIO126, AF0)
+#define GPIO127_GPIO_127		MFP_CFG(GPIO127, AF0)
+
+#define MMC1_DAT7_MMC1_DAT7		MFP_CFG(MMC1_DAT7, AF0)
+#define MMC1_DAT6_MMC1_DAT6		MFP_CFG(MMC1_DAT6, AF0)
+#define MMC1_DAT5_MMC1_DAT5		MFP_CFG(MMC1_DAT5, AF0)
+#define MMC1_DAT4_MMC1_DAT4		MFP_CFG(MMC1_DAT4, AF0)
+#define MMC1_DAT3_MMC1_DAT3		MFP_CFG(MMC1_DAT3, AF0)
+#define MMC1_DAT2_MMC1_DAT2		MFP_CFG(MMC1_DAT2, AF0)
+#define MMC1_DAT1_MMC1_DAT1		MFP_CFG(MMC1_DAT1, AF0)
+#define MMC1_DAT0_MMC1_DAT0		MFP_CFG(MMC1_DAT0, AF0)
+#define MMC1_CMD_MMC1_CMD		MFP_CFG(MMC1_CMD, AF0)
+#define MMC1_CLK_MMC1_CLK		MFP_CFG(MMC1_CLK, AF0)
+#define MMC1_CD_MMC1_CD			MFP_CFG(MMC1_CD, AF1)
+#define MMC1_WP_MMC1_WP			MFP_CFG(MMC1_WP, AF1) //GPIO99
+
+#define ND_IO7_MMC3_DAT7		MFP_CFG(DF_IO7, AF1)
+#define ND_IO6_MMC3_DAT6		MFP_CFG(DF_IO6, AF1)
+#define ND_IO5_MMC3_DAT5		MFP_CFG(DF_IO5, AF1)
+#define ND_IO4_MMC3_DAT4		MFP_CFG(DF_IO4, AF1)
+#define ND_IO3_MMC3_DAT3		MFP_CFG(DF_IO3, AF1)
+#define ND_IO2_MMC3_DAT2		MFP_CFG(DF_IO2, AF1)
+#define ND_IO1_MMC3_DAT1		MFP_CFG(DF_IO1, AF1)
+#define ND_IO0_MMC3_DAT0		MFP_CFG(DF_IO0, AF1)
+#define ND_CLE_SM_OEN_MMC3_CMD		MFP_CFG(DF_CLE_SM_OEn, AF1)
+//#define SM_SCLK_MMC3_CLK		MFP_CFG(SM_SCLK, AF1)
+#define SM_SCLK_MMC3_CLK		MFP_CFG_DRV(SM_SCLK, AF1, DS02X)
+#define SM_BEN0_MMC3_RSTN		MFP_CFG(SM_BE0, AF2)
+#define SM_BEN0_GPIO126         MFP_CFG(SM_BE0, AF0)
+
+#define ANT_SW4_GPIO_28			MFP_CFG(ANT_SW4, AF6)
+#define SM_ADV_GPIO_0			MFP_CFG(SM_ADV, AF1)
+#define ND_RDY1_GPIO_1			MFP_CFG(DF_RDY1, AF1)
+#define SM_ADVMUX_GPIO_2		MFP_CFG(SM_ADVMUX, AF1)
+#define SM_RDY_GPIO_3			MFP_CFG(SM_RDY, AF1)
+#define SM_BEN1_GPIO_127		MFP_CFG(SM_BE1, AF0)
+#define SM_CSN0_GPIO_103		MFP_CFG(SM_nCS0, AF1)
+#define SM_CSN1_GPIO_104		MFP_CFG(SM_nCS1, AF1)
+#define ND_CS0N2_GPIO_101		MFP_CFG(DF_nCS0_SM_nCS2, AF1)
+#define ND_CS1N3_GPIO_102		MFP_CFG(DF_nCS1_SM_nCS3, AF1)
+#define GPIO_ND_IO15_DAT15		MFP_CFG(DF_IO15, AF1)
+#define GPIO_ND_IO13_DAT13      MFP_CFG(DF_IO13, AF1)
+#define GPIO_ND_IO12_DAT12      MFP_CFG(DF_IO12, AF1)
+#define GPIO_ND_IO11_DAT11      MFP_CFG(DF_IO11, AF1)
+#define GPIO_ND_IO10_DAT10      MFP_CFG(DF_IO10, AF1)
+#define GPIO_ND_IO9_DAT9        MFP_CFG(DF_IO9, AF1)
+
+#define ND_IO15_ND_DAT15		MFP_CFG(DF_IO15, AF1) //GPIO60
+#define ND_IO14_ND_DAT14		MFP_CFG(DF_IO14, AF1) //GPIO61
+#define ND_IO13_ND_DAT13		MFP_CFG(DF_IO13, AF1) //GPIO62
+#define ND_IO12_ND_DAT12		MFP_CFG(DF_IO12, AF1) //GPIO63
+#define ND_IO11_ND_DAT11		MFP_CFG(DF_IO11, AF1) //GPIO64
+#define ND_IO10_ND_DAT10		MFP_CFG(DF_IO10, AF1) //GPIO65
+#define ND_IO9_ND_DAT9			MFP_CFG(DF_IO9, AF1) //GPIO66
+#define ND_IO8_ND_DAT8			MFP_CFG(DF_IO8, AF1) //GPIO100
+#define ND_nCS0_SM_nCS2			MFP_CFG(DF_nCS0_SM_nCS2, AF1) //GPIO101
+#define DF_ALE_SM_WEn_ND_ALE		MFP_CFG(DF_ALE_SM_WEn, AF0) //GPIO107
+#define DF_WEn_DF_WEn			MFP_CFG(DF_WEn, AF0) //GPIO105
+#define DF_REn_DF_REn			MFP_CFG(DF_REn, AF0) //GPIO106
+#define DF_RDY0_DF_RDY0			MFP_CFG(DF_RDY0, AF1) //GPIO108
+
+#define MFP_VCXO_OUT			MFP_CFG_DRV (VCXO_OUT, AF0, DS01X)
+#define VCXO_REQ			MFP_CFG(VCXO_REQ, AF0)
+#define GPIO_SLAVE_RESET_OUT		MFP_CFG(SLAVE_RESET_OUT, AF1) //GPIO122
+
+#endif /* __ASM_MACH_MFP_PXA988_H */
diff --git a/arch/arm/mach-mmp/include/mach/mfp.h b/arch/arm/mach-mmp/include/mach/mfp.h
index 62e510e8..d1a0e42c 100644
--- a/arch/arm/mach-mmp/include/mach/mfp.h
+++ b/arch/arm/mach-mmp/include/mach/mfp.h
@@ -21,9 +21,11 @@
 
 #undef MFP_CFG
 #undef MFP_CFG_DRV
-#undef MFP_CFG_LPM
-#undef MFP_CFG_X
-#undef MFP_CFG_DEFAULT
+
+#define MFP_VERY_SLOW		MFP_DS01X
+#define MFP_SLOW		MFP_DS02X
+#define MFP_MEDIUM		MFP_DS03X
+#define MFP_FAST		MFP_DS04X
 
 #define MFP_CFG(pin, af)		\
 	(MFP_LPM_FLOAT | MFP_PIN(MFP_PIN_##pin) | MFP_##af | MFP_DRIVE_MEDIUM)
diff --git a/arch/arm/mach-mmp/include/mach/mmp3.h b/arch/arm/mach-mmp/include/mach/mmp3.h
new file mode 100644
index 00000000..56dbbc52
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mmp3.h
@@ -0,0 +1,307 @@
+#ifndef __ASM_MACH_MMP3_H
+#define __ASM_MACH_MMP3_H
+
+struct sys_timer;
+
+extern struct sys_timer mmp3_timer;
+extern void __init mmp3_init_gic(void);
+extern void __init mmp3_init_irq(void);
+extern void __init mmp3_reserve(void);
+
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/i2c/pxa-i2c.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <mach/devices.h>
+#include <mach/cputype.h>
+#include <mach/regs-apbc.h>
+#include <plat/pxa27x_keypad.h>
+#include <plat/pxa3xx_nand.h>
+#include <linux/platform_data/pxa_sdhci.h>
+#include <mach/sram.h>
+#include <mach/uio_hdmi.h>
+#include <mach/pxa168fb.h>
+#include <mach/camera.h>
+
+#define IOPWRDOM_VIRT_BASE	(APB_VIRT_BASE + 0x1e800)
+#define PAD_1V8			(1 << 2)
+#define PAD_POWERDOWN		(1 << 0)
+#define AIB_HSIC3_IO_REG	0x0000
+#define AIB_HSIC2_IO_REG	0x0004
+#define AIB_GPIO2_IO_REG	0x000C
+#define AIB_GPIO3_IO_REG	0x0010
+#define AIB_TWSI_IO_REG		0x0014
+#define AIB_SDMMC_IO_REG	0x001c
+#define AIB_NAND_IO_REG		0x0020
+#define AIB_USIM_IO_REG		0x002c
+#define AIB_BB_IO_REG		0x0030
+
+extern struct pxa_device_desc mmp3_device_uart1;
+extern struct pxa_device_desc mmp3_device_uart2;
+extern struct pxa_device_desc mmp3_device_uart3;
+extern struct pxa_device_desc mmp3_device_uart4;
+extern struct pxa_device_desc mmp3_device_twsi1;
+extern struct pxa_device_desc mmp3_device_twsi2;
+extern struct pxa_device_desc mmp3_device_twsi3;
+extern struct pxa_device_desc mmp3_device_twsi4;
+extern struct pxa_device_desc mmp3_device_twsi5;
+extern struct pxa_device_desc mmp3_device_twsi6;
+extern struct pxa_device_desc mmp3_device_nand;
+extern struct pxa_device_desc mmp3_device_sdh0;
+extern struct pxa_device_desc mmp3_device_sdh1;
+extern struct pxa_device_desc mmp3_device_sdh2;
+extern struct pxa_device_desc mmp3_device_sdh3;
+extern struct pxa_device_desc mmp3_device_camera0;
+extern struct pxa_device_desc mmp3_device_camera1;
+extern struct pxa_device_desc mmp3_device_pwm1;
+extern struct pxa_device_desc mmp3_device_pwm2;
+extern struct pxa_device_desc mmp3_device_pwm3;
+extern struct pxa_device_desc mmp3_device_pwm4;
+extern struct pxa_device_desc mmp3_device_keypad;
+extern struct pxa_device_desc mmp3_device_fb;
+extern struct pxa_device_desc mmp3_device_fb_ovly;
+extern struct pxa_device_desc mmp3_device_v4l2_ovly;
+extern struct pxa_device_desc mmp3_device_fb_tv;
+extern struct pxa_device_desc mmp3_device_fb_tv_ovly;
+extern struct pxa_device_desc mmp3_device_v4l2_tv_ovly;
+extern struct pxa_device_desc mmp3_device_hdmi;
+extern struct pxa_device_desc mmp3_device_ddr_devfreq;
+extern struct pxa_device_desc mmp3_device_isram;
+extern struct pxa_device_desc mmp3_device_thermal;
+
+extern struct platform_device mmp3_device_gpio;
+extern struct platform_device mmp3_device_rtc;
+extern struct platform_device mmp3_device_vnc_touch;
+extern struct pxa_device_desc mmp3_device_ssp1;
+extern struct pxa_device_desc mmp3_device_ssp2;
+extern struct pxa_device_desc mmp3_device_ssp3;
+extern struct pxa_device_desc mmp3_device_ssp4;
+
+extern struct pxa_device_desc mmp3_device_asram;
+extern struct platform_device mmp3_device_u2o;
+extern struct platform_device mmp3_device_u2ootg;
+extern struct platform_device mmp3_device_u2oehci;
+extern struct platform_device mmp3_hsic1_device;
+extern struct platform_device mmp3_hsic2_device;
+
+extern struct platform_device mmp3_device_adma0;
+extern struct platform_device mmp3_device_adma1;
+extern struct platform_device mmp3_device_asoc_sspa1;
+extern struct platform_device mmp3_device_asoc_sspa2;
+
+extern void mmp_zsp_platform_device_init(void);
+extern void pxa_u3d_phy_disable(void);
+
+#define MAGIC_ASFAR	0xbaba
+#define MAGIC_ASSAR	0xeb10
+static inline void mmp3_io_domain_1v8(u16 reg, int set)
+{
+	u32 tmp;
+
+	writel(MAGIC_ASFAR, APBC_MMP2_ASFAR);
+	writel(MAGIC_ASSAR, APBC_MMP2_ASSAR);
+	tmp = readl(IOPWRDOM_VIRT_BASE + reg);
+
+	if (set)
+		tmp |= PAD_1V8;
+	else
+		tmp &= ~PAD_1V8;
+
+	writel(MAGIC_ASFAR, APBC_MMP2_ASFAR);
+	writel(MAGIC_ASSAR, APBC_MMP2_ASSAR);
+	writel(tmp, IOPWRDOM_VIRT_BASE + reg);
+}
+
+static inline int mmp3_add_ssp(int id)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+		case 1: d = &mmp3_device_ssp1; break;
+		case 2: d = &mmp3_device_ssp2; break;
+		case 3: d = &mmp3_device_ssp3; break;
+		case 4: d = &mmp3_device_ssp4; break;
+		default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, NULL, 0);
+}
+
+static inline int mmp3_add_spi(int id, struct pxa2xx_spi_master *pdata)
+{
+	struct platform_device *pd;
+	pd = platform_device_alloc("pxa2xx-spi", id);
+	if (pd == NULL) {
+		pr_err("pxa2xx-spi: failed to allocate device (id=%d)\n", id);
+		return -ENOMEM;
+	}
+
+	platform_device_add_data(pd, pdata, sizeof(*pdata));
+
+	return platform_device_add(pd);
+}
+
+static inline int mmp3_add_uart(int id)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 1: d = &mmp3_device_uart1; break;
+	case 2: d = &mmp3_device_uart2; break;
+	case 3: d = &mmp3_device_uart3; break;
+	case 4: d = &mmp3_device_uart4; break;
+	default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, NULL, 0);
+}
+
+static inline int mmp3_add_thermal(void)
+{
+	return pxa_register_device(&mmp3_device_thermal, NULL, 0);
+}
+
+static inline int mmp3_add_twsi(int id, struct i2c_pxa_platform_data *data,
+				  struct i2c_board_info *info, unsigned size)
+{
+	struct pxa_device_desc *d = NULL;
+	int ret;
+
+	switch (id) {
+	case 1: d = &mmp3_device_twsi1; break;
+	case 2: d = &mmp3_device_twsi2; break;
+	case 3: d = &mmp3_device_twsi3; break;
+	case 4: d = &mmp3_device_twsi4; break;
+	case 5: d = &mmp3_device_twsi5; break;
+	case 6: d = &mmp3_device_twsi6; break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = i2c_register_board_info(id - 1, info, size);
+	if (ret)
+		return ret;
+
+	return pxa_register_device(d, data, sizeof(*data));
+}
+
+static inline int mmp3_add_cam(int id, struct mmp_cam_pdata *pdata)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 0:
+		d = &mmp3_device_camera0; break;
+	case 1:
+		d = &mmp3_device_camera1; break;
+	default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, pdata, sizeof(*pdata));
+}
+
+static inline int mmp3_add_ddr_devfreq(void)
+{
+	return pxa_register_device(&mmp3_device_ddr_devfreq, NULL, 0);
+}
+
+static inline int mmp3_add_nand(struct pxa3xx_nand_platform_data *info)
+{
+	return pxa_register_device(&mmp3_device_nand, info, sizeof(*info));
+}
+
+static inline int mmp3_add_sdh(int id, struct sdhci_pxa_platdata *data)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 0: d = &mmp3_device_sdh0; break;
+	case 1: d = &mmp3_device_sdh1; break;
+	case 2: d = &mmp3_device_sdh2; break;
+	case 3: d = &mmp3_device_sdh3; break;
+	default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, data, sizeof(*data));
+}
+
+static inline int mmp3_add_pwm(int id)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 1:
+		d = &mmp3_device_pwm1;
+		break;
+	case 2:
+		d = &mmp3_device_pwm2;
+		break;
+	case 3:
+		d = &mmp3_device_pwm3;
+		break;
+	case 4:
+		d = &mmp3_device_pwm4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, NULL, 0);
+}
+
+static inline int mmp3_add_hdmi(struct uio_hdmi_platform_data *data)
+{
+        return pxa_register_device(&mmp3_device_hdmi, data, sizeof(*data));
+}
+
+static inline int mmp3_add_fb(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&mmp3_device_fb, mi, sizeof(*mi));
+}
+
+static inline int mmp3_add_fb_ovly(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&mmp3_device_fb_ovly, mi, sizeof(*mi));
+}
+
+static inline int mmp3_add_v4l2_ovly(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&mmp3_device_v4l2_ovly, mi, sizeof(*mi));
+}
+
+static inline int mmp3_add_fb_tv(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&mmp3_device_fb_tv, mi, sizeof(*mi));
+}
+
+static inline int mmp3_add_fb_tv_ovly(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&mmp3_device_fb_tv_ovly, mi, sizeof(*mi));
+}
+
+static inline int mmp3_add_v4l2_tv_ovly(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&mmp3_device_v4l2_tv_ovly, mi, sizeof(*mi));
+}
+
+extern void mmp3_clear_keypad_wakeup(void);
+static inline int mmp3_add_keypad(struct pxa27x_keypad_platform_data *data)
+{
+	data->clear_wakeup_event = mmp3_clear_keypad_wakeup;
+	return pxa_register_device(&mmp3_device_keypad, data, sizeof(*data));
+}
+
+static inline int mmp3_add_asram(struct sram_platdata *data)
+{
+	return pxa_register_device(&mmp3_device_asram, data, sizeof(*data));
+}
+
+static inline int mmp3_add_isram(struct sram_platdata *data)
+{
+	return pxa_register_device(&mmp3_device_isram, data, sizeof(*data));
+}
+#endif /* __ASM_MACH_MMP2_H */
diff --git a/arch/arm/mach-mmp/include/mach/mmp_device.h b/arch/arm/mach-mmp/include/mach/mmp_device.h
new file mode 100644
index 00000000..52873e94
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mmp_device.h
@@ -0,0 +1,69 @@
+/*
+ * arch/arm/mach-mmp/include/mach/mmp_device.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MMP_DEVICE__
+#define __MMP_DEVICE__
+
+#include <linux/pm_qos.h>
+
+#define MAX_OPT_CLKS	3
+struct mmp_hw_desc {
+	const char		*name;
+	int			id;
+	unsigned int		constraint;
+	const char		*fn_clk;
+	const char		*opt_clks[MAX_OPT_CLKS];
+};
+
+struct mmp_clk {
+	const char	*name;
+	struct clk	*clk;
+};
+
+struct mmp_device;
+struct mmp_device_hw {
+	const char		*name;
+	int			id;
+	struct mmp_clk		fn_clk;
+	struct mmp_clk		opt_clks[MAX_OPT_CLKS];
+	unsigned int		constraint;
+	int (*activate_func)(struct mmp_device *);
+	int (*deactivate_func)(struct mmp_device *);
+
+	struct pm_qos_request   qos_idle;
+	struct list_head	node;
+};
+
+struct mmp_device {
+	struct platform_device	*pdev;
+	struct mmp_device_hw	*hw;
+#define MMP_DEVICE_STATE_ACTIVE		1
+#define MMP_DEVICE_STATE_IDLE		2
+	unsigned int		state;
+
+#define MMP_DEVICE_NO_IDLE_ON_SUSPEND 	(1 << 0)
+#define MMP_DEVICE_SUSPENDED		(1 << 1)
+	unsigned int		flags;
+};
+
+#define MMP_HW_DESC(_name, _desc, _id, _constraint, _fn_clk, _opt_clk...) \
+struct mmp_hw_desc mmp_device_hw_##_name __initdata = {			\
+	.name		= _desc,					\
+	.id		= _id,						\
+	.constraint	= _constraint,					\
+	.fn_clk		= _fn_clk,					\
+	.opt_clks	= { _opt_clk },					\
+}
+
+static inline struct mmp_device *to_mmp_device(struct platform_device *pdev)
+{
+	return pdev ? pdev->archdata.md : NULL;
+}
+
+int __init mmp_device_hw_register(struct mmp_hw_desc *desc);
+#endif /* __MMP_DEVICE__ */
diff --git a/arch/arm/mach-mmp/include/mach/pxa168fb.h b/arch/arm/mach-mmp/include/mach/pxa168fb.h
new file mode 100644
index 00000000..228e9b2c
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/pxa168fb.h
@@ -0,0 +1,678 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/pxa168fb.h
+ *
+ *  Copyright (C) 2009 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_PXA168FB_H
+#define __ASM_MACH_PXA168FB_H
+/* ---------------------------------------------- */
+/*              Header Files                      */
+/* ---------------------------------------------- */
+#include <linux/fb.h>
+#include <plat/fb_ioctl.h>
+#define VSYNC_DSI_CMD
+
+#ifdef __KERNEL__
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <mach/cputype.h>
+#include <linux/pm_qos.h>
+
+/* Dumb interface */
+#define PIN_MODE_DUMB_24		0
+#define PIN_MODE_DUMB_18_SPI		1
+#define PIN_MODE_DUMB_18_GPIO		2
+#define PIN_MODE_DUMB_16_SPI		3
+#define PIN_MODE_DUMB_16_GPIO		4
+#define PIN_MODE_DUMB_12_SPI_GPIO	5
+#define PIN_MODE_SMART_18_SPI		6
+#define PIN_MODE_SMART_16_SPI		7
+#define PIN_MODE_SMART_8_SPI_GPIO	8
+#define PIN_MODE_DUMB_18_SMART_8	9
+#define PIN_MODE_DUMB_16_SMART_8_SPI	10
+#define PIN_MODE_DUMB_16_SMART_8_GPIO	11
+#define PIN_MODE_DUMB_16_DUMB_16	12
+
+/*I/O pad control*/
+#define CFG_BOUNDARY_1KB	(1<<5)	/*no crossing 1KB boundary*/
+#define CFG_BOUNDARY_4KB	(0<<5)	/*no crossing 4KB boundary*/
+#define CFG_CYC_BURST_LEN16	(1<<4)
+#define CFG_CYC_BURST_LEN8	(0<<4)
+
+/* Dumb interface pin allocation */
+#define DUMB_MODE_RGB565		0
+#define DUMB_MODE_RGB565_UPPER		1
+#define DUMB_MODE_RGB666		2
+#define DUMB_MODE_RGB666_UPPER		3
+#define DUMB_MODE_RGB444		4
+#define DUMB_MODE_RGB444_UPPER		5
+#define DUMB_MODE_RGB888		6
+
+#define MAX_FB_INFO	(3)
+
+/* default fb buffer size WVGA-32bits */
+#if defined(CONFIG_MACH_WILCOX)
+#define DEFAULT_FB_SIZE	((960 * 544 * 12)+ 4096)
+#elif defined(CONFIG_MACH_DEGA) 
+#define DEFAULT_FB_SIZE	((800 * 1280 * 12)+ 4096)
+#elif defined(CONFIG_MACH_LT02) || defined(CONFIG_MACH_GOYA)
+#define DEFAULT_FB_SIZE	((1024 * 600 * 12)+ 4096)
+#else
+#define DEFAULT_FB_SIZE	((800 * 480 * 12)+ 4096)
+#endif
+/*
+ * Buffer pixel format
+ * bit0 is for rb swap.
+ * bit12 is for Y UorV swap
+ */
+#define PIX_FMT_RGB565		0
+#define PIX_FMT_BGR565		1
+#define PIX_FMT_RGB1555		2
+#define PIX_FMT_BGR1555		3
+#define PIX_FMT_RGB888PACK	4
+#define PIX_FMT_BGR888PACK	5
+#define PIX_FMT_RGB888UNPACK	6
+#define PIX_FMT_BGR888UNPACK	7
+#define PIX_FMT_RGBA888		8
+#define PIX_FMT_BGRA888		9
+#define PIX_FMT_YUV422PACK	10
+#define PIX_FMT_YVU422PACK	11
+#define PIX_FMT_YUV422PLANAR	12
+#define PIX_FMT_YVU422PLANAR	13
+#define PIX_FMT_YUV420PLANAR	14
+#define PIX_FMT_YVU420PLANAR	15
+#define PIX_FMT_RGB888A		22
+#define PIX_FMT_BGR888A		23
+#define PIX_FMT_YUV420SEMIPLANAR	24
+#define PIX_FMT_YVU420SEMIPLANAR	25
+#define PIX_FMT_PSEUDOCOLOR	20
+#define PIX_FMT_YUYV422PACK	(0x1000|PIX_FMT_YUV422PACK)
+#define PIX_FMT_YUV422PACK_IRE_90_270	(0x1000|PIX_FMT_RGB888UNPACK)
+
+/*
+ * panel interface
+ */
+enum {
+	DPI = 0,
+	DSI2DPI = 1,
+	DSI = 2,
+	LVDS =4,
+};
+/* flags indicate update region for regshadow
+ * bit[0] = 1, address need update;
+ * bit[1] = 1, video mode need update;
+ * bit[2] = 1, viewport control info need update;
+ */
+#define UPDATE_ADDR (0x1 << 0)
+#define UPDATE_MODE (0x1 << 1)
+#define UPDATE_VIEW (0x1 << 2)
+
+struct regshadow {
+	u32	flags;
+
+	/* address */
+	u32	paddr0[3];
+	u32	paddr1[3];
+
+	/* video mode */
+	u32	dma_ctrl0;
+	u32	yuv420sp_ctrl;
+
+	/* viewport info*/
+	u32	pitch[2];
+	u32	start_point;
+	u32	src_size;
+	u32	dst_size;
+	u32	zoom;
+};
+
+/* shadowreg list for flip mode */
+struct regshadow_list {
+	struct regshadow shadowreg;
+	struct list_head dma_queue;
+};
+
+struct pxa168fb_vdma_info {
+	struct device	*dev;
+	void		*reg_base;
+	int		ch;
+	/* path id, 0->panel, 1->TV, 2->panel2 */
+	int		path;
+	int		pix_fmt;
+	unsigned int	sram_size;
+	unsigned int	rotation;
+	unsigned int	yuv_format;
+	unsigned int	vdma_lines;
+	unsigned int	sram_paddr;
+	unsigned int	sram_vaddr;
+	unsigned	vid:1,
+			active:1,
+			dma_on:1,
+			enable:1;
+};
+/*
+ * PXA LCD controller private state.
+ */
+struct pxa168fb_info {
+	struct device		*dev;
+	struct clk		*clk;
+	__kernel_suseconds_t	frm_usec;
+	int			id;
+	int			vid;
+	void			*reg_base;
+	unsigned char		*filterBufList[MAX_QUEUE_NUM][3];
+	struct regshadow_list	buf_freelist;
+	struct regshadow_list	buf_waitlist;
+	struct regshadow_list	*buf_current;
+	dma_addr_t		fb_start_dma;
+	void			*fb_start;
+	int			fb_size;
+	u32			scrn_act_bak;
+	atomic_t		op_count;
+	atomic_t		irq_en_count;
+	atomic_t		w_intr;
+	atomic_t		w_intr1;
+	atomic_t		vsync_cnt;
+	wait_queue_head_t	w_intr_wq;
+	wait_queue_head_t	w_intr_wq1;
+	struct mutex		access_ok;
+	struct mutex		output_lock;
+	spinlock_t		job_lock;
+	spinlock_t		buf_lock;
+	spinlock_t		dfc_lock;
+	struct _sOvlySurface    surface;
+	struct _sOvlySurface    surface_bak;
+	struct regshadow	shadowreg;
+	struct _sColorKeyNAlpha ckey_alpha;
+	struct fb_videomode	dft_vmode;
+	unsigned int		pseudo_palette[16];
+	struct fb_info          *fb_info;
+	int			pix_fmt;
+	int			debug;
+	unsigned		is_blanked:1,
+				surface_set:1,
+				output_on:1,
+				active:1;
+	/* indicate dma on/off requirement from user space */
+	int			dma_on;
+	/* lock for variables, e.g. active */
+	spinlock_t		var_lock;
+	unsigned                wait_vsync;
+	unsigned                vsync_en;
+	uint64_t		vsync_ts_nano;
+	struct work_struct	vsync_work;
+	struct workqueue_struct	*workqueue;
+
+	/* Compatibility mode global switch .....
+	 *
+	 * This is a secret switch for user space programs that may want to
+	 * select color spaces and set resolutions the same as legacy PXA
+	 * display drivers. The switch is set and unset by setting a specific
+	 * value in the var_screeninfo.nonstd variable.
+	 *
+	 * To turn on/off compatibility with older PXA:
+	 * set the MSB of nonstd to 0xAA to turn it on.
+	 * set the MSB of nonstd to 0x55 to turn it off.
+	 */
+	unsigned int	compat_mode;
+
+	unsigned		irq_mask;
+	/* if display is enabled in uboot, skip power on sequence in kernel */
+	unsigned		skip_pw_on;
+
+	struct fb_var_screeninfo var_bak;
+
+	/* gamma correction */
+	struct mvdisp_gamma	gamma;
+	struct pm_qos_request   qos_idle;
+	/*
+	 * separated display clock
+	 * controller clock is for reg access - bind with pm runtime
+	 * path clock is for each path
+	 * phy clock is for dsi/hdmi phy (in case we have)
+	*/
+	struct clk	*path_clk;
+	struct clk	*phy_clk;
+#ifdef VSYNC_DSI_CMD
+		//wait_queue_head_t vsync_detect_wq;
+		//int vsync_detected;
+		struct mutex cmd_mutex; /* Frequency change mutex */
+		struct mutex vsync_mutex; /* Frequency change mutex */
+
+#endif
+};
+
+struct dsi_phy {
+	unsigned int hs_prep_constant;    /* Unit: ns. */
+	unsigned int hs_prep_ui;
+	unsigned int hs_zero_constant;
+	unsigned int hs_zero_ui;
+	unsigned int hs_trail_constant;
+	unsigned int hs_trail_ui;
+	unsigned int hs_exit_constant;
+	unsigned int hs_exit_ui;
+	unsigned int ck_zero_constant;
+	unsigned int ck_zero_ui;
+	unsigned int ck_trail_constant;
+	unsigned int ck_trail_ui;
+	unsigned int req_ready;
+	unsigned int wakeup_constant;
+	unsigned int wakeup_ui;
+	unsigned int lpx_constant;
+	unsigned int lpx_ui;
+};
+
+struct dsi_info {
+	unsigned	id;
+	unsigned	regs;
+	unsigned	lanes;
+	unsigned	bpp;
+	unsigned	rgb_mode;
+	unsigned	burst_mode;
+	unsigned	master_mode;
+	unsigned	lpm_line_en;
+	unsigned	lpm_frame_en;
+	unsigned	last_line_turn;
+	unsigned	hex_slot_en;
+	unsigned	all_slot_en;
+	unsigned	hbp_en;
+	unsigned	hact_en;
+	unsigned	hfp_en;
+	unsigned	hex_en;
+	unsigned	hlp_en;
+	unsigned	hsa_en;
+	unsigned	hse_en;
+	unsigned	eotp_en;
+	struct dsi_phy  *phy;
+};
+
+/* LVDS info */
+struct lvds_info {
+#define LVDS_SRC_PN	0
+#define LVDS_SRC_CMU	1
+#define LVDS_SRC_PN2	2
+#define LVDS_SRC_TV	3
+	u32	src;
+#define LVDS_FMT_24BIT	0
+#define LVDS_FMT_18BIT	1
+	u32	fmt;
+};
+
+/*
+ * CMU information
+ */
+struct cmu_calibration {
+	int left;
+	int right;
+	int top;
+	int bottom;
+};
+struct cmu_res {
+	int width;
+	int height;
+};
+
+struct pxa168fb_lcd_platform_driver {
+	int (*reset)(struct pxa168fb_info *);
+	int (*power)(struct pxa168fb_info *, int on);
+};
+
+struct pxa168fb_mipi_lcd_driver {
+	int (*probe)(struct pxa168fb_info *);
+	int (*reset)(struct pxa168fb_info *);    
+	int (*init)(struct pxa168fb_info *);
+	int (*enable)(struct pxa168fb_info *);
+	int (*disable)(struct pxa168fb_info *);
+};
+
+/*
+ * PXA fb machine information
+ */
+struct pxa168fb_mach_info {
+	char	id[16];
+	union {
+		unsigned int	sclk_src;     /* source clk rate */
+		unsigned int 	sclk_default; /* unit MHz */
+	};
+	unsigned int	sclk_div;
+	unsigned int	sclk_rst;
+
+	int		num_modes;
+	struct fb_videomode *modes;
+	unsigned int max_fb_size;
+	unsigned int xres_virtual;
+	unsigned int xres_alignment;
+	unsigned int yres_alignment;
+
+	/*
+	 * Pix_fmt
+	 */
+	unsigned	pix_fmt;
+	/*
+	 *ISR clear mask
+	 */
+	unsigned	isr_clear_mask;
+	/*
+	 * I/O pad control.
+	 */
+	unsigned int	io_pad_ctrl;
+
+	/*
+	 * Dumb panel -- assignment of R/G/B component info to the 24
+	 * available external data lanes.
+	 */
+	unsigned	dumb_mode:4;
+	unsigned	panel_rgb_reverse_lanes:1;
+
+	/*
+	 * Dumb panel -- GPIO output data.
+	 */
+	unsigned	gpio_output_mask:8;
+	unsigned	gpio_output_data:8;
+
+	/*
+	 * Dumb panel -- configurable output signal polarity.
+	 */
+	unsigned	invert_composite_blank:1;
+	unsigned	invert_pix_val_ena:1;
+	unsigned	invert_pixclock:1;
+	unsigned	invert_vsync:1;
+	unsigned	invert_hsync:1;
+	unsigned	panel_rbswap:1;
+	unsigned	active:1;
+	unsigned	enable_lcd:1;
+	unsigned	mmap:2;
+
+	/*
+	 * dither option
+	 */
+	unsigned	dither_en:1;
+#define DITHER_TBL_4X4	0
+#define DITHER_TBL_4X8	1
+	unsigned	dither_table:1;
+#define DITHER_MODE_RGB444	0
+#define DITHER_MODE_RGB565	1
+#define DITHER_MODE_RGB666	2
+	unsigned	dither_mode:2;
+
+	/*
+	 * SPI control
+	 */
+	unsigned int	spi_ctrl;
+	unsigned int	spi_gpio_cs;
+	unsigned int	spi_gpio_reset;
+
+	/*
+	 * panel interface
+	*/
+	unsigned int	phy_type;
+	int		(*phy_init)(struct pxa168fb_info *);
+	void		*phy_info;
+
+	/*
+	 * for AMOLED panel
+	 */
+	unsigned int	last_dummy_lines;
+
+	/*
+	 * vdma option
+	 */
+	unsigned int vdma_enable;
+	unsigned int sram_size;
+	unsigned int height;			/* height of picture in mm    */
+	unsigned int width;			/* width of picture in mm     */
+
+	/*
+	 * power on/off function.
+	 */
+	int (*pxa168fb_lcd_power)(struct pxa168fb_info *,
+			 unsigned int, unsigned int, int);
+
+	/*
+	 * dsi to dpi setting function
+	 */
+	int (*exter_brige_init)(struct pxa168fb_info *);
+	int (*exter_brige_pwr)(struct pxa168fb_info *, int on);
+
+	/* init config for panel via dsi */
+	void (*dsi_panel_config)(struct pxa168fb_info *);
+
+	struct pxa168fb_lcd_platform_driver *lcd_platform_driver;
+	struct pxa168fb_mipi_lcd_driver *lcd_driver;
+	/*
+	 * special ioctls
+	 */
+	int (*ioctl)(struct fb_info *info, unsigned int cmd, unsigned long arg);
+	/*CMU platform calibration*/
+	struct cmu_calibration cmu_cal[3];
+	struct cmu_calibration cmu_cal_letter_box[3];
+	/*legacy clk flag*/
+	int	no_legacy_clk;
+	const char *path_clk_name;
+	const char *phy_clk_name;
+};
+
+struct fbi_info {
+	struct pxa168fb_info *fbi[MAX_FB_INFO];
+};
+
+enum dsi_packet_di {
+	/* for sleep in/out display on/off */
+	DSI_DI_DCS_SWRITE = 0x5,
+	/* for set_pixel_format */
+	DSI_DI_DCS_SWRITE1 = 0x15,
+	DSI_DI_GENERIC_LWRITE = 0x29,
+	DSI_DI_DCS_LWRITE = 0x39,
+	DSI_DI_DCS_READ = 0x6,
+	DSI_DI_SET_MAX_PKT_SIZE = 0x37,
+	/* for video mode off */
+	DSI_DI_PERIPHE_CMD_OFF = 0x22,
+	/* for video mode on */
+	DSI_DI_PERIPHE_CMD_ON = 0x32,
+	/* for long packet gen command */
+	DSI_DI_DCS_GEN_LWRITE = 0x29,	
+};
+
+enum dsi_rx_packet_di {
+	DSI_DI_ACK_ERR_RESP = 0x2,
+	DSI_DI_EOTP = 0x8,
+	DSI_DI_GEN_READ1_RESP = 0x11,
+	DSI_DI_GEN_READ2_RESP = 0x12,
+	DSI_DI_GEN_LREAD_RESP = 0x1A,
+	DSI_DI_DCS_READ1_RESP = 0x21,
+	DSI_DI_DCS_READ2_RESP = 0x22,
+	DSI_DI_DCS_LREAD_RESP = 0x1C,
+};
+
+struct dsi_cmd_desc {
+	enum dsi_packet_di data_type;
+	u8  lp;    /*command tx through low power mode or high-speed mode */
+	u32 delay; /* time to delay */
+	u32 length; /* cmds length */
+	u8 *data;
+};
+
+#define BPP_16		0x55
+#define BPP_18		0x66
+#define BPP_24		0x77
+
+/* LCD partial display */
+#define THRESHOLD_PN	64
+#define THRESHOLD_TV	100
+#define BURST_LEN		64
+
+/* DSI burst mode */
+#define DSI_BURST_MODE_SYNC_PULSE			0x0
+#define DSI_BURST_MODE_SYNC_EVENT			0x1
+#define DSI_BURST_MODE_BURST				0x2
+
+/* DSI input data RGB mode */
+#define DSI_LCD_INPUT_DATA_RGB_MODE_565			0
+#define DSI_LCD_INPUT_DATA_RGB_MODE_666PACKET		1
+#define DSI_LCD_INPUT_DATA_RGB_MODE_666UNPACKET		2
+#define DSI_LCD_INPUT_DATA_RGB_MODE_888			3
+
+/* DSI maximum packet data buffer */
+#define DSI_MAX_DATA_BYTES	256
+/* LCD ISR clear mask */
+#define LCD_ISR_CLEAR_MASK_PXA168       0xffffffff
+#define LCD_ISR_CLEAR_MASK_PXA910       0xffff00cc
+
+struct dsi_buf {
+	enum dsi_rx_packet_di data_type;
+	u32 length; /* cmds length */
+	u8 data[DSI_MAX_DATA_BYTES];
+};
+extern struct lcd_regs *get_regs(int id);
+extern struct cmu_calibration cmu_cal[3];
+extern struct cmu_calibration cmu_cal_letter_box[3];
+extern struct cmu_res res;
+
+extern u32 dma_ctrl_read(int id, int ctrl1);
+extern void dma_ctrl_write(int id, int ctrl1, u32 value);
+extern void dma_ctrl_set(int id, int ctrl1, u32 mask, u32 value);
+extern void panel_dma_ctrl(bool flag);
+extern void irq_mask_set(int id, u32 mask, u32 val);
+extern void irq_status_clear(int id, u32 mask);
+extern int lcd_clk_get(int id, u32 type);
+extern void lcd_clk_set(int id, u32 type, u32 mask, u32 val);
+extern void yuvsp_fmt_ctrl(u32 mask, u32 value);
+
+extern void pxa988_reserve_fb_mem(void);
+extern int pxa168fb_spi_send(struct pxa168fb_info *fbi, void *cmd,
+				 int count, unsigned int spi_gpio_cs);
+extern int pxa688_cmu_ioctl(struct fb_info *info, unsigned int cmd,
+				 unsigned long arg);
+extern void irq_mask_eof(int id);
+extern void irq_unmask_eof(int id);
+#ifdef CONFIG_PXA688_PHY
+/* dsi related */
+#ifdef VSYNC_DSI_CMD
+extern void pxa168_dsi_cmd_array_tx(struct pxa168fb_info *fbi, struct dsi_cmd_desc cmds[],
+		int count);
+
+extern void dsi_prepare_cmd_array_tx(struct pxa168fb_info *fbi, struct dsi_cmd_desc cmds[],
+		int count, u8 *buffer, u8 *packet_len);
+extern void dsi_send_prepared_cmd_tx(struct pxa168fb_info *fbi, struct dsi_cmd_desc cmds,
+		u8 *buffer,u8 len);
+extern void pxa168_dsi_cmd_array_rx(struct pxa168fb_info *fbi, struct dsi_buf *dbuf,
+		struct dsi_cmd_desc cmds[], int count);
+extern void dsi_cmd_array_rx_process(struct pxa168fb_info *fbi, struct dsi_buf *dbuf);
+extern void dsi_lanes_reset(struct pxa168fb_info *fbi);
+extern void dsi_lanes_check(struct pxa168fb_info *fbi);
+extern void dsi_lanes_debug(struct pxa168fb_info *fbi);
+
+#endif
+extern void dsi_cmd_array_tx(struct pxa168fb_info *fbi,
+		struct dsi_cmd_desc cmds[], int count);
+extern void dsi_cmd_array_rx(struct pxa168fb_info *fbi, struct dsi_buf *dbuf,
+		struct dsi_cmd_desc cmds[], int count);
+extern void set_dsi_low_power_mode(struct pxa168fb_info *fbi);
+extern void dsi_cclk_set(struct pxa168fb_info *fbi, int en);
+extern void dsi_set_dphy(struct pxa168fb_info *fbi);
+extern void dsi_reset(struct pxa168fb_info *fbi, int hold);
+extern void dsi_set_controller(struct pxa168fb_info *fbi);
+extern void dsi_lanes_enable(struct pxa168fb_info *fbi, int en);
+extern void dsi_set_panel_interface(struct pxa168fb_info *fbi, bool on);
+extern void dsi_set_panel_intf(struct pxa168fb_info *fbi, bool on);
+/* LVDS related */
+extern int pxa688_lvds_init(struct pxa168fb_info *fbi);
+extern void dsi_dphy_force_ulps_mode(struct pxa168fb_info *fbi);
+extern void dsi_dphy_exit_ulps_mode(struct pxa168fb_info *fbi);
+extern void dsi_ulps_tx_enable(struct pxa168fb_info *fbi, int en);
+void dsi_reset_dsi_module(struct pxa168fb_info *fbi);
+#else
+static inline void dsi_cmd_array_tx(struct pxa168fb_info *fbi,
+		struct dsi_cmd_desc cmds[], int count){}
+static inline void dsi_cmd_array_rx(struct pxa168fb_info *fbi,
+		struct dsi_buf *dbuf, struct dsi_cmd_desc cmds[], int count){}
+static inline void set_dsi_low_power_mode(struct pxa168fb_info *fbi){}
+static inline void dsi_cclk_set(struct pxa168fb_info *fbi, int en){}
+static inline void dsi_set_dphy(struct pxa168fb_info *fbi){}
+static inline void dsi_reset(struct pxa168fb_info *fbi, int hold){}
+static inline void dsi_set_controller(struct pxa168fb_info *fbi){}
+static inline void dsi_lanes_enable(struct pxa168fb_info *fbi, int en){}
+static inline void dsi_set_panel_intf(struct pxa168fb_info *fbi, bool on) {}
+static inline int pxa688_lvds_init(struct pxa168fb_info *fbi)
+{
+	return -EINVAL;
+}
+#endif
+
+/* VDMA related */
+#ifdef CONFIG_PXA688_VDMA
+#define EOF_TIMEOUT 20
+extern struct pxa168fb_vdma_info *request_vdma(int path, int vid);
+extern void pxa688_vdma_init(struct pxa168fb_vdma_info *lcd_vdma);
+extern void pxa688_vdma_config(struct pxa168fb_vdma_info *lcd_vdma);
+extern void pxa688_vdma_release(int path, int vid);
+extern int pxa688_vdma_en(struct pxa168fb_vdma_info *lcd_vdma,
+			int enable, int vid);
+static inline void vdma_info_update(struct pxa168fb_vdma_info *lcd_vdma,
+		int active, int dma_on, int pix_fmt, unsigned int rotation,
+		unsigned int yuv_format)
+{
+	lcd_vdma->active = active;
+	lcd_vdma->dma_on = dma_on;
+	lcd_vdma->pix_fmt = pix_fmt;
+	lcd_vdma->rotation = rotation;
+	lcd_vdma->yuv_format = yuv_format;
+}
+#else
+static inline struct pxa168fb_vdma_info *request_vdma(int path, int vid)
+{
+	return 0;
+}
+static inline void pxa688_vdma_init(struct pxa168fb_vdma_info *lcd_vdma) {}
+static inline void pxa688_vdma_config(struct pxa168fb_vdma_info *lcd_vdma) {}
+static inline void pxa688_vdma_release(int path, int vid) {}
+static inline int pxa688_vdma_en(struct pxa168fb_vdma_info *lcd_vdma,
+				int enable, int vid)
+{
+	return -EINVAL;
+}
+static inline void vdma_info_update(struct pxa168fb_vdma_info *lcd_vdma,
+		int active, int dma_on, int pix_fmt, unsigned int rotation,
+		unsigned int yuv_format) {}
+#endif
+
+/* misc */
+extern int fb_filter;
+extern int fb_vsmooth;
+extern int gfx_vsmooth;
+extern int vid_vsmooth;
+extern struct device_attribute dev_attr_misc;
+extern void dynamic_change_pll3(unsigned int rate);
+extern int dip_register_notifier(struct notifier_block *nb, unsigned int list);
+#ifdef CONFIG_PXA688_MISC
+extern int pxa688fb_vsmooth_set(int id, int vid, int en);
+extern int pxa688fb_partdisp_set(struct mvdisp_partdisp grap);
+extern void pxa688fb_partdisp_update(int id);
+extern int gamma_set(int path, int flag, char *gamma_table);
+extern void gamma_dump(int path, int lines);
+extern void dither_set(struct pxa168fb_info *fbi,
+	int table, int mode, int enable);
+#else
+static inline int pxa688fb_vsmooth_set(int id, int vid, int en)
+{
+	return 0;
+}
+static inline int pxa688fb_partdisp_set(struct mvdisp_partdisp grap)
+{
+	return -EINVAL;
+}
+static inline void pxa688fb_partdisp_update(int id) { }
+#define gamma_set(path, flag, gamma_table)		do {} while (0)
+#define gamma_dump(path, lines)				do {} while(0)
+#define dither_set(fbi, table, mode, enable)	do {} while (0)
+#endif
+
+extern int is_fhd_lcd(void);
+
+#endif /* __KERNEL__ */
+#endif /* __ASM_MACH_PXA168FB_H */
diff --git a/arch/arm/mach-mmp/include/mach/pxa988.h b/arch/arm/mach-mmp/include/mach/pxa988.h
new file mode 100644
index 00000000..dc4ee0e2
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/pxa988.h
@@ -0,0 +1,277 @@
+#ifndef __ASM_CPU_PXA988_H
+#define __ASM_CPU_PXA988_H
+
+struct sys_timer;
+
+extern struct sys_timer pxa988_timer;
+extern void __init pxa988_init_gic(void);
+extern void __init pxa988_init_irq(void);
+extern void __init pxa988_init_early(void);
+extern void __init pxa988_reserve(void);
+extern void pxa988_ripc_lock(void);
+extern void pxa988_ripc_unlock(void);
+extern int pxa988_ripc_trylock(void);
+extern int pxa988_ripc_status(void);
+extern spinlock_t ripc_lock;
+
+#if defined(CONFIG_D2199_DVC)
+int d2199_dvc_set_voltage(int buck_id, int level);
+#else
+extern int dvc_set_voltage(int buck_id, int volt);
+#endif
+
+#include <linux/i2c.h>
+#include <linux/i2c/pxa-i2c.h>
+#include <mach/devices.h>
+#include <mach/cputype.h>
+#include <mach/regs-apbc.h>
+#include <mach/sram.h>
+#include <plat/pxa27x_keypad.h>
+#include <linux/platform_data/pxa_sdhci.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <mach/pxa168fb.h>
+#include <mach/camera.h>
+
+extern struct pxa_device_desc pxa988_device_uart0;
+extern struct pxa_device_desc pxa988_device_uart1;
+extern struct pxa_device_desc pxa988_device_uart2;
+extern struct pxa_device_desc pxa988_device_keypad;
+extern struct pxa_device_desc pxa988_device_twsi0;
+extern struct pxa_device_desc pxa988_device_twsi1;
+extern struct pxa_device_desc pxa988_device_twsi2;
+extern struct pxa_device_desc pxa988_device_pwm1;
+extern struct pxa_device_desc pxa988_device_pwm2;
+extern struct pxa_device_desc pxa988_device_pwm3;
+extern struct pxa_device_desc pxa988_device_pwm4;
+extern struct pxa_device_desc pxa988_device_sdh1;
+extern struct pxa_device_desc pxa988_device_sdh2;
+extern struct pxa_device_desc pxa988_device_sdh3;
+extern struct pxa_device_desc pxa988_device_ssp0;
+extern struct pxa_device_desc pxa988_device_ssp1;
+extern struct pxa_device_desc pxa988_device_ssp2;
+extern struct pxa_device_desc pxa988_device_gssp;
+extern struct pxa_device_desc pxa988_device_asram;
+extern struct pxa_device_desc pxa988_device_isram;
+extern struct pxa_device_desc pxa988_device_fb;
+extern struct pxa_device_desc pxa988_device_fb_ovly;
+extern struct pxa_device_desc pxa988_device_fb_tv;
+extern struct pxa_device_desc pxa988_device_fb_tv_ovly;
+extern struct pxa_device_desc pxa988_device_camera;
+extern struct platform_device pxa988_device_rtc;
+extern struct pxa_device_desc pxa988_device_thermal;
+
+extern struct platform_device pxa9xx_device_acipc;
+extern struct platform_device pxa988_device_squ;
+extern struct platform_device pxa988_device_asoc_platform;
+
+extern void pxa988_clear_keypad_wakeup(void);
+extern void pxa988_clear_sdh_wakeup(void);
+
+extern struct platform_device pxa988_device_udc;
+extern struct platform_device pxa_device_coda7542;
+
+#define IOPWRDOM_VIRT_BASE	(APB_VIRT_BASE + 0x1e800)
+#define AIB_MMC1_IO_REG		0x1c
+#define MMC1_PAD_1V8		(0x1 << 2)
+#define MMC1_PAD_2V5		(0x2 << 2)
+#define MMC1_PAD_3V3		(0x0 << 2)
+#define MMC1_PAD_MASK		(0x3 << 2)
+#define PAD_POWERDOWNn		(1 << 0)
+static inline void pxa988_aib_mmc1_iodomain(int vol)
+{
+	u32 tmp;
+
+	writel(AKEY_ASFAR, APBC_PXA988_ASFAR);
+	writel(AKEY_ASSAR, APBC_PXA988_ASSAR);
+	tmp = readl(IOPWRDOM_VIRT_BASE + AIB_MMC1_IO_REG);
+
+	/* 0= power down, only set power down when vol = 0 */
+	tmp |= PAD_POWERDOWNn;
+
+	tmp &= ~MMC1_PAD_MASK;
+	if (vol >= 2800000)
+		tmp |= MMC1_PAD_3V3;
+	else if (vol >= 2300000)
+		tmp |= MMC1_PAD_2V5;
+	else if (vol >= 1200000)
+		tmp |= MMC1_PAD_1V8;
+	else if (vol == 0)
+		tmp &= ~PAD_POWERDOWNn;
+
+	writel(AKEY_ASFAR, APBC_PXA988_ASFAR);
+	writel(AKEY_ASSAR, APBC_PXA988_ASSAR);
+	writel(tmp, IOPWRDOM_VIRT_BASE + AIB_MMC1_IO_REG);
+}
+
+static inline int pxa988_add_uart(int id)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 0:
+		d = &pxa988_device_uart0;
+		break;
+	case 1:
+		d = &pxa988_device_uart1;
+		break;
+	case 2:
+		d = &pxa988_device_uart2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, NULL, 0);
+}
+
+static inline int pxa988_add_keypad(struct pxa27x_keypad_platform_data *data)
+{
+	data->clear_wakeup_event = pxa988_clear_keypad_wakeup;
+	return pxa_register_device(&pxa988_device_keypad, data, sizeof(*data));
+}
+
+static inline int pxa988_add_twsi(int id, struct i2c_pxa_platform_data *data,
+				  struct i2c_board_info *info, unsigned size)
+{
+	struct pxa_device_desc *d = NULL;
+	int ret;
+
+	switch (id) {
+	case 0:
+		d = &pxa988_device_twsi0;
+		break;
+	case 1:
+		d = &pxa988_device_twsi1;
+		break;
+	case 2:
+		d = &pxa988_device_twsi2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = i2c_register_board_info(id, info, size);
+	if (ret)
+		return ret;
+
+	return pxa_register_device(d, data, sizeof(*data));
+}
+
+static inline int pxa988_add_pwm(int id)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 1: d = &pxa988_device_pwm1; break;
+	case 2: d = &pxa988_device_pwm2; break;
+	case 3: d = &pxa988_device_pwm3; break;
+	case 4: d = &pxa988_device_pwm4; break;
+	default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, NULL, 0);
+}
+
+static inline int pxa988_add_sdh(int id, struct sdhci_pxa_platdata *data)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 1:
+		d = &pxa988_device_sdh1;
+		break;
+	case 2:
+		d = &pxa988_device_sdh2;
+		break;
+	case 3:
+		d = &pxa988_device_sdh3;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	data->clear_wakeup_event = pxa988_clear_sdh_wakeup;
+	return pxa_register_device(d, data, sizeof(*data));
+}
+
+static inline int pxa988_add_ssp(int id)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 0:
+		d = &pxa988_device_ssp0;
+		break;
+	case 1:
+		d = &pxa988_device_ssp1;
+		break;
+	case 2:
+		d = &pxa988_device_ssp2;
+		break;
+	case 4:
+		d = &pxa988_device_gssp;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, NULL, 0);
+}
+
+static inline int pxa988_add_spi(int id, struct pxa2xx_spi_master *pdata)
+{
+	struct platform_device *pd;
+
+	pd = platform_device_alloc("pxa2xx-spi", id);
+	if (pd == NULL) {
+		pr_err("pxa2xx-spi: failed to allocate device (id=%d)\n", id);
+		return -ENOMEM;
+	}
+
+	platform_device_add_data(pd, pdata, sizeof(*pdata));
+
+	return platform_device_add(pd);
+}
+
+static inline int pxa988_add_asram(struct sram_platdata *data)
+{
+	return pxa_register_device(&pxa988_device_asram, data, sizeof(*data));
+}
+
+static inline int pxa988_add_vsram(struct sram_platdata *data)
+{
+	return pxa_register_device(&pxa988_device_isram, data, sizeof(*data));
+}
+
+static inline int pxa988_add_fb(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&pxa988_device_fb, mi, sizeof(*mi));
+}
+
+static inline int pxa988_add_fb_ovly(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&pxa988_device_fb_ovly, mi, sizeof(*mi));
+}
+
+static inline int pxa988_add_fb_tv(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&pxa988_device_fb_tv, mi, sizeof(*mi));
+}
+
+static inline int pxa988_add_fb_tv_ovly(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&pxa988_device_fb_tv_ovly, mi, sizeof(*mi));
+}
+
+static inline int pxa988_add_thermal(void)
+{
+	return pxa_register_device(&pxa988_device_thermal, NULL, 0);
+}
+
+static inline int pxa988_add_cam(struct mmp_cam_pdata *cam)
+{
+	return pxa_register_device(&pxa988_device_camera, cam, sizeof(*cam));
+}
+
+#endif /* __ASM_CPU_PXA988_H */
diff --git a/arch/arm/mach-mmp/include/mach/pxa988_ddr.h b/arch/arm/mach-mmp/include/mach/pxa988_ddr.h
new file mode 100644
index 00000000..248d6302
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/pxa988_ddr.h
@@ -0,0 +1,51 @@
+/*
+ * PXA988 DDR Settings
+ *
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+ *
+ * (C) Copyright 2011 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#ifndef __PXA988_DDR_H__
+#define __PXA988_DDR_H__
+
+struct ddr_setting_entry {
+	unsigned int reg;
+	unsigned int val;
+};
+
+struct ddr_timing {
+	/* PXA988 MCK4 controller has 8 timing registers*/
+	struct ddr_setting_entry entry[8];
+};
+
+struct ddr_phy_ds {
+	/*
+	 * We have to set 3 phy registers for drive strength,
+	 * PHY_CTRL7, PHY_CTRL8, PHY_CTRL9.
+	 * If the value is always same for different frequencies,
+	 * we could remove this part in the future.
+	 */
+	struct ddr_setting_entry entry[3];
+};
+
+struct ddr_phy_misc {
+	/*
+	 * Some phy settings which are different for different
+	 * frequencies.
+	 */
+	struct ddr_setting_entry entry[1];
+};
+
+struct platform_ddr_setting {
+	unsigned int ddr_freq;
+	unsigned int cas_latency;
+	unsigned int table_idx;
+	struct ddr_timing timing;
+	struct ddr_phy_ds phy_ds;
+	struct ddr_phy_misc phy_misc;
+};
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/pxa988_lowpower.h b/arch/arm/mach-mmp/include/mach/pxa988_lowpower.h
new file mode 100644
index 00000000..5779925a
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/pxa988_lowpower.h
@@ -0,0 +1,158 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/pxa988_lowpower.h
+ *
+ * Author:	Raul Xiong <xjian@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+
+#ifndef __MMP_MACH_PXA988_LOWPOWER_H__
+#define __MMP_MACH_PXA988_LOWPOWER_H__
+
+#define LPM_NUM				16
+#define MAX_CPU_NUM			CONFIG_NR_CPUS
+#define OFFSET_SCU_SHUTDOWN		(MAX_CPU_NUM << 2)
+#define OFFSET_SPINLOCK			(OFFSET_SCU_SHUTDOWN + 4)
+#define OFFSET_BARRIER			(OFFSET_SPINLOCK + 4)
+
+#define	INVALID_LPM			(-1)
+#define	LPM_C1				0
+#define	LPM_C2				1
+#define	LPM_D1P				2
+#define	LPM_D1				3
+#define	LPM_D2				4
+#define	LPM_D2_UDR			5
+
+#define PMUA_CORE_IDLE			(1 << 0)
+#define PMUA_CORE_POWER_DOWN		(1 << 1)
+#define PMUA_CORE_L1_SRAM_POWER_DOWN	(1 << 2)
+#define PMUA_GIC_IRQ_GLOBAL_MASK	(1 << 3)
+#define PMUA_GIC_FIQ_GLOBAL_MASK	(1 << 4)
+
+#define PMUA_MP_IDLE			(1 << 0)
+#define PMUA_MP_POWER_DOWN		(1 << 1)
+#define PMUA_MP_L2_SRAM_POWER_DOWN	(1 << 2)
+#define PMUA_MP_SCU_SRAM_POWER_DOWN	(1 << 3)
+#define PMUA_MP_MASK_CLK_OFF		(1 << 11)
+#define PMUA_DIS_MP_SLP			(1 << 18)
+
+#define ICU_MASK_FIQ			(1 << 0)
+#define ICU_MASK_IRQ			(1 << 1)
+
+#define PMUM_AXISD		(1 << 31)
+#define PMUM_DSPSD		(1 << 30)
+#define PMUM_SLPEN		(1 << 29)
+#define PMUM_DTCMSD		(1 << 28)
+#define PMUM_DDRCORSD		(1 << 27)
+#define PMUM_APBSD		(1 << 26)
+#define PMUM_BBSD		(1 << 25)
+#define PMUM_INTCLR		(1 << 24)
+#define PMUM_SLPWP0		(1 << 23)
+#define PMUM_SLPWP1		(1 << 22)
+#define PMUM_SLPWP2		(1 << 21)
+#define PMUM_SLPWP3		(1 << 20)
+#define PMUM_VCTCXOSD		(1 << 19)
+#define PMUM_SLPWP4		(1 << 18)
+#define PMUM_SLPWP5		(1 << 17)
+#define PMUM_SLPWP6		(1 << 16)
+#define PMUM_SLPWP7		(1 << 15)
+#define PMUM_MSASLPEN		(1 << 14)
+#define PMUM_STBYEN		(1 << 13)
+
+#define PMUM_GSM_WAKEUPWMX	(1 << 29)
+#define PMUM_WCDMA_WAKEUPX	(1 << 28)
+#define PMUM_GSM_WAKEUPWM	(1 << 27)
+#define PMUM_WCDMA_WAKEUPWM	(1 << 26)
+#define PMUM_AP_ASYNC_INT	(1 << 25)
+#define PMUM_AP_FULL_IDLE	(1 << 24)
+#define PMUM_SQU_SDH1		(1 << 23)
+#define PMUM_SDH_23		(1 << 22)
+#define PMUM_KEYPRESS		(1 << 21)
+#define PMUM_TRACKBALL		(1 << 20)
+#define PMUM_NEWROTARY		(1 << 19)
+#define PMUM_WDT		(1 << 18)
+#define PMUM_RTC_ALARM		(1 << 17)
+#define PMUM_CP_TIMER_3		(1 << 16)
+#define PMUM_CP_TIMER_2		(1 << 15)
+#define PMUM_CP_TIMER_1		(1 << 14)
+#define PMUM_AP2_TIMER_3	(1 << 13)
+#define PMUM_AP2_TIMER_2	(1 << 12)
+#define PMUM_AP2_TIMER_1	(1 << 11)
+#define PMUM_AP1_TIMER_3	(1 << 10)
+#define PMUM_AP1_TIMER_2	(1 << 9)
+#define PMUM_AP1_TIMER_1	(1 << 8)
+#define PMUM_WAKEUP7		(1 << 7)
+#define PMUM_WAKEUP6		(1 << 6)
+#define PMUM_WAKEUP5		(1 << 5)
+#define PMUM_WAKEUP4		(1 << 4)
+#define PMUM_WAKEUP3		(1 << 3)
+#define PMUM_WAKEUP2		(1 << 2)
+#define PMUM_WAKEUP1		(1 << 1)
+#define PMUM_WAKEUP0		(1 << 0)
+
+#ifndef __ASSEMBLER__
+
+enum pxa988_lowpower_state {
+	POWER_MODE_ACTIVE = 0, /* not used for PXA988 */
+	POWER_MODE_CORE_INTIDLE, /* used for C1 */
+	POWER_MODE_CORE_EXTIDLE, /* not used for PXA988*/
+	POWER_MODE_CORE_POWERDOWN, /* used for C2 */
+	POWER_MODE_APPS_IDLE, /* used for D1P */
+	POWER_MODE_APPS_SLEEP, /* not used now */
+	POWER_MODE_SYS_SLEEP, /* used for non-udr chip sleep, D1 */
+	POWER_MODE_UDR_VCTCXO, /* used for udr with vctcxo, D2 */
+	POWER_MODE_UDR, /* used for udr D2, suspend */
+};
+
+enum pxa988_lowpower_mode {
+	/* POWER_MODE_CORE_INTIDLE */
+	PXA988_LPM_C1 = LPM_C1,
+	/* POWER_MODE_CORE_POWERDOWN with L1 shutdown, L2 retentive */
+	PXA988_LPM_C2 = LPM_C2,
+	/* POWER_MODE_APPS_IDLE with L2 retentive */
+	PXA988_LPM_D1P = LPM_D1P,
+	/* POWER_MODE_SYS_SLEEP with L2 retentive */
+	PXA988_LPM_D1 = LPM_D1,
+	/* POWER_MODE_UDR_VCTCXO with L2 retentive */
+	PXA988_LPM_D2 = LPM_D2,
+	/* POWER_MODE_UDR with L2 shutdown */
+	PXA988_LPM_D2_UDR = LPM_D2_UDR,
+	/* Maximum LPM index, must be the last one! */
+	PXA988_MAX_LPM_INDEX = 15,
+};
+
+struct pxa988_lowpower_data {
+	u32 power_state;	/* SoC specific LPM states */
+	/* Whether this LPM is valid according to the constraints */
+	u32 valid;
+};
+
+extern struct pxa988_lowpower_data pxa988_lpm_data[];
+extern void pxa988_hotplug_enter(u32 cpu, u32 power_mode);
+extern void pxa988_pm_suspend(u32 cpu, u32 power_mode);
+extern void pxa988_enter_c1(u32 cpu);
+extern int pxa988_enter_lowpower(u32 cpu, u32 power_mode);
+
+extern void pl310_suspend(void);
+
+extern void pmu_register_lock(void);
+extern void pmu_register_unlock(void);
+
+extern void pl310_disable(void);
+
+extern u32 sav_wucrs, sav_wucrm;
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+extern atomic_t disable_c2;
+#endif
+
+extern atomic_t freqchg_disable_c2;
+
+#endif
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/regs-apbc.h b/arch/arm/mach-mmp/include/mach/regs-apbc.h
index 8a37fb00..ed260e47 100644
--- a/arch/arm/mach-mmp/include/mach/regs-apbc.h
+++ b/arch/arm/mach-mmp/include/mach/regs-apbc.h
@@ -13,8 +13,9 @@
 
 #include <mach/addr-map.h>
 
-#define APBC_VIRT_BASE	(APB_VIRT_BASE + 0x015000)
-#define APBC_REG(x)	(APBC_VIRT_BASE + (x))
+/* add for AP controls GSSP device */
+#define CPBC_VIRT_BASE	(APB_VIRT_BASE + 0x03b000)
+#define CPBC_REG(x)	(CPBC_VIRT_BASE + (x))
 
 /*
  * APB clock register offsets for PXA168
@@ -69,6 +70,49 @@
 #define APBC_PXA910_SSP3	APBC_REG(0x04c)
 #define APBC_PXA910_ASFAR	APBC_REG(0x050)
 #define APBC_PXA910_ASSAR	APBC_REG(0x054)
+/* GBS: clock for GSSP */
+#define APBC_PXA910_GBS		CPBC_REG(0x00c)
+#define APBC_PXA910_GCER	CPBC_REG(0x034)
+
+/*
+ * APB Clock register offsets for PXA988
+ */
+#define APBC_PXA988_UART1	APBC_REG(0x000)
+#define APBC_PXA988_UART2	APBC_REG(0x004)
+#define APBC_PXA988_GPIO	APBC_REG(0x008)
+#define APBC_PXA988_PWM0	APBC_REG(0x00c)
+#define APBC_PXA988_PWM1	APBC_REG(0x010)
+#define APBC_PXA988_PWM2	APBC_REG(0x014)
+#define APBC_PXA988_PWM3	APBC_REG(0x018)
+#define APBC_PXA988_SSP0	APBC_REG(0x01c)
+#define APBC_PXA988_SSP1	APBC_REG(0x020)
+#define APBC_PXA988_IPC		APBC_REG(0x024)
+#define APBC_PXA988_RTC		APBC_REG(0x028)
+#define APBC_PXA988_TWSI0	APBC_REG(0x02c)
+#define APBC_PXA988_KPC		APBC_REG(0x030)
+#define APBC_PXA988_TIMERS	APBC_REG(0x034)
+#define APBC_PXA988_TBROT	APBC_REG(0x038)
+#define APBC_PXA988_AIB		APBC_REG(0x03c)
+#define APBC_PXA988_SW_JTAG	APBC_REG(0x040)
+#define APBC_PXA988_TIMERS1	APBC_REG(0x044)
+#define APBC_PXA988_ONEWIRE	APBC_REG(0x048)
+#define APBC_PXA988_SSP2	APBC_REG(0x04c)
+#define APBC_PXA988_ASFAR	APBC_REG(0x050)
+#define  AKEY_ASFAR		0xbaba
+#define APBC_PXA988_ASSAR	APBC_REG(0x054)
+#define  AKEY_ASSAR		0xeb10
+#define APBC_PXA988_DROTS	APBC_REG(0x058)
+#define APBC_PXA988_I2CIO	APBC_REG(0x05c)
+#define APBC_PXA988_TWSI1	APBC_REG(0x060)
+
+#define APBC_PXA988_UART0	APBCP_REG(0x01c)
+#define APBC_PXA988_PWRTWSI	APBCP_REG(0x028)
+#define APBC_PXA988_RIPC	APBCP_REG(0x038)
+/* GBS: clock for GSSP */
+#define	APBC_PXA988_GBS		CPBC_REG(0x00c)
+#define	APBC_PXA988_GCER	CPBC_REG(0x034)
+
+#define APBC_PXA1088_TIMERS2	APBC_REG(0x068)
 
 /*
  * APB Clock register offsets for MMP2
@@ -111,12 +155,25 @@
 #define APBC_MMP2_THSENS1	APBC_REG(0x090)	/* Thermal Sensor */
 #define APBC_MMP2_THSENS_INTSTS	APBC_REG(0x0a4)
 
+
+#define APBC_EDEN_IPC_CP	APBC_REG(0x0ac)
+
+
 /* Common APB clock register bit definitions */
 #define APBC_APBCLK	(1 << 0)  /* APB Bus Clock Enable */
 #define APBC_FNCLK	(1 << 1)  /* Functional Clock Enable */
 #define APBC_RST	(1 << 2)  /* Reset Generation */
+#define MAGIC_ASFAR	0xbaba
+#define MAGIC_ASSAR	0xeb10
 
 /* Functional Clock Selection Mask */
 #define APBC_FNCLKSEL(x)	(((x) & 0xf) << 4)
 
+#ifdef CONFIG_CPU_PXA1088
+/* Clock Control Register for Generic Counter */
+#define APBC_COUNTER_CLK_SEL	APBC_REG(0x64)
+#define FREQ_HW_CTRL		0x1
+#define FREQ_SW_SEL		0x2
+#endif
+
 #endif /* __ASM_MACH_REGS_APBC_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-apmu.h b/arch/arm/mach-mmp/include/mach/regs-apmu.h
index 8447ac63..b79c9f1c 100644
--- a/arch/arm/mach-mmp/include/mach/regs-apmu.h
+++ b/arch/arm/mach-mmp/include/mach/regs-apmu.h
@@ -17,9 +17,24 @@
 #define APMU_REG(x)	(APMU_VIRT_BASE + (x))
 
 /* Clock Reset Control */
+#define APMU_CC_SP	APMU_REG(0x000)
+#define APMU_CC_PJ	APMU_REG(0x004)
+#define APMU_CC2_PJ	APMU_REG(0x150)
+#define APMU_CC3_PJ	APMU_REG(0x188)
+#define APMU_DM_CC_SP	APMU_REG(0x008)
+#define APMU_DM_CC_PJ	APMU_REG(0x00c)
+#define APMU_DM2_CC_PJ	APMU_REG(0x158)
+#define APMU_SP_IDLE_CFG	APMU_REG(0x014)
+#define APMU_IDLE_CFG	APMU_REG(0x018)
+
+#define APMU_CCIC_GATE	APMU_REG(0x028)
+#define APMU_CCIC2_GATE APMU_REG(0x118)
+#define APMU_ISPDXO	APMU_REG(0x038)
+#define APMU_DSI	APMU_REG(0x044)
 #define APMU_IRE	APMU_REG(0x048)
 #define APMU_LCD	APMU_REG(0x04c)
-#define APMU_CCIC	APMU_REG(0x050)
+#define APMU_CCIC_RST	APMU_REG(0x050)
+#define APMU_CCIC2_RST	APMU_REG(0x0f4)
 #define APMU_SDH0	APMU_REG(0x054)
 #define APMU_SDH1	APMU_REG(0x058)
 #define APMU_USB	APMU_REG(0x05c)
@@ -27,15 +42,96 @@
 #define APMU_DMA	APMU_REG(0x064)
 #define APMU_GEU	APMU_REG(0x068)
 #define APMU_BUS	APMU_REG(0x06c)
+#define APMU_PWR_STBL_TIMER        APMU_REG(0x084)
+#define APMU_CORE_STATUS APMU_REG(0x090)
+#define APMU_GC		APMU_REG(0x0cc)
+#define APMU_GC_2D	APMU_REG(0x0f4)
+#define APMU_GC_PD	APMU_REG(0x0d0)
+
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)\
+	|| defined(CONFIG_CPU_EDEN)
 #define APMU_SDH2	APMU_REG(0x0e8)
 #define APMU_SDH3	APMU_REG(0x0ec)
-#define APMU_ETH	APMU_REG(0x0fc)
+#define APMU_SDH4	APMU_REG(0x15c)
+#elif defined(CONFIG_CPU_PXA910) || defined(CONFIG_CPU_PXA988)	\
+	|| defined(CONFIG_CPU_PXA1088)
+#define APMU_SDH2	APMU_REG(0x0e0)
+#endif
+
+/* pxa988 MCK4 AHB clock */
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define APMU_MCK4_CTL	APMU_REG(0x0e8)
+#endif
+
+#define APMU_CCIC_DBG	APMU_REG(0x088)
+#define APMU_CCIC2_DBG	APMU_REG(0x088)
+#define APMU_SRAM_PWR_DWN	APMU_REG(0x08c)
+#define APMU_VMETA	APMU_REG(0x0A4)
+#define APMU_SMC	APMU_REG(0x0d4)
+
+#define APMU_ISPPWR	APMU_REG(0x1FC)
+#define APMU_ISPCLK	APMU_REG(0x224)
+#define APMU_ISLD_CI_CTRL       APMU_REG(0x01E0)
+
+#define APMU_CP_CCR             APMU_REG(0x0000)
+#define APMU_CCR                APMU_REG(0x0004)
+#define APMU_CP_CCSR            APMU_REG(0x0008)
+#define APMU_CCSR               APMU_REG(0x000c)
+#define APMU_SQU_CLK_GATE_CTRL	APMU_REG(0x001c)
+#define APMU_LCD_CLK_RES_CTRL   APMU_REG(0x004c)
+#define APMU_IMR                APMU_REG(0x0098)
+#define APMU_IRWC				APMU_REG(0x009c)
+#define APMU_ISR                APMU_REG(0x00a0)
+#define APMU_MC_HW_SLP_TYPE     APMU_REG(0x00b0)
+#define APMU_PLL_SEL_STATUS     APMU_REG(0x00c4)
+#define APMU_SMC_CLK_RES_CTRL   APMU_REG(0x00d4)
+#define APMU_GC_CLK_RES_CTRL	APMU_REG(0x00cc)
+#define APMU_GC_CLK_RES_CTRL2	APMU_REG(0x027c)
+
+#define APMU_CC2R               APMU_REG(0x0100)
+#define APMU_CC2SR              APMU_REG(0x0104)
+#define APMU_TRACE              APMU_REG(0x0108)
+
+#define APMU_SLIM_CLK_RES_CTRL	APMU_REG(0x0104)
+#define APMU_FSIC3_CLK_RES_CTRL APMU_REG(0x0100)
+#define APMU_LCD2_CLK_RES_CTRL  APMU_REG(0x0110)
+
+/* VPU clk control regs of PXA988/Eden */
+#define APMU_VPU_CLK_RES_CTRL	APMU_REG(0x00a4)
+/* Eden */
+#define APMU_ISLD_VPU_CTRL		APMU_REG(0x01b0)
+#define APMU_ISLD_GC_CTRL		APMU_REG(0x01b4)
+
+/* CNM clock and power on/off register*/
+#define APMU_DX8_CLK_RES_CTRL   APMU_REG(0x00a4)
+#define APMU_PWR_CTRL_REG       APMU_REG(0x00d8)
+#define APMU_PWR_BLK_TMR_REG    APMU_REG(0x00dc)
+#define APMU_PWR_STATUS_REG     APMU_REG(0x00f0)
+
+#define APMU_ISLD_CI_PDWN_CTRL		APMU_REG(0x01e0)
+#define APMU_ISLD_DSPA_PDWN_CTRL	APMU_REG(0x01e4)
+#define APMU_ISLD_BCM_PDWN_CTRL		APMU_REG(0x01e8)
+#define APMU_ISLD_LCDMIPI_PDWN_CTRL	APMU_REG(0x01ec)
+#define APMU_ISLD_VMETA_PDWN_CTRL	APMU_REG(0x01f0)
+#define APMU_ISLD_GC2000_PDWN_CTRL	APMU_REG(0x01f4)
+#define APMU_ISLD_CPUMC_PDWN_CTRL	APMU_REG(0x01f8)
+
+#define APMU_ISLD_CMEM_CLKGATE_BYPASS	(1u << 5)
+#define APMU_ISLD_CMEM_DMMYCLK_EN	(1u << 4)
+
+#define APMU_MC_PAR_CTRL		APMU_REG(0x011c)
+
+/* Debug register */
+#define APMU_DEBUG		APMU_REG(0x0088)
+#define APMU_DEBUG2		APMU_REG(0x0190)
 
 #define APMU_FNCLK_EN	(1 << 4)
 #define APMU_AXICLK_EN	(1 << 3)
 #define APMU_FNRST_DIS	(1 << 1)
 #define APMU_AXIRST_DIS	(1 << 0)
 
+#define MASK_LCD_BLANK_CHECK	(1 << 27)
+
 /* Wake Clear Register */
 #define APMU_WAKE_CLR	APMU_REG(0x07c)
 
@@ -48,4 +144,121 @@
 #define APMU_PXA168_SD2_WAKE_CLR	(1 << 1)
 #define APMU_PXA168_SD1_WAKE_CLR	(1 << 0)
 
+#define APMU_PXA910_KP_WAKE_CLR		(1 << 3)
+#define APMU_PXA988_KP_WAKE_CLR		(1 << 3)
+#define APMU_PXA988_SD3_WAKE_CLR	(1 << 6)
+#define APMU_PXA988_SD2_WAKE_CLR	(1 << 1)
+#define APMU_PXA988_SD1_WAKE_CLR	(1 << 0)
+
+#define APMU_GC_156M		0x0
+#define APMU_GC_312M		0x40
+#define APMU_GC_PLL2		0x80
+#define APMU_GC_PLL2_DIV2	0xc0
+#define APMU_GC_624M		0xc0 /* added according to Aspen SW spec v2.8*/
+
+#define APMU_VMETA_CLK_RES_CTRL	APMU_VMETA
+/* VMeta Technology Power Mode */
+#define APMU_VMETA_CLK_DIV_MASK			(0xF << 16)
+#define APMU_VMETA_CLK_DIV_1			(0x1 << 16)
+#define APMU_VMETA_CLK_DIV_2                    (0x2 << 16)
+#define APMU_VMETA_CLK_DIV_4                    (0x4 << 16)
+#define APMU_VMETA_CLK_DIV_8                    (0x8 << 16)
+#define APMU_VMETA_CLK_DIV_SHIFT		16
+#define APMU_VMETA_CLK_PLL2			(0x1 << 6)
+#define APMU_VMETA_CLK_SEL_SHIFT		6
+/* VMeta Technology Power Up */
+#define APMU_VMETA_PWRUP_ON			(3 << 9)
+#define APMU_VMETA_PWRUP_SLOW_RAMP		(1 << 9)
+#define APMU_VMETA_PWRUP_MASK			(3 << 9)
+/* VMeta Technology Isolation Enable */
+#define APMU_VMETA_ISB				(1 << 8)
+/* VMeta Technology Clock Select */
+#define APMU_VMETA_CLK_SEL_MASK			(3 << 6)
+/* VMeta Technology Peripheral Clock Enable */
+#define APMU_VMETA_CLK_EN			(1 << 4)
+/* VMeta Technology AXI Clock Enable */
+#define APMU_VMETA_AXICLK_EN			(1 << 3)
+/* VMeta Technology Memory Redundancy Repair Start */
+#define APMU_VMETA_REDUN_START			(1 << 2)
+/* VMeta Technology Peripheral Reset 1 */
+#define APMU_VMETA_RST				(1 << 1)
+/* VMeta Technology AXI Reset */
+#define APMU_VMETA_AXI_RST			(1 << 0)
+#define APMU_VMETA_CLK_RES_CTRL_DFT		(APMU_VMETA_CLK_DIV_4)
+
+/* VMeta Technology Clock/Reset Control Register For MMP2 */
+/* [31:16]	Reserved */
+/* [15]		Bus Clock Source */
+#define APMU_MMP2_VMETA_ACLK_SRC		(1 << 15)
+/* [14:12]	Clock Select */
+#define APMU_MMP2_VMETA_ACLK_SEL_MASK	(7 << 12)
+#define APMU_MMP2_VMETA_ACLK_SEL_SHIFT	12
+/* [11]		Power Mode */
+#define APMU_MMP2_VMETA_PWR_CTRL		(1 << 11)
+/* [10]		Power Up */
+#define APMU_MMP2_VMETA_PWRUP			(1 << 10)
+/* [9]		Input Isolation Enable */
+#define APMU_MMP2_VMETA_INP_ISB			(1 << 9)
+/* [8]		Isolation Enable */
+#define APMU_MMP2_VMETA_ISB				(1 << 8)
+/* [7:5]	Clock Select */
+#define APMU_MMP2_VMETA_CLK_SEL_MASK	(7 << 5)
+#define APMU_MMP2_VMETA_CLK_SEL_SHIFT	5
+/* [4]		Peripheral Clock Enable */
+#define APMU_MMP2_VMETA_CLK_EN			(1 << 4)
+/* [3]		AXI Clock Enable */
+#define APMU_MMP2_VMETA_AXICLK_EN		(1 << 3)
+/* [2]		Reserved */
+/* [1]		Peripheral Reset 1 */
+#define APMU_MMP2_VMETA_RST1	(1 << 1)
+/* [0]		AXI Reset */
+#define APMU_MMP2_VMETA_AXI_RST	(1 << 0)
+
+/* USB HSIC/FSIC*/
+#define APMU_USBHSIC1   APMU_REG(0x0f8)
+#define APMU_USBHSIC2   APMU_REG(0x0fc)
+#define APMU_USBFSIC    APMU_REG(0x100)
+
+/* Audio Island */
+#define APMU_AUDIO_CLK_RES_CTRL		APMU_REG(0x010c)
+#define APMU_AUDIO_DSA			APMU_REG(0x0164)
+#define APMU_ISLD_DSPA_CTRL		APMU_REG(0x01e4)
+#define APMU_AUDIO_SRAM_PWR		APMU_REG(0x0240)
+
+#define APMU_PJ_C0_CC4			APMU_REG(0x0248)
+#define APMU_PJ_C1_CC4			APMU_REG(0x024C)
+#define APMU_PJ_C2_CC4			APMU_REG(0x0250)
+
+/* PXA988/1088 Common core idle configuration */
+#define PMU_CORE0_IDLE_CFG		APMU_REG(0x0124)
+#define PMU_CORE1_IDLE_CFG		APMU_REG(0x0128)
+#define APMU_COREn_WAKEUP_CTL(n)	(APMU_REG(0x012C) + 4 * (n & 0x3))
+#define APMU_WAKEUP_CORE(n)		(1 << (n & 0x3))
+
+/* PXA988/1088 Common MP idle configuration */
+#define PMU_MP_IDLE_CFG0		APMU_REG(0x0120)
+#define PMU_MP_IDLE_CFG1		APMU_REG(0x00e4)
+
+/* PXA1088 Unique MP idle configuration */
+#ifdef CONFIG_CPU_PXA1088
+#define PMU_CORE2_IDLE_CFG		APMU_REG(0x0160)
+#define PMU_CORE3_IDLE_CFG		APMU_REG(0x0164)
+#define PMU_MP_IDLE_CFG2		APMU_REG(0x0150)
+#define PMU_MP_IDLE_CFG3		APMU_REG(0x0154)
+#endif
+
+
+/* PXA988 AP Clock Control Register2 */
+#define PMU_CC2_AP			APMU_REG(0x0100)
+
+#define APMU_AUDIO_PWR_UP		(3 << 9)
+#define APMU_AUDIO_PWR_DOWN		(0 << 9)
+#define APMU_AUDIO_ISO_DIS		(1 << 8)
+#define APMU_AUDIO_CLK_SEL_PLL1_DIV_2	(0 << 6)
+#define APMU_AUDIO_CLK_SEL_PLL2_DIV_2	(1 << 6)
+#define APMU_AUDIO_CLK_SEL_PLL2_DIV_3	(2 << 6)
+#define APMU_AUDIO_CLK_SEL_PLL1_DIV_8	(3 << 6)
+#define APMU_AUDIO_CLK_ENA		(1 << 4)
+#define APMU_AUDIO_RST_DIS		(1 << 1)
+
 #endif /* __ASM_MACH_REGS_APMU_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-ciu.h b/arch/arm/mach-mmp/include/mach/regs-ciu.h
new file mode 100644
index 00000000..a864ef66
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-ciu.h
@@ -0,0 +1,95 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/regs-ciu.h
+ *
+ *  CPU Interface Unit Registers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_REGS_CIU_H
+#define __ASM_MACH_REGS_CIU_H
+
+#include <mach/addr-map.h>
+
+#define CIU_VIRT_BASE		(AXI_VIRT_BASE + 0x82c00)
+#define CIU_REG(x)		(CIU_VIRT_BASE + (x))
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+
+#define CIU_CHIP_ID			CIU_REG(0x0000)
+#define CIU_SEAGULL_CPU_CONF		CIU_REG(0x0004)
+#define CIU_SEAGULL_CPU_SRAM_SPD	CIU_REG(0x000c)
+#define CIU_SEAGULL_CPU_L2C_SRAM_SPD	CIU_REG(0x0014)
+#define CIU_SYS_BOOT_CNTRL		CIU_REG(0x0020)
+#define CIU_SW_BRANCH_ADDR		CIU_REG(0x0024)
+#define CIU_PERF_COUNT2			CIU_REG(0x003c)
+#define CIU_MC_CONF			CIU_REG(0x0040)
+#define CIU_CS_CONF			CIU_REG(0x004c)
+#define CIU_CS_DEBUG_CONF		CIU_REG(0x0050)
+#define CIU_MCB_CONFIG2_REG		CIU_REG(0x008c)
+#define CIU_DDR_PHY_TST_CONFIG_REG	CIU_REG(0x0090)
+#define CIU_DDR_PHY_TST_SEED_REG	CIU_REG(0x0094)
+#define CIU_DDR_PHY_TST_SIGNATURE_REG	CIU_REG(0x0098)
+#define CIU_DDR_PHY_TST_STATUS_REG	CIU_REG(0x009c)
+#define CIU_GPU_XTC_REG			CIU_REG(0x00a4)
+#define CIU_VPU_XTC_REG			CIU_REG(0x00a8)
+#define CIU_CPU_CONF_ADDR_FILTER	CIU_REG(0x00b0)
+#define CIU_CPU_CONF_L2C		CIU_REG(0x00b4)
+#define CIU_CPU_CONF_SCU		CIU_REG(0x00b8)
+#define CIU_CPU_CONF_MISC		CIU_REG(0x00bc)
+#define CIU_CPU_CONF_CORESIGHT_ROM_ADDR		CIU_REG(0x00c0)
+#define CIU_CPU_CONF_CORESIGHT_SELF_ADDR	CIU_REG(0x00c4)
+#define CIU_CPU_CONF_SRAM_0		CIU_REG(0x00c8)
+#define CIU_CPU_CONF_SRAM_1		CIU_REG(0x00cc)
+#define CIU_CPU_CORE0_CONF		CIU_REG(0x00d0)
+#define CIU_CPU_CORE0_STATUS		CIU_REG(0x00d4)
+#define CIU_WARM_RESET_VECTOR		CIU_REG(0x00d8)
+#define CIU_CPU_CORE1_CONF		CIU_REG(0x00e0)
+#define CIU_CPU_CORE1_STATUS		CIU_REG(0x00e4)
+#define CIU_SW_SCRATCH_REG		CIU_REG(0x00e8)
+
+#if defined(CONFIG_CPU_PXA988)
+
+#define CIU_MOHAWK_CPU_CONF		CIU_REG(0x0008)
+#define CIU_MOHAWK_CPU_SRAM_SPD		CIU_REG(0x0010)
+#define CIU_MOHAWK_CPU_L2C_SRAM_SPD	CIU_REG(0x0018)
+#define CIU_MCB_CONF0			CIU_REG(0x001c)
+#define CIU_PERF_COUNT0_CNTRL_A		CIU_REG(0x0028)
+#define CIU_PERF_COUNT1_CNTRL_A		CIU_REG(0x002c)
+#define CIU_PERF_COUNT2_CNTRL		CIU_REG(0x0030)
+#define CIU_PERF_COUNT0			CIU_REG(0x0034)
+#define CIU_PERF_COUNT1			CIU_REG(0x0038)
+#define CIU_AXI2MC_CTRL			CIU_REG(0x005c)
+#define CIU_MOHAWK_CPU_L1_SRAM_SPD	CIU_REG(0x0060)
+#define CIU_MOHAWK_SOC_ID_AP		CIU_REG(0x0064)
+#define CIU_MOHAWK_CPU_CFG_MISC		CIU_REG(0x0068)
+#define CIU_MOHAWK_CPU_CFG_VITAL	CIU_REG(0x006c)
+#define CIU_MCB_CONF1			CIU_REG(0x0070)
+#define CIU_PERF_COUNT3			CIU_REG(0x0074)
+#define CIU_PERF_COUNT3_CNTRL_A		CIU_REG(0x0078)
+#define CIU_PERF_COUNT0_CNTRL_B		CIU_REG(0x007c)
+#define CIU_PERF_COUNT1_CNTRL_B		CIU_REG(0x0080)
+#define CIU_PERF_COUNT2_CNTRL_B		CIU_REG(0x0084)
+#define CIU_PERF_COUNT3_CNTRL_B		CIU_REG(0x0088)
+
+#elif defined(CONFIG_CPU_PXA1088)
+
+#define CIU_MC_QOS_CTRL			CIU_REG(0x001c)
+#define CIU_SQU_SEC_RANGE_H		CIU_REG(0x0034)
+#define CIU_SQU_SEC_RANGE_L		CIU_REG(0x0038)
+#define CIU_TOP_MEM_RTC_WTC_SPD		CIU_REG(0x0044)
+#define CIU_HSI_MEM_RTC_WTC_SPD		CIU_REG(0x0048)
+#define CIU_SYSSEC_CTRL			CIU_REG(0x005c)
+#define CIU_DMA_SEC_CH_REG		CIU_REG(0x006c)
+#define CIU_CPU_CORE2_CONF		CIU_REG(0x00f0)
+#define CIU_CPU_CORE2_STATUS		CIU_REG(0x00f4)
+#define CIU_CPU_CORE3_CONF		CIU_REG(0x00f8)
+#define CIU_CPU_CORE3_STATUS		CIU_REG(0x00fc)
+
+#endif
+
+#endif /* CONFIG_CPU_PXA988 or CONFIG_CPU_PXA1088 */
+
+#endif /* __ASM_MACH_REGS_CIU_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-coresight.h b/arch/arm/mach-mmp/include/mach/regs-coresight.h
new file mode 100644
index 00000000..e9a02284
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-coresight.h
@@ -0,0 +1,100 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/regs-coresight.h
+ *
+ * Author:     Neil Zhang <zhangwm@marvell.com>
+ * Copyright:  (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __ASM_MACH_CORSIGHT_H
+#define __ASM_MACH_CORSIGHT_H
+
+#include <mach/addr-map.h>
+
+#define CORESIGHT_VIRT_BASE	(APB_VIRT_BASE + 0x100000)
+
+#define ETB_VIRT_BASE		(CORESIGHT_VIRT_BASE + 0x5000)
+#define CTI_SOC_VIRT_BASE	(CORESIGHT_VIRT_BASE + 0x6000)
+#define TPIU_VIRT_BASE		(CORESIGHT_VIRT_BASE + 0x8000)
+#define CSTF_VIRT_BASE		(CORESIGHT_VIRT_BASE + 0x9000)
+
+#define DBG_CORE0_VIRT_BASE	(CORESIGHT_VIRT_BASE + 0x10000)
+#define CTI_CORE0_VIRT_BASE	(CORESIGHT_VIRT_BASE + 0x18000)
+#define CTI_CORE1_VIRT_BASE	(CORESIGHT_VIRT_BASE + 0x19000)
+#if defined(CONFIG_CPU_PXA1088)
+#define CTI_CORE2_VIRT_BASE	(CORESIGHT_VIRT_BASE + 0x1A000)
+#define CTI_CORE3_VIRT_BASE	(CORESIGHT_VIRT_BASE + 0x1B000)
+#endif
+#define PTM_CORE0_VIRT_BASE	(CORESIGHT_VIRT_BASE + 0x1C000)
+#define PTM_CORE1_VIRT_BASE	(CORESIGHT_VIRT_BASE + 0x1D000)
+
+#define ETB_REG(x)		(ETB_VIRT_BASE + (x))
+#define CTI_SOC_REG(x)		(CTI_SOC_VIRT_BASE + (x))
+#define TPIU_REG(x)		(TPIU_VIRT_BASE + (x))
+#define CSTF_REG(x)		(CSTF_VIRT_BASE + (x))
+
+#define PTM_REG(x)		((PTM_CORE0_VIRT_BASE \
+				+ 0x1000 * raw_smp_processor_id()) \
+				+ (x))
+
+#define CTI_REG(x)		((CTI_CORE0_VIRT_BASE \
+				+ 0x1000 * raw_smp_processor_id()) \
+				+ (x))
+
+#define ETB_LOCK		ETB_REG(0xFB0)
+#define TPIU_LOCK		TPIU_REG(0xFB0)
+#define CSTF_LOCK		CSTF_REG(0xFB0)
+#define PTM_LOCK		PTM_REG(0xFB0)
+#define CTI_LOCK		CTI_REG(0xFB0)
+
+#define DBG_REG(cpu, addr)	(DBG_CORE0_VIRT_BASE + cpu * 0x2000 + addr)
+
+#define DBG_ID(cpu)		DBG_REG(cpu, 0x0)
+#define DBG_DTRRX(cpu)		DBG_REG(cpu, 0x80)
+#define DBG_ITR(cpu)		DBG_REG(cpu, 0x84)	/* Write only */
+#define DBG_PCSR(cpu)		DBG_REG(cpu, 0x84)	/* Read only */
+#define DBG_DSCR(cpu)		DBG_REG(cpu, 0x88)
+#define DBG_DTRTX(cpu)		DBG_REG(cpu, 0x8C)
+#define DBG_DRCR(cpu)		DBG_REG(cpu, 0x90)
+#define DBG_LAR(cpu)		DBG_REG(cpu, 0xFB0)
+
+#define CTI_EN_MASK		0x0F
+#define CTI_CTRL_OFFSET		0x0
+#define CTI_INTACK_OFFSET	0x10
+#define CTI_EN_IN0_OFFSET	0x20
+#define CTI_EN_IN1_OFFSET	0x24
+#define CTI_EN_IN2_OFFSET	0x28
+#define CTI_EN_IN3_OFFSET	0x2C
+#define CTI_EN_IN4_OFFSET	0x30
+#define CTI_EN_IN5_OFFSET	0x34
+#define CTI_EN_IN6_OFFSET	0x38
+#define CTI_EN_IN7_OFFSET	0x3C
+#define CTI_EN_OUT0_OFFSET	0xA0
+#define CTI_EN_OUT1_OFFSET	0xA4
+#define CTI_EN_OUT2_OFFSET	0xA8
+#define CTI_EN_OUT3_OFFSET	0xAC
+#define CTI_EN_OUT4_OFFSET	0xB0
+#define CTI_EN_OUT5_OFFSET	0xB4
+#define CTI_EN_OUT6_OFFSET	0xB8
+#define CTI_EN_OUT7_OFFSET	0xBC
+#define CTI_LOCK_OFFSET		0xFB0
+
+#ifdef CONFIG_CORESIGHT_SUPPORT
+void coresight_dump_pcsr(u32 cpu);
+void coresight_panic_locked_cpu(int cpu);
+#else
+#define coresight_dump_pcsr(u32 cpu)     do {} while (0)
+#define coresight_panic_locked_cpu(cpu)	do {} while (0)
+#endif
+
+#ifdef CONFIG_CORESIGHT_TRACE_SUPPORT
+void coresight_ptm_disable(u32 cpu);
+#else
+#define coresight_ptm_disable(cpu) do {} while (0)
+#endif
+
+#endif /* __ASM_MACH_CORSIGHT_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-icu.h b/arch/arm/mach-mmp/include/mach/regs-icu.h
index f882d918..1adc62d5 100644
--- a/arch/arm/mach-mmp/include/mach/regs-icu.h
+++ b/arch/arm/mach-mmp/include/mach/regs-icu.h
@@ -27,8 +27,14 @@
 #define ICU_AP_FIQ_SEL_INT_NUM	ICU_REG(0x108)	/* AP FIQ Selected Interrupt */
 #define ICU_AP_IRQ_SEL_INT_NUM	ICU_REG(0x10C)	/* AP IRQ Selected Interrupt */
 #define ICU_AP_GBL_IRQ_MSK	ICU_REG(0x114)	/* AP Global Interrupt Mask */
+#if defined(CONFIG_CPU_PXA1088)
+#define ICU_INT_STATUS_0	ICU_REG(0x200)
+#define ICU_INT_STATUS_1	ICU_REG(0x204)
+#elif defined(CONFIG_CPU_PXA988)
 #define ICU_INT_STATUS_0	ICU_REG(0x128)	/* Interrupt Stuats 0 */
 #define ICU_INT_STATUS_1	ICU_REG(0x12C)	/* Interrupt Status 1 */
+#endif
+#define ICU_INT_STATUS_2	ICU_REG(0x208)	/* Only for HELAN Use */
 
 /************************** MMP2 ***********************/
 
@@ -45,17 +51,25 @@
 #define MMP2_ICU_PJ4_FIQ_STATUS0	ICU_REG(0x140)
 #define MMP2_ICU_PJ4_FIQ_STATUS1	ICU_REG(0x144)
 
+#define ICU_DMAIRQ_MASK		ICU_REG(0x11c)
+#define ICU_DMAFIQ_MASK		ICU_REG(0x120)
+#define ICU_DMAIRQ_STATUS	ICU_REG(0x128)
+
 #define MMP2_ICU_INT4_STATUS		ICU_REG(0x150)
 #define MMP2_ICU_INT5_STATUS		ICU_REG(0x154)
 #define MMP2_ICU_INT17_STATUS		ICU_REG(0x158)
 #define MMP2_ICU_INT35_STATUS		ICU_REG(0x15c)
 #define MMP2_ICU_INT51_STATUS		ICU_REG(0x160)
+#define MMP2_ICU_INT9_STATUS		ICU_REG(0x180)
+#define MMP2_ICU_INT55_STATUS		ICU_REG(0x188)
 
 #define MMP2_ICU_INT4_MASK		ICU_REG(0x168)
 #define MMP2_ICU_INT5_MASK		ICU_REG(0x16C)
 #define MMP2_ICU_INT17_MASK		ICU_REG(0x170)
 #define MMP2_ICU_INT35_MASK		ICU_REG(0x174)
 #define MMP2_ICU_INT51_MASK		ICU_REG(0x178)
+#define MMP2_ICU_INT9_MASK		ICU_REG(0x17c)
+#define MMP2_ICU_INT55_MASK		ICU_REG(0x184)
 
 #define MMP2_ICU_SP_IRQ_SEL		ICU_REG(0x100)
 #define MMP2_ICU_PJ4_IRQ_SEL		ICU_REG(0x104)
@@ -68,4 +82,260 @@
 #define MMP2_ICU_INV_COMMTX		(1 << 2)
 #define MMP2_ICU_INV_COMMRX		(1 << 3)
 
+/************************** MMP3 ***********************/
+
+#if defined(CONFIG_CPU_MMP3)
+
+#define ICU1_VIRT_BASE	 (AXI_VIRT_BASE + 0x82000)
+#define ICU1_REG(x)	 (ICU1_VIRT_BASE + (x))
+#define ICU1_INT_CONF(n) ICU1_REG((n) << 2)
+
+#define ICU2_VIRT_BASE	 (AXI_VIRT_BASE + 0x84000)
+#define ICU2_REG(x)	 (ICU2_VIRT_BASE + (x))
+#define ICU2_INT_CONF(n) ICU2_REG((n) << 2)
+
+/*
++ * FIQ0 routes to SP FIQ
++ * IRQ0 routes to SP IRQ
++ * IRQ1 routes to PJ4-MP1 IRQ
++ * IRQ2 routes to PJ4-MP1 FIQ
++ * IRQ3 routes to PJ4-MP2 IRQ
++ * IRQ4 routes to PJ4-MP2 FIQ
++ * IRQ5 routes to PJ4-mm IRQ
++ * IRQ6 routes to PJ4-mm FIQ
++ */
+
+#define ICU1_INT_ROUTE_SP_IRQ_FIQ	(1 << 4)
+#define ICU1_INT_ROUTE_PJMP1_IRQ	(1 << 5)
+#define ICU1_INT_ROUTE_PJMP1_FIQ	(1 << 6)
+
+#define ICU2_INT_ROUTE_PJMP2_IRQ	(1 << 4)
+#define ICU2_INT_ROUTE_PJMP2_FIQ	(1 << 5)
+#define ICU2_INT_ROUTE_PJMM_IRQ		(1 << 6)
+#define ICU2_INT_ROUTE_PJMM_FIQ		(1 << 7)
+
+#define MMP3_ICU_IRQ_55_CONF		ICU1_REG(0x0DC)
+#define MMP3_ICU_IRQ0_SEL_INT_NUM	ICU1_REG(0x100)
+#define MMP3_ICU_IRQ1_SEL_INT_NUM	ICU1_REG(0x104)
+#define MMP3_ICU_IRQ2_SEL_INT_NUM	ICU1_REG(0x108)
+#define MMP3_ICU_GBL_IRQ0_MSK		ICU1_REG(0x10C)
+#define MMP3_ICU_GBL_IRQ1_MSK		ICU1_REG(0x110)
+#define MMP3_ICU_GBL_IRQ2_MSK		ICU1_REG(0x114)
+#define MMP3_ICU_DMA_IRQ0_MASK		ICU1_REG(0x118)
+#define MMP3_ICU_DMA_IRQ1_MASK		ICU1_REG(0x11C)
+#define MMP3_ICU_DMA_IRQ2_MASK		ICU1_REG(0x120)
+#define MMP3_ICU_DMA_IRQ0_STATUS	ICU1_REG(0x124)
+#define MMP3_ICU_DMA_IRQ1_STATUS	ICU1_REG(0x128)
+#define MMP3_ICU_DMA_IRQ2_STATUS	ICU1_REG(0x12C)
+#define MMP3_ICU_IRQ0_STATUS_0		ICU1_REG(0x130)
+#define MMP3_ICU_IRQ0_STATUS_1		ICU1_REG(0x134)
+#define MMP3_ICU_IRQ1_STATUS_0		ICU1_REG(0x138)
+#define MMP3_ICU_IRQ1_STATUS_1		ICU1_REG(0x13C)
+#define MMP3_ICU_IRQ2_STATUS_0		ICU1_REG(0x140)
+#define MMP3_ICU_IRQ2_STATUS_1		ICU1_REG(0x144)
+#define MMP3_ICU_INT_4_STATUS		ICU1_REG(0x150)
+#define MMP3_ICU_INT_5_STATUS		ICU1_REG(0x154)
+#define MMP3_ICU_INT_17_STATUS		ICU1_REG(0x158)
+#define MMP3_ICU_INT_35_STATUS		ICU1_REG(0x15C)
+#define MMP3_ICU_INT_51_STATUS		ICU1_REG(0x160)
+#define MMP3_ICU_INT_INVERT		ICU1_REG(0x164)
+#define MMP3_ICU_INT_4_MASK		ICU1_REG(0x168)
+#define MMP3_ICU_INT_5_MASK		ICU1_REG(0x16C)
+#define MMP3_ICU_INT_17_MASK		ICU1_REG(0x170)
+#define MMP3_ICU_INT_35_MASK		ICU1_REG(0x174)
+#define MMP3_ICU_INT_51_MASK		ICU1_REG(0x178)
+#define MMP3_ICU_INT_55_MASK		ICU1_REG(0x17C)
+#define MMP3_ICU_INT_57_MASK		ICU1_REG(0x180)
+#define MMP3_ICU_INT_55_STATUS		ICU1_REG(0x184)
+#define MMP3_ICU_INT_57_STATUS		ICU1_REG(0x188)
+#define MMP3_ICU_INT_6_MASK		ICU1_REG(0x1A4)
+#define MMP3_ICU_INT_8_MASK		ICU1_REG(0x1A8)
+#define MMP3_ICU_INT_18_MASK		ICU1_REG(0x1AC)
+#define MMP3_ICU_INT_30_MASK		ICU1_REG(0x1B0)
+#define MMP3_ICU_INT_42_MASK		ICU1_REG(0x1B4)
+#define MMP3_ICU_INT_58_MASK		ICU1_REG(0x1B8)
+#define MMP3_ICU_INT_6_STATUS		ICU1_REG(0x1BC)
+#define MMP3_ICU_INT_8_STATUS		ICU1_REG(0x1C0)
+#define MMP3_ICU_INT_18_STATUS		ICU1_REG(0x1C4)
+#define MMP3_ICU_INT_30_STATUS		ICU1_REG(0x1C8)
+#define MMP3_ICU_INT_42_STATUS		ICU1_REG(0x1CC)
+#define MMP3_ICU_INT_58_STATUS		ICU1_REG(0x1D0)
+
+
+#define MMP3_ICU_IRQ3_SEL_INT_NUM	ICU2_REG(0x100)
+#define MMP3_ICU_IRQ4_SEL_INT_NUM	ICU2_REG(0x104)
+#define MMP3_ICU_IRQ5_SEL_INT_NUM	ICU2_REG(0x108)
+#define MMP3_ICU_GBL_IRQ3_MSK		ICU2_REG(0x10C)
+#define MMP3_ICU_GBL_IRQ4_MSK		ICU2_REG(0x110)
+#define MMP3_ICU_GBL_IRQ5_MSK		ICU2_REG(0x114)
+#define MMP3_ICU_DMA_IRQ3_MASK		ICU2_REG(0x118)
+#define MMP3_ICU_DMA_IRQ4_MASK		ICU2_REG(0x11C)
+#define MMP3_ICU_DMA_IRQ5_MASK		ICU2_REG(0x120)
+#define MMP3_ICU_DMA_IRQ3_STATUS	ICU2_REG(0x124)
+#define MMP3_ICU_DMA_IRQ4_STATUS	ICU2_REG(0x128)
+#define MMP3_ICU_DMA_IRQ5_STATUS	ICU2_REG(0x12C)
+#define MMP3_ICU_IRQ3_STATUS_0		ICU2_REG(0x130)
+#define MMP3_ICU_IRQ3_STATUS_1		ICU2_REG(0x134)
+#define MMP3_ICU_IRQ4_STATUS_0		ICU2_REG(0x138)
+#define MMP3_ICU_IRQ4_STATUS_1		ICU2_REG(0x13C)
+#define MMP3_ICU_IRQ5_STATUS_0		ICU2_REG(0x140)
+#define MMP3_ICU_IRQ5_STATUS_1		ICU2_REG(0x144)
+#define MMP3_ICU_IRQ6_SEL_INT_NUM	ICU2_REG(0x18C)
+#define MMP3_ICU_GBL_IRQ6_MSK		ICU2_REG(0x190)
+#define MMP3_ICU_DMA_IRQ6_MSK		ICU2_REG(0x194)
+#define MMP3_ICU_DMA_IRQ6_STATUS	ICU2_REG(0x198)
+#define MMP3_ICU_IRQ6_STATUS_0		ICU2_REG(0x19C)
+#define MMP3_ICU_IRQ6_STATUS_1		ICU2_REG(0x1A0)
+
+#endif /* CONFIG_CPU_MMP3 */
+
+#if defined(CONFIG_CPU_PXA988)
+#define PXA988_ICU_CP_FIQ_NUM		ICU_REG(0x100)
+#define PXA988_ICU_CP_IRQ_NUM		ICU_REG(0x104)
+#define PXA988_ICU_A9C0_FIQ_NUM		ICU_REG(0x108)
+#define PXA988_ICU_A9C0_IRQ_NUM		ICU_REG(0x10C)
+#define PXA988_ICU_CP_GBL_INT_MSK	ICU_REG(0x110)
+#define PXA988_ICU_A9C0_GBL_INT_MSK	ICU_REG(0x114)
+#define PXA988_ICU_DMA_CP_INT_MSK	ICU_REG(0x118)
+#define PXA988_ICU_DMA_A9C0_INT_MSK	ICU_REG(0x11C)
+#define PXA988_ICU_DMA_CP_INT_STATUS	ICU_REG(0x120)
+#define PXA988_ICU_DMA_A9C0_INT_STATUS	ICU_REG(0x124)
+#define PXA988_ICU_INT_STATUS_0		ICU_REG(0x128)
+#define PXA988_ICU_INT_STATUS_1		ICU_REG(0x12C)
+#define PXA988_ICU_ARM_INT_MSK		ICU_REG(0x130)
+#define PXA988_ICU_ARM_INT_STATUS	ICU_REG(0x134)
+#define PXA988_ICU_PA_CLR		ICU_REG(0x138)
+#define PXA988_ICU_A9C1_FIQ_NUM		ICU_REG(0x13C)
+#define PXA988_ICU_A9C1_IRQ_NUM		ICU_REG(0x140)
+#define PXA988_ICU_A9C1_GBL_INT_MSK	ICU_REG(0x144)
+#define PXA988_ICU_DMA_A9C1_INT_MSK	ICU_REG(0x148)
+#define PXA988_ICU_DMA_A9C1_INT_STATUS	ICU_REG(0x14C)
+#endif /* CONFIG_CPU_PXA988 */
+
+#if defined(CONFIG_CPU_PXA1088)
+#define PXA1088_ICU_INT_STATUS_0	ICU_REG(0x200)
+#define PXA1088_ICU_INT_STATUS_1	ICU_REG(0x204)
+#define PXA1088_ICU_INT_STATUS_2	ICU_REG(0x208)
+#define PXA1088_ICU_CP_FIQ_NUM		ICU_REG(0x210)
+#define PXA1088_ICU_CP_IRQ_NUM		ICU_REG(0x214)
+#define PXA1088_ICU_CP_GBL_INT_MSK	ICU_REG(0x218)
+#define PXA1088_ICU_APC0_FIQ_NUM	ICU_REG(0x220)
+#define PXA1088_ICU_APC0_IRQ_NUM	ICU_REG(0x224)
+#define PXA1088_ICU_APC0_GBL_INT_MSK	ICU_REG(0x228)
+#define PXA1088_ICU_APC1_FIQ_NUM	ICU_REG(0x230)
+#define PXA1088_ICU_APC1_IRQ_NUM	ICU_REG(0x234)
+#define PXA1088_ICU_APC1_GBL_INT_MSK	ICU_REG(0x238)
+#define PXA1088_ICU_APC2_FIQ_NUM	ICU_REG(0x240)
+#define PXA1088_ICU_APC2_IRQ_NUM	ICU_REG(0x244)
+#define PXA1088_ICU_APC2_GBL_INT_MSK	ICU_REG(0x248)
+#define PXA1088_ICU_APC3_FIQ_NUM	ICU_REG(0x250)
+#define PXA1088_ICU_APC3_IRQ_NUM	ICU_REG(0x254)
+#define PXA1088_ICU_APC3_GBL_INT_MSK	ICU_REG(0x258)
+#define PXA1088_ICU_ARM_INT_STATUS	ICU_REG(0x300)
+#define PXA1088_ICU_ARM_INT_MSK		ICU_REG(0x304)
+#define PXA1088_ICU_DMA_CP_INT_ST	ICU_REG(0x310)
+#define PXA1088_ICU_DMA_CP_INT_MSK	ICU_REG(0x314)
+#define PXA1088_ICU_DMA_APC0_INT_ST		ICU_REG(0x320)
+#define PXA1088_ICU_DMA_APC0_INT_MSK		ICU_REG(0x324)
+#define PXA1088_ICU_SEC_DMA_APC0_INT_ST		ICU_REG(0x328)
+#define PXA1088_ICU_DMA_APC0_SEC_INT_MSK	ICU_REG(0x32c)
+#define PXA1088_ICU_DMA_APC1_INT_ST		ICU_REG(0x330)
+#define PXA1088_ICU_DMA_APC1_INT_MSK		ICU_REG(0x334)
+#define PXA1088_ICU_SEC_DMA_APC1_INT_ST		ICU_REG(0x338)
+#define PXA1088_ICU_DMA_APC1_SEC_INT_MSK	ICU_REG(0x33c)
+#define PXA1088_ICU_DMA_APC2_INT_ST		ICU_REG(0x340)
+#define PXA1088_ICU_DMA_APC2_INT_MSK		ICU_REG(0x344)
+#define PXA1088_ICU_SEC_DMA_APC2_INT_ST		ICU_REG(0x348)
+#define PXA1088_ICU_DMA_APC2_SEC_INT_MSK	ICU_REG(0x34c)
+#define PXA1088_ICU_DMA_APC3_INT_ST		ICU_REG(0x350)
+#define PXA1088_ICU_DMA_APC3_INT_MSK		ICU_REG(0x354)
+#define PXA1088_ICU_SEC_DMA_APC3_INT_ST		ICU_REG(0x358)
+#define PXA1088_ICU_DMA_APC3_SEC_INT_MSK	ICU_REG(0x35c)
+#endif /* CONFIG_CPU_PXA1088 */
+
+/************************** EDEN ***********************/
+
+#if defined(CONFIG_CPU_EDEN)
+
+/*
+ * ICU Configuration Register Bit Definitions:
+ * IRQ SP routes to SP IRQ
+ * FIRQ1 routes to CA7-1 FIQ
+ * IRQ1 routes to CA7-1 IRQ
+ * FIRQ2 routes to CA7-2 FIQ
+ * IRQ2 routes to CA7-2 IRQ
+*/
+
+#define ICU_INT_ROUTE_SP_IRQ		(1 << 4)
+#define ICU_INT_ROUTE_CA7_1_FIQ		(1 << 5)
+#define ICU_INT_ROUTE_CA7_1_IRQ		(1 << 6)
+#define ICU_INT_ROUTE_CA7_2_FIQ		(1 << 7)
+#define ICU_INT_ROUTE_CA7_2_IRQ		(1 << 8)
+
+#define EDEN_ICU_IRQ_SP_SEL_INT_NUM	ICU_REG(0x100)
+#define EDEN_ICU_FIQ1_SEL_INT_NUM	ICU_REG(0x104)
+#define EDEN_ICU_IRQ1_SEL_INT_NUM	ICU_REG(0x108)
+#define EDEN_ICU_FIQ2_SEL_INT_NUM	ICU_REG(0x18C)
+#define EDEN_ICU_IRQ2_SEL_INT_NUM	ICU_REG(0x1d4)
+
+#define EDEN_ICU_GBL_IRQ_SP_MSK		ICU_REG(0x10C)
+#define EDEN_ICU_GBL_FIQ1_MSK		ICU_REG(0x110)
+#define EDEN_ICU_GBL_IRQ1_MSK		ICU_REG(0x114)
+#define EDEN_ICU_GBL_FIQ2_MSK		ICU_REG(0x190)
+#define EDEN_ICU_GBL_IRQ2_MSK		ICU_REG(0x1d8)
+
+#define EDEN_ICU_DMA_IRQ_SP_MSK		ICU_REG(0x118)
+#define EDEN_ICU_DMA_FIQ1_MSK		ICU_REG(0x11C)
+#define EDEN_ICU_DMA_IRQ1_MSK		ICU_REG(0x120)
+#define EDEN_ICU_DMA_FIQ2_MSK		ICU_REG(0x194)
+#define EDEN_ICU_DMA_IRQ2_MSK		ICU_REG(0x1dc)
+
+#define EDEN_ICU_DMA_IRQ_SP_STATUS	ICU_REG(0x124)
+#define EDEN_ICU_DMA_FIQ1_STATUS	ICU_REG(0x128)
+#define EDEN_ICU_DMA_IRQ1_STATUS	ICU_REG(0x12C)
+#define EDEN_ICU_DMA_FIQ2_STATUS	ICU_REG(0x198)
+#define EDEN_ICU_DMA_IRQ2_STATUS	ICU_REG(0x1E0)
+
+#define EDEN_ICU_IRQ_SP_STATUS_0	ICU_REG(0x130)
+#define EDEN_ICU_IRQ_SP_STATUS_1	ICU_REG(0x134)
+#define EDEN_ICU_FIQ1_STATUS_0		ICU_REG(0x138)
+#define EDEN_ICU_FIQ1_STATUS_1		ICU_REG(0x13C)
+#define EDEN_ICU_IRQ1_STATUS_0		ICU_REG(0x140)
+#define EDEN_ICU_IRQ1_STATUS_1		ICU_REG(0x144)
+#define EDEN_ICU_FIQ2_STATUS_0		ICU_REG(0x19C)
+#define EDEN_ICU_FIQ2_STATUS_1		ICU_REG(0x1A0)
+#define EDEN_ICU_IRQ2_STATUS_0		ICU_REG(0x1E4)
+#define EDEN_ICU_IRQ2_STATUS_1		ICU_REG(0x1E8)
+
+#define EDEN_ICU_INT_4_STATUS		ICU_REG(0x150)
+#define EDEN_ICU_INT_5_STATUS		ICU_REG(0x154)
+#define EDEN_ICU_INT_6_STATUS		ICU_REG(0x1BC)
+#define EDEN_ICU_INT_8_STATUS		ICU_REG(0x1C0)
+#define EDEN_ICU_INT_17_STATUS		ICU_REG(0x158)
+#define EDEN_ICU_INT_18_STATUS		ICU_REG(0x1C4)
+#define EDEN_ICU_INT_30_STATUS		ICU_REG(0x1C8)
+#define EDEN_ICU_INT_35_STATUS		ICU_REG(0x15C)
+#define EDEN_ICU_INT_42_STATUS		ICU_REG(0x1CC)
+#define EDEN_ICU_INT_51_STATUS		ICU_REG(0x160)
+#define EDEN_ICU_INT_INVERT		ICU_REG(0x164)
+#define EDEN_ICU_INT_55_STATUS		ICU_REG(0x184)
+#define EDEN_ICU_INT_57_STATUS		ICU_REG(0x188)
+#define EDEN_ICU_INT_58_STATUS		ICU_REG(0x1D0)
+
+#define EDEN_ICU_INT_4_MASK		ICU_REG(0x168)
+#define EDEN_ICU_INT_5_MASK		ICU_REG(0x16C)
+#define EDEN_ICU_INT_6_MASK		ICU_REG(0x1A4)
+#define EDEN_ICU_INT_8_MASK		ICU_REG(0x1A8)
+#define EDEN_ICU_INT_17_MASK		ICU_REG(0x170)
+#define EDEN_ICU_INT_18_MASK		ICU_REG(0x1AC)
+#define EDEN_ICU_INT_30_MASK		ICU_REG(0x1B0)
+#define EDEN_ICU_INT_35_MASK		ICU_REG(0x174)
+#define EDEN_ICU_INT_42_MASK		ICU_REG(0x1B4)
+#define EDEN_ICU_INT_51_MASK		ICU_REG(0x178)
+#define EDEN_ICU_INT_55_MASK		ICU_REG(0x17C)
+#define EDEN_ICU_INT_57_MASK		ICU_REG(0x180)
+#define EDEN_ICU_INT_58_MASK		ICU_REG(0x1B8)
+
+#endif /* CONFIG_CPU_EDEN */
+
 #endif /* __ASM_MACH_ICU_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-map.h b/arch/arm/mach-mmp/include/mach/regs-map.h
new file mode 100644
index 00000000..a7feb47c
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-map.h
@@ -0,0 +1,249 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/regs-map.h
+ *
+ *   Common soc registers map
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_MACH_REGS_MAP_H
+#define __ASM_MACH_REGS_MAP_H
+#include <plat/dump_regs.h>
+
+struct reg_map pxa_reg_map[] = {
+#ifdef CONFIG_CPU_PXA988
+	{0xD4050000, 0xD405004C, 0, "Main_PMU1"},
+	{0xD4050100, 0xD4050100, 0, "Main_PMU2"},
+	{0xD4050200, 0xD4050200, 0, "Main_PMU3"},
+	{0xD4050400, 0xD4050410, 0, "Main_PMU4"},
+	{0xD4051000, 0xD4051004, 0, "Main_PMU5"},
+	{0xD4051020, 0xD4051028, 0, "Main_PMU6"},
+	{0xD4051048, 0xD405104C, 0, "Main_PMU7"},
+	{0xD4282800, 0xD4282804, 0, "Apps_PMU_1"},
+	{0xD4282808, 0xD428280C, 0, "Apps_PMU_2"},
+	{0xD4282810, 0xD4282820, 0, "Apps_PMU_3"},
+	{0xD4282828, 0xD42828F0, 0, "Apps_PMU_4"},
+	{0xD4282900, 0xD4282908, 0, "Apps_PMU_5"},
+	{0xD4282920, 0xD4282928, 0, "Apps_PMU_6"},
+	{0xF00E0000, 0xF00E0140, 0, "CCU"},
+	{0xD403B000, 0xD403B03C, 0, "APB_ctl"},
+	{0xD4015000, 0xD4015060, 0, "APB_clock"},
+	{0xD4080000, 0xD40800AC, 0, "PMU_Timer"},
+	{0xFFA60000, 0xFFA60018, 0, "Sleep_Timer"},
+	{0xD4014000, 0xD40140B0, 0, "Timer"},
+	{0xD401E000, 0xD401E32C, 0, "MFPR"},
+	{0xD4282000, 0xD428214C, 0, "ICU"},
+	{0xD4282C00, 0xD4282CE8, 0, "CIU"},
+	{0xF0205100, 0xF020510C, 0, "DSSP0"},
+	{0xF0206100, 0xF020610C, 0, "DSSP1"},
+	{0xF0207100, 0xF020710C, 0, "DSSP2"},
+	{0xF0208100, 0xF020810C, 0, "DSSP3"},
+	{0xD4032000, 0xD4032044, 0, "USIM1"},
+	{0xD4033000, 0xD4033044, 0, "USIM2"},
+	{0xD4019000, 0xD4019014, 0, "GPIO1"},
+	{0xD4019030, 0xD4019050, 0, "GPIO2"},
+	{0xD401909C, 0xD40190A4, 0, "GPIO3"},
+	{0xD4019800, 0xD401980C, 0, "GPIO_Edge"},
+	{0xD401D000, 0xD401D000, 0, "APIPC"},
+	{0xD4280000, 0xD42800FE, 0, "SD1"},
+	{0xD4280800, 0xD42808FE, 0, "SD2"},
+	{0xD4281000, 0xD42810FE, 0, "SD3"},
+	{0xD4036000, 0xD403602C, 0, "UART0"},
+	{0xD4017000, 0xD401702C, 0, "UART1"},
+	{0xD4018000, 0xD401802C, 0, "UART1"},
+	{0xD420A000, 0xD420A238, 0, "Camera"},
+	{0xD420B000, 0xD420B1FC, 0, "LCD"},
+	{0xD401B000, 0xD401B08C, 0, "SSP0"},
+	{0xD42A0C00, 0xD42A0C8C, 0, "SSP1"},
+	{0xD401C000, 0xD401C08C, 0, "SSP2"},
+	{0xD4011000, 0xD401108C, 0, "TWSI0"},
+	{0xD4010800, 0xD401088C, 0, "TWSI1"},
+	{0xD4010000, 0xD4010024, 0, "RTC"},
+	{0xD4012000, 0xD4012048, 0, "KPC"},
+	{0xD4013200, 0xD4013224, 0, "DRO"},
+	{0xD4000000, 0xD40003FC, 0, "DMAC"},
+	{0xD4011800, 0xD4011810, 0, "1Wire"},
+	{0xD4208000, 0xD42081FC, 0, "USB_OTG"},
+	{0xD4207000, 0xD420707C, 0, "USB_PHY"},
+	{0xC0100000, 0xC010045C, 0, "DDR_MC"},
+#endif /* CONFIG_CPU_PXA988 */
+
+#ifdef CONFIG_CPU_PXA1088
+/* register map of pxa1088 */
+
+/*
+ * important registers like CIU, Main_PMU, AP_PMU, MCK4, APB_clock, ICU are
+ * put ahead, they will be dumped as early as possible.
+ */
+	{0xD4282C00, 0xD4282CFC, 0, "CIU"},
+	{0xD4050000, 0xD405004C, 0, "Main_PMU_0"},
+	{0xD4050100, 0xD4050100, 0, "Main_PMU_1"},
+	{0xD4050200, 0xD4050200, 0, "Main_PMU_2"},
+	{0xD4050400, 0xD4050410, 0, "Main_PMU_3"},
+	{0xD4051000, 0xD4051004, 0, "Main_PMU_4"},
+	{0xD4051020, 0xD4051028, 0, "Main_PMU_5"},
+	{0xD4051048, 0xD405104C, 0, "Main_PMU_6"},
+	{0xD4052000, 0xD4052058, 0, "Main_PMU_DVC"},
+	{0xD4282800, 0xD4282970, 0, "AP_PMU"},
+	{0xC0100000, 0xC010003C, 0, "MCK4_00"},
+	{0xC0100050, 0xC0100078, 0, "MCK4_01"},
+	{0xC0100080, 0xC010009C, 0, "MCK4_02"},
+	{0xC0100100, 0xC0100100, 0, "MCK4_03"},
+	{0xC0100110, 0xC0100110, 0, "MCK4_04"},
+	{0xC0100120, 0xC010012C, 0, "MCK4_05"},
+	{0xC010013C, 0xC0100158, 0, "MCK4_06"},
+	{0xC0100160, 0xC0100164, 0, "MCK4_07"},
+	{0xC0100170, 0xC0100170, 0, "MCK4_08"},
+	{0xC0100180, 0xC0100184, 0, "MCK4_09"},
+	{0xC01001C0, 0xC01001C0, 0, "MCK4_10"},
+	{0xC01001C8, 0xC01001CC, 0, "MCK4_11"},
+	{0xC0100220, 0xC0100220, 0, "MCK4_12"},
+	{0xC0100230, 0xC0100258, 0, "MCK4_13"},
+	{0xC0100280, 0xC0100288, 0, "MCK4_14"},
+	{0xC0100300, 0xC0100308, 0, "MCK4_15"},
+	{0xC0100380, 0xC0100390, 0, "MCK4_16"},
+	{0xC0100400, 0xC0100400, 0, "MCK4_17"},
+	{0xC0100410, 0xC0100414, 0, "MCK4_18"},
+	{0xC0100440, 0xC0100448, 0, "MCK4_19"},
+	{0xC0100450, 0xC010045c, 0, "MCK4_20"},
+	{0xD4015000, 0xD4015068, 0, "APB_clock"},
+	{0xD4282000, 0xD428217C, 0, "ICU_0"},
+	{0xD4282200, 0xD4282258, 0, "ICU_1"},
+	{0xD4282300, 0xD428235C, 0, "ICU_2"},
+
+/*
+ * below registers are arranged according their physical address.
+ * please -don't- delete the commented lines, they are kept as index
+ * some regs are already dumped above;
+ * some regs do not exist in spec;
+ * some modules are not enabled, if read the regs, system will hang;
+ * some regs are not necessary to dump at present, but may need in furture.
+ */
+
+/*	{0xC0000000, 0xC000FFFC, 0, "SPH USB PHY"}, not necessary */
+/*	{0xC0010000, 0xC001FFFC, 0, "SPH USB CTL"}, not necessary */
+/*	{0xC0100000, 0xC010045C, 0, "MCK4"}, already dumped above */
+/*	{0xC0400000, 0xC04FFFFC, 0, "GC 1000T"}, not necessary */
+
+/* 0xD1DF9000 ~ 0xD1DFDFFF are GIC registers */
+	{0xD1DF9000, 0xD1DF9008, 0, "GIC_Distributor_00"},
+	{0xD1DF9080, 0xD1DF90BC, 0, "GIC_Distributor_01"},
+	{0xD1DF9100, 0xD1DF913C, 0, "GIC_Distributor_02"},
+	{0xD1DF9180, 0xD1DF91BC, 0, "GIC_Distributor_03"},
+	{0xD1DF9200, 0xD1DF923C, 0, "GIC_Distributor_04"},
+	{0xD1DF9280, 0xD1DF92BC, 0, "GIC_Distributor_05"},
+	{0xD1DF9300, 0xD1DF933C, 0, "GIC_Distributor_06"},
+	{0xD1DF9380, 0xD1DF93BC, 0, "GIC_Distributor_07"},
+	{0xD1DF9400, 0xD1DF95FC, 0, "GIC_Distributor_08"},
+	{0xD1DF9800, 0xD1DF99FC, 0, "GIC_Distributor_09"},
+	{0xD1DF9C00, 0xD1DF9C7C, 0, "GIC_Distributor_10"},
+	{0xD1DF9D00, 0xD1DF9D3C, 0, "GIC_Distributor_11"},
+	{0xD1DF9F00, 0xD1DF9F2C, 0, "GIC_Distributor_12"},
+	{0xD1DF9FD0, 0xD1DF9FFC, 0, "GIC_Distributor_13"},
+	{0xD1DFA000, 0xD1DFA028, 0, "GIC_CPU_interface_0"},
+	{0xD1DFA0D0, 0xD1DFA0FC, 0, "GIC_CPU_interface_1"},
+	{0xD1DFB000, 0xD1DFB030, 0, "GIC_common_base_add_0"},
+	{0xD1DFB0F0, 0xD1DFB10C, 0, "GIC_common_base_add_1"},
+	{0xD1DFC000, 0xD1DFC030, 0, "GIC_processor_spc_add_0"},
+	{0xD1DFC0F0, 0xD1DFC10C, 0, "GIC_processor_spc_add_1"},
+	{0xD1DFD000, 0xD1DFD028, 0, "GIC_Vir_CPU_interface_0"},
+	{0xD1DFD0D0, 0xD1DFD0FC, 0, "GIC_Vir_CPU_interface_1"},
+
+/* 0xD4000000 ~ 0xD41FFFFF are APB Peripheral registers */
+	{0xD4000000, 0xD40003FC, 0, "DMA"},
+	{0xD4010000, 0xD4010024, 0, "RTC"},
+	{0xD4010800, 0xD4010858, 0, "IIC1"},
+	{0xD4011000, 0xD4011058, 0, "IIC0"},
+	{0xD4011800, 0xD4011810, 0, "OneWire"},
+	{0xD4012000, 0xD4012048, 0, "Keypad"},
+/*	{0xD4013000, 0xD40130FC, 0, "Trackball"}, not exist in spec */
+	{0xD4013100, 0xD4013108, 0, "JTAG"},
+	{0xD4013200, 0xD4013230, 0, "DRO"},
+	{0xD4014000, 0xD40140AC, 0, "Timer0"},
+/*	{0xD4015000, 0xD4015068, 0, "APB_clock"}, already dumped above */
+	{0xD4016000, 0xD40160AC, 0, "Timer1"},
+	{0xD4017000, 0xD401702C, 0, "UART1"},
+	{0xD4018000, 0xD401802C, 0, "UART2"},
+	{0xD4019000, 0xD40191A8, 0, "GPIO"},
+	{0xD4019800, 0xD401980C, 0, "GPIO_Edge"},
+	{0xD401A000, 0xD401A008, 0, "PWM0"},
+	{0xD401A400, 0xD401A408, 0, "PWM1"},
+	{0xD401A800, 0xD401A808, 0, "PWM2"},
+	{0xD401AC00, 0xD401AC08, 0, "PWM3"},
+	{0xD401B000, 0xD401B08C, 0, "SSP1"},
+	{0xD401C000, 0xD401C08C, 0, "SSP3"},
+	{0xD401D000, 0xD401D014, 0, "AP_IPC"},
+	{0xD401D800, 0xD401D814, 0, "CP_IPC"},
+	{0xD401E000, 0xD401E32C, 0, "MFPR"},
+	{0xD401E800, 0xD401E830, 0, "IO_Power_0"},
+/*	{0xD401EC00, 0xD401EC14, 0, "IO_Power_1"}, overlap with SFO */
+	{0xD401EC00, 0xD401EC14, 0, "SFO"},
+	{0xD401F000, 0xD401F0B0, 0, "Timer2"},
+/*	{0xD4030000, 0xD403004C, 0, "TCU_0"}, not necessary */
+/*	{0xD4030400, 0xD40307FC, 0, "TCU_1"}, not necessary */
+/*	{0xD4031000, 0xD40318F4, 0, "XIRQ"}, not necessary */
+/*	{0xD4032000, 0xD4032044, 0, "USIM1"}, not necessary */
+/*	{0xD4033000, 0xD4033044, 0, "USIM2"}, not necessary */
+/*	{0xD4034000, 0xD4034050, 0, "E_cip_core"}, not necessary */
+/*	{0xD4034100, 0xD4034100, 0, "E_cip_data"}, not necessary */
+/*	{0xD4035000, 0xD4035FFC, 0, "E_cip_ctrl"}, not necessary */
+/*	{0xD4036000, 0xD403602C, 0, "GB_UART0"}, not necessary */
+/*	{0xD4037000, 0xD4037058, 0, "GB_IIC"}, not necessary */
+/*	{0xD4038000, 0xD403802C, 0, "GB_SCLK"}, not necessary */
+/*	{0xD403B00C, 0xD403B00C, 0, "GSSP"}, inside GB Mreg */
+/*	{0xD403A000, 0xD403A0AC, 0, "TimerCP"}, not necessary */
+/*	{0xD403B000, 0xD403B03C, 0, "APB_CP_clock_ctrl"}, not necessary */
+/*	{0xD403C000, 0xD403C014, 0, "GB_IPC"}, not necessary */
+/*	{0xD403D000, 0xD403D01C, 0, "GB_R_IPC_0"}, not necessary */
+/*	{0xD403D100, 0xD403D11C, 0, "GB_R_IPC_1"}, not necessary */
+/*	{0xD403D200, 0xD403D21C, 0, "GB_R_IPC_2"}, not necessary */
+/*	{0xD403D300, 0xD403D31C, 0, "GB_R_IPC_3"}, not necessary */
+/*	{0xD4050000, 0xD405104C, 0, "Main PMU"}, already dumped above */
+/*	{0xD4052000, 0xD4052058, 0, "Main_PMU_DVC"}, already dumped above */
+/*	{0xD4060000, 0xD406FFFC, 0, "PMU_SCK"}, not exist in spec */
+	{0xD4070000, 0xD4070020, 0, "APB_Aux"},
+	{0xD4080000, 0xD40800AC, 0, "PMU_Timer"},
+	{0xD4090000, 0xD409000C, 0, "APB_spare_0"},
+	{0xD4090100, 0xD409010C, 0, "APB_spare_1"},
+/*	{0xD4100000, 0xD41FFFFC, 0, "CoreSight"}, not necessary */
+	{0xD4101000, 0xD4101020, 0, "GenericCounter"},
+
+/* 0xD4200000 ~ 0xD4284FFF are AXI Peripheral registers */
+	{0xD4200200, 0xD4200260, 0, "AXI_Fab_0"},
+	{0xD4200408, 0xD42004CC, 0, "AXI_Fab_1"},
+/*	{0xD4201000, 0xD42014C8, 0, "GEU"}, not necessary */
+	{0xD4207000, 0xD4207064, 0, "USB_utmi_phy"},
+	{0xD4207100, 0xD4207134, 0, "USB_utmi_old"},
+	{0xD4208000, 0xD42081FC, 0, "USB_device"},
+	{0xD420A000, 0xD420A23C, 0, "CCIC"},
+	{0xD420B000, 0xD420B1F4, 0, "LCD"},
+	{0xD420B800, 0xD420B9EC, 0, "DSI"},
+/*	{0xD420D000, 0xD420DFFC, 0, "7542_Video_Decoder"}, not necessary */
+/*	{0xD420E000, 0xD420EFFC, 0, "DTE(DDR Test)"}, not exist in spec */
+/*	{0xD420F000, 0xD420FE38, 0, "ISPDMA"}, not necessary */
+/*	{0xD4240000, 0xD427FFFC, 0, "DXO DMA config"}, not exist in spec */
+	{0xD4280000, 0xD428006C, 0, "SDH1_0"},
+	{0xD42800E0, 0xD42800E0, 0, "SDH1_1"},
+	{0xD42800FC, 0xD428011C, 0, "SDH1_2"},
+	{0xD4280800, 0xD428086C, 0, "SDH2_0"},
+	{0xD42808E0, 0xD42808E0, 0, "SDH2_1"},
+	{0xD42808FC, 0xD428091C, 0, "SDH2_2"},
+	{0xD4281000, 0xD428106C, 0, "SDH3_0"},
+	{0xD42810E0, 0xD42810E0, 0, "SDH3_1"},
+	{0xD42810FC, 0xD428111C, 0, "SDH3_2"},
+/*	{0xD4282000, 0xD42823FC, 0, "ICU"}, already dumped above */
+/*	{0xD4282800, 0xD4282970, 0, "AP PMU"}, already dumped above */
+/*	{0xD4282C00, 0xD42820FC, 0, "CIU"},  already dumped above */
+/*	{0xD4283000, 0xD428307C, 0, "NAND"}, if read, will hang */
+	{0xD4283800, 0xD4283840, 0, "SMC"},
+/*	{0xD4284000, 0xD42840C0, 0, "DTC"}, if read, will hang */
+/*	{0xD4290000, 0xD4290B78, 0, "HSI"}, if read, will hang */
+	{0xD42A0C00, 0xD42A0C8C, 0, "SSP3"},
+#endif /* CONFIG_CPU_PXA1088 */
+
+	{0         , 0         , 0, NULL   }
+};
+
+#endif /* __ASM_MACH_REG_MAP_H
+# */
diff --git a/arch/arm/mach-mmp/include/mach/regs-mcu.h b/arch/arm/mach-mmp/include/mach/regs-mcu.h
new file mode 100644
index 00000000..909155f6
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-mcu.h
@@ -0,0 +1,159 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/regs-mcu.h
+ *
+ *   Memory Control Unit
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_MCU_H
+#define __ASM_MACH_MCU_H
+
+#include <mach/addr-map.h>
+
+#ifdef CONFIG_CPU_MMP3
+#define FIXADDR(base, offset)		((u32 *)(((u32)base)+offset))
+#define DMCU_HWTCTRL(base)		FIXADDR(base, 0x1c0)
+#define DMCU_HWTDAT0(base)		FIXADDR(base, 0x1c8)
+#define DMCU_HWTDAT1(base)		FIXADDR(base, 0x1cc)
+#else
+#define DMCU_VIRT_REG(x)		(DMCU_VIRT_BASE + (x))
+#define DMCU_PHYS_REG(x)		(DMCU_PHYS_BASE + (x))
+#define DMCU_HWTCTRL			(0x1c0)
+#define DMCU_HWTDAT0			(0x1c8)
+#define DMCU_HWTDAT1			(0x1cc)
+#endif
+#define DMCU_HWTPAUSE			(0x00010000)
+#define DMCU_HWTEND			(0x00020000)
+#define DMCU_HWTWRITE			(0x80000000)
+
+#define DMCU_CPU_ID_REV			(0x00)
+#define DMCU_STATUS			(0x04)
+#define DMCU_DRAM_STATUS		(0x08)
+
+#define DMCU_DRAM_STATUS_PD		(4)
+#define DMCU_DRAM_STATUS_DPD		(2)
+#define DMCU_DRAM_STATUS_SR		(1)
+
+#define DMCU_MAP_CS0			(0x10)
+#define DMCU_MAP_CS1			(0x14)
+#define DMCU_MAP_CSx(cs)		(DMCU_MAP_CS0 + cs * 4)
+#define DMCU_MAP_VALID			(1u << 0)
+#define DMCU_CMD_CSSEL_CS0		(1u << 24)
+#define DMCU_CMD_CSSEL_CS1		(1u << 25)
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define DMCU_MAP_CS2			(0x18)
+#define DMCU_MAP_CS3			(0x1c)
+#endif
+
+#define DMCU_SDRAM_CFG0_TYPE1		(0x20)
+#define DMCU_SDRAM_CFG1_TYPE1		(0x24)
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define DMCU_SDRAM_CFG2_TYPE1		(0x28)
+#define DMCU_SDRAM_CFG3_TYPE1		(0x2c)
+#endif
+
+#define DMCU_SDRAM_CFG0_TYPE2		(0x30)
+#define DMCU_SDRAM_CFG1_TYPE2		(0x34)
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define DMCU_SDRAM_CFG2_TYPE2		(0x38)
+#define DMCU_SDRAM_CFG3_TYPE2		(0x3c)
+#endif
+
+#define DMCU_SDRAM_CTRL1		(0x50)
+#define DMCU_SDRAM_CTRL2		(0x54)
+#define DMCU_SDRAM_CTRL4		(0x58)
+#define DMCU_SDRAM_TYPE_MASK		(7u << 2)
+#define DMCU_SDRAM_TYPE_DDR3		(2u << 2)
+#define DMCU_SDRAM_TYPE_LPDDR2		(5u << 2)
+#define DMCU_SDRAM_CTRL4_CL_SHIFT	(13)
+#define DMCU_SDRAM_CTRL4_CL_MASK	(0xf << DMCU_SDRAM_CTRL4_CL_SHIFT)
+#define DMCU_SDRAM_CTRL6		(0x5c)
+#define DMCU_SDRAM_CTRL7		(0x60)
+#define DMCU_SDRAM_CTRL13		(0x64)
+#define DMCU_SDRAM_CTRL14		(0x68)
+#define DMCU_SDRAM_TIMING1		(0x80)
+#define DMCU_SDRAM_TIMING2		(0x84)
+#define DMCU_SDRAM_TIMING3		(0x88)
+#define DMCU_SDRAM_TIMING4		(0x8c)
+#define DMCU_SDRAM_TIMING5		(0x90)
+#define DMCU_SDRAM_TIMING6		(0x94)
+#define DMCU_SDRAM_TIMING7		(0x98)
+#define DMCU_SDRAM_TIMING8		(0x9c)
+#define DMCU_EXCLUSIVE_MONITOR_CTRL	(0x100)
+#define DMCU_DATA_COH_CTRL		(0x110)
+#define DMCU_TRUSTZONE_SEL		(0x120)
+#define DMCU_TRUSTZONE_RANGE0		(0x124)
+#define DMCU_TRUSTZONE_RANGE1		(0x128)
+#define DMCU_TRUSTZONE_PERMISSION	(0x12C)
+#define DMCU_PORT_PRIORITY		(0x140)
+#define DMCU_BQ_STARV_PREVENTION	(0x144)
+#define DMCU_RRB_STARV_PREVENTION0	(0x148)
+#define DMCU_RRB_STARV_PREVENTION1	(0x14C)
+#define DMCU_SRAM_CTRL1			(0x150)
+#define DMCU_SRAM_CTRL2			(0x154)
+#define DMCU_SRAM_CTRL3			(0x158)
+#define DMCU_USER_COMMAND0		(0x160)
+#define DMCU_USER_COMMAND1		(0x164)
+#define DMCU_MODE_RD_DATA		(0x170)
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define DMCU_SMR1			(0x180)
+#define DMCU_SMR2			(0x184)
+#endif
+
+#define DMCU_PHY_CTRL3			(0x220)
+#define DMCU_PHY_CTRL7			(0x230)
+#define DMCU_PHY_CTRL8			(0x234)
+#define DMCU_PHY_CTRL9			(0x238)
+#define DMCU_PHY_CTRL10			(0x23c)
+#define DMCU_PHY_CTRL11			(0x240)
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define DMCU_PHY_CTRL12			(0x244)
+#endif
+
+#define DMCU_PHY_CTRL13			(0x248)
+#define DMCU_PHY_CTRL14			(0x24c)
+#define DMCU_PHY_CTRL15			(0x250)
+#define DMCU_PHY_CTRL16			(0x254)
+#define DMCU_PHY_CTRL21			(0x258)
+#define DMCU_PHY_CTRL19			(0x280)
+#define DMCU_PHY_CTRL20			(0x284)
+#define DMCU_PHY_CTRL22			(0x288)
+#define DMCU_PHY_DQ_BYTE_SEL		(0x300)
+#define DMCU_PHY_DLL_CTRL_BYTE1		(0x304)
+#define DMCU_PHY_DLL_WL_SEL		(0x380)
+#define DMCU_PHY_DLL_WL_CTRL0		(0x384)
+#define DMCU_PHY_DLL_WL_CTRL1		(0x388)
+#define DMCU_PHY_DLL_WL_CTRL2		(0x38C)
+#define DMCU_PHY_DLL_RL_CTRL		(0x390)
+
+#define PHY_CTRL14_DLL_RESET		(1u << 29)
+#define PHY_CTRL14_DLL_UPDATE		(1u << 30)
+#define PHY_CTRL14_PHY_SYNC		(1u << 31)
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define DMCU_PHY_CTRL_TESTMODE		(0x400)
+#endif
+
+#define DMCU_TEST_MODE0			(0x410)
+#define DMCU_TEST_MODE1			(0x414)
+#define DMCU_PERF_CNT_CTRL0		(0x440)
+#define DMCU_PERF_CNT_STATUS		(0x444)
+#define DMCU_PERF_CNT_SEL		(0x448)
+#define DMCU_PERF_CNT0			(0x450)
+#define DMCU_PERF_CNT1			(0x454)
+#define DMCU_PERF_CNT2			(0x458)
+#define DMCU_PERF_CNT3			(0x45c)
+
+#define INSERT_ENTRY(value, regid, index)			\
+	do {							\
+		__raw_writel(value, DMCU_VIRT_REG(DMCU_HWTDAT0));\
+		__raw_writel(regid, DMCU_VIRT_REG(DMCU_HWTDAT1));\
+		__raw_writel(index, DMCU_VIRT_REG(DMCU_HWTCTRL));\
+	} while (0)
+
+#endif /* __ASM_MACH_MCU_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-mpmu.h b/arch/arm/mach-mmp/include/mach/regs-mpmu.h
new file mode 100644
index 00000000..64d314ec
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-mpmu.h
@@ -0,0 +1,139 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/regs-mpmu.h
+ *
+ *   Main Power Management Unit
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_REGS_MPMU_H
+#define __ASM_MACH_REGS_MPMU_H
+
+#include <mach/addr-map.h>
+
+#define MPMU_CPCR	MPMU_REG(0x0000)
+#define MPMU_CPSR	MPMU_REG(0x0004)
+#define MPMU_FCCR	MPMU_REG(0x0008)
+#define MPMU_POCR	MPMU_REG(0x000c)
+#define MPMU_POSR	MPMU_REG(0x0010)
+#define MPMU_SUCCR	MPMU_REG(0x0014)
+#define MPMU_VRCR	MPMU_REG(0x0018)
+#define MPMU_OHCR	MPMU_REG(0x001c)
+#define MPMU_CPRR	MPMU_REG(0x0020)
+#define MPMU_CCGR	MPMU_REG(0x0024)
+#define MPMU_GPCR	MPMU_REG(0x0030)
+#define MPMU_PLL2CR	MPMU_REG(0x0034)
+#ifndef CONFIG_CPU_EDEN
+#define MPMU_PLL3CR	MPMU_REG(0x001c)
+#else
+#define MPMU_PLL3CR	MPMU_REG(0x0050)
+#define MPMU_PLL4CR	MPMU_REG(0x1100)
+#define MPMU_PLL5CR	MPMU_REG(0x1114)
+#endif /* CONFIG_CPU_EDEN */
+#define MPMU_SCCR	MPMU_REG(0x0038)
+#define MPMU_MCCR	MPMU_REG(0x003c)
+#define MPMU_ISCCRX0	MPMU_REG(0x0040)
+#define MPMU_ISCCRX1	MPMU_REG(0x0044)
+#define MPMU_CWUCRM	MPMU_REG(0x004c)
+#ifndef CONFIG_CPU_EDEN
+#define MPMU_PLL1_REG1	MPMU_REG(0x0050)
+#define MPMU_PLL1_REG2	MPMU_REG(0x0054)
+#define MPMU_PLL1_SSC	MPMU_REG(0x0058)
+#define MPMU_PLL2_REG1	MPMU_REG(0x0060)
+#define MPMU_PLL2_REG2	MPMU_REG(0x0064)
+#define MPMU_PLL2_SSC	MPMU_REG(0x0068)
+#else
+#define MPMU_POSR2	MPMU_REG(0x0054)
+#define MPMU_PLL3_CTRL1	MPMU_REG(0x0058)
+#define MPMU_PLL1_CTRL	MPMU_REG(0x005c)
+#define MPMU_PLL3_CTRL2	MPMU_REG(0x0060)
+#define MPMU_PLL3_CTRL3	MPMU_REG(0x0064)
+#define MPMU_PLL2_DIFF_CTRL	MPMU_REG(0x0068)
+#define MPMU_PLL3_DIFF_CTRL	MPMU_REG(0x006c)
+#endif /* CONFIG_CPU_EDEN */
+
+#define MPMU_SD_ROT_WAKE_CLR	MPMU_REG(0x007c)
+#define MPMU_PLL2_CTRL1 MPMU_REG(0x0414)
+#define MPMU_PLL2_CTRL2 MPMU_REG(0x0418)
+#define MPMU_PLL2_CTRL3	MPMU_REG(0x041c)
+
+#define MPMU_SRAM_PWRDWN_CTRL	MPMU_REG(0x0420)
+
+#if defined(CONFIG_CPU_MMP3) || defined(CONFIG_CPU_EDEN)
+#define MPMU_PLL1_CTRL  MPMU_REG(0x005c)    /* MMP3 PLL1 control reg */
+#else
+#define MPMU_PLL1_CTRL  MPMU_REG(0x0418)    /* MMP2 PLL1 control reg */
+#endif
+
+#define MPMU_TS		MPMU_REG(0x0080)
+#define MPMU_WDTPCR	MPMU_REG(0x0200)
+#define MPMU_APCR	MPMU_REG(0x1000)
+#define MPMU_APSR	MPMU_REG(0x1004)
+#define MPMU_APRR	MPMU_REG(0x1020)
+#define MPMU_ACGR	MPMU_REG(0x1024)
+#define MPMU_ARSR	MPMU_REG(0x1028)
+#define MPMU_AWUCRS	MPMU_REG(0x1048)
+#define MPMU_AWUCRM	MPMU_REG(0x104c)
+#define MPMU_CWUCRS	MPMU_REG(0x0048)
+#define MPMU_CWUCRM	MPMU_REG(0x004c)
+#define MPMU_HSI_CLK_RES_CTRL MPMU_REG(0x1050)
+
+#define MPMU_PLL4_CTRL1	MPMU_REG(0x1104)
+#define MPMU_PLL4_CTRL2	MPMU_REG(0x1108)
+#define MPMU_PLL4_CTRL3	MPMU_REG(0x110c)
+#define MPMU_PLL4_DIFF_CTRL	MPMU_REG(0x1110)
+#define MPMU_PLL5_CTRL1	MPMU_REG(0x1118)
+#define MPMU_PLL5_CTRL2	MPMU_REG(0x111c)
+#define MPMU_PLL5_CTRL3	MPMU_REG(0x1120)
+#define MPMU_PLL5_DIFF_CTRL	MPMU_REG(0x1124)
+
+/*MMP3 PLL3 registers*/
+#define PMUM_PLL3_CR	MPMU_REG(0x0050)
+#define PMUM_POSR2	MPMU_REG(0x0054)
+#define PMUM_PLL3_CTRL1	MPMU_REG(0x0058)
+#define PMUM_PLL3_CTRL2	MPMU_REG(0x0060)
+#define PMUM_PLL3_CTRL3	MPMU_REG(0x0064)
+
+#define PMUM_PLL_DIFF_CTRL	MPMU_REG(0x0068)
+#define PMUM_DVC_AP		MPMU_REG(0x2020)
+#define PMUM_DVC_CP		MPMU_REG(0x2024)
+#define PMUM_DVC_DP		MPMU_REG(0x2028)
+#define PMUM_DVC_APSUB		MPMU_REG(0x202C)
+#define PMUM_DVC_CHIP		MPMU_REG(0x2030)
+#define PMUM_DVC_STATUS		MPMU_REG(0x2040)
+#define PMUM_DVCR		MPMU_REG(0x2000)
+#define PMUM_VL01STR		MPMU_REG(0x2004)
+#define PMUM_VL12STR		MPMU_REG(0x2008)
+#define PMUM_VL23STR		MPMU_REG(0x200c)
+#define PMUM_VL34STR		MPMU_REG(0x2010)
+#define PMUM_VL45STR		MPMU_REG(0x2014)
+#define PMUM_VL56STR		MPMU_REG(0x2018)
+#define PMUM_VL67STR		MPMU_REG(0x201c)
+#define PMUM_DVC_IMR		MPMU_REG(0x2050)
+#define PMUM_DVC_ISR		MPMU_REG(0x2054)
+
+#define DVC_AP_LPM_AVC_EN	(1 << 3)
+#define DVC_CP_LPM_AVC_EN	(1 << 3)
+#define DVC_DP_LPM_AVC_EN	(1 << 3)
+#define UDR_AP_SLP_AVC_EN	(1 << 15)
+#define nUDR_AP_SLP_AVC_EN	(1 << 11)
+#define AP_IDLE_DDROFF_AVC_EN	(1 << 7)
+#define AP_IDLE_DDRON_AVC_EN	(1 << 3)
+#define UDR_SLP_AVC_EN		(1 << 7)
+#define nUDR_SLP_AVC_EN		(1 << 3)
+#define DVCR_VC_EN		(1 << 1)
+#define DVCR_LPM_AVC_EN		(1 << 0)
+#define VLXX_ST_MASK		(0xFFFF)
+#define AP_VC_DONE_INTR_MASK	(1 << 0)
+#define CP_VC_DONE_INTR_MASK	(1 << 1)
+#define DP_VC_DONE_INTR_MASK	(1 << 2)
+#define AP_VC_DONE_INTR_ISR	(1 << 0)
+#define CP_VC_DONE_INTR_ISR	(1 << 1)
+#define DP_VC_DONE_INTR_ISR	(1 << 2)
+
+
+
+
+#endif /* __ASM_MACH_REGS_APMU_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-timers.h b/arch/arm/mach-mmp/include/mach/regs-timers.h
index 45589fec..252090cd 100644
--- a/arch/arm/mach-mmp/include/mach/regs-timers.h
+++ b/arch/arm/mach-mmp/include/mach/regs-timers.h
@@ -15,6 +15,8 @@
 
 #define TIMERS1_VIRT_BASE	(APB_VIRT_BASE + 0x14000)
 #define TIMERS2_VIRT_BASE	(APB_VIRT_BASE + 0x16000)
+#define TIMERS3_VIRT_BASE	(APB_VIRT_BASE + 0x1F000) /* for PXA1088 */
+#define CP_TIMERS2_VIRT_BASE    (APB_VIRT_BASE + 0x80000)
 
 #define TMR_CCR		(0x0000)
 #define TMR_TN_MM(n, m)	(0x0004 + ((n) << 3) + (((n) + (m)) << 2))
@@ -37,8 +39,14 @@
 #define TMR_WSAR	(0x00A0)
 #define TMR_CVWR(n)	(0x00A4 + ((n) << 2))
 
+#define TMR_CRSR	(0x00B0) /* for EDEN and PXA1088 */
+
 #define TMR_CCR_CS_0(x)	(((x) & 0x3) << 0)
-#define TMR_CCR_CS_1(x)	(((x) & 0x7) << 2)
+#define TMR_CCR_CS_1(x)	(((x) & 0x3) << 2)
 #define TMR_CCR_CS_2(x)	(((x) & 0x3) << 5)
 
+#ifdef CONFIG_CPU_PXA1088
+#define GENERIC_COUNTER_VIRT_BASE       (APB_VIRT_BASE + 0x101000)
+#endif
+
 #endif /* __ASM_MACH_REGS_TIMERS_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-usb.h b/arch/arm/mach-mmp/include/mach/regs-usb.h
new file mode 100644
index 00000000..b2b92a09
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-usb.h
@@ -0,0 +1,416 @@
+/*
+ * Copyright (C) 2011 Marvell International Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_REGS_USB_H
+#define __ASM_ARCH_REGS_USB_H
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+/* USB DEVICE REGISTER BASE ADDRESS */
+#define PXA988_UDC_REGBASE		(0xd4208000)
+#define PXA988_UDC_CAPREGS_RANGE	(0x100)
+#define PXA988_UDC_REG_RANGE		(0x1ff)
+
+/* USB PHY REGISTER BASE ADDRESS */
+#define PXA988_UDC_PHYBASE	(0xd4207000)
+#define PXA988_UDC_PHY_RANGE	(0xff)
+
+/*
+ * PXA988 USB DEVICE PHY(UTMI) Registers
+ */
+struct pxa988_usb_phy {
+	u16 utmi_id;		/* 0x00 */
+	u16 pad0;
+	u16 utmi_pll_reg0;	/* 0x04 */
+#define PLLVDD18(x)		((x & 0x3) << 14)
+#define REFDIV(x)		((x & 0x1f) << 9)
+#define FBDIV(x)		(x & 0x1ff)
+	u16 pad1;
+	u16 utmi_pll_reg1;	/* 0x08 */
+#define PLL_READY		(0x1 << 15)
+#define PLL_CONTROL_BY_PIN	(0x1 << 14)
+#define PU_PLL			(0x1 << 13)
+#define PLL_LOCK_BYPASS		(0x1 << 12)
+#define DLL_RESET_BLK		(0x1 << 11)
+#define ICP(x)			((x & 0x7) << 8)
+#define KVCO_EXT		(0x1 << 7)
+#define KVCO(x)			((x & 0x7) << 4)
+#define CLK_BLK_EN		(0x1 << 3)
+#define VCOCAL_START		(0x1 << 2)
+#define PLLCAL12(x)		(x & 0x3)
+	u16 pad2;
+	u32 rsvd0;		/* 0x0c */
+	u16 utmi_tx_reg0;	/* 0x10 */
+#define TXDATA_BLK_EN		(0x1 << 14)
+#define RCAL_START		(0x1 << 13)
+#define EXT_HS_RCAL_EN		(0x1 << 12)
+#define EXT_FS_RCAL_EN		(0x1 << 11)
+#define IMPCAL_VTH(x)		((x & 0x7) << 8)
+#define EXT_HS_RCAL(x)		((x & 0xf) << 4)
+#define EXT_FS_RCAL(x)		(x & 0xf)
+	u16 pad3;
+	u16 utmi_tx_reg1;	/* 0x14 */
+#define TXVDD15(x)		((x & 0x3) << 10)
+#define TXVDD12(x)		((x & 0x3) << 8)
+#define LOWVDD_EN		(0x1 << 7)
+#define AMP(x)			((x & 0x7) << 4)
+#define CK60_PHSEL(x)		(x & 0xf)
+	u16 pad4;
+	u16 utmi_tx_reg2;	/* 0x18 */
+#define DRV_SLEWRATE(x)		((x & 0x3) << 10)
+#define IMP_CAL_DLY(x)		((x & 0x3) << 8)
+#define FSDRV_EN(x)		((x & 0xf) << 4)
+#define HSDEV_EN(x)		(x & 0xf)
+	u16 pad5;
+	u32 rsvd1;		/* 0x1c */
+	u16 utmi_rx_reg0;	/* 0x20 */
+#define PHASE_FREEZE_DLY	(0x1 << 15)
+#define USQ_LENGTH		(0x1 << 14)
+#define ACQ_LENGTH(x)		((x & 0x3) << 12)
+#define SQ_LENGTH(x)		((x & 0x3) << 10)
+#define DISCON_THRESH(x)	((x & 0x3) << 8)
+#define SQ_THRESH(x)		((x & 0xf) << 4)
+#define LPF_COEF(x)		((x & 0x3) << 2)
+#define INTPI(x)		(x & 0x3)
+	u16 pad6;
+	u16 utmi_rx_reg1;	/* 0x24 */
+#define EARLY_VOS_ON_EN		(0x1 << 13)
+#define RXDATA_BLOCK_EN		(0x1 << 12)
+#define EDGE_DET_EN		(0x1 << 11)
+#define CAP_SEL(x)		((x & 0x7) << 8)
+#define RXDATA_BLOCK_LENGTH(x)	((x & 0x3) << 6)
+#define EDGE_DET_SEL(x)		((x & 0x3) << 4)
+#define CDR_COEF_SEL		(0x1 << 3)
+#define CDR_FASTLOCK_EN		(0x1 << 2)
+#define S2TO3_DLY_SEL(x)	(x & 0x3)
+	u16 pad7;
+	u16 utmi_rx_reg2;	/* 0x28 */
+#define USQ_FILTER		(0x1 << 8)
+#define SQ_CM_SEL		(0x1 << 7)
+#define SAMPLER_CTRL		(0x1 << 6)
+#define SQ_BUFFER_EN		(0x1 << 5)
+#define SQ_ALWAYS_ON		(0x1 << 4)
+#define RXVDD18(x)		((x & 0x3) << 2)
+#define RXVDD12(x)		(x & 0x3)
+	u16 pad8;
+	u32 rsvd2;		/* 0x2c */
+	u16 utmi_ana_reg0;	/* 0x30 */
+#define BG_VSEL(x)		((x & 0x3) << 8)
+#define DIG_SEL(x)		((x & 0x3) << 6)
+#define TOPVDD18(x)		((x & 0x3) << 4)
+#define VDD_USB2_DIG_TOP_SEL	(0x1 << 3)
+#define IPTAT_SEL(x)		(x & 0x7)
+	u16 pad9;
+	u16 utmi_ana_reg1;	/* 0x34 */
+#define PU_ANA			(0x1 << 14)
+#define ANA_CONTROL_BY_PIN	(0x1 << 13)
+#define SEL_LPFR		(0x1 << 12)
+#define V2I_EXT			(0x1 << 11)
+#define V2I(x)			((x & 0x7) << 8)
+#define R_ROTATE_SEL		(0x1 << 7)
+#define STRESS_TEST_MODE	(0x1 << 6)
+#define TESTMON_ANA(x)		(x & 0x3f)
+	u16 pad10;
+	u32 rsvd3;		/* 0x38 */
+	u16 utmi_dig_reg0;	/* 0x3c */
+#define FIFO_UF			(0x1 << 15)
+#define FIFO_OV			(0x1 << 14)
+#define FS_EOP_MODE		(0x1 << 13)
+#define HOST_DISCON_SEL1	(0x1 << 12)
+#define HOST_DISCON_SEL0	(0x1 << 11)
+#define FORCE_END_EN		(0x1 << 10)
+#define EARLY_TX_EN		(0x1 << 9)
+#define SYNCDET_WINDOW_EN	(0x1 << 8)
+#define CLK_SUSPEND_EN		(0x1 << 7)
+#define HS_DRIBBLE_EN		(0x1 << 6)
+#define SYNC_NUM(x)		((x & 0x3) << 4)
+#define FIFO_FILL_NUM(x)	(x & 0xf)
+	u16 pad11;
+	u16 utmi_dig_reg1;	/* 0x40 */
+#define FS_RX_ERROR_MODE2	(0x1 << 15)
+#define FS_RX_ERROR_MODE1	(0x1 << 14)
+#define FS_RX_ERROR_MODE	(0x1 << 13)
+#define CLK_OUT_SEL		(0x1 << 12)
+#define EXT_TX_CLK_SEL		(0x1 << 11)
+#define ARC_DPDM_MODE		(0x1 << 10)
+#define DP_PULLDOWN		(0x1 << 9)
+#define DM_PULLDOWN		(0x1 << 8)
+#define SYNC_IGNORE_SQ		(0x1 << 7)
+#define SQ_RST_RX		(0x1 << 6)
+#define MON_SEL(x)		(x & 0x3f)
+	u16 pad12;
+	u16 utmi_dig_reg2;	/* 0x44 */
+#define PAD_STRENGTH(x)		((x & 0x1f) << 8)
+#define LONG_EOP		(0x1 << 5)
+#define NOVBUS_DPDM00		(0x1 << 4)
+#define ALIGN_FS_OUTEN		(0x1 << 2)
+#define HS_HDL_SYNC		(0x1 << 1)
+#define FS_HDL_OPMD		(0x1 << 0)
+	u16 pad13;
+	u32 rsvd4;		/* 0x48 */
+	u16 utmi_test_reg0;	/* 0x4c */
+	u16 pad14;
+	u16 utmi_test_reg1;	/* 0x50 */
+	u16 pad15;
+	u32 rsvd5;		/* 0x54 */
+	u16 utmi_charger_reg0;	/* 0x58 */
+#define ENABLE_SWITCH		(0x1 << 3)
+#define PU_CHRG_DTC		(0x1 << 2)
+#define TESTMON_CHRGDTC(x)	(x & 0x3)
+	u16 pad16;
+	u16 utmi_otg_reg;	/* 0x5c */
+	u16 pad17;
+	u16 utmi_phy_mon0;	/* 0x60 */
+	u16 pad18;
+	u16 utmi_reserve_reg0;	/* 0x64 */
+	u16 pad19;
+};
+#else /* CONFIG_CPU_PXA988 */
+
+#define PXA168_U2O_REGBASE	(0xd4208000)
+#define PXA168_U2O_PHYBASE	(0xd4207000)
+
+#define PXA168_U2H_REGBASE      (0xd4209000)
+#define PXA168_U2H_PHYBASE      (0xd4206000)
+
+#define MMP3_HSIC1_REGBASE	(0xf0001000)
+#define MMP3_HSIC1_PHYBASE	(0xf0001800)
+
+#define MMP3_HSIC2_REGBASE	(0xf0002000)
+#define MMP3_HSIC2_PHYBASE	(0xf0002800)
+
+#define MMP3_FSIC_REGBASE	(0xf0003000)
+#define MMP3_FSIC_PHYBASE	(0xf0003800)
+
+
+#define USB_REG_RANGE		(0x1ff)
+#define USB_PHY_RANGE		(0xff)
+
+/* registers */
+#define U2x_CAPREGS_OFFSET       0x100
+
+/* phy regs */
+#define UTMI_REVISION		0x0
+#define UTMI_CTRL		0x4
+#define UTMI_PLL		0x8
+#define UTMI_TX			0xc
+#define UTMI_RX			0x10
+#define UTMI_IVREF		0x14
+#define UTMI_T0			0x18
+#define UTMI_T1			0x1c
+#define UTMI_T2			0x20
+#define UTMI_T3			0x24
+#define UTMI_T4			0x28
+#define UTMI_T5			0x2c
+#define UTMI_RESERVE		0x30
+#define UTMI_USB_INT		0x34
+#define UTMI_DBG_CTL		0x38
+#define UTMI_OTG_ADDON		0x3c
+
+/* For UTMICTRL Register */
+#define UTMI_CTRL_USB_CLK_EN                    (1 << 31)
+/* pxa168 */
+#define UTMI_CTRL_SUSPEND_SET1                  (1 << 30)
+#define UTMI_CTRL_SUSPEND_SET2                  (1 << 29)
+#define UTMI_CTRL_RXBUF_PDWN                    (1 << 24)
+#define UTMI_CTRL_TXBUF_PDWN                    (1 << 11)
+
+#define UTMI_CTRL_INPKT_DELAY_SHIFT             30
+#define UTMI_CTRL_INPKT_DELAY_SOF_SHIFT		28
+#define UTMI_CTRL_PU_REF_SHIFT			20
+#define UTMI_CTRL_ARC_PULLDN_SHIFT              12
+#define UTMI_CTRL_PLL_PWR_UP_SHIFT              1
+#define UTMI_CTRL_PWR_UP_SHIFT                  0
+
+/* For UTMI_PLL Register */
+#define UTMI_PLL_PLLCALI12_SHIFT		29
+#define UTMI_PLL_PLLCALI12_MASK			(0x3 << 29)
+
+#define UTMI_PLL_PLLVDD18_SHIFT			27
+#define UTMI_PLL_PLLVDD18_MASK			(0x3 << 27)
+
+#define UTMI_PLL_PLLVDD12_SHIFT			25
+#define UTMI_PLL_PLLVDD12_MASK			(0x3 << 25)
+
+#define UTMI_PLL_CLK_BLK_EN_SHIFT               24
+#define CLK_BLK_EN                              (0x1 << 24)
+#define PLL_READY                               (0x1 << 23)
+#define KVCO_EXT                                (0x1 << 22)
+#define VCOCAL_START                            (0x1 << 21)
+
+#define UTMI_PLL_KVCO_SHIFT			15
+#define UTMI_PLL_KVCO_MASK                      (0x7 << 15)
+
+#define UTMI_PLL_ICP_SHIFT			12
+#define UTMI_PLL_ICP_MASK                       (0x7 << 12)
+
+#define UTMI_PLL_FBDIV_SHIFT                    4
+#define UTMI_PLL_FBDIV_MASK                     (0xFF << 4)
+
+#define UTMI_PLL_REFDIV_SHIFT                   0
+#define UTMI_PLL_REFDIV_MASK                    (0xF << 0)
+
+/* For UTMI_TX Register */
+#define UTMI_TX_REG_EXT_FS_RCAL_SHIFT		27
+#define UTMI_TX_REG_EXT_FS_RCAL_MASK		(0xf << 27)
+
+#define UTMI_TX_REG_EXT_FS_RCAL_EN_SHIFT	26
+#define UTMI_TX_REG_EXT_FS_RCAL_EN_MASK		(0x1 << 26)
+
+#define UTMI_TX_TXVDD12_SHIFT                   22
+#define UTMI_TX_TXVDD12_MASK                    (0x3 << 22)
+
+#define UTMI_TX_CK60_PHSEL_SHIFT                17
+#define UTMI_TX_CK60_PHSEL_MASK                 (0xf << 17)
+
+#define UTMI_TX_IMPCAL_VTH_SHIFT                14
+#define UTMI_TX_IMPCAL_VTH_MASK                 (0x7 << 14)
+
+#define REG_RCAL_START                          (0x1 << 12)
+
+#define UTMI_TX_LOW_VDD_EN_SHIFT                11
+
+#define UTMI_TX_AMP_SHIFT			0
+#define UTMI_TX_AMP_MASK			(0x7 << 0)
+
+/* For UTMI_RX Register */
+#define UTMI_REG_SQ_LENGTH_SHIFT                15
+#define UTMI_REG_SQ_LENGTH_MASK                 (0x3 << 15)
+
+#define UTMI_RX_SQ_THRESH_SHIFT                 4
+#define UTMI_RX_SQ_THRESH_MASK                  (0xf << 4)
+
+#define UTMI_OTG_ADDON_OTG_ON			(1 << 0)
+
+/* For MMP3 USB Phy */
+#define USB2_PLL_REG0		0x4
+#define USB2_PLL_REG1		0x8
+#define USB2_TX_REG0		0x10
+#define USB2_TX_REG1		0x14
+#define USB2_TX_REG2		0x18
+#define USB2_RX_REG0		0x20
+#define USB2_RX_REG1		0x24
+#define USB2_RX_REG2		0x28
+#define USB2_ANA_REG0		0x30
+#define USB2_ANA_REG1		0x34
+#define USB2_ANA_REG2		0x38
+#define USB2_DIG_REG0		0x3C
+#define USB2_DIG_REG1		0x40
+#define USB2_DIG_REG2		0x44
+#define USB2_DIG_REG3		0x48
+#define USB2_TEST_REG0		0x4C
+#define USB2_TEST_REG1		0x50
+#define USB2_TEST_REG2		0x54
+#define USB2_CHARGER_REG0	0x58
+#define USB2_OTG_REG0		0x5C
+#define USB2_PHY_MON0		0x60
+#define USB2_RESETVE_REG0	0x64
+#define USB2_ICID_REG0		0x78
+#define USB2_ICID_REG1		0x7C
+
+/* USB2_PLL_REG0 */
+/* This is for Ax stepping */
+#define USB2_PLL_FBDIV_SHIFT_MMP3		0
+#define USB2_PLL_FBDIV_MASK_MMP3		(0xFF << 0)
+
+#define USB2_PLL_REFDIV_SHIFT_MMP3		8
+#define USB2_PLL_REFDIV_MASK_MMP3		(0xF << 8)
+
+#define USB2_PLL_VDD12_SHIFT_MMP3		12
+#define USB2_PLL_VDD18_SHIFT_MMP3		14
+
+/* This is for B0 stepping */
+#define USB2_PLL_FBDIV_SHIFT_MMP3_B0		0
+#define USB2_PLL_REFDIV_SHIFT_MMP3_B0		9
+#define USB2_PLL_VDD18_SHIFT_MMP3_B0		14
+#define USB2_PLL_FBDIV_MASK_MMP3_B0		0x01FF
+#define USB2_PLL_REFDIV_MASK_MMP3_B0		0x3E00
+
+#define USB2_PLL_CAL12_SHIFT_MMP3		0
+#define USB2_PLL_CALI12_MASK_MMP3		(0x3 << 0)
+
+#define USB2_PLL_VCOCAL_START_SHIFT_MMP3	2
+
+#define USB2_PLL_KVCO_SHIFT_MMP3		4
+#define USB2_PLL_KVCO_MASK_MMP3			(0x7<<4)
+
+#define USB2_PLL_ICP_SHIFT_MMP3			8
+#define USB2_PLL_ICP_MASK_MMP3			(0x7<<8)
+
+#define USB2_PLL_LOCK_BYPASS_SHIFT_MMP3		12
+
+#define USB2_PLL_PU_PLL_SHIFT_MMP3		13
+#define USB2_PLL_PU_PLL_MASK			(0x1 << 13)
+
+#define USB2_PLL_READY_MASK_MMP3		(0x1 << 15)
+
+/* USB2_TX_REG0 */
+#define USB2_TX_IMPCAL_VTH_SHIFT_MMP3		8
+#define USB2_TX_IMPCAL_VTH_MASK_MMP3		(0x7 << 8)
+
+#define USB2_TX_RCAL_START_SHIFT_MMP3		13
+
+/* USB2_TX_REG1 */
+#define USB2_TX_CK60_PHSEL_SHIFT_MMP3		0
+#define USB2_TX_CK60_PHSEL_MASK_MMP3		(0xf << 0)
+
+#define USB2_TX_AMP_SHIFT_MMP3			4
+#define USB2_TX_AMP_MASK_MMP3			(0x7 << 4)
+
+#define USB2_TX_VDD12_SHIFT_MMP3		8
+#define USB2_TX_VDD12_MASK_MMP3			(0x3 << 8)
+
+/* USB2_TX_REG2 */
+#define USB2_TX_DRV_SLEWRATE_SHIFT		10
+
+/* USB2_RX_REG0 */
+#define USB2_RX_SQ_THRESH_SHIFT_MMP3		4
+#define USB2_RX_SQ_THRESH_MASK_MMP3		(0xf << 4)
+
+#define USB2_RX_SQ_LENGTH_SHIFT_MMP3		10
+#define USB2_RX_SQ_LENGTH_MASK_MMP3		(0x3 << 10)
+
+/* USB2_ANA_REG1*/
+#define USB2_ANA_PU_ANA_SHIFT_MMP3		14
+
+/* USB2_OTG_REG0 */
+#define USB2_OTG_PU_OTG_SHIFT_MMP3		3
+
+/* fsic registers */
+#define FSIC_MISC			0x4
+#define FSIC_INT			0x28
+#define FSIC_CTRL			0x30
+
+/* HSIC registers */
+#define HSIC_PAD_CTRL			0x4
+
+#define HSIC_CTRL			0x8
+#define HSIC_CTRL_HSIC_ENABLE		(1<<7)
+#define HSIC_CTRL_PLL_BYPASS		(1<<4)
+
+#define TEST_GRP_0			0xc
+#define TEST_GRP_1			0x10
+
+#define HSIC_INT			0x14
+#define HSIC_INT_READY_INT_EN		(1<<10)
+#define HSIC_INT_CONNECT_INT_EN		(1<<9)
+#define HSIC_INT_CORE_INT_EN		(1<<8)
+#define HSIC_INT_HS_READY		(1<<2)
+#define HSIC_INT_CONNECT		(1<<1)
+#define HSIC_INT_CORE			(1<<0)
+
+#define HSIC_CONFIG			0x18
+#define USBHSIC_CTRL			0x20
+
+#define HSIC_USB_CTRL			0x28
+#define HSIC_USB_CTRL_CLKEN		1
+#define	HSIC_USB_CLK_PHY		0x0
+#define HSIC_USB_CLK_PMU		0x1
+
+#endif /* CONFIG_CPU_PXA988 */
+#endif /* __ASM_ARCH_REGS_USB_H */
diff --git a/arch/arm/mach-mmp/include/mach/reset-pxa988.h b/arch/arm/mach-mmp/include/mach/reset-pxa988.h
new file mode 100644
index 00000000..356ee4b5
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/reset-pxa988.h
@@ -0,0 +1,49 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/reset-pxa988.h
+ *
+ * Author:	Neil Zhang <zhangwm@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __RESET_PXA988_H__
+#define __RESET_PXA988_H__
+
+#ifdef CONFIG_CPU_PXA988
+#define CPU_CORE_RST(n)	(1 << ((n) * 4 + 16))
+#define CPU_DBG_RST(n)	(1 << ((n) * 4 + 18))
+#define CPU_WDOG_RST(n)	(1 << ((n) * 4 + 19))
+#elif defined(CONFIG_CPU_PXA1088)
+#define CPU_POR_RST(n)	(1 << ((n) * 3 + 16))
+#define CPU_CORE_RST(n)	(1 << ((n) * 3 + 17))
+#define CPU_DBG_RST(n)	(1 << ((n) * 3 + 18))
+#endif
+
+extern u32 pm_reserve_pa;
+extern u32 reset_handler_pa;
+extern u32 secondary_cpu_handler;
+extern void pxa988_secondary_startup(void);
+extern void pxa988_hotplug_handler(void);
+extern void pxa988_return_handler(void);
+extern void pxa988_set_reset_handler(u32 fn, u32 cpu);
+extern void pxa988_cpu_reset_entry(void);
+extern void pxa_cpu_reset(u32 cpu);
+extern void pxa988_gic_raise_softirq(const struct cpumask *mask,
+	unsigned int irq);
+
+#ifdef CONFIG_PM
+extern u32 l2sram_shutdown;
+#ifdef CONFIG_CACHE_L2X0
+extern u32 l2x0_regs_phys;
+extern u32 l2x0_saved_regs_phys_addr;
+#endif
+extern void pxa988_cpu_resume_handler(void);
+#endif
+
+extern void __init pxa_cpu_reset_handler_init(void);
+
+#endif /* __RESET_PXA988_H__ */
diff --git a/arch/arm/mach-mmp/include/mach/samsung_camera.h b/arch/arm/mach-mmp/include/mach/samsung_camera.h
new file mode 100755
index 00000000..b3bf6bfb
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/samsung_camera.h
@@ -0,0 +1,48 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ * 
+ * Created for samsung by Vincent Wan <zswan@marvell.com>,2012/03/31
+ */
+#include <linux/platform_device.h>
+#include <mach/camera.h>
+#include <linux/io.h>
+#include <linux/pm_qos.h>
+#include "../../../drivers/media/video/mmp_camera.h"
+
+#if 1//def CAM_DEBUG 
+#define Cam_Printk(msg...) printk(msg)	
+#else
+#define Cam_Printk(msg...)
+#endif
+
+enum {
+	ID_SUBSENSOR	= 0,
+	ID_S5K4ECGX	= 1,
+	ID_SR030PC30	= 2,
+};
+
+enum cam_power {
+	CAM_POWER_OFF	= 0,
+	CAM_POWER_ON	= 1
+};
+
+/* for s5k sensor power sequence workaround */
+struct mmp_camera_dev;
+struct pxa_i2c ;
+struct soc_camera_device;
+
+struct samsung_camera_data {
+	void (*disable_clk)(struct mmp_camera_dev *pdev);
+	void (*enable_clk)(struct mmp_camera_dev *pdev);
+	void (*i2c_pxa_reset)(struct pxa_i2c *i2c);
+	struct pxa_i2c *i2c;
+	struct mmp_camera_dev *pcdev;
+	struct soc_camera_device *icd;
+	int skip_frames;
+};
+
+extern struct samsung_camera_data samsung_camera;
+extern void  init_samsung_cam(void);
+extern struct mmp_cam_pdata mv_cam_data_forssg;
diff --git a/arch/arm/mach-mmp/include/mach/samsung_camera_goya.h b/arch/arm/mach-mmp/include/mach/samsung_camera_goya.h
new file mode 100644
index 00000000..68042c48
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/samsung_camera_goya.h
@@ -0,0 +1,44 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ * 
+ * Created for samsung by Vincent Wan <zswan@marvell.com>,2012/03/31
+ */
+#include <linux/platform_device.h>
+#include <mach/camera.h>
+#include "../../../drivers/media/video/mmp_camera.h"
+#define CAM_DEBUG 
+#ifdef CAM_DEBUG 
+#define Cam_Printk(msg...) printk(msg)	
+#else
+#define Cam_Printk(msg...)
+#endif
+
+enum {
+	ID_SUBSENSOR	= 0,
+	ID_SR200PC20M  = 1,
+};
+
+enum cam_power {
+	CAM_POWER_OFF	= 0,
+	CAM_POWER_ON	= 1
+};
+
+/* for s5k sensor power sequence workaround */
+struct mmp_camera_dev;
+struct pxa_i2c ;
+
+struct samsung_camera_data {
+	void (*disable_clk)(struct mmp_camera_dev *pdev);
+	void (*enable_clk)(struct mmp_camera_dev *pdev);
+	void (*i2c_pxa_reset)(struct pxa_i2c *i2c);
+	struct pxa_i2c *i2c;
+	struct mmp_camera_dev *pcdev;
+	struct soc_camera_device *icd;
+	int skip_frames;
+};
+
+extern struct samsung_camera_data samsung_camera;
+extern void  init_samsung_cam(void);
+extern struct mmp_cam_pdata mv_cam_data_forssg;
\ No newline at end of file
diff --git a/arch/arm/mach-mmp/include/mach/scu.h b/arch/arm/mach-mmp/include/mach/scu.h
new file mode 100644
index 00000000..d3049507
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/scu.h
@@ -0,0 +1,18 @@
+#ifndef __ASM_MACH_SCU_H
+#define __ASM_MACH_SCU_H
+
+/*
+ * SCU registers
+ */
+#define SCU_CTRL		0x00
+#define SCU_CONFIG		0x04
+#define SCU_CPU_STATUS		0x08
+#define SCU_INVALIDATE		0x0c
+#define SCU_FPGA_REVISION	0x10
+
+/*
+ * Snoop filter registers
+ */
+#define SNOOP_FILTER_ENABLE		0xC20
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/sec_debug.h b/arch/arm/mach-mmp/include/mach/sec_debug.h
new file mode 100644
index 00000000..fc9b59c2
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/sec_debug.h
@@ -0,0 +1,83 @@
+#ifndef SEC_DEBUG_H
+#define SEC_DEBUG_H
+
+#include <linux/sched.h>
+
+#ifdef CONFIG_SEC_DEBUG
+
+union sec_debug_level_t {
+	struct {
+		u16 kernel_fault;
+		u16 user_fault;
+	} en;
+	u32 uint_val;
+};
+
+extern union sec_debug_level_t sec_debug_level;
+
+extern int sec_debug_init(void);
+extern void sec_debug_check_crash_key(unsigned int code, int value);
+
+#endif
+
+#ifdef CONFIG_SEC_LOG
+extern void sec_getlog_supply_kloginfo(void *klog_buf);
+extern void register_log_char_hook(void (*f) (char c));
+#endif
+
+struct worker;
+struct work_struct;
+
+#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
+extern void __sec_debug_task_log(int cpu, struct task_struct *task);
+extern void __sec_debug_irq_log(unsigned int irq, void *fn, int en);
+extern void __sec_debug_work_log(struct worker *worker,
+				 struct work_struct *work, work_func_t f, int en);
+#ifdef CONFIG_SEC_DEBUG_TIMER_LOG
+extern void __sec_debug_timer_log(unsigned int type, void *fn);
+#endif
+
+static inline void sec_debug_task_log(int cpu, struct task_struct *task)
+{
+	if (unlikely(sec_debug_level.en.kernel_fault))
+		__sec_debug_task_log(cpu, task);
+}
+
+static inline void sec_debug_irq_log(unsigned int irq, void *fn, int en)
+{
+	if (unlikely(sec_debug_level.en.kernel_fault))
+		__sec_debug_irq_log(irq, fn, en);
+}
+
+static inline void sec_debug_work_log(struct worker *worker,
+				      struct work_struct *work, work_func_t f, int en)
+{
+	if (unlikely(sec_debug_level.en.kernel_fault))
+		__sec_debug_work_log(worker, work, f, en);
+}
+
+#ifdef CONFIG_SEC_DEBUG_TIMER_LOG
+static inline void sec_debug_timer_log(unsigned int type, void *fn)
+{
+	if (unlikely(sec_debug_level.en.kernel_fault))
+		__sec_debug_timer_log(type, fn);
+}
+#else
+static inline void sec_debug_timer_log(unsigned int type, void *fn)
+{
+}
+#endif
+
+#ifdef CONFIG_SEC_DEBUG_SOFTIRQ_LOG
+static inline void sec_debug_softirq_log(unsigned int irq, void *fn, int en)
+{
+	if (unlikely(sec_debug_level.en.kernel_fault))
+		__sec_debug_irq_log(irq, fn, en);
+}
+#else
+static inline void sec_debug_softirq_log(unsigned int irq, void *fn, int en)
+{
+}
+#endif
+#endif
+#endif				/* SEC_DEBUG_H */
diff --git a/arch/arm/mach-mmp/include/mach/soc_coda7542.h b/arch/arm/mach-mmp/include/mach/soc_coda7542.h
new file mode 100644
index 00000000..231720ab
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/soc_coda7542.h
@@ -0,0 +1,8 @@
+#ifndef _SOC_CODA7542_H_
+#define _SOC_CODA7542_H_
+
+#include <linux/uio_coda7542.h>
+
+extern void __init pxa_register_coda7542(void);
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/timex.h b/arch/arm/mach-mmp/include/mach/timex.h
index 70c9f1d8..2b31c15c 100644
--- a/arch/arm/mach-mmp/include/mach/timex.h
+++ b/arch/arm/mach-mmp/include/mach/timex.h
@@ -6,7 +6,7 @@
  * published by the Free Software Foundation.
  */
 
-#ifdef CONFIG_CPU_MMP2
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3) || defined(CONFIG_CPU_EDEN)
 #define CLOCK_TICK_RATE		6500000
 #else
 #define CLOCK_TICK_RATE		3250000
diff --git a/arch/arm/mach-mmp/include/mach/uio_hdmi.h b/arch/arm/mach-mmp/include/mach/uio_hdmi.h
new file mode 100644
index 00000000..2e182fa4
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/uio_hdmi.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Name:        uio_hdmi.h
+ * Project:     MMP
+ * Yifan Zhang
+ *
+ * Copyright (c) 2011, Marvell International Ltd (zhangyf@marvell.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * (C) Copyright 2011 Marvell International Ltd.
+ * All Rights Reserved
+ *****************************************************************************/
+
+#ifndef __UIO_HDMI_H__
+#define __UIO_HDMI_H__
+
+#define SSPA1_GET_VALUE 0
+#define HPD_PIN_READ 6
+#define EDID_NUM 1
+
+enum connect_lock {
+	UNLOCK = 0,
+	FIRST_ACCESS_LOCK,
+	SECOND_ACCESS_LOCK,
+};
+
+struct uio_hdmi_platform_data {
+	u32 itlc_reg_base;
+	u32 sspa_reg_base;
+	u32 gpio;
+	u32 edid_bus_num;
+	int (*hdmi_v5p_power)(int on);
+	int hpd_val;
+};
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/uio_isp.h b/arch/arm/mach-mmp/include/mach/uio_isp.h
new file mode 100644
index 00000000..5de707ab
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/uio_isp.h
@@ -0,0 +1,8 @@
+#ifndef _UIO_ISP_H_
+#define _UIO_ISP_H_
+
+#include <linux/uio_mvisp.h>
+
+extern void __init pxa_register_uio_mvisp(void);
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/uncompress.h b/arch/arm/mach-mmp/include/mach/uncompress.h
index d6daeb7e..21b4a283 100644
--- a/arch/arm/mach-mmp/include/mach/uncompress.h
+++ b/arch/arm/mach-mmp/include/mach/uncompress.h
@@ -40,7 +40,7 @@ static inline void arch_decomp_setup(void)
 	/* default to UART2 */
 	UART = (unsigned long *)UART2_BASE;
 
-	if (machine_is_avengers_lite())
+	if (machine_is_avengers_lite() || machine_is_yellowstone())
 		UART = (unsigned long *)UART3_BASE;
 }
 
diff --git a/arch/arm/mach-mmp/mmp_device.c b/arch/arm/mach-mmp/mmp_device.c
new file mode 100644
index 00000000..a43b1167
--- /dev/null
+++ b/arch/arm/mach-mmp/mmp_device.c
@@ -0,0 +1,323 @@
+
+/*
+ * mmp_device implementation
+ *
+ * Copyright (C) 2012 Marvell Inc
+ * Lei Wen <leiwen@marvell.com>
+ *
+ * Developed in collaboration with (alphabetical order): Benoit
+ * Cousson, Thara Gopinath, Tony Lindgren, Rajendra Nayak, Vikram
+ * Pandita, Sakari Poussa, Anand Sawant, Santosh Shilimkar, Richard
+ * Woodruff
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#undef DEBUG
+
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/pm_runtime.h>
+#include <linux/notifier.h>
+#include <plat/pm.h>
+#include <mach/mmp_device.h>
+
+static LIST_HEAD(mmp_device_hw_list);
+
+static int _mmp_device_enable(struct mmp_device *md)
+{
+	struct mmp_device_hw *hw = md->hw;
+	int i;
+
+	/* avoid system enter low power modes */
+	if (hw->constraint)
+		pm_qos_update_request(&hw->qos_idle,
+				hw->constraint);
+
+	if (hw->activate_func)
+		return hw->activate_func(md);
+
+	clk_enable(hw->fn_clk.clk);
+	for (i = 0; i < MAX_OPT_CLKS && hw->opt_clks[i].clk; i ++)
+		clk_enable(hw->opt_clks[i].clk);
+
+	return 0;
+}
+
+static int _mmp_device_disable(struct mmp_device *md)
+{
+	struct mmp_device_hw *hw = md->hw;
+	int i;
+
+	if (hw->deactivate_func)
+		return hw->deactivate_func(md);
+
+	clk_disable(hw->fn_clk.clk);
+	for (i = 0; i < MAX_OPT_CLKS && hw->opt_clks[i].clk; i ++)
+		clk_disable(hw->opt_clks[i].clk);
+
+	/* allow system enter low power modes */
+	if (hw->constraint)
+		pm_qos_update_request(&hw->qos_idle,
+				PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+	return 0;
+}
+
+int mmp_device_enable(struct platform_device *pdev)
+{
+	int ret;
+	struct mmp_device *md;
+
+	md = to_mmp_device(pdev);
+
+	if (md->state == MMP_DEVICE_STATE_ACTIVE) {
+		dev_warn(&pdev->dev,
+			 "mmp_device: %s() called from invalid state %d\n",
+			 __func__, md->state);
+		return -EINVAL;
+	}
+
+	ret = _mmp_device_enable(md);
+
+	md->state = MMP_DEVICE_STATE_ACTIVE;
+
+	return ret;
+}
+
+int mmp_device_disable(struct platform_device *pdev)
+{
+	int ret;
+	struct mmp_device *md;
+
+	md = to_mmp_device(pdev);
+
+	if (md->state != MMP_DEVICE_STATE_ACTIVE) {
+		dev_warn(&pdev->dev,
+			 "mmp_device: %s() called from invalid state %d\n",
+			 __func__, md->state);
+		return -EINVAL;
+	}
+
+	ret = _mmp_device_disable(md);
+
+	md->state = MMP_DEVICE_STATE_IDLE;
+
+	return ret;
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static int md_runtime_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	int ret;
+
+	ret = pm_generic_runtime_suspend(dev);
+
+	if (!ret)
+		mmp_device_disable(pdev);
+
+	return ret;
+}
+
+static int md_runtime_idle(struct device *dev)
+{
+	return pm_generic_runtime_idle(dev);
+}
+
+static int md_runtime_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	mmp_device_enable(pdev);
+
+	return pm_generic_runtime_resume(dev);
+}
+#endif
+
+#ifdef CONFIG_SUSPEND
+static int md_suspend_noirq(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct mmp_device *md = to_mmp_device(pdev);
+	int ret;
+
+	ret = pm_generic_suspend_noirq(dev);
+
+	if (!ret && !pm_runtime_status_suspended(dev)) {
+		if (pm_generic_runtime_suspend(dev) == 0) {
+			if (!(md->flags & MMP_DEVICE_NO_IDLE_ON_SUSPEND))
+				mmp_device_disable(pdev);
+			md->flags |= MMP_DEVICE_SUSPENDED;
+		}
+	}
+
+	return ret;
+}
+
+static int md_resume_noirq(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct mmp_device *md = to_mmp_device(pdev);
+
+	if ((md->flags & MMP_DEVICE_SUSPENDED) &&
+	    !pm_runtime_status_suspended(dev)) {
+		md->flags &= ~MMP_DEVICE_SUSPENDED;
+		if (!(md->flags & MMP_DEVICE_NO_IDLE_ON_SUSPEND))
+			mmp_device_enable(pdev);
+		pm_generic_runtime_resume(dev);
+	}
+
+	return pm_generic_resume_noirq(dev);
+}
+#else
+#define md_suspend_noirq NULL
+#define md_resume_noirq NULL
+#endif
+
+struct dev_pm_domain mmp_device_pm_domain = {
+	.ops = {
+		SET_RUNTIME_PM_OPS(md_runtime_suspend, md_runtime_resume,
+				   md_runtime_idle)
+		USE_PLATFORM_PM_SLEEP_OPS
+		.suspend_noirq = md_suspend_noirq,
+		.resume_noirq = md_resume_noirq,
+	}
+};
+
+static int init_mmp_clk(struct mmp_clk *mmp_clk, const char *clk_name)
+{
+	mmp_clk->name = clk_name;
+	mmp_clk->clk = clk_get(NULL, clk_name);
+	if (IS_ERR(mmp_clk->clk)) {
+		printk(KERN_WARNING "cannot get clk(%s)\n", clk_name);
+		return PTR_ERR(mmp_clk->clk);
+	}
+
+	return 0;
+}
+
+int __init mmp_device_hw_register(struct mmp_hw_desc *desc)
+{
+	struct mmp_device_hw * hw;
+	int i, ret;
+
+	hw = kzalloc(sizeof(*hw), GFP_KERNEL);
+	if (!hw)
+		return -ENOMEM;
+
+	hw->name = desc->name;
+	hw->id = desc->id;
+	hw->constraint = desc->constraint;
+
+	ret = init_mmp_clk(&hw->fn_clk, desc->fn_clk);
+	if (ret)
+		goto error_exit;
+
+	for (i = 0; i < MAX_OPT_CLKS && desc->opt_clks[i]; i ++) {
+		ret = init_mmp_clk(&hw->opt_clks[i], desc->opt_clks[i]);
+		if (ret)
+			goto error_exit;
+	}
+
+	list_add_tail(&hw->node, &mmp_device_hw_list);
+
+	/* init qos with constraint */
+	if (hw->constraint) {
+		hw->qos_idle.name = hw->name;
+		pm_qos_add_request(&hw->qos_idle, PM_QOS_CPUIDLE_BLOCK,
+				PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+	}
+	return 0;
+
+error_exit:
+	kfree(hw);
+	return ret;
+}
+
+static struct mmp_device_hw *hw_lookup(const char *name)
+{
+	struct mmp_device_hw *hw, *temp;
+
+	hw = NULL;
+	list_for_each_entry(temp, &mmp_device_hw_list, node) {
+		if (!strcmp(name, temp->name)) {
+			hw = temp;
+			break;
+		}
+	}
+
+	return hw;
+}
+
+static void mmp_device_build(struct platform_device *pdev)
+{
+	struct mmp_device_hw *hw;
+	struct mmp_device *md;
+
+	hw = hw_lookup(pdev->name);
+	if (!hw)
+		return;
+
+	md = kzalloc(sizeof(*md), GFP_KERNEL);
+	if (!md)
+		return;
+
+	md->pdev = pdev;
+	md->hw = hw;
+	md->state = MMP_DEVICE_STATE_IDLE;
+	pdev->archdata.md = md;
+	pdev->dev.pm_domain = &mmp_device_pm_domain;
+}
+
+static void mmp_device_delete(struct platform_device *pdev)
+{
+	struct mmp_device *md = pdev->archdata.md;
+
+	if (!md)
+		return;
+
+	pdev->archdata.md = NULL;
+	kfree(md);
+}
+
+static int mmp_device_notifier_call(struct notifier_block *nb,
+				      unsigned long event, void *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	/* only do the lookup the pdev name */
+	if (!pdev->name)
+		return NOTIFY_DONE;
+
+	switch (event) {
+	case BUS_NOTIFY_ADD_DEVICE:
+		mmp_device_build(pdev);
+		break;
+
+	case BUS_NOTIFY_DEL_DEVICE:
+		mmp_device_delete(pdev);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block platform_nb = {
+	.notifier_call = mmp_device_notifier_call,
+};
+
+
+static int __init mmp_device_init(void)
+{
+	bus_register_notifier(&platform_bus_type, &platform_nb);
+	return 0;
+}
+core_initcall(mmp_device_init);
diff --git a/arch/arm/mach-mmp/onboard.h b/arch/arm/mach-mmp/onboard.h
new file mode 100644
index 00000000..796ca928
--- /dev/null
+++ b/arch/arm/mach-mmp/onboard.h
@@ -0,0 +1,23 @@
+#ifndef ONBOARD_H_
+#define ONBOARD_H_
+
+void __init dkb_add_lcd_tpo(void);
+void __init dkb_add_lcd_truly(void);
+void __init dkb_add_lcd_sharp(void);
+void __init yellowstone_add_lcd_mipi(void);
+void __init eden_fpga_add_lcd_mipi(void);
+void __init mmp3_add_tv_out(void);
+void __init emeidkb_add_lcd_mipi(void);
+void __init t7_add_lcd_mipi(void);
+void __init emeidkb_add_tv_out(void);
+void __init harrison_add_lcd_mipi(void);
+void __init lt02_add_lcd_mipi(void);
+#if defined(CONFIG_TOUCHSCREEN_MXT336S)
+void __init input_touchscreen_init(void);
+#endif
+#if defined(CONFIG_TOUCHSCREEN_CYPRESS_TMA46X)
+void __init board_tsp_init(void);
+#endif
+
+
+#endif /* ONBOARD_H_ */
diff --git a/arch/arm/mach-mmp/onboard/Lcd_mipi2lvds_vx5b3d.c b/arch/arm/mach-mmp/onboard/Lcd_mipi2lvds_vx5b3d.c
new file mode 100755
index 00000000..98837209
--- /dev/null
+++ b/arch/arm/mach-mmp/onboard/Lcd_mipi2lvds_vx5b3d.c
@@ -0,0 +1,777 @@
+/*
+ * VX5B3D MIPI to RGB Bridge Chip
+ *
+ *
+ * Copyright (C) 2013, Samsung Corporation.
+ *
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+ */
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/lcd.h>
+#include <linux/backlight.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/suspend.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/regulator/machine.h>
+#include <mach/cputype.h>
+#include <mach/mfp-pxa986-goya.h>
+#include <mach/regs-mpmu.h>
+#include <mach/pxa988.h>
+#include <mach/pxa168fb.h>
+#include <mach/Quicklogic_Vxbridge_interface.h>
+
+struct pxa168fb_info *fbi_global = NULL;
+struct Quicklogic_bridge_info *g_vx5b3d = NULL;
+
+
+void vx5b3d_backlightReg_on(int reg_on)
+{
+	struct Quicklogic_bridge_info *pvx5b3d = g_vx5b3d;
+
+#if defined(CONFIG_QUICKLOGIC_BRIDGE)
+	if (reg_on == true) {
+		lcd_power(fbi_global, 1);
+		mutex_lock(&pvx5b3d->pwr_lock);
+
+		/*6.3Khz period for pwm */
+		if(LVDS_CLK_48P05Mhz == pvx5b3d->lvds_clk)
+			Quicklogic_i2c_write32(0x160, V5D3BX_6P3KHZ_REG_VALUE);
+		else
+			Quicklogic_i2c_write32(0x160, V5D3BX_6P3KHZ_REG_VALUE);
+
+		/*Quicklogic_i2c_write32(0x164, 0x0);*/
+		Quicklogic_i2c_write32(0x604, 0x3FFFFFE0/*lvds tx enable*/);
+		mutex_unlock(&pvx5b3d->pwr_lock);
+
+		msleep(110);
+
+		mutex_lock(&pvx5b3d->pwr_lock);
+		Quicklogic_i2c_write32(0x138, 0x3fff0000);
+		Quicklogic_i2c_write32(0x15c, 0x5);
+		mutex_unlock(&pvx5b3d->pwr_lock);
+
+	} else {
+		mutex_lock(&pvx5b3d->pwr_lock);	
+		Quicklogic_i2c_write32(0x164, 0x0);
+		Quicklogic_i2c_write32(0x15c, 0x0);
+		msleep(100);
+		Quicklogic_i2c_write32(0x604, 0x3FFFFFFF/*lvds tx disable*/);
+		msleep(30);
+		mutex_unlock(&pvx5b3d->pwr_lock);
+	}
+#endif	
+}
+
+static int goya_update_brightness(struct Quicklogic_bridge_info *vx5b3d)
+{
+	struct Quicklogic_backlight_value *pwm = vx5b3d->vee_lightValue;
+
+	int brightness = vx5b3d->bd->props.brightness;
+
+	int vx5b3d_brightness = 0;
+	u32 vee_strenght = 0;
+	int ret = 0;
+
+
+	/*
+	register 0x160
+	register 0x164
+			  value of 0x164
+	---> duty ratio = -------------
+			  value of 0x160
+	*/
+
+	/* brightness tuning*/
+	if (brightness > MAX_BRIGHTNESS_LEVEL)
+		brightness = MAX_BRIGHTNESS_LEVEL;
+
+//	if (brightness == LOW_BATTERY_LEVEL)/*Outgoing Quality Control Group issue*/
+//		brightness = MINIMUM_VISIBILITY_LEVEL;
+
+	if (brightness >= MID_BRIGHTNESS_LEVEL) {
+		vx5b3d_brightness  = (brightness - MID_BRIGHTNESS_LEVEL) *
+		(pwm->max - pwm->mid) / (MAX_BRIGHTNESS_LEVEL-MID_BRIGHTNESS_LEVEL) + pwm->mid;
+	} else if (brightness >= LOW_BRIGHTNESS_LEVEL) {
+		vx5b3d_brightness  = (brightness - LOW_BRIGHTNESS_LEVEL) *
+		(pwm->mid - pwm->low) / (MID_BRIGHTNESS_LEVEL-LOW_BRIGHTNESS_LEVEL) + pwm->low;
+	} else if (brightness >= DIM_BRIGHTNESS_LEVEL) {
+		vx5b3d_brightness  = (brightness - DIM_BRIGHTNESS_LEVEL) *
+		(pwm->low - pwm->dim) / (LOW_BRIGHTNESS_LEVEL-DIM_BRIGHTNESS_LEVEL) + pwm->dim;
+	} else if (brightness > 0)
+		vx5b3d_brightness  = pwm->dim;
+	else {
+		vx5b3d_brightness = 0;
+		printk("brightness = [%d]: vx5b3d_brightness = [%d]\n",\
+			brightness,vx5b3d_brightness);	
+	}
+	if (vx5b3d->cabc) {
+
+		switch (vx5b3d->auto_brightness) {
+
+		case	0 ... 3:
+			vx5b3d->vee_strenght = V5D3BX_DEFAULT_STRENGHT;
+			break;
+		case	4 ... 5:
+			vx5b3d->vee_strenght = V5D3BX_DEFAULT_LOW_STRENGHT;
+			break;
+		case 	6 ... 8:
+			vx5b3d->vee_strenght = V5D3BX_DEFAULT_HIGH_STRENGHT;
+			break;	
+		default:
+			vx5b3d->vee_strenght = V5D3BX_DEFAULT_STRENGHT;
+		}
+/*
+	if (g_vx5d3b->auto_brightness >= 5)
+		g_vx5d3b->vee_strenght = V5D3BX_MAX_STRENGHT;
+*/
+		vee_strenght = V5D3BX_VEESTRENGHT | ((vx5b3d->vee_strenght) << 27);
+
+	if (!(vx5b3d->auto_brightness >= 5))
+		vx5b3d_brightness = (vx5b3d_brightness * V5D3BX_CABCBRIGHTNESSRATIO) / 1000;
+
+	} else {
+		vee_strenght = V5D3BX_VEESTRENGHT | (V5D3BX_VEEDEFAULTVAL << 27);
+	}
+
+	/* brightness setting from platform is from 0 to 255 */
+	mutex_lock(&vx5b3d->pwr_lock);
+
+	if (LVDS_CLK_48P05Mhz == vx5b3d->lvds_clk)	
+		vx5b3d->vx5b3d_backlight_frq = V5D3BX_6P3KHZ_DEFAULT_RATIO;
+	else	/*Default for 51.6Mhz*/
+		vx5b3d->vx5b3d_backlight_frq = V5D3BX_6P3KHZ_DEFAULT_RATIO;
+/*
+
+	if ((vx5b3d->prevee_strenght != vee_strenght) && (brightness != 0))
+		ret |= Quicklogic_i2c_write32(0x400,vee_strenght);
+	if (!vx5b3d->first_count)
+		ret |= Quicklogic_i2c_write32(0x164,((vx5b3d_brightness * vx5b3d->vx5b3d_backlight_frq)/1000));
+*/
+#if defined(CONFIG_QUICKLOGIC_BRIDGE)
+	ret |= Quicklogic_i2c_write32(0x164,((vx5b3d_brightness * vx5b3d->vx5b3d_backlight_frq)/1000));
+	if ( vx5b3d_brightness == 0)
+		Quicklogic_i2c_write32(0x15c, 0x0);
+	else
+		Quicklogic_i2c_write32(0x15c, 0x5);
+#endif
+#if 0
+	/*backlight duty ration control when device is first backlight on.*/
+	if (vx5b3d->first_count && brightness != 0) {
+		printk("backlight control first...[%d] \n",brightness);
+		vx5b3d_backlightReg_on();
+		ret |= Quicklogic_i2c_write32(0x164,((vx5b3d_brightness * vx5b3d->vx5b3d_backlight_frq)/1000));
+
+		vx5b3d->first_count = false;
+	}
+#endif
+	vx5b3d->prevee_strenght = vee_strenght;
+
+	mutex_unlock(&vx5b3d->pwr_lock);
+
+	if (ret < 0)
+		pr_info("vx5b3d_i2c_write fail [%d] ! \n",ret);
+
+	return 0;
+}
+
+void goya_brightness_update(void)
+{
+	struct Quicklogic_bridge_info *vx5b3d = g_vx5b3d;
+	printk("goya brightness update! \n");
+	if (vx5b3d->vx5b3d_enable == false)
+		vx5b3d_backlightReg_on(true);
+
+	goya_update_brightness(vx5b3d);
+}
+
+static int goya_set_brightness(struct backlight_device *bd)
+{
+	struct Quicklogic_bridge_info *vx5b3d = g_vx5b3d;
+	int ret = 0;
+	
+	vx5b3d->bd->props.brightness = bd->props.brightness;
+
+	printk("backlight control =[%d] \n",bd->props.brightness);
+
+	if (fbi_global->active)
+		goya_update_brightness(vx5b3d);
+
+	return ret;
+}
+
+static int goya_get_brightness(struct backlight_device *bd)
+{
+	return bd->props.brightness;
+}
+
+static const struct backlight_ops goya_backlight_ops = {
+	.get_brightness = goya_get_brightness,
+	.update_status = goya_set_brightness,
+};
+
+int vx5b3d_power(struct pxa168fb_info *fbi, int on)
+{
+	struct Quicklogic_bridge_info *vx5b3d = g_vx5b3d;
+	static struct regulator *lvds_1v8, *lvds_1v2;
+
+	if (gpio_request(VX5B3D_RST, "lvds reset")) {
+		pr_err("gpio %d request failed\n", VX5B3D_RST);
+		return -EIO;
+	}
+
+	if (gpio_request(VX5B3D_PWR_EN_VXE_3P3, "lvds 3v3")) {
+		pr_err("gpio %d request failed\n", VX5B3D_PWR_EN_VXE_3P3);
+		return -EIO;
+	}
+
+	if (!lvds_1v2) {
+		lvds_1v2 = regulator_get(NULL, "v_lvds_1v2");
+		if (IS_ERR(lvds_1v2)) {
+			pr_err("%s v_lvds_1v2 regulator get error!\n", __func__);
+			goto regu_lcd_avdd;
+		}
+	}
+
+	if (!lvds_1v8) {
+		lvds_1v8 = regulator_get(NULL, "v_lvds_1v8");
+		if (IS_ERR(lvds_1v8)) {
+			pr_err("%s v_lvds_1v8 regulator get error!\n", __func__);
+			goto regu_lcd_avdd;
+		}
+	}
+
+	if (on) {
+
+		/*LVDS_1P2 / 1P8 Enable*/
+		regulator_set_voltage(lvds_1v2, 1200000, 1200000);
+		regulator_set_voltage(lvds_1v8, 1800000, 1800000);
+		
+		regulator_enable(lvds_1v2);
+		regulator_enable(lvds_1v8);
+
+		if (fbi->skip_pw_on) {
+			printk("vx5b3d_power skip pw on \n");
+			gpio_free(VX5B3D_PWR_EN_VXE_3P3);
+			gpio_free(VX5B3D_RST);			
+			return 0;
+		}
+		/*LVDS_3P3 Enable*/
+		gpio_direction_output(VX5B3D_PWR_EN_VXE_3P3, 1);
+		mdelay(10);
+		/*LVDS_RST*/
+		gpio_direction_output(VX5B3D_RST,0);
+		udelay(20);
+		gpio_direction_output(VX5B3D_RST,1);
+		udelay(20);
+
+	} else {
+		vx5b3d->prevee_strenght = 0;
+		vx5b3d->vx5b3d_enable = false;
+
+		vx5b3d_backlightReg_on(false);
+		lcd_power(fbi, 0);		
+#if defined(CONFIG_QUICKLOGIC_BRIDGE)
+#if defined(CONFIG_SPA) || defined(CONFIG_SPA_LPM_MODE)
+		if(!spa_lpm_charging_mode_get())
+#else
+		if (!lpcharge)
+#endif
+		i2c1_pin_changed(1);
+#endif
+		gpio_direction_output(VX5B3D_RST,0);
+		udelay(20);
+		gpio_direction_output(VX5B3D_PWR_EN_VXE_3P3, 0);
+		regulator_disable(lvds_1v8);
+		regulator_disable(lvds_1v2);
+		msleep(350);
+
+	}
+
+	gpio_free(VX5B3D_PWR_EN_VXE_3P3);
+	gpio_free(VX5B3D_RST);
+
+	return 0;
+ 
+regu_lcd_avdd:
+	lvds_1v2 = NULL;
+	lvds_1v8 = NULL;
+	regulator_put(lvds_1v2);
+	regulator_put(lvds_1v8);
+
+	return -EIO;
+
+}
+
+int vx5b3d_brige_init(struct pxa168fb_info *fbi)
+{
+	struct Quicklogic_bridge_info *vx5b3d = g_vx5b3d;
+	int status;
+
+	printk("VX5B3D ...START.....\n");
+#if defined(CONFIG_QUICKLOGIC_BRIDGE)
+	mutex_lock(&vx5b3d->pwr_lock);
+
+	Quicklogic_mipi_write(fbi,0x700, 0x6C900040,4);
+
+	if (LVDS_CLK_48P05Mhz == vx5b3d->lvds_clk)
+		Quicklogic_mipi_write(fbi,0x704, 0x3040A,4);
+	else
+		Quicklogic_mipi_write(fbi,0x704, 0x30449,4); /* LVDS_CLK_50P98Mhz */
+
+	Quicklogic_mipi_write(fbi,0x70C, 0x00004604,4);
+	Quicklogic_mipi_write(fbi,0x710, /*0x54D004B vee off*/0x54D000B,4);
+	Quicklogic_mipi_write(fbi,0x714, 0x20,4);
+	Quicklogic_mipi_write(fbi,0x718, 0x00000102,4);
+	Quicklogic_mipi_write(fbi,0x71C, 0xA8002F,4);
+	Quicklogic_mipi_write(fbi,0x720, 0x0,4);
+	
+	Quicklogic_mipi_write(fbi,0x154, 0x00000000,4);
+	Quicklogic_mipi_write(fbi,0x154, 0x80000000,4);
+	mdelay(1); /* For pll locking */
+	Quicklogic_mipi_write(fbi,0x700, 0x6C900840,4);
+	Quicklogic_mipi_write(fbi,0x70C, 0x5E56/*0x5646*/,4);
+	Quicklogic_mipi_write(fbi,0x718, 0x00000202,4);
+	
+	
+	Quicklogic_mipi_write(fbi,0x154, 0x00000000,4);	
+	Quicklogic_mipi_write(fbi,0x154, 0x80000000,4);
+	mdelay(1); /* For pll locking */
+	Quicklogic_mipi_write(fbi,0x37C, 0x00001063,4);
+	Quicklogic_mipi_write(fbi,0x380, 0x82A86030,4);
+	Quicklogic_mipi_write(fbi,0x384, 0x2861408B,4);
+	Quicklogic_mipi_write(fbi,0x388, 0x00130285,4);
+	Quicklogic_mipi_write(fbi,0x38C, 0x10630009,4);
+	Quicklogic_mipi_write(fbi,0x394, 0x400B82A8,4);
+	Quicklogic_mipi_write(fbi,0x600, 0x16CC78C,4);
+	Quicklogic_mipi_write(fbi,0x604, 0x3FFFFFFF,4);
+	Quicklogic_mipi_write(fbi,0x608, 0xD8C,4);
+
+
+	Quicklogic_mipi_write(fbi,0x154, 0x00000000,4);
+	Quicklogic_mipi_write(fbi,0x154, 0x80000000,4);
+
+	/* ...move for system reset command (0x158)*/
+
+	Quicklogic_mipi_write(fbi,0x120, 0x5,4);
+
+	if (LVDS_CLK_48P05Mhz == vx5b3d->lvds_clk)
+		Quicklogic_mipi_write(fbi,0x124, 0x1892C400,4);
+	else
+		Quicklogic_mipi_write(fbi,0x124, 0x1B12C400,4); /* LVDS_CLK_50P98Mhz */
+
+	Quicklogic_mipi_write(fbi,0x128, 0x102806,4);
+	
+	if (LVDS_CLK_48P05Mhz == vx5b3d->lvds_clk)
+		Quicklogic_mipi_write(fbi,0x12C, 0x62,4);
+	else
+		Quicklogic_mipi_write(fbi,0x12C, 0x6C,4); /*LVDS_CLK_50P98Mhz*/
+
+	Quicklogic_mipi_write(fbi,0x130, 0x3C18,4);
+	Quicklogic_mipi_write(fbi,0x134, 0x15,4);
+	Quicklogic_mipi_write(fbi,0x138, 0xFF8000,4);
+	Quicklogic_mipi_write(fbi,0x13C, 0x0,4);
+
+
+	/*PWM  100 % duty ration*/
+
+	Quicklogic_mipi_write(fbi,0x114, 0xc6302,4);
+	/*backlight duty ratio control when device is first bring up.*/
+#if 0
+	mdelay(200);
+	Quicklogic_mipi_write(fbi,0x160, 0x7F8/*0xff*/,4);
+	Quicklogic_mipi_write(fbi,0x164, 0x2A8/*0x4c*/,4);
+	Quicklogic_mipi_write(fbi,0x138, 0x3fff0000,4);
+	Quicklogic_mipi_write(fbi,0x15c, 0x5,4);
+	/* END...*/
+#endif
+	Quicklogic_mipi_write(fbi,0x140, 0x10000,4);
+	/*Add for power consumtion*/
+	Quicklogic_mipi_write(fbi,0x174, /*0xff vee off*/0x0,4);
+	/*end*/
+
+	/*
+	slope = 2 / variance = 0x55550022
+	slope register [15,10]
+	*/
+	Quicklogic_mipi_write(fbi, 0x404, 0x55550822,4);
+
+	/*
+	To minimize the text effect 
+	this value from 0xa to 0xf
+	*/
+	Quicklogic_mipi_write(fbi, 0x418, 0x555502ff,4);
+
+	/* 
+	Disable brightnes issue Caused by IBC
+	read 4 bytes from address 0x410 to 0x413
+	0x15E50300 is read value for 0x410 register
+	0x5E50300= 0x15E50300 & 0xefffffff
+	 */
+	Quicklogic_mipi_write(fbi,0x410, 0x5E50300,4);
+	/*...end*/
+	Quicklogic_mipi_write(fbi,0x20C, 0x124,4);
+	Quicklogic_mipi_write(fbi,0x21C, 0x0,4);
+	Quicklogic_mipi_write(fbi,0x224, 0x7,4);
+	Quicklogic_mipi_write(fbi,0x228, 0x50001,4);
+	Quicklogic_mipi_write(fbi,0x22C, 0xFF03,4);
+	Quicklogic_mipi_write(fbi,0x230, 0x1,4);
+	Quicklogic_mipi_write(fbi,0x234, 0xCA033E10,4);
+	Quicklogic_mipi_write(fbi,0x238, 0x00000060,4);
+	Quicklogic_mipi_write(fbi,0x23C, 0x82E86030,4);
+	Quicklogic_mipi_write(fbi,0x244, 0x001E0285,4);
+	
+	if (LVDS_CLK_48P05Mhz == vx5b3d->lvds_clk)
+		Quicklogic_mipi_write(fbi,0x258, 0x60062,4);
+	else
+		Quicklogic_mipi_write(fbi,0x258, 0xA006C,4); /*LVDS_CLK_50P98Mhz*/
+
+	/*vee strenght initialization*/
+	Quicklogic_mipi_write(fbi,0x400, 0x0,4);
+
+	Quicklogic_mipi_write(fbi,0x158, 0x0,4);
+	Quicklogic_mipi_write(fbi,0x158, 0x1,4);
+	mutex_unlock(&vx5b3d->pwr_lock);
+	
+	mdelay(10); /* For pll locking */
+	/*...end */
+#endif	
+	printk("VX5B3D ..END.....\n");
+
+	goya_brightness_update();
+	vx5b3d->vx5b3d_enable = true;
+
+	return 0;
+}
+
+#if defined(CONFIG_QUICKLOGIC_BRIDGE)
+static ssize_t vx5b3dxreg_write_store(struct device *dev, struct
+device_attribute *attr, const char *buf, size_t size)
+{
+	int value;
+	static u32 vee_data = 0;
+	static u16 vee_register = 0;
+	static int cnt;
+	int rc;
+
+	rc = strict_strtoul(buf, (unsigned int) 0, (unsigned long *)&value);
+
+	if (rc < 0)
+		return rc;
+	else {
+		if ( cnt == 0 )
+			vee_register = (u16)value;
+		else
+			vee_data = value;
+		cnt++;
+		printk("count value loop =[%d]\n",cnt);
+		if (cnt == 2) {
+			Quicklogic_i2c_write32(vee_register,vee_data);
+			printk("vx5b3dx register[0x%x]..data[0x%x]\n", \
+				vee_register, vee_data);
+			cnt = 0;
+		}
+
+	}
+	return size;	
+}
+static DEVICE_ATTR(veeregwrite, 0664,NULL, vx5b3dxreg_write_store);
+
+static ssize_t vx5b3d_Regread_store(struct device *dev, struct
+device_attribute *attr, const char *buf, size_t size)
+{
+	unsigned long value = 0;
+	unsigned long ret_value = 0;	
+	int rc = 0;
+
+	if (fbi_global->active == 0)
+		return size;
+
+	rc = strict_strtoul(buf, (unsigned int) 0, (unsigned long *)&value);
+	if (rc < 0)
+		return rc;
+	else {
+		Quicklogic_i2c_read(value,&ret_value,4);
+		pr_info("vx5b3d_Regread_register[0x%x]..return=[0x%x]\n",\
+			value,ret_value);
+
+		return size;
+	}
+}
+static DEVICE_ATTR(veeregread, 0664,NULL, vx5b3d_Regread_store);
+#endif
+
+static ssize_t power_reduce_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct Quicklogic_bridge_info *pvx5b3d = g_vx5b3d;
+	char *pos = buf;
+
+	pos += sprintf(pos, "%d, %d, ", pvx5b3d->auto_brightness, pvx5b3d->cabc);
+
+	return pos - buf;
+}
+
+static ssize_t power_reduce_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct Quicklogic_bridge_info *pvx5b3d = g_vx5b3d;
+	int value = 0, rc = 0;
+
+	if (fbi_global->active == 0)
+		return size;
+
+	rc = strict_strtoul(buf, (unsigned int)0, (unsigned long *)&value);
+	
+	if (rc < 0)
+		return rc;
+	else {
+		mutex_lock(&pvx5b3d->lock);
+
+		printk("CABC[%d] -> [%d]\n",\
+				pvx5b3d->cabc, value);
+
+		if (pvx5b3d->cabc != value) {
+
+			pvx5b3d->auto_brightness = value;
+			pvx5b3d->cabc = (value) ? CABC_ON : CABC_OFF;
+
+			if(pvx5b3d->cabc) {
+				printk("cabc enable \n");
+			} else {
+				printk("cabc disable \n");
+			}
+
+			goya_brightness_update();
+		}
+
+		mutex_unlock(&pvx5b3d->lock);
+	}
+	return size;
+}
+
+static ssize_t lcd_panelName_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "HX8282A");
+}
+
+static ssize_t lcd_MTP_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int panel_id = get_panel_id();
+
+	((unsigned char*)buf)[0] = (panel_id >> 16) & 0xFF;
+	((unsigned char*)buf)[1] = (panel_id >> 8) & 0xFF;
+	((unsigned char*)buf)[2] = panel_id & 0xFF;
+
+	printk("ldi mtpdata: %x %x %x\n", buf[0], buf[1], buf[2]);
+
+	return 3;
+}
+
+static ssize_t lcd_type_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int panel_id = get_panel_id();
+	int ret = 0;
+
+	switch (panel_id) {
+
+		case HX8282A_PANEL_BOE:
+			ret = sprintf(buf, "BOE_BA070WS1-400");	
+			break;	    	
+		case HX8282A_PANEL_SDC:
+			ret = sprintf(buf, "SDC_BA070WS1-400");	
+			break;
+		case HX8282A_PANEL_CPT:
+			ret = sprintf(buf, "CPT_BA070WS1-400");	
+			break;
+		
+		case HX8282A_PANEL_HIMAX:
+			ret = sprintf(buf, "HIMAX_BA070WS1-400");	
+			break;
+
+		default:
+			ret = sprintf(buf, "Panel disconnet");	
+			break;		   
+	}
+	return ret;
+}
+static DEVICE_ATTR(power_reduce, 0644, power_reduce_show, power_reduce_store);
+static DEVICE_ATTR(lcd_MTP, S_IRUGO | S_IWUSR | S_IWGRP | S_IXOTH, lcd_MTP_show, NULL);
+static DEVICE_ATTR(lcd_panelName, S_IRUGO | S_IWUSR | S_IWGRP | S_IXOTH, lcd_panelName_show, NULL);
+static DEVICE_ATTR(lcd_type, S_IRUGO | S_IWUSR | S_IWGRP | S_IXOTH, lcd_type_show, NULL);
+
+static ssize_t lvds_clk_switch_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct Quicklogic_bridge_info *Vee_cabc = g_vx5b3d;
+
+	int ret = 0;
+	ret = sprintf(buf, "%d\n", Vee_cabc->lvds_clk);
+	return ret;
+}
+
+extern int dsi_init(struct pxa168fb_info *fbi);
+
+static ssize_t lvds_clk_switch_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+
+{
+	struct Quicklogic_bridge_info *Vee_cabc = g_vx5b3d;
+	int ret = 0;
+	unsigned int value = 0;
+
+	ret = strict_strtoul(buf, 0, (unsigned long *)&value);
+
+	dev_info(dev, "%s :: value=%d\n", __func__, value);
+
+	if(value == Vee_cabc->lvds_clk)
+	{
+		printk(" lvds clk has been what you want,so not change\n");
+		return -1;
+	}
+	else if( value > LVDS_CLK_50P98Mhz)
+	{
+		printk(" invalid lvds freq index!!!\n");
+		return -1;
+	}
+
+	printk("%s:lvds clk swith to %\n",Vee_cabc->lvds_clk);
+
+	/*just for user mode.
+	for test mode,return -1 directly*/
+	if (fbi_global->active == 0)
+	{
+		mutex_lock(&Vee_cabc->lvds_clk_switch_lock);
+		/*save new lvds clk temprarily*/		
+		Vee_cabc->lvds_clk = value;
+		/*update video_modes for every lvds clk update request during lcd off,
+		lvds setting will be updated during lcd resume */
+	//	pxa168fb_update_modes(fbi_global,Vee_cabc->lvds_clk,Vee_cabc->lcd_panel);
+		mutex_unlock(&Vee_cabc->lvds_clk_switch_lock);
+		return -1;
+	}
+
+	mutex_lock(&Vee_cabc->lvds_clk_switch_lock);
+
+	Vee_cabc->lvds_clk = value;
+
+	Vee_cabc->lvds_clk_switching = true;
+
+	g_vx5b3d->vx5b3d_enable = false;
+	
+	/*do dsi_init,then lvds_init is called to re-gerenate lvds pclk*/	
+	dsi_init(fbi_global);
+	
+	Vee_cabc->orig_lvds_clk = Vee_cabc->lvds_clk;
+	Vee_cabc->lvds_clk_switching = false;
+
+	mutex_unlock(&Vee_cabc->lvds_clk_switch_lock);
+
+	return count;
+}
+
+ DEVICE_ATTR(lvds_clk_switch, 0664, lvds_clk_switch_show, lvds_clk_switch_store);
+
+static int goya_bridge_dummy(struct pxa168fb_info *fbi)
+{
+
+	return 0;
+}
+
+static int goya_bridge_probe(struct pxa168fb_info *fbi)
+{
+	struct Quicklogic_bridge_info *vx5b3dInfo;
+	int ret = 0;
+
+	fbi_global = fbi;
+
+	printk("%s, probe \n", __func__);
+
+	/*For Bridge alloc*/
+	vx5b3dInfo = kzalloc(sizeof(struct Quicklogic_bridge_info), GFP_KERNEL);
+
+	if (!vx5b3dInfo) {
+		pr_err("failed to allocate vx5b3dInfo\n");
+		ret = -ENOMEM;
+		goto error1;
+	}
+
+	/*For lcd class*/
+	vx5b3dInfo->lcd = lcd_device_register("panel", NULL, NULL, NULL);
+	if (IS_ERR_OR_NULL(vx5b3dInfo->lcd)) 
+	{
+		printk("Failed to create lcd class!\n");
+		ret = -EINVAL;
+		goto error1;
+	}
+
+	if (device_create_file(&vx5b3dInfo->lcd->dev, &dev_attr_lcd_panelName) < 0)
+		printk("Failed to create device file(%s)!\n", dev_attr_lcd_panelName.attr.name);
+	if (device_create_file(&vx5b3dInfo->lcd->dev, &dev_attr_lcd_MTP) < 0)
+		printk("Failed to create device file(%s)!\n", dev_attr_lcd_MTP.attr.name);
+	if (device_create_file(&vx5b3dInfo->lcd->dev, &dev_attr_lcd_type) < 0)
+		printk("Failed to create device file(%s)!\n", dev_attr_lcd_type.attr.name);
+
+#if defined(CONFIG_QUICKLOGIC_BRIDGE)
+	if (device_create_file(&vx5b3dInfo->lcd->dev, &dev_attr_veeregwrite) < 0)
+		printk("Failed to create device file(%s)!\n", dev_attr_veeregwrite.attr.name);
+
+	if (device_create_file(&vx5b3dInfo->lcd->dev, &dev_attr_veeregread) < 0)
+		printk("Failed to create device file(%s)!\n", dev_attr_veeregwrite.attr.name);
+#endif
+
+	/*For backlight*/
+	vx5b3dInfo->bd = backlight_device_register("panel", vx5b3dInfo->dev_bd, vx5b3dInfo,
+					&goya_backlight_ops,NULL);
+
+	if (device_create_file(&vx5b3dInfo->lcd->dev, &dev_attr_power_reduce) < 0)
+		printk("Failed to create auto_brightness\n");
+
+	vx5b3dInfo->bd->props.max_brightness = MAX_BRIGHTNESS_LEVEL;
+	vx5b3dInfo->bd->props.brightness = DEFAULT_BRIGHTNESS;
+	vx5b3dInfo->bd->props.type = BACKLIGHT_RAW;
+	vx5b3dInfo->cabc = CABC_OFF;
+	vx5b3dInfo->vee_strenght = V5D3BX_VEEDEFAULTVAL;
+	vx5b3dInfo->current_bl = vx5b3dInfo->bd->props.brightness;
+	vx5b3dInfo->auto_brightness = false;
+	vx5b3dInfo->vx5b3d_enable = true;
+	vx5b3dInfo->negative = false;
+	vx5b3dInfo->prevee_strenght = 1;
+	vx5b3dInfo->lcd_panel = get_panel_id();
+	vx5b3dInfo->vee_lightValue = &backlight_table[vx5b3dInfo->lcd_panel];
+	vx5b3dInfo->lvds_clk = LVDS_CLK_48P05Mhz;
+	vx5b3dInfo->orig_lvds_clk = vx5b3dInfo->lvds_clk;
+	vx5b3dInfo->vx5b3d_backlight_frq = V5D3BX_6P3KHZ_DEFAULT_RATIO;
+
+	mutex_init(&vx5b3dInfo->lock);
+	mutex_init(&vx5b3dInfo->pwr_lock);
+	mutex_init(&vx5b3dInfo->lvds_clk_switch_lock);
+
+	g_vx5b3d = vx5b3dInfo;
+
+	if (device_create_file(&vx5b3dInfo->lcd->dev, &dev_attr_lvds_clk_switch) < 0)
+		printk("Failed to create device file(%s)!\n", dev_attr_lvds_clk_switch.attr.name);
+
+	return ret;
+
+error1:
+	kfree(vx5b3dInfo);	
+	return ret;
+
+}
+
+struct pxa168fb_mipi_lcd_driver goya_lcd_driver = {
+	.probe		= goya_bridge_probe,
+	.init		= goya_bridge_dummy,
+	.disable	= goya_bridge_dummy,
+	.enable		= goya_bridge_dummy,
+};
diff --git a/arch/arm/mach-mmp/onboard/Makefile b/arch/arm/mach-mmp/onboard/Makefile
new file mode 100644
index 00000000..ce6f55eb
--- /dev/null
+++ b/arch/arm/mach-mmp/onboard/Makefile
@@ -0,0 +1,22 @@
+#
+#
+obj-$(CONFIG_MACH_TTC_DKB) += lcd_tpo.o lcd_truly.o lcd_sharp.o
+obj-$(CONFIG_UIO_HDMI) += lcd_hdmi.o
+obj-$(CONFIG_MACH_YELLOWSTONE) += lcd_mipi.o
+obj-$(CONFIG_MACH_EMEIDKB) += lcd_mipi.o
+obj-$(CONFIG_MACH_ARUBA_TD) += lcd_hx8369_mipi.o
+obj-$(CONFIG_MACH_WARUBA) += lcd_hx8369_mipi.o
+obj-$(CONFIG_MACH_HELANDKB) += lcd_mipi.o
+obj-$(CONFIG_MACH_HELANDELOS) += lcd_hx8369_mipi.o
+obj-$(CONFIG_MACH_EDEN_FPGA) += lcd_mipi.o
+obj-$(CONFIG_MACH_HARRISON) += lcd_tc35876x_boeot_wsvga_mipi.o
+obj-$(CONFIG_MACH_LT02) += lcd_tc35876x_boeot_wsvga_mipi.o
+obj-$(CONFIG_MACH_WILCOX) += board-wilcox-display.o lcd_hx8389b_mipi.o lcd_s6d78a0x_mipi.o
+obj-$(CONFIG_MACH_DEGAS) += board-degas-display.o lcd_s6d7aa0x_mipi.o
+obj-$(CONFIG_MACH_CS05) += board-cs05-display.o Lcd_mipi2rgb_vx6b3e.o
+obj-$(CONFIG_MACH_CS02) += lcd_hx8369_mipi.o
+obj-$(CONFIG_MACH_BAFFIN) += lcd_hx8369_mipi.o
+obj-$(CONFIG_MACH_BAFFINQ) += lcd_mipi_generic.o board-baffinq-display.o
+obj-$(CONFIG_MACH_GOLDEN) += board-golden-display.o lcd_s6e63m0.o lcd_s6e63m0_smart.o
+obj-$(CONFIG_MACH_GOYA) += board-goya-display.o Lcd_mipi2lvds_vx5b3d.o
+obj-$(CONFIG_LCD_ESD_RECOVERY) +=  esd_detect.o
diff --git a/arch/arm/mach-mmp/onboard/board-goya-display.c b/arch/arm/mach-mmp/onboard/board-goya-display.c
new file mode 100755
index 00000000..8fd7442b
--- /dev/null
+++ b/arch/arm/mach-mmp/onboard/board-goya-display.c
@@ -0,0 +1,635 @@
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/regulator/machine.h>
+#include <linux/lcd.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/mfp-mmp2.h>
+#include <mach/mmp3.h>
+#include <mach/pxa988.h>
+#include <mach/pxa168fb.h>
+#include <mach/regs-mcu.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <mach/mfp-pxa986-goya.h>
+#include <mach/features.h>
+#include "../common.h"
+#include <linux/power_supply.h>
+#include <mach/Quicklogic_Vxbridge_interface.h>
+
+int dsi_init(struct pxa168fb_info *fbi);
+extern struct pxa168fb_mipi_lcd_driver goya_lcd_driver;
+
+static struct dsi_info dsiinfo = {
+	.id = 1,
+	.lanes = 4,
+	.bpp = 24,
+	.rgb_mode = DSI_LCD_INPUT_DATA_RGB_MODE_888,
+	.burst_mode = DSI_BURST_MODE_SYNC_EVENT,
+	.hbp_en = 1,
+	.hfp_en = 0,
+	.master_mode = 1,
+};
+
+static struct fb_videomode video_modes_emeidkb[] = {
+
+	[0] = {
+		.refresh = 60,
+		.xres = 1024,
+		.yres = 600,
+		.right_margin = 123,	/*HFP*/
+		.left_margin = 100,	/*HBP*/
+		.hsync_len = 120,	/*HWD*/
+		.upper_margin = 10,	/*VBP*/
+		.lower_margin = 13,	/*VFP*/
+		.vsync_len = 10,	/*VWD*/	
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+};
+
+static struct pxa168fb_mach_info mipi_lcd_info = {
+	.id = "GFX Layer",
+	.num_modes = 0,
+	.modes = NULL,
+	.sclk_src = 624000000,	
+	.sclk_div = 0x40001208,
+	.pix_fmt = PIX_FMT_RGBA888,
+	.isr_clear_mask	= LCD_ISR_CLEAR_MASK_PXA168,
+	/*
+	 * don't care about io_pin_allocation_mode and dumb_mode
+	 * since the panel is hard connected with lcd panel path and
+	 * dsi1 output
+	 */
+	.io_pad_ctrl = CFG_CYC_BURST_LEN16,
+	.panel_rgb_reverse_lanes = 0,
+	.invert_composite_blank = 0,
+	.invert_pix_val_ena = 0,
+	.invert_pixclock = 0,
+	.panel_rbswap = 0,
+	.active = 1,
+	.enable_lcd = 1,
+	.spi_gpio_cs = -1,
+	.spi_gpio_reset = -1,
+	.mmap = 1,
+	.phy_type = DSI,
+	.phy_init = dsi_init,
+	.phy_info = &dsiinfo,
+	.lcd_driver = &goya_lcd_driver,
+	.pxa168fb_lcd_power = NULL,
+	.exter_brige_init = vx5b3d_brige_init,
+	.exter_brige_pwr = vx5b3d_power,
+	.width = 154,
+	.height = 90,
+//	.last_dummy_lines = 2,	
+};
+
+static struct pxa168fb_mach_info mipi_lcd_ovly_info = {
+	.id = "Video Layer",
+	.num_modes = 0,
+	.modes = NULL,
+	.pix_fmt = PIX_FMT_RGBA888,
+	.io_pad_ctrl = CFG_CYC_BURST_LEN16,
+	.panel_rgb_reverse_lanes = 0,
+	.invert_composite_blank = 0,
+	.invert_pix_val_ena = 0,
+	.invert_pixclock = 0,
+	.panel_rbswap = 0,
+	.active = 1,
+	.enable_lcd = 1,
+	.spi_gpio_cs = -1,
+	.spi_gpio_reset = -1,
+	.mmap = 0,
+	.last_dummy_lines = 2,	
+};
+
+u32 panel_id = 0;
+static int __init panel_id_setup(char *str)
+{
+	int n;
+	if (!get_option(&str, &n)) {
+		pr_err("get_lcd_id: can't get lcd_id from cmdline\n");
+		return 0;
+	}
+
+	panel_id = n;
+	pr_info("panel_id = 0x%x\n", panel_id);
+	return 1;
+}
+__setup("lcd_id=", panel_id_setup);
+
+int get_panel_id(void)
+{
+	return panel_id;
+}
+
+#define     FHD_PANEL   1
+static int fhd_lcd = 0;
+static int __init fhd_lcd_setup(char *str)
+{
+	int en;
+	if(!get_option(&str, &en))
+		return 0;
+	fhd_lcd = en;
+	return 1;
+}
+
+__setup("fhd_lcd=", fhd_lcd_setup);
+
+int is_fhd_lcd(void)
+{
+	return fhd_lcd;
+}
+
+/*
+ * FIXME:add qhd_lcd to indicate if use qhd or use hvga_vnc
+ */
+#define QHD_PANEL 1
+static int qhd_lcd;
+static int __init qhd_lcd_setup(char *str)
+{
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	qhd_lcd = n;
+	return 1;
+}
+__setup("qhd_lcd=", qhd_lcd_setup);
+
+static int is_qhd_lcd(void)
+{
+	return qhd_lcd;
+}
+
+#define     DSI1_BITCLK(div)			((div)<<8)
+#define     DSI1_BITCLK_DIV_MASK		0x00000F00
+#define     CLK_INT_DIV(div)			(div)
+#define     CLK_INT_DIV_MASK			0x000000FF
+static void calculate_dsi_clk(struct pxa168fb_mach_info *mi)
+{
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct fb_videomode *modes = &mi->modes[0];
+	u32 total_w, total_h, pclk2bclk_rate, byteclk, bitclk,
+	    pclk_div, bitclk_div = 1;
+
+	if (!di)
+		return;
+
+	/*
+	 * When DSI is used to refresh panel, the timing configuration should
+	 * follow the rules below:
+	 * 1.Because Async fifo exists between the pixel clock and byte clock
+	 *   domain, so there is no strict ratio requirement between pix_clk
+	 *   and byte_clk, we just need to meet the following inequation to
+	 *   promise the data supply from LCD controller:
+	 *   pix_clk * (nbytes/pixel) >= byte_clk * lane_num
+	 *   (nbyte/pixel: the real byte in DSI transmission)
+	 *   a)16-bit format n = 2; b) 18-bit packed format n = 18/8 = 9/4;
+	 *   c)18-bit unpacked format  n=3; d)24-bit format  n=3;
+	 *   if lane_num = 1 or 2, we can configure pix_clk/byte_clk = 1:1 >
+	 *   lane_num/nbytes/pixel
+	 *   if lane_num = 3 or 4, we can configure pix_clk/byte_clk = 2:1 >
+	 *   lane_num/nbytes/pixel
+	 * 2.The horizontal sync for LCD is synchronized from DSI,
+	 *    so the refresh rate calculation should base on the
+	 *    configuration of DSI.
+	 *    byte_clk = (h_total * nbytes/pixel) * v_total * fps / lane_num;
+	 */
+	total_w = modes->xres + modes->left_margin +
+		modes->right_margin + modes->hsync_len;
+	total_h = modes->yres + modes->upper_margin +
+		modes->lower_margin + modes->vsync_len;
+
+	pclk2bclk_rate = (di->lanes > 2) ? 2 : 1;
+	byteclk = ((total_w * (di->bpp >> 3)) * total_h *
+			modes->refresh) / di->lanes;
+	bitclk = byteclk << 3;
+
+	/* The minimum of DSI pll is 150MHz */
+	if (bitclk < 150000000)
+		bitclk_div = 150000000 / bitclk + 1;
+
+	//bitclk_div *= 2;
+
+	mi->sclk_src = bitclk * bitclk_div;
+	/*
+	 * mi->sclk_src = pclk * pclk_div;
+	 * pclk / bitclk  = pclk / (8 * byteclk) = pclk2bclk_rate / 8;
+	 * pclk_div / bitclk_div = 8 / pclk2bclk_rate;
+	 */
+	pclk_div = (bitclk_div << 3) / pclk2bclk_rate;
+
+	mi->sclk_div &= ~(DSI1_BITCLK_DIV_MASK | CLK_INT_DIV_MASK);
+	mi->sclk_div |= DSI1_BITCLK(bitclk_div) | CLK_INT_DIV(pclk_div);
+}
+
+static void calculate_lvds_clk(struct pxa168fb_mach_info *mi)
+{
+	struct fb_videomode *modes = &mi->modes[0];
+	u32 total_w, total_h, pclk, div;
+
+	total_w = modes->xres + modes->left_margin +
+		modes->right_margin + modes->hsync_len;
+	total_h = modes->yres + modes->upper_margin +
+		modes->lower_margin + modes->vsync_len;
+
+	pclk = total_w * total_h * modes->refresh;
+
+	/*
+	 * use pll1 by default
+	 * we could set a more flexible clocking options by selecting pll3
+	 */
+
+	/* src clock is 800MHz */
+	div = 800000000 / pclk;
+	if (div * pclk < 800000000)
+		div++;
+	mi->sclk_src = 800000000;
+	mi->sclk_div = 0x20000000 | div;
+
+	pr_debug("\n%s sclk_src %d sclk_div 0x%x\n", __func__,
+			mi->sclk_src, mi->sclk_div);
+}
+
+static void calculate_lcd_sclk(struct pxa168fb_mach_info *mi)
+{
+
+	if (mi->phy_type & (DSI | DSI2DPI))
+		calculate_dsi_clk(mi);
+	else if (mi->phy_type & LVDS)
+		calculate_lvds_clk(mi);
+	else
+		return;
+}
+
+static void dither_config(struct pxa168fb_mach_info *mi)
+{
+	struct dsi_info *dsi;
+	int bpp;
+
+	if (mi->phy_type == LVDS) {
+		struct lvds_info *lvds = (struct lvds_info *)mi->phy_info;
+		bpp = (lvds->fmt == LVDS_FMT_18BIT) ? 18 : 24;
+	} else {
+		dsi = (struct dsi_info *)mi->phy_info;
+		if (!dsi)
+			return;
+		bpp = dsi->bpp;
+	}
+
+	if (bpp < 24) {
+		mi->dither_en = 1;
+		/*
+		 * dither table was related to resolution
+		 * 4x4 table could be select for all cases.
+		 * we can select 4x8 table if xres is much
+		 * bigger than yres
+		 */
+		mi->dither_table = DITHER_TBL_4X4;
+		if (bpp == 18)
+			mi->dither_mode = DITHER_MODE_RGB666;
+		else if (bpp == 16)
+			mi->dither_mode = DITHER_MODE_RGB565;
+		else
+			mi->dither_mode = DITHER_MODE_RGB444;
+	}
+}
+
+static void set_maxfb_size(struct pxa168fb_mach_info *mi,
+		int xalign, int yalign)
+{
+	u32 bits_per_pixel, fb_size, xres_virtual, yres_virtual, buf_count;
+	mi->xres_alignment = xalign;
+	mi->yres_alignment = yalign;
+
+	if (xalign)
+		xres_virtual = ALIGN(mi->modes->xres, xalign);
+	else
+		xres_virtual = mi->modes->xres;
+
+	if (yalign)
+		yres_virtual = ALIGN(mi->modes->yres, yalign);
+	else
+		yres_virtual = mi->modes->yres;
+
+	switch (mi->pix_fmt) {
+	case PIX_FMT_RGBA888:
+	case PIX_FMT_BGRA888:
+	case PIX_FMT_RGB888A:
+	case PIX_FMT_BGR888A:
+	case PIX_FMT_RGB888UNPACK:
+	case PIX_FMT_BGR888UNPACK:
+	case PIX_FMT_YUV422PACK_IRE_90_270:
+		bits_per_pixel = 32;
+		break;
+	case PIX_FMT_RGB565:
+	case PIX_FMT_BGR565:
+	case PIX_FMT_RGB1555:
+	case PIX_FMT_BGR1555:
+	case PIX_FMT_YUYV422PACK:
+	case PIX_FMT_YVU422PACK:
+	case PIX_FMT_YUV422PACK:
+	case PIX_FMT_YUV422PLANAR:
+	case PIX_FMT_YVU422PLANAR:
+		bits_per_pixel = 16;
+		break;
+	case PIX_FMT_RGB888PACK:
+	case PIX_FMT_BGR888PACK:
+		bits_per_pixel = 24;
+		break;
+	case PIX_FMT_PSEUDOCOLOR:
+		bits_per_pixel = 8;
+		break;
+	case PIX_FMT_YUV420PLANAR:
+	case PIX_FMT_YVU420PLANAR:
+	case PIX_FMT_YUV420SEMIPLANAR:
+	case PIX_FMT_YVU420SEMIPLANAR:
+		bits_per_pixel = 12;
+		break;
+	default:
+		bits_per_pixel = 32;
+		break;
+	}
+
+	fb_size = xres_virtual * yres_virtual *  bits_per_pixel >> 3;
+	/* there should be at least double buffer for ping-pang. */
+	buf_count = (mi->mmap > 1) ? (mi->mmap) : 2;
+	mi->max_fb_size = fb_size * buf_count + 4096;
+}
+
+static int lcd_reset(struct pxa168fb_info *fbi)
+{
+#if 0
+	if (gpio_request(GPIO18_LCD_RESET, "lcd reset gpio")) {
+		pr_err("gpio %d request failed\n", GPIO18_LCD_RESET);
+		return -EIO;
+	}
+	gpio_direction_output(GPIO18_LCD_RESET, 0);
+	msleep(15);
+	gpio_direction_output(GPIO18_LCD_RESET, 1);
+	msleep(120);
+
+	gpio_free(GPIO18_LCD_RESET);
+#endif
+	return 0;
+}
+
+int lcd_power(struct pxa168fb_info * fbi, int on)
+{
+	static struct regulator *lcd_vdd_3p3v = NULL;
+
+
+	if ( get_board_id() >= GOYA_R0_4) {
+		if (gpio_request(GOYA_LCD_3P3, "lcd_3p3")) {
+			pr_err("gpio %d request failed\n", GOYA_LCD_3P3);
+			return -EIO;
+		}
+
+		if (gpio_request(LED_BACK_LIGHT_RST, "backligh en")) {
+			pr_err("gpio %d request failed\n", LED_BACK_LIGHT_RST);
+			return -EIO;
+		}
+
+	} else {
+		if (!lcd_vdd_3p3v) {
+			lcd_vdd_3p3v = regulator_get(NULL, "v_lcd_3v3");
+			if (IS_ERR(lcd_vdd_3p3v)) {
+				pr_err("%s regulator get error!\n", __func__);
+				goto regu_lcd_avdd;
+			}
+		}
+	}
+
+	if (on) {
+		if ( get_board_id() >= GOYA_R0_4) {
+			gpio_direction_output(GOYA_LCD_3P3, 1);
+			if (get_panel_id() == HX8282A_PANEL_NONE)
+				gpio_direction_output(LED_BACK_LIGHT_RST, 0);
+			else						
+				gpio_direction_output(LED_BACK_LIGHT_RST, 1);
+		} else {
+			regulator_set_voltage(lcd_vdd_3p3v, 3300000, 3300000);
+			regulator_enable(lcd_vdd_3p3v);
+		}
+	} else {
+		if ( get_board_id() >= GOYA_R0_4) {
+			gpio_direction_output(GOYA_LCD_3P3, 0);
+			gpio_direction_output(LED_BACK_LIGHT_RST, 0);
+		} else {
+			regulator_disable(lcd_vdd_3p3v);
+		}
+	}
+
+	mdelay(5);
+
+	if ( get_board_id() >= GOYA_R0_4) {
+		gpio_free(GOYA_LCD_3P3);
+		gpio_free(LED_BACK_LIGHT_RST);
+	}
+	printk("%s, power %s -\n", __func__, on ? "on" : "off");
+
+	return 0;
+
+regu_lcd_avdd:
+
+	regulator_put(lcd_vdd_3p3v);
+	lcd_vdd_3p3v = NULL;
+
+	return -EIO;
+}
+
+int dsi_init(struct pxa168fb_info *fbi)
+{
+#ifdef CONFIG_PXA688_PHY
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	/*struct pxa168fb_lcd_platform_driver *lcd_pd = mi->lcd_platform_driver;*/
+	struct pxa168fb_mipi_lcd_driver *lcd_driver = mi->lcd_driver;
+
+
+	/*  power the bridge */
+	if (mi->exter_brige_pwr)
+		mi->exter_brige_pwr(fbi,1);
+
+	if (fbi->skip_pw_on) {
+		printk("%s, skip dsi_init\n", __func__);
+		return 0;
+	}
+
+	/*dsi_dphy_exit_ulps_mode(fbi);*/
+	/* reset DSI controller */
+	dsi_reset(fbi, 1);
+	mdelay(1);
+
+	/* disable continuous clock */
+	dsi_cclk_set(fbi, 0);
+
+	/* dsi out of reset */
+	dsi_reset(fbi, 0);
+
+	/* turn on DSI continuous clock */
+	dsi_cclk_set(fbi, 1);
+
+	/* set dphy */
+	dsi_set_dphy(fbi);
+
+	/*lcd power on*/
+	//lcd_power(fbi, 1);
+	set_dsi_low_power_mode(fbi);
+	msleep(32);
+
+	/*  power the bridge */
+	/*
+	if (mi->exter_brige_pwr)
+		mi->exter_brige_pwr(fbi,1);
+	*/
+
+	/* set dsi to dpi conversion chip */
+	if (mi->phy_type & (DSI2DPI | DSI)) {
+		int ret = 0;
+		ret = mi->exter_brige_init(fbi);
+		if (ret < 0)
+			pr_err("exter_brige_init error!\n");
+	}
+	if(lcd_driver) {
+	//	lcd_driver->init(fbi);
+	//	lcd_driver->enable(fbi);
+	}
+	/* put all lanes to LP-11 state  */
+	
+	dsi_lanes_enable(fbi, 0);
+	dsi_lanes_enable(fbi, 1);
+	mdelay(1);
+
+	/* set dsi controller */
+	dsi_set_controller(fbi);
+
+#endif
+	return 0;
+}
+
+void __init emeidkb_add_lcd_mipi(void)
+{
+	unsigned int CSn_NO_COL;
+	struct dsi_info *dsi;
+
+	struct pxa168fb_mach_info *fb = &mipi_lcd_info, *ovly =
+		&mipi_lcd_ovly_info;
+
+	fb->num_modes = ARRAY_SIZE(video_modes_emeidkb);
+	fb->modes = &video_modes_emeidkb[0];
+
+	if (1 == get_recoverymode())
+		fb->mmap = 2;
+	else
+		fb->mmap = 3;
+
+	fb->pix_fmt = PIX_FMT_RGBA888;
+	/*
+	 * align with GPU, xres should be aligned for 16 pixels;
+	 * yres should be aligned for 4 lines
+	 */
+	set_maxfb_size(fb, 16, 4);
+
+	ovly->num_modes = fb->num_modes;
+	ovly->modes = fb->modes;
+	ovly->max_fb_size = fb->max_fb_size;
+
+	fb->phy_type = DSI;
+	fb->phy_info = (void *)&dsiinfo;
+
+	dsi = (struct dsi_info *)fb->phy_info;
+
+	dither_config(fb);
+	/* TODO: in which case we use slave mode? */
+	if (QHD_PANEL != is_qhd_lcd() && FHD_PANEL != is_fhd_lcd())
+		dsi->master_mode = 0; /* dsi use slave mode */
+
+	/* TODO: just code add for new clock and not removed legacy codes */
+	fb->no_legacy_clk = 1;
+	fb->path_clk_name = "mmp_pnpath";
+	fb->phy_clk_name = "mmp_dsi1";
+	CSn_NO_COL = __raw_readl(DMCU_VIRT_BASE + DMCU_SDRAM_CFG0_TYPE1) >> 4;
+	CSn_NO_COL &= 0xF;
+	if (CSn_NO_COL <= 0x2) {
+		/*
+		 *If DDR page size < 4KB,
+		 *select no crossing 1KB boundary check
+		 */
+		fb->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+		ovly->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+	}
+
+	/* add frame buffer drivers */
+	pxa988_add_fb(fb);
+	/* add overlay driver */
+
+	if (!has_feat_video_replace_graphics_dma())
+		pxa988_add_fb_ovly(ovly);
+}
+
+//#ifdef CONFIG_PXA988_DISP_HACK
+void __init emeidkb_add_tv_out(void)
+{
+	struct pxa168fb_mach_info *fb = &mipi_lcd_info, *ovly =
+		&mipi_lcd_ovly_info;
+
+	/* Change id for TV GFX layer to avoid duplicate with panel path */
+	strncpy(fb->id, "TV GFX Layer", 13);
+	fb->num_modes = ARRAY_SIZE(video_modes_emeidkb);
+	fb->modes = video_modes_emeidkb;
+
+	fb->mmap = 0;
+	/*
+	 * align with GPU, xres should be aligned for 16 pixels;
+	 * yres should be aligned for 4 lines
+	 */
+	set_maxfb_size(fb, 16, 4);
+
+	ovly->num_modes = fb->num_modes;
+	ovly->modes = fb->modes;
+	ovly->max_fb_size = fb->max_fb_size;
+
+	fb->phy_init = NULL;
+	fb->phy_type = DSI;
+	fb->phy_info = (void *)&dsiinfo;
+	fb->exter_brige_pwr = NULL;
+	fb->exter_brige_init = NULL;
+	fb->dsi_panel_config = NULL;
+	fb->pxa168fb_lcd_power = NULL;
+
+	dither_config(fb);
+	/*
+	 * Re-calculate lcd clk source and divider
+	 * according to dsi lanes and output format.
+	 */
+#if 0
+	if (QHD_PANEL == is_qhd_lcd()) {
+		calculate_lcd_sclk(fb);
+		fb->phy_info = NULL;
+		fb->phy_type = 0;
+	} else {
+		/* FIXME:rewrite sclk_src, otherwise VNC will
+		 * use 520000000 as sclk_src so that clock source
+		 * will be set 624M */
+		fb->sclk_src = 416000000;
+		/* FIXME: change pixel clk divider for HVGA for fps 60 */
+		fb->sclk_div = 0xE000141B;
+	}
+#endif
+
+	/*
+	 * FIXME:EMEI dkb use display clk1 as clk source,
+	 * which is from PLL1 416MHZ. PLL3 1GHZ will be used
+	 * for cpu core,and can't be DSI clock source specially.
+	 */
+	fb->sclk_div &= 0x0fffffff;
+	fb->sclk_div |= 0x40000000;
+
+	pxa988_add_fb_tv(fb);
+	pxa988_add_fb_tv_ovly(ovly);
+}
diff --git a/arch/arm/mach-mmp/platsmp.c b/arch/arm/mach-mmp/platsmp.c
new file mode 100644
index 00000000..be29cf57
--- /dev/null
+++ b/arch/arm/mach-mmp/platsmp.c
@@ -0,0 +1,262 @@
+/*
+ *  linux/arch/arm/mach-mmp/platsmp.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <asm/cacheflush.h>
+#include <mach/hardware.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <asm/localtimer.h>
+#include <asm/smp_scu.h>
+
+#include <mach/irqs.h>
+#include <mach/addr-map.h>
+#include <mach/regs-apmu.h>
+#include <mach/features.h>
+#include <plat/pxa_trace.h>
+
+#include "platsmp.h"
+
+#ifdef CONFIG_TZ_HYPERVISOR
+#include <asm/smp_plat.h>
+#include "./tzlc/pxa_tzlc.h"
+#endif
+
+#if (defined CONFIG_DEBUG_FS) && ((defined CONFIG_CPU_PXA988)\
+|| (defined CONFIG_CPU_PXA1088))
+#include <mach/pxa988_lowpower.h>
+#include <mach/clock-pxa988.h>
+#endif
+
+/*
+ * control for which core is the next to come out of the secondary
+ * boot "holding pen"
+ */
+volatile int __cpuinitdata pen_release = -1;
+
+/*
+ * Write pen_release in a way that is guaranteed to be visible to all
+ * observers, irrespective of whether they're taking part in coherency
+ * or not.  This is necessary for the hotplug code to work reliably.
+ */
+static void __cpuinit write_pen_release(int val)
+{
+	pen_release = val;
+	smp_wmb();
+	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+}
+#ifdef CONFIG_HAVE_ARM_SCU
+void notrace __iomem *pxa_scu_base_addr(void)
+{
+	return (void __iomem *)SCU_VIRT_BASE;
+}
+
+static inline unsigned int get_core_count(void)
+{
+	void __iomem *scu_base = pxa_scu_base_addr();
+	if (scu_base)
+		return scu_get_core_count(scu_base);
+	return 1;
+}
+#else
+static inline unsigned int get_core_count(void)
+{
+#ifdef CONFIG_CPU_CA7MP
+	unsigned int val;
+	/* Read L2 control register */
+	asm volatile("mrc p15, 1, %0, c9, c0, 2" : "=r"(val));
+	/* core count : [25:24] of L2 register + 1 */
+	val = ((val>>24) & 3) + 1;
+	return val;
+#else
+	return 1;
+#endif
+}
+#endif
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	trace_pxa_core_hotplug(HOTPLUG_EXIT, cpu);
+#if (defined CONFIG_DEBUG_FS) && ((defined CONFIG_CPU_PXA988)\
+|| (defined CONFIG_CPU_PXA1088))
+	pxa988_cpu_dcstat_event(cpu, CPU_IDLE_EXIT, PXA988_MAX_LPM_INDEX);
+#endif
+
+	pxa_secondary_init(cpu);
+
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	gic_secondary_init(0);
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	write_pen_release(-1);
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * Avoid timer calibration on slave cpus. Use the value calibrated
+	 * on master cpu. Referenced from tegra3
+	 */
+	preset_lpj = loops_per_jiffy;
+
+	/*
+	 * set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+
+	spin_lock(&boot_lock);
+	/*
+	 * The secondary processor is waiting to be released from
+	 * the holding pen - release it, then wait for it to flag
+	 * that it has been released by resetting pen_release.
+	 *
+	 * Note that "pen_release" is the hardware CPU ID, whereas
+	 * "cpu" is Linux's internal ID.
+	 */
+	write_pen_release(cpu);
+
+	/* reset the cpu, let it branch to the kernel entry */
+	pxa_cpu_reset(cpu);
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+void pxa988_gic_raise_softirq(const struct cpumask *mask, unsigned int irq)
+{
+	unsigned int val = 0;
+	int targ_cpu;
+
+#ifdef CONFIG_TZ_HYPERVISOR
+	int cpu;
+	unsigned long map = 0;
+	tzlc_cmd_desc cmd_desc;
+	tzlc_handle tzlc_handle;
+
+	/* Convert our logical CPU mask into a physical one. */
+	for_each_cpu(cpu, mask)
+		map |= 1 << cpu_logical_map(cpu);
+
+	/*
+	 * Ensure that stores to Normal memory are visible to the
+	 * other CPUs before issuing the IPI.
+	 */
+	dsb();
+
+	tzlc_handle = pxa_tzlc_create_handle();
+
+	cmd_desc.op = TZLC_CMD_TRIGER_SGI;
+	cmd_desc.args[0] = map << 16 | irq;
+	pxa_tzlc_cmd_op(tzlc_handle, &cmd_desc);
+
+	pxa_tzlc_destroy_handle(tzlc_handle);
+#else
+	gic_raise_softirq(mask, irq);
+#endif
+
+	if (has_feat_ipc_wakeup_core()) {
+		#define IPCC_VIRT_BASE	(APB_VIRT_BASE + 0x1D800)
+		/*
+		* "Trigger IPC interrupt to wake cores when sending IPI"
+		* Trigger IPC GP_INT to generate IRQ19 as wake up source inside
+		* the ICU to wake up the cores when sending IPI.
+		*/
+		__raw_writel(0x400, IPCC_VIRT_BASE + 0x8); /* IPC_ISRW */
+	} else {
+		/*
+		 * Set the wakeup bits to make sure the core(s) can respond to
+		 * the IPI interrupt.
+		 * If the target core(s) IS alive, this operation is ignored by
+		 * the APMU. After the core wakes up, these corresponding bits
+		 * are clearly automatically by PMU hardware.
+		 */
+		for_each_cpu(targ_cpu, mask) {
+			BUG_ON(targ_cpu >= CONFIG_NR_CPUS);
+			val |= APMU_WAKEUP_CORE(targ_cpu);
+		}
+		__raw_writel(val, APMU_COREn_WAKEUP_CTL(smp_processor_id()));
+	}
+}
+#endif
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	unsigned int i, ncores = get_core_count();
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	set_smp_cross_call(pxa988_gic_raise_softirq);
+#else
+	set_smp_cross_call(gic_raise_softirq);
+#endif
+}
+
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+{
+	int i;
+
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	for (i = 0; i < max_cpus; i++)
+		set_cpu_present(i, true);
+#ifdef CONFIG_HAVE_ARM_SCU
+	scu_enable(pxa_scu_base_addr());
+#endif
+
+	pxa_cpu_reset_handler_init();
+}
diff --git a/arch/arm/mach-mmp/platsmp.h b/arch/arm/mach-mmp/platsmp.h
new file mode 100644
index 00000000..3a0ebe63
--- /dev/null
+++ b/arch/arm/mach-mmp/platsmp.h
@@ -0,0 +1,20 @@
+/*
+ * linux/arch/arm/mach-mmp/platsmp.h
+ *
+ * Author:	Neil Zhang <zhangwm@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __PLATSMP_H__
+#define __PLATSMP_H__
+
+extern void pxa_cpu_reset(u32 cpu);
+extern void __init pxa_cpu_reset_handler_init(void);
+extern void __cpuinit pxa_secondary_init(u32 cpu);
+
+#endif /* __PLATSMP_H__ */
diff --git a/arch/arm/mach-mmp/pm-pxa988.c b/arch/arm/mach-mmp/pm-pxa988.c
new file mode 100644
index 00000000..4103a80e
--- /dev/null
+++ b/arch/arm/mach-mmp/pm-pxa988.c
@@ -0,0 +1,467 @@
+/*
+ * linux/arch/arm/mach-mmp/pm-pxa988.c
+ *
+ * Author:      Hong Feng <hongfeng@marvell.com>
+ * Copyright:   (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/cpu_pm.h>
+#include <linux/suspend.h>
+#include <linux/clk.h>
+#include <linux/wakelock.h>
+#include <linux/cpu.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/88pm80x.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/power/fake-sysoff.h>
+#include <linux/pm_qos.h>
+#include <asm/suspend.h>
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/smp_scu.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/hardware/gic.h>
+#include <mach/regs-apmu.h>
+#include <mach/regs-mpmu.h>
+#include <mach/regs-icu.h>
+#include <mach/pxa988_lowpower.h>
+#include <mach/regs-ciu.h>
+#include <mach/irqs.h>
+#include <mach/cputype.h>
+#include "common.h"
+#include <mach/gpio-edge.h>
+#ifdef CONFIG_SEC_GPIO_DVS
+#include <linux/secgpio_dvs.h>
+#endif
+
+static struct wakeup_source system_wakeup;
+static int pmic_wakeup_detect;
+/*
+ *As history said, the detect_wakeup_status
+ *can be used by other modules.
+ */
+uint32_t detect_wakeup_status;
+EXPORT_SYMBOL(detect_wakeup_status);
+
+u32 sav_wucrs, sav_wucrm;
+
+void gpio_edge_wakeup_enable(void)
+{
+	uint32_t awucrm = 0, apcr = 0;
+	/* already get pmu_lock in LPM code */
+	awucrm = __raw_readl(MPMU_AWUCRM);
+	apcr = __raw_readl(MPMU_APCR);
+	__raw_writel(awucrm | PMUM_WAKEUP2, MPMU_AWUCRM);
+	__raw_writel(apcr & ~PMUM_SLPWP2, MPMU_APCR);
+}
+
+void gpio_edge_wakeup_disable(void)
+{
+	uint32_t awucrm = 0, apcr = 0;
+	/* already get pmu_lock in LPM code */
+	awucrm = __raw_readl(MPMU_AWUCRM);
+	apcr = __raw_readl(MPMU_APCR);
+	__raw_writel(awucrm & ~PMUM_WAKEUP2, MPMU_AWUCRM);
+	__raw_writel(apcr | PMUM_SLPWP2, MPMU_APCR);
+}
+
+int pxa988_set_wake(struct irq_data *data, unsigned int on)
+{
+	int irq = data->irq;
+	struct irq_desc *desc = irq_to_desc(data->irq);
+	uint32_t awucrm = 0, apcr = 0;
+
+	if (on) {
+		if (desc->action)
+			desc->action->flags |= IRQF_NO_SUSPEND;
+	} else {
+		if (desc->action)
+			desc->action->flags &= ~IRQF_NO_SUSPEND;
+	}
+
+	/* setting wakeup sources */
+	switch (irq) {
+	/* wakeup line 2 */
+	case IRQ_PXA988_GPIO_AP:
+		awucrm = PMUM_WAKEUP2;
+		apcr |= PMUM_SLPWP2;
+		break;
+	/* wakeup line 3 */
+	case IRQ_PXA988_KEYPAD:
+		awucrm = PMUM_WAKEUP3 | PMUM_KEYPRESS | PMUM_TRACKBALL |
+				PMUM_NEWROTARY;
+		apcr |= PMUM_SLPWP3;
+		break;
+	/* wakeup line 4 */
+	case IRQ_PXA988_AP_TIMER1:
+		awucrm = PMUM_WAKEUP4 | PMUM_AP1_TIMER_1;
+		apcr |= PMUM_SLPWP4;
+		break;
+	case IRQ_PXA988_AP_TIMER2_3:
+		awucrm = PMUM_WAKEUP4 | PMUM_AP1_TIMER_2 |
+				PMUM_AP1_TIMER_3;
+		apcr |= PMUM_SLPWP4;
+		break;
+	case IRQ_PXA988_AP2_TIMER1:
+		awucrm = PMUM_WAKEUP4 | PMUM_AP2_TIMER_1;
+		apcr |= PMUM_SLPWP4;
+		break;
+	case IRQ_PXA988_AP2_TIMER2_3:
+		awucrm = PMUM_WAKEUP4 | PMUM_AP2_TIMER_2 |
+				PMUM_AP2_TIMER_3;
+		apcr |= PMUM_SLPWP4;
+		break;
+	case IRQ_PXA988_RTC_ALARM:
+		awucrm = PMUM_WAKEUP4 | PMUM_RTC_ALARM;
+		apcr |= PMUM_SLPWP4;
+		break;
+	/* wakeup line 5 */
+	case IRQ_PXA988_USB1:
+		awucrm = PMUM_WAKEUP5;
+		apcr |= PMUM_SLPWP5;
+		break;
+	/* wakeup line 6 */
+	case IRQ_PXA988_MMC:
+		awucrm = PMUM_WAKEUP6 | PMUM_SDH_23 | PMUM_SQU_SDH1;
+		apcr |= PMUM_SLPWP6;
+		break;
+	case IRQ_PXA988_HIFI_DMA:
+		awucrm = PMUM_WAKEUP6 | PMUM_SQU_SDH1;
+		apcr |= PMUM_SLPWP6;
+		break;
+	/* wakeup line 7 */
+	case IRQ_PXA988_PMIC:
+		awucrm = PMUM_WAKEUP7;
+		apcr |= PMUM_SLPWP7;
+		break;
+	default:
+		if (irq >= IRQ_GPIO_START && irq < IRQ_BOARD_START) {
+			awucrm = PMUM_WAKEUP2;
+			apcr |= PMUM_SLPWP2;
+		} else
+			pr_err("Error: no defined wake up source irq: %d\n",
+					irq);
+	}
+	/* add lock, MPMU_APCR may access through other cpu on SMP system */
+	pmu_register_lock();
+	if (on) {
+		if (awucrm) {
+			awucrm |= __raw_readl(MPMU_AWUCRM);
+			__raw_writel(awucrm, MPMU_AWUCRM);
+		}
+		if (apcr) {
+			apcr = ~apcr & __raw_readl(MPMU_APCR);
+			__raw_writel(apcr, MPMU_APCR);
+		}
+	} else {
+		if (awucrm) {
+			awucrm = ~awucrm & __raw_readl(MPMU_AWUCRM);
+			__raw_writel(awucrm, MPMU_AWUCRM);
+		}
+		if (apcr) {
+			apcr |= __raw_readl(MPMU_APCR);
+			__raw_writel(apcr, MPMU_APCR);
+		}
+	}
+	pmu_register_unlock();
+	return 0;
+}
+
+static int pxa988_pm_valid(suspend_state_t state)
+{
+	return ((state == PM_SUSPEND_STANDBY) || (state == PM_SUSPEND_MEM));
+}
+
+/* Called after devices suspend, before noirq devices suspend */
+static int pxa988_pm_prepare(void)
+{
+	return 0;
+}
+
+/* Clear SDH wakeup to avoid IRQ storm */
+static int pxa988_clr_sdh_wakeup(void)
+{
+	uint32_t val;
+	uint32_t mask = APMU_PXA988_SD1_WAKE_CLR | APMU_PXA988_SD2_WAKE_CLR
+					| APMU_PXA988_SD3_WAKE_CLR;
+
+	val = __raw_readl(APMU_WAKE_CLR);
+	__raw_writel(val | mask, APMU_WAKE_CLR);
+
+	return 0;
+}
+
+static int pxa988_pm_check_constraint(void)
+{
+	int ret = 0;
+	struct pm_qos_object *idle_qos;
+	struct list_head *list;
+	struct plist_node *node;
+	struct pm_qos_request *req;
+
+	idle_qos = pm_qos_array[PM_QOS_CPUIDLE_BLOCK];
+	list = &idle_qos->constraints->list.node_list;
+
+	/* local irq disabled here, not need any lock */
+	list_for_each_entry(node, list, node_list) {
+		req = container_of(node, struct pm_qos_request, node);
+		/*
+		 * add warn and return error if:
+		 * 1. any lpm constraint hold
+		 * 2. constraint name didn't start with "uart" --- > uart rx pad
+		 *    or rxuart --- > rxUART1,2,3...
+		 */
+		if ((node->prio != PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE) &&
+				strncasecmp(req->name, "uart", 4) &&
+				strncasecmp(req->name, "rxuart", 6)) {
+			WARN(1, KERN_ERR"%s lpm constraint before suspend",
+					req->name);
+			ret = -EBUSY;
+		}
+	}
+
+	return ret;
+}
+
+#define WAKEUP_EVENTS_MASK (0xFF)
+static int check_gpio_wakeup_stat(char *buf, int len, size_t size)
+{
+	int i;
+
+	i = find_first_bit(gpio_wp_stat, gpio_edge_gpio_num);
+
+	if (i >= gpio_edge_gpio_num)
+		return -EINVAL;
+	len += snprintf(buf + len, size - len, "GPIO");
+	while (i < gpio_edge_gpio_num) {
+		len += snprintf(buf + len, size - len, "-%d", i);
+		i = find_next_bit(gpio_wp_stat, gpio_edge_gpio_num, i + 1);
+	}
+	len += snprintf(buf + len, size - len, ",");
+	for (i = 0; i < gpio_edge_gpio_num / 32; i++)
+		gpio_wp_stat[i] = 0;
+	return len;
+}
+
+static u32 wakeup_source_check(void)
+{
+	char *buf;
+	size_t size = PAGE_SIZE - 1;
+	int len = 0;
+	u32 real_wus = sav_wucrs & sav_wucrm;
+
+	pr_info("After SUSPEND");
+	pr_info("General wakeup source status:0x%x\n", sav_wucrs);
+	pr_info("General wakeup source mask:0x%x\n", sav_wucrm);
+
+	buf = (char *)__get_free_pages(GFP_NOIO, 0);
+	if (!buf) {
+		pr_err("memory alloc for wakeup check is failed!!\n");
+		return sav_wucrs;
+	}
+	if (!(real_wus & WAKEUP_EVENTS_MASK)) {
+		pr_err("System is Woken up by Unexpected Events!\n");
+		free_pages((unsigned long)buf, 0);
+		return sav_wucrs;
+	}
+
+	len = snprintf(buf, size, "System is woken up by:");
+	if (real_wus & (PMUM_WAKEUP0))
+		len += snprintf(buf + len, size - len, "GSM,");
+	if (real_wus & (PMUM_WAKEUP1))
+		len += snprintf(buf + len, size - len, "3G Base band,");
+	if (real_wus & PMUM_WAKEUP2) {
+		int ret = check_gpio_wakeup_stat(buf, len, size);
+		if (ret < 0)
+			pr_info("GPIO wakeup check failed!!!\n");
+		else
+			len = ret;
+	}
+	if (real_wus & PMUM_WAKEUP3) {
+		if (real_wus & PMUM_KEYPRESS)
+			len += snprintf(buf + len, size - len, "KeyPress,");
+		if (real_wus & PMUM_TRACKBALL)
+			len += snprintf(buf + len, size - len, "TRACKBALL,");
+		if (real_wus & PMUM_NEWROTARY)
+			len += snprintf(buf + len, size - len, "NEWROTARY,");
+	}
+	if (real_wus & PMUM_WAKEUP4) {
+		if (real_wus & PMUM_WDT)
+			len += snprintf(buf + len, size - len, "WDT,");
+		if (real_wus & PMUM_RTC_ALARM)
+			len += snprintf(buf + len, size - len, "RTC_ALARM,");
+		if (real_wus & PMUM_CP_TIMER_3)
+			len += snprintf(buf + len, size - len, "CP_TIMER_3,");
+		if (real_wus & PMUM_CP_TIMER_2)
+			len += snprintf(buf + len, size - len, "CP_TIMER_2,");
+		if (real_wus & PMUM_CP_TIMER_1)
+			len += snprintf(buf + len, size - len, "CP_TIMER_1,");
+		if (real_wus & PMUM_AP2_TIMER_3)
+			len += snprintf(buf + len, size - len, "AP2_TIMER_3,");
+		if (real_wus & PMUM_AP2_TIMER_2)
+			len += snprintf(buf + len, size - len, "AP2_TIMER_2,");
+		if (real_wus & PMUM_AP2_TIMER_1)
+			len += snprintf(buf + len, size - len, "AP2_TIMER_1,");
+		if (real_wus & PMUM_AP1_TIMER_3)
+			len += snprintf(buf + len, size - len, "AP1_TIMER_3,");
+		if (real_wus & PMUM_AP1_TIMER_2)
+			len += snprintf(buf + len, size - len, "AP1_TIMER_2,");
+		if (real_wus & PMUM_AP1_TIMER_1)
+			len += snprintf(buf + len, size - len, "AP1_TIMER_1,");
+	}
+	if (real_wus & PMUM_WAKEUP5)
+		len += snprintf(buf + len, size - len, "USB,");
+	if (real_wus & PMUM_WAKEUP6) {
+		if (real_wus & PMUM_SQU_SDH1)
+			len += snprintf(buf + len, size - len, "SQU_SDH1,");
+		if (real_wus & PMUM_SDH_23)
+			len += snprintf(buf + len, size - len, "SDH_23,");
+	}
+	if (real_wus & PMUM_WAKEUP7) {
+		len += snprintf(buf + len, size - len, "PMIC,");
+		pmic_wakeup_detect = 1;
+	}
+
+	snprintf(buf + (len - 1), size - len + 1, "\n");
+	pr_info("%s", buf);
+
+	free_pages((unsigned long)buf, 0);
+
+	return sav_wucrs;
+}
+#if defined(CONFIG_SEC_GPIO_DVS)&& defined(CONFIG_MACH_BAFFINQ)
+extern void  dvs_setting_sleep(void);
+#endif
+static int pxa988_pm_enter(suspend_state_t state)
+{
+	uint32_t reg = 0;
+
+#ifdef CONFIG_SEC_GPIO_DVS
+	/************************ Caution !!! ****************************/
+	/* This function must be located in appropriate SLEEP position
+	 * in accordance with the specification of each BB vendor.
+	 */
+	/************************ Caution !!! ****************************/
+#if defined(CONFIG_SEC_GPIO_DVS)&& defined(CONFIG_MACH_BAFFINQ)
+	dvs_setting_sleep();
+#endif
+	gpio_dvs_check_sleepgpio();
+#endif
+
+	/*
+	 * pmic thread not completed, exit;
+	 * otherwise system can't be waked up
+	 */
+	reg = __raw_readl(ICU_INT_CONF(IRQ_PXA988_PMIC - IRQ_PXA988_START));
+	if ((reg & 0x3) == 0) {
+		pr_info("pmic thread not completed reg(0x%x)\n", reg);
+		return -EAGAIN;
+	}
+
+	/*
+	 * check if there is any constraint, it's not allowed
+	 * Now, we only give out WARN for convenience, like GC
+	 * LPM disable case, GC constraint is always hold
+	 */
+	pxa988_pm_check_constraint();
+
+#ifdef CONFIG_FAKE_SYSTEMOFF
+	/* In fake system off mode, cancel timeout work here*/
+	if (fake_sysoff_status_query()) {
+		fake_sysoff_set_block_onkey(0);
+		fake_sysoff_work_cancel();
+	}
+#endif
+
+	pr_info("========wake up events status =========\n");
+	pr_info("BEFORE SUSPEND AWUCRS:0x%x\n", __raw_readl(MPMU_AWUCRS));
+	pxa988_pm_suspend(0, PXA988_LPM_D2_UDR);
+
+	detect_wakeup_status = wakeup_source_check();
+
+	if (cpu_is_pxa1088()) {
+		pr_info("INT0:0x%x INT1:0x%x, INT2:0x%x\n", \
+				__raw_readl(ICU_INT_STATUS_0),
+				__raw_readl(ICU_INT_STATUS_1),
+				__raw_readl(ICU_INT_STATUS_2));
+	} else
+		pr_info("INT0:0x%x INT1:0x%x\n", \
+				__raw_readl(ICU_INT_STATUS_0),
+				__raw_readl(ICU_INT_STATUS_1));
+	pr_info("=======================================\n");
+
+	/*
+	* Note: In case that SDH wake up would happen together
+	* with PMIC or others, so check awucrs separately
+	*/
+	if (detect_wakeup_status & (PMUM_SQU_SDH1|PMUM_SDH_23)) {
+		pxa988_clr_sdh_wakeup();
+		pr_info(" Clear the WakeUp Event for SDH\n");
+	}
+
+	return 0;
+}
+
+/* Called after noirq devices resume, before devices resume */
+static void pxa988_pm_finish(void)
+{
+}
+
+static void pxa988_pm_wake(void)
+{
+	if (pmic_wakeup_detect) {
+		__pm_wakeup_event(&system_wakeup, 5 * 1000);
+		pmic_wakeup_detect = 0;
+	}
+}
+
+static const struct platform_suspend_ops pxa988_pm_ops = {
+	.valid          = pxa988_pm_valid,
+	.prepare        = pxa988_pm_prepare,
+	.enter          = pxa988_pm_enter,
+	.finish         = pxa988_pm_finish,
+	.wake           = pxa988_pm_wake,
+};
+
+static int __init pxa988_pm_init(void)
+{
+	u32 awucrm = 0;
+
+	suspend_set_ops(&pxa988_pm_ops);
+
+	wakeup_source_init(&system_wakeup,
+			"system_wakeup_detect");
+
+	/*
+	 * These two bits are used to solve the corner case that
+	 * 1.	APMU enters sleep mode.
+	 * 2.	MPMU is activated but not finished.
+	 * 3.	An interrupt comes
+	 * 4.	The interrupt is not a wake up source
+	 * Keeping these two bits can assure it aborts from
+	 * the intermediate state.
+	 *
+	 * Actually for suspend it won't happen since we disable
+	 * non-wake up interrupts before WFI.
+	 * For idle replacement we will encounter such issue
+	 * since not all interrupts are wake up source.
+	 * */
+	awucrm |= PMUM_AP_ASYNC_INT;
+	awucrm |= PMUM_AP_FULL_IDLE;
+	__raw_writel(awucrm, MPMU_AWUCRM);
+	/* hook wakeup callback */
+	gic_arch_extn.irq_set_wake = pxa988_set_wake;
+
+	return 0;
+}
+late_initcall(pxa988_pm_init);
diff --git a/arch/arm/mach-mmp/pmu.c b/arch/arm/mach-mmp/pmu.c
new file mode 100644
index 00000000..bc9c70d2
--- /dev/null
+++ b/arch/arm/mach-mmp/pmu.c
@@ -0,0 +1,143 @@
+/*
+ * PMU IRQ registration for MMP PMU families.
+ *
+ * (C) Copyright 2011 Marvell International Ltd.
+ * All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <asm/pmu.h>
+#include <asm/io.h>
+#include <mach/addr-map.h>
+#include <mach/cputype.h>
+#include <mach/irqs.h>
+#include <mach/regs-ciu.h>
+#include <mach/features.h>
+#include <mach/regs-coresight.h>
+
+static struct platform_device pmu_device = {
+	.name		= "arm-pmu",
+	.id		= ARM_PMU_DEVICE_CPU,
+};
+
+static struct resource pmu_resource_pxa[] = {
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	/* core0 */
+	{
+		.start	= IRQ_PXA988_CORESIGHT,
+		.end	= IRQ_PXA988_CORESIGHT,
+		.flags	= IORESOURCE_IRQ,
+	},
+	/* core1*/
+	{
+		.start	= IRQ_PXA988_CORESIGHT2,
+		.end	= IRQ_PXA988_CORESIGHT2,
+		.flags	= IORESOURCE_IRQ,
+	},
+#if defined(CONFIG_CPU_PXA1088)
+	/* core2 */
+	{
+		.start	= IRQ_PXA1088_CORESIGHT3,
+		.end	= IRQ_PXA1088_CORESIGHT3,
+		.flags	= IORESOURCE_IRQ,
+	},
+	/* core3 */
+	{
+		.start	= IRQ_PXA1088_CORESIGHT4,
+		.end	= IRQ_PXA1088_CORESIGHT4,
+		.flags	= IORESOURCE_IRQ,
+	},
+#endif
+#endif
+};
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+static void __init pxa988_enable_external_agent(void __iomem *addr)
+{
+	u32 tmp;
+
+	tmp = readl_relaxed(addr);
+	tmp |= 0x100000;
+	writel_relaxed(tmp, addr);
+}
+
+static void __init pxa988_cti_enable(u32 cpu)
+{
+	void __iomem *cti_base = CTI_CORE0_VIRT_BASE + 0x1000 * cpu;
+	u32 tmp;
+
+	/* Unlock CTI */
+	writel_relaxed(0xC5ACCE55, cti_base + CTI_LOCK_OFFSET);
+
+	/*
+	 * Enables a cross trigger event to the corresponding channel.
+	 */
+	tmp = readl_relaxed(cti_base + CTI_EN_IN1_OFFSET);
+	tmp &= ~CTI_EN_MASK;
+	tmp |= 0x1 << cpu;
+	writel_relaxed(tmp, cti_base + CTI_EN_IN1_OFFSET);
+
+	tmp = readl_relaxed(cti_base + CTI_EN_OUT6_OFFSET);
+	tmp &= ~CTI_EN_MASK;
+	tmp |= 0x1 << cpu;
+	writel_relaxed(tmp, cti_base + CTI_EN_OUT6_OFFSET);
+
+	/* Enable CTI */
+	writel_relaxed(0x1, cti_base + CTI_CTRL_OFFSET);
+}
+
+static void __init pxa988_cti_init(void)
+{
+	int cpu;
+
+	/* if enable TrustZone, move core config to TZSW. */
+#ifndef CONFIG_TZ_HYPERVISOR
+	/* enable access CTI registers for core */
+	pxa988_enable_external_agent(CIU_CPU_CORE0_CONF);
+	pxa988_enable_external_agent(CIU_CPU_CORE1_CONF);
+#if defined(CONFIG_CPU_PXA1088)
+	pxa988_enable_external_agent(CIU_CPU_CORE2_CONF);
+	pxa988_enable_external_agent(CIU_CPU_CORE3_CONF);
+#endif
+#endif /* CONFIG_TZ_HYPERVISOR */
+
+	for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++)
+		pxa988_cti_enable(cpu);
+}
+
+void pxa988_ack_ctiint(void)
+{
+	writel_relaxed(0x40, CTI_REG(CTI_INTACK_OFFSET));
+}
+EXPORT_SYMBOL(pxa988_ack_ctiint);
+
+void pxa_pmu_ack(void)
+{
+	pxa988_ack_ctiint();
+}
+#endif
+
+static int __init pxa_pmu_init(void)
+{
+	if (has_feat_pmu_support()) {
+		pmu_device.resource = pmu_resource_pxa;
+		pmu_device.num_resources = ARRAY_SIZE(pmu_resource_pxa);
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+		pxa988_cti_init();
+#endif
+		platform_device_register(&pmu_device);
+	} else {
+		printk(KERN_WARNING "unsupported Soc for PMU");
+		return -EIO;
+	}
+	return 0;
+}
+arch_initcall(pxa_pmu_init);
diff --git a/arch/arm/mach-mmp/pxa988.c b/arch/arm/mach-mmp/pxa988.c
new file mode 100644
index 00000000..fabcf310
--- /dev/null
+++ b/arch/arm/mach-mmp/pxa988.c
@@ -0,0 +1,1572 @@
+/*
+ * linux/arch/arm/mach-mmp/pxa988.c
+ *
+ * code name PXA988
+ *
+ * Copyright (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_data/mmp_audio.h>
+#include <linux/notifier.h>
+#include <linux/memblock.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/ion.h>
+#include <linux/dma-mapping.h>
+#include <linux/persistent_ram.h>
+
+#include <asm/smp_twd.h>
+#include <asm/mach/time.h>
+#include <asm/hardware/gic.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/cacheflush.h>
+
+#include <mach/addr-map.h>
+#include <mach/regs-ciu.h>
+#include <mach/regs-apbc.h>
+#include <mach/regs-apmu.h>
+#include <mach/regs-mpmu.h>
+#include <mach/cputype.h>
+#include <mach/irqs.h>
+#include <mach/gpio.h>
+#include <mach/gpio-edge.h>
+#include <mach/dma.h>
+#include <mach/devices.h>
+#include <mach/pxa988.h>
+#include <mach/regs-timers.h>
+#include <mach/regs-usb.h>
+#include <mach/soc_coda7542.h>
+#include <mach/isp_dev.h>
+#include <mach/uio_isp.h>
+#include <mach/reset-pxa988.h>
+#include <mach/pxa168fb.h>
+#include <plat/mfp.h>
+#include <mach/gpu_mem.h>
+
+#ifdef CONFIG_ARM_ARCH_TIMER
+#include <asm/arch_timer.h>
+#endif /* #ifdef CONFIG_ARM_ARCH_TIMER */
+
+#include "common.h"
+
+#include <linux/regdump_ops.h>
+
+#define MFPR_VIRT_BASE	(APB_VIRT_BASE + 0x1e000)
+#define RIPC3_VIRT_BASE	(APB_VIRT_BASE + 0x3D000)
+#define GPIOE_VIRT_BASE	(APB_VIRT_BASE + 0x19800)
+#define RIPC3_STATUS	(RIPC3_VIRT_BASE + 0x300)
+#define APMU_PHY_BASE  0xd4282800
+#define GIC_DIST_PHYS_BASE  (PERI_PHYS_BASE + 0x1000)
+
+#ifdef CONFIG_MACH_WILCOX_CMCC
+#define BOARD_ID_CMCC_REV05 (0x7)
+#endif
+
+static struct mfp_addr_map pxa988_addr_map[] __initdata = {
+
+	MFP_ADDR_X(GPIO0, GPIO54, 0xdc),
+	MFP_ADDR_X(GPIO67, GPIO98, 0x1b8),
+	MFP_ADDR_X(GPIO100, GPIO109, 0x238),
+	MFP_ADDR_X(GPIO110, GPIO116, 0x298),
+
+	MFP_ADDR(DF_IO0, 0x40),
+	MFP_ADDR(DF_IO1, 0x3c),
+	MFP_ADDR(DF_IO2, 0x38),
+	MFP_ADDR(DF_IO3, 0x34),
+	MFP_ADDR(DF_IO4, 0x30),
+	MFP_ADDR(DF_IO5, 0x2c),
+	MFP_ADDR(DF_IO6, 0x28),
+	MFP_ADDR(DF_IO7, 0x24),
+	MFP_ADDR(DF_IO8, 0x20),
+	MFP_ADDR(DF_IO9, 0x1c),
+	MFP_ADDR(DF_IO10, 0x18),
+	MFP_ADDR(DF_IO11, 0x14),
+	MFP_ADDR(DF_IO12, 0x10),
+	MFP_ADDR(DF_IO13, 0xc),
+	MFP_ADDR(DF_IO14, 0x8),
+	MFP_ADDR(DF_IO15, 0x4),
+
+	MFP_ADDR(DF_nCS0_SM_nCS2, 0x44),
+	MFP_ADDR(DF_nCS1_SM_nCS3, 0x48),
+	MFP_ADDR(SM_nCS0, 0x4c),
+	MFP_ADDR(SM_nCS1, 0x50),
+	MFP_ADDR(DF_WEn, 0x54),
+	MFP_ADDR(DF_REn, 0x58),
+	MFP_ADDR(DF_CLE_SM_OEn, 0x5c),
+	MFP_ADDR(DF_ALE_SM_WEn, 0x60),
+	MFP_ADDR(SM_SCLK, 0x64),
+	MFP_ADDR(DF_RDY0, 0x68),
+	MFP_ADDR(SM_BE0, 0x6c),
+	MFP_ADDR(SM_BE1, 0x70),
+	MFP_ADDR(SM_ADV, 0x74),
+	MFP_ADDR(DF_RDY1, 0x78),
+	MFP_ADDR(SM_ADVMUX, 0x7c),
+	MFP_ADDR(SM_RDY, 0x80),
+	MFP_ADDR(ANT_SW4, 0x26c),
+
+	MFP_ADDR_X(MMC1_DAT7, MMC1_WP, 0x84),
+
+	MFP_ADDR(GPIO124, 0xd0),
+	MFP_ADDR(VCXO_REQ, 0xd4),       
+	MFP_ADDR(VCXO_OUT, 0xd8),
+
+	MFP_ADDR(CLK_REQ, 0xcc),
+#ifdef CONFIG_SEC_GPIO_DVS
+	MFP_ADDR(PRI_TDI, 0xB4),
+	MFP_ADDR(PRI_TMS, 0xB8),
+	MFP_ADDR(PRI_TCK, 0xBC),
+	MFP_ADDR(PRI_TDO, 0xC0),
+	MFP_ADDR(SLAVE_RESET_OUT, 0xC8),
+#endif
+	MFP_ADDR_END,
+};
+
+#ifdef CONFIG_REGDUMP
+static struct regdump_ops pmua_regdump_ops = {
+	.dev_name = "PXA1088-PMUA",
+};
+
+static struct regdump_region pmua_dump_region[] = {
+	{"PMUA_CC_CP",			0x000, 4, regdump_cond_true},
+	{"PMUA_CC_AP",			0x004, 4, regdump_cond_true},
+	{"PMUA_DM_CC_CP",		0x008, 4, regdump_cond_true},
+	{"PMUA_DM_CC_AP",		0x00c, 4, regdump_cond_true},
+	{"PMUA_FC_TIMER",		0x010, 4, regdump_cond_true},
+	{"PMUA_CP_IDLE_CFG",		0x014, 4, regdump_cond_true},
+	{"PMUA_AP_IDLE_CFG",		0x018, 4, regdump_cond_true},
+	{"PMUA_SQU_CLK_GATE_CTRL",		0x01c, 4, regdump_cond_true},
+#ifdef CONFIG_CPU_PXA1088
+	{"PMUA_IRE_CLK_GATE_CTRL",		0x020, 4, regdump_cond_true},
+#endif
+	{"PMUA_CCIC_CLK_GATE_CTRL",	0x028, 4, regdump_cond_true},
+	{"PMUA_FBRC0_CLK_GATE_CTRL",	0x02c, 4, regdump_cond_true},
+	{"PMUA_FBRC1_CLK_GATE_CTRL",	0x030, 4, regdump_cond_true},
+	{"PMUA_USB_CLK_GATE_CTRL",	0x034, 4, regdump_cond_true},
+	{"PMUA_ISP_CLK_RES_CTRL",	0x038, 4, regdump_cond_true},
+	{"PMUA_PMU_CLK_GATE_CTRL",	0x040, 4, regdump_cond_true},
+	{"PMUA_DSI_CLK_RES_CTRL",	0x044, 4, regdump_cond_true},
+#ifdef CONFIG_CPU_PXA1088
+	{"PMUA_HSI_CLK_RES_CTRL",	0x048, 4, regdump_cond_true},
+#endif
+	{"PMUA_LCD_DSI_CLK_RES_CTRL",	0x04c, 4, regdump_cond_true},
+	{"PMUA_CCIC_CLK_RES_CTRL",	0x050, 4, regdump_cond_true},
+	{"PMUA_SDH0_CLK_RES_CTRL",	0x054, 4, regdump_cond_true},
+	{"PMUA_SDH1_CLK_RES_CTRL",	0x058, 4, regdump_cond_true},
+	{"PMUA_USB_CLK_RES_CTRL",	0x05c, 4, regdump_cond_true},
+	{"PMUA_NF_CLK_RES_CTRL",	0x060, 4, regdump_cond_true},
+	{"PMUA_DMA_CLK_RES_CTRL",	0x064, 4, regdump_cond_true},
+	{"PMUA_AES_CLK_RES_CTRL",	0x068, 4, regdump_cond_true},
+	{"PMUA_MCB_CLK_RES_CTRL",	0x06c, 4, regdump_cond_true},
+	{"PMUA_CP_IMR",			0x070, 4, regdump_cond_true},
+	{"PMUA_CP_IRWC",			0x074, 4, regdump_cond_true},
+	{"PMUA_CP_ISR",			0x078, 4, regdump_cond_true},
+	{"PMUA_SD_ROT_WAKE_CLR",		0x07c, 4, regdump_cond_true},
+#ifdef CONFIG_CPU_PXA1088
+	{"PMUA_FBRC_CLK",		0x080, 4, regdump_cond_true},
+#endif
+	{"PMUA_PWR_STBL_TIMER",		0x084, 4, regdump_cond_true},
+	{"PMUA_DEBUG_REG",		0x088, 4, regdump_cond_true},
+	{"PMUA_SRAM_PWR_DWN",		0x08c, 4, regdump_cond_true},
+	{"PMUA_CORE_STATUS",		0x090, 4, regdump_cond_true},
+	{"PMUA_RES_FRM_SLP_CLR",	0x094, 4, regdump_cond_true},
+	{"PMUA_AP_IMR",			0x098, 4, regdump_cond_true},
+	{"PMUA_AP_IRWC",		0x09c, 4, regdump_cond_true},
+	{"PMUA_AP_ISR",			0x0a0, 4, regdump_cond_true},
+	{"PMUA_VPU_CLK_RES_CTRL",	0x0a4, 4, regdump_cond_true},
+#ifdef CONFIG_CPU_PXA1088
+	{"PMUA_VPRO_PWRDWN",	0x0a8, 4, regdump_cond_true},
+#endif
+	{"PMUA_DTC_CLK_RES_CTRL",	0x0ac, 4, regdump_cond_true},
+	{"PMUA_MC_HW_SLP_TYPE",		0x0b0, 4, regdump_cond_true},
+	{"PMUA_MC_SLP_REQ_AP",		0x0b4, 4, regdump_cond_true},
+	{"PMUA_MC_SLP_REQ_CP",		0x0b8, 4, regdump_cond_true},
+	{"PMUA_MC_SLP_REQ_MSA",		0x0bc, 4, regdump_cond_true},
+	{"PMUA_MC_SW_SLP_TYPE",		0x0c0, 4, regdump_cond_true},
+	{"PMUA_PLL_SEL_STATUS",		0x0c4, 4, regdump_cond_true},
+	{"PMUA_SYNC_MODE_BYPASS",	0x0c8, 4, regdump_cond_true},
+	{"PMUA_GPU_3D_CLK_RES_CTRL",	0x0cc, 4, regdump_cond_true},
+#ifdef CONFIG_CPU_PXA1088
+	{"PMUA_GPU_3D_PWRDWN",	0x0d0, 4, regdump_cond_true},
+#endif
+	{"PMUA_SMC_CLK_RES_CTRL",	0x0d4, 4, regdump_cond_true},
+	{"PMUA_PWR_CTRL_REG",	0x0d8, 4, regdump_cond_true},
+	{"PMUA_PWR_BLK_TMR_REG",		0x0dc, 4, regdump_cond_true},
+	{"PMUA_SDH2_CLK_RES_CTRL",	0x0e0, 4, regdump_cond_true},
+	{"PMUA_CA7MP_IDLE_CFG1",		0x0e4, 4, regdump_cond_true},
+	{"PMUA_MC_CTRL",	0x0e8, 4, regdump_cond_true},
+	{"PMUA_PWR_STATUS_REG",	0x0f0, 4, regdump_cond_true},
+	{"PMUA_GPU_2D_CLK_RES_CTRL",	0x0f4, 4, regdump_cond_true},
+	{"PMUA_CC2_AP",	0x100, 4, regdump_cond_true},
+	{"PMUA_DM_CC2_AP",	0x104, 4, regdump_cond_true},
+	{"PMUA_TRACE_CONFIG",	0x108, 4, regdump_cond_true},
+	{"PMUA_CA7MP_IDLE_CFG0",		0x120, 4, regdump_cond_true},
+	{"PMUA_CA7_CORE0_IDLE_CFG",		0x124, 4, regdump_cond_true},
+	{"PMUA_CA7_CORE1_IDLE_CFG",		0x128, 4, regdump_cond_true},
+	{"PMUA_CA7_CORE0_WAKEUP",		0x12c, 4, regdump_cond_true},
+	{"PMUA_CA7_CORE1_WAKEUP",		0x130, 4, regdump_cond_true},
+	{"PMUA_CA7_CORE2_WAKEUP",		0x134, 4, regdump_cond_true},
+	{"PMUA_CA7_CORE3_WAKEUP",		0x138, 4, regdump_cond_true},
+	{"PMUA_DVC_DEBUG",		0x140, 4, regdump_cond_true},
+	{"PMUA_CA7MP_IDLE_CFG2",		0x150, 4, regdump_cond_true},
+	{"PMUA_CA7MP_IDLE_CFG3",		0x154, 4, regdump_cond_true},
+	{"PMUA_CA7_CORE2_IDLE_CFG",		0x160, 4, regdump_cond_true},
+	{"PMUA_CA7_CORE3_IDLE_CFG",		0x164, 4, regdump_cond_true},
+	{"PMUA_CA7_PWR_MISC",		0x170, 4, regdump_cond_true},
+};
+
+static void __init pxa_init_pmua_regdump(void)
+{
+	pmua_regdump_ops.base = (unsigned long)(APMU_VIRT_BASE);
+	pmua_regdump_ops.phy_base = (unsigned long)(APMU_PHY_BASE);
+	pmua_regdump_ops.regions = pmua_dump_region;
+	pmua_regdump_ops.reg_nums = ARRAY_SIZE(pmua_dump_region);
+	register_regdump_ops(&pmua_regdump_ops);
+}
+
+static struct regdump_ops gic_regdump_ops = {
+	.dev_name = "PXA1088-gic",
+};
+
+static struct regdump_region gic_dump_region[] = {
+	{"GIC_GICD_CTLR",			0x000, 4, regdump_cond_true},
+	{"GIC_GICD_TYPER",			0x004, 4, regdump_cond_true},
+	{"GIC_GICD_IIDR",			0x008, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER0",			0x100, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER1",			0x104, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER2",			0x108, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER3",			0x10c, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER4",			0x110, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER5",			0x114, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER6",			0x118, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER7",			0x11c, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER8",			0x120, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER9",			0x124, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER10",		0x128, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER11",		0x12c, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER12",		0x130, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER13",		0x134, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER14",		0x138, 4, regdump_cond_true},
+	{"GIC_GICD_ISENABLER15",		0x13c, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR0",			0x200, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR1",			0x204, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR2",			0x208, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR3",			0x20c, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR4",			0x210, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR5",			0x214, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR6",			0x218, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR7",			0x21c, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR8",			0x220, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR9",			0x224, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR10",			0x228, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR11",			0x22c, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR12",			0x230, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR13",			0x234, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR14",			0x238, 4, regdump_cond_true},
+	{"GIC_GICD_ISPENDR15",			0x23c, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER0",			0x300, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER1",			0x304, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER2",			0x308, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER3",			0x30c, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER4",			0x310, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER5",			0x314, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER6",			0x318, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER7",			0x31c, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER8",			0x320, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER9",			0x324, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER10",		0x328, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER11",		0x32c, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER12",		0x330, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER13",		0x334, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER14",		0x338, 4, regdump_cond_true},
+	{"GIC_GICD_ISACTIVER15",		0x33c, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR0",			0xc00, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR1",			0xc04, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR2",			0xc08, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR3",			0xc0c, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR4",			0xc10, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR5",			0xc14, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR6",			0xc18, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR7",			0xc1c, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR8",			0xc20, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR9",			0xc24, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR10",			0xc28, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR11",			0xc2c, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR12",			0xc30, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR13",			0xc34, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR14",			0xc38, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR15",			0xc3c, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR16",			0xc40, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR17",			0xc44, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR18",			0xc48, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR19",			0xc4c, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR20",			0xc50, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR21",			0xc54, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR22",			0xc58, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR23",			0xc5c, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR24",			0xc60, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR25",			0xc64, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR26",			0xc68, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR27",			0xc6c, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR28",			0xc70, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR29",			0xc74, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR30",			0xc78, 4, regdump_cond_true},
+	{"GIC_GICD_ICFGR31",			0xc7c, 4, regdump_cond_true},
+};
+
+static void __init pxa_init_gic_regdump(void)
+{
+	gic_regdump_ops.base = (void __iomem *)GIC_DIST_VIRT_BASE;
+	gic_regdump_ops.phy_base = GIC_DIST_PHYS_BASE;
+	gic_regdump_ops.regions = gic_dump_region;
+	gic_regdump_ops.reg_nums = ARRAY_SIZE(gic_dump_region);
+	register_regdump_ops(&gic_regdump_ops);
+}
+
+#else
+static inline void  __init pxa_init_pmua_regdump(void) {}
+static inline void __init pxa_init_gic_regdump(void) {}
+#endif
+
+/*
+ * gc, vpu, isp will access the same regsiter to pwr on/off,
+ * add spinlock to protect the sequence
+ */
+static DEFINE_SPINLOCK(gc_vpu_isp_pwr_lock);
+
+/* used to protect GC power sequence */
+static DEFINE_SPINLOCK(gc_pwr_lock);
+
+/* used to protect ripc status */
+DEFINE_SPINLOCK(ripc_lock);
+EXPORT_SYMBOL(ripc_lock);
+static int ripc_status;
+
+/* GC power control */
+#define GC_USE_HW_PWRCTRL	1
+#define GC_AUTO_PWR_ON		(0x1 << 0)
+
+#define GC_CLK_EN	\
+	((0x1 << 3) | (0x1 << 4) | (0x1 << 5))
+
+#define GC_ACLK_RST	(0x1 << 0)
+#define GC_FCLK_RST	(0x1 << 1)
+#define GC_HCLK_RST	(0x1 << 2)
+#define GC_CLK_RST	\
+	(GC_ACLK_RST | GC_FCLK_RST | GC_HCLK_RST)
+
+#define GC_ISOB		(0x1 << 8)
+#define GC_PWRON1	(0x1 << 9)
+#define GC_PWRON2	(0x1 << 10)
+#define GC_HWMODE	(0x1 << 11)
+
+#define GC_FCLK_SEL_MASK	(0x3 << 6)
+#define GC_ACLK_SEL_MASK	(0x3 << 20)
+#define GC_FCLK_DIV_MASK	(0x7 << 12)
+#define GC_ACLK_DIV_MASK	(0x7 << 17)
+#define GC_FCLK_REQ		(0x1 << 15)
+#define GC_ACLK_REQ		(0x1 << 16)
+
+#define GC_CLK_SEL_WIDTH	(2)
+#define GC_CLK_DIV_WIDTH	(3)
+#define GC_FCLK_SEL_SHIFT	(6)
+#define GC_ACLK_SEL_SHIFT	(20)
+#define GC_FCLK_DIV_SHIFT	(12)
+#define GC_ACLK_DIV_SHIFT	(17)
+
+#define GC_REG_WRITE(val)	{	\
+	__raw_writel(val, APMU_GC);	\
+}
+
+#define GC_2D_REG_WRITE(val)	{	\
+	_raw_writel(val, APMU_GC_2D);	\
+}
+
+void gc_pwr(int power_on)
+{
+	unsigned int val = __raw_readl(APMU_GC);
+	int timeout = 5000;
+#ifdef	CONFIG_CPU_PXA1088
+	unsigned int __attribute__ ((unused)) val_2d = __raw_readl(APMU_GC_2D);
+#endif
+
+	static struct clk *gc_clk = NULL;
+	if(!gc_clk)
+		gc_clk = clk_get(NULL, "GCCLK");
+	if(power_on)
+		clk_enable(gc_clk);
+
+	spin_lock(&gc_pwr_lock);
+
+	if (power_on) {
+#ifdef GC_USE_HW_PWRCTRL
+		/* enable hw mode */
+		val |= GC_HWMODE;
+		GC_REG_WRITE(val);
+
+		spin_lock(&gc_vpu_isp_pwr_lock);
+		/* set PWR_BLK_TMR_REG to recommend value */
+		__raw_writel(0x20001FFF, APMU_PWR_BLK_TMR_REG);
+
+		/* pwr on GC */
+		val = __raw_readl(APMU_PWR_CTRL_REG);
+		val |= GC_AUTO_PWR_ON;
+		__raw_writel(val, APMU_PWR_CTRL_REG);
+		spin_unlock(&gc_vpu_isp_pwr_lock);
+
+		/* polling pwr status */
+		while (!(__raw_readl(APMU_PWR_STATUS_REG) & GC_AUTO_PWR_ON)) {
+			udelay(200);
+			timeout -= 200;
+			if (timeout < 0) {
+				pr_err("%s: power on timeout\n", __func__);
+				clk_disable(gc_clk);
+				return;
+			}
+		}
+#else
+		/* enable bus and function clock  */
+		val |= GC_CLK_EN;
+		GC_REG_WRITE(val);
+
+#ifdef	CONFIG_CPU_PXA1088
+		val_2d |= GC_CLK_EN;
+		GC_2D_REG_WRITE(val_2d);
+#endif
+		/* enable power_on1, wait at least 200us */
+		val |= GC_PWRON1;
+		GC_REG_WRITE(val);
+		udelay(200);
+
+		/* enable power_on2 */
+		val |= GC_PWRON2;
+		GC_REG_WRITE(val);
+
+		/* fRst release */
+		val |= GC_FCLK_RST;
+		GC_REG_WRITE(val);
+#ifdef	CONFIG_CPU_PXA1088
+		val_2d |= GC_FCLK_RST;
+		GC_2D_REG_WRITE(val_2d);
+#endif
+		udelay(100);
+
+		/* aRst hRst release at least 48 cycles later than fRst */
+		val |= (GC_ACLK_RST | GC_HCLK_RST);
+		GC_REG_WRITE(val);
+#ifdef	CONFIG_CPU_PXA1088
+		val_2d |= (GC_ACLK_RST | GC_HCLK_RST);
+		GC_2D_REG_WRITE(val_2d);
+#endif
+		/* disable isolation */
+		val |= GC_ISOB;
+		GC_REG_WRITE(val);
+#endif
+	} else {
+#ifdef GC_USE_HW_PWRCTRL
+		spin_lock(&gc_vpu_isp_pwr_lock);
+		/* pwr on GC */
+		val = __raw_readl(APMU_PWR_CTRL_REG);
+		val &= ~GC_AUTO_PWR_ON;
+		__raw_writel(val, APMU_PWR_CTRL_REG);
+		spin_unlock(&gc_vpu_isp_pwr_lock);
+
+		/* polling pwr status */
+		while ((__raw_readl(APMU_PWR_STATUS_REG) & GC_AUTO_PWR_ON)) {
+			udelay(200);
+			timeout -= 200;
+			if (timeout < 0) {
+				pr_err("%s: power off timeout\n", __func__);
+				return;
+			}
+		}
+#else
+		/* enable isolation */
+		val &= ~GC_ISOB;
+		GC_REG_WRITE(val);
+
+		/* disable power_on2 */
+		val &= ~GC_PWRON2;
+		GC_REG_WRITE(val);
+
+		/* disable power_on1 */
+		val &= ~GC_PWRON1;
+		GC_REG_WRITE(val);
+
+		/* fRst aRst hRst */
+		val &= ~(GC_CLK_RST | GC_CLK_EN);
+		GC_REG_WRITE(val);
+#ifdef	CONFIG_CPU_PXA1088
+		val_2d &= ~(GC_CLK_RST | GC_CLK_EN);
+		GC_2D_REG_WRITE(val_2d);
+#endif
+		udelay(100);
+
+#endif
+	}
+	spin_unlock(&gc_pwr_lock);
+	if(power_on)
+		clk_disable(gc_clk);
+}
+EXPORT_SYMBOL(gc_pwr);
+
+#define VPU_HW_MODE	(0x1 << 19)
+#define VPU_AUTO_PWR_ON	(0x1 << 2)
+#define VPU_PWR_STAT	(0x1 << 2)
+
+void coda7542_power_switch(int on)
+{
+	unsigned int val;
+	int timeout = 2000;
+
+	/* HW mode power on */
+	if (on) {
+		/* set VPU HW on/off mode  */
+		val = __raw_readl(APMU_VPU_CLK_RES_CTRL);
+		val |= VPU_HW_MODE;
+		__raw_writel(val, APMU_VPU_CLK_RES_CTRL);
+
+		spin_lock(&gc_vpu_isp_pwr_lock);
+		/* on1, on2, off timer */
+		__raw_writel(0x20001fff, APMU_PWR_BLK_TMR_REG);
+
+		/* VPU auto power on */
+		val = __raw_readl(APMU_PWR_CTRL_REG);
+		val |= VPU_AUTO_PWR_ON;
+		__raw_writel(val, APMU_PWR_CTRL_REG);
+		spin_unlock(&gc_vpu_isp_pwr_lock);
+		/*
+		 * VPU power on takes 316us, usleep_range(280,290) takes about
+		 * 300~320us, so it can reduce the duty cycle.
+		 */
+		usleep_range(280, 290);
+
+		/* polling VPU_PWR_STAT bit */
+		while (!(__raw_readl(APMU_PWR_STATUS_REG) & VPU_PWR_STAT)) {
+			udelay(1);
+			timeout -= 1;
+			if (timeout < 0) {
+				pr_err("%s: VPU power on timeout\n", __func__);
+				return;
+			}
+		}
+	/* HW mode power off */
+	} else {
+		spin_lock(&gc_vpu_isp_pwr_lock);
+		/* VPU auto power off */
+		val = __raw_readl(APMU_PWR_CTRL_REG);
+		val &= ~VPU_AUTO_PWR_ON;
+		__raw_writel(val, APMU_PWR_CTRL_REG);
+		spin_unlock(&gc_vpu_isp_pwr_lock);
+		/*
+		 * VPU power off takes 23us, add a pre-delay to reduce the
+		 * number of polling
+		 */
+		udelay(20);
+
+		/* polling VPU_PWR_STAT bit */
+		while ((__raw_readl(APMU_PWR_STATUS_REG) & VPU_PWR_STAT)) {
+			udelay(1);
+			timeout -= 1;
+			if (timeout < 0) {
+				pr_err("%s: VPU power off timeout\n", __func__);
+				return;
+			}
+		}
+	}
+}
+
+#ifdef CONFIG_ANDROID_RAM_CONSOLE
+static void pxa988_ram_console_init(void)
+{
+	static struct persistent_ram ram;
+	static struct persistent_ram_descriptor desc;
+	static char name[20] = "ram_console";
+
+	/* reserver 256K memory from DDR address 0x8100000 */
+	ram.start = 0x8100000;
+	ram.size = 0x40000;
+	ram.num_descs = 1;
+
+	desc.size = 0x40000;
+	desc.name = name;
+	ram.descs = &desc;
+
+	persistent_ram_early_init(&ram);
+}
+#endif
+
+#ifdef CONFIG_ION
+static struct ion_platform_data ion_data = {
+	.nr	= 2,
+	.heaps	= {
+		[0] = {
+			.type	= ION_HEAP_TYPE_CARVEOUT,
+			.id	= ION_HEAP_TYPE_CARVEOUT,
+			.name	= "carveout_heap",
+			.size   = 0x01000000,
+			.base   = 0x09000000,
+		},
+		[1] = {
+			.type	= ION_HEAP_TYPE_SYSTEM,
+			.id	= ION_HEAP_TYPE_SYSTEM,
+			.name	= "system_heap",
+		},
+	},
+};
+
+struct platform_device device_ion = {
+	.name	= "pxa-ion",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &ion_data,
+	},
+};
+
+static int __init ion_mem_carveout(char *p)
+{
+	unsigned long size;
+	phys_addr_t start;
+	char *endp;
+
+	size  = memparse(p, &endp);
+
+	if (size == 0) {
+		ion_data.heaps[0].size = 0;
+		ion_data.heaps[0].base = 0;
+		return 0;
+	}
+
+	if (*endp == '@')
+		start = memparse(endp + 1, NULL);
+	else
+		BUG_ON(1);
+
+	/* set the carveout heap range */
+	ion_data.heaps[0].size = size;
+	ion_data.heaps[0].base = start;
+
+	return 0;
+}
+early_param("ioncarv", ion_mem_carveout);
+#endif
+
+/* CP memeory reservation, 32MB by default */
+static u32 cp_area_size = 0x02000000;
+static u32 cp_area_addr = 0x06000000;
+
+static int __init early_cpmem(char *p)
+{
+	char *endp;
+
+	cp_area_size = memparse(p, &endp);
+	if (*endp == '@')
+		cp_area_addr = memparse(endp + 1, NULL);
+
+	return 0;
+}
+early_param("cpmem", early_cpmem);
+
+static void __init pxa988_reserve_cpmem(void)
+{
+	/* Reserve memory for CP */
+	BUG_ON(memblock_reserve(cp_area_addr, cp_area_size) != 0);
+	memblock_free(cp_area_addr, cp_area_size);
+	memblock_remove(cp_area_addr, cp_area_size);
+	pr_info("Reserved CP memory: 0x%x@0x%x\n", cp_area_size, cp_area_addr);
+}
+
+static void __init pxa988_reserve_obmmem(void)
+{
+	/* Reserve 1MB memory for obm */
+	BUG_ON(memblock_reserve(PLAT_PHYS_OFFSET, 0x100000) != 0);
+	memblock_free(PLAT_PHYS_OFFSET, 0x100000);
+	memblock_remove(PLAT_PHYS_OFFSET, 0x100000);
+	pr_info("Reserved OBM memory: 0x%x@0x%lx\n",
+		0x100000, PLAT_PHYS_OFFSET);
+}
+
+/*
+* We will arrange the reserved memory for the following usage.
+* 0 ~ PAGE_SIZE -1:  For low power
+* PAGE_SIZE ~ 2 * PAGE_SIZE -1: For reset handler
+*/
+static void __init pxa988_reserve_pmmem(void)
+{
+	u32 pm_area_addr = 0x08000000;
+	u32 pm_area_size = 0x00100000;
+	pm_reserve_pa = pm_area_addr;
+	/* Reserve 1MB memory for power management use */
+	BUG_ON(memblock_reserve(pm_area_addr, pm_area_size) != 0);
+	BUG_ON(memblock_free(pm_area_addr, pm_area_size));
+	BUG_ON(0 != memblock_remove(pm_area_addr, pm_area_size));
+}
+
+#ifdef CONFIG_ION
+static void __init pxa988_reserve_ion(void)
+{
+	BUG_ON(memblock_reserve(ion_data.heaps[0].base,
+		ion_data.heaps[0].size));
+
+	pr_info("ION carveout memory: 0x%08x@0x%08x\n",
+		(u32)ion_data.heaps[0].size, (u32)ion_data.heaps[0].base);
+}
+#endif
+void __init pxa988_reserve(void)
+{
+	/*
+	 * reserve the first 1MB physical ddr memory for obm. when use EMMD
+	 * (Enhanced Marvell Memory Dump), kernel should not make use of this
+	 * memory, since it'll be corrupted by next reboot by obm.
+	 */
+	pxa988_reserve_obmmem();
+
+	pxa988_reserve_cpmem();
+
+#ifdef CONFIG_ANDROID_RAM_CONSOLE
+	pxa988_ram_console_init();
+#endif
+#ifdef CONFIG_GPU_RESERVE_MEM
+	pxa_reserve_gpu_memblock();
+#endif
+	pxa988_reserve_pmmem();
+#ifdef CONFIG_ION
+	pxa988_reserve_ion();
+#endif
+
+	pxa988_reserve_fb_mem();
+}
+
+void __init pxa988_init_irq(void)
+{
+	mmp_wakeupgen_init();
+	gic_init(0, 29, IOMEM(GIC_DIST_VIRT_BASE), IOMEM(GIC_CPU_VIRT_BASE));
+}
+
+void pxa988_ripc_lock(void)
+{
+	int cnt = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ripc_lock, flags);
+
+	while (__raw_readl(RIPC3_STATUS)) {
+		/* give telephnoy chance to detect ripc status */
+
+		ripc_status = 0;
+		spin_unlock_irqrestore(&ripc_lock, flags);
+
+		cpu_relax();
+		udelay(50);
+
+		cnt++;
+		if (cnt >= 10000) {
+			pr_warn("AP: ripc cannot be locked!\n");
+			cnt = 0;
+		}
+
+		spin_lock_irqsave(&ripc_lock, flags);
+	}
+
+	/* we are sure to have held ripc */
+	ripc_status = 1;
+
+	spin_unlock_irqrestore(&ripc_lock, flags);
+}
+
+int pxa988_ripc_trylock(void)
+{
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ripc_lock, flags);
+	ret = !__raw_readl(RIPC3_STATUS);
+	ripc_status = ret;
+	spin_unlock_irqrestore(&ripc_lock, flags);
+
+	return ret;
+}
+
+void pxa988_ripc_unlock(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&ripc_lock, flags);
+
+	__raw_writel(1, RIPC3_STATUS);
+	ripc_status = 0;
+
+	spin_unlock_irqrestore(&ripc_lock, flags);
+}
+
+/* the caller _MUST_ hold ripc_lock before calling it */
+int pxa988_ripc_status(void)
+{
+	return ripc_status;
+}
+EXPORT_SYMBOL(pxa988_ripc_status);
+
+#ifdef CONFIG_CACHE_L2X0
+
+#ifdef CONFIG_PM
+static inline void l2x0_save_phys_reg_addr(u32 *addr_ptr, u32 addr)
+{
+	BUG_ON(!addr_ptr);
+	*addr_ptr = addr;
+	flush_cache_all();
+	outer_clean_range(virt_to_phys(addr_ptr),
+		virt_to_phys(addr_ptr) + sizeof(*addr_ptr));
+}
+#endif
+
+static void pxa988_l2_cache_init(void)
+{
+	void __iomem *l2x0_base;
+
+	l2x0_base = ioremap(SL2C_PHYS_BASE, SZ_4K);
+	BUG_ON(!l2x0_base);
+
+	/* TAG, Data Latency Control */
+	writel_relaxed(0x010, l2x0_base + L2X0_TAG_LATENCY_CTRL);
+	writel_relaxed(0x010, l2x0_base + L2X0_DATA_LATENCY_CTRL);
+
+	/* L2X0 Power Control  */
+	writel_relaxed(0x3, l2x0_base + L2X0_POWER_CTRL);
+
+	/* Enable I/D cache prefetch feature */
+	l2x0_init(l2x0_base, 0x30800000, 0xFE7FFFFF);
+
+#ifdef CONFIG_PM
+	l2x0_saved_regs.phy_base = SL2C_PHYS_BASE;
+	l2x0_save_phys_reg_addr(&l2x0_regs_phys,
+				l2x0_saved_regs_phys_addr);
+#endif
+}
+#else
+#define pxa988_l2_cache_init()
+#endif
+
+#ifdef CONFIG_HAVE_ARM_TWD
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
+	(unsigned int)TWD_PHYS_BASE, IRQ_LOCALTIMER);
+
+static void __init pxa988_twd_init(void)
+{
+	int err = twd_local_timer_register(&twd_local_timer);
+	if (err)
+		pr_err("twd_local_timer_register failed %d\n", err);
+}
+#else
+#define pxa988_twd_init(void)	do {} while (0)
+#endif
+
+#ifdef CONFIG_ARM_ARCH_TIMER
+static struct arch_timer pxa1088_arch_timer = {
+	.rate = 26000000,
+	.ppi = {
+		IRQ_GIC_PHYS_SECURE_PPI,
+		IRQ_GIC_PHYS_NONSECURE_PPI,
+		IRQ_GIC_VIRT_PPI,
+		IRQ_GIC_HYP_PPI
+	},
+	.use_virtual = false,
+	.base = GENERIC_COUNTER_VIRT_BASE
+};
+#endif /* #ifdef CONFIG_ARM_ARCH_TIMER */
+
+static void __init pxa988_timer_init(void)
+{
+#ifdef CONFIG_ARM_ARCH_TIMER
+	uint32_t tmp;
+#endif /* #ifdef CONFIG_ARM_ARCH_TIMER */
+
+#ifdef CONFIG_APB_LOCALTIMER
+	apb_timer_init();
+#else /* CONFIG_APB_LOCALTIMER */
+	/* Select the configurable timer clock source to be 3.25MHz */
+	__raw_writel(APBC_APBCLK | APBC_RST, APBC_PXA988_TIMERS);
+	__raw_writel(APBC_APBCLK | APBC_FNCLK | APBC_FNCLKSEL(3),
+		     APBC_PXA988_TIMERS);
+
+	timer_init(IRQ_PXA988_AP_TIMER1);
+	pxa988_twd_init();
+#endif /* CONFIG_APB_LOCALTIMER */
+
+
+#ifdef CONFIG_ARM_ARCH_TIMER
+	tmp = readl(APBC_COUNTER_CLK_SEL);
+	/* Default is 26M/32768 = 0x319 */
+	if ((tmp >> 16) != 0x319) {
+		pr_warn("pxa988_timer_init: Generic Counter"
+			" step of Low Frequency is not right\n");
+		return;
+	}
+	/* bit0 = 1: Generic Counter Frequency control by hardware VCTCXO_EN
+	   VCTCXO_EN = 1, Generic Counter Frequency is 26Mhz;
+	   VCTCXO_EN = 0, Generic Counter Frequency is 32KHz */
+	writel(tmp | FREQ_HW_CTRL, APBC_COUNTER_CLK_SEL);
+
+	/* NOTE: can not read CNTCR before write, otherwise write will fail
+	   Halt on debug;
+	   start the counter */
+	writel(CNTCR_HDBG | CNTCR_EN, GENERIC_COUNTER_VIRT_BASE + CNTCR);
+
+	arch_timer_init(&pxa1088_arch_timer);
+#endif /* #ifdef CONFIG_ARM_ARCH_TIMER */
+}
+
+struct sys_timer pxa988_timer = {
+	.init   = pxa988_timer_init,
+};
+
+void pxa988_clear_keypad_wakeup(void)
+{
+	uint32_t val;
+	uint32_t mask = APMU_PXA988_KP_WAKE_CLR;
+
+	/* wake event clear is needed in order to clear keypad interrupt */
+	val = __raw_readl(APMU_WAKE_CLR);
+	__raw_writel(val | mask, APMU_WAKE_CLR);
+}
+
+void pxa988_clear_sdh_wakeup(void)
+{
+	uint32_t val;
+	uint32_t mask = APMU_PXA988_SD1_WAKE_CLR | APMU_PXA988_SD2_WAKE_CLR
+					| APMU_PXA988_SD3_WAKE_CLR;
+
+	val = __raw_readl(APMU_WAKE_CLR);
+	__raw_writel(val | mask, APMU_WAKE_CLR);
+
+}
+
+struct resource pxa988_resource_gpio[] = {
+	{
+		.start	= 0xd4019000,
+		.end	= 0xd40197ff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_PXA988_GPIO_AP,
+		.end	= IRQ_PXA988_GPIO_AP,
+		.name	= "gpio_mux",
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa988_device_gpio = {
+	.name		= "pxa-gpio",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(pxa988_resource_gpio),
+	.resource	= pxa988_resource_gpio,
+};
+
+#ifdef CONFIG_USB_MV_UDC
+static DEFINE_SPINLOCK(phy_lock);
+static int phy_init_cnt;
+
+static int usb_phy_init_internal(void __iomem *base)
+{
+	struct pxa988_usb_phy *phy = (struct pxa988_usb_phy *)base;
+	int i;
+	u32 phy_old, phy_power;
+
+	pr_debug("init usb phy.\n");
+
+	/*
+	 * power up PHY by PIN.
+	 * From the datasheet, it can be controlled by current regiter,
+	 * but not pin.
+	 * Will remove it after debug.
+	 */
+	phy_old = (u32)ioremap_nocache(0xD4207100, 0x10);
+	phy_power = phy_old + 0x4;
+	writel(0x10901003, phy_power);
+
+	/* enable usb device PHY */
+	writew(PLLVDD18(0x1) | REFDIV(0xd) | FBDIV(0xf0),
+		&phy->utmi_pll_reg0);
+#ifdef CONFIG_MACH_WILCOX_CMCC
+     if (get_board_id() <BOARD_ID_CMCC_REV05) 
+	writew(PU_PLL | PLL_LOCK_BYPASS | DLL_RESET_BLK |
+		ICP(0x1) | KVCO(0x3) | PLLCAL12(0x3),
+		&phy->utmi_pll_reg1);
+	else
+	writew(PU_PLL | PLL_LOCK_BYPASS | ICP(0x1) | KVCO(0x3) | PLLCAL12(0x3),
+		&phy->utmi_pll_reg1);
+#else
+    writew(PU_PLL | PLL_LOCK_BYPASS | ICP(0x1) | KVCO(0x3) | PLLCAL12(0x3),
+		&phy->utmi_pll_reg1);
+#endif
+	writew(IMPCAL_VTH(0x1) | EXT_HS_RCAL(0x8) | EXT_FS_RCAL(0x8),
+		&phy->utmi_tx_reg0);
+	writew(TXVDD15(0x1) | TXVDD12(0x3) | LOWVDD_EN |
+		AMP(0x5) | CK60_PHSEL(0x4),
+		&phy->utmi_tx_reg1);
+	writew(DRV_SLEWRATE(0x2) | IMP_CAL_DLY(0x2) |
+		FSDRV_EN(0xf) | HSDEV_EN(0xf),
+		&phy->utmi_tx_reg2);
+#if defined(CONFIG_MACH_CS02) || defined(CONFIG_MACH_WILCOX) || defined(CONFIG_MACH_GOYA)
+	writew(PHASE_FREEZE_DLY | ACQ_LENGTH(0x2) | SQ_LENGTH(0x2) |
+		DISCON_THRESH(0x2) | SQ_THRESH(0xc) | INTPI(0x1),
+		&phy->utmi_rx_reg0);
+#elif defined(CONFIG_MACH_LT02)
+	writew(PHASE_FREEZE_DLY | ACQ_LENGTH(0x2) | SQ_LENGTH(0x2) |
+		DISCON_THRESH(0x2) | SQ_THRESH(0x8) | INTPI(0x1),
+		&phy->utmi_rx_reg0);
+#else
+	writew(PHASE_FREEZE_DLY | ACQ_LENGTH(0x2) | SQ_LENGTH(0x2) |
+		DISCON_THRESH(0x2) | SQ_THRESH(0xa) | INTPI(0x1),
+		&phy->utmi_rx_reg0);
+#endif
+	writew(EARLY_VOS_ON_EN | RXDATA_BLOCK_EN | EDGE_DET_EN |
+		RXDATA_BLOCK_LENGTH(0x2) | EDGE_DET_SEL(0x1) |
+		S2TO3_DLY_SEL(0x2),
+		&phy->utmi_rx_reg1);
+#ifdef CONFIG_MACH_LT02
+	writew(USQ_FILTER | SQ_BUFFER_EN | RXVDD18(0x1) | RXVDD12(0x1),
+		&phy->utmi_rx_reg2);
+#else
+	writew(USQ_FILTER | RXVDD18(0x1) | RXVDD12(0x1),
+		&phy->utmi_rx_reg2);
+#endif
+	writew(BG_VSEL(0x1) | TOPVDD18(0x1),
+		&phy->utmi_ana_reg0);
+	writew(PU_ANA | SEL_LPFR | V2I(0x6) | R_ROTATE_SEL,
+		&phy->utmi_ana_reg1);
+	writew(FS_EOP_MODE | FORCE_END_EN | SYNCDET_WINDOW_EN |
+		CLK_SUSPEND_EN | FIFO_FILL_NUM(0x6),
+		&phy->utmi_dig_reg0);
+	writew(FS_RX_ERROR_MODE2 | FS_RX_ERROR_MODE1 |
+		FS_RX_ERROR_MODE | ARC_DPDM_MODE,
+		&phy->utmi_dig_reg1);
+	writew(0x0, &phy->utmi_charger_reg0);
+
+	for (i = 0; i < 0x80; i = i + 4)
+		pr_debug("[0x%x] = 0x%x\n", (u32)base + i,
+			readw((u32)base + i));
+
+	iounmap((void __iomem *)phy_old);
+	return 0;
+}
+
+static int usb_phy_deinit_internal(void __iomem *base)
+{
+	u32 phy_old, phy_power;
+	struct pxa988_usb_phy *phy = (struct pxa988_usb_phy *)base;
+	u16 val;
+
+	pr_debug("Deinit usb phy.\n");
+
+	/* power down PHY PLL */
+	val = readw(&phy->utmi_pll_reg1);
+	val &= ~PU_PLL;
+	writew(val, &phy->utmi_pll_reg1);
+
+	/* power down PHY Analog part */
+	val = readw(&phy->utmi_ana_reg1);
+	val &= ~PU_ANA;
+	writew(val, &phy->utmi_ana_reg1);
+
+	/* power down PHY by PIN.
+	 * From the datasheet, it can be controlled by current regiter,
+	 * but not pin.
+	 * Will remove it after debug.
+	 */
+	phy_old = (u32)ioremap_nocache(0xD4207100, 0x10);
+	phy_power = phy_old + 0x4;
+	writel(0x10901000, phy_power);
+
+	iounmap((void __iomem *)phy_old);
+	return 0;
+}
+
+int pxa_usb_phy_init(void __iomem *base)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&phy_lock, flags);
+	if (phy_init_cnt++ == 0)
+		usb_phy_init_internal(base);
+	spin_unlock_irqrestore(&phy_lock, flags);
+	return 0;
+}
+
+void pxa_usb_phy_deinit(void __iomem *base)
+{
+	unsigned long flags;
+
+	WARN_ON(phy_init_cnt == 0);
+
+	spin_lock_irqsave(&phy_lock, flags);
+	if (--phy_init_cnt == 0)
+		usb_phy_deinit_internal(base);
+	spin_unlock_irqrestore(&phy_lock, flags);
+}
+
+static u64 usb_dma_mask = ~(u32)0;
+
+struct resource pxa988_udc_resources[] = {
+	/* regbase */
+	[0] = {
+		.start	= PXA988_UDC_REGBASE + PXA988_UDC_CAPREGS_RANGE,
+		.end	= PXA988_UDC_REGBASE + PXA988_UDC_REG_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= PXA988_UDC_PHYBASE,
+		.end	= PXA988_UDC_PHYBASE + PXA988_UDC_PHY_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_PXA988_USB1,
+		.end	= IRQ_PXA988_USB1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa988_device_udc = {
+	.name		= "mv-udc",
+	.id		= -1,
+	.resource	= pxa988_udc_resources,
+	.num_resources	= ARRAY_SIZE(pxa988_udc_resources),
+	.dev		=  {
+		.dma_mask	= &usb_dma_mask,
+		.coherent_dma_mask = 0xffffffff,
+	}
+};
+#endif /* CONFIG_USB_MV_UDC */
+
+#if defined(CONFIG_TOUCHSCREEN_VNC)
+struct platform_device pxa988_device_vnc_touch = {
+	.name   = "vnc-ts",
+	.id     = -1,
+};
+#endif /* CONFIG_TOUCHSCREEN_VNC */
+
+/*
+ * This function is used to adjust the xtc for sram.
+ * It is used to achieve better Vmin floor.
+ */
+static void pxa988_set_xtc(void)
+{
+	/* wtc/rtc for Z1/Z2 silicon */
+	if (cpu_is_pxa988_z1() || \
+		cpu_is_pxa988_z2() || \
+		cpu_is_pxa986_z1() || \
+		cpu_is_pxa986_z2()) {
+		/* CORE L1 */
+		writel_relaxed(0xAAAAAAAA, CIU_CPU_CONF_SRAM_0);
+		/* CORE L2 */
+		writel_relaxed(0x0000A666, CIU_CPU_CONF_SRAM_1);
+		/* GC */
+		writel_relaxed(0x00045555, CIU_GPU_XTC_REG);
+		/* VPU */
+		writel_relaxed(0x00B06655, CIU_VPU_XTC_REG);
+	} else if (cpu_is_pxa1088()) {
+		writel_relaxed(0x00055555, CIU_GPU_XTC_REG);
+	} else {
+		/* On Z3, core L1/L2 wtc/rtc change on the fly */
+		/* GC */
+		writel_relaxed(0x00044444, CIU_GPU_XTC_REG);
+		/* VPU keeps default setting */
+	}
+}
+
+static int __init pxa988_init(void)
+{
+	pxa988_l2_cache_init();
+
+	mfp_init_base(MFPR_VIRT_BASE);
+	mfp_init_addr(pxa988_addr_map);
+
+#ifdef CONFIG_TZ_HYPERVISOR
+/* if enable TrustZone, reserve ch30/ch31 for GEU. */
+	pxa_init_dma(IRQ_PXA988_DMA_INT0, 30);
+#else
+	pxa_init_dma(IRQ_PXA988_DMA_INT0, 32);
+#endif
+
+#ifdef CONFIG_ION
+	platform_device_register(&device_ion);
+#endif
+#ifdef CONFIG_GPU_RESERVE_MEM
+	pxa_add_gpu();
+#endif
+	platform_device_register(&pxa988_device_gpio);
+#if defined(CONFIG_TOUCHSCREEN_VNC)
+	platform_device_register(&pxa988_device_vnc_touch);
+#endif /* CONFIG_TOUCHSCREEN_VNC */
+	mmp_gpio_edge_init(GPIOE_VIRT_BASE, MFP_PIN_MAX, 128);
+
+	pxa988_set_xtc();
+
+	if (cpu_is_pxa1088()) {
+		pxa_init_pmua_regdump();
+		pxa_init_gic_regdump();
+	}
+	return 0;
+}
+
+postcore_initcall(pxa988_init);
+
+/* on-chip devices */
+PXA988_DEVICE(uart0, "pxa2xx-uart", 0, UART0, 0xd4036000, 0x30, 4, 5);
+PXA988_DEVICE(uart1, "pxa2xx-uart", 1, UART1, 0xd4017000, 0x30, 21, 22);
+PXA988_DEVICE(uart2, "pxa2xx-uart", 2, UART2, 0xd4018000, 0x30, 23, 24);
+PXA988_DEVICE(keypad, "pxa27x-keypad", -1, KEYPAD, 0xd4012000, 0x4c);
+PXA988_DEVICE(twsi0, "pxa910-i2c", 0, I2C0, 0xd4011000, 0x60);
+PXA988_DEVICE(twsi1, "pxa910-i2c", 1, I2C1, 0xd4010800, 0x60);
+PXA988_DEVICE(twsi2, "pxa910-i2c", 2, I2C2, 0xd4037000, 0x60);
+PXA988_DEVICE(pwm1, "pxa910-pwm", 0, NONE, 0xd401a000, 0x10);
+PXA988_DEVICE(pwm2, "pxa910-pwm", 1, NONE, 0xd401a400, 0x10);
+PXA988_DEVICE(pwm3, "pxa910-pwm", 2, NONE, 0xd401a800, 0x10);
+PXA988_DEVICE(pwm4, "pxa910-pwm", 3, NONE, 0xd401ac00, 0x10);
+PXA988_DEVICE(sdh1, "sdhci-pxav3", 0, MMC, 0xd4280000, 0x120);
+PXA988_DEVICE(sdh2, "sdhci-pxav3", 1, MMC, 0xd4280800, 0x120);
+PXA988_DEVICE(sdh3, "sdhci-pxav3", 2, MMC, 0xd4281000, 0x120);
+PXA988_DEVICE(ssp0, "pxa988-ssp", 0, SSP0, 0xd401b000, 0x90, 52, 53);
+PXA988_DEVICE(ssp1, "pxa988-ssp", 1, SSP1, 0xd42a0c00, 0x90, 1, 2);
+PXA988_DEVICE(ssp2, "pxa988-ssp", 2, SSP2, 0xd401C000, 0x90, 60, 61);
+PXA988_DEVICE(gssp, "pxa988-ssp", 4, GSSP, 0xd4039000, 0x90, 6, 7);
+PXA988_DEVICE(asram, "asram", 0, NONE, SRAM_AUDIO_BASE, SRAM_AUDIO_SIZE);
+PXA988_DEVICE(isram, "isram", 1, NONE, SRAM_VIDEO_BASE, SRAM_VIDEO_SIZE);
+PXA988_DEVICE(fb, "pxa168-fb", 0, LCD, 0xd420b000, 0x1fc);
+PXA988_DEVICE(fb_ovly, "pxa168fb_ovly", 0, LCD, 0xd420b000, 0x1fc);
+PXA988_DEVICE(fb_tv, "pxa168-fb", 1, LCD, 0xd420b000, 0x1fc);
+PXA988_DEVICE(fb_tv_ovly, "pxa168fb_ovly", 1, LCD, 0xd420b000, 0x1fc);
+PXA988_DEVICE(camera, "mmp-camera", 0, CI, 0xd420a000, 0x1000);
+PXA988_DEVICE(thermal, "thermal", -1, DRO_SENSOR, 0xd4013200, 0x34);
+
+static struct resource pxa988_resource_rtc[] = {
+	{ 0xd4010000, 0xd40100ff, NULL, IORESOURCE_MEM, },
+	{ IRQ_PXA988_RTC, IRQ_PXA988_RTC, "rtc 1Hz", IORESOURCE_IRQ, },
+	{ IRQ_PXA988_RTC_ALARM, IRQ_PXA988_RTC_ALARM, "rtc alarm", IORESOURCE_IRQ, },
+};
+
+struct platform_device pxa988_device_rtc = {
+	.name		= "sa1100-rtc",
+	.id		= -1,
+	.resource	= pxa988_resource_rtc,
+	.num_resources	= ARRAY_SIZE(pxa988_resource_rtc),
+};
+
+static struct resource pxa988_resource_squ[] = {
+	{
+		.start	= 0xd42a0800,
+		.end	= 0xd42a08ff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_PXA988_HIFI_DMA,
+		.end	= IRQ_PXA988_HIFI_DMA,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa988_device_squ = {
+	.name		= "pxa910-squ",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(pxa988_resource_squ),
+	.resource	= pxa988_resource_squ,
+	.dev		= {
+		.coherent_dma_mask = DMA_BIT_MASK(64),
+	},
+};
+
+static struct resource pxa988_resource_pcm_audio[] = {
+	 {
+		 /* playback dma */
+		.name	= "pxa910-squ",
+		.start	= 0,
+		.flags	= IORESOURCE_DMA,
+	},
+	 {
+		 /* record dma */
+		.name	= "pxa910-squ",
+		.start	= 1,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+static struct mmp_audio_platdata mmp_audio_pdata = {
+	.period_max_capture = 4 * 1024,
+	.buffer_max_capture = 20 * 1024,
+	.period_max_playback = 4 * 1024,
+	.buffer_max_playback = 20 * 1024,
+};
+
+struct platform_device pxa988_device_asoc_platform = {
+	.name		= "mmp-pcm-audio",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(pxa988_resource_pcm_audio),
+	.resource	= pxa988_resource_pcm_audio,
+	.dev = {
+		.platform_data  = &mmp_audio_pdata,
+	},
+};
+
+#ifdef CONFIG_VIDEO_MVISP
+static u64 pxa988_dxo_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource pxa988_dxoisp_resources[] = {
+	[0] = {
+		.name	= "isp-ipc",
+		.start	= IRQ_PXA988_DXO,
+		.end	= IRQ_PXA988_DXO,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa988_device_dxoisp = {
+	.name           = "pxa988-mvisp",
+	.id             = 0,
+	.dev            = {
+		.dma_mask = &pxa988_dxo_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource       = pxa988_dxoisp_resources,
+	.num_resources  = ARRAY_SIZE(pxa988_dxoisp_resources),
+};
+
+static struct resource pxa988_dxodma_resources[] = {
+	{
+		.start	= 0xD420F000,
+		.end	= 0xD4210000 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IRQ_PXA988_ISP_DMA,
+		.end	= IRQ_PXA988_ISP_DMA,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.name	= "ISP-CLK",
+		.flags	= MAP_RES_CLK,
+	},
+};
+
+struct platform_device pxa988_device_dxodma = {
+	.name		= "dxo-dma",
+	.id             = 0,
+	.dev            = {
+		.dma_mask = &pxa988_dxo_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource       = pxa988_dxodma_resources,
+	.num_resources  = ARRAY_SIZE(pxa988_dxodma_resources),
+};
+
+static struct resource pxa988_ccic_resources[] = {
+#if 0
+	/* This is a W/R to avoid iomem conflict with smart sensor driver */
+	/* FIXME: after merge MC/SOC camera driver, should enable this mem_res*/
+	{
+		.start	= 0xD420A000,
+		.end	= 0xD420A100 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+#endif
+	{
+		.start	= IRQ_PXA988_CI,
+		.end	= IRQ_PXA988_CI,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.name	= "CCICFUNCLK",
+		.flags	= MAP_RES_CLK,
+	},
+	{
+		.name	= "CCICPHYCLK",
+		.flags	= MAP_RES_CLK,
+	},
+};
+
+struct platform_device pxa988_device_ccic = {
+	.name           = "ccic",
+	.id             = 0,
+	.dev            = {
+		.dma_mask = &pxa988_dxo_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource       = pxa988_ccic_resources,
+	.num_resources  = ARRAY_SIZE(pxa988_ccic_resources),
+};
+
+void pxa988_register_dxoisp(struct mvisp_platform_data *data)
+{
+	int ret;
+
+	pxa988_device_dxodma.dev.platform_data = data;
+	ret = platform_device_register(&pxa988_device_dxodma);
+	if (ret)
+		dev_err(&(pxa988_device_dxodma.dev),
+				"unable to register dxodma device: %d\n", ret);
+
+	pxa988_device_ccic.dev.platform_data = data;
+	ret = platform_device_register(&pxa988_device_ccic);
+	if (ret)
+		dev_err(&(pxa988_device_ccic.dev),
+				"unable to register ccic device: %d\n", ret);
+
+	pxa988_device_dxoisp.dev.platform_data = data;
+	ret = platform_device_register(&pxa988_device_dxoisp);
+	if (ret)
+		dev_err(&(pxa988_device_dxoisp.dev),
+				"unable to register dxo device: %d\n", ret);
+}
+
+#define ISP_HW_MODE         (0x1 << 15)
+#define ISP_AUTO_PWR_ON     (0x1 << 4)
+#define ISP_PWR_STAT        (0x1 << 4)
+#define ISP_CLK_RST         ((1 << 0) | (1 << 8) | (1 << 10))
+#define ISP_CLK_EN          ((1 << 1) | (1 << 9) | (1 << 11))
+
+int pxa988_isp_power_control(int on)
+{
+	unsigned int val;
+	int timeout = 5000;
+
+	/*  HW mode power on/off*/
+	if (on) {
+		/* set isp HW mode*/
+		val = __raw_readl(APMU_ISPDXO);
+		val |= ISP_HW_MODE;
+		__raw_writel(val, APMU_ISPDXO);
+
+		spin_lock(&gc_vpu_isp_pwr_lock);
+		/*  on1, on2, off timer */
+		__raw_writel(0x20001fff, APMU_PWR_BLK_TMR_REG);
+
+		/*  isp auto power on */
+		val = __raw_readl(APMU_PWR_CTRL_REG);
+		val |= ISP_AUTO_PWR_ON;
+		__raw_writel(val, APMU_PWR_CTRL_REG);
+		spin_unlock(&gc_vpu_isp_pwr_lock);
+
+		/*  polling ISP_PWR_STAT bit */
+		while (!(__raw_readl(APMU_PWR_STATUS_REG) & ISP_PWR_STAT)) {
+			udelay(500);
+			timeout -= 500;
+			if (timeout < 0) {
+				pr_err("%s: isp power on timeout\n", __func__);
+				return -ENODEV;
+			}
+		}
+
+	} else {
+		spin_lock(&gc_vpu_isp_pwr_lock);
+		/*  isp auto power off */
+		val = __raw_readl(APMU_PWR_CTRL_REG);
+		val &= ~ISP_AUTO_PWR_ON;
+		__raw_writel(val, APMU_PWR_CTRL_REG);
+		spin_unlock(&gc_vpu_isp_pwr_lock);
+
+		/*  polling ISP_PWR_STAT bit */
+		while ((__raw_readl(APMU_PWR_STATUS_REG) & ISP_PWR_STAT)) {
+			udelay(500);
+			timeout -= 500;
+			if (timeout < 0) {
+				pr_err("%s: ISP power off timeout\n", __func__);
+				return -ENODEV;
+			}
+		}
+
+	}
+
+	return 0;
+}
+
+#define LCD_CI_ISP_ACLK_EN		(1 << 3)
+#define LCD_CI_ISP_ACLK_RST		(1 << 16)
+int pxa988_isp_reset_hw(void *param)
+{
+	unsigned int val;
+
+	/*disable isp clock*/
+	val = __raw_readl(APMU_ISPDXO);
+	val &= ~ISP_CLK_EN;
+	__raw_writel(val, APMU_ISPDXO);
+
+#if defined(ENABLE_LCD_RST)
+	val = __raw_readl(APMU_LCD);
+	val &= ~LCD_CI_ISP_ACLK_EN;
+	__raw_writel(val, APMU_LCD);
+
+	/*reset clock*/
+	val = __raw_readl(APMU_LCD);
+	val &= ~LCD_CI_ISP_ACLK_RST;
+	__raw_writel(val, APMU_LCD);
+#endif
+
+	/*reset isp clock*/
+	val = __raw_readl(APMU_ISPDXO);
+	val &= ~ISP_CLK_RST;
+	__raw_writel(val, APMU_ISPDXO);
+
+	/*de-reset isp clock*/
+	val = __raw_readl(APMU_ISPDXO);
+	val |= ISP_CLK_RST;
+	__raw_writel(val, APMU_ISPDXO);
+
+#if defined(ENABLE_LCD_RST)
+	val = __raw_readl(APMU_LCD);
+	val |= LCD_CI_ISP_ACLK_RST;
+	__raw_writel(val, APMU_LCD);
+
+	val = __raw_readl(APMU_LCD);
+	val |= LCD_CI_ISP_ACLK_EN;
+	__raw_writel(val, APMU_LCD);
+#endif
+
+	/*enable isp clock*/
+	val = __raw_readl(APMU_ISPDXO);
+	val |= ISP_CLK_EN;
+	__raw_writel(val, APMU_ISPDXO);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_UIO_MVISP
+static u64 pxa_uio_mvisp_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource pxa_uio_mvisp_resources[] = {
+	[0] = {
+		.start	= 0xD4240000,
+		.end	= 0xD427FFFF,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+struct platform_device pxa_device_mvisp = {
+	.name	= "uio-mvisp",
+	.id	= 0,
+	.dev	= {
+		.dma_mask = &pxa_uio_mvisp_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource	= pxa_uio_mvisp_resources,
+	.num_resources = ARRAY_SIZE(pxa_uio_mvisp_resources),
+};
+
+void __init pxa_register_uio_mvisp(void)
+{
+	int ret;
+
+	ret = platform_device_register(&pxa_device_mvisp);
+	if (ret)
+		dev_err(&(pxa_device_mvisp.dev),
+			"unable to register uio mvisp device:%d\n", ret);
+}
+#endif
diff --git a/arch/arm/mach-mmp/pxa988_headsmp.S b/arch/arm/mach-mmp/pxa988_headsmp.S
new file mode 100644
index 00000000..35ddf5c6
--- /dev/null
+++ b/arch/arm/mach-mmp/pxa988_headsmp.S
@@ -0,0 +1,278 @@
+/*
+ * linux/arch/arm/mach-mmp/pxa988_headsmp.S
+ *
+ * Copyright (C) 2012 Marvell, Inc.
+ *
+ * Author: Neil Zhang <zhangwm@marvell.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/memory.h>
+#include <mach/addr-map.h>
+#include <mach/pxa988_lowpower.h>
+
+	__CPUINIT
+
+/*
+ * PXA specific entry point for secondary CPUs.  This provides
+ * a "holding pen" into which all secondary cores are held until we're
+ * ready for them to initialise.
+ */
+ENTRY(pxa988_secondary_startup)
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+
+/*
+ * Note: Architecturally, caches are not guaranteed to be in a known state
+ * at reset.
+ * - need to be invalidated by software on Cortex-A9.
+ * - not required on Cortex-A5/A7/A15.
+ */
+#ifdef CONFIG_CPU_CA9MP
+	bl	v7_invalidate_l1
+#endif
+
+	b	secondary_startup
+ENDPROC(pxa988_secondary_startup)
+
+	.align	2
+1:	.long	.
+	.long	pen_release
+
+
+/*
+ * Note: The following code is located into the .data section. This is to
+ *       allow sw_reset_flag and cpu_plugin_handler to be accessed with a
+ *       relative load while we can't rely on any MMU translation.
+ *       Reference from: arch/arm/kernel/sleep.S
+ */
+
+	.data
+	.align
+
+#ifdef CONFIG_HOTPLUG_CPU
+
+#ifdef CONFIG_HAVE_ARM_SCU
+#define SCU_CPU_POWER_STATUS	(SCU_PHYS_BASE + 0x08)
+#endif
+
+#define PMU_PHYS_BASE		(AXI_PHYS_BASE + 0x82800)
+#define PMU_CORE0_IDLE_CFG_PHYS	(PMU_PHYS_BASE + 0x0124)
+#define PMU_CORE1_IDLE_CFG_PHYS	(PMU_PHYS_BASE + 0x0128)
+#define PMU_CORE2_IDLE_CFG_PHYS	(PMU_PHYS_BASE + 0x0160)
+#define PMU_CORE3_IDLE_CFG_PHYS	(PMU_PHYS_BASE + 0x0164)
+
+#define PMU_MP_IDLE_CFG0_PHYS	(PMU_PHYS_BASE + 0x0120)
+#define PMU_MP_IDLE_CFG1_PHYS	(PMU_PHYS_BASE + 0x00e4)
+#define PMU_MP_IDLE_CFG2_PHYS	(PMU_PHYS_BASE + 0x0150)
+#define PMU_MP_IDLE_CFG3_PHYS	(PMU_PHYS_BASE + 0x0154)
+
+#define ICU_PHYS_BASE		(AXI_PHYS_BASE + 0x82000)
+#if defined(CONFIG_CPU_PXA988)
+#define ICU_C0_GBL_INT_MSK_PHYS	(ICU_PHYS_BASE + 0x114)
+#define ICU_C1_GBL_INT_MSK_PHYS	(ICU_PHYS_BASE + 0x144)
+#elif defined(CONFIG_CPU_PXA1088)
+#define ICU_C0_GBL_INT_MSK_PHYS	(ICU_PHYS_BASE + 0x228)
+#define ICU_C1_GBL_INT_MSK_PHYS	(ICU_PHYS_BASE + 0x238)
+#endif
+#define ICU_C2_GBL_INT_MSK_PHYS	(ICU_PHYS_BASE + 0x248)
+#define ICU_C3_GBL_INT_MSK_PHYS	(ICU_PHYS_BASE + 0x258)
+
+#define GIC_GLABAL_MASK	(PMUA_GIC_IRQ_GLOBAL_MASK | PMUA_GIC_FIQ_GLOBAL_MASK)
+#define ICU_GLABAL_MASK	(ICU_MASK_FIQ | ICU_MASK_IRQ)
+
+#ifdef CONFIG_CPU_PXA988
+#define CORE_IDLE_MASK	(PMUA_CORE_IDLE | PMUA_CORE_POWER_DOWN | \
+			PMUA_CORE_L1_SRAM_POWER_DOWN)
+#define MP_IDLE_MASK	(PMUA_MP_IDLE | PMUA_MP_POWER_DOWN |	\
+			PMUA_MP_L2_SRAM_POWER_DOWN |		\
+			PMUA_MP_SCU_SRAM_POWER_DOWN)
+#elif defined(CONFIG_CPU_PXA1088)
+#define CORE_IDLE_MASK	(PMUA_CORE_IDLE | PMUA_CORE_POWER_DOWN)
+#define MP_IDLE_MASK	(PMUA_MP_IDLE | PMUA_MP_POWER_DOWN |	\
+			PMUA_MP_L2_SRAM_POWER_DOWN)
+#endif
+
+/* r0, keep to CPUID */
+ENTRY(pxa988_return_handler)
+	/* Get the physical address of pm_reserve_pa */
+	ldr	r1, =pm_reserve_pa
+	sub	r1, r1, #PAGE_OFFSET
+	add	r1, r1, #PLAT_PHYS_OFFSET
+
+	/* Load the reserved memory address */
+	ldr	r1, [r1]
+
+	@ barrier to make sure all cores have been waken
+	mov     r2, #OFFSET_BARRIER
+	add     r2, r2, r1
+
+	dmb
+
+	@ barrier_inc
+	ldr	r3, [r2, r0, lsl #2]
+	add	r3, r3, #1
+	str	r3, [r2, r0, lsl #2]
+	dmb
+
+	@ no need to spin checking other core's status here
+	@ since it is impossible first core to be here.
+
+	/* mask GIC interrtup */
+	cmp	r0, #0
+	ldreq   r1, =PMU_CORE0_IDLE_CFG_PHYS
+	cmp	r0, #1
+	ldreq   r1, =PMU_CORE1_IDLE_CFG_PHYS
+	cmp	r0, #2
+	ldreq   r1, =PMU_CORE2_IDLE_CFG_PHYS
+	cmp	r0, #3
+	ldreq   r1, =PMU_CORE3_IDLE_CFG_PHYS
+
+	ldr     r2, [r1]
+	orr	r2, r2, #GIC_GLABAL_MASK
+	str	r2, [r1]
+
+	/* Mask ICU global interrupt */
+	cmp	r0, #0
+	ldreq	r1, =ICU_C0_GBL_INT_MSK_PHYS
+	cmp	r0, #1
+	ldreq	r1, =ICU_C1_GBL_INT_MSK_PHYS
+	cmp	r0, #2
+	ldreq	r1, =ICU_C2_GBL_INT_MSK_PHYS
+	cmp	r0, #3
+	ldreq	r1, =ICU_C3_GBL_INT_MSK_PHYS
+
+	ldr     r2, [r1]
+	orr	r2, r2, #ICU_GLABAL_MASK
+	str 	r2, [r1]
+
+	b	cpu_v7_do_idle
+ENDPROC(pxa988_return_handler)
+
+/* r0, keep to CPUID */
+ENTRY(pxa988_hotplug_handler)
+	/* Get the physical address of pm_reserve_pa */
+	ldr	r1, =pm_reserve_pa
+	sub	r1, r1, #PAGE_OFFSET
+	add	r1, r1, #PLAT_PHYS_OFFSET
+
+	/* Load the reserved memory address */
+	ldr	r2, [r1]
+	/* clear all flags for current core */
+	mov	r3, #0
+	str	r3, [r2, r0, lsl #2]    @ clear all flags
+
+#ifdef CONFIG_HAVE_ARM_SCU
+	/* scu_power_mode(scu_base_addr, SCU_PM_NORMAL) */
+	ldr     r1, =SCU_CPU_POWER_STATUS
+	ldrb    r2, [r1, r0]
+	bic     r2, r2, #0x3
+	strb    r2, [r1, r0]
+#endif
+	/* Unmask GIC interrtup */
+	cmp	r0, #0
+	ldreq   r1, =PMU_CORE0_IDLE_CFG_PHYS
+	cmp	r0, #1
+	ldreq   r1, =PMU_CORE1_IDLE_CFG_PHYS
+	cmp	r0, #2
+	ldreq   r1, =PMU_CORE2_IDLE_CFG_PHYS
+	cmp	r0, #3
+	ldreq   r1, =PMU_CORE3_IDLE_CFG_PHYS
+
+	ldr     r2, [r1]
+	bic	r2, r2, #GIC_GLABAL_MASK
+	str	r2, [r1]
+
+	/* Mask ICU global interrupt */
+	cmp	r0, #0
+	ldreq	r1, =ICU_C0_GBL_INT_MSK_PHYS
+	cmp	r0, #1
+	ldreq	r1, =ICU_C1_GBL_INT_MSK_PHYS
+	cmp	r0, #2
+	ldreq	r1, =ICU_C2_GBL_INT_MSK_PHYS
+	cmp	r0, #3
+	ldreq	r1, =ICU_C3_GBL_INT_MSK_PHYS
+
+	ldr     r2, [r1]
+	orr	r2, r2, #ICU_GLABAL_MASK
+	str 	r2, [r1]
+
+	/* reset the core idle config register */
+	cmp	r0, #0
+	ldreq   r1, =PMU_CORE0_IDLE_CFG_PHYS
+	cmp	r0, #1
+	ldreq   r1, =PMU_CORE1_IDLE_CFG_PHYS
+	cmp	r0, #2
+	ldreq   r1, =PMU_CORE2_IDLE_CFG_PHYS
+	cmp	r0, #3
+	ldreq   r1, =PMU_CORE3_IDLE_CFG_PHYS
+
+	ldr     r2, [r1]
+	bic	r2, r2, #CORE_IDLE_MASK
+	str 	r2, [r1]
+
+
+	/* reset the MP idle config register */
+	cmp     r0, #0
+	ldreq   r1, =PMU_MP_IDLE_CFG0_PHYS
+	cmp     r0, #1
+	ldreq   r1, =PMU_MP_IDLE_CFG1_PHYS
+	cmp     r0, #2
+	ldreq   r1, =PMU_MP_IDLE_CFG2_PHYS
+	cmp     r0, #3
+	ldreq   r1, =PMU_MP_IDLE_CFG3_PHYS
+
+	ldr     r2, [r1]
+	bic	r2, r2, #MP_IDLE_MASK
+	str     r2, [r1]
+
+	/* jump to secondary cpu startup routine */
+	ldr     r1, secondary_cpu_handler
+	mov	pc, r1
+ENDPROC(pxa988_hotplug_handler)
+#endif
+
+/*
+ * ROM code jumps to this function while waking up from CPU
+ * OFF or software reset state. Physical address of the function is
+ * stored at CA9_WARM_RESET_VECTOR while system is bring up.
+ */
+ENTRY(pxa988_cpu_reset_entry)
+	ldr     r1, reset_handler_pa
+	mrc 	p15, 0, r0, c0, c0, 5
+	and     r0, r0, #15		@ fetch CPUID
+	ldr     r2, [r1, r0, lsl #2]    @ get the handler addr for this core
+	mov     pc, r2			@ jump to the handler
+ENDPROC(pxa988_cpu_reset_entry)
+
+	/* Point to the address that save handlers for each core */
+	.global reset_handler_pa
+reset_handler_pa:
+	.long   0
+
+	.globl secondary_cpu_handler
+secondary_cpu_handler:
+	.long   0
+
diff --git a/arch/arm/mach-mmp/pxa988_hotplug.c b/arch/arm/mach-mmp/pxa988_hotplug.c
new file mode 100644
index 00000000..40aa90ec
--- /dev/null
+++ b/arch/arm/mach-mmp/pxa988_hotplug.c
@@ -0,0 +1,74 @@
+/*
+ * linux/arch/arm/mach-mmp/ca9-hotplug.c
+ *
+ * Author:      Hong Feng <hongfeng@marvell.com>
+ * Copyright:   (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/completion.h>
+#include <linux/jiffies.h>
+
+#include <asm/cacheflush.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <mach/regs-apmu.h>
+#include <mach/pxa988_lowpower.h>
+#include <mach/features.h>
+
+static int pxa988_powergate_is_powered(u32 cpu)
+{
+#ifdef CONFIG_CPU_PXA988
+	if (has_feat_legacy_apmu_core_status())
+		return !(__raw_readl(APMU_CORE_STATUS) & (1 << (3 + 2 * cpu)));
+	else
+		return !(__raw_readl(APMU_CORE_STATUS) & (1 << (4 + 3 * cpu)));
+#elif defined(CONFIG_CPU_PXA1088)
+	return !(__raw_readl(APMU_CORE_STATUS) & (1 << (7 + 3 * cpu)));
+#endif
+}
+
+/*
+ * called from the request cpu,
+ * make sure the target cpu is actully down after return
+ */
+int platform_cpu_kill(unsigned int cpu)
+{
+	int count = 10000;
+	while (count--) {
+		if (!pxa988_powergate_is_powered(cpu)) {
+			pr_info("CPU%u: real shutdown\n", cpu);
+			return 1;
+		}
+
+		udelay(10);
+	}
+
+	return 0;
+}
+
+/*
+ * platform-specific code to shutdown a CPU,
+ * Called with IRQs disabled
+ */
+void platform_cpu_die(unsigned int cpu)
+{
+	/* we're ready for shutdown now, so do it */
+	pxa988_hotplug_enter(cpu, PXA988_LPM_D2_UDR);
+	/* Never get here, Reset from pxa988_secondary_startup */
+	panic("core reset should never get here");
+}
+
+int platform_cpu_disable(unsigned int cpu)
+{
+	/*
+	 * we don't allow CPU 0 to be shutdown (it is still too special
+	 * e.g. clock tick interrupts)
+	 */
+	return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/mach-mmp/pxa988_lowpower.c b/arch/arm/mach-mmp/pxa988_lowpower.c
new file mode 100644
index 00000000..c27af660
--- /dev/null
+++ b/arch/arm/mach-mmp/pxa988_lowpower.c
@@ -0,0 +1,1182 @@
+/*
+ * linux/arch/arm/mach-mmp/pxa988_lowpower.c
+ *
+ * Author:	Raul Xiong <xjian@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/cpu_pm.h>
+#include <linux/spinlock.h>
+#include <linux/clockchips.h>
+#include <linux/pm_qos.h>
+#include <asm/mach/map.h>
+#include <asm/suspend.h>
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/cp15.h>
+#include <asm/smp_scu.h>
+#include <asm/hardware/gic.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <mach/pxa988_lowpower.h>
+#include <mach/clock-pxa988.h>
+#include <mach/regs-apmu.h>
+#include <mach/regs-mpmu.h>
+#include <mach/regs-icu.h>
+#include <mach/regs-mcu.h>
+#include <mach/cputype.h>
+#include <mach/features.h>
+#include <mach/scu.h>
+#include <mach/reset-pxa988.h>
+#include <mach/gpio-edge.h>
+#include <plat/pxa_trace.h>
+#include "common.h"
+
+/*
+ * The topology of the reserved data is as following.
+ * Each core will use 4 bytes to save the flags.
+ * The base address is pointed by pm_reserve_pa
+ *
+ * +--------------------------------------------------------+
+ * | ... | hotplug | LPM[MAX_NUM_LPM - 1] | LPM[1] | LPM[0] |(PXA988/1088)
+ * +--------------------------------------------------------+
+ * | ... | hotplug | LPM[MAX_NUM_LPM - 1] | LPM[1] | LPM[0] |(PXA988/1088)
+ * +--------------------------------------------------------+
+ * | ... | hotplug | LPM[MAX_NUM_LPM - 1] | LPM[1] | LPM[0] |(PXA1088 only)
+ * +--------------------------------------------------------+
+ * | ... | hotplug | LPM[MAX_NUM_LPM - 1] | LPM[1] | LPM[0] |(PXA1088 only)
+ * +--------------------------------------------------------+
+ * |     scu power down flag                                |(PXA988 only)
+ * +--------------------------------------------------------+
+ * |     spin_lock                                          |(PXA988 only)
+ * +--------------------------------------------------------+
+ *
+ * There are totally seven low power modes defined for PXA988
+ * and PXA1088.
+ * Please refer mach/pxa988_lowpower.h.
+ *
+ * 1. PXA988_LPM_C1: POWER_MODE_CORE_INTIDLE
+ * 2. PXA988_LPM_C2: POWER_MODE_CORE_POWERDOWN with L1 shutdown, L2 retentive
+ * 3. PXA988_LPM_D1P: POWER_MODE_APPS_IDLE with L2 retentive
+ * 4. PXA988_LPM_D1: POWER_MODE_SYS_SLEEP with L2 retentive
+ * 5. PXA988_LPM_D2: POWER_MODE_UDR_VCTCXO with L2 retentive
+ * 6. PXA988_LPM_D2_UDR: POWER_MODE_UDR with L2 shutdown
+ */
+
+static char *coherent_buf;
+static u32 num_cpus;
+static u32 *enter_lpm_p;
+static u32 *mp_restore;
+static arch_spinlock_t *lpm_lock_p;
+#ifdef CONFIG_ARM_ERRATA_802022
+static volatile u32 *barrier;
+#endif
+
+static int (*finish_func)(unsigned long param);
+
+#define IPCA_VIRT_BASE  (APB_VIRT_BASE + 0x1D000)
+
+enum {
+	CPU_SUSPEND_FROM_IDLE,
+	CPU_SUSPEND_FROM_HOTPLUG,
+	CPU_SUSPEND_FROM_SUSPEND,
+};
+
+static DEFINE_SPINLOCK(pmu_lock);
+static unsigned long flags;
+
+static const u32 APMU_CORE_IDLE_CFG[CONFIG_NR_CPUS] = {
+	(u32)PMU_CORE0_IDLE_CFG, (u32)PMU_CORE1_IDLE_CFG,
+#ifdef CONFIG_CPU_PXA1088
+	(u32)PMU_CORE2_IDLE_CFG, (u32)PMU_CORE3_IDLE_CFG,
+#endif
+};
+static const u32 APMU_MP_IDLE_CFG[CONFIG_NR_CPUS] = {
+	(u32)PMU_MP_IDLE_CFG0, (u32)PMU_MP_IDLE_CFG1,
+#ifdef CONFIG_CPU_PXA1088
+	(u32)PMU_MP_IDLE_CFG2, (u32)PMU_MP_IDLE_CFG3,
+#endif
+};
+static const u32 ICU_AP_GBL_INT_MSK[] = {
+#if defined(CONFIG_CPU_PXA988)
+	(u32)PXA988_ICU_A9C0_GBL_INT_MSK, (u32)PXA988_ICU_A9C1_GBL_INT_MSK,
+#elif defined(CONFIG_CPU_PXA1088)
+	(u32)PXA1088_ICU_APC0_GBL_INT_MSK, (u32)PXA1088_ICU_APC1_GBL_INT_MSK,
+	(u32)PXA1088_ICU_APC2_GBL_INT_MSK, (u32)PXA1088_ICU_APC3_GBL_INT_MSK,
+#endif
+};
+
+/*
+ * To avoid multi-cores are accessing the same PMU register,
+ * any functions MUST call pmu_register_lock before accessing
+ * the PMU register and pmu_register_unlock after it.
+ */
+void pmu_register_lock()
+{
+	spin_lock_irqsave(&pmu_lock, flags);
+}
+
+void pmu_register_unlock()
+{
+	spin_unlock_irqrestore(&pmu_lock, flags);
+}
+
+static inline void core_exit_coherency(void)
+{
+	unsigned int v;
+	asm volatile(
+	"       mrc     p15, 0, %0, c1, c0, 1\n"
+	"       bic     %0, %0, #(1 << 6)\n"
+	"       mcr     p15, 0, %0, c1, c0, 1\n"
+	: "=&r" (v) : : "cc");
+	isb();
+}
+
+static inline void disable_l1_dcache(void)
+{
+	unsigned int v;
+	asm volatile(
+	"       mrc     p15, 0, %0, c1, c0, 0\n"
+	"       bic     %0, %0, %1\n"
+	"       mcr     p15, 0, %0, c1, c0, 0\n"
+	: "=&r" (v) : "Ir" (CR_C) : "cc");
+	isb();
+}
+
+static inline void core_enter_coherency(void)
+{
+	unsigned int v;
+	asm volatile(
+	"       mrc     p15, 0, %0, c1, c0, 1\n"
+	"       orr     %0, %0, #(1 << 6)\n"
+	"       mcr     p15, 0, %0, c1, c0, 1\n"
+	: "=&r" (v) : : "cc");
+	isb();
+}
+
+static inline void enable_l1_dcache(void)
+{
+	unsigned int v;
+	asm volatile(
+	"       mrc     p15, 0, %0, c1, c0, 0\n"
+	"       orr     %0, %0, %1\n"
+	"       mcr     p15, 0, %0, c1, c0, 0\n"
+	: "=&r" (v) : "Ir" (CR_C) : "cc");
+	isb();
+}
+
+static inline void ca7_pwr_down(void)
+{
+	unsigned int v;
+	asm volatile(
+	/* Disable L1 Cache */
+	"       mrc     p15, 0, %0, c1, c0, 0\n"
+	"       bic     %0, %0, %1\n"
+	"       mcr     p15, 0, %0, c1, c0, 0\n"
+#ifdef CONFIG_ARM_ERRATA_794322
+	"	ldr	%0, =_stext\n"
+	"       mcr     p15, 0, %0, c8, c7, 1\n"
+	"	dsb\n"
+#endif
+	/* L1 data Cache clean and invalidate */
+	"	bl	v7_flush_dcache_louis\n"
+	"	clrex\n"
+	/* Core Exit SMP*/
+	"       mrc     p15, 0, %0, c1, c0, 1\n"
+	"       bic	%0, %0, #(1 << 6)\n"
+	"       mcr     p15, 0, %0, c1, c0, 1\n"
+	"	isb\n"
+	"	b	cpu_v7_do_idle\n"
+	: "=&r" (v) : "Ir" (CR_C) : "cc");
+}
+
+static inline void ca7_pwr_down_udr(void)
+{
+	unsigned int v;
+	asm volatile(
+	"       mrc     p15, 0, %0, c1, c0, 0\n"
+	"       bic     %0, %0, %1\n"
+	"       mcr     p15, 0, %0, c1, c0, 0\n"
+#ifdef CONFIG_ARM_ERRATA_794322
+	"	ldr	%0, =_stext\n"
+	"       mcr     p15, 0, %0, c8, c7, 1\n"
+	"	dsb\n"
+#endif
+	/* L1 data Cache clean and invalidate */
+	"	bl	v7_flush_dcache_louis\n"
+	"	clrex\n"
+	/* L1&L2 Cache clean and invalidate */
+	"	bl	v7_flush_kern_cache_all\n"
+	/* Core Exit SMP*/
+	"       mrc     p15, 0, %0, c1, c0, 1\n"
+	"       bic	%0, %0, #(1 << 6)\n"
+	"       mcr     p15, 0, %0, c1, c0, 1\n"
+	"	isb\n"
+	"	b	cpu_v7_do_idle\n"
+	: "=&r" (v) : "Ir" (CR_C) : "cc");
+}
+
+static int pxa1088_finish_suspend(unsigned long param)
+{
+	u32 icdispr = readl_relaxed(GIC_DIST_VIRT_BASE + GIC_DIST_PENDING_SET);
+	if (icdispr)  {
+		if (param == CPU_SUSPEND_FROM_HOTPLUG) {
+			/* This is used to enable serial log output */
+			set_cpu_online(smp_processor_id(), true);
+			panic("Hotplug procedure got Pending PPI IRQ(0x%X)\n", icdispr);
+		} else if (param == CPU_SUSPEND_FROM_IDLE)
+			goto idle_fall_back;
+	}
+
+	if (unlikely(param == CPU_SUSPEND_FROM_SUSPEND))
+		ca7_pwr_down_udr();
+	else
+		ca7_pwr_down();
+
+idle_fall_back:
+
+	core_enter_coherency();
+
+	enable_l1_dcache();
+
+	/* clear percpu flag in this path */
+	enter_lpm_p[smp_processor_id()] = 0;
+
+	return INVALID_LPM;
+}
+static int pxa988_finish_suspend(unsigned long param)
+{
+	u32 icdispr;
+
+	/* clean & invalidate dcache cache, it contains dsb & isb */
+	flush_cache_all();
+
+	/*
+	 * Clear the SCTLR.C bit to prevent further data cache
+	 * allocation. Clearing SCTLR.C would make all the data accesses
+	 * strongly ordered and would not hit the cache.
+	 */
+	disable_l1_dcache();
+	/* Clear ACTLR.SMP bit */
+	core_exit_coherency();
+
+#ifdef CONFIG_HAVE_ARM_SCU
+	/*
+	 * Switch the CPU from Symmetric Multiprocessing (SMP) mode
+	 * to AsymmetricMultiprocessing (AMP) mode by programming
+	 * the SCU power status to DORMANT or OFF mode.
+	 * This enables the CPU to be taken out of coherency by
+	 * preventing the CPU from receiving cache, TLB, or BTB
+	 * maintenance operations broadcast by other CPUs in
+	 * the cluster.
+	 * NOTE:
+	 * This must be done after cache is flushed.
+	 */
+	scu_power_mode(pxa_scu_base_addr(), SCU_PM_POWEROFF);
+#endif
+
+	/* For suspend case we power down L2 sram
+	 * so need to flush L2 here
+	 */
+	if (unlikely(param == CPU_SUSPEND_FROM_SUSPEND)) {
+#ifdef CONFIG_CACHE_L2X0
+		pl310_disable();
+#endif
+	}
+	/*
+	 * FIXME: There is risk that Dragon will enter M2 even there is an
+	 * interrupt pending. SW need to check it before issue wfi,
+	 * if yes, just jump out.
+	 * It will be fixed in Z3 and further, we won't need it then.
+	 */
+	icdispr = readl_relaxed(GIC_DIST_VIRT_BASE + GIC_DIST_PENDING_SET);
+	if (icdispr) {
+		/*
+		 * FIXME: There may be pending local timer interrupt on hotplug
+		 * out core, this cause hotplug failed since we will jump out.
+		 * Clear the interrupt for Hotplug scenario.
+		 */
+		if (unlikely(param == CPU_SUSPEND_FROM_HOTPLUG))
+			writel_relaxed(icdispr, GIC_DIST_VIRT_BASE
+					+ GIC_DIST_PENDING_CLEAR);
+		else
+			goto back;
+	}
+
+	cpu_do_idle();
+
+back:
+
+#ifdef CONFIG_HAVE_ARM_SCU
+	/*
+	 * Ensure the CPU power state is set to NORMAL in
+	 * SCU power state so that CPU is back in coherency.
+	 * In non-coherent mode CPU can lock-up and lead to
+	 * system deadlock.
+	 */
+	scu_power_mode(pxa_scu_base_addr(), SCU_PM_NORMAL);
+#endif
+	core_enter_coherency();
+
+	enable_l1_dcache();
+
+	/* clear percpu flag in this path */
+	enter_lpm_p[smp_processor_id()] = 0;
+
+	return INVALID_LPM;
+}
+
+static void pxa988_lowpower_config(u32 cpu,
+			u32 power_state, u32 lowpower_enable)
+{
+	u32 core_idle_cfg, mp_idle_cfg, apcr;
+	u32 mc_slp_type = 0;
+	u8 apmu_debug_byte1 = 0;
+	u8 apmu_debug_byte2 = 0;
+
+	pmu_register_lock();
+	core_idle_cfg = __raw_readl(APMU_CORE_IDLE_CFG[cpu]);
+	mp_idle_cfg = __raw_readl(APMU_MP_IDLE_CFG[cpu]);
+	apcr = __raw_readl(MPMU_APCR);
+	if (has_feat_debugreg_in_d1p() && !has_feat_d1p_hipwr()) {
+		mc_slp_type = __raw_readl(APMU_MC_HW_SLP_TYPE);
+		apmu_debug_byte1 = __raw_readb(APMU_DEBUG + 1);
+		apmu_debug_byte2 = __raw_readb(APMU_DEBUG + 2);
+	}
+
+	if (lowpower_enable) {
+		switch (power_state) {
+		case POWER_MODE_UDR:
+			mp_idle_cfg |= PMUA_MP_L2_SRAM_POWER_DOWN;
+			/*
+			 * FIXME:
+			 * Workaround for EMEI-166:
+			 * CA9 SCU ram and L2 sram power switch control signals
+			 * are mistakenly cross-connected.
+			 *
+			 * The workaround keeps SCU/L2 retention state as the
+			 * same on Zx.
+			 * This is supposed to be fixed on A0.
+			 */
+			if (has_feat_scu_l2_power_connection())
+				mp_idle_cfg |= PMUA_MP_SCU_SRAM_POWER_DOWN;
+			apcr |= PMUM_VCTCXOSD;
+			/* fall through */
+		case POWER_MODE_UDR_VCTCXO:
+			apcr |= PMUM_STBYEN;
+			/* fall through */
+		case POWER_MODE_SYS_SLEEP:
+			apcr |= PMUM_APBSD;
+			/* fall through */
+		case POWER_MODE_APPS_SLEEP:
+			apcr |= PMUM_SLPEN;
+			/* For Z1/Z2 we vote AXISD and DDRCORSD here*/
+			if (has_feat_d1p_hipwr()) {
+				apcr |= PMUM_AXISD;
+				apcr |= PMUM_DDRCORSD;
+			}
+			/* For A0 or newer stepping we vote DDRCORSD here */
+			if (!has_feat_debugreg_in_d1p())
+				apcr |= PMUM_DDRCORSD;
+			/* fall through */
+		case POWER_MODE_APPS_IDLE:
+			/* For Z3/A0 or newer stepping we vote AXISD here */
+			if (!has_feat_d1p_hipwr())
+				apcr |= PMUM_AXISD;
+			/* For Z3 we vote DDRCORSD here */
+			if (has_feat_debugreg_in_d1p() && !has_feat_d1p_hipwr())
+				apcr |= PMUM_DDRCORSD;
+			/* enable gpio edge for the modes need wakeup source */
+			mmp_gpio_edge_enable();
+			/* fall through */
+		case POWER_MODE_CORE_POWERDOWN:
+			core_idle_cfg |= PMUA_CORE_POWER_DOWN;
+			if (cpu_is_pxa988())
+				core_idle_cfg |= PMUA_CORE_L1_SRAM_POWER_DOWN;
+			mp_idle_cfg |= PMUA_MP_POWER_DOWN;
+			if (!has_feat_scu_l2_power_connection())
+				mp_idle_cfg |= PMUA_MP_SCU_SRAM_POWER_DOWN;
+			/*
+			 * FIXME: This is a temporary workaround for D1/D2 hang
+			 * issue. DE confirmed that D1/D2 may hang due to
+			 * missing mpsub_idle_clk_off_ack.
+			 * Mask MP clock off State check can be a SW workaround.
+			 * Will remove this workaround when the issue is fixed.
+			 * Index: EMEI-145
+			 */
+			mp_idle_cfg |= PMUA_MP_MASK_CLK_OFF;
+			/* fall through */
+		case POWER_MODE_CORE_EXTIDLE:
+			core_idle_cfg |= PMUA_CORE_IDLE;
+			mp_idle_cfg |= PMUA_MP_IDLE;
+			/* fall through */
+		case POWER_MODE_CORE_INTIDLE:
+			break;
+		default:
+			WARN(1, "Invalid power state!\n");
+		}
+
+		/*
+		 * For Z3 we need the D1P workaround.
+		 * Z1/Z2 don't use D1P because of EMEI-101 issue
+		 */
+		if (has_feat_debugreg_in_d1p() && !has_feat_d1p_hipwr() &&
+				power_state == POWER_MODE_APPS_IDLE) {
+			mc_slp_type &= ~0x7;
+			mc_slp_type |= 0x4;
+			apmu_debug_byte1 |= (1 << 6);
+			apmu_debug_byte2 |= (1 << 7);
+		}
+	} else {
+		core_idle_cfg &= ~(PMUA_CORE_IDLE | PMUA_CORE_POWER_DOWN);
+		mp_idle_cfg &= ~(PMUA_MP_IDLE | PMUA_MP_POWER_DOWN |
+				PMUA_MP_L2_SRAM_POWER_DOWN |
+				PMUA_MP_MASK_CLK_OFF);
+		if (cpu_is_pxa988()) {
+			core_idle_cfg &= ~(PMUA_CORE_L1_SRAM_POWER_DOWN);
+			mp_idle_cfg &= ~(PMUA_MP_SCU_SRAM_POWER_DOWN);
+		}
+		apcr &= ~(PMUM_DDRCORSD | PMUM_APBSD | PMUM_AXISD |
+			PMUM_VCTCXOSD | PMUM_STBYEN | PMUM_SLPEN);
+
+		if (has_feat_debugreg_in_d1p() && !has_feat_d1p_hipwr()) {
+			mc_slp_type &= ~0x7;
+			apmu_debug_byte1 &= ~(1 << 6);
+			apmu_debug_byte2 &= ~(1 << 7);
+		}
+		/* disable the gpio edge for cpu active states */
+		mmp_gpio_edge_disable();
+	}
+
+	__raw_writel(core_idle_cfg, APMU_CORE_IDLE_CFG[cpu]);
+	__raw_writel(mp_idle_cfg, APMU_MP_IDLE_CFG[cpu]);
+	__raw_writel(apcr, MPMU_APCR);
+	if (has_feat_debugreg_in_d1p() && !has_feat_d1p_hipwr()) {
+		__raw_writel(mc_slp_type, APMU_MC_HW_SLP_TYPE);
+		__raw_writeb(apmu_debug_byte1, APMU_DEBUG + 1);
+		__raw_writeb(apmu_debug_byte2, APMU_DEBUG + 2);
+	}
+	pmu_register_unlock();
+}
+
+#define DISABLE_ALL_WAKEUP_PORTS		\
+	(PMUM_SLPWP0 | PMUM_SLPWP1 | PMUM_SLPWP2 | PMUM_SLPWP3 |	\
+	 PMUM_SLPWP4 | PMUM_SLPWP5 | PMUM_SLPWP6 | PMUM_SLPWP7)
+/* Here we don't enable CP wakeup sources since CP will enable them */
+#define ENABLE_AP_WAKEUP_SOURCES	\
+	(PMUM_AP_ASYNC_INT | PMUM_AP_FULL_IDLE | PMUM_SQU_SDH1 | PMUM_SDH_23 |\
+	 PMUM_KEYPRESS | PMUM_WDT | PMUM_RTC_ALARM | PMUM_AP1_TIMER_1 |	\
+	 PMUM_AP1_TIMER_2 | PMUM_WAKEUP7 | PMUM_WAKEUP6 | PMUM_WAKEUP5 |\
+	 PMUM_AP2_TIMER_1 | PMUM_AP2_TIMER_2 |\
+	 PMUM_WAKEUP4 | PMUM_WAKEUP3 | PMUM_WAKEUP2)
+static u32 s_apcr, s_awucrm, s_wake_saved;
+/*
+ * Enable AP wakeup sources and ports. To enalbe wakeup
+ * ports, it needs both AP side to configure MPMU_APCR
+ * and CP side to configure MPMU_CPCR to really enable
+ * it. To enable wakeup sources, either AP side to set
+ * MPMU_AWUCRM or CP side to set MPMU_CWRCRM can really
+ * enable it.
+ */
+static void enable_ap_wakeup_sources(void)
+{
+	pmu_register_lock();
+	s_awucrm = __raw_readl(MPMU_AWUCRM);
+	s_apcr = __raw_readl(MPMU_APCR);
+	__raw_writel(s_awucrm | ENABLE_AP_WAKEUP_SOURCES, MPMU_AWUCRM);
+	__raw_writel(s_apcr & ~DISABLE_ALL_WAKEUP_PORTS, MPMU_APCR);
+	pmu_register_unlock();
+	s_wake_saved = 1;
+}
+
+static void restore_wakeup_sources(void)
+{
+	pmu_register_lock();
+	__raw_writel(s_awucrm, MPMU_AWUCRM);
+	__raw_writel(s_apcr, MPMU_APCR);
+	pmu_register_unlock();
+	s_wake_saved = 0;
+}
+
+static void pxa988_gic_global_mask(u32 cpu, u32 mask)
+{
+	u32 core_idle_cfg;
+
+	core_idle_cfg = __raw_readl(APMU_CORE_IDLE_CFG[cpu]);
+
+	if (mask) {
+		core_idle_cfg |= PMUA_GIC_IRQ_GLOBAL_MASK;
+		core_idle_cfg |= PMUA_GIC_FIQ_GLOBAL_MASK;
+	} else {
+		core_idle_cfg &= ~(PMUA_GIC_IRQ_GLOBAL_MASK |
+					PMUA_GIC_FIQ_GLOBAL_MASK);
+	}
+	__raw_writel(core_idle_cfg, APMU_CORE_IDLE_CFG[cpu]);
+}
+
+static void pxa988_icu_global_mask(u32 cpu, u32 mask)
+{
+	u32 icu_msk;
+
+	icu_msk = __raw_readl(ICU_AP_GBL_INT_MSK[cpu]);
+
+	if (mask) {
+		icu_msk |= ICU_MASK_FIQ;
+		icu_msk |= ICU_MASK_IRQ;
+	} else {
+		icu_msk &= ~(ICU_MASK_FIQ | ICU_MASK_IRQ);
+	}
+	__raw_writel(icu_msk, ICU_AP_GBL_INT_MSK[cpu]);
+}
+
+/* These states are used as idle replacement as well as suspend/hotplug */
+struct pxa988_lowpower_data pxa988_lpm_data[] = {
+	[PXA988_LPM_C1] = {
+		.power_state = POWER_MODE_CORE_INTIDLE,
+		.valid = 1,
+	},
+	[PXA988_LPM_C2] = {
+		.power_state = POWER_MODE_CORE_POWERDOWN,
+		.valid = 1,
+	},
+	[PXA988_LPM_D1P] = {
+		.power_state = POWER_MODE_APPS_IDLE,
+		.valid = 1,
+	},
+	[PXA988_LPM_D1] = {
+		.power_state = POWER_MODE_SYS_SLEEP,
+		.valid = 1,
+	},
+	[PXA988_LPM_D2] = {
+		.power_state = POWER_MODE_UDR_VCTCXO,
+		.valid = 1,
+	},
+	[PXA988_LPM_D2_UDR] = {
+		.power_state = POWER_MODE_UDR,
+		.valid = 1,
+	},
+	/* must always be the last one! */
+	[PXA988_MAX_LPM_INDEX] = {
+		.power_state = -1,
+		.valid = 0,
+	},
+};
+
+#ifdef CONFIG_PM
+void pxa988_enter_c1(u32 cpu)
+{
+	if (has_feat_ipc_wakeup_core()) {
+		/*
+		* Clear IPC GP_INT interrupt status in the ICU to de-assert
+		* the wake up signal before enter lpm.
+		*/
+		__raw_writel(0x400, IPCA_VIRT_BASE + 0xC);
+	}
+
+	pxa988_lowpower_config(cpu,
+			pxa988_lpm_data[PXA988_LPM_C1].power_state, 1);
+	trace_pxa_cpu_idle(LPM_ENTRY(PXA988_LPM_C1), cpu);
+
+	pxa988_cpu_dcstat_event(cpu, CPU_IDLE_ENTER, PXA988_LPM_C1);
+	cpu_do_idle();
+	pxa988_cpu_dcstat_event(cpu, CPU_IDLE_EXIT, PXA988_MAX_LPM_INDEX);
+
+	trace_pxa_cpu_idle(LPM_EXIT(PXA988_LPM_C1), cpu);
+	pxa988_lowpower_config(cpu,
+			pxa988_lpm_data[PXA988_LPM_C1].power_state, 0);
+}
+
+static void pxa988_pre_enter_lpm(u32 cpu, u32 power_mode)
+{
+	pxa988_lowpower_config(cpu,
+			pxa988_lpm_data[power_mode].power_state, 1);
+
+	/* Mask GIC global interrupt */
+	pxa988_gic_global_mask(cpu, 1);
+	/* Mask ICU global interrupt */
+	pxa988_icu_global_mask(cpu, 1);
+
+	if (has_feat_ipc_wakeup_core()) {
+		/*
+		* Clear the IPC GP_INT interrupt status in the ICU to de-assert
+		* the wake up signal before enter lpm.
+		*/
+		__raw_writel(0x400, IPCA_VIRT_BASE + 0xC);
+	}
+}
+
+static void pxa988_post_enter_lpm(u32 cpu, u32 power_mode)
+{
+	/* Unmask GIC interrtup */
+	pxa988_gic_global_mask(cpu, 0);
+	/*
+	 * FIXME: Do we need to mask ICU before cpu_cluster_pm_exit
+	 * to avoid GIC ID31 interrupt?
+	 */
+	/* Mask ICU global interrupt */
+	pxa988_icu_global_mask(cpu, 1);
+
+	pxa988_lowpower_config(cpu,
+			pxa988_lpm_data[power_mode].power_state, 0);
+}
+
+static void pxa988_check_constraint(unsigned long constraint)
+{
+	switch (constraint) {
+	case PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE:
+		pxa988_lpm_data[PXA988_LPM_D1P].valid = 1;
+		pxa988_lpm_data[PXA988_LPM_D1].valid = 1;
+		pxa988_lpm_data[PXA988_LPM_D2].valid = 1;
+		break;
+	case PM_QOS_CPUIDLE_BLOCK_VCTCXO_VALUE:
+		pxa988_lpm_data[PXA988_LPM_D1P].valid = 1;
+		pxa988_lpm_data[PXA988_LPM_D1].valid = 1;
+		pxa988_lpm_data[PXA988_LPM_D2].valid = 0;
+		break;
+	case PM_QOS_CPUIDLE_BLOCK_DDR_VALUE:
+		pxa988_lpm_data[PXA988_LPM_D1P].valid = 1;
+		pxa988_lpm_data[PXA988_LPM_D1].valid = 0;
+		pxa988_lpm_data[PXA988_LPM_D2].valid = 0;
+		break;
+	case PM_QOS_CPUIDLE_BLOCK_AXI_VALUE:
+		pxa988_lpm_data[PXA988_LPM_D1P].valid = 0;
+		pxa988_lpm_data[PXA988_LPM_D1].valid = 0;
+		pxa988_lpm_data[PXA988_LPM_D2].valid = 0;
+		break;
+	default:
+		pr_err("cpuidle blocked by an unknown state!\n");
+	}
+}
+
+/*
+ * For Zx stepping, MCK4 table 0 is triggered when system exits
+ * from D1P, which is unnecessary. Make a workaround to skip table
+ * 0 if only entering LPM no deeper than D1P and restore table 0
+ * if going to D1 or deeper LPM.
+ */
+#define DLL_RST_SKIP	(0x2000C)
+#define DLL_RST_RESTORE	(0xC)
+static void ddr_dll_rst_wkr(int skip)
+{
+	int dll_rst = 0;
+
+	if (has_feat_mck4_table0_trigger()) {
+		if (skip) {
+			/* skip DLL reset in MCK4 table 0 */
+			dll_rst = DLL_RST_SKIP;
+			trace_pxa_ddr_lpm(dll_rst);
+			__raw_writel(0x0, DMCU_VIRT_REG(DMCU_HWTDAT0));
+			__raw_writel(dll_rst, DMCU_VIRT_REG(DMCU_HWTDAT1));
+			__raw_writel(0x0, DMCU_VIRT_REG(DMCU_HWTCTRL));
+		} else {
+			/* restore DLL reset in MCK4 table 0 */
+			dll_rst = DLL_RST_RESTORE;
+			trace_pxa_ddr_lpm(dll_rst);
+			__raw_writel(0x0, DMCU_VIRT_REG(DMCU_HWTDAT0));
+			__raw_writel(dll_rst, DMCU_VIRT_REG(DMCU_HWTDAT1));
+			__raw_writel(0x0, DMCU_VIRT_REG(DMCU_HWTCTRL));
+		}
+	}
+}
+
+/*
+ * pxa988_enter_lowpower - the entry function of pxa988 low power mode
+ *
+ * Here we are assuming there are maximum 16 low power modes,
+ * and the first LPM is C1, the second LPM is C2 (cpu power down)
+ * The following LPMs are D-stauts.
+ *
+ * @cpu: the cpu id of the cpu that calls this function.
+ * @power_mode: then low power mode it will enter
+ *
+ */
+
+#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED
+int lpm_index;
+int pxa988_enter_lowpower(u32 cpu, u32 power_mode)
+{
+	int i;
+	int cpus_enter_lpm = 0xffffffff;
+#ifdef CONFIG_LOCAL_TIMERS
+	int cpu_id = cpu;
+#endif
+	/* if uses coupled idle*/
+	u32 icdispr = 0;
+	/* The default power_mode should be C2 */
+	lpm_index = PXA988_LPM_C2;
+	if (has_feat_freqchg_disable_c2()) {
+		if (atomic_read(&freqchg_disable_c2))
+			lpm_index = PXA988_LPM_C1;
+	}
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+	if (atomic_read(&disable_c2))
+		lpm_index = PXA988_LPM_C1;
+#endif
+
+#ifdef CONFIG_LOCAL_TIMERS
+	/* switch to broadcast timer before enter lpm */
+	clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu_id);
+#endif
+
+	/*
+	 * If there's a pending IPI, exit low power function.
+	 * Otherwise, since the CORE1_IDLE_FLAG in PMUA(0x90)
+	 * is set before hardware checking the interrupt, CPU0
+	 * has a chance to exit waiting loop. But at that time,
+	 * CPU1 exits C2, which is not expected.
+	 */
+	icdispr = readl_relaxed(GIC_DIST_VIRT_BASE + GIC_DIST_PENDING_SET);
+	if (icdispr)
+		lpm_index = INVALID_LPM;
+	/*FIXME
+	 * Here the return state is not very accurate.
+	 * When Core1 enters C2 and Core0 excutes here,
+	 * Core1 would be woke up but it also return
+	 * C1 although it exits from C2.
+	 */
+	if ((lpm_index == PXA988_LPM_C1) || (lpm_index == INVALID_LPM)) {
+#ifdef CONFIG_LOCAL_TIMERS
+		/* switch back to normal timer */
+		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu_id);
+#endif
+		return lpm_index;
+	}
+
+	cpu_pm_enter();
+
+	/* mask the LPM states we can enter */
+	enter_lpm_p[cpu] |= (1 << (power_mode + 1)) - 1;
+	/*
+	 * CPU0 is always the last core to enter.
+	 */
+	if (cpu == 0) {
+		for (i = 0; i < num_cpus; i++)
+			cpus_enter_lpm &= enter_lpm_p[i];
+#ifdef CONFIG_CACHE_L2X0
+		pl310_suspend();
+#endif
+		cpu_cluster_pm_enter();
+		/*
+		 * Here we assume when one LPM state is disabled,
+		 * all shallower states are disabled
+		 */
+		lpm_index = find_first_zero_bit((void *)&cpus_enter_lpm,
+						PXA988_MAX_LPM_INDEX) - 1;
+		if (lpm_index > PXA988_LPM_C2)
+			pxa988_check_constraint(pm_qos_request(PM_QOS_CPUIDLE_BLOCK));
+
+		/* check LPM constraints  */
+		while (pxa988_lpm_data[lpm_index].valid != 1)
+			lpm_index--;
+		pxa988_pre_enter_lpm(cpu, lpm_index);
+		/* For D1 or deeper LPM, we need to enable wakeup sources */
+		if (lpm_index >= PXA988_LPM_D1) {
+			ddr_dll_rst_wkr(0);
+			enable_ap_wakeup_sources();
+		}
+#ifdef CONFIG_DEBUG_FS
+		pxa988_cpu_dcstat_event(cpu, CPU_M2_OR_DEEPER_ENTER, lpm_index);
+#endif
+	} else
+		/* Other cores enter C2 */
+		pxa988_pre_enter_lpm(cpu, PXA988_LPM_C2);
+
+	trace_pxa_cpu_idle(LPM_ENTRY(lpm_index), cpu);
+#ifdef CONFIG_DEBUG_FS
+	pxa988_cpu_dcstat_event(cpu, CPU_IDLE_ENTER, lpm_index);
+#endif
+	if (INVALID_LPM \
+		== cpu_suspend(CPU_SUSPEND_FROM_IDLE, finish_func))
+		lpm_index = INVALID_LPM;
+#ifdef CONFIG_DEBUG_FS
+	pxa988_cpu_dcstat_event(cpu, CPU_IDLE_EXIT, PXA988_MAX_LPM_INDEX);
+#endif
+	trace_pxa_cpu_idle(LPM_EXIT(lpm_index), cpu);
+
+	/* here we exit from LPM */
+
+	if (s_wake_saved == 1) {
+		ddr_dll_rst_wkr(1);
+		restore_wakeup_sources();
+	}
+
+#ifdef CONFIG_CPU_CA7MP
+	*mp_restore = !((readl_relaxed(GIC_DIST_VIRT_BASE + GIC_DIST_CTRL)) & (0x1));
+#endif
+	if (*mp_restore) {
+		*mp_restore = 0;
+		cpu_cluster_pm_exit();
+	}
+
+#ifdef CONFIG_LOCAL_TIMERS
+	/* switch back to normal timer after back from lpm */
+	clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu_id);
+#endif
+	pxa988_post_enter_lpm(cpu, power_mode);
+
+	cpu_pm_exit();
+
+	return lpm_index;
+}
+#else
+int pxa988_enter_lowpower(u32 cpu, u32 power_mode)
+{
+	int i;
+	int cpus_enter_lpm = 0xffffffff;
+	int mp_shutdown = 1;
+	/* The default power_mode should be C2 */
+	int lpm_index = PXA988_LPM_C2;
+	u32 apcr;
+
+#ifdef CONFIG_LOCAL_TIMERS
+	int cpu_id = cpu;
+#endif
+
+	if (has_feat_freqchg_disable_c2()) {
+		if (atomic_read(&freqchg_disable_c2))
+			power_mode = PXA988_LPM_C1;
+	}
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+	if (atomic_read(&disable_c2))
+		power_mode = PXA988_LPM_C1;
+#endif
+
+	if (power_mode == PXA988_LPM_C1) {
+		/* For C1 the core won't be reset */
+		pxa988_enter_c1(cpu);
+		return 0;
+	}
+
+#ifdef CONFIG_LOCAL_TIMERS
+	/* switch to broadcast timer before enter lpm */
+	clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu_id);
+#endif
+	cpu_pm_enter();
+
+	arch_spin_lock(lpm_lock_p);
+
+	/* Suppose that there should be no one touch the MPMU_APCR
+	 * but only Last man entering the low power modes which are
+	 * deeper than M2. Thus, add BUG check here.
+	 */
+	apcr = __raw_readl(MPMU_APCR);
+	if (apcr & (PMUM_DDRCORSD | PMUM_APBSD | PMUM_AXISD |
+		PMUM_VCTCXOSD | PMUM_STBYEN | PMUM_SLPEN)) {
+		pr_err("APCR is set to 0x%X by the Non-lastman\n", apcr);
+		BUG_ON(1);
+	}
+
+	/* mask the LPM states we can enter */
+	enter_lpm_p[cpu] = (1 << (power_mode + 1)) - 1;
+	for (i = 0; i < num_cpus; i++)
+		cpus_enter_lpm &= enter_lpm_p[i];
+	mp_shutdown = test_bit(PXA988_LPM_C2, (void *)&cpus_enter_lpm);
+
+	if (!mp_shutdown) {
+		/* Enter C2 */
+		pxa988_pre_enter_lpm(cpu, PXA988_LPM_C2);
+	} else {
+#ifdef CONFIG_CACHE_L2X0
+		pl310_suspend();
+#endif
+		cpu_cluster_pm_enter();
+		/*
+		 * Here we assume when one LPM state is disabled,
+		 * all shallower states are disabled
+		 */
+		lpm_index = find_first_zero_bit((void *)&cpus_enter_lpm,
+						PXA988_MAX_LPM_INDEX) - 1;
+		if (lpm_index > PXA988_LPM_C2)
+			pxa988_check_constraint(pm_qos_request(PM_QOS_CPUIDLE_BLOCK));
+
+		/* check LPM constraints  */
+		while (pxa988_lpm_data[lpm_index].valid != 1)
+			lpm_index--;
+
+		pxa988_pre_enter_lpm(cpu, lpm_index);
+		/* For D1 or deeper LPM, we need to enable wakeup sources */
+		if (lpm_index >= PXA988_LPM_D1) {
+			ddr_dll_rst_wkr(0);
+			enable_ap_wakeup_sources();
+		}
+
+		pxa988_cpu_dcstat_event(cpu, CPU_M2_OR_DEEPER_ENTER, lpm_index);
+
+#ifdef CONFIG_ARM_ERRATA_802022
+		for_each_possible_cpu(i) {
+			barrier[i] = 0;
+		}
+#endif
+	}
+	arch_spin_unlock(lpm_lock_p);
+
+	trace_pxa_cpu_idle(LPM_ENTRY(lpm_index), cpu);
+
+	pxa988_cpu_dcstat_event(cpu, CPU_IDLE_ENTER, lpm_index);
+	if (INVALID_LPM == \
+		cpu_suspend(CPU_SUSPEND_FROM_IDLE, finish_func))
+		lpm_index = INVALID_LPM;
+	pxa988_cpu_dcstat_event(cpu, CPU_IDLE_EXIT, PXA988_MAX_LPM_INDEX);
+
+	trace_pxa_cpu_idle(LPM_EXIT(lpm_index), cpu);
+
+	/* here we exit from LPM */
+	arch_spin_lock(lpm_lock_p);
+
+	if (s_wake_saved == 1) {
+		ddr_dll_rst_wkr(1);
+		restore_wakeup_sources();
+	}
+
+#ifdef CONFIG_CPU_CA7MP
+	*mp_restore = !((readl_relaxed(GIC_DIST_VIRT_BASE + GIC_DIST_CTRL)) & (0x1));
+#endif
+	if (*mp_restore) {
+		*mp_restore = 0;
+		cpu_cluster_pm_exit();
+	}
+
+	arch_spin_unlock(lpm_lock_p);
+
+#ifdef CONFIG_LOCAL_TIMERS
+	/* switch back to normal timer after back from lpm */
+	clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu_id);
+#endif
+	pxa988_post_enter_lpm(cpu, power_mode);
+
+	cpu_pm_exit();
+
+	return lpm_index;
+}
+#endif
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_HOTPLUG_CPU
+/*
+ * Allows POWER_MODE_UDR for CPU hotplug.
+ * Actually the hotpluged CPU will enter C2 but it will allow
+ * POWER_MODE_UDR since the hotpluged CPU should never blocks
+ * other CPUs enter the deepest LPM.
+ */
+#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED
+void pxa988_hotplug_enter(u32 cpu, u32 power_mode)
+{
+	u32 mp_idle_cfg;
+
+	pxa988_pre_enter_lpm(cpu, PXA988_LPM_C2);
+
+	/*
+	 * For CPU hotplug, we don't need cpu_suspend help functions
+	 * but still need to mask LPM bits as the deepest LPM.
+	 * We are assuming the hotplug CPU will NEVER be the last CPU
+	 * enter C2 since in platform_cpu_kill we ensure that.
+	 */
+	pxa988_set_reset_handler(__pa(pxa988_hotplug_handler), cpu);
+
+	/* The hotpluged CPU always allow SCU/L2 SRAM power down */
+	mp_idle_cfg = __raw_readl(APMU_MP_IDLE_CFG[cpu]);
+	mp_idle_cfg |= PMUA_MP_L2_SRAM_POWER_DOWN;
+	if (cpu_is_pxa988())
+		mp_idle_cfg |= PMUA_MP_SCU_SRAM_POWER_DOWN;
+	__raw_writel(mp_idle_cfg, APMU_MP_IDLE_CFG[cpu]);
+
+	enter_lpm_p[cpu] |= (1 << (power_mode + 1)) - 1;
+
+	trace_pxa_core_hotplug(HOTPLUG_ENTRY, smp_processor_id());
+#ifdef CONFIG_DEBUG_FS
+	pxa988_cpu_dcstat_event(cpu, CPU_IDLE_ENTER, PXA988_LPM_D2_UDR);
+#endif
+	finish_func(CPU_SUSPEND_FROM_HOTPLUG);
+}
+#else
+void pxa988_hotplug_enter(u32 cpu, u32 power_mode)
+{
+	u32 mp_idle_cfg;
+	int i, mp_shutdown;
+	int cpus_enter_lpm = 0xffffffff;
+
+	pxa988_pre_enter_lpm(cpu, PXA988_LPM_C2);
+
+	/*
+	 * For CPU hotplug, we don't need cpu_suspend help functions
+	 * but still need to mask LPM bits as the deepest LPM.
+	 * We are assuming the hotplug CPU will NEVER be the last CPU
+	 * enter C2 since in platform_cpu_kill we ensure that.
+	 */
+#ifdef CONFIG_ARM_ERRATA_802022
+	pxa988_set_reset_handler(__pa(pxa988_return_handler), cpu);
+#else
+	pxa988_set_reset_handler(__pa(pxa988_hotplug_handler), cpu);
+#endif
+
+	/* The hotpluged CPU always allow SCU/L2 SRAM power down */
+	mp_idle_cfg = __raw_readl(APMU_MP_IDLE_CFG[cpu]);
+	mp_idle_cfg |= PMUA_MP_L2_SRAM_POWER_DOWN;
+	if (cpu_is_pxa988())
+		mp_idle_cfg |= PMUA_MP_SCU_SRAM_POWER_DOWN;
+	__raw_writel(mp_idle_cfg, APMU_MP_IDLE_CFG[cpu]);
+
+	arch_spin_lock(lpm_lock_p);
+	enter_lpm_p[cpu] = (1 << (power_mode + 1)) - 1;
+	for (i = 0; i < num_cpus; i++)
+		cpus_enter_lpm &= enter_lpm_p[i];
+	mp_shutdown = test_bit(PXA988_LPM_C2, (void *)&cpus_enter_lpm);
+	if (mp_shutdown) {
+#ifdef CONFIG_CACHE_L2X0
+		pl310_suspend();
+#endif
+		cpu_cluster_pm_enter();
+#ifdef CONFIG_ARM_ERRATA_802022
+		for_each_possible_cpu(i) {
+			barrier[i] = 0;
+		}
+#endif
+	}
+	arch_spin_unlock(lpm_lock_p);
+
+	trace_pxa_core_hotplug(HOTPLUG_ENTRY, smp_processor_id());
+
+	pxa988_cpu_dcstat_event(cpu, CPU_IDLE_ENTER, PXA988_LPM_D2_UDR);
+
+	finish_func(CPU_SUSPEND_FROM_HOTPLUG);
+}
+#endif
+#endif
+
+#ifdef CONFIG_SUSPEND
+void pxa988_pm_suspend(u32 cpu, u32 power_mode)
+{
+#ifdef CONFIG_ARM_ERRATA_802022
+	int i;
+#endif
+	/* Reset handler checks the flag to decide if needs to invalidate L2 */
+#ifdef CONFIG_CACHE_L2X0
+	l2sram_shutdown = 1;
+	smp_wmb();
+	__cpuc_flush_dcache_area((void *)&l2sram_shutdown,
+				sizeof(l2sram_shutdown));
+	outer_clean_range(__pa(&l2sram_shutdown), __pa(&l2sram_shutdown + 1));
+
+	pl310_suspend();
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_802022
+	for_each_possible_cpu(i) {
+		barrier[i] = 0;
+	}
+#endif
+	pxa988_pre_enter_lpm(cpu, power_mode);
+#ifdef CONFIG_ARM_ERRATA_802022
+	/* clear MP powerdown disable bit for suspend */
+	for_each_possible_cpu(i) {
+		u32 mp_idle_cfg;
+		mp_idle_cfg = __raw_readl(APMU_MP_IDLE_CFG[i]);
+		mp_idle_cfg &= ~(PMUA_DIS_MP_SLP);
+		__raw_writel(mp_idle_cfg, APMU_MP_IDLE_CFG[i]);
+	}
+#endif
+
+	ddr_dll_rst_wkr(0);
+	trace_pxa_cpu_idle(LPM_ENTRY(PXA988_LPM_D2_UDR), cpu);
+	cpu_suspend(CPU_SUSPEND_FROM_SUSPEND, finish_func);
+	trace_pxa_cpu_idle(LPM_EXIT(PXA988_LPM_D2_UDR), cpu);
+	ddr_dll_rst_wkr(1);
+#ifdef CONFIG_ARM_ERRATA_802022
+	/* set back MP powerdown disable bit for idle/hotplug */
+	for_each_possible_cpu(i) {
+		u32 mp_idle_cfg;
+		mp_idle_cfg = __raw_readl(APMU_MP_IDLE_CFG[i]);
+		mp_idle_cfg |= (PMUA_DIS_MP_SLP);
+		__raw_writel(mp_idle_cfg, APMU_MP_IDLE_CFG[i]);
+	}
+#endif
+	sav_wucrs = (__raw_readl(MPMU_AWUCRS) | __raw_readl(MPMU_CWUCRS));
+	sav_wucrm = (__raw_readl(MPMU_AWUCRM) | __raw_readl(MPMU_CWUCRM));
+
+	pxa988_post_enter_lpm(cpu, power_mode);
+}
+#endif
+
+static int __init pxa988_lowpower_init(void)
+{
+#ifdef CONFIG_HAVE_ARM_SCU
+	void __iomem *scu_addr;
+#endif
+	u32 apcr = __raw_readl(MPMU_APCR);
+
+	/* set DSPSD, DTCMSD, BBSD, MSASLPEN */
+	apcr |= PMUM_DTCMSD | PMUM_BBSD | PMUM_MSASLPEN;
+	if (cpu_is_pxa988())
+		apcr |= PMUM_DSPSD;
+	/* PMUM_STBYEN in MPMU_APCR is "0b1" by default in reset.
+	 * So we also need to clear when doing init.
+	 */
+	apcr &= ~PMUM_STBYEN;
+	__raw_writel(apcr, MPMU_APCR);
+
+#ifdef CONFIG_ARM_ERRATA_802022
+	{
+		int i;
+		/* set MP powerdown disable bit for idle/hotplug */
+		for_each_possible_cpu(i) {
+			u32 mp_idle_cfg;
+			mp_idle_cfg = __raw_readl(APMU_MP_IDLE_CFG[i]);
+			mp_idle_cfg |= (PMUA_DIS_MP_SLP);
+			__raw_writel(mp_idle_cfg, APMU_MP_IDLE_CFG[i]);
+		}
+	}
+#endif
+	num_cpus = num_possible_cpus();
+	coherent_buf = __arm_ioremap(pm_reserve_pa, PAGE_SIZE, MT_MEMORY_SO);
+	if (coherent_buf == NULL)
+		panic("%s: failed to remap memory for pm\n", __func__);
+	memset(coherent_buf, 0x0, PAGE_SIZE);
+
+	enter_lpm_p = (u32 *)coherent_buf;
+
+#ifdef CONFIG_CPU_CA9MP
+	mp_restore = (u32 *)(&coherent_buf[OFFSET_SCU_SHUTDOWN]);
+	lpm_lock_p = (arch_spinlock_t *)(&coherent_buf[OFFSET_SPINLOCK]);
+#elif defined(CONFIG_CPU_CA7MP)
+	mp_restore = kzalloc(sizeof(u32), GFP_KERNEL);
+	lpm_lock_p = kzalloc(sizeof(arch_spinlock_t), GFP_KERNEL);
+#ifdef CONFIG_ARM_ERRATA_802022
+	barrier = (u32 *)(&coherent_buf[OFFSET_BARRIER]);
+#endif
+#endif
+	*lpm_lock_p = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;
+
+	/*
+	 * Set PL310 power ctrl register to set standby_mode_en bit
+	 * and dynamic_clk_gating_en bit
+	 * it is done in cache-l2x0.c : l2x0_init now
+	 */
+#ifdef CONFIG_HAVE_ARM_SCU
+	scu_addr = pxa_scu_base_addr();
+	/* Set SCU control register standby enable bit */
+	__raw_writel(__raw_readl(scu_addr + SCU_CTRL) | (1 << 5),
+			scu_addr + SCU_CTRL);
+#endif
+
+	/* set the power stable timer as 10us */
+	__raw_writel(0x28207, APMU_PWR_STBL_TIMER);
+
+	/* Init dll_rst_wkr, skip table 0 by default for Zx */
+	ddr_dll_rst_wkr(1);
+
+	finish_func = cpu_is_pxa1088() ? \
+		pxa1088_finish_suspend : pxa988_finish_suspend;
+	return 0;
+}
+
+postcore_initcall(pxa988_lowpower_init);
diff --git a/arch/arm/mach-mmp/reset-pxa988.c b/arch/arm/mach-mmp/reset-pxa988.c
new file mode 100644
index 00000000..a59ca5a4
--- /dev/null
+++ b/arch/arm/mach-mmp/reset-pxa988.c
@@ -0,0 +1,147 @@
+/*
+ * linux/arch/arm/mach-mmp/reset-pxa988.c
+ *
+ * Author:	Neil Zhang <zhangwm@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/smp.h>
+
+#include <asm/io.h>
+#include <asm/hardware/gic.h>
+#include <asm/cacheflush.h>
+#include <asm/mach/map.h>
+
+#include <mach/regs-ciu.h>
+#include <mach/regs-apmu.h>
+#include <mach/reset-pxa988.h>
+#ifdef CONFIG_DEBUG_FS
+#include <mach/pxa988_lowpower.h>
+#include <mach/clock-pxa988.h>
+#endif
+
+#ifdef CONFIG_TZ_HYPERVISOR
+#include "./tzlc/pxa_tzlc.h"
+#endif
+
+static u32 *reset_handler;
+
+/*
+ * This function is called from boot_secondary to bootup the secondary cpu.
+ * It maybe called when system bootup or add a plugged cpu into system.
+ *
+ * cpu here can only be 1 since we only have two cores.
+ */
+void pxa_cpu_reset(u32 cpu)
+{
+	u32 tmp;
+
+	/*
+	 * only need to confirm it's not core0, since the caller will validate
+	 * cpu id.
+	 */
+	BUG_ON(cpu == 0);
+
+#ifdef CONFIG_ARM_ERRATA_802022
+	pxa988_set_reset_handler(__pa(pxa988_hotplug_handler), cpu);
+#endif
+
+	tmp = readl(PMU_CC2_AP);
+
+	if ((tmp & CPU_CORE_RST(cpu)) == CPU_CORE_RST(cpu)) {
+		/* secondary core bootup, we need to release it from reset */
+#ifdef CONFIG_CPU_PXA988
+		tmp &= ~(CPU_CORE_RST(cpu)
+			| CPU_DBG_RST(cpu) | CPU_WDOG_RST(cpu));
+#elif defined(CONFIG_CPU_PXA1088)
+		tmp &= ~(CPU_CORE_RST(cpu)
+			| CPU_DBG_RST(cpu) | CPU_POR_RST(cpu));
+#endif
+		writel(tmp, PMU_CC2_AP);
+	} else {
+#ifdef CONFIG_ARM_ERRATA_802022
+		pxa988_set_reset_handler(__pa(pxa988_hotplug_handler), cpu);
+#endif
+		pxa988_gic_raise_softirq(cpumask_of(cpu), 1);
+	}
+}
+
+/* This function is called from platform_secondary_init in platform.c */
+void __cpuinit pxa_secondary_init(u32 cpu)
+{
+#ifdef CONFIG_DEBUG_FS
+	pxa988_cpu_dcstat_event(cpu, CPU_IDLE_EXIT, PXA988_MAX_LPM_INDEX);
+#endif
+
+#ifdef CONFIG_PM
+	/* Use resume handler as the default handler when hotplugin */
+	pxa988_set_reset_handler(__pa(pxa988_cpu_resume_handler), cpu);
+#endif
+}
+
+void pxa988_set_reset_handler(u32 fn, u32 cpu)
+{
+	reset_handler[cpu] = fn;
+}
+
+void __init pxa_cpu_reset_handler_init(void)
+{
+	int cpu;
+#ifdef CONFIG_TZ_HYPERVISOR
+	tzlc_cmd_desc cmd_desc;
+	tzlc_handle tzlc_hdl;
+#endif
+
+	/* Assign the address for saving reset handler */
+	reset_handler_pa = pm_reserve_pa + PAGE_SIZE;
+	reset_handler = (u32 *)__arm_ioremap(reset_handler_pa,
+						PAGE_SIZE, MT_MEMORY_SO);
+	if (reset_handler == NULL)
+		panic("failed to remap memory for reset handler!\n");
+	memset(reset_handler, 0x0, PAGE_SIZE);
+
+	/* Flush the addr to DDR */
+	__cpuc_flush_dcache_area((void *)&reset_handler_pa,
+				sizeof(reset_handler_pa));
+	outer_clean_range(__pa(&reset_handler_pa),
+		__pa(&reset_handler_pa + 1));
+
+/*
+ * with TrustZone enabled, CIU_WARM_RESET_VECTOR is used by TrustZone software,
+ * and kernel use CIU_SW_SCRATCH_REG to save the cpu reset entry.
+*/
+#ifdef CONFIG_TZ_HYPERVISOR
+	tzlc_hdl = pxa_tzlc_create_handle();
+	cmd_desc.op = TZLC_CMD_SET_WARM_RESET_ENTRY;
+	cmd_desc.args[0] = __pa(pxa988_cpu_reset_entry);
+	pxa_tzlc_cmd_op(tzlc_hdl, &cmd_desc);
+	pxa_tzlc_destroy_handle(tzlc_hdl);
+#else
+	/* We will reset from DDR directly by default */
+	writel(__pa(pxa988_cpu_reset_entry), CIU_WARM_RESET_VECTOR);
+#endif
+
+#ifdef CONFIG_PM
+	/* Setup the resume handler for the first core */
+	pxa988_set_reset_handler(__pa(pxa988_cpu_resume_handler), 0);
+#endif
+
+	/* Setup the handler for secondary cores */
+	for (cpu = 1; cpu < CONFIG_NR_CPUS; cpu++)
+		pxa988_set_reset_handler(__pa(pxa988_secondary_startup), cpu);
+
+#ifdef CONFIG_HOTPLUG_CPU
+	/* Setup the handler for Hotplug cores */
+	writel(__pa(pxa988_secondary_startup), &secondary_cpu_handler);
+	__cpuc_flush_dcache_area((void *)&secondary_cpu_handler,
+				sizeof(secondary_cpu_handler));
+	outer_clean_range(__pa(&secondary_cpu_handler),
+		__pa(&secondary_cpu_handler + 1));
+#endif
+}
diff --git a/arch/arm/mach-mmp/reset.c b/arch/arm/mach-mmp/reset.c
new file mode 100644
index 00000000..96031e41
--- /dev/null
+++ b/arch/arm/mach-mmp/reset.c
@@ -0,0 +1,176 @@
+/*
+ *  linux/arch/arm/mach-mmp/reset.c
+ *
+ *  Copyright (C) 2009-2011 Marvell International Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  publishhed by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/io.h>
+#include <mach/regs-mpmu.h>
+#include <mach/regs-timers.h>
+#include <mach/cputype.h>
+#include <linux/delay.h>
+#include <asm/cacheflush.h>
+#include <asm/setup.h>
+
+#ifdef CONFIG_MFD_D2199
+#include <linux/d2199/core.h>
+#include <linux/d2199/pmic.h>
+#include <linux/d2199/d2199_reg.h>
+#include <linux/d2199/d2199_battery.h>
+#endif
+
+#ifdef CONFIG_MFD_88PM822
+#include <linux/mfd/88pm822.h>
+#endif
+
+#define REG_RTC_BR0	(APB_VIRT_BASE + 0x010014)
+
+#define MPMU_APRR_WDTR	(1<<4)
+#define MPMU_APRR_CPR	(1<<0)
+#define MPMU_CPRR_DSPR	(1<<2)
+#define MPMU_CPRR_BBR	(1<<3)
+
+int is_panic = 1;
+
+/* Using watchdog reset */
+static void do_wdt_reset(const char *cmd)
+{
+	u32 reg, backup;
+	void __iomem *watchdog_virt_base;
+	int i;
+	int match = 0, count = 0;
+
+	if (cpu_is_pxa910() || cpu_is_pxa988() || cpu_is_pxa986() ||
+			cpu_is_pxa1088())
+		watchdog_virt_base = CP_TIMERS2_VIRT_BASE;
+	else if (cpu_is_pxa168())
+		watchdog_virt_base = TIMERS1_VIRT_BASE;
+	else
+		return;
+
+	/*Hold cp to avoid reset watchdog*/
+	if (cpu_is_pxa910() || cpu_is_pxa988() || cpu_is_pxa986() ||
+			cpu_is_pxa1088()) {
+		/*hold CP first */
+		reg = readl(MPMU_APRR) | MPMU_APRR_CPR;
+		writel(reg, MPMU_APRR);
+		udelay(10);
+		/*CP reset MSA */
+		reg = readl(MPMU_CPRR) | MPMU_CPRR_DSPR | MPMU_CPRR_BBR;
+		writel(reg, MPMU_CPRR);
+		udelay(10);
+	}
+
+	/*If reboot by recovery, store info for uboot*/
+	if (cpu_is_pxa910() || cpu_is_pxa988() || cpu_is_pxa986() ||
+			cpu_is_pxa1088()) {
+		if (cmd && !strcmp(cmd, "recovery")) {
+			for (i = 0, backup = 0; i < 4; i++) {
+				backup <<= 8;
+				backup |= *(cmd + i);
+			}
+			do {
+				writel(backup, REG_RTC_BR0);
+			} while (readl(REG_RTC_BR0) != backup);
+		}
+	}
+
+	/* reset/enable WDT clock */
+	writel(0x7, MPMU_WDTPCR);
+	readl(MPMU_WDTPCR);
+	writel(0x3, MPMU_WDTPCR);
+	readl(MPMU_WDTPCR);
+
+	/* enable WDT reset */
+	writel(0xbaba, watchdog_virt_base + TMR_WFAR);
+	writel(0xeb10, watchdog_virt_base + TMR_WSAR);
+	writel(0x3, watchdog_virt_base + TMR_WMER);
+
+	/* negate hardware reset to the WDT after system reset */
+	reg = readl(MPMU_APRR) | MPMU_APRR_WDTR;
+	writel(reg, MPMU_APRR);
+
+	/* clear previous WDT status */
+	writel(0xbaba, watchdog_virt_base + TMR_WFAR);
+	writel(0xeb10, watchdog_virt_base + TMR_WSAR);
+	writel(0, watchdog_virt_base + TMR_WSR);
+
+	match = readl(watchdog_virt_base + TMR_WMR);
+	count = readl(watchdog_virt_base + TMR_WVR);
+
+	/* set match counter */
+	writel(0xbaba, watchdog_virt_base + TMR_WFAR);
+	writel(0xeb10, watchdog_virt_base + TMR_WSAR);
+	writel((0x20 + count) & 0xFFFF, watchdog_virt_base + TMR_WMR);
+}
+
+int pxa_board_reset(char mode, const char *cmd)
+{
+	struct membank *bank;
+	int i;
+
+	flush_cache_all();
+
+	for (i = 0; i < meminfo.nr_banks; i ++) {
+		bank = &meminfo.bank[i];
+		if (bank->size)
+			outer_flush_range(bank->start, bank->size);
+	}
+
+	return 0;
+}
+
+int (*board_reset)(char mode, const char *cmd) = pxa_board_reset;
+void mmp_arch_reset(char mode, const char *cmd)
+{
+	int count = 10;
+#if defined(CONFIG_MFD_D2199)
+	static unsigned char data;
+#endif
+
+	if ((!cpu_is_pxa910()) && (!cpu_is_pxa168()) &&
+	    (!cpu_is_pxa988()) && (!cpu_is_pxa986()) &&
+	    (!cpu_is_pxa1088()))
+		return;
+#if defined(CONFIG_MFD_D2199)
+	if (is_panic) {
+		/* dump buck1 voltage */
+		d2199_extern_reg_read(D2199_BUCK2PH_BUCK1_REG, &data);
+		pr_info("buck1 voltage: 0x%x\n", data);
+
+		d2199_extern_reg_write(D2199_BUCK2PH_BUCK1_REG, 0xd8);
+
+		/* double check */
+		d2199_extern_reg_read(D2199_BUCK2PH_BUCK1_REG, &data);
+		pr_info("buck1 voltage: 0x%x\n", data);
+	}
+#endif
+
+	printk("%s (%c)\n", __func__, mode);
+
+	if (board_reset(mode, cmd))
+		return;
+
+	switch (mode) {
+	case 's':
+		/* Jump into ROM at address 0 */
+		cpu_reset(0);
+		break;
+	case 'w':
+	default:
+		while(count--) {
+			do_wdt_reset(cmd);
+			mdelay(1000);
+			printk("Watchdog fail...retry\n");
+		}
+		break;
+	}
+
+}
diff --git a/arch/arm/mach-mmp/sec-common.c b/arch/arm/mach-mmp/sec-common.c
new file mode 100755
index 00000000..5de681af
--- /dev/null
+++ b/arch/arm/mach-mmp/sec-common.c
@@ -0,0 +1,38 @@
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/module.h>
+
+struct class *sec_class;
+EXPORT_SYMBOL(sec_class);
+
+#if defined(CONFIG_MACH_LT02)
+struct class *camera_class;
+EXPORT_SYMBOL(camera_class);
+#endif 
+
+static int __init rhea_class_create(void)
+{
+	sec_class = class_create(THIS_MODULE, "sec");
+	if (IS_ERR(sec_class)) {
+		pr_err("Failed to create class(sec)!\n");
+		return PTR_ERR(sec_class);
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_MACH_LT02)
+int __init camera_class_init(void)
+{
+	printk("zc class_creat camera\r\n");
+	camera_class = class_create(THIS_MODULE, "camera");
+	if (IS_ERR(camera_class))
+		pr_err("Failed to create class(camera)!\n");
+
+	return 0;
+}
+subsys_initcall(camera_class_init);
+#endif 
+
+subsys_initcall(rhea_class_create);
+
diff --git a/arch/arm/mach-mmp/sleep-pxa988.S b/arch/arm/mach-mmp/sleep-pxa988.S
new file mode 100644
index 00000000..4625156c
--- /dev/null
+++ b/arch/arm/mach-mmp/sleep-pxa988.S
@@ -0,0 +1,278 @@
+/*
+ * linux/arch/arm/mach-mmp/sleep-pxa988.S
+ *
+ * Copyright (C) 2012 Marvell, Inc.
+ *
+ * Author: Neil Zhang <zhangwm@marvell.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/asm-offsets.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <mach/addr-map.h>
+#include <mach/pxa988_lowpower.h>
+
+/*
+ * The following Macros should be defined in mach/pxa988_lowpower.h
+ *
+ * #define LPM_NUM
+ * #define OFFSET_SCU_SHUTDOWN
+ * #define OFFSET_SPINLOCK
+ *
+ * The topology of the reserved data is as following.
+ * Each core will use 4 bytes to save the flags.
+ * The base address is pointed by pm_reserve_pa
+ *
+ *
+ * +--------------------------------------------------------+
+ * | ... | hotplug | LPM[MAX_NUM_LPM - 1] | LPM[1] | LPM[0] |(PXA988/1088)
+ * +--------------------------------------------------------+
+ * | ... | hotplug | LPM[MAX_NUM_LPM - 1] | LPM[1] | LPM[0] |(PXA988/1088)
+ * +--------------------------------------------------------+
+ * | ... | hotplug | LPM[MAX_NUM_LPM - 1] | LPM[1] | LPM[0] |(PXA1088 only)
+ * +--------------------------------------------------------+
+ * | ... | hotplug | LPM[MAX_NUM_LPM - 1] | LPM[1] | LPM[0] |(PXA1088 only)
+ * +--------------------------------------------------------+
+ * |     scu power down flag                                |(PXA988 only)
+ * +--------------------------------------------------------+
+ * |     spin_lock                                          |(PXA988 only)
+ * +--------------------------------------------------------+
+ * |     barrier                                            |(PXA1088 only)
+ * +--------------------------------------------------------+
+ */
+
+#ifdef CONFIG_HAVE_ARM_SCU
+#define SCU_CTRL		(SCU_PHYS_BASE + 0x00)
+#define SCU_CPU_POWER_STATUS    (SCU_PHYS_BASE + 0x08)
+#define SCU_INVALIDATE          (SCU_PHYS_BASE + 0x0c)
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_802022
+#define GICD_CTLR	(PERI_PHYS_BASE + 0x1000)
+#define CORE0_WAKEUP	0xd428292c
+#define MP_IDLE_CFG0	0xd4282920
+#endif
+
+/*
+ * Note: The following code is located into the .data section. This is to
+ *	 allow l2x0_regs_phys to be accessed with a relative load while we
+ *	 can't rely on any MMU translation.
+ *	 Reference from: arch/arm/kernel/sleep.S
+ */
+        .data
+        .align
+
+/*
+ * r0, CPUID
+ * r1, the base physical address of pm reserved space
+ */
+ENTRY(pxa988_cpu_resume_handler)
+#ifndef CONFIG_ARM_ERRATA_802022
+#ifdef CONFIG_CPU_CA7MP
+	mrc     p15, 0, r0, c1, c0, 1
+	orr	r0, r0, #0x40
+	mcr     p15, 0, r0, c1, c0, 1
+#endif
+#ifdef CONFIG_CPU_CA9MP
+	/* I+BTB cache invalidate */
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 0
+#endif
+
+	/* Enalble I-cache and Branch Prediction here */
+	mrc	p15, 0, r0, c1, c0, 0
+	orr	r0, r0, #0x1800
+	mcr	p15, 0, r0, c1, c0, 0
+#endif
+
+/*
+ * Note: Architecturally, caches are not guaranteed to be in a known state
+ * at reset.
+ * - need to be invalidated by software on Cortex-A9.
+ * - not required on Cortex-A5/A7/A15.
+ */
+#ifdef CONFIG_CPU_CA9MP
+	bl	v7_invalidate_l1	@ invalidate L1 first when back
+#endif
+
+	/* Load the reserved memory address */
+	ldr	r1, pm_reserve_pa
+
+	/* fetch the CPU ID */
+	mrc 	p15, 0, r0, c0, c0, 5
+	and     r0, r0, #15		@ fetch CPUID
+
+#ifdef CONFIG_ARM_ERRATA_802022
+	@ Check MP power disable bit
+	ldr     r2, =MP_IDLE_CFG0
+	ldr     r3, [r2]
+	tst	r3, #PMUA_DIS_MP_SLP
+	bne     nowake
+
+	@ Check GIC status
+	ldr     r2, =GICD_CTLR
+        ldr     r3, [r2]
+        cmp     r3, #0
+        bne     nowake
+
+	@ Wakeup all cores
+        mov     r3, #0xf
+        ldr     r2, =CORE0_WAKEUP
+        add     r2, r2, r0, lsl #2
+        str     r3, [r2]
+
+	@ barrier to make sure all cores have been waken
+	mov     r2, #OFFSET_BARRIER
+	add     r2, r2, r1
+
+	dmb
+
+	@ barrier_inc
+	ldr	r3, [r2, r0, lsl #2]
+	add	r3, r3, #1
+	str	r3, [r2, r0, lsl #2]
+	dmb
+
+	@ check other core's status
+1:	mov	r3, #0
+2:	dmb
+	ldr	r4, [r2, r3, lsl #2]
+	cmp	r4, #1
+	bne	1b
+	add	r3, r3, #1
+	cmp	r3, #CONFIG_NR_CPUS
+	bne	2b
+
+nowake:
+	mrc     p15, 0, r2, c1, c0, 1
+	orr	r2, r2, #0x40
+	mcr     p15, 0, r2, c1, c0, 1
+	isb
+#endif
+
+#if defined(CONFIG_HAVE_ARM_SCU) || defined(CONFIG_CACHE_L2X0)
+	/* spin lock */
+	mov     r2, #OFFSET_SPINLOCK
+	add     r2, r2, r1
+	mov     r3, #1
+1:	ldrex	r4, [r2]
+	teq     r4, #0
+	wfene
+	strexeq r4, r3, [r2]
+	teqeq   r4, #0
+	bne     1b
+	dmb
+#endif
+
+#ifdef CONFIG_HAVE_ARM_SCU
+	ldr	r2, =SCU_CTRL
+	ldr	r3, [r2]
+	tst	r3, #1
+	bne	set_scu_mode
+
+	/* enable SCU */
+	orr	r3, r3, #0x21
+	str	r3, [r2]
+	/* Invalidate both CPUs' SCU tag RAMs */
+	mov	r4, #0xff
+	ldr	r5, =SCU_INVALIDATE
+	str	r4, [r5]
+
+	/* set SCU_SHUTDOWN flag */
+	mov	r4, #0x1
+	str	r4, [r1, #OFFSET_SCU_SHUTDOWN]
+
+set_scu_mode:
+	/* scu_power_mode(scu_base_addr, SCU_PM_NORMAL) */
+	ldr     r2, =SCU_CPU_POWER_STATUS
+	ldrb    r3, [r2, r0]
+	bic     r3, r3, #0x3
+	strb    r3, [r2, r0]
+#endif
+	/* Clear cpu flags */
+	mov	r2, #0
+	str     r2, [r1, r0, lsl #2]
+
+	/* check L2, if disabled, then enable it */
+#ifdef CONFIG_CACHE_L2X0
+	adr	r2, l2x0_regs_phys
+	ldr	r2, [r2]
+	ldr	r3, [r2, #L2X0_R_PHY_BASE]	@ phys addr
+	ldr	r4, [r3, #L2X0_CTRL]
+	tst	r4, #0x1
+	bne	l2on
+
+	/* check whether the L2 Array has been powered down */
+	adr	r4, l2sram_shutdown
+	ldr	r5, [r4]
+	cmp     r5, #0		@ no, restore registers is enough
+	beq     pl310_restore
+	mov	r5, #0
+	str	r5, [r4]	@ clear it if setted
+pl310_inv_all:
+	mov     r4, #0xff00
+	orr	r4, #0xff
+	str     r4, [r3, #L2X0_INV_WAY]
+inv_wait:
+	ldr     r5, [r3,#L2X0_INV_WAY]
+	and     r5, r5, r4
+	cmp     r5, #0
+	bne     inv_wait
+	str     r5, [r3, #L2X0_CACHE_SYNC]
+pl310_restore:
+	ldmia   r2!, {r4-r7}
+	str     r5, [r3, #L2X0_AUX_CTRL]
+	str     r6, [r3, #L2X0_TAG_LATENCY_CTRL]
+	str     r7, [r3, #L2X0_DATA_LATENCY_CTRL]
+	ldmia   r2!, {r4-r7}
+	str     r4, [r3, #L2X0_ADDR_FILTER_START]
+	str     r5, [r3, #L2X0_ADDR_FILTER_END]
+	str     r6, [r3, #L2X0_PREFETCH_CTRL]
+	str     r7, [r3, #L2X0_POWER_CTRL]
+	mov	r4, #1
+	str	r4, [r3, #L2X0_CTRL]
+l2on:
+#else
+#ifdef CONFIG_CPU_PXA988
+	/* workaroud: M2 depends on L2 dynamic clock gating enabled */
+	ldr	r2, =SL2C_PHYS_BASE
+	mov	r3, #0x3
+	str	r3, [r2, #L2X0_POWER_CTRL]
+#endif
+#endif
+
+#if defined(CONFIG_HAVE_ARM_SCU) || defined(CONFIG_CACHE_L2X0)
+	/* spin unlock */
+	dmb
+	mov     r2, #0
+	str     r2, [r1, #OFFSET_SPINLOCK]
+	dsb
+	sev
+#endif
+	b	cpu_resume
+
+	.globl pm_reserve_pa
+pm_reserve_pa:
+	.long   0
+
+#ifdef CONFIG_CACHE_L2X0
+	.globl l2sram_shutdown
+l2sram_shutdown:
+	.long   0
+
+	.globl l2x0_regs_phys
+l2x0_regs_phys:
+	.long   0
+#endif
+ENDPROC(pxa988_cpu_resume_handler)
diff --git a/arch/arm/mach-mmp/sram.c b/arch/arm/mach-mmp/sram.c
index 4304f951..7e8a5a2e 100644
--- a/arch/arm/mach-mmp/sram.c
+++ b/arch/arm/mach-mmp/sram.c
@@ -68,7 +68,7 @@ static int __devinit sram_probe(struct platform_device *pdev)
 	struct resource *res;
 	int ret = 0;
 
-	if (!pdata && !pdata->pool_name)
+	if (!pdata || !pdata->pool_name)
 		return -ENODEV;
 
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
diff --git a/arch/arm/mach-mmp/stand-hotplug.c b/arch/arm/mach-mmp/stand-hotplug.c
new file mode 100644
index 00000000..9f707d18
--- /dev/null
+++ b/arch/arm/mach-mmp/stand-hotplug.c
@@ -0,0 +1,747 @@
+/* linux/arch/arm/mach-exynos/stand-hotplug.c
+ *
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com/
+ *
+ * EXYNOS - Dynamic CPU hotpluging
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <linux/cpu.h>
+#include <linux/tick.h>
+#include <linux/suspend.h>
+#include <linux/reboot.h>
+#include <linux/cpufreq.h>
+#include <linux/clk.h>
+#include <linux/uaccess.h>
+#include <linux/kthread.h>
+
+#include <plat/clock.h>
+#include <plat/pxa_trace.h>
+
+#include <mach/clock-pxa988.h>
+
+#define BOOT_DELAY	60
+#define CHECK_DELAY_NOP	(.5 * HZ * 16)
+#define CHECK_DELAY_ON	(.5 * HZ * 4)
+#define CHECK_DELAY_OFF	(.5*HZ)
+#define TRANS_RQ 1
+#define TRANS_LOAD_RQ 8
+#define NUM_CPUS num_possible_cpus()
+#define CPULOAD_TABLE (NR_CPUS + 1)
+
+#if (NR_CPUS > 2)
+#define MIPS_HIGH	624000
+#define MIPS_LOW	250000
+#else
+#define TRANS_LOAD_L0 0
+#define TRANS_LOAD_H0 25
+#define TRANS_LOAD_L1 10
+#define TRANS_LOAD_H1 100
+#endif
+
+#define cputime64_sub(__a, __b)	((__a) - (__b))
+
+static struct workqueue_struct *hotplug_wq;
+static struct delayed_work hotplug_work;
+
+static unsigned int freq_max;
+static unsigned int freq_min = -1UL;
+static unsigned int max_performance;
+
+static unsigned int hotpluging_rate = CHECK_DELAY_OFF;
+static unsigned int hotpluging_nop_time = CHECK_DELAY_NOP;
+static unsigned int nop_time;
+static unsigned int user_lock;
+static unsigned int trans_rq = TRANS_RQ;
+static unsigned int trans_load_rq = TRANS_LOAD_RQ;
+
+#if (NR_CPUS <= 2)
+static unsigned int trans_load_l0 = TRANS_LOAD_L0;
+static unsigned int trans_load_h0 = TRANS_LOAD_H0;
+static unsigned int trans_load_l1 = TRANS_LOAD_L1;
+static unsigned int trans_load_h1 = TRANS_LOAD_H1;
+#else
+static unsigned int trans_load_l0;
+static unsigned int trans_load_l1;
+static unsigned int trans_load_l2;
+static unsigned int trans_load_l3;
+static unsigned int trans_load_h0;
+static unsigned int trans_load_h1;
+static unsigned int trans_load_h2;
+static unsigned int trans_load_h3 = 100;
+#endif
+
+
+
+enum flag {
+	HOTPLUG_NOP,
+	HOTPLUG_IN,
+	HOTPLUG_OUT
+};
+
+enum {
+	THRESHOLD_LOW = 0,
+	THRESHOLD_HIGH,
+};
+
+struct cpu_time_info {
+	cputime64_t prev_cpu_idle;
+	cputime64_t prev_cpu_wall;
+	cputime64_t total_wall_time;	/* True wall time*/
+	unsigned int load;		/* Not consider freq */
+	unsigned int avg_load;		/* Consider freq */
+};
+
+struct cpu_hotplug_info {
+	unsigned long nr_running;
+	pid_t tgid;
+};
+
+
+static DEFINE_PER_CPU(struct cpu_time_info, hotplug_cpu_time);
+
+static void init_hotplug_statistics(void)
+{
+	int i;
+
+	/* Initialize tmp_info */
+	for_each_online_cpu(i) {
+		struct cpu_time_info *tmp_info;
+		cputime64_t cur_wall_time, cur_idle_time;
+		tmp_info = &per_cpu(hotplug_cpu_time, i);
+
+		/* Get current idle and wall time */
+		cur_idle_time = get_cpu_idle_time(i, &cur_wall_time);
+
+		/* Initial tmp_info */
+		tmp_info->load  = 0;
+		tmp_info->avg_load  = 0;
+		tmp_info->prev_cpu_idle  = cur_idle_time;
+		tmp_info->prev_cpu_wall  = cur_wall_time;
+		tmp_info->total_wall_time = cur_wall_time;
+	}
+
+	/* Initialize nop_time */
+	nop_time = 0;
+}
+
+/* mutex can be used since hotplug_timer does not run in
+   timer(softirq) context but in process context */
+static DEFINE_MUTEX(hotplug_stat_lock);
+static DEFINE_MUTEX(hotplug_user_lock);
+static struct clk *cpu_clk;
+static inline enum flag
+standalone_hotplug(unsigned int avg_load, unsigned int cur_freq,
+		unsigned long nr_rq_min, unsigned int cpu_rq_min)
+{
+	unsigned int nr_online_cpu;
+
+	/*load threshold*/
+	unsigned int threshold[CPULOAD_TABLE][2] = {
+		{trans_load_l0, trans_load_h0},
+		{trans_load_l1, trans_load_h1},
+#if (NR_CPUS > 2)
+		{trans_load_l2, trans_load_h2},
+		{trans_load_l3, trans_load_h3},
+#endif
+		{0, 0}
+	};
+
+	nr_online_cpu = num_online_cpus();
+
+	if (avg_load < threshold[nr_online_cpu - 1][THRESHOLD_LOW]) {
+		nop_time = 0;
+		if (nr_online_cpu > 1)
+			return HOTPLUG_OUT;
+		/* If total nr_running is less than cpu(on-state) number
+		 * hotplug do not hotplug-in
+		 */
+	} else if (avg_load > threshold[nr_online_cpu - 1][THRESHOLD_HIGH]) {
+		nop_time = 0;
+		if ((nr_running() > nr_online_cpu) &&
+		    (cur_freq > freq_min))
+			return HOTPLUG_IN;
+	} else if (nr_online_cpu > 1 && nr_rq_min < trans_rq) {
+		struct cpu_time_info *tmp_info;
+
+		tmp_info = &per_cpu(hotplug_cpu_time, cpu_rq_min);
+		/* If CPU(cpu_rq_min) load is less than trans_load_rq
+		 * hotplug-out operation need
+		 */
+		if ((tmp_info->load < trans_load_rq) &&
+		    (avg_load < threshold[nr_online_cpu - 2][THRESHOLD_HIGH])) {
+			nop_time = 0;
+			return HOTPLUG_OUT;
+		}
+	} else if (nr_online_cpu > 1) {
+		if ((avg_load >=
+		     threshold[nr_online_cpu - 2][THRESHOLD_HIGH]) &&
+		    (avg_load <=
+		     threshold[nr_online_cpu - 1][THRESHOLD_HIGH]))
+			nop_time = 0;
+		else if ((avg_load >=
+			  threshold[nr_online_cpu - 1][THRESHOLD_LOW]) &&
+			 (avg_load <
+			  threshold[nr_online_cpu - 2][THRESHOLD_HIGH])) {
+			nop_time += hotpluging_rate;
+
+			/*
+			 * If load_l <= avg_load <= former load_h,
+			 * more than one online cpu, and nop_time
+			 * >= hotpluging_nop_time, plug-out cpu
+			 */
+			if (nop_time >= hotpluging_nop_time) {
+				nop_time = 0;
+				return HOTPLUG_OUT;
+			}
+		}
+	}
+
+	return HOTPLUG_NOP;
+}
+
+static int hotplug_freq_notifer_call(struct notifier_block *nb,
+	       unsigned long val, void *data)
+{
+	struct cpufreq_freqs *freq = data;
+	int i;
+
+	if (val != CPUFREQ_POSTCHANGE)
+		return 0;
+
+	/* If lock this hotplug, user_lock=1, return */
+	if (user_lock == 1)
+		return  0;
+
+	mutex_lock(&hotplug_stat_lock);
+
+	for_each_online_cpu(i) {
+		struct cpu_time_info *tmp_info;
+		cputime64_t cur_wall_time, cur_idle_time;
+		unsigned int idle_time, wall_time;
+
+		tmp_info = &per_cpu(hotplug_cpu_time, i);
+
+		/* Get idle time and wall time */
+		cur_idle_time = get_cpu_idle_time(i, &cur_wall_time);
+
+		/* Update idle time */
+		idle_time = (unsigned int)cputime64_sub(cur_idle_time, \
+					tmp_info->prev_cpu_idle);
+		tmp_info->prev_cpu_idle = cur_idle_time;
+
+		/* Update wall time */
+		wall_time = (unsigned int)cputime64_sub(cur_wall_time, \
+					tmp_info->prev_cpu_wall);
+		tmp_info->prev_cpu_wall = cur_wall_time;
+
+		/*
+		 * Let idle & wall time to be divided by 1024
+		 * to avoid overflow
+		 */
+		idle_time >>= 10;
+		wall_time >>= 10;
+
+		/* Update load */
+		tmp_info->load += (wall_time - idle_time);
+
+		/*
+		 * Update avg_load, and let freq to be divided
+		 * by 1024 to avoid overflow
+		 */
+		tmp_info->avg_load += ((wall_time - idle_time) \
+					* (freq->old >> 10));
+	}
+
+	mutex_unlock(&hotplug_stat_lock);
+
+	return 0;
+}
+
+static struct notifier_block hotplug_freq_notifier = {
+	.notifier_call = hotplug_freq_notifer_call
+};
+
+static void __ref hotplug_timer(struct work_struct *work)
+{
+	struct cpu_hotplug_info tmp_hotplug_info[4];
+	struct sched_param param_normal = { .sched_priority = 0 };
+	struct sched_param param_rt = { .sched_priority = 1};
+	int i;
+	unsigned int avg_load = 0;
+	unsigned int cpu_rq_min = 0;
+	unsigned long nr_rq_min = -1UL;
+	unsigned int select_off_cpu = 0;
+	unsigned int cur_freq;
+	enum flag flag_hotplug;
+
+	/* If lock this hotplug, user_lock=1, return */
+	if (user_lock == 1)
+		return;
+
+	mutex_lock(&hotplug_stat_lock);
+
+	/* Get current cpu freq */
+	cur_freq = cpu_clk->ops->getrate(cpu_clk) / 1000;
+
+	for_each_online_cpu(i) {
+		struct cpu_time_info *tmp_info;
+		cputime64_t cur_wall_time, cur_idle_time;
+		unsigned int idle_time, wall_time, total_wall_time;
+
+		tmp_info = &per_cpu(hotplug_cpu_time, i);
+
+		/* Get idle time and wall time */
+		cur_idle_time = get_cpu_idle_time(i, &cur_wall_time);
+
+		/* Get idle_time and wall_time */
+		idle_time = (unsigned int)cputime64_sub(cur_idle_time, \
+					tmp_info->prev_cpu_idle);
+		wall_time = (unsigned int)cputime64_sub(cur_wall_time, \
+					tmp_info->prev_cpu_wall);
+
+		/* Check wall time and idle time */
+		if (wall_time < idle_time) {
+			mutex_unlock(&hotplug_stat_lock);
+			goto no_hotplug;
+		}
+
+		/* Update idle time and wall time */
+		tmp_info->prev_cpu_idle = cur_idle_time;
+		tmp_info->prev_cpu_wall = cur_wall_time;
+
+		/* Update total wall time */
+		total_wall_time = (unsigned int)cputime64_sub(cur_wall_time, \
+					tmp_info->total_wall_time);
+		tmp_info->total_wall_time = cur_wall_time;
+
+		/*
+		 * Let idle time, wall time and total wall time
+		 * to be divided by 1024 to avoid overflow
+		 */
+		idle_time >>= 10;
+		wall_time >>= 10;
+		total_wall_time >>= 10;
+
+		/*For once Divide-by-Zero issue*/
+		if (total_wall_time == 0)
+			total_wall_time++;
+
+		/* Update load */
+		tmp_info->load += (wall_time - idle_time);
+		/* Get real load(xx%) */
+		tmp_info->load = 100 * tmp_info->load / total_wall_time;
+
+		/*
+		 * Update avg_load on current freq, let freq to
+		 * be divied by 1024 to avoid overflow
+		 */
+		tmp_info->avg_load += ((wall_time - idle_time) \
+					* (cur_freq >> 10));
+
+		/* Get real avg_load(xx%) */
+		tmp_info->avg_load = ((100 * tmp_info->avg_load) \
+					/ total_wall_time) \
+				     / (max_performance >> 10);
+
+		trace_pxa_hp_single(i,
+				    get_cpu_nr_running(i),
+				    tmp_info->load,
+				    (tmp_info->avg_load *
+				     (max_performance >> 10) / 100));
+
+		/* Get avg_load of two cores */
+		avg_load += tmp_info->avg_load;
+
+		/* Find minimum runqueue length */
+		tmp_hotplug_info[i].nr_running = get_cpu_nr_running(i);
+
+		if (i && nr_rq_min > tmp_hotplug_info[i].nr_running) {
+			nr_rq_min = tmp_hotplug_info[i].nr_running;
+
+			cpu_rq_min = i;
+		}
+	}
+
+	trace_pxa_hotplug_stand_mips((cur_freq / 1000),
+				     (avg_load * (max_performance >> 10) / 100),
+				     num_online_cpus());
+
+	for (i = NUM_CPUS - 1; i > 0; --i) {
+		if (cpu_online(i) == 0) {
+			select_off_cpu = i;
+			break;
+		}
+	}
+
+	/*standallone hotplug*/
+	flag_hotplug = standalone_hotplug(avg_load, cur_freq,
+					nr_rq_min, cpu_rq_min);
+
+	/* Initial tmp_info */
+	for_each_online_cpu(i) {
+		struct cpu_time_info *tmp_info;
+		tmp_info = &per_cpu(hotplug_cpu_time, i);
+
+		/* Initial load, avg_load, total wall time */
+		tmp_info->load = 0;
+		tmp_info->avg_load = 0;
+	}
+
+	/*cpu hotplug*/
+	if ((flag_hotplug == HOTPLUG_IN) &&
+	    /* Avoid running cpu_up(0) */
+	    select_off_cpu &&
+	    (!cpu_online(select_off_cpu))) {
+		pr_info("cpu%d turning on!\n", select_off_cpu);
+		mutex_unlock(&hotplug_stat_lock);
+
+		/* Plug-In one cpu */
+		sched_setscheduler(kthreadd_task, SCHED_FIFO, &param_rt);
+		cpu_up(select_off_cpu);
+		sched_setscheduler(kthreadd_task, SCHED_NORMAL, &param_normal);
+		pr_info("cpu%d on\n", select_off_cpu);
+
+		hotpluging_rate = CHECK_DELAY_ON;
+	} else if ((flag_hotplug == HOTPLUG_OUT) &&
+		   /* Avoid running cpu_down(0) */
+		   cpu_rq_min &&
+		   (cpu_online(cpu_rq_min))) {
+		pr_info("cpu%d turnning off!\n", cpu_rq_min);
+		mutex_unlock(&hotplug_stat_lock);
+
+		/* Plug-Out one cpu */
+		cpu_down(cpu_rq_min);
+		pr_info("cpu%d off!\n", cpu_rq_min);
+
+		hotpluging_rate = CHECK_DELAY_OFF;
+	} else
+		mutex_unlock(&hotplug_stat_lock);
+
+no_hotplug:
+	queue_delayed_work_on(0, hotplug_wq, \
+				&hotplug_work, hotpluging_rate);
+}
+
+static int standalone_hotplug_notifier_event(struct notifier_block *this,
+					     unsigned long event, void *ptr)
+{
+	static unsigned user_lock_saved;
+
+	switch (event) {
+	case PM_SUSPEND_PREPARE:
+		mutex_lock(&hotplug_user_lock);
+		user_lock_saved = user_lock;
+		user_lock = 1;
+		pr_info("%s: saving pm_hotplug lock %x\n",
+			__func__, user_lock_saved);
+		mutex_unlock(&hotplug_user_lock);
+		return NOTIFY_OK;
+	case PM_POST_RESTORE:
+	case PM_POST_SUSPEND:
+		mutex_lock(&hotplug_user_lock);
+		pr_info("%s: restoring pm_hotplug lock %x\n",
+			__func__, user_lock_saved);
+		user_lock = user_lock_saved;
+		mutex_unlock(&hotplug_user_lock);
+		/*
+		 * corner case:
+		 * user_lock set to 1 during suspend, and work_queue may goto
+		 * "unlock", then work_queue never have chance to run again
+		 */
+		if (0 == user_lock) {
+			flush_delayed_work(&hotplug_work);
+			mutex_lock(&hotplug_stat_lock);
+			/* Initialize data */
+			init_hotplug_statistics();
+			mutex_unlock(&hotplug_stat_lock);
+			queue_delayed_work_on(0, hotplug_wq, &hotplug_work,
+				hotpluging_rate);
+		}
+
+		return NOTIFY_OK;
+	}
+	return NOTIFY_DONE;
+}
+
+/*TODO: Whether the PM notifier is enabled in our suspend process*/
+static struct notifier_block standalone_hotplug_notifier = {
+	.notifier_call = standalone_hotplug_notifier_event,
+};
+
+static int hotplug_reboot_notifier_call(struct notifier_block *this,
+					unsigned long code, void *_cmd)
+{
+	mutex_lock(&hotplug_user_lock);
+	pr_err("%s: disabling pm hotplug\n", __func__);
+	user_lock = 1;
+	mutex_unlock(&hotplug_user_lock);
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block hotplug_reboot_notifier = {
+	.notifier_call = hotplug_reboot_notifier_call,
+};
+
+static struct kobject hotplug_kobj;
+
+static int bound_freq_get(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d\n", freq_min);
+}
+static int bound_freq_set(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int freq_tmp;
+	if (!sscanf(buf, "%d", &freq_tmp))
+		return -EINVAL;
+	freq_min = freq_tmp;
+	return count;
+}
+static DEVICE_ATTR(bound_freq, S_IRUGO | S_IWUSR, bound_freq_get,
+		bound_freq_set);
+
+
+static int lock_get(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d\n", user_lock);
+}
+
+static int lock_set(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	u32 val;
+	int restart_hp = 0;
+	bool waitqueue_finish = false;
+
+	if (!sscanf(buf, "%d", &val))
+		return -EINVAL;
+
+	mutex_lock(&hotplug_user_lock);
+	/* we want to re-enable governor */
+	if ((1 == user_lock) && (0 == val))
+		restart_hp = 1;
+	/*
+	 * when lock governor, we should wait workqueue finish
+	 * before return, it can avoid user lock and gonvernor work
+	 * concurrent conflict corner case
+	 */
+	if ((0 == user_lock) && (1 == !!val))
+		waitqueue_finish = true;
+	user_lock = val ? 1 : 0;
+	mutex_unlock(&hotplug_user_lock);
+
+	if (restart_hp) {
+		flush_delayed_work(&hotplug_work);
+		mutex_lock(&hotplug_stat_lock);
+		/* Initialize data */
+		init_hotplug_statistics();
+		mutex_unlock(&hotplug_stat_lock);
+		queue_delayed_work_on(0, hotplug_wq, &hotplug_work,
+				CHECK_DELAY_OFF);
+	}
+	if (waitqueue_finish)
+		cancel_delayed_work_sync(&hotplug_work);
+
+	return count;
+}
+static DEVICE_ATTR(lock, S_IRUGO | S_IWUSR, lock_get, lock_set);
+
+#define define_store_thhd_function(_name) \
+static ssize_t load_set_##_name(struct device *dev, \
+			struct device_attribute *attr, \
+			const char *buf, size_t count) \
+{ \
+	int tmp; \
+	if (!sscanf(buf, "%d", &tmp)) \
+		return -EINVAL; \
+	trans_load_##_name = tmp; \
+	return count; \
+}
+#define define_show_thhd_function(_name) \
+static ssize_t load_get_##_name(struct device *dev, \
+				struct device_attribute *attr, \
+				char *buf) \
+{ \
+	return sprintf(buf, "%d\n", (int) trans_load_##_name); \
+}
+
+define_store_thhd_function(h0);
+define_show_thhd_function(h0);
+define_store_thhd_function(l1);
+define_show_thhd_function(l1);
+static DEVICE_ATTR(load_h0, S_IRUGO | S_IWUSR, load_get_h0, load_set_h0);
+static DEVICE_ATTR(load_l1, S_IRUGO | S_IWUSR, load_get_l1, load_set_l1);
+
+#if (NR_CPUS > 2)
+define_store_thhd_function(h1);
+define_show_thhd_function(h1);
+define_store_thhd_function(l2);
+define_show_thhd_function(l2);
+define_store_thhd_function(h2);
+define_show_thhd_function(h2);
+define_store_thhd_function(l3);
+define_show_thhd_function(l3);
+static DEVICE_ATTR(load_h1, S_IRUGO | S_IWUSR, load_get_h1, load_set_h1);
+static DEVICE_ATTR(load_l2, S_IRUGO | S_IWUSR, load_get_l2, load_set_l2);
+static DEVICE_ATTR(load_h2, S_IRUGO | S_IWUSR, load_get_h2, load_set_h2);
+static DEVICE_ATTR(load_l3, S_IRUGO | S_IWUSR, load_get_l3, load_set_l3);
+#endif
+
+static struct attribute *hotplug_attributes[] = {
+	&dev_attr_lock.attr,
+	&dev_attr_load_h0.attr,
+	&dev_attr_load_l1.attr,
+#if (NR_CPUS > 2)
+	&dev_attr_load_h1.attr,
+	&dev_attr_load_l2.attr,
+	&dev_attr_load_h2.attr,
+	&dev_attr_load_l3.attr,
+#endif
+	&dev_attr_bound_freq.attr,
+	NULL,
+};
+
+static struct kobj_type hotplug_dir_ktype = {
+	.sysfs_ops	= &kobj_sysfs_ops,
+	.default_attrs	= hotplug_attributes,
+};
+
+static int __init stand_alone_hotplug_init(void)
+{
+	unsigned int freq;
+	int i, ret;
+	struct cpufreq_frequency_table *table;
+
+	pr_info("%s, PM-hotplug init function\n", __func__);
+	hotplug_wq = create_singlethread_workqueue("dynamic hotplug");
+	if (!hotplug_wq) {
+		printk(KERN_ERR "Creation of hotplug work failed\n");
+		ret = -EFAULT;
+		goto err_create_singlethread_workqueue;
+	}
+
+	if (!cpu_clk) {
+		cpu_clk = clk_get_sys(NULL, "cpu");
+		if (IS_ERR(cpu_clk)) {
+			ret = PTR_ERR(cpu_clk);
+			goto err_clk_get_sys;
+		}
+	}
+
+	/* Register cpufreq change notifier call */
+	ret = cpufreq_register_notifier(&hotplug_freq_notifier,
+				CPUFREQ_TRANSITION_NOTIFIER);
+	if (ret)
+		goto err_cpufreq_register_notifier;
+
+	/* Initialize data */
+	init_hotplug_statistics();
+
+	INIT_DELAYED_WORK(&hotplug_work, hotplug_timer);
+
+	queue_delayed_work_on(0, hotplug_wq, &hotplug_work, BOOT_DELAY * HZ);
+	table = cpufreq_frequency_get_table(0);
+
+	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		freq = table[i].frequency;
+		if (freq != CPUFREQ_ENTRY_INVALID && freq > freq_max)
+			freq_max = freq;
+		if (freq != CPUFREQ_ENTRY_INVALID && freq_min > freq)
+			freq_min = freq;
+	}
+
+	max_performance = freq_max * NUM_CPUS;
+	pr_info("init max_performance : %u\n", max_performance);
+
+#if (NR_CPUS > 2)
+	/* Set trans_load_XX with MIPS_XX */
+	trans_load_l1 = MIPS_LOW * 100 * 1 / max_performance;
+	trans_load_l2 = MIPS_LOW * 100 * 2 / max_performance;
+	trans_load_l3 = MIPS_LOW * 100 * 3 / max_performance;
+	trans_load_h0 = MIPS_HIGH * 100 * 1 / max_performance;
+	trans_load_h1 = MIPS_HIGH * 100 * 2 / max_performance;
+	trans_load_h2 = MIPS_HIGH * 100 * 3 / max_performance;
+
+	/* Show trans_load_XX */
+
+	pr_info("--------------------\n"
+		"|CPU|LOW(%%)|HIGH(%%)|\n"
+		"|  1|   %3d|    %3d|\n"
+		"|  2|   %3d|    %3d|\n"
+		"|  3|   %3d|    %3d|\n"
+		"|  4|   %3d|    %3d|\n"
+		"--------------------\n",
+		trans_load_l0, trans_load_h0,
+		trans_load_l1, trans_load_h1,
+		trans_load_l2, trans_load_h2,
+		trans_load_l3, trans_load_h3);
+
+#endif
+
+	ret = kobject_init_and_add(&hotplug_kobj, &hotplug_dir_ktype,
+				&(cpu_subsys.dev_root->kobj), "hotplug");
+	if (ret) {
+		pr_err("%s: Failed to add kobject for hotplug\n", __func__);
+		goto err_kobject_init_and_add;
+	}
+
+	ret = register_pm_notifier(&standalone_hotplug_notifier);
+	if (ret)
+		goto err_register_pm_notifier;
+
+	ret = register_reboot_notifier(&hotplug_reboot_notifier);
+	if (ret)
+		goto err_register_reboot_notifier;
+
+	return 0;
+
+err_register_reboot_notifier:
+	unregister_pm_notifier(&standalone_hotplug_notifier);
+err_register_pm_notifier:
+err_kobject_init_and_add:
+	cancel_delayed_work(&hotplug_work);
+	cpufreq_unregister_notifier(&hotplug_freq_notifier,
+				CPUFREQ_POLICY_NOTIFIER);
+err_cpufreq_register_notifier:
+	clk_put(cpu_clk);
+err_clk_get_sys:
+	destroy_workqueue(hotplug_wq);
+err_create_singlethread_workqueue:
+	return ret;
+}
+
+module_init(stand_alone_hotplug_init);
+
+static struct platform_device standalone_hotplug_device = {
+	.name = "standalone-cpu-hotplug",
+	.id = -1,
+};
+
+static int __init standalone_hotplug_device_init(void)
+{
+	int ret;
+
+	ret = platform_device_register(&standalone_hotplug_device);
+
+	if (ret) {
+		pr_err("Register device Failed\n");
+		return ret;
+	}
+
+	printk(KERN_INFO "standalone_hotplug_device_init: %d\n", ret);
+
+	return ret;
+}
+
+module_init(standalone_hotplug_device_init);
diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 71fc4ee4..ef1bb7a2 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -25,8 +25,12 @@
 
 #include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 
 #include <asm/sched_clock.h>
+#include <asm/delay.h>
 #include <mach/addr-map.h>
 #include <mach/regs-timers.h>
 #include <mach/regs-apbc.h>
@@ -36,26 +40,89 @@
 
 #include "clock.h"
 
+#ifdef CONFIG_PXA_32KTIMER
+#define CLOCK_TICK_RATE_32KHZ	32768
+#endif
+
+#ifdef CONFIG_ARCH_PROVIDES_UDELAY
+#define TIMER2_EN	(0x1 << 2)
+#else
+#define TIMER2_EN	0x0
+#endif
+
 #define TIMERS_VIRT_BASE	TIMERS1_VIRT_BASE
 
 #define MAX_DELTA		(0xfffffffe)
 #define MIN_DELTA		(16)
 
+static void __iomem *mmp_timer_base = TIMERS_VIRT_BASE;
+
 /*
  * FIXME: the timer needs some delay to stablize the counter capture
  */
 static inline uint32_t timer_read(void)
 {
-	int delay = 100;
+	u32 val = 0;
 
-	__raw_writel(1, TIMERS_VIRT_BASE + TMR_CVWR(1));
+#ifdef CONFIG_PXA_32KTIMER
+	u32 val2 = 0;
+	do {
+		val = __raw_readl(mmp_timer_base + TMR_CR(1));
+		val2 = __raw_readl(mmp_timer_base + TMR_CR(1));
+	} while (val2 != val);
+#else /* CONFIG_PXA_32KTIMER */
+	u32 delay = 3;
+
+	__raw_writel(1, mmp_timer_base + TMR_CVWR(1));
 
 	while (delay--)
-		cpu_relax();
+		val = __raw_readl(mmp_timer_base + TMR_CVWR(1));
+#endif /* CONFIG_PXA_32KTIMER */
+	return val;
+}
 
-	return __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(1));
+#ifdef CONFIG_ARCH_PROVIDES_UDELAY
+#define UDELAY_MAX_LOOP_STEP_US		20
+#define UDELAY_MIN_CPU_FREQ_MHZ		156
+static inline u32 timer_read_udelay_tick(void)
+{
+	u32 val;
+	u32 delay = 3;
+
+	__raw_writel(1, mmp_timer_base + TMR_CVWR(2));
+
+	while (delay--)
+		val = __raw_readl(mmp_timer_base + TMR_CVWR(2));
+
+	return val;
+}
+
+void __udelay(unsigned long usecs)
+{
+	u32 now, begin, end;
+	u32 ticks, loops;
+
+	ticks = usecs * CLOCK_TICK_RATE / 1000000;
+	if (usecs < UDELAY_MAX_LOOP_STEP_US)
+		loops = usecs * UDELAY_MIN_CPU_FREQ_MHZ;
+	else
+		loops = UDELAY_MAX_LOOP_STEP_US * UDELAY_MIN_CPU_FREQ_MHZ;
+
+	begin = timer_read_udelay_tick();
+	end = begin + ticks;
+
+	do {
+		__delay(loops);
+		now = timer_read_udelay_tick();
+	} while ((now - begin) < ticks);
 }
 
+void __const_udelay(unsigned long usecs)
+{
+	return __udelay(usecs);
+}
+#endif /* CONFIG_ARCH_PROVIDES_UDELAY */
+
 static u32 notrace mmp_read_sched_clock(void)
 {
 	return timer_read();
@@ -68,12 +135,12 @@ static irqreturn_t timer_interrupt(int irq, void *dev_id)
 	/*
 	 * Clear pending interrupt status.
 	 */
-	__raw_writel(0x01, TIMERS_VIRT_BASE + TMR_ICR(0));
+	__raw_writel(0x01, mmp_timer_base + TMR_ICR(0));
 
 	/*
 	 * Disable timer 0.
 	 */
-	__raw_writel(0x02, TIMERS_VIRT_BASE + TMR_CER);
+	__raw_writel(0x02 | TIMER2_EN, mmp_timer_base + TMR_CER);
 
 	c->event_handler(c);
 
@@ -90,23 +157,31 @@ static int timer_set_next_event(unsigned long delta,
 	/*
 	 * Disable timer 0.
 	 */
-	__raw_writel(0x02, TIMERS_VIRT_BASE + TMR_CER);
+	__raw_writel(0x02 | TIMER2_EN, mmp_timer_base + TMR_CER);
 
+#ifdef CONFIG_PXA_32KTIMER
+	__raw_writel(TMR_CCR_CS_0(0) | TMR_CCR_CS_1(1),
+		mmp_timer_base + TMR_CCR);
+#endif
 	/*
 	 * Clear and enable timer match 0 interrupt.
 	 */
-	__raw_writel(0x01, TIMERS_VIRT_BASE + TMR_ICR(0));
-	__raw_writel(0x01, TIMERS_VIRT_BASE + TMR_IER(0));
+	__raw_writel(0x01, mmp_timer_base + TMR_ICR(0));
+	__raw_writel(0x01, mmp_timer_base + TMR_IER(0));
 
 	/*
 	 * Setup new clockevent timer value.
 	 */
-	__raw_writel(delta - 1, TIMERS_VIRT_BASE + TMR_TN_MM(0, 0));
+	__raw_writel(delta - 1, mmp_timer_base + TMR_TN_MM(0, 0));
 
+#ifdef CONFIG_PXA_32KTIMER
+	__raw_writel(TMR_CCR_CS_0(1) | TMR_CCR_CS_1(1),
+		mmp_timer_base + TMR_CCR);
+#endif
 	/*
 	 * Enable timer 0.
 	 */
-	__raw_writel(0x03, TIMERS_VIRT_BASE + TMR_CER);
+	__raw_writel(0x03 | TIMER2_EN, mmp_timer_base + TMR_CER);
 
 	local_irq_restore(flags);
 
@@ -124,7 +199,7 @@ static void timer_set_mode(enum clock_event_mode mode,
 	case CLOCK_EVT_MODE_UNUSED:
 	case CLOCK_EVT_MODE_SHUTDOWN:
 		/* disable the matching interrupt */
-		__raw_writel(0x00, TIMERS_VIRT_BASE + TMR_IER(0));
+		__raw_writel(0x00, mmp_timer_base + TMR_IER(0));
 		break;
 	case CLOCK_EVT_MODE_RESUME:
 	case CLOCK_EVT_MODE_PERIODIC:
@@ -136,7 +211,6 @@ static void timer_set_mode(enum clock_event_mode mode,
 static struct clock_event_device ckevt = {
 	.name		= "clockevent",
 	.features	= CLOCK_EVT_FEAT_ONESHOT,
-	.shift		= 32,
 	.rating		= 200,
 	.set_next_event	= timer_set_next_event,
 	.set_mode	= timer_set_mode,
@@ -157,27 +231,35 @@ static struct clocksource cksrc = {
 
 static void __init timer_config(void)
 {
-	uint32_t ccr = __raw_readl(TIMERS_VIRT_BASE + TMR_CCR);
-
-	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_CER); /* disable */
-
-	ccr &= (cpu_is_mmp2()) ? (TMR_CCR_CS_0(0) | TMR_CCR_CS_1(0)) :
-		(TMR_CCR_CS_0(3) | TMR_CCR_CS_1(3));
-	__raw_writel(ccr, TIMERS_VIRT_BASE + TMR_CCR);
-
-	/* set timer 0 to periodic mode, and timer 1 to free-running mode */
-	__raw_writel(0x2, TIMERS_VIRT_BASE + TMR_CMR);
-
-	__raw_writel(0x1, TIMERS_VIRT_BASE + TMR_PLCR(0)); /* periodic */
-	__raw_writel(0x7, TIMERS_VIRT_BASE + TMR_ICR(0));  /* clear status */
-	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(0));
-
-	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_PLCR(1)); /* free-running */
-	__raw_writel(0x7, TIMERS_VIRT_BASE + TMR_ICR(1));  /* clear status */
-	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(1));
-
-	/* enable timer 1 counter */
-	__raw_writel(0x2, TIMERS_VIRT_BASE + TMR_CER);
+	uint32_t ccr;
+
+	__raw_writel(0x0, mmp_timer_base + TMR_CER); /* disable */
+
+#ifdef CONFIG_PXA_32KTIMER
+	ccr = TMR_CCR_CS_0(1) | TMR_CCR_CS_1(1);
+#else
+	ccr = TMR_CCR_CS_0(0) | TMR_CCR_CS_1(0);
+#endif
+	__raw_writel(ccr, mmp_timer_base + TMR_CCR);
+
+	/* set timer 0 to periodic mode, and timer 1/2 to free-running mode */
+	__raw_writel(0x2 | TIMER2_EN, mmp_timer_base + TMR_CMR);
+
+	__raw_writel(0x1, mmp_timer_base + TMR_PLCR(0)); /* periodic */
+	__raw_writel(0x7, mmp_timer_base + TMR_ICR(0));  /* clear status */
+	__raw_writel(0x0, mmp_timer_base + TMR_IER(0));
+
+	__raw_writel(0x0, mmp_timer_base + TMR_PLCR(1)); /* free-running */
+	__raw_writel(0x7, mmp_timer_base + TMR_ICR(1));  /* clear status */
+	__raw_writel(0x0, mmp_timer_base + TMR_IER(1));
+
+#ifdef CONFIG_ARCH_PROVIDES_UDELAY
+	__raw_writel(0x0, mmp_timer_base + TMR_PLCR(2)); /* free-running */
+	__raw_writel(0x7, mmp_timer_base + TMR_ICR(2));  /* clear status */
+	__raw_writel(0x0, mmp_timer_base + TMR_IER(2));
+#endif
+	/* enable timer 1/2 counter */
+	__raw_writel(0x2 | TIMER2_EN, mmp_timer_base + TMR_CER);
 }
 
 static struct irqaction timer_irq = {
@@ -191,15 +273,57 @@ void __init timer_init(int irq)
 {
 	timer_config();
 
+#ifdef CONFIG_PXA_32KTIMER
+	setup_sched_clock(mmp_read_sched_clock, 32, CLOCK_TICK_RATE_32KHZ);
+	clockevents_calc_mult_shift(&ckevt, CLOCK_TICK_RATE_32KHZ, 4);
+#else
 	setup_sched_clock(mmp_read_sched_clock, 32, CLOCK_TICK_RATE);
-
-	ckevt.mult = div_sc(CLOCK_TICK_RATE, NSEC_PER_SEC, ckevt.shift);
+	clockevents_calc_mult_shift(&ckevt, CLOCK_TICK_RATE, 4);
+#endif
 	ckevt.max_delta_ns = clockevent_delta2ns(MAX_DELTA, &ckevt);
 	ckevt.min_delta_ns = clockevent_delta2ns(MIN_DELTA, &ckevt);
 	ckevt.cpumask = cpumask_of(0);
+	ckevt.irq = irq;
 
 	setup_irq(irq, &timer_irq);
-
+#ifdef CONFIG_PXA_32KTIMER
+	clocksource_register_hz(&cksrc, CLOCK_TICK_RATE_32KHZ);
+#else
 	clocksource_register_hz(&cksrc, CLOCK_TICK_RATE);
+#endif
 	clockevents_register_device(&ckevt);
 }
+
+#ifdef CONFIG_OF
+static struct of_device_id mmp_timer_dt_ids[] = {
+	{ .compatible = "mrvl,mmp-timer", },
+	{}
+};
+
+void __init mmp_dt_init_timer(void)
+{
+	struct device_node *np;
+	int irq, ret;
+
+	np = of_find_matching_node(NULL, mmp_timer_dt_ids);
+	if (!np) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	irq = irq_of_parse_and_map(np, 0);
+	if (!irq) {
+		ret = -EINVAL;
+		goto out;
+	}
+	mmp_timer_base = of_iomap(np, 0);
+	if (!mmp_timer_base) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	timer_init(irq);
+	return;
+out:
+	pr_err("Failed to get timer from device tree with error:%d\n", ret);
+}
+#endif
diff --git a/arch/arm/mach-mmp/wakeupgen.c b/arch/arm/mach-mmp/wakeupgen.c
new file mode 100644
index 00000000..63e66c1c
--- /dev/null
+++ b/arch/arm/mach-mmp/wakeupgen.c
@@ -0,0 +1,184 @@
+/*
+ * linux/arch/arm/mach-mmp/wakeupgen.c
+ *
+ * This mmp wakeup generation is the interrupt controller extension used
+ * along with ARM GIC to wake the CPU out from low power states on external
+ * interrupts. This extension always keeps the mask status and wake up
+ * affinity the same mapping as in the GIC. In the normal CPU active mode,
+ * the global interrupts in the icu are masked, external interrupts route
+ * directly to the GIC.
+
+ * Copyright (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <asm/hardware/gic.h>
+#include <mach/features.h>
+#include <mach/irqs.h>
+#include <mach/regs-icu.h>
+#include <mach/regs-apbc.h>
+
+#define ICU_INT_CONF_CPU3	(1 << 9)
+#define ICU_INT_CONF_CPU2	(1 << 8)
+#define ICU_INT_CONF_CPU1	(1 << 7)
+#define ICU_INT_CONF_CPU0	(1 << 6)
+#define ICU_INT_CONF_AP(n)	(1 << (6 + (n & 0x3)))
+#define ICU_INT_CONF_AP_MASK	(0xF << 6)
+#define ICU_INT_CONF_IRQ_FIQ	(1 << 4)
+#define ICU_INT_CONF_PRIO(n)	(n & 0xF)
+#define ICU_INT_CONF_MASKING	(0 << 0)
+
+#define ICU_IRQ_CPU0_MASKED	(ICU_INT_CONF_IRQ_FIQ | ICU_INT_CONF_CPU0)
+
+#if defined(CONFIG_CPU_PXA988)
+#define ICU_IRQ_START	IRQ_PXA988_START
+#define ICU_IRQ_END	IRQ_PXA988_END
+#elif defined(CONFIG_CPU_PXA1088)
+#define ICU_IRQ_START	IRQ_PXA1088_START
+#define ICU_IRQ_END	IRQ_PXA1088_END
+#endif
+
+/*
+ * Return:
+ * >=0: the irq line for ICU
+ * -1: no need to handle this irq line
+ */
+static inline int irq_need_handle(struct irq_data *d)
+{
+	/* Avoid modify CP interrupts */
+	if (d->irq == IRQ_PXA988_AIRQ
+	 || d->irq == IRQ_PXA988_CP_TIMER1
+	 || d->irq == IRQ_PXA988_CP_TIMER2_3)
+		return -1;
+
+	/* out of the ICU range */
+	if (d->irq >= ICU_IRQ_END)
+		return -1;
+
+#ifdef CONFIG_CPU_PXA988
+	/* WORKAROUND: Trigger IPC interrupt to wake cores when sending IPI */
+	if (d->irq == IRQ_PXA988_IPC_AP3)
+		return -1;
+#endif
+
+	/*
+	 * the icu connects the sys_int_ap interrupt source to the SPI interface
+	 * of the GIC. since the GIC SPI interrupts start from 32, here minus 32
+	 * from the GIC spi irq number to get the raw icu based irq.
+	 * For PPI and SGI, just skip it.
+	 */
+	return d->irq - ICU_IRQ_START;
+}
+
+static void icu_mask_irq(struct irq_data *d)
+{
+	void __iomem *reg;
+	unsigned long val;
+	int irq;
+
+	irq = irq_need_handle(d);
+	if (irq < 0)
+		return;
+
+	reg = ICU_INT_CONF(irq);
+	val = __raw_readl(reg);
+	val &= ~0xF;
+	__raw_writel(val, reg);
+}
+
+static void icu_unmask_irq(struct irq_data *d)
+{
+	void __iomem *reg;
+	unsigned long val;
+	int irq;
+
+	irq = irq_need_handle(d);
+	if (irq < 0)
+		return;
+
+	reg = ICU_INT_CONF(irq);
+	val = __raw_readl(reg);
+	val &= ~0xF;
+	val |= ICU_INT_CONF_PRIO(1);
+	__raw_writel(val, reg);
+}
+
+static int icu_set_affinity(struct irq_data *d,
+	const struct cpumask *mask_val, bool force)
+{
+	void __iomem *reg;
+	unsigned long val;
+	unsigned int cpu;
+	int irq;
+
+	irq = irq_need_handle(d);
+	if (irq < 0)
+		return 0;
+
+	cpu = cpumask_first(mask_val);
+	reg = ICU_INT_CONF(irq);
+	val = __raw_readl(reg);
+	val &= ~ICU_INT_CONF_AP_MASK;
+	val |= ICU_INT_CONF_AP(cpu);
+	__raw_writel(val, reg);
+
+	return 0;
+}
+
+void __init mmp_wakeupgen_init(void)
+{
+	int irq;
+
+	/* disable global irq/fiq in icu for all the cores */
+#if defined(CONFIG_CPU_PXA988)
+	__raw_writel(0x3, PXA988_ICU_CP_GBL_INT_MSK);
+	__raw_writel(0x3, PXA988_ICU_A9C0_GBL_INT_MSK);
+	__raw_writel(0x3, PXA988_ICU_A9C1_GBL_INT_MSK);
+#elif defined(CONFIG_CPU_PXA1088)
+	__raw_writel(0x3, PXA1088_ICU_CP_GBL_INT_MSK);
+	__raw_writel(0x3, PXA1088_ICU_APC0_GBL_INT_MSK);
+	__raw_writel(0x3, PXA1088_ICU_APC1_GBL_INT_MSK);
+	__raw_writel(0x3, PXA1088_ICU_APC2_GBL_INT_MSK);
+	__raw_writel(0x3, PXA1088_ICU_APC3_GBL_INT_MSK);
+#endif
+	/*
+	 * config all the interrupt source be able to interrupt the cpu 0,
+	 * except those which are routed to Seagull
+	 * in IRQ mode, with priority 0 as masked by default.
+	 */
+	for (irq = 0; irq < ICU_IRQ_END - ICU_IRQ_START; irq++) {
+		if (irq == IRQ_PXA988_AIRQ - ICU_IRQ_START
+		 || irq == IRQ_PXA988_CP_TIMER1 - ICU_IRQ_START
+		 || irq == IRQ_PXA988_CP_TIMER2_3 - ICU_IRQ_START)
+			__raw_writel(__raw_readl(ICU_INT_CONF(irq)) &
+					~ICU_INT_CONF_CPU0, ICU_INT_CONF(irq));
+		else
+			__raw_writel(ICU_IRQ_CPU0_MASKED, ICU_INT_CONF(irq));
+	}
+
+#ifdef CONFIG_CPU_PXA988
+	if (has_feat_ipc_wakeup_core()) {
+		/*
+		* "Trigger IPC interrupt to wake cores when sending IPI"
+		* Enable the IPC AP3 in ICU to let the IPC interrupt be able to
+		* wake up two AP cores.
+		*/
+		__raw_writel(APBC_APBCLK | APBC_RST, APBC_PXA988_IPC);
+		__raw_writel(APBC_APBCLK | APBC_FNCLK, APBC_PXA988_IPC);
+
+	#define ICU_IRQ_CPU_ALL_ENABLE	(ICU_INT_CONF_IRQ_FIQ |\
+		ICU_INT_CONF_CPU0 | ICU_INT_CONF_CPU1 | ICU_INT_CONF_PRIO(2))
+		irq = IRQ_PXA988_IPC_AP3 - IRQ_PXA988_START;
+		__raw_writel(ICU_IRQ_CPU_ALL_ENABLE, ICU_INT_CONF(irq));
+	}
+#endif
+
+	gic_arch_extn.irq_mask = icu_mask_irq;
+	gic_arch_extn.irq_unmask = icu_unmask_irq;
+	gic_arch_extn.irq_set_affinity = icu_set_affinity;
+}
diff --git a/arch/arm/mm/Makefile b/arch/arm/mm/Makefile
index bca7e619..09fd4b60 100644
--- a/arch/arm/mm/Makefile
+++ b/arch/arm/mm/Makefile
@@ -7,6 +7,7 @@ obj-y				:= dma-mapping.o extable.o fault.o init.o \
 
 obj-$(CONFIG_MMU)		+= fault-armv.o flush.o idmap.o ioremap.o \
 				   mmap.o pgd.o mmu.o vmregion.o
+obj-$(CONFIG_DEBUG_RODATA)	+= rodata.o
 
 ifneq ($(CONFIG_MMU),y)
 obj-y				+= nommu.o
@@ -100,3 +101,4 @@ obj-$(CONFIG_CACHE_FEROCEON_L2)	+= cache-feroceon-l2.o
 obj-$(CONFIG_CACHE_L2X0)	+= cache-l2x0.o
 obj-$(CONFIG_CACHE_XSC3L2)	+= cache-xsc3l2.o
 obj-$(CONFIG_CACHE_TAUROS2)	+= cache-tauros2.o
+obj-$(CONFIG_CACHE_TAUROS3)	+= cache-tauros3.o
diff --git a/arch/arm/mm/alignment.c b/arch/arm/mm/alignment.c
index 9107231a..fc000e3a 100644
--- a/arch/arm/mm/alignment.c
+++ b/arch/arm/mm/alignment.c
@@ -750,7 +750,6 @@ do_alignment(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 	unsigned long instr = 0, instrptr;
 	int (*handler)(unsigned long addr, unsigned long instr, struct pt_regs *regs);
 	unsigned int type;
-	mm_segment_t fs;
 	unsigned int fault;
 	u16 tinstr = 0;
 	int isize = 4;
@@ -761,16 +760,15 @@ do_alignment(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 
 	instrptr = instruction_pointer(regs);
 
-	fs = get_fs();
-	set_fs(KERNEL_DS);
 	if (thumb_mode(regs)) {
-		fault = __get_user(tinstr, (u16 *)(instrptr & ~1));
+		u16 *ptr = (u16 *)(instrptr & ~1);
+		fault = probe_kernel_address(ptr, tinstr);
 		if (!fault) {
 			if (cpu_architecture() >= CPU_ARCH_ARMv7 &&
 			    IS_T32(tinstr)) {
 				/* Thumb-2 32-bit */
 				u16 tinst2 = 0;
-				fault = __get_user(tinst2, (u16 *)(instrptr+2));
+				fault = probe_kernel_address(ptr + 1, tinst2);
 				instr = (tinstr << 16) | tinst2;
 				thumb2_32b = 1;
 			} else {
@@ -779,8 +777,7 @@ do_alignment(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 			}
 		}
 	} else
-		fault = __get_user(instr, (u32 *)instrptr);
-	set_fs(fs);
+		fault = probe_kernel_address(instrptr, instr);
 
 	if (fault) {
 		type = TYPE_FAULT;
diff --git a/arch/arm/mm/cache-l2x0.c b/arch/arm/mm/cache-l2x0.c
index 2a8e3805..804e65d5 100644
--- a/arch/arm/mm/cache-l2x0.c
+++ b/arch/arm/mm/cache-l2x0.c
@@ -28,13 +28,24 @@
 
 #define CACHE_LINE_SIZE		32
 
-static void __iomem *l2x0_base;
+void __iomem *l2x0_base;
 static DEFINE_RAW_SPINLOCK(l2x0_lock);
 static u32 l2x0_way_mask;	/* Bitmask of active ways */
 static u32 l2x0_size;
+static u32 l2x0_cache_id;
+static unsigned int l2x0_sets;
+static unsigned int l2x0_ways;
 static unsigned long sync_reg_offset = L2X0_CACHE_SYNC;
 
+static inline bool is_pl310_rev(int rev)
+{
+	return (l2x0_cache_id &
+		(L2X0_CACHE_ID_PART_MASK | L2X0_CACHE_ID_REV_MASK)) ==
+			(L2X0_CACHE_ID_PART_L310 | rev);
+}
+
 struct l2x0_regs l2x0_saved_regs;
+u32 l2x0_saved_regs_phys_addr;
 
 struct l2x0_of_data {
 	void (*setup)(const struct device_node *, u32 *, u32 *);
@@ -130,6 +141,23 @@ static void l2x0_cache_sync(void)
 	raw_spin_unlock_irqrestore(&l2x0_lock, flags);
 }
 
+#ifdef CONFIG_PL310_ERRATA_727915
+static void l2x0_for_each_set_way(void __iomem *reg)
+{
+	int set;
+	int way;
+	unsigned long flags;
+
+	for (way = 0; way < l2x0_ways; way++) {
+		raw_spin_lock_irqsave(&l2x0_lock, flags);
+		for (set = 0; set < l2x0_sets; set++)
+			writel_relaxed((way << 28) | (set << 5), reg);
+		cache_sync();
+		raw_spin_unlock_irqrestore(&l2x0_lock, flags);
+	}
+}
+#endif
+
 static void __l2x0_flush_all(void)
 {
 	debug_writel(0x03);
@@ -143,6 +171,13 @@ static void l2x0_flush_all(void)
 {
 	unsigned long flags;
 
+#ifdef CONFIG_PL310_ERRATA_727915
+	if (is_pl310_rev(REV_PL310_R2P0)) {
+		l2x0_for_each_set_way(l2x0_base + L2X0_CLEAN_INV_LINE_IDX);
+		return;
+	}
+#endif
+
 	/* clean all ways */
 	raw_spin_lock_irqsave(&l2x0_lock, flags);
 	__l2x0_flush_all();
@@ -153,11 +188,20 @@ static void l2x0_clean_all(void)
 {
 	unsigned long flags;
 
+#ifdef CONFIG_PL310_ERRATA_727915
+	if (is_pl310_rev(REV_PL310_R2P0)) {
+		l2x0_for_each_set_way(l2x0_base + L2X0_CLEAN_LINE_IDX);
+		return;
+	}
+#endif
+
 	/* clean all ways */
 	raw_spin_lock_irqsave(&l2x0_lock, flags);
+	debug_writel(0x03);
 	writel_relaxed(l2x0_way_mask, l2x0_base + L2X0_CLEAN_WAY);
 	cache_wait_way(l2x0_base + L2X0_CLEAN_WAY, l2x0_way_mask);
 	cache_sync();
+	debug_writel(0x00);
 	raw_spin_unlock_irqrestore(&l2x0_lock, flags);
 }
 
@@ -309,52 +353,74 @@ static void l2x0_unlock(u32 cache_id)
 void __init l2x0_init(void __iomem *base, u32 aux_val, u32 aux_mask)
 {
 	u32 aux;
-	u32 cache_id;
 	u32 way_size = 0;
-	int ways;
+	u32 prefetch_ctrl = 0;
 	const char *type;
 
 	l2x0_base = base;
 
-	cache_id = readl_relaxed(l2x0_base + L2X0_CACHE_ID);
+	l2x0_cache_id = readl_relaxed(l2x0_base + L2X0_CACHE_ID);
 	aux = readl_relaxed(l2x0_base + L2X0_AUX_CTRL);
 
-	aux &= aux_mask;
-	aux |= aux_val;
-
 	/* Determine the number of ways */
-	switch (cache_id & L2X0_CACHE_ID_PART_MASK) {
+	switch (l2x0_cache_id & L2X0_CACHE_ID_PART_MASK) {
 	case L2X0_CACHE_ID_PART_L310:
 		if (aux & (1 << 16))
-			ways = 16;
+			l2x0_ways = 16;
 		else
-			ways = 8;
+			l2x0_ways = 8;
 		type = "L310";
 #ifdef CONFIG_PL310_ERRATA_753970
 		/* Unmapped register. */
 		sync_reg_offset = L2X0_DUMMY_REG;
 #endif
+
 		outer_cache.set_debug = pl310_set_debug;
+
+		/*
+		 * Set bit 22 in the auxiliary control register. If this bit
+		 * is cleared, PL310 treats Normal Shared Non-cacheable
+		 * accesses as Cacheable no-allocate.
+		 */
+		aux_val |= 1 << 22;
 		break;
 	case L2X0_CACHE_ID_PART_L210:
-		ways = (aux >> 13) & 0xf;
+		l2x0_ways = (aux >> 13) & 0xf;
 		type = "L210";
 		break;
 	default:
 		/* Assume unknown chips have 8 ways */
-		ways = 8;
+		l2x0_ways = 8;
 		type = "L2x0 series";
 		break;
 	}
 
-	l2x0_way_mask = (1 << ways) - 1;
+	l2x0_way_mask = (1 << l2x0_ways) - 1;
 
 	/*
 	 * L2 cache Size =  Way size * Number of ways
 	 */
 	way_size = (aux & L2X0_AUX_CTRL_WAY_SIZE_MASK) >> 17;
-	way_size = 1 << (way_size + 3);
-	l2x0_size = ways * way_size * SZ_1K;
+	way_size = SZ_1K << (way_size + 3);
+	l2x0_size = l2x0_ways * way_size;
+	l2x0_sets = way_size / CACHE_LINE_SIZE;
+
+#ifdef CONFIG_CACHE_L2X0_PREFETCH
+	/* Configure double line fill and prefetch */
+	prefetch_ctrl |= (1u << 30); /* DLF (double linefill) enabled*/
+	prefetch_ctrl |= (1u << 29); /* instruction prefetch enabled */
+	prefetch_ctrl |= (1u << 28); /* data prefetch enabled */
+
+	if (CONFIG_CACHE_L2X0_PREFETCH_OFFSET <= 7)
+		prefetch_ctrl |= CONFIG_CACHE_L2X0_PREFETCH_OFFSET;
+	else if (CONFIG_CACHE_L2X0_PREFETCH_OFFSET <= 15)
+		prefetch_ctrl |= 15;
+	else if (CONFIG_CACHE_L2X0_PREFETCH_OFFSET <= 23)
+		prefetch_ctrl |= 23;
+	else
+		prefetch_ctrl |= 31;
+	writel_relaxed(prefetch_ctrl, l2x0_base + L2X0_PREFETCH_CTRL);
+#endif
 
 	/*
 	 * Check if l2x0 controller is already enabled.
@@ -363,18 +429,30 @@ void __init l2x0_init(void __iomem *base, u32 aux_val, u32 aux_mask)
 	 */
 	if (!(readl_relaxed(l2x0_base + L2X0_CTRL) & 1)) {
 		/* Make sure that I&D is not locked down when starting */
-		l2x0_unlock(cache_id);
+		l2x0_unlock(l2x0_cache_id);
+
+		aux &= aux_mask;
+		aux |= aux_val;
 
 		/* l2x0 controller is disabled */
 		writel_relaxed(aux, l2x0_base + L2X0_AUX_CTRL);
 
-		l2x0_saved_regs.aux_ctrl = aux;
-
 		l2x0_inv_all();
 
 		/* enable L2X0 */
 		writel_relaxed(1, l2x0_base + L2X0_CTRL);
 	}
+	/*
+	 * l2x0 controller is enabled at this time
+	 */
+	l2x0_saved_regs.ctrl = 1;
+
+	/* Re-read it in case some bits are reserved. */
+	aux = readl_relaxed(l2x0_base + L2X0_AUX_CTRL);
+
+	/* Save the value for resuming. */
+	l2x0_saved_regs.aux_ctrl = aux;
+	l2x0_saved_regs_phys_addr = virt_to_phys(&l2x0_saved_regs);
 
 	outer_cache.inv_range = l2x0_inv_range;
 	outer_cache.clean_range = l2x0_clean_range;
@@ -386,83 +464,15 @@ void __init l2x0_init(void __iomem *base, u32 aux_val, u32 aux_mask)
 
 	printk(KERN_INFO "%s cache controller enabled\n", type);
 	printk(KERN_INFO "l2x0: %d ways, CACHE_ID 0x%08x, AUX_CTRL 0x%08x, Cache size: %d B\n",
-			ways, cache_id, aux, l2x0_size);
-}
-
-#ifdef CONFIG_OF
-static void __init l2x0_of_setup(const struct device_node *np,
-				 u32 *aux_val, u32 *aux_mask)
-{
-	u32 data[2] = { 0, 0 };
-	u32 tag = 0;
-	u32 dirty = 0;
-	u32 val = 0, mask = 0;
-
-	of_property_read_u32(np, "arm,tag-latency", &tag);
-	if (tag) {
-		mask |= L2X0_AUX_CTRL_TAG_LATENCY_MASK;
-		val |= (tag - 1) << L2X0_AUX_CTRL_TAG_LATENCY_SHIFT;
-	}
-
-	of_property_read_u32_array(np, "arm,data-latency",
-				   data, ARRAY_SIZE(data));
-	if (data[0] && data[1]) {
-		mask |= L2X0_AUX_CTRL_DATA_RD_LATENCY_MASK |
-			L2X0_AUX_CTRL_DATA_WR_LATENCY_MASK;
-		val |= ((data[0] - 1) << L2X0_AUX_CTRL_DATA_RD_LATENCY_SHIFT) |
-		       ((data[1] - 1) << L2X0_AUX_CTRL_DATA_WR_LATENCY_SHIFT);
-	}
-
-	of_property_read_u32(np, "arm,dirty-latency", &dirty);
-	if (dirty) {
-		mask |= L2X0_AUX_CTRL_DIRTY_LATENCY_MASK;
-		val |= (dirty - 1) << L2X0_AUX_CTRL_DIRTY_LATENCY_SHIFT;
-	}
-
-	*aux_val &= ~mask;
-	*aux_val |= val;
-	*aux_mask &= ~mask;
-}
-
-static void __init pl310_of_setup(const struct device_node *np,
-				  u32 *aux_val, u32 *aux_mask)
-{
-	u32 data[3] = { 0, 0, 0 };
-	u32 tag[3] = { 0, 0, 0 };
-	u32 filter[2] = { 0, 0 };
-
-	of_property_read_u32_array(np, "arm,tag-latency", tag, ARRAY_SIZE(tag));
-	if (tag[0] && tag[1] && tag[2])
-		writel_relaxed(
-			((tag[0] - 1) << L2X0_LATENCY_CTRL_RD_SHIFT) |
-			((tag[1] - 1) << L2X0_LATENCY_CTRL_WR_SHIFT) |
-			((tag[2] - 1) << L2X0_LATENCY_CTRL_SETUP_SHIFT),
-			l2x0_base + L2X0_TAG_LATENCY_CTRL);
-
-	of_property_read_u32_array(np, "arm,data-latency",
-				   data, ARRAY_SIZE(data));
-	if (data[0] && data[1] && data[2])
-		writel_relaxed(
-			((data[0] - 1) << L2X0_LATENCY_CTRL_RD_SHIFT) |
-			((data[1] - 1) << L2X0_LATENCY_CTRL_WR_SHIFT) |
-			((data[2] - 1) << L2X0_LATENCY_CTRL_SETUP_SHIFT),
-			l2x0_base + L2X0_DATA_LATENCY_CTRL);
-
-	of_property_read_u32_array(np, "arm,filter-ranges",
-				   filter, ARRAY_SIZE(filter));
-	if (filter[1]) {
-		writel_relaxed(ALIGN(filter[0] + filter[1], SZ_1M),
-			       l2x0_base + L2X0_ADDR_FILTER_END);
-		writel_relaxed((filter[0] & ~(SZ_1M - 1)) | L2X0_ADDR_FILTER_EN,
-			       l2x0_base + L2X0_ADDR_FILTER_START);
-	}
+			l2x0_ways, l2x0_cache_id, aux, l2x0_size);
 }
 
-static void __init pl310_save(void)
+void pl310_save(void)
 {
 	u32 l2x0_revision = readl_relaxed(l2x0_base + L2X0_CACHE_ID) &
 		L2X0_CACHE_ID_RTL_MASK;
 
+	l2x0_saved_regs.ctrl = readl_relaxed(l2x0_base + L2X0_CTRL);
 	l2x0_saved_regs.tag_latency = readl_relaxed(l2x0_base +
 		L2X0_TAG_LATENCY_CTRL);
 	l2x0_saved_regs.data_latency = readl_relaxed(l2x0_base +
@@ -487,6 +497,20 @@ static void __init pl310_save(void)
 	}
 }
 
+void pl310_suspend(void)
+{
+	pl310_save();
+
+	__cpuc_flush_dcache_area((void *)&l2x0_saved_regs,
+				sizeof(l2x0_saved_regs));
+	outer_clean_range(l2x0_saved_regs_phys_addr,
+			  l2x0_saved_regs_phys_addr + sizeof(l2x0_saved_regs));
+}
+
+void flush_l2x0_lock(void)
+{
+	__cpuc_flush_dcache_area(&l2x0_lock, sizeof(l2x0_lock));
+}
 static void l2x0_resume(void)
 {
 	if (!(readl_relaxed(l2x0_base + L2X0_CTRL) & 1)) {
@@ -502,7 +526,7 @@ static void l2x0_resume(void)
 	}
 }
 
-static void pl310_resume(void)
+void pl310_resume(void)
 {
 	u32 l2x0_revision;
 
@@ -532,6 +556,75 @@ static void pl310_resume(void)
 	l2x0_resume();
 }
 
+#ifdef CONFIG_OF
+static void __init l2x0_of_setup(const struct device_node *np,
+				 u32 *aux_val, u32 *aux_mask)
+{
+	u32 data[2] = { 0, 0 };
+	u32 tag = 0;
+	u32 dirty = 0;
+	u32 val = 0, mask = 0;
+
+	of_property_read_u32(np, "arm,tag-latency", &tag);
+	if (tag) {
+		mask |= L2X0_AUX_CTRL_TAG_LATENCY_MASK;
+		val |= (tag - 1) << L2X0_AUX_CTRL_TAG_LATENCY_SHIFT;
+	}
+
+	of_property_read_u32_array(np, "arm,data-latency",
+				   data, ARRAY_SIZE(data));
+	if (data[0] && data[1]) {
+		mask |= L2X0_AUX_CTRL_DATA_RD_LATENCY_MASK |
+			L2X0_AUX_CTRL_DATA_WR_LATENCY_MASK;
+		val |= ((data[0] - 1) << L2X0_AUX_CTRL_DATA_RD_LATENCY_SHIFT) |
+		       ((data[1] - 1) << L2X0_AUX_CTRL_DATA_WR_LATENCY_SHIFT);
+	}
+
+	of_property_read_u32(np, "arm,dirty-latency", &dirty);
+	if (dirty) {
+		mask |= L2X0_AUX_CTRL_DIRTY_LATENCY_MASK;
+		val |= (dirty - 1) << L2X0_AUX_CTRL_DIRTY_LATENCY_SHIFT;
+	}
+
+	*aux_val &= ~mask;
+	*aux_val |= val;
+	*aux_mask &= ~mask;
+}
+
+static void __init pl310_of_setup(const struct device_node *np,
+				  u32 *aux_val, u32 *aux_mask)
+{
+	u32 data[3] = { 0, 0, 0 };
+	u32 tag[3] = { 0, 0, 0 };
+	u32 filter[2] = { 0, 0 };
+
+	of_property_read_u32_array(np, "arm,tag-latency", tag, ARRAY_SIZE(tag));
+	if (tag[0] && tag[1] && tag[2])
+		writel_relaxed(
+			((tag[0] - 1) << L2X0_LATENCY_CTRL_RD_SHIFT) |
+			((tag[1] - 1) << L2X0_LATENCY_CTRL_WR_SHIFT) |
+			((tag[2] - 1) << L2X0_LATENCY_CTRL_SETUP_SHIFT),
+			l2x0_base + L2X0_TAG_LATENCY_CTRL);
+
+	of_property_read_u32_array(np, "arm,data-latency",
+				   data, ARRAY_SIZE(data));
+	if (data[0] && data[1] && data[2])
+		writel_relaxed(
+			((data[0] - 1) << L2X0_LATENCY_CTRL_RD_SHIFT) |
+			((data[1] - 1) << L2X0_LATENCY_CTRL_WR_SHIFT) |
+			((data[2] - 1) << L2X0_LATENCY_CTRL_SETUP_SHIFT),
+			l2x0_base + L2X0_DATA_LATENCY_CTRL);
+
+	of_property_read_u32_array(np, "arm,filter-ranges",
+				   filter, ARRAY_SIZE(filter));
+	if (filter[1]) {
+		writel_relaxed(ALIGN(filter[0] + filter[1], SZ_1M),
+			       l2x0_base + L2X0_ADDR_FILTER_END);
+		writel_relaxed((filter[0] & ~(SZ_1M - 1)) | L2X0_ADDR_FILTER_EN,
+			       l2x0_base + L2X0_ADDR_FILTER_START);
+	}
+}
+
 static const struct l2x0_of_data pl310_data = {
 	pl310_of_setup,
 	pl310_save,
diff --git a/arch/arm/mm/cache-v7.S b/arch/arm/mm/cache-v7.S
index a655d3da..16c17b83 100644
--- a/arch/arm/mm/cache-v7.S
+++ b/arch/arm/mm/cache-v7.S
@@ -13,6 +13,7 @@
 #include <linux/linkage.h>
 #include <linux/init.h>
 #include <asm/assembler.h>
+#include <asm/errno.h>
 #include <asm/unwind.h>
 
 #include "proc-macros.S"
@@ -32,6 +33,24 @@ ENTRY(v7_flush_icache_all)
 	mov	pc, lr
 ENDPROC(v7_flush_icache_all)
 
+ /*
+ *     v7_flush_dcache_louis()
+ *
+ *     Flush the D-cache up to the Level of Unification Inner Shareable
+ *
+ *     Corrupted registers: r0-r7, r9-r11 (r6 only in Thumb mode)
+ */
+
+ENTRY(v7_flush_dcache_louis)
+	dmb					@ ensure ordering with previous memory accesses
+	mrc	p15, 1, r0, c0, c0, 1		@ read clidr, r0 = clidr
+	ands	r3, r0, #0xe00000		@ extract LoUIS from clidr
+	mov	r3, r3, lsr #20			@ r3 = LoUIS * 2
+	moveq	pc, lr				@ return if level == 0
+	mov	r10, #0				@ r10 (starting level) = 0
+	b	flush_levels			@ start flushing cache levels
+ENDPROC(v7_flush_dcache_louis)
+
 /*
  *	v7_flush_dcache_all()
  *
@@ -42,14 +61,21 @@ ENDPROC(v7_flush_icache_all)
  *	- mm    - mm_struct describing address space
  */
 ENTRY(v7_flush_dcache_all)
+#ifdef CONFIG_PJ4B_ERRATA_6359
+	dsb
+#else
 	dmb					@ ensure ordering with previous memory accesses
+#endif
 	mrc	p15, 1, r0, c0, c0, 1		@ read clidr
 	ands	r3, r0, #0x7000000		@ extract loc from clidr
 	mov	r3, r3, lsr #23			@ left align loc bit field
 	beq	finished			@ if loc is 0, then no need to clean
 	mov	r10, #0				@ start clean at cache level 0
-loop1:
+flush_levels:
 	add	r2, r10, r10, lsr #1		@ work out 3x current cache level
+#ifdef CONFIG_PJ4B_ERRATA_6315
+	mrc     p15, 1, r0, c0, c0, 1           @ read clidr
+#endif
 	mov	r1, r0, lsr r2			@ extract cache type bits from clidr
 	and	r1, r1, #7			@ mask of the bits for current cache only
 	cmp	r1, #2				@ see what cache we have at this level
@@ -70,24 +96,30 @@ loop1:
 	clz	r5, r4				@ find bit position of way size increment
 	ldr	r7, =0x7fff
 	ands	r7, r7, r1, lsr #13		@ extract max number of the index size
-loop2:
+loop1:
 	mov	r9, r4				@ create working copy of max way size
-loop3:
+loop2:
  ARM(	orr	r11, r10, r9, lsl r5	)	@ factor way and cache number into r11
  THUMB(	lsl	r6, r9, r5		)
  THUMB(	orr	r11, r10, r6		)	@ factor way and cache number into r11
  ARM(	orr	r11, r11, r7, lsl r2	)	@ factor index number into r11
  THUMB(	lsl	r6, r7, r2		)
  THUMB(	orr	r11, r11, r6		)	@ factor index number into r11
+#ifdef CONFIG_PJ4B_ERRATA_6315
+	dsb					@ replace dmb w. dsb to ensure ordering with previous memory accesses
+	mov	r0, #24				@ require approximately a 24 cycle delay to guarantee all outstanding
+1:	subs	r0, r0, #1			@ request to complete
+	bne	1b
+#endif
 	mcr	p15, 0, r11, c7, c14, 2		@ clean & invalidate by set/way
 	subs	r9, r9, #1			@ decrement the way
-	bge	loop3
-	subs	r7, r7, #1			@ decrement the index
 	bge	loop2
+	subs	r7, r7, #1			@ decrement the index
+	bge	loop1
 skip:
 	add	r10, r10, #2			@ increment cache number
 	cmp	r3, r10
-	bgt	loop1
+	bgt	flush_levels
 finished:
 	mov	r10, #0				@ swith back to cache level 0
 	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level in cssr
@@ -119,6 +151,24 @@ ENTRY(v7_flush_kern_cache_all)
 	mov	pc, lr
 ENDPROC(v7_flush_kern_cache_all)
 
+ /*
+ *     v7_flush_kern_cache_louis(void)
+ *
+ *     Flush the data cache up to Level of Unification Inner Shareable.
+ *     Invalidate the I-cache to the point of unification.
+ */
+ENTRY(v7_flush_kern_cache_louis)
+ ARM(	stmfd	sp!, {r4-r5, r7, r9-r11, lr}	)
+ THUMB(	stmfd	sp!, {r4-r7, r9-r11, lr}	)
+	bl	v7_flush_dcache_louis
+	mov	r0, #0
+	ALT_SMP(mcr	p15, 0, r0, c7, c1, 0)	@ invalidate I-cache inner shareable
+	ALT_UP(mcr	p15, 0, r0, c7, c5, 0)	@ I+BTB cache invalidate
+ ARM(	ldmfd	sp!, {r4-r5, r7, r9-r11, lr}	)
+ THUMB(	ldmfd	sp!, {r4-r7, r9-r11, lr}	)
+	mov	pc, lr
+ENDPROC(v7_flush_kern_cache_louis)
+
 /*
  *	v7_flush_cache_all()
  *
@@ -198,7 +248,6 @@ ENTRY(v7_coherent_user_range)
 	add	r12, r12, r2
 	cmp	r12, r1
 	blo	2b
-3:
 	mov	r0, #0
 	ALT_SMP(mcr	p15, 0, r0, c7, c1, 6)	@ invalidate BTB Inner Shareable
 	ALT_UP(mcr	p15, 0, r0, c7, c5, 6)	@ invalidate BTB
@@ -208,13 +257,14 @@ ENTRY(v7_coherent_user_range)
 
 /*
  * Fault handling for the cache operation above. If the virtual address in r0
- * isn't mapped, just try the next page.
+ * isn't mapped, fail with -EFAULT.
  */
 9001:
-	mov	r12, r12, lsr #12
-	mov	r12, r12, lsl #12
-	add	r12, r12, #4096
-	b	3b
+#ifdef CONFIG_ARM_ERRATA_775420
+	dsb
+#endif
+	mov	r0, #-EFAULT
+	mov	pc, lr
  UNWIND(.fnend		)
 ENDPROC(v7_coherent_kern_range)
 ENDPROC(v7_coherent_user_range)
diff --git a/arch/arm/mm/context.c b/arch/arm/mm/context.c
index ee9bb363..806cc4f6 100644
--- a/arch/arm/mm/context.c
+++ b/arch/arm/mm/context.c
@@ -18,30 +18,39 @@
 
 static DEFINE_RAW_SPINLOCK(cpu_asid_lock);
 unsigned int cpu_last_asid = ASID_FIRST_VERSION;
-#ifdef CONFIG_SMP
-DEFINE_PER_CPU(struct mm_struct *, current_mm);
-#endif
 
 #ifdef CONFIG_ARM_LPAE
-#define cpu_set_asid(asid) {						\
-	unsigned long ttbl, ttbh;					\
-	asm volatile(							\
-	"	mrrc	p15, 0, %0, %1, c2		@ read TTBR0\n"	\
-	"	mov	%1, %2, lsl #(48 - 32)		@ set ASID\n"	\
-	"	mcrr	p15, 0, %0, %1, c2		@ set TTBR0\n"	\
-	: "=&r" (ttbl), "=&r" (ttbh)					\
-	: "r" (asid & ~ASID_MASK));					\
+void cpu_set_reserved_ttbr0(void)
+{
+	unsigned long ttbl = __pa(swapper_pg_dir);
+	unsigned long ttbh = 0;
+
+	/*
+	 * Set TTBR0 to swapper_pg_dir which contains only global entries. The
+	 * ASID is set to 0.
+	 */
+	asm volatile(
+	"	mcrr	p15, 0, %0, %1, c2		@ set TTBR0\n"
+	:
+	: "r" (ttbl), "r" (ttbh));
+	isb();
 }
 #else
-#define cpu_set_asid(asid) \
-	asm("	mcr	p15, 0, %0, c13, c0, 1\n" : : "r" (asid))
+void cpu_set_reserved_ttbr0(void)
+{
+	u32 ttb;
+	/* Copy TTBR1 into TTBR0 */
+	asm volatile(
+	"	mrc	p15, 0, %0, c2, c0, 1		@ read TTBR1\n"
+	"	mcr	p15, 0, %0, c2, c0, 0		@ set TTBR0\n"
+	: "=r" (ttb));
+	isb();
+}
 #endif
 
 /*
  * We fork()ed a process, and we need a new context for the child
- * to run in.  We reserve version 0 for initial tasks so we will
- * always allocate an ASID. The ASID 0 is reserved for the TTBR
- * register changing sequence.
+ * to run in.
  */
 void __init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 {
@@ -51,9 +60,7 @@ void __init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 
 static void flush_context(void)
 {
-	/* set the reserved ASID before flushing the TLB */
-	cpu_set_asid(0);
-	isb();
+	cpu_set_reserved_ttbr0();
 	local_flush_tlb_all();
 	if (icache_is_vivt_asid_tagged()) {
 		__flush_icache_all();
@@ -98,14 +105,7 @@ static void reset_context(void *info)
 {
 	unsigned int asid;
 	unsigned int cpu = smp_processor_id();
-	struct mm_struct *mm = per_cpu(current_mm, cpu);
-
-	/*
-	 * Check if a current_mm was set on this CPU as it might still
-	 * be in the early booting stages and using the reserved ASID.
-	 */
-	if (!mm)
-		return;
+	struct mm_struct *mm = current->active_mm;
 
 	smp_rmb();
 	asid = cpu_last_asid + cpu + 1;
@@ -114,8 +114,7 @@ static void reset_context(void *info)
 	set_mm_context(mm, asid);
 
 	/* set the new ASID */
-	cpu_set_asid(mm->context.id);
-	isb();
+	cpu_switch_mm(mm->pgd, mm);
 }
 
 #else
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index db23ae4a..b44fb561 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -17,7 +17,9 @@
 #include <linux/init.h>
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
 #include <linux/highmem.h>
+#include <linux/memblock.h>
 #include <linux/slab.h>
 
 #include <asm/memory.h>
@@ -26,6 +28,9 @@
 #include <asm/tlbflush.h>
 #include <asm/sizes.h>
 #include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/system_info.h>
+#include <asm/dma-contiguous.h>
 
 #include "mm.h"
 
@@ -56,6 +61,19 @@ static u64 get_coherent_dma_mask(struct device *dev)
 	return mask;
 }
 
+static void __dma_clear_buffer(struct page *page, size_t size)
+{
+	void *ptr;
+	/*
+	 * Ensure that the allocated pages are zeroed, and that any data
+	 * lurking in the kernel direct-mapped region is invalidated.
+	 */
+	ptr = page_address(page);
+	memset(ptr, 0, size);
+	dmac_flush_range(ptr, ptr + size);
+	outer_flush_range(__pa(ptr), __pa(ptr) + size);
+}
+
 /*
  * Allocate a DMA buffer for 'dev' of size 'size' using the
  * specified gfp mask.  Note that 'size' must be page aligned.
@@ -64,23 +82,6 @@ static struct page *__dma_alloc_buffer(struct device *dev, size_t size, gfp_t gf
 {
 	unsigned long order = get_order(size);
 	struct page *page, *p, *e;
-	void *ptr;
-	u64 mask = get_coherent_dma_mask(dev);
-
-#ifdef CONFIG_DMA_API_DEBUG
-	u64 limit = (mask + 1) & ~mask;
-	if (limit && size >= limit) {
-		dev_warn(dev, "coherent allocation too big (requested %#x mask %#llx)\n",
-			size, mask);
-		return NULL;
-	}
-#endif
-
-	if (!mask)
-		return NULL;
-
-	if (mask < 0xffffffffULL)
-		gfp |= GFP_DMA;
 
 	page = alloc_pages(gfp, order);
 	if (!page)
@@ -93,14 +94,7 @@ static struct page *__dma_alloc_buffer(struct device *dev, size_t size, gfp_t gf
 	for (p = page + (size >> PAGE_SHIFT), e = page + (1 << order); p < e; p++)
 		__free_page(p);
 
-	/*
-	 * Ensure that the allocated pages are zeroed, and that any data
-	 * lurking in the kernel direct-mapped region is invalidated.
-	 */
-	ptr = page_address(page);
-	memset(ptr, 0, size);
-	dmac_flush_range(ptr, ptr + size);
-	outer_flush_range(__pa(ptr), __pa(ptr) + size);
+	__dma_clear_buffer(page, size);
 
 	return page;
 }
@@ -170,6 +164,9 @@ static int __init consistent_init(void)
 	unsigned long base = consistent_base;
 	unsigned long num_ptes = (CONSISTENT_END - base) >> PMD_SHIFT;
 
+	if (cma_available)
+		return 0;
+
 	consistent_pte = kmalloc(num_ptes * sizeof(pte_t), GFP_KERNEL);
 	if (!consistent_pte) {
 		pr_err("%s: no memory\n", __func__);
@@ -210,9 +207,107 @@ static int __init consistent_init(void)
 
 	return ret;
 }
-
 core_initcall(consistent_init);
 
+static void *__alloc_from_contiguous(struct device *dev, size_t size,
+				     pgprot_t prot, struct page **ret_page);
+
+static struct arm_vmregion_head coherent_head = {
+	.vm_lock	= __SPIN_LOCK_UNLOCKED(&coherent_head.vm_lock),
+	.vm_list	= LIST_HEAD_INIT(coherent_head.vm_list),
+};
+
+size_t coherent_pool_size = DEFAULT_CONSISTENT_DMA_SIZE / 8;
+
+static int __init early_coherent_pool(char *p)
+{
+	coherent_pool_size = memparse(p, &p);
+	return 0;
+}
+early_param("coherent_pool", early_coherent_pool);
+
+static void *__alloc_remap_buffer(struct device *dev, size_t size, gfp_t gfp,
+				 pgprot_t prot, struct page **ret_page,
+				 const void *caller);
+/*
+ * Initialise the coherent pool for atomic allocations.
+ */
+static int __init coherent_init(void)
+{
+	pgprot_t prot = pgprot_dmacoherent(pgprot_kernel);
+	size_t size = coherent_pool_size;
+	struct page *page;
+	void *ptr;
+
+	if (cma_available)
+		ptr = __alloc_from_contiguous(NULL, size, prot, &page);
+	else
+		ptr = __alloc_remap_buffer(NULL, size, GFP_KERNEL | GFP_DMA,
+			prot, &page, NULL);
+
+	if (ptr) {
+		coherent_head.vm_start = (unsigned long) ptr;
+		coherent_head.vm_end = (unsigned long) ptr + size;
+		coherent_head.vm_pages = page;
+		printk(KERN_INFO "DMA: preallocated %u KiB pool for atomic coherent allocations\n",
+		       (unsigned)size / 1024);
+		return 0;
+	}
+	printk(KERN_ERR "DMA: failed to allocate %u KiB pool for atomic coherent allocation\n",
+	       (unsigned)size / 1024);
+	return -ENOMEM;
+}
+/*
+ * CMA is activated by core_initcall, so we must be called after it.
+ */
+postcore_initcall(coherent_init);
+
+struct dma_contig_early_reserve {
+	phys_addr_t base;
+	unsigned long size;
+};
+
+static struct dma_contig_early_reserve dma_mmu_remap[MAX_CMA_AREAS] __initdata;
+
+static int dma_mmu_remap_num __initdata;
+
+void __init dma_contiguous_early_fixup(phys_addr_t base, unsigned long size)
+{
+	dma_mmu_remap[dma_mmu_remap_num].base = base;
+	dma_mmu_remap[dma_mmu_remap_num].size = size;
+	dma_mmu_remap_num++;
+}
+
+void __init dma_contiguous_remap(void)
+{
+	int i;
+	for (i = 0; i < dma_mmu_remap_num; i++) {
+		phys_addr_t start = dma_mmu_remap[i].base;
+		phys_addr_t end = start + dma_mmu_remap[i].size;
+		struct map_desc map;
+		unsigned long addr;
+
+		if (end > arm_lowmem_limit)
+			end = arm_lowmem_limit;
+		if (start >= end)
+			continue;
+
+		map.pfn = __phys_to_pfn(start);
+		map.virtual = __phys_to_virt(start);
+		map.length = end - start;
+		map.type = MT_MEMORY_DMA_READY;
+
+		/*
+		 * Clear previous low-memory mapping
+		 */
+		for (addr = __phys_to_virt(start); addr < __phys_to_virt(end);
+		     addr += PGDIR_SIZE)
+			pmd_clear(pmd_off_k(addr));
+
+		iotable_init(&map, 1);
+	}
+}
+
 static void *
 __dma_alloc_remap(struct page *page, size_t size, gfp_t gfp, pgprot_t prot,
 	const void *caller)
@@ -319,20 +414,172 @@ static void __dma_free_remap(void *cpu_addr, size_t size)
 	arm_vmregion_free(&consistent_head, c);
 }
 
+static int __dma_update_pte(pte_t *pte, pgtable_t token, unsigned long addr,
+			    void *data)
+{
+	struct page *page = virt_to_page(addr);
+	pgprot_t prot = *(pgprot_t *)data;
+
+	set_pte_ext(pte, mk_pte(page, prot), 0);
+	return 0;
+}
+
+static void __dma_remap(struct page *page, size_t size, pgprot_t prot)
+{
+	unsigned long start = (unsigned long) page_address(page);
+	unsigned end = start + size;
+
+	apply_to_page_range(&init_mm, start, size, __dma_update_pte, &prot);
+	dsb();
+	flush_tlb_kernel_range(start, end);
+}
+
+static void *__alloc_remap_buffer(struct device *dev, size_t size, gfp_t gfp,
+				 pgprot_t prot, struct page **ret_page,
+				 const void *caller)
+{
+	struct page *page;
+	void *ptr;
+	page = __dma_alloc_buffer(dev, size, gfp);
+	if (!page)
+		return NULL;
+
+	ptr = __dma_alloc_remap(page, size, gfp, prot, caller);
+	if (!ptr) {
+		__dma_free_buffer(page, size);
+		return NULL;
+	}
+
+	*ret_page = page;
+	return ptr;
+}
+
+static void *__alloc_from_pool(struct device *dev, size_t size,
+			       struct page **ret_page, const void *caller)
+{
+	struct arm_vmregion *c;
+	size_t align;
+
+	if (!coherent_head.vm_start) {
+		printk(KERN_ERR "%s: coherent pool not initialised!\n",
+		       __func__);
+		dump_stack();
+		return NULL;
+	}
+
+	/*
+	 * Align the region allocation - allocations from pool are rather
+	 * small, so align them to their order in pages, minimum is a page
+	 * size. This helps reduce fragmentation of the DMA space.
+	 */
+	align = PAGE_SIZE << get_order(size);
+	c = arm_vmregion_alloc(&coherent_head, align, size, 0, caller);
+	if (c) {
+		void *ptr = (void *)c->vm_start;
+		*ret_page = c->vm_pages;
+		return ptr;
+	}
+	return NULL;
+}
+
+static int __free_from_pool(void *cpu_addr, size_t size)
+{
+	unsigned long start = (unsigned long)cpu_addr;
+	unsigned long end = start + size;
+	struct arm_vmregion *c;
+
+	if (start < coherent_head.vm_start || end > coherent_head.vm_end)
+		return 0;
+
+	c = arm_vmregion_find_remove(&coherent_head, (unsigned long)start);
+
+	if ((c->vm_end - c->vm_start) != size) {
+		printk(KERN_ERR "%s: freeing wrong coherent size (%ld != %d)\n",
+		       __func__, c->vm_end - c->vm_start, size);
+		dump_stack();
+		size = c->vm_end - c->vm_start;
+	}
+
+	arm_vmregion_free(&coherent_head, c);
+	return 1;
+}
+
+static void *__alloc_from_contiguous(struct device *dev, size_t size,
+				     pgprot_t prot, struct page **ret_page)
+{
+	unsigned long order = get_order(size);
+	size_t count = size >> PAGE_SHIFT;
+	struct page *page;
+
+	page = dma_alloc_from_contiguous(dev, count, order);
+	if (!page)
+		return NULL;
+
+	__dma_clear_buffer(page, size);
+	__dma_remap(page, size, prot);
+
+	*ret_page = page;
+	return page_address(page);
+}
+
+static void __free_from_contiguous(struct device *dev, struct page *page,
+				   size_t size)
+{
+	__dma_remap(page, size, pgprot_kernel);
+	dma_release_from_contiguous(dev, page, size >> PAGE_SHIFT);
+}
+
+#define nommu() 0
+
 #else	/* !CONFIG_MMU */
 
-#define __dma_alloc_remap(page, size, gfp, prot, c)	page_address(page)
-#define __dma_free_remap(addr, size)			do { } while (0)
+#define nommu() 1
+
+#define __alloc_remap_buffer(dev, size, gfp, prot, ret, c)	NULL
+#define __alloc_from_pool(dev, size, ret_page, c)		NULL
+#define __alloc_from_contiguous(dev, size, prot, ret)		NULL
+#define __free_from_pool(cpu_addr, size)			0
+#define __free_from_contiguous(dev, page, size)			do { } while (0)
+#define __dma_free_remap(cpu_addr, size)			do { } while (0)
 
 #endif	/* CONFIG_MMU */
 
-static void *
-__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp,
-	    pgprot_t prot, const void *caller)
+static void *__alloc_simple_buffer(struct device *dev, size_t size, gfp_t gfp,
+				   struct page **ret_page)
 {
+	struct page *page;
+	page = __dma_alloc_buffer(dev, size, gfp);
+	if (!page)
+		return NULL;
+
+	*ret_page = page;
+	return page_address(page);
+}
+
+
+
+static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
+			 gfp_t gfp, pgprot_t prot, const void *caller)
+{
+	u64 mask = get_coherent_dma_mask(dev);
 	struct page *page;
 	void *addr;
 
+#ifdef CONFIG_DMA_API_DEBUG
+	u64 limit = (mask + 1) & ~mask;
+	if (limit && size >= limit) {
+		dev_warn(dev, "coherent allocation too big (requested %#x mask %#llx)\n",
+			size, mask);
+		return NULL;
+	}
+#endif
+
+	if (!mask)
+		return NULL;
+
+	if (mask < 0xffffffffULL)
+		gfp |= GFP_DMA;
+
 	/*
 	 * Following is a work-around (a.k.a. hack) to prevent pages
 	 * with __GFP_COMP being passed to split_page() which cannot
@@ -345,19 +592,18 @@ __dma_alloc(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp,
 	*handle = ~0;
 	size = PAGE_ALIGN(size);
 
-	page = __dma_alloc_buffer(dev, size, gfp);
-	if (!page)
-		return NULL;
-
-	if (!arch_is_coherent())
-		addr = __dma_alloc_remap(page, size, gfp, prot, caller);
+	if (arch_is_coherent() || nommu())
+		addr = __alloc_simple_buffer(dev, size, gfp, &page);
+	else if (!(gfp & __GFP_WAIT))
+		addr = __alloc_from_pool(dev, size, &page, caller);
+	else if (!cma_available)
+		addr = __alloc_remap_buffer(dev, size, gfp, prot, &page,
+			caller);
 	else
-		addr = page_address(page);
+		addr = __alloc_from_contiguous(dev, size, prot, &page);
 
 	if (addr)
 		*handle = pfn_to_dma(dev, page_to_pfn(page));
-	else
-		__dma_free_buffer(page, size);
 
 	return addr;
 }
@@ -366,8 +612,8 @@ __dma_alloc(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp,
  * Allocate DMA-coherent memory space and return both the kernel remapped
  * virtual and bus address for that space.
  */
-void *
-dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)
+void *dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle,
+			 gfp_t gfp)
 {
 	void *memory;
 
@@ -398,25 +644,11 @@ static int dma_mmap(struct device *dev, struct vm_area_struct *vma,
 {
 	int ret = -ENXIO;
 #ifdef CONFIG_MMU
-	unsigned long user_size, kern_size;
-	struct arm_vmregion *c;
-
-	user_size = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
-
-	c = arm_vmregion_find(&consistent_head, (unsigned long)cpu_addr);
-	if (c) {
-		unsigned long off = vma->vm_pgoff;
-
-		kern_size = (c->vm_end - c->vm_start) >> PAGE_SHIFT;
-
-		if (off < kern_size &&
-		    user_size <= (kern_size - off)) {
-			ret = remap_pfn_range(vma, vma->vm_start,
-					      page_to_pfn(c->vm_pages) + off,
-					      user_size << PAGE_SHIFT,
-					      vma->vm_page_prot);
-		}
-	}
+	unsigned long pfn = dma_to_pfn(dev, dma_addr);
+	ret = remap_pfn_range(vma, vma->vm_start,
+			      pfn + vma->vm_pgoff,
+			      vma->vm_end - vma->vm_start,
+			      vma->vm_page_prot);
 #endif	/* CONFIG_MMU */
 
 	return ret;
@@ -438,23 +670,33 @@ int dma_mmap_writecombine(struct device *dev, struct vm_area_struct *vma,
 }
 EXPORT_SYMBOL(dma_mmap_writecombine);
 
+
 /*
- * free a page as defined by the above mapping.
- * Must not be called with IRQs disabled.
+ * Free a buffer as defined by the above mapping.
  */
 void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t handle)
 {
-	WARN_ON(irqs_disabled());
+	struct page *page = pfn_to_page(dma_to_pfn(dev, handle));
 
 	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
 		return;
 
 	size = PAGE_ALIGN(size);
 
-	if (!arch_is_coherent())
+	if (arch_is_coherent() || nommu()) {
+		__dma_free_buffer(page, size);
+	} else if (__free_from_pool(cpu_addr, size)) {
+			return;
+	} else if (!cma_available) {
 		__dma_free_remap(cpu_addr, size);
-
-	__dma_free_buffer(pfn_to_page(dma_to_pfn(dev, handle)), size);
+		__dma_free_buffer(page, size);
+	} else {
+		/*
+		 * Non-atomic allocations cannot be freed with IRQs disabled
+		 */
+		WARN_ON(irqs_disabled());
+		__free_from_contiguous(dev, page, size);
+	}
 }
 EXPORT_SYMBOL(dma_free_coherent);
 
diff --git a/arch/arm/mm/init.c b/arch/arm/mm/init.c
index 8f5813bb..32280836 100644
--- a/arch/arm/mm/init.c
+++ b/arch/arm/mm/init.c
@@ -20,6 +20,7 @@
 #include <linux/highmem.h>
 #include <linux/gfp.h>
 #include <linux/memblock.h>
+#include <linux/dma-contiguous.h>
 
 #include <asm/mach-types.h>
 #include <asm/memblock.h>
@@ -226,6 +227,17 @@ static void __init arm_adjust_dma_zone(unsigned long *size, unsigned long *hole,
 }
 #endif
 
+void __init setup_dma_zone(struct machine_desc *mdesc)
+{
+#ifdef CONFIG_ZONE_DMA
+	if (mdesc->dma_zone_size) {
+		arm_dma_zone_size = mdesc->dma_zone_size;
+		arm_dma_limit = PHYS_OFFSET + arm_dma_zone_size - 1;
+	} else
+		arm_dma_limit = 0xffffffff;
+#endif
+}
+
 static void __init arm_bootmem_free(unsigned long min, unsigned long max_low,
 	unsigned long max_high)
 {
@@ -273,12 +285,9 @@ static void __init arm_bootmem_free(unsigned long min, unsigned long max_low,
 	 * Adjust the sizes according to any special requirements for
 	 * this machine type.
 	 */
-	if (arm_dma_zone_size) {
+	if (arm_dma_zone_size)
 		arm_adjust_dma_zone(zone_size, zhole_size,
 			arm_dma_zone_size >> PAGE_SHIFT);
-		arm_dma_limit = PHYS_OFFSET + arm_dma_zone_size - 1;
-	} else
-		arm_dma_limit = 0xffffffff;
 #endif
 
 	free_area_init_node(0, zone_size, min, zhole_size);
@@ -287,6 +296,11 @@ static void __init arm_bootmem_free(unsigned long min, unsigned long max_low,
 #ifdef CONFIG_HAVE_ARCH_PFN_VALID
 int pfn_valid(unsigned long pfn)
 {
+#ifdef CONFIG_SPARSEMEM
+	if (pfn_to_section_nr(pfn) >= NR_MEM_SECTIONS
+		|| !valid_section(__nr_to_section(pfn_to_section_nr(pfn))))
+		return 0;
+#endif
 	return memblock_is_memory(__pfn_to_phys(pfn));
 }
 EXPORT_SYMBOL(pfn_valid);
@@ -364,6 +378,12 @@ void __init arm_memblock_init(struct meminfo *mi, struct machine_desc *mdesc)
 	if (mdesc->reserve)
 		mdesc->reserve();
 
+	/*
+	 * reserve memory for DMA contigouos allocations,
+	 * must come from DMA area inside low memory
+	 */
+	dma_contiguous_reserve(min(arm_dma_limit, arm_lowmem_limit));
+
 	arm_memblock_steal_permitted = false;
 	memblock_allow_resize();
 	memblock_dump_all();
@@ -605,21 +625,19 @@ void __init mem_init(void)
 	for_each_bank(i, &meminfo) {
 		struct membank *bank = &meminfo.bank[i];
 		unsigned int pfn1, pfn2;
-		struct page *page, *end;
+		struct page *page;
 
 		pfn1 = bank_pfn_start(bank);
 		pfn2 = bank_pfn_end(bank);
 
-		page = pfn_to_page(pfn1);
-		end  = pfn_to_page(pfn2 - 1) + 1;
-
 		do {
+			page = pfn_to_page(pfn1);
 			if (PageReserved(page))
 				reserved_pages++;
 			else if (!page_count(page))
 				free_pages++;
-			page++;
-		} while (page < end);
+			pfn1++;
+		} while (pfn1 < pfn2);
 	}
 
 	/*
@@ -757,3 +775,24 @@ static int __init keepinitrd_setup(char *__unused)
 
 __setup("keepinitrd", keepinitrd_setup);
 #endif
+
+#ifdef CONFIG_MEMORY_HOTPLUG
+int arch_add_memory(int nid, u64 start, u64 size)
+{
+	/*
+	 * This function is used to support memory hotplug on arm architecture.
+	 */
+	struct pglist_data *pgdata = NODE_DATA(nid);
+#ifdef CONFIG_MEMORY_FORCE_MOVABLE_HIGHMEM
+	struct zone *zone = pgdata->node_zones + ZONE_MOVABLE;
+#else
+	struct zone *zone = pgdata->node_zones + ZONE_HIGHMEM;
+#endif
+	unsigned long start_pfn = start >> PAGE_SHIFT;
+	unsigned long nr_pages = size >> PAGE_SHIFT;
+
+	memblock_add(start, 1 << SECTION_SIZE_BITS);
+
+	return __add_pages(0, zone, start_pfn, nr_pages);
+}
+#endif /* CONFIG_MEMORY_HOTPLUG */
diff --git a/arch/arm/mm/mm.h b/arch/arm/mm/mm.h
index 27f4a619..93dc0c17 100644
--- a/arch/arm/mm/mm.h
+++ b/arch/arm/mm/mm.h
@@ -67,5 +67,8 @@ extern u32 arm_dma_limit;
 #define arm_dma_limit ((u32)~0)
 #endif
 
+extern phys_addr_t arm_lowmem_limit;
+
 void __init bootmem_init(void);
 void arm_mm_memblock_reserve(void);
+void dma_contiguous_remap(void);
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index 75f9f9d6..ced5520e 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -288,6 +288,11 @@ static struct mem_type mem_types[] = {
 				PMD_SECT_UNCACHED | PMD_SECT_XN,
 		.domain    = DOMAIN_KERNEL,
 	},
+	[MT_MEMORY_DMA_READY] = {
+		.prot_pte  = L_PTE_PRESENT | L_PTE_YOUNG | L_PTE_DIRTY,
+		.prot_l1   = PMD_TYPE_TABLE,
+		.domain    = DOMAIN_KERNEL,
+	},
 };
 
 const struct mem_type *get_mem_type(unsigned int type)
@@ -429,6 +434,7 @@ static void __init build_mem_type_table(void)
 	if (arch_is_coherent() && cpu_is_xsc3()) {
 		mem_types[MT_MEMORY].prot_sect |= PMD_SECT_S;
 		mem_types[MT_MEMORY].prot_pte |= L_PTE_SHARED;
+		mem_types[MT_MEMORY_DMA_READY].prot_pte |= L_PTE_SHARED;
 		mem_types[MT_MEMORY_NONCACHED].prot_sect |= PMD_SECT_S;
 		mem_types[MT_MEMORY_NONCACHED].prot_pte |= L_PTE_SHARED;
 	}
@@ -460,6 +466,7 @@ static void __init build_mem_type_table(void)
 			mem_types[MT_DEVICE_CACHED].prot_pte |= L_PTE_SHARED;
 			mem_types[MT_MEMORY].prot_sect |= PMD_SECT_S;
 			mem_types[MT_MEMORY].prot_pte |= L_PTE_SHARED;
+			mem_types[MT_MEMORY_DMA_READY].prot_pte |= L_PTE_SHARED;
 			mem_types[MT_MEMORY_NONCACHED].prot_sect |= PMD_SECT_S;
 			mem_types[MT_MEMORY_NONCACHED].prot_pte |= L_PTE_SHARED;
 		}
@@ -512,6 +519,7 @@ static void __init build_mem_type_table(void)
 	mem_types[MT_HIGH_VECTORS].prot_l1 |= ecc_mask;
 	mem_types[MT_MEMORY].prot_sect |= ecc_mask | cp->pmd;
 	mem_types[MT_MEMORY].prot_pte |= kern_pgprot;
+	mem_types[MT_MEMORY_DMA_READY].prot_pte |= kern_pgprot;
 	mem_types[MT_MEMORY_NONCACHED].prot_sect |= ecc_mask;
 	mem_types[MT_ROM].prot_sect |= cp->pmd;
 
@@ -563,11 +571,25 @@ static void __init *early_alloc(unsigned long sz)
 	return early_alloc_aligned(sz, sz);
 }
 
-static pte_t * __init early_pte_alloc(pmd_t *pmd, unsigned long addr, unsigned long prot)
+static pte_t * __init early_pte_alloc(pmd_t *pmd)
+{
+	if (pmd_none(*pmd) || pmd_bad(*pmd))
+		return early_alloc(PTE_HWTABLE_OFF + PTE_HWTABLE_SIZE);
+	return pmd_page_vaddr(*pmd);
+}
+
+static void __init early_pte_install(pmd_t *pmd, pte_t *pte, unsigned long prot)
+{
+	__pmd_populate(pmd, __pa(pte), prot);
+	BUG_ON(pmd_bad(*pmd));
+}
+
+static pte_t * __init early_pte_alloc_and_install(pmd_t *pmd,
+	unsigned long addr, unsigned long prot)
 {
 	if (pmd_none(*pmd)) {
-		pte_t *pte = early_alloc(PTE_HWTABLE_OFF + PTE_HWTABLE_SIZE);
-		__pmd_populate(pmd, __pa(pte), prot);
+		pte_t *pte = early_pte_alloc(pmd);
+		early_pte_install(pmd, pte, prot);
 	}
 	BUG_ON(pmd_bad(*pmd));
 	return pte_offset_kernel(pmd, addr);
@@ -577,16 +599,23 @@ static void __init alloc_init_pte(pmd_t *pmd, unsigned long addr,
 				  unsigned long end, unsigned long pfn,
 				  const struct mem_type *type)
 {
-	pte_t *pte = early_pte_alloc(pmd, addr, type->prot_l1);
+	pte_t *start_pte = early_pte_alloc(pmd);
+	pte_t *pte = start_pte + pte_index(addr);
+
+	/* If replacing a section mapping, the whole section must be replaced */
+	BUG_ON(pmd_bad(*pmd) && ((addr | end) & ~PMD_MASK));
+
 	do {
 		set_pte_ext(pte, pfn_pte(pfn, __pgprot(type->prot_pte)), 0);
 		pfn++;
 	} while (pte++, addr += PAGE_SIZE, addr != end);
+	early_pte_install(pmd, start_pte, type->prot_l1);
 }
 
 static void __init alloc_init_section(pud_t *pud, unsigned long addr,
 				      unsigned long end, phys_addr_t phys,
-				      const struct mem_type *type)
+				      const struct mem_type *type,
+				      bool force_pages)
 {
 	pmd_t *pmd = pmd_offset(pud, addr);
 
@@ -596,7 +625,8 @@ static void __init alloc_init_section(pud_t *pud, unsigned long addr,
 	 * L1 entries, whereas PGDs refer to a group of L1 entries making
 	 * up one logical pointer to an L2 table.
 	 */
-	if (((addr | end | phys) & ~SECTION_MASK) == 0) {
+	if (type->prot_sect && ((addr | end | phys) & ~SECTION_MASK) == 0
+		&& !force_pages) {
 		pmd_t *p = pmd;
 
 #ifndef CONFIG_ARM_LPAE
@@ -620,14 +650,15 @@ static void __init alloc_init_section(pud_t *pud, unsigned long addr,
 }
 
 static void __init alloc_init_pud(pgd_t *pgd, unsigned long addr,
-	unsigned long end, unsigned long phys, const struct mem_type *type)
+	unsigned long end, unsigned long phys, const struct mem_type *type,
+	bool force_pages)
 {
 	pud_t *pud = pud_offset(pgd, addr);
 	unsigned long next;
 
 	do {
 		next = pud_addr_end(addr, end);
-		alloc_init_section(pud, addr, next, phys, type);
+		alloc_init_section(pud, addr, next, phys, type, force_pages);
 		phys += next - addr;
 	} while (pud++, addr = next, addr != end);
 }
@@ -701,7 +732,7 @@ static void __init create_36bit_mapping(struct map_desc *md,
  * offsets, and we take full advantage of sections and
  * supersections.
  */
-static void __init create_mapping(struct map_desc *md)
+static void __init create_mapping(struct map_desc *md, bool force_pages)
 {
 	unsigned long addr, length, end;
 	phys_addr_t phys;
@@ -751,7 +782,7 @@ static void __init create_mapping(struct map_desc *md)
 	do {
 		unsigned long next = pgd_addr_end(addr, end);
 
-		alloc_init_pud(pgd, addr, next, phys, type);
+		alloc_init_pud(pgd, addr, next, phys, type, force_pages);
 
 		phys += next - addr;
 		addr = next;
@@ -772,7 +803,7 @@ void __init iotable_init(struct map_desc *io_desc, int nr)
 	vm = early_alloc_aligned(sizeof(*vm) * nr, __alignof__(*vm));
 
 	for (md = io_desc; nr; md++, nr--) {
-		create_mapping(md);
+		create_mapping(md, false);
 		vm->addr = (void *)(md->virtual & PAGE_MASK);
 		vm->size = PAGE_ALIGN(md->length + (md->virtual & ~PAGE_MASK));
 		vm->phys_addr = __pfn_to_phys(md->pfn); 
@@ -887,7 +918,7 @@ static int __init early_vmalloc(char *arg)
 }
 early_param("vmalloc", early_vmalloc);
 
-static phys_addr_t lowmem_limit __initdata = 0;
+phys_addr_t arm_lowmem_limit __initdata = 0;
 
 void __init sanity_check_meminfo(void)
 {
@@ -970,8 +1001,8 @@ void __init sanity_check_meminfo(void)
 			bank->size = newsize;
 		}
 #endif
-		if (!bank->highmem && bank->start + bank->size > lowmem_limit)
-			lowmem_limit = bank->start + bank->size;
+		if (!bank->highmem && bank->start + bank->size > arm_lowmem_limit)
+			arm_lowmem_limit = bank->start + bank->size;
 
 		j++;
 	}
@@ -996,8 +1027,8 @@ void __init sanity_check_meminfo(void)
 	}
 #endif
 	meminfo.nr_banks = j;
-	high_memory = __va(lowmem_limit - 1) + 1;
-	memblock_set_current_limit(lowmem_limit);
+	high_memory = __va(arm_lowmem_limit - 1) + 1;
+	memblock_set_current_limit(arm_lowmem_limit);
 }
 
 static inline void prepare_page_table(void)
@@ -1022,8 +1053,8 @@ static inline void prepare_page_table(void)
 	 * Find the end of the first block of lowmem.
 	 */
 	end = memblock.memory.regions[0].base + memblock.memory.regions[0].size;
-	if (end >= lowmem_limit)
-		end = lowmem_limit;
+	if (end >= arm_lowmem_limit)
+		end = arm_lowmem_limit;
 
 	/*
 	 * Clear out all the kernel space mappings, except for the first
@@ -1124,12 +1155,12 @@ static void __init devicemaps_init(struct machine_desc *mdesc)
 	map.virtual = 0xffff0000;
 	map.length = PAGE_SIZE;
 	map.type = MT_HIGH_VECTORS;
-	create_mapping(&map);
+	create_mapping(&map, false);
 
 	if (!vectors_high()) {
 		map.virtual = 0;
 		map.type = MT_LOW_VECTORS;
-		create_mapping(&map);
+		create_mapping(&map, false);
 	}
 
 	/*
@@ -1152,23 +1183,26 @@ static void __init devicemaps_init(struct machine_desc *mdesc)
 static void __init kmap_init(void)
 {
 #ifdef CONFIG_HIGHMEM
-	pkmap_page_table = early_pte_alloc(pmd_off_k(PKMAP_BASE),
+	pkmap_page_table = early_pte_alloc_and_install(pmd_off_k(PKMAP_BASE),
 		PKMAP_BASE, _PAGE_KERNEL_TABLE);
 #endif
 }
 
+
 static void __init map_lowmem(void)
 {
 	struct memblock_region *reg;
+	phys_addr_t start;
+	phys_addr_t end;
+	struct map_desc map;
 
 	/* Map all the lowmem memory banks. */
 	for_each_memblock(memory, reg) {
-		phys_addr_t start = reg->base;
-		phys_addr_t end = start + reg->size;
-		struct map_desc map;
+		start = reg->base;
+		end = start + reg->size;
 
-		if (end > lowmem_limit)
-			end = lowmem_limit;
+		if (end > arm_lowmem_limit)
+			end = arm_lowmem_limit;
 		if (start >= end)
 			break;
 
@@ -1177,8 +1211,20 @@ static void __init map_lowmem(void)
 		map.length = end - start;
 		map.type = MT_MEMORY;
 
-		create_mapping(&map);
+		create_mapping(&map, false);
 	}
+
+#ifdef CONFIG_DEBUG_RODATA
+	start = __pa(_stext) & PMD_MASK;
+	end = ALIGN(__pa(__end_rodata), PMD_SIZE);
+
+	map.pfn = __phys_to_pfn(start);
+	map.virtual = __phys_to_virt(start);
+	map.length = end - start;
+	map.type = MT_MEMORY;
+
+	create_mapping(&map, true);
+#endif
 }
 
 /*
@@ -1189,11 +1235,12 @@ void __init paging_init(struct machine_desc *mdesc)
 {
 	void *zero_page;
 
-	memblock_set_current_limit(lowmem_limit);
+	memblock_set_current_limit(arm_lowmem_limit);
 
 	build_mem_type_table();
 	prepare_page_table();
 	map_lowmem();
+	dma_contiguous_remap();
 	devicemaps_init(mdesc);
 	kmap_init();
 
diff --git a/arch/arm/mm/proc-macros.S b/arch/arm/mm/proc-macros.S
index 2d8ff3ad..b29a2265 100644
--- a/arch/arm/mm/proc-macros.S
+++ b/arch/arm/mm/proc-macros.S
@@ -299,6 +299,7 @@ ENTRY(\name\()_processor_functions)
 ENTRY(\name\()_cache_fns)
 	.long	\name\()_flush_icache_all
 	.long	\name\()_flush_kern_cache_all
+	.long   \name\()_flush_kern_cache_louis
 	.long	\name\()_flush_user_cache_all
 	.long	\name\()_flush_user_cache_range
 	.long	\name\()_coherent_kern_range
diff --git a/arch/arm/mm/proc-v7-2level.S b/arch/arm/mm/proc-v7-2level.S
index 3a4b3e7b..42ac069c 100644
--- a/arch/arm/mm/proc-v7-2level.S
+++ b/arch/arm/mm/proc-v7-2level.S
@@ -46,18 +46,13 @@ ENTRY(cpu_v7_switch_mm)
 #ifdef CONFIG_ARM_ERRATA_430973
 	mcr	p15, 0, r2, c7, c5, 6		@ flush BTAC/BTB
 #endif
-#ifdef CONFIG_ARM_ERRATA_754322
-	dsb
-#endif
-	mcr	p15, 0, r2, c13, c0, 1		@ set reserved context ID
-	isb
-1:	mcr	p15, 0, r0, c2, c0, 0		@ set TTB 0
-	isb
 #ifdef CONFIG_ARM_ERRATA_754322
 	dsb
 #endif
 	mcr	p15, 0, r1, c13, c0, 1		@ set context ID
 	isb
+	mcr	p15, 0, r0, c2, c0, 0		@ set TTB 0
+	isb
 #endif
 	mov	pc, lr
 ENDPROC(cpu_v7_switch_mm)
diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S
index c2e2b66f..eb007f3c 100644
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -69,7 +69,9 @@ ENDPROC(cpu_v7_reset)
  *	IRQs are already disabled.
  */
 ENTRY(cpu_v7_do_idle)
+#ifndef CONFIG_CPU_PJ4B
 	dsb					@ WFI may enter a low-power mode
+#endif
 	wfi
 	mov	pc, lr
 ENDPROC(cpu_v7_do_idle)
@@ -170,6 +172,58 @@ __v7_ca15mp_setup:
 	mcreq	p15, 0, r0, c1, c0, 1
 #endif
 __v7_setup:
+#if defined(CONFIG_CPU_PJ4B) && defined(CONFIG_NEON)
+	mrc	p15, 1, r0, c15, c1, 1
+	orr	r0, r0, #(1 << 11)		@ PJ4B NEON enable bit
+	mcr	p15, 1, r0, c15, c1, 1
+#endif
+#if defined(CONFIG_CPU_MMP3) && defined(CONFIG_NEON)
+	mrc	p15, 0, r5, c1, c0, 2		@ Read coprocessor access
+	mov	r0, r5
+	orr	r0, r0, #0x00f00000		@ Allow access to cp10 and cp11
+	mcr	p15, 0, r0, c1, c0, 2		@ Enable CP10, CP11 coprocessor access
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 4		@ Flush prefetch buffer
+	mrc	p10, 7, r0, c8, c0, 0
+	orr	r0, r0, #0x40000000
+	mcr	p10, 7, r0, c8, c0, 0		@ Enable FPEXC.EN bit
+	isb
+	mov	r0, #1
+	mcr	p10, 7, r0, c9, c0, 0		@ Enable dual-issue feature in FPCFG.bit0
+	/* Continuous 6 VMOV instructions to initialize the unused second pipe */
+	.word	0xeeb00b00			@ VMOV.F64 d0, #2.00000000
+	.word	0xeeb00b00
+	.word	0xeeb00b00
+	.word	0xeeb00b00
+	.word	0xeeb00b00
+	.word	0xeeb00b00
+	mov	r0, #0
+	mcr	p10, 7, r0, c9, c0, 0		@ Disable dual-issue feature in FPCFG.bit0
+	isb
+	mrc	p10, 7, r0, c8, c0, 0
+	bic	r0, r0, #0x40000000
+	mcr	p10, 7, r0, c8, c0, 0		@ Disable FPEXC.EN bit
+	mcr	p15, 0, r5, c1, c0, 2		@ Disable CP10, CP11 coprocessor access
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 4		@ Flush prefetch buffer
+#endif
+
+#ifdef CONFIG_PJ4_RETURNSTACK_ISSUE
+	mrc	p15, 1, r0, c15, c1, 1
+	bic	r0, r0, #0x1			@disable return stack
+	mcr	p15, 1, r0, c15, c1, 1
+#endif
+
+#ifdef CONFIG_PJ4B_ERRATA_6409
+	mrc	p15, 1, r0, c15, c1, 1
+	bic	r0, r0, #0x4			@ Disable Static BP
+	mcr	p15, 1, r0, c15, c1, 1
+#endif
+#ifdef CONFIG_DISABLE_CWF
+	mrc	p15, 1, r0, c15, c1, 2
+	orr	r0, r0, #(1 << 27)
+	mcr	p15, 1, r0, c15, c1, 2
+#endif
 	adr	r12, __v7_setup_stack		@ the local stack
 	stmia	r12, {r0-r5, r7, r9, r11, lr}
 	bl	v7_flush_dcache_all
@@ -342,6 +396,17 @@ __v7_ca9mp_proc_info:
 	.long	0xff0ffff0
 	__v7_proc __v7_ca9mp_setup
 	.size	__v7_ca9mp_proc_info, . - __v7_ca9mp_proc_info
+
+	/*
+	 * Marvell. PJ4B processor.
+	 */
+	.type  __v7_pj4b_proc_info, #object
+__v7_pj4b_proc_info:
+	.long  0x562f5840
+	.long  0xfffffff0
+	/* It can used same set up function as ca9mp */
+	__v7_proc __v7_ca9mp_setup
+	.size	__v7_pj4b_proc_info, . - __v7_pj4b_proc_info
 #endif	/* CONFIG_ARM_LPAE */
 
 	/*
diff --git a/arch/arm/mm/vmregion.c b/arch/arm/mm/vmregion.c
index a631016e..e6345987 100644
--- a/arch/arm/mm/vmregion.c
+++ b/arch/arm/mm/vmregion.c
@@ -4,6 +4,7 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/slab.h>
+#include <linux/mm_types.h>
 
 #include "vmregion.h"
 
@@ -76,6 +77,7 @@ arm_vmregion_alloc(struct arm_vmregion_head *head, size_t align,
 	new->vm_start = addr;
 	new->vm_end = addr + size;
 	new->vm_active = 1;
+	new->vm_pages = head->vm_pages + ((new->vm_start - head->vm_start) >> PAGE_SHIFT);
 
 	spin_unlock_irqrestore(&head->vm_lock, flags);
 	return new;
diff --git a/arch/arm/mm/vmregion.h b/arch/arm/mm/vmregion.h
index 162be662..22a090db 100644
--- a/arch/arm/mm/vmregion.h
+++ b/arch/arm/mm/vmregion.h
@@ -11,6 +11,7 @@ struct arm_vmregion_head {
 	struct list_head	vm_list;
 	unsigned long		vm_start;
 	unsigned long		vm_end;
+	struct page		*vm_pages;
 };
 
 struct arm_vmregion {
diff --git a/arch/arm/plat-pxa/Makefile b/arch/arm/plat-pxa/Makefile
index f302d048..5b014f1f 100644
--- a/arch/arm/plat-pxa/Makefile
+++ b/arch/arm/plat-pxa/Makefile
@@ -2,11 +2,18 @@
 # Makefile for code common across different PXA processor families
 #
 
-obj-y	:= dma.o
+obj-y	:= dma.o usb.o
 
 obj-$(CONFIG_PXA3xx)		+= mfp.o
 obj-$(CONFIG_PXA95x)		+= mfp.o
 obj-$(CONFIG_ARCH_MMP)		+= mfp.o
+obj-$(CONFIG_CPU_PXA988)	+= clock.o dvfs.o
+obj-$(CONFIG_CPU_PXA1088)	+= clock.o dvfs.o
+obj-$(CONFIG_CPU_MMP3)		+= clock.o dvfs.o
+obj-$(CONFIG_CPU_EDEN)		+= clock.o dvfs.o
 
 obj-$(CONFIG_HAVE_PWM)		+= pwm.o
+obj-$(CONFIG_PXA_PANIC_FLUSH)	+= panic.o
 obj-$(CONFIG_PXA_SSP)		+= ssp.o
+obj-$(CONFIG_DEBUG_FS)		+= debugfs.o
+obj-$(CONFIG_DUMP_REGS)		+= dump_regs.o
diff --git a/arch/arm/plat-pxa/clock.c b/arch/arm/plat-pxa/clock.c
new file mode 100644
index 00000000..bbb28b29
--- /dev/null
+++ b/arch/arm/plat-pxa/clock.c
@@ -0,0 +1,631 @@
+/*
+ *  linux/arch/arm/plat-pxa/clock.c
+ *
+ *  based on arch/arm/mach-tegra/clock.c
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+
+#include <plat/clock.h>
+#include <plat/dvfs.h>
+
+static DEFINE_MUTEX(clock_list_lock);
+static LIST_HEAD(clocks);
+
+int enable_voltage_based_dvfm;
+EXPORT_SYMBOL(enable_voltage_based_dvfm);
+
+static int disable_freqchg;
+
+static int __init disable_freqchg_setup(char *str)
+{
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	disable_freqchg = n;
+	return 1;
+}
+__setup("disable_freqchg=", disable_freqchg_setup);
+
+static inline bool clk_cansleep(struct clk *c)
+{
+	return c->cansleep;
+}
+
+#define clk_lock_save(c, flags)						\
+	do {								\
+		if (clk_cansleep(c)) {					\
+			flags = 0;					\
+			mutex_lock(&c->mutex);				\
+		} else {						\
+			spin_lock_irqsave(&c->spinlock, flags);		\
+		}							\
+	} while (0)
+
+#define clk_unlock_restore(c, flags)					\
+	do {								\
+		if (clk_cansleep(c))					\
+			mutex_unlock(&c->mutex);			\
+		else							\
+			spin_unlock_irqrestore(&c->spinlock, flags);	\
+	} while (0)
+
+#ifdef CONFIG_LOCKDEP
+
+#define clock_set_lockdep_class(c, lock)				\
+	do {								\
+		lockdep_set_class(lock, &c->lockdep_key);		\
+	} while (0)
+
+#else
+
+#define clock_set_lockdep_class(c, lock)	do {} while (0)
+
+#endif
+
+static inline void clk_lock_init(struct clk *c)
+{
+	mutex_init(&c->mutex);
+	clock_set_lockdep_class(c, &c->mutex);
+	spin_lock_init(&c->spinlock);
+	clock_set_lockdep_class(c, &c->spinlock);
+}
+
+static void __clk_set_cansleep(struct clk *c)
+{
+	struct clk *child;
+	BUG_ON(mutex_is_locked(&c->mutex));
+	BUG_ON(spin_is_locked(&c->spinlock));
+
+	list_for_each_entry(child, &clocks, node) {
+		if (child->parent != c)
+			continue;
+
+		WARN(child->ops && child->ops->set_parent,
+			"can't make child clock %s of %s "
+			"sleepable if it's parent could change",
+			child->name, c->name);
+
+		__clk_set_cansleep(child);
+	}
+
+	c->cansleep = true;
+}
+
+/* Must be called before any clk_get calls */
+void clk_set_cansleep(struct clk *c)
+{
+
+	mutex_lock(&clock_list_lock);
+	__clk_set_cansleep(c);
+	mutex_unlock(&clock_list_lock);
+}
+
+int clk_reparent(struct clk *c, struct clk *parent)
+{
+	c->parent = parent;
+	return 0;
+}
+
+void clk_init(struct clk *c)
+{
+	clk_lock_init(c);
+
+	if (c->ops && c->ops->init)
+		c->ops->init(c);
+
+	if (!c->ops || !c->ops->enable)
+		c->refcnt++;
+
+	mutex_lock(&clock_list_lock);
+	list_add(&c->node, &clocks);
+	mutex_unlock(&clock_list_lock);
+}
+
+/* Must be called with clk_lock(c) held */
+static unsigned long clk_predict_rate_from_parent(struct clk *c, struct clk *p)
+{
+	u64 rate;
+
+	rate = clk_get_rate(p);
+
+	if (c->mul != 0 && c->div != 0) {
+		rate *= c->mul;
+		do_div(rate, c->div);
+	}
+
+	return rate;
+}
+
+/* Must be called with clk_lock(c) held */
+unsigned long clk_get_rate_locked(struct clk *c)
+{
+	unsigned long rate;
+
+	if (c->ops && c->ops->getrate)
+		rate = c->ops->getrate(c);
+	else if (c->parent)
+		rate = clk_predict_rate_from_parent(c, c->parent);
+	else
+		rate = c->rate;
+
+	return rate;
+}
+
+int clk_enable(struct clk *c)
+{
+	int ret = 0;
+	unsigned long flags;
+	int i = 0;
+	u32 dependence_count = c->dependence_count;
+
+	clk_lock_save(c, flags);
+
+	if (clk_is_dvfs(c)) {
+		ret = dvfs_set_rate(c, clk_get_rate_locked(c));
+		if (ret)
+			goto out;
+	}
+
+	if (c->refcnt == 0) {
+		while (dependence_count != 0) {
+			dependence_count--;
+			ret = clk_enable(c->dependence[i]);
+			if (ret) {
+				while (i > 0)
+					clk_disable(c->dependence[--i]);
+				goto out;
+			}
+			i++;
+		}
+
+		if (c->parent) {
+			ret = clk_enable(c->parent);
+			if (ret)
+				goto disable_depend;
+		}
+
+		if (c->ops && c->ops->enable) {
+			ret = c->ops->enable(c);
+			if (ret) {
+				if (c->parent)
+					clk_disable(c->parent);
+				goto disable_depend;
+			}
+		}
+	}
+	c->refcnt++;
+
+	clk_unlock_restore(c, flags);
+	return 0;
+
+disable_depend:
+	dependence_count = c->dependence_count;
+	while (dependence_count != 0)
+		clk_disable(c->dependence[--dependence_count]);
+out:
+	clk_unlock_restore(c, flags);
+	return ret;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *c)
+{
+	unsigned long flags;
+	u32 dependence_count = c->dependence_count;
+
+	clk_lock_save(c, flags);
+
+	if (c->refcnt == 0) {
+		clk_unlock_restore(c, flags);
+		return;
+	}
+	if (c->refcnt == 1) {
+		if (c->ops && c->ops->disable)
+			c->ops->disable(c);
+
+		if (c->parent)
+			clk_disable(c->parent);
+
+		while (dependence_count != 0)
+			clk_disable(c->dependence[--dependence_count]);
+	}
+	c->refcnt--;
+
+	if (clk_is_dvfs(c) && c->refcnt == 0)
+		dvfs_set_rate(c, 0);
+
+	clk_unlock_restore(c, flags);
+}
+EXPORT_SYMBOL(clk_disable);
+
+int clk_set_rate(struct clk *c, unsigned long rate)
+{
+	int ret = 0;
+	unsigned long flags, old_rate;
+	long new_rate;
+	int sr_flag = 0;
+	if (disable_freqchg)
+		return 0;
+
+	clk_lock_save(c, flags);
+
+	if ((c->refcnt != 0) && !c->dynamic_change) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	if (!c->ops || !c->ops->setrate) {
+		ret = -ENOSYS;
+		goto out;
+	}
+
+	old_rate = clk_get_rate_locked(c);
+
+	if (c->ops && c->ops->round_rate) {
+		new_rate = c->ops->round_rate(c, rate);
+
+		if (new_rate < 0) {
+			ret = new_rate;
+			goto out;
+		}
+
+		rate = new_rate;
+	}
+
+	if (clk_is_dvfs(c) && c->refcnt > 0 && rate > old_rate) {
+		ret = dvfs_set_rate(c, rate);
+		if (ret)
+			goto out;
+	}
+
+	new_rate = rate;
+
+	if (!enable_voltage_based_dvfm  || !c->is_combined_fc) {
+		ret = c->ops->setrate(c, rate);
+		if (ret)
+			goto out;
+
+		if (c->ops->getrate)
+			new_rate = c->ops->getrate(c);
+		if (rate != new_rate) {
+			rate = new_rate;
+			sr_flag = 1;
+		}
+
+		c->rate = rate;
+	}
+	if (clk_is_dvfs(c) && c->refcnt > 0 && (rate < old_rate || sr_flag)) {
+		ret = dvfs_set_rate(c, rate);
+		if (ret)
+			goto out;
+	}
+
+out:
+	clk_unlock_restore(c, flags);
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+unsigned long clk_get_rate(struct clk *c)
+{
+	unsigned long flags;
+	unsigned long rate;
+
+	clk_lock_save(c, flags);
+
+	rate = clk_get_rate_locked(c);
+
+	clk_unlock_restore(c, flags);
+
+	return rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+int clk_set_parent(struct clk *c, struct clk *parent)
+{
+	int ret = 0;
+	unsigned long flags, new_rate, old_rate;
+
+	clk_lock_save(c, flags);
+
+	if (!c->ops || !c->ops->set_parent) {
+		ret = -ENOSYS;
+		goto out;
+	}
+
+	new_rate = clk_predict_rate_from_parent(c, parent);
+	old_rate = clk_get_rate_locked(c);
+
+	if (c->ops && c->ops->getrate)
+		new_rate = c->ops->getrate(c);
+
+	if (clk_is_dvfs(c) && c->refcnt > 0 && new_rate > old_rate) {
+		ret = dvfs_set_rate(c, new_rate);
+		if (ret)
+			goto out;
+	}
+
+	ret = c->ops->set_parent(c, parent);
+	if (ret)
+		goto out;
+
+	if (clk_is_dvfs(c) && c->refcnt > 0 && new_rate < old_rate)
+		ret = dvfs_set_rate(c, new_rate);
+
+out:
+	clk_unlock_restore(c, flags);
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+struct clk *clk_get_parent(struct clk *c)
+{
+	return c->parent;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+long clk_round_rate(struct clk *c, unsigned long rate)
+{
+	unsigned long flags;
+	long ret;
+
+	clk_lock_save(c, flags);
+
+	if (!c->ops || !c->ops->round_rate) {
+		ret = -ENOSYS;
+		goto out;
+	}
+
+	ret = c->ops->round_rate(c, rate);
+
+out:
+	clk_unlock_restore(c, flags);
+	return ret;
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+struct clk *get_clock_by_name(const char *name)
+{
+	struct clk *c;
+	struct clk *ret = NULL;
+	mutex_lock(&clock_list_lock);
+	list_for_each_entry(c, &clocks, node) {
+		if (strcmp(c->name, name) == 0) {
+			ret = c;
+			break;
+		}
+	}
+	mutex_unlock(&clock_list_lock);
+	return ret;
+}
+
+#if defined(CONFIG_DEBUG_FS)
+DEFINE_MUTEX(clk_mutex);
+static int clk_enable_open(struct inode *inode, struct file *filp)
+{
+	filp->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t
+clk_enable_read(struct file *filp, char __user *ubuf, size_t cnt,
+		loff_t *ppos)
+{
+	struct clk *clk = filp->private_data;
+	char buf[5];
+	int ret;
+
+	mutex_lock(&clk_mutex);
+	sprintf(buf, "%4x", clk->refcnt);
+	mutex_unlock(&clk_mutex);
+	buf[4] = '\n';
+
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, 5);
+
+	return ret;
+}
+
+static ssize_t
+clk_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,
+		 loff_t *ppos)
+{
+	struct clk *clk = filp->private_data;
+	char buf[64];
+	unsigned long val;
+	int ret;
+
+	if (cnt >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(&buf, ubuf, cnt))
+		return -EFAULT;
+
+	buf[cnt] = 0;
+
+	ret = kstrtoul(buf, 10, &val);
+	if (ret < 0)
+		return ret;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	*ppos += cnt;
+	mutex_lock(&clk_mutex);
+	if (val)
+		clk_enable(clk);
+	else
+		clk_disable(clk);
+	mutex_unlock(&clk_mutex);
+
+	return cnt;
+}
+
+static const struct file_operations clk_enable_fops = {
+	.open = clk_enable_open,
+	.read = clk_enable_read,
+	.write = clk_enable_write,
+};
+
+static int clk_rate_open(struct inode *inode, struct file *filp)
+{
+	filp->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t
+clk_getrate_read(struct file *filp, char __user *ubuf, size_t cnt,
+		loff_t *ppos)
+{
+	struct clk *clk = filp->private_data;
+	char buf[12];
+	int ret, len = 0;
+
+	mutex_lock(&clk_mutex);
+	len = snprintf(buf, sizeof(buf), "%10lu\n", clk_get_rate(clk));
+	mutex_unlock(&clk_mutex);
+
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, len);
+	return ret;
+}
+
+static ssize_t
+clk_setrate_write(struct file *filp, const char __user *ubuf, size_t cnt,
+		 loff_t *ppos)
+{
+	struct clk *clk = filp->private_data;
+	char buf[64];
+	unsigned long rate;
+	int ret;
+
+	if (cnt >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(&buf, ubuf, cnt))
+		return -EFAULT;
+
+	buf[cnt] = 0;
+
+	ret = kstrtoul(buf, 10, &rate);
+	if (ret < 0)
+		return ret;
+
+	*ppos += cnt;
+	mutex_lock(&clk_mutex);
+	clk_set_rate(clk, rate);
+	mutex_unlock(&clk_mutex);
+
+	return cnt;
+}
+
+
+static const struct file_operations clk_rate_fops = {
+	.open = clk_rate_open,
+	.read = clk_getrate_read,
+	.write = clk_setrate_write,
+};
+
+
+/*
+ *	debugfs support to trace clock tree hierarchy and attributes
+ */
+static struct dentry *clk_debugfs_root;
+
+static int clk_debugfs_register_one(struct clk *c)
+{
+	int err;
+	struct dentry *d, *child, *child_tmp;
+	struct clk *pa = c->parent;
+	char s[255];
+	char *p = s;
+
+	if (!c->name)
+		return -EINVAL;
+
+	p += sprintf(p, "%s", c->name);
+	d = debugfs_create_dir(s, pa ? pa->dent : clk_debugfs_root);
+	if (!d)
+		return -ENOMEM;
+	c->dent = d;
+
+	d = debugfs_create_u32("usecount", S_IRUGO, c->dent, (u32 *)&c->refcnt);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	d = debugfs_create_file("rate", 0644, c->dent, c, &clk_rate_fops);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	d = debugfs_create_file("enable", 0644, c->dent, c, &clk_enable_fops);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	return 0;
+
+err_out:
+	d = c->dent;
+	list_for_each_entry_safe(child, child_tmp, &d->d_subdirs, d_u.d_child)
+		debugfs_remove(child);
+	debugfs_remove(c->dent);
+	return err;
+}
+
+static int clk_debugfs_register(struct clk *c)
+{
+	int err;
+	struct clk *pa = c->parent;
+
+	if (pa && !pa->dent) {
+		err = clk_debugfs_register(pa);
+		if (err)
+			return err;
+	}
+
+	if (!c->dent) {
+		err = clk_debugfs_register_one(c);
+		if (err)
+			return err;
+	}
+	return 0;
+}
+
+static int __init clk_debugfs_init(void)
+{
+	struct clk *c;
+	struct dentry *d;
+	int err;
+
+	d = debugfs_create_dir("clock", NULL);
+	if (!d)
+		return -ENOMEM;
+	clk_debugfs_root = d;
+
+	list_for_each_entry(c, &clocks, node) {
+		err = clk_debugfs_register(c);
+		if (err)
+			goto err_out;
+	}
+	return 0;
+err_out:
+	debugfs_remove_recursive(clk_debugfs_root);
+	return err;
+}
+late_initcall(clk_debugfs_init);
+
+#endif /* CONFIG_DEBUG_FS */
diff --git a/arch/arm/plat-pxa/debugfs.c b/arch/arm/plat-pxa/debugfs.c
new file mode 100644
index 00000000..2f77fe45
--- /dev/null
+++ b/arch/arm/plat-pxa/debugfs.c
@@ -0,0 +1,732 @@
+/*
+ * arch/arm/plat-pxa/debugfs.c
+ *
+ * Author:	Neil Zhang <zhangwm@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/io.h>
+
+#include <mach/addr-map.h>
+#include <plat/debugfs.h>
+#include <mach/cputype.h>
+
+#ifdef CONFIG_CACHE_L2X0
+#include <asm/hardware/cache-l2x0.h>
+#endif
+
+#ifdef CONFIG_ARM_GIC
+#include <asm/hardware/gic.h>
+#endif
+
+static ssize_t cp15_write(struct file *filp, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	pr_info("cp15 doesn't support read a giving register now.\n"
+		"Please cat it directly.\n");
+
+	return count;
+}
+
+static ssize_t cp15_read(struct file *filp, char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	char *p;
+	size_t ret, buf_len;
+	u32 value;
+	int len = 0;
+
+	p = (char *)__get_free_pages(GFP_KERNEL, 0);
+	if (!p)
+		return -ENOMEM;
+
+	buf_len	= (PAGE_SIZE - 1);
+
+	/* c0 registers */
+	asm volatile("mrc p15, 0, %0, c0, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Main ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Cache Type: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c0, 3" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"TLB Type: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Processor Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Processor Feature 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Debug Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 3" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Auxiliary Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 4" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Memory Model Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 5" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Memory Model Feature 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 6" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Memory Model Feature 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 7" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Memory Model Feature 3: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Set Attribute 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Set Attribute 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Set Attribute 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 3" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Set Attribute 3: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 4" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Set Attribute 4: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c0, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Current Cache Size ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c0, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Current Cache Level ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 2, %0, c0, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Cache Size Selection: 0x%08x\n", value);
+
+	/* c1 registers */
+	asm volatile("mrc p15, 0, %0, c1, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"System Control: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Auxiliary Control: 0x%08x\n", value);
+
+	len += snprintf(p + len, buf_len - len, "L2 prefetch: %s\n",
+			(value & (1 << 1)) ? "Enabled" : "Disabled");
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Coprocessor Access Control: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c1, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Secure Configuration: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c1, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Secure Debug Enable: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c1, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Non-Secure Access Control: 0x%08x\n", value);
+
+	if (cpu_is_armv7_a9()) {
+		asm volatile("mrc p15, 0, %0, c1, c1, 3" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"Virtualization Control: 0x%08x\n", value);
+	}
+
+	/* c2 registers */
+	asm volatile("mrc p15, 0, %0, c2, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Translation Table Base 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c2, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Translation Table Base 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c2, c0, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Translation Table Control: 0x%08x\n", value);
+
+	/* c3 registers */
+	asm volatile("mrc p15, 0, %0, c3, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Domain Access Control: 0x%08x\n", value);
+
+	/* c5 registers */
+	asm volatile("mrc p15, 0, %0, c5, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Data Fault Status: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c5, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Fault Status: 0x%08x\n", value);
+
+	/* c6 registers */
+	asm volatile("mrc p15, 0, %0, c6, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Data Fault Address: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c6, c0, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Fault Address: 0x%08x\n", value);
+
+	/* c7 register */
+	asm volatile("mrc p15, 0, %0, c7, c4, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Physical Address: 0x%08x\n", value);
+
+	/* c9 register */
+	asm volatile("mrc p15, 0, %0, c9, c12, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Performance Monitor Control(PMCR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c12, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Count Enable Set(PMCNTENSET): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c12, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Count Enable Clear(PMCNTENCLR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c12, 3" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Overflow Flag Status(PMOVSR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c12, 5" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Event Counter Selection(PMSELR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c13, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Cycle Count(PMCCNTR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c13, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Event Type Select(PMXEVTYPER): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c13, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Event Count(PMXEVCNTR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c14, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"User Enable(PMUSERENR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c14, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Interrupt Enable Set(PMINTENSET): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c14, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Interrupt Enable Clear(PMINTENCLR): 0x%08x\n", value);
+
+	if (cpu_is_armv7_a7()) {
+		asm volatile("mrc p15, 1, %0, c9, c0, 2" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"L2 Control: 0x%08x\n", value);
+
+		asm volatile("mrc p15, 1, %0, c9, c0, 3" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"L2 Extended Control: 0x%08x\n", value);
+	}
+
+	/* c10 registers */
+	if (cpu_is_armv7_a9()) {
+		asm volatile("mrc p15, 0, %0, c10, c0, 0" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"TLB Lockdown: 0x%08x\n", value);
+	}
+	asm volatile("mrc p15, 0, %0, c10, c2, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Memory Attribute PRRR: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c10, c2, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Memory Attribute NMRR: 0x%08x\n", value);
+
+	if (cpu_is_armv7_a7()) {
+		asm volatile("mrc p15, 0, %0, c10, c2, 0" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"Memory Attribute Indirection 0: 0x%08x\n",
+				value);
+
+		asm volatile("mrc p15, 0, %0, c10, c2, 1" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"Memory Attribute Indirection 1: 0x%08x\n",
+				value);
+	}
+
+	/* c11 register */
+	if (cpu_is_armv7_a9()) {
+		asm volatile("mrc p15, 0, %0, c11, c1, 0" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"Preload Engine User Accessibility: 0x%08x\n",
+				value);
+
+		asm volatile("mrc p15, 0, %0, c11, c1, 1" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"Preload Engine Parameters Control: 0x%08x\n",
+				value);
+	}
+
+	/* c12 register */
+	asm volatile("mrc p15, 0, %0, c12, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Vector Base Address: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c12, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Monitor Vector Base Address: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c12, c1, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Interrupt Status: 0x%08x\n", value);
+
+	/* c13 register */
+	asm volatile("mrc p15, 0, %0, c13, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"FCSE Process ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c13, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Context ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c13, c0, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"User Thread ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c13, c0, 4" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Privileged Only Thread ID: 0x%08x\n", value);
+
+	/* c15 registers */
+	if (cpu_is_armv7_a9()) {
+		asm volatile("mrc p15, 0, %0, c15, c0, 0" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"Power Control: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c15, c1, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len, "NEON is: %s\n",
+			(value & (1 << 0)) ?  "Busy" : "Idle");
+
+	asm volatile("mrc p15, 0, %0, c15, c5, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Main TLB VA: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c15, c6, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Main TLB PA: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c15, c7, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Main TLB Attribute: 0x%08x\n", value);
+	} else if (cpu_is_armv7_a7()) {
+
+		asm volatile("mrc p15, 3, %0, c15, c0, 0" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"Direct Access To Interal Memory Data 0: 0x%08x\n",
+				value);
+
+		asm volatile("mrc p15, 3, %0, c15, c0, 1" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"Direct Access To Interal Memory Data 1: 0x%08x\n",
+				value);
+
+		asm volatile("mrc p15, 3, %0, c15, c0, 2" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"Direct Access To Interal Memory Data 2: 0x%08x\n",
+				value);
+
+		asm volatile("mrc p15, 4, %0, c15, c0, 0" : "=r"(value));
+		len += snprintf(p + len, buf_len - len,
+				"Configuration Base Address: 0x%08x\n", value);
+	}
+	if (len == buf_len)
+		pr_warn("The buffer for dumpping cp15 is full now!\n");
+
+	ret = simple_read_from_buffer(buffer, count, ppos, p, len);
+	free_pages((unsigned long)p, 0);
+
+	return ret;
+}
+
+const struct file_operations dumpregs_cp15_fops = {
+	.read = cp15_read,
+	.write = cp15_write,
+};
+
+
+#ifdef CONFIG_ARM_GIC
+#define GIC_DIST_STATUS		0xD00
+
+static int gic_offset = -1;
+
+static ssize_t gic_write(struct file *filp, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	char buf[32] = {0};
+	int offset;
+
+	/* copy user's input to kernel space */
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%x", &offset);
+	pr_info("Check gic offset: 0x%x\n", offset);
+
+	if (offset < 0 || offset > 0xffc)
+		pr_err("The offset is out of GIC distributor range.\n");
+	else if (offset % 4)
+		pr_err("offset should be aligned to 4 bytes.\n");
+	else
+		gic_offset = offset;
+
+	return count;
+
+}
+
+static ssize_t gic_read(struct file *filp, char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	void __iomem *dist_base = (void __iomem *)GIC_DIST_VIRT_BASE;
+	char *p;
+	size_t ret, buf_len;
+	u32 gic_irqs;
+	u32 value;
+	int i, len = 0;
+
+	p = (char *)__get_free_pages(GFP_KERNEL, 0);
+	if (!p)
+		return -ENOMEM;
+
+	buf_len = (PAGE_SIZE - 1);
+
+	if (gic_offset != -1) {
+		value = readl_relaxed(dist_base + gic_offset);
+		len += snprintf(p + len, buf_len - len,
+				"offset[0x%x]: 0x%08x\n", gic_offset, value);
+	} else {
+		gic_irqs = readl_relaxed(dist_base + GIC_DIST_CTR) & 0x1f;
+		gic_irqs = (gic_irqs + 1) * 32;
+		if (gic_irqs > 1020)
+			gic_irqs = 1020;
+
+		value = readl_relaxed(dist_base + GIC_DIST_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"Dist Control Register: 0x%08x\n", value);
+
+		for (i = 32; i < gic_irqs; i += 4) {
+			value = readl_relaxed(dist_base + GIC_DIST_TARGET
+					+ i * 4 / 4);
+			len += snprintf(p + len, buf_len - len,
+				"Target setting[%d]: 0x%08x\n", i / 4, value);
+		}
+
+		for (i = 32; i < gic_irqs; i += 32) {
+			value = readl_relaxed(dist_base + GIC_DIST_ENABLE_SET
+					+ i * 4 / 32);
+			len += snprintf(p + len, buf_len - len,
+				"Enable setting[%d]: 0x%08x\n", i / 32, value);
+		}
+
+		for (i = 32; i < gic_irqs; i += 32) {
+			value = readl_relaxed(dist_base + GIC_DIST_PENDING_SET
+					+ i * 4 / 32);
+			len += snprintf(p + len, buf_len - len,
+				"Pending status[%d]: 0x%08x\n", i / 32, value);
+		}
+
+		for (i = 32; i < gic_irqs; i += 32) {
+			value = readl_relaxed(dist_base + GIC_DIST_STATUS
+					+ i * 4 / 32);
+			len += snprintf(p + len, buf_len - len,
+				"SPI status[%d]: 0x%08x\n", i / 32, value);
+		}
+	}
+
+	if (len == buf_len)
+		pr_warn("The buffer for dumpping gic is full now!\n");
+
+	ret = simple_read_from_buffer(buffer, count, ppos, p, len);
+
+	free_pages((unsigned long)p, 0);
+
+	if (gic_offset != -1 && !ret)
+		gic_offset = -1;
+
+	return ret;
+}
+
+const struct file_operations dumpregs_gic_fops = {
+	.read = gic_read,
+	.write = gic_write,
+};
+#endif
+
+#ifdef CONFIG_CACHE_L2X0
+
+static int l2_offset = -1;
+
+static ssize_t l2_write(struct file *filp, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	char buf[32] = {0};
+	int offset;
+
+	/* copy user's input to kernel space */
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%x", &offset);
+	pr_info("Check L2 offset: 0x%x\n", offset);
+
+	if (offset < 0 || offset > 0xffc)
+		pr_err("The offset is out of L2 register range.\n");
+	else if (offset % 4)
+		pr_err("offset should be aligned to 4 bytes.\n");
+	else
+		l2_offset = offset;
+
+	return count;
+
+}
+
+static ssize_t l2_read(struct file *filp, char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	char buf[256];
+	char *p = buf;
+	size_t ret, buf_len;
+	u32 value;
+	int len = 0;
+
+	buf_len = sizeof(buf) - 1;
+
+	if (l2_offset != -1) {
+		value = readl_relaxed(l2x0_base + l2_offset);
+		len += snprintf(p + len, buf_len - len,
+				"offset[0x%x]: 0x%08x\n", l2_offset, value);
+	} else {
+		value = readl_relaxed(l2x0_base + L2X0_AUX_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"Auxiliary Control: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_TAG_LATENCY_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"Tag RAM Latency: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_DATA_LATENCY_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"Data RAM Latency: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_ADDR_FILTER_START);
+		len += snprintf(p + len, buf_len - len,
+				"Address filtering Start: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_ADDR_FILTER_END);
+		len += snprintf(p + len, buf_len - len,
+				"Address filtering End: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_PREFETCH_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"Prefetch Control: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_POWER_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"Power Control: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_CTRL);
+		len += snprintf(p + len, buf_len - len, "L2 Cache: %s\n",
+			(value & (1 << 0)) ? "Enabled" : "Disabled");
+	}
+
+	if (len == buf_len)
+		pr_warn("The buffer for dumpping L2 is full now!\n");
+
+	ret = simple_read_from_buffer(buffer, count, ppos, buf, len);
+	if (l2_offset != -1 && !ret)
+		l2_offset = -1;
+	return ret;
+}
+
+const struct file_operations dumpregs_l2_fops = {
+	.read = l2_read,
+	.write = l2_write,
+};
+#endif
+
+#ifdef CONFIG_HAVE_ARM_SCU
+
+#define SCU_CTRL		0x00
+#define SCU_CONFIG		0x04
+#define SCU_CPU_STATUS		0x08
+
+static int scu_offset = -1;
+
+static ssize_t scu_write(struct file *filp, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	char buf[32] = {0};
+	int offset;
+
+	/* copy user's input to kernel space */
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%x", &offset);
+	pr_info("Check SCU offset: 0x%x\n", offset);
+
+	if (offset < 0 || offset > 0x54)
+		pr_err("The offset is out of SCU register range.\n");
+	else if (offset % 4)
+		pr_err("offset should be aligned to 4 bytes.\n");
+	else
+		scu_offset = offset;
+
+	return count;
+}
+
+static ssize_t scu_read(struct file *filp, char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	char buf[256];
+	char *p = buf;
+	size_t ret, buf_len;
+	u32 value;
+	int len = 0;
+
+	buf_len = sizeof(buf) - 1;
+
+	if (scu_offset != -1) {
+		value = readl_relaxed(SCU_VIRT_BASE + scu_offset);
+		len += snprintf(p + len, buf_len - len,
+				"offset[0x%x]: 0x%08x\n", scu_offset, value);
+	} else {
+		value = readl_relaxed(SCU_VIRT_BASE + SCU_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"SCU Control: 0x%08x\n", value);
+
+		value = readl_relaxed(SCU_VIRT_BASE + SCU_CONFIG);
+		len += snprintf(p + len, buf_len - len,
+				"SCU Configuration: 0x%08x\n", value);
+
+		value = readl_relaxed(SCU_VIRT_BASE + SCU_CPU_STATUS);
+		len += snprintf(p + len, buf_len - len,
+				"SCU CPU Power Status: 0x%08x\n", value);
+	}
+
+	if (len == buf_len)
+		pr_warn("The buffer for dumpping SCU is full now!\n");
+
+	ret = simple_read_from_buffer(buffer, count, ppos, buf, len);
+	if (scu_offset != -1 && !ret)
+		scu_offset = -1;
+	return ret;
+}
+
+const struct file_operations dumpregs_scu_fops = {
+	.read = scu_read,
+	.write = scu_write,
+};
+#endif
+
+struct dentry *pxa;
+
+static int __init pxa_debugfs_init(void)
+{
+	struct dentry *dumpregs_cp15;
+#ifdef CONFIG_ARM_GIC
+	struct dentry *dumpregs_gic;
+#endif
+#ifdef CONFIG_CACHE_L2X0
+	struct dentry *dumpregs_l2;
+#endif
+#ifdef CONFIG_HAVE_ARM_SCU
+	struct dentry *dumpregs_scu;
+#endif
+
+	pxa = debugfs_create_dir("pxa", NULL);
+	if (!pxa)
+		return -ENOENT;
+
+	dumpregs_cp15 = debugfs_create_file("cp15", 0664,
+					pxa, NULL, &dumpregs_cp15_fops);
+	if (!dumpregs_cp15)
+		goto err_cp15;
+
+#ifdef CONFIG_ARM_GIC
+	dumpregs_gic = debugfs_create_file("gic_dist", 0664,
+					pxa, NULL, &dumpregs_gic_fops);
+	if (!dumpregs_gic)
+		goto err_gic;
+#endif
+
+#ifdef CONFIG_CACHE_L2X0
+	dumpregs_l2 = debugfs_create_file("l2", 0664,
+					pxa, NULL, &dumpregs_l2_fops);
+	if (!dumpregs_l2)
+		goto err_l2;
+#endif
+
+#ifdef CONFIG_HAVE_ARM_SCU
+	dumpregs_scu = debugfs_create_file("scu", 0664,
+				pxa, NULL, &dumpregs_scu_fops);
+	if (!dumpregs_scu)
+		goto err_scu;
+#endif
+
+	return 0;
+
+#ifdef CONFIG_HAVE_ARM_SCU
+err_scu:
+#endif
+
+#ifdef CONFIG_CACHE_L2X0
+	debugfs_remove(dumpregs_l2);
+	dumpregs_l2 = NULL;
+err_l2:
+#endif
+
+#ifdef CONFIG_ARM_GIC
+	debugfs_remove(dumpregs_gic);
+	dumpregs_gic = NULL;
+err_gic:
+#endif
+	debugfs_remove(dumpregs_cp15);
+	dumpregs_cp15 = NULL;
+
+err_cp15:
+	debugfs_remove(pxa);
+	pxa = NULL;
+
+	return -ENOENT;
+}
+
+postcore_initcall(pxa_debugfs_init);
diff --git a/arch/arm/plat-pxa/dma.c b/arch/arm/plat-pxa/dma.c
index 79ef102e..408463dc 100644
--- a/arch/arm/plat-pxa/dma.c
+++ b/arch/arm/plat-pxa/dma.c
@@ -39,6 +39,8 @@ struct dma_channel {
 static struct dma_channel *dma_channels;
 static int num_dma_channels;
 
+static DEFINE_SPINLOCK(dma_lock);
+
 /*
  * Debug fs
  */
@@ -242,7 +244,7 @@ static void pxa_dma_init_debugfs(void)
 	if (!dbgfs_state)
 		goto err_state;
 
-	dbgfs_chan = kmalloc(sizeof(*dbgfs_state) * num_dma_channels,
+	dbgfs_chan = kmalloc(sizeof(struct dentry*) * num_dma_channels,
 			     GFP_KERNEL);
 	if (!dbgfs_chan)
 		goto err_alloc;
@@ -288,7 +290,7 @@ int pxa_request_dma (char *name, pxa_dma_prio prio,
 	if (!name || !irq_handler)
 		return -EINVAL;
 
-	local_irq_save(flags);
+	spin_lock_irqsave(&dma_lock, flags);
 
 	do {
 		/* try grabbing a DMA channel with the requested priority */
@@ -312,7 +314,7 @@ int pxa_request_dma (char *name, pxa_dma_prio prio,
 		i = -ENODEV;
 	}
 
-	local_irq_restore(flags);
+	spin_unlock_irqrestore(&dma_lock, flags);
 	return i;
 }
 EXPORT_SYMBOL(pxa_request_dma);
@@ -328,10 +330,10 @@ void pxa_free_dma (int dma_ch)
 		return;
 	}
 
-	local_irq_save(flags);
+	spin_lock_irqsave(&dma_lock, flags);
 	DCSR(dma_ch) = DCSR_STARTINTR|DCSR_ENDINTR|DCSR_BUSERR;
 	dma_channels[dma_ch].name = NULL;
-	local_irq_restore(flags);
+	spin_unlock_irqrestore(&dma_lock, flags);
 }
 EXPORT_SYMBOL(pxa_free_dma);
 
@@ -340,6 +342,7 @@ static irqreturn_t dma_irq_handler(int irq, void *dev_id)
 	int i, dint = DINT;
 	struct dma_channel *channel;
 
+	spin_lock(&dma_lock);
 	while (dint) {
 		i = __ffs(dint);
 		dint &= (dint - 1);
@@ -355,6 +358,7 @@ static irqreturn_t dma_irq_handler(int irq, void *dev_id)
 			DCSR(i) = DCSR_STARTINTR|DCSR_ENDINTR|DCSR_BUSERR;
 		}
 	}
+	spin_unlock(&dma_lock);
 	return IRQ_HANDLED;
 }
 
@@ -377,7 +381,8 @@ int __init pxa_init_dma(int irq, int num_ch)
 		spin_lock_init(&dma_channels[i].lock);
 	}
 
-	ret = request_irq(irq, dma_irq_handler, IRQF_DISABLED, "DMA", NULL);
+	ret = request_irq(irq, dma_irq_handler, IRQF_DISABLED | IRQF_SHARED,
+			  "DMA", "DMAC");
 	if (ret) {
 		printk (KERN_CRIT "Wow!  Can't register IRQ for DMA\n");
 		kfree(dma_channels);
diff --git a/arch/arm/plat-pxa/dump_regs.c b/arch/arm/plat-pxa/dump_regs.c
new file mode 100644
index 00000000..30792499
--- /dev/null
+++ b/arch/arm/plat-pxa/dump_regs.c
@@ -0,0 +1,158 @@
+/*
+ * arch/arm/plat-pxa/dump_regs.c
+ *
+ * PXA988 Dump Soc registers and stack driver
+ *
+ * Copyright (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/sched.h>
+#include <linux/io.h>
+#include <asm/current.h>
+#include <plat/dump_regs.h>
+#include <mach/regs-map.h>
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#include <mach/regs-apmu.h>
+#endif
+
+
+static void ioremap_reg_map(struct reg_map map[])
+{
+	unsigned int i;
+	for (i = 0; map[i].reg_name != NULL; i++) {
+		if ((map[i].vir_addr == 0) &&
+		    (map[i].end_addr >= map[i].beg_addr)) {
+
+			map[i].vir_addr = (unsigned int)ioremap(map[i].beg_addr
+				, map[i].end_addr + 4 - map[i].beg_addr);
+
+			if (map[i].vir_addr == 0)
+				printk(KERN_INFO "ioremap(0x%08x, %d) failed!\n",
+					map[i].beg_addr,
+					map[i].end_addr + 4 - map[i].beg_addr);
+		}
+	}
+}
+
+static void iounmap_reg_map(struct reg_map map[])
+{
+	unsigned int i;
+	for (i = 0; map[i].reg_name != NULL; i++) {
+		if ((map[i].vir_addr != 0))
+			iounmap((volatile void *)map[i].vir_addr);
+	}
+}
+
+void dump_soc_regs(struct reg_map map[])
+{
+	unsigned int i, j, k;
+
+	unsigned int total = 0;
+	for (i = 0; map[i].reg_name != NULL; i++) {
+
+		printk(KERN_INFO "\n%-15s\t start:%08x end:%08x size=%d\n",
+			map[i].reg_name, map[i].beg_addr, map[i].end_addr,
+			map[i].end_addr - map[i].beg_addr + 4);
+
+		total += (map[i].end_addr - map[i].beg_addr + 4);
+
+		if (unlikely(map[i].vir_addr == 0)) {
+			pr_info("%s: NULL virtual address!\n",
+				map[i].reg_name);
+			continue;
+		}
+
+		for (j = map[i].beg_addr; j <= map[i].end_addr; j += 32) {
+
+			printk(KERN_INFO "%08x:", j);
+
+			for (k = j; (k <= map[i].end_addr) &&
+					(k < j + 32); k += 4)
+				printk(" %08x", __raw_readl(k - map[i].beg_addr
+							+ map[i].vir_addr));
+
+			printk("\n");
+		}
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+		if (strcmp(map[i].reg_name, "Apps_PMU_2") == 0) {
+			__raw_writel(__raw_readl(APMU_CP_CCR) | 0x80000000,
+					APMU_CP_CCR);
+			__raw_writel(__raw_readl(APMU_CP_CCR) & ~0x80000000,
+					APMU_CP_CCR);
+		}
+#endif
+	}
+
+	printk(KERN_INFO "total dumped reg size = %d\n", total);
+}
+
+
+
+void dump_stack_and_func(void)
+{
+	register unsigned long current_sp asm ("sp");
+	unsigned long flag;
+	unsigned long *cur_stack;
+	unsigned long *copy_stack;
+	unsigned long *top_stack;
+	char *thread_name;
+	pid_t cur_pid;
+
+	local_irq_save(flag);
+	cur_stack = (unsigned long *)current_sp;
+	copy_stack = (unsigned long *)current_sp;
+	thread_name = current->comm;
+	cur_pid = current->pid;
+	top_stack = (unsigned long *)((current_sp
+			& (~(THREAD_SIZE - 1))) + THREAD_SIZE);
+	local_irq_restore(flag);
+
+	printk(KERN_INFO "\nStart to print kernel stack and func in stack!\n");
+	printk(KERN_INFO "Thread_name:%s PID:%d sp=%lx, Kernel_stack@%lx-to-%lx\n",
+		thread_name, cur_pid, (unsigned long)cur_stack,
+		(unsigned long)cur_stack & (~(THREAD_SIZE - 1)),
+		(unsigned long)top_stack);
+
+	cur_stack = (unsigned long *)((unsigned long)cur_stack & (~31));
+	while (cur_stack < top_stack) {
+		printk(KERN_INFO "%08lx: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+			(unsigned long)cur_stack, *cur_stack, *(cur_stack + 1),
+			*(cur_stack + 2), *(cur_stack + 3), *(cur_stack + 4),
+			*(cur_stack + 5), *(cur_stack + 6), *(cur_stack + 7));
+
+		cur_stack += 8;
+	}
+
+	printk(KERN_INFO "\n_stext:0x%x, _etext:0x%x\n",
+			(unsigned int)&_stext, (unsigned int)&_etext);
+	printk(KERN_INFO "\nPossible func in current stack, please check them manually\n");
+
+	while (copy_stack <= top_stack) {
+		if ((*copy_stack < (unsigned int)&_etext) &&
+		    (*copy_stack > (unsigned int)&_stext))
+			printk(KERN_INFO "[<%08lx>] (%pS)\n",
+				(*copy_stack), (void *)(*copy_stack));
+		copy_stack += 1;
+	}
+	printk(KERN_INFO "\nEnd of %s()\n", __func__);
+}
+
+static int __init dump_regs_init(void)
+{
+	printk(KERN_INFO "dump_regs_init()!\n");
+	ioremap_reg_map(pxa_reg_map);
+	return 0;
+}
+
+static void __exit dump_regs_exit(void)
+{
+	iounmap_reg_map(pxa_reg_map);
+}
+
+arch_initcall(dump_regs_init);
+__exitcall(dump_regs_exit);
diff --git a/arch/arm/plat-pxa/dvfs.c b/arch/arm/plat-pxa/dvfs.c
new file mode 100644
index 00000000..47e116b4
--- /dev/null
+++ b/arch/arm/plat-pxa/dvfs.c
@@ -0,0 +1,364 @@
+/*
+ *  linux/arch/arm/plat-pxa/dvfs.c
+ *
+ *  based on arch/arm/mach-tegra/dvfs.c
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/export.h>
+#include <linux/err.h>
+#include <linux/regulator/consumer.h>
+#include <linux/list.h>
+
+#include <plat/clock.h>
+#include <plat/dvfs.h>
+#include <plat/pxa_trace.h>
+
+static LIST_HEAD(dvfs_rail_list);
+static DEFINE_MUTEX(dvfs_lock);
+
+static ATOMIC_NOTIFIER_HEAD(dvfs_freq_notifier_list);
+
+int dvfs_notifier_frequency(struct dvfs_freqs *freqs, unsigned int state)
+{
+	int ret;
+
+	switch (state) {
+	case DVFS_FREQ_PRECHANGE:
+		ret = atomic_notifier_call_chain(&dvfs_freq_notifier_list,
+						 DVFS_FREQ_PRECHANGE, freqs);
+		if (ret != NOTIFY_DONE)
+			pr_debug("Failure in device driver before "
+				 "switching frequency\n");
+		break;
+	case DVFS_FREQ_POSTCHANGE:
+		ret = atomic_notifier_call_chain(&dvfs_freq_notifier_list,
+						 DVFS_FREQ_POSTCHANGE, freqs);
+		if (ret != NOTIFY_DONE)
+			pr_debug("Failure in device driver after "
+				 "switching frequency\n");
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(dvfs_notifier_frequency);
+
+int dvfs_register_notifier(struct notifier_block *nb, unsigned int list)
+{
+	int ret;
+
+	switch (list) {
+	case DVFS_FREQUENCY_NOTIFIER:
+		ret = atomic_notifier_chain_register
+		    (&dvfs_freq_notifier_list, nb);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(dvfs_register_notifier);
+
+int dvfs_unregister_notifier(struct notifier_block *nb, unsigned int list)
+{
+	int ret;
+
+	switch (list) {
+	case DVFS_FREQUENCY_NOTIFIER:
+		ret = atomic_notifier_chain_unregister
+		    (&dvfs_freq_notifier_list, nb);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(dvfs_unregister_notifier);
+
+void dvfs_add_relationships(struct dvfs_relationship *rels, int n)
+{
+	int i;
+	struct dvfs_relationship *rel;
+
+	mutex_lock(&dvfs_lock);
+
+	for (i = 0; i < n; i++) {
+		rel = &rels[i];
+		list_add_tail(&rel->from_node, &rel->to->relationships_from);
+		list_add_tail(&rel->to_node, &rel->from->relationships_to);
+	}
+
+	mutex_unlock(&dvfs_lock);
+}
+
+void dvfs_remove_relationship(struct dvfs_relationship *rel)
+{
+	mutex_lock(&dvfs_lock);
+
+	list_del(&rel->from_node);
+	list_del(&rel->to_node);
+
+	mutex_unlock(&dvfs_lock);
+}
+
+
+int dvfs_init_rails(struct dvfs_rail *rails[], int n)
+{
+	int i;
+
+	mutex_lock(&dvfs_lock);
+
+	for (i = 0; i < n; i++) {
+		INIT_LIST_HEAD(&rails[i]->dvfs);
+		INIT_LIST_HEAD(&rails[i]->relationships_from);
+		INIT_LIST_HEAD(&rails[i]->relationships_to);
+		rails[i]->millivolts = rails[i]->nominal_millivolts;
+		rails[i]->new_millivolts = rails[i]->nominal_millivolts;
+		if (!rails[i]->step)
+			rails[i]->step = rails[i]->max_millivolts;
+
+		list_add_tail(&rails[i]->node, &dvfs_rail_list);
+	}
+
+	mutex_unlock(&dvfs_lock);
+
+	return 0;
+};
+
+static int dvfs_solve_relationship(struct dvfs_relationship *rel)
+{
+	return rel->solve(rel->from, rel->to);
+}
+
+/*
+ * Sets the voltage on a dvfs rail to a specific value, and updates any
+ * rails that depend on this rail.
+ */
+static int dvfs_rail_set_voltage(struct dvfs_rail *rail, int millivolts)
+{
+	int ret = 0;
+	struct dvfs_relationship *rel;
+	int step = (millivolts > rail->millivolts) ? rail->step : -rail->step;
+	int i;
+	int steps;
+
+	if (!rail->reg) {
+		if (millivolts == rail->millivolts)
+			return 0;
+		else
+			return -EINVAL;
+	}
+
+	steps = DIV_ROUND_UP(abs(millivolts - rail->millivolts), rail->step);
+
+	for (i = 0; i < steps; i++) {
+		if (abs(millivolts - rail->millivolts) > rail->step)
+			rail->new_millivolts = rail->millivolts + step;
+		else
+			rail->new_millivolts = millivolts;
+
+		/*
+		 * Before changing the voltage, tell each rail that depends
+		 * on this rail that the voltage will change.
+		 * This rail will be the "from" rail in the relationship,
+		 * the rail that depends on this rail will be the "to" rail.
+		 * from->millivolts will be the old voltage
+		 * from->new_millivolts will be the new voltage
+		 */
+		list_for_each_entry(rel, &rail->relationships_to, to_node) {
+			ret = dvfs_rail_update(rel->to);
+			if (ret)
+				return ret;
+		}
+
+		ret = regulator_set_voltage(rail->reg,
+				rail->new_millivolts * 1000,
+				rail->max_millivolts * 1000);
+		if (ret) {
+			pr_err("Failed to set dvfs regulator %s\n",
+				rail->reg_id);
+			return ret;
+		}
+
+		trace_pxa_set_voltage((u32)rail,\
+			rail->millivolts, rail->new_millivolts);
+		rail->millivolts = rail->new_millivolts;
+
+		/*
+		 * After changing the voltage, tell each rail that depends
+		 * on this rail that the voltage has changed.
+		 * from->millivolts and from->new_millivolts will be the
+		 * new voltage
+		 */
+		list_for_each_entry(rel, &rail->relationships_to, to_node) {
+			ret = dvfs_rail_update(rel->to);
+			if (ret)
+				return ret;
+		}
+	}
+
+	if (unlikely(rail->millivolts != millivolts)) {
+		pr_err("%s: rail didn't reach target %d in %d steps (%d)\n",
+			__func__, millivolts, steps, rail->millivolts);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+/*
+ * Determine the minimum valid voltage for a rail, taking into account
+ * the dvfs clocks and any rails that this rail depends on.  Calls
+ * dvfs_rail_set_voltage with the new voltage, which will call
+ * dvfs_rail_update on any rails that depend on this rail.
+ */
+int dvfs_rail_update(struct dvfs_rail *rail)
+{
+	int millivolts = 0;
+	struct dvfs *d;
+	struct dvfs_relationship *rel;
+	int ret = 0;
+
+	/* if regulators are not connected yet, return and handle it later */
+	if (!rail->reg)
+		return 0;
+
+	/* Find the maximum voltage requested by any clock */
+	list_for_each_entry(d, &rail->dvfs, dvfs_node)
+		millivolts = max(d->millivolts, millivolts);
+
+	if (millivolts != 0)
+		rail->new_millivolts = millivolts;
+
+	/* Check any rails that this rail depends on */
+	list_for_each_entry(rel, &rail->relationships_from, from_node)
+		rail->new_millivolts = dvfs_solve_relationship(rel);
+
+	if (rail->new_millivolts != rail->millivolts)
+		ret = dvfs_rail_set_voltage(rail, rail->new_millivolts);
+
+	return ret;
+}
+EXPORT_SYMBOL(dvfs_rail_update);
+
+static int dvfs_rail_connect_to_regulator(struct dvfs_rail *rail)
+{
+	struct regulator *reg = NULL;
+
+	if (rail->reg) {
+		pr_warn("dvfs: rail has already been connnected to reg\n");
+		return -EINVAL;
+	}
+
+	reg = regulator_get(NULL, rail->reg_id);
+	if (IS_ERR(reg))
+		return -EINVAL;
+
+	rail->reg = reg;
+
+	if (regulator_is_enabled(rail->reg))
+		rail->nominal_millivolts = regulator_get_voltage(rail->reg) / 1000;
+
+	return 0;
+}
+
+static int
+__dvfs_set_rate(struct dvfs *d, unsigned long rate)
+{
+	int i = 0;
+	int ret;
+
+	if (d->vol_freq_table == NULL)
+		return -ENODEV;
+
+	if (rate > d->vol_freq_table[d->num_freqs - 1].freq) {
+		pr_warn("dvfs: rate %lu too high for dvfs on %s\n", rate,
+			d->clk_name);
+		return -EINVAL;
+	}
+
+	if (rate == 0) {
+		d->millivolts = 0;
+	} else {
+		while (i < d->num_freqs && rate > d->vol_freq_table[i].freq)
+			i++;
+
+		d->millivolts = d->vol_freq_table[i].millivolts;
+	}
+
+	ret = dvfs_rail_update(d->dvfs_rail);
+	if (ret)
+		pr_err("Failed to set regulator %s for clock %s to %d mV\n",
+			d->dvfs_rail->reg_id, d->clk_name, d->millivolts);
+
+	return ret;
+}
+
+int dvfs_set_rate(struct clk *c, unsigned long rate)
+{
+	int ret;
+
+	if (!c->dvfs)
+		return -EINVAL;
+
+	mutex_lock(&dvfs_lock);
+	ret = __dvfs_set_rate(c->dvfs, rate);
+	mutex_unlock(&dvfs_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(dvfs_set_rate);
+
+/* May only be called during clock init, does not take any locks on clock c. */
+int __init enable_dvfs_on_clk(struct clk *c, struct dvfs *d)
+{
+	if (c->dvfs) {
+		pr_err("Error when enabling dvfs on %s for clock %s:\n",
+			d->dvfs_rail->reg_id, c->name);
+		pr_err("DVFS already enabled for %s\n",
+			c->dvfs->dvfs_rail->reg_id);
+		return -EINVAL;
+	}
+
+	clk_set_cansleep(c);
+
+	c->dvfs = d;
+
+	mutex_lock(&dvfs_lock);
+	list_add_tail(&d->dvfs_node, &d->dvfs_rail->dvfs);
+	mutex_unlock(&dvfs_lock);
+
+	return 0;
+}
+
+/*
+ * Iterate through all the dvfs regulators, finding the regulator exported
+ * by the regulator api for each one.
+ * Must be called after all the regulator api initialized (subsys_initcall).
+ * Must be called before all the cpufreq/devfreq framework initialized
+ * (module_initcall).
+ */
+int __init dvfs_late_init(void)
+{
+	struct dvfs_rail *rail;
+
+	mutex_lock(&dvfs_lock);
+
+	list_for_each_entry(rail, &dvfs_rail_list, node)
+		dvfs_rail_connect_to_regulator(rail);
+
+	list_for_each_entry(rail, &dvfs_rail_list, node)
+		dvfs_rail_update(rail);
+
+	mutex_unlock(&dvfs_lock);
+
+	return 0;
+}
+fs_initcall(dvfs_late_init);
+
diff --git a/arch/arm/plat-pxa/include/plat/clock.h b/arch/arm/plat-pxa/include/plat/clock.h
new file mode 100644
index 00000000..58b230d4
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/clock.h
@@ -0,0 +1,112 @@
+/*
+ *  linux/arch/arm/plat-pxa/include/pxa/clock.h
+ *
+ *  based on arch/arm/mach-tegra/clock.h
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef __PLAT_PXA_CLOCK_H
+#define __PLAT_PXA_CLOCK_H
+
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/clkdev.h>
+
+struct clk_mux_sel {
+	struct clk *input;
+	u32 value;
+};
+
+enum reg_type {
+	SOURCE = 0,
+	DIV,
+	MUL,
+	REG_TYPE_NUM,
+};
+
+enum reg_control {
+	STATUS = 0,
+	CONTROL,
+	REG_CONTROL_NUM,
+};
+
+struct clkops {
+	void (*init) (struct clk *);
+	int (*enable) (struct clk *);
+	void (*disable) (struct clk *);
+	unsigned long (*getrate) (struct clk *);
+	int (*setrate) (struct clk *, unsigned long);
+	int (*set_parent) (struct clk *, struct clk *);
+	long (*round_rate) (struct clk *, unsigned long);
+};
+
+struct clk {
+	const struct clkops *ops;
+
+	/* node for master clocks list */
+	struct list_head node;
+	struct clk_lookup lookup;
+	struct dvfs *dvfs;
+
+	bool cansleep;
+	bool dynamic_change;
+	const char *name;
+
+	u32 refcnt;
+	struct clk *parent;
+	struct clk **dependence;
+	u32 dependence_count;
+	u32 div;
+	u32 mul;
+
+	const struct clk_mux_sel *inputs;
+
+	struct {
+		void __iomem *reg;
+		u32 reg_shift;
+		u32 reg_mask;
+	} reg_data[REG_TYPE_NUM][REG_CONTROL_NUM];
+
+	struct list_head shared_bus_list;
+
+	struct mutex mutex;
+	spinlock_t spinlock;
+
+	unsigned long rate;
+
+#ifdef CONFIG_LOCKDEP
+	struct lock_class_key lockdep_key;
+#endif
+	/*
+	 * This is for the old MMP clock implementation
+	 * will remove them later
+	 */
+	/* For APBC clocks */
+	void __iomem *clk_rst;
+	int fnclksel;
+	/* value for clock enable (APMU) */
+	uint32_t enable_val;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry		*dent;	/* For visible tree hierarchy */
+#endif
+	bool is_combined_fc;	/* whether combine fc with other clocks */
+};
+
+void clk_init(struct clk *clk);
+int clk_reparent(struct clk *c, struct clk *parent);
+void clk_set_cansleep(struct clk *c);
+unsigned long clk_get_rate_locked(struct clk *c);
+struct clk *get_clock_by_name(const char *name);
+extern int enable_voltage_based_dvfm;
+
+static inline bool clk_is_dvfs(struct clk *c)
+{
+	return (c->dvfs != NULL);
+}
+
+#endif
diff --git a/arch/arm/plat-pxa/include/plat/debugfs.h b/arch/arm/plat-pxa/include/plat/debugfs.h
new file mode 100644
index 00000000..e55d4deb
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/debugfs.h
@@ -0,0 +1,22 @@
+/*
+ * arch/arm/plat-pxa/debugfs.h
+ *
+ * Author:	Neil Zhang <zhangwm@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __PXA_DEBUGFS_H_
+#define __PXA_DEBUGFS_H_
+
+#ifdef CONFIG_CACHE_L2X0
+extern void __iomem *l2x0_base;
+#endif
+
+extern struct dentry *pxa;
+
+#endif  /* __PXA_DEBUGFS_H_ */
diff --git a/arch/arm/plat-pxa/include/plat/devfreq.h b/arch/arm/plat-pxa/include/plat/devfreq.h
new file mode 100644
index 00000000..5aa88703
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/devfreq.h
@@ -0,0 +1,56 @@
+/*
+ * devfreq: Generic Dynamic Voltage and Frequency Scaling (DVFS) Framework
+ *	    for Non-CPU Devices.
+ *
+ * Copyright (C) 2012 Marvell
+ *	Xiaoguang Chen <chenxg@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __PXA_DEVFREQ_H__
+#define __PXA_DEVFREQ_H__
+
+#include <linux/devfreq.h>
+
+#define INIT_FREQ_TABLE(_index, _freq)	\
+	{				\
+		.index = _index,	\
+		.frequency = _freq,	\
+	}
+
+struct devfreq_platform_data {
+	const char *clk_name;
+	struct devfreq_frequency_table *freq_table;
+
+#ifdef CONFIG_DDR_DEVFREQ
+	unsigned int interleave_is_on;
+	unsigned int hw_base[2];
+	struct devfreq_pm_qos_table *qos_list;
+#endif
+};
+
+#ifdef CONFIG_DDR_DEVFREQ
+/*
+ * DDR PM constraint value, these lvl can be used by device driver.
+ * The relationship of Qos lvl and corresponding ddr frequency
+ * should be handled in platform. Frequency should be ordered in
+ * ascending.
+ * This can be used to avoid driver use the same lvl Qos value
+ * instead of different frequency on different platforms.
+ */
+enum ddr_pm_qos_constraint {
+	DDR_CONSTRAINT_LVL_RSV = 0,
+	DDR_CONSTRAINT_LVL0,
+	DDR_CONSTRAINT_LVL1,
+	DDR_CONSTRAINT_LVL2,
+	DDR_CONSTRAINT_LVL3,
+	DDR_CONSTRAINT_LVL4,
+	DDR_CONSTRAINT_LVL_MAX,
+};
+
+#endif
+
+#endif
diff --git a/arch/arm/plat-pxa/include/plat/dump_regs.h b/arch/arm/plat-pxa/include/plat/dump_regs.h
new file mode 100644
index 00000000..b44e0d04
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/dump_regs.h
@@ -0,0 +1,28 @@
+/*
+ * arch/arm/mach-pxa/include/mach/dump_regs.h
+ *
+ * PXA988 Dump Soc registers and stack Head File
+ *
+ * Copyright (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __DUMP_REGS_H__
+#define __DUMP_REGS_H__
+
+struct reg_map {
+	const unsigned int beg_addr;
+	const unsigned int end_addr;
+	unsigned int       vir_addr;
+	const char * const reg_name;
+};
+
+extern struct reg_map pxa_reg_map[];
+extern void dump_soc_regs(struct reg_map map[]);
+extern void dump_stack_and_func(void);
+extern unsigned int _stext, _etext;
+
+#endif
diff --git a/arch/arm/plat-pxa/include/plat/dvfs.h b/arch/arm/plat-pxa/include/plat/dvfs.h
new file mode 100644
index 00000000..45cf79e8
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/dvfs.h
@@ -0,0 +1,89 @@
+/*
+ *  linux/arch/arm/plat-pxa/include/plat/dvfs.h
+ *
+ *  based on arch/arm/mach-tegra/dvfs.h
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _PXA_DVFS_H_
+#define _PXA_DVFS_H_
+
+#include "clock.h"
+
+#define DVFS_FREQUENCY_NOTIFIER		0
+#define DVFS_FREQ_PRECHANGE		0
+#define DVFS_FREQ_POSTCHANGE		1
+
+struct dvfs_freqs {
+	struct dvfs *dvfs;
+	unsigned int old;	/*old frequency */
+	unsigned int new;	/*new frequency */
+};
+
+extern int dvfs_notifier_frequency(struct dvfs_freqs *freqs,
+				   unsigned int state);
+extern int dvfs_register_notifier(struct notifier_block *nb, unsigned int list);
+extern int dvfs_unregister_notifier(struct notifier_block *nb,
+				    unsigned int list);
+
+/*
+ * dvfs_relationship between to rails, "from" and "to"
+ * when the rail changes, it will call dvfs_rail_update on the rails
+ * in the relationship_to list.
+ * when determining the voltage to set a rail to, it will consider each
+ * rail in the relationship_from list.
+ */
+struct dvfs_relationship {
+	struct dvfs_rail *to;
+	struct dvfs_rail *from;
+	int (*solve)(struct dvfs_rail *, struct dvfs_rail *);
+
+	struct list_head to_node; /* node in relationship_to list */
+	struct list_head from_node; /* node in relationship_from list */
+};
+
+struct dvfs_rail {
+	const char *reg_id;
+	int min_millivolts;
+	int max_millivolts;
+	int nominal_millivolts;
+	int step;
+
+	struct list_head node;  /* node in dvfs_rail_list */
+	struct list_head dvfs;  /* list head of attached dvfs clocks */
+	struct list_head relationships_to;
+	struct list_head relationships_from;
+	struct regulator *reg;
+	int millivolts;
+	int new_millivolts;
+};
+
+struct vol_table {
+	unsigned long freq; /* in KHz */
+	int millivolts;
+};
+
+struct dvfs {
+	const char *clk_name;
+
+	/* Must be initialized before dvfs_init */
+	struct vol_table *vol_freq_table;
+	int num_freqs;
+	struct dvfs_rail *dvfs_rail;
+
+	int millivolts;
+	struct list_head dvfs_node;
+};
+
+int enable_dvfs_on_clk(struct clk *c, struct dvfs *d);
+int dvfs_init_rails(struct dvfs_rail *dvfs_rails[], int n);
+void dvfs_add_relationships(struct dvfs_relationship *rels, int n);
+void dvfs_remove_relationship(struct dvfs_relationship *rel);
+int dvfs_set_rate(struct clk *c, unsigned long rate);
+int dvfs_rail_update(struct dvfs_rail *rail);
+
+#endif
diff --git a/arch/arm/plat-pxa/include/plat/fb_ioctl.h b/arch/arm/plat-pxa/include/plat/fb_ioctl.h
new file mode 100644
index 00000000..5e8dc3b4
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/fb_ioctl.h
@@ -0,0 +1,279 @@
+/*
+ * linux/arch/arm/plat-pxa/include/plat/overlay_ioctl.h
+ *
+ *  Copyright (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_PLAT_FB_IOCTL_H
+#define __ASM_PLAT_FB_IOCTL_H
+/* ---------------------------------------------- */
+/*              IOCTL Definition                  */
+/* ---------------------------------------------- */
+#define FB_IOC_MAGIC                        'm'
+#define FB_IOCTL_CONFIG_CURSOR              _IO(FB_IOC_MAGIC, 0)
+#define FB_IOCTL_DUMP_REGS                  _IO(FB_IOC_MAGIC, 1)
+#define FB_IOCTL_CLEAR_IRQ                  _IO(FB_IOC_MAGIC, 2)
+
+/*
+ * There are many video mode supported.
+ */
+#define FB_IOCTL_SET_VIDEO_MODE             _IO(FB_IOC_MAGIC, 3)
+#define FB_IOCTL_GET_VIDEO_MODE             _IO(FB_IOC_MAGIC, 4)
+/* Request a new video buffer from driver. User program needs to free
+ * this memory.
+ */
+#define FB_IOCTL_CREATE_VID_BUFFER          _IO(FB_IOC_MAGIC, 5)
+
+/* Configure viewport in driver. */
+#define FB_IOCTL_SET_VIEWPORT_INFO          _IO(FB_IOC_MAGIC, 6)
+#define FB_IOCTL_GET_VIEWPORT_INFO          _IO(FB_IOC_MAGIC, 7)
+
+/* Flip the video buffer from user mode. Vide buffer can be separated into:
+ * a. Current-used buffer - user program put any data into it. It will be
+ *    displayed immediately.
+ * b. Requested from driver but not current-used - user programe can put any
+ *    data into it. It will be displayed after calling
+ *    FB_IOCTL_FLIP_VID_BUFFER.
+ *    User program should free this memory when they don't use it any more.
+ * c. User program alloated - user program can allocated a contiguos DMA
+ *    buffer to store its video data. And flip it to driver. Notices that
+ *    this momory should be free by user programs. Driver won't take care of
+ *    this.
+ */
+#define FB_IOCTL_FLIP_VID_BUFFER            _IO(FB_IOC_MAGIC, 8)
+
+#define FB_IOCTL_FLIP_VSYNC	            _IO(FB_IOC_MAGIC, 26)
+/* Get the current buffer information. User program could use it to display
+ * anything directly. If developer wants to allocate multiple video layers,
+ * try to use FB_IOCTL_CREATE_VID_BUFFER  to request a brand new video
+ * buffer.
+ */
+#define FB_IOCTL_GET_BUFF_ADDR              _IO(FB_IOC_MAGIC, 9)
+
+/* Get/Set offset position of screen */
+#define FB_IOCTL_SET_VID_OFFSET             _IO(FB_IOC_MAGIC, 10)
+#define FB_IOCTL_GET_VID_OFFSET             _IO(FB_IOC_MAGIC, 11)
+
+/* Turn on the memory toggle function to improve the frame rate while playing
+ * movie.
+ */
+#define FB_IOCTL_SET_MEMORY_TOGGLE          _IO(FB_IOC_MAGIC, 12)
+
+/* Turn on the memory toggle function to improve the frame rate while playing
+ * movie.
+ */
+#define FB_IOCTL_SET_COLORKEYnALPHA         _IO(FB_IOC_MAGIC, 13)
+#define FB_IOCTL_GET_COLORKEYnALPHA         _IO(FB_IOC_MAGIC, 14)
+#define FB_IOCTL_SWITCH_GRA_OVLY            _IO(FB_IOC_MAGIC, 15)
+#define FB_IOCTL_SWITCH_VID_OVLY            _IO(FB_IOC_MAGIC, 16)
+
+/* For VPro integration */
+#define FB_IOCTL_GET_FREELIST               _IO(FB_IOC_MAGIC, 17)
+
+/* Wait for vsync happen. */
+#define FB_IOCTL_WAIT_VSYNC                 _IO(FB_IOC_MAGIC, 18)
+
+/* clear framebuffer: Makes resolution or color space changes look nicer */
+#define FB_IOCTL_CLEAR_FRAMEBUFFER              _IO(FB_IOC_MAGIC, 19)
+
+/* Wait for vsync each time pan display */
+#define FB_IOCTL_WAIT_VSYNC_ON              _IO(FB_IOC_MAGIC, 20)
+#define FB_IOCTL_WAIT_VSYNC_OFF             _IO(FB_IOC_MAGIC, 21)
+
+/* Get and set the display surface */
+#define FB_IOCTL_GET_SURFACE			_IO(FB_IOC_MAGIC, 22)
+#define FB_IOCTL_SET_SURFACE			_IO(FB_IOC_MAGIC, 23)
+
+/* Graphic partial display ctrl */
+#define FB_IOCTL_GRA_PARTDISP			_IO(FB_IOC_MAGIC, 24)
+
+/* VDMA enable/disable */
+#define FB_IOCTL_VDMA_SET			_IO(FB_IOC_MAGIC, 25)
+
+/* Global alpha blend controls - Maintaining compatibility with existing
+   user programs. */
+#define FB_IOCTL_PUT_VIDEO_ALPHABLEND            0xeb
+#define FB_IOCTL_PUT_GLOBAL_ALPHABLEND           0xe1
+#define FB_IOCTL_PUT_GRAPHIC_ALPHABLEND          0xe2
+
+/* color swapping */
+#define FB_IOCTL_SWAP_GRAPHIC_RED_BLUE       0xe3
+#define FB_IOCTL_SWAP_GRAPHIC_U_V            0xe4
+#define FB_IOCTL_SWAP_GRAPHIC_Y_UV           0xe5
+#define FB_IOCTL_SWAP_VIDEO_RED_BLUE         0xe6
+#define FB_IOCTL_SWAP_VIDEO_U_V              0xe7
+#define FB_IOCTL_SWAP_VIDEO_Y_UV             0xe8
+
+/* colorkey compatibility */
+#define FB_IOCTL_GET_CHROMAKEYS		0xe9
+#define FB_IOCTL_PUT_CHROMAKEYS		0xea
+
+/* cmu operation */
+#define FB_IOCTL_CMU_SWITCH		0xf1
+#define FB_IOCTL_CMU_WRITE		0xf2
+#define FB_IOCTL_CMU_READ		0xf3
+#define FB_IOCTL_CMU_SET_ROUTE		0xf4
+#define FB_IOCTL_CMU_SET_PIP		0xf5
+#define FB_IOCTL_CMU_GET_RES		0xf6
+#define FB_IOCTL_CMU_SET_LETTER_BOX 0xf7
+
+/* gamma correction */
+#define FB_IOCTL_GAMMA_SET		0xff
+
+#define FB_VMODE_RGB565			0x100
+#define FB_VMODE_BGR565                 0x101
+#define FB_VMODE_RGB1555		0x102
+#define FB_VMODE_BGR1555                0x103
+#define FB_VMODE_RGB888PACK		0x104
+#define FB_VMODE_BGR888PACK		0x105
+#define FB_VMODE_RGB888UNPACK		0x106
+#define FB_VMODE_BGR888UNPACK		0x107
+#define FB_VMODE_RGBA888		0x108
+#define FB_VMODE_BGRA888		0x109
+#define FB_VMODE_RGB888A		0x10A
+#define FB_VMODE_BGR888A		0x10B
+
+#define FB_VMODE_YUV422PACKED               0x0
+#define FB_VMODE_YUV422PACKED_SWAPUV        0x1
+#define FB_VMODE_YUV422PACKED_SWAPYUorV     0x2
+#define FB_VMODE_YUV422PLANAR               0x3
+#define FB_VMODE_YUV422PLANAR_SWAPUV        0x4
+#define FB_VMODE_YUV422PLANAR_SWAPYUorV     0x5
+#define FB_VMODE_YUV420PLANAR               0x6
+#define FB_VMODE_YUV420PLANAR_SWAPUV        0x7
+#define FB_VMODE_YUV420PLANAR_SWAPYUorV     0x8
+#define FB_VMODE_YUV422PACKED_IRE_90_270    0x9
+#define FB_VMODE_YUV420SEMIPLANAR           0xA
+#define FB_VMODE_YUV420SEMIPLANAR_SWAPUV    0xB
+
+
+#define FB_HWCMODE_1BITMODE                 0x0
+#define FB_HWCMODE_2BITMODE                 0x1
+
+#define FB_DISABLE_COLORKEY_MODE            0x0
+#define FB_ENABLE_Y_COLORKEY_MODE           0x1
+#define FB_ENABLE_U_COLORKEY_MODE           0x2
+#define FB_ENABLE_V_COLORKEY_MODE           0x4
+#define FB_ENABLE_RGB_COLORKEY_MODE         0x3
+#define FB_ENABLE_R_COLORKEY_MODE           0x5
+#define FB_ENABLE_G_COLORKEY_MODE           0x6
+#define FB_ENABLE_B_COLORKEY_MODE           0x7
+
+#define FB_VID_PATH_ALPHA		0x0
+#define FB_GRA_PATH_ALPHA		0x1
+#define FB_CONFIG_ALPHA			0x2
+
+#define FB_SYNC_COLORKEY_TO_CHROMA          1
+#define FB_SYNC_CHROMA_TO_COLORKEY          2
+
+#define MAX_QUEUE_NUM 30
+
+/* ---------------------------------------------- */
+/*              Data Structure                    */
+/* ---------------------------------------------- */
+/*
+ * The follow structures are used to pass data from
+ * user space into the kernel for the creation of
+ * overlay surfaces and setting the video mode.
+ */
+
+#define FBVideoMode int
+
+struct _sViewPortInfo {
+	unsigned short srcWidth;        /* video source size */
+	unsigned short srcHeight;
+	unsigned short zoomXSize;       /* size after zooming */
+	unsigned short zoomYSize;
+	unsigned short yPitch;
+	unsigned short uPitch;
+	unsigned short vPitch;
+	unsigned int rotation;
+	unsigned int yuv_format;
+};
+
+struct _sViewPortOffset {
+	unsigned short xOffset;         /* position on screen */
+	unsigned short yOffset;
+};
+
+struct _sVideoBufferAddr {
+	unsigned char   frameID;        /* which frame wants */
+	 /* new buffer (PA). 3 addr for YUV planar */
+	unsigned char *startAddr[3];
+	unsigned char *inputData;       /* input buf address (VA) */
+	unsigned int length;            /* input data's length */
+};
+
+struct _sColorKeyNAlpha {
+	unsigned int mode;
+	unsigned int alphapath;
+	unsigned int config;
+	unsigned int Y_ColorAlpha;
+	unsigned int U_ColorAlpha;
+	unsigned int V_ColorAlpha;
+};
+
+struct _sOvlySurface {
+	FBVideoMode videoMode;
+	struct _sViewPortInfo viewPortInfo;
+	struct _sViewPortOffset viewPortOffset;
+	struct _sVideoBufferAddr videoBufferAddr;
+};
+
+struct mvdisp_cmu_config {
+	unsigned int addr;
+	unsigned int data;
+};
+
+struct mvdisp_cmu_pip {
+	unsigned int left;
+	unsigned int right;
+	unsigned int top;
+	unsigned int bottom;
+};
+
+struct mvdisp_partdisp {
+	/* path id, 0->panel, 1->TV, 2->panel2 */
+	int id;
+	/* partial display horizontal starting pixel number
+	 * NOTE: it must be 64x */
+	unsigned int horpix_start;
+	/* partial display vertical starting line number */
+	unsigned int vertline_start;
+	/* partial display horizontal ending pixel number
+	 * NOTE: it must be 64x */
+	unsigned int horpix_end;
+	/* partial display vertical ending line number */
+	unsigned int vertline_end;
+	/* graphic color for partial disabled area,
+	 * color format should be RGB565 */
+	unsigned short color;
+};
+
+struct mvdisp_vdma {
+	/* path id, 0->panel, 1->TV, 2->panel2 */
+	unsigned int path;
+	/* 0: grafhics, 1: video */
+	unsigned int layer;
+	unsigned int enable;
+};
+
+struct mvdisp_gamma {
+#define GAMMA_ENABLE	(1 << 0)
+#define GAMMA_DUMP	(1 << 1)
+	unsigned int	flag;
+#define GAMMA_TABLE_LEN	256
+	char		table[GAMMA_TABLE_LEN];
+};
+
+enum {
+	SYNC_SELF,
+	SYNC_PANEL,
+	SYNC_TV,
+	SYNC_PANEL_TV,
+};
+#endif /* __ASM_PLAT_FB_IOCTL_H */
diff --git a/arch/arm/plat-pxa/include/plat/mfp.h b/arch/arm/plat-pxa/include/plat/mfp.h
index 5c79c29f..6c6cd001 100644
--- a/arch/arm/plat-pxa/include/plat/mfp.h
+++ b/arch/arm/plat-pxa/include/plat/mfp.h
@@ -216,6 +216,79 @@ enum {
 	MFP_PIN_GPIO190,
 	MFP_PIN_GPIO191,
 
+	MFP_PIN_RF_MFP0 = MFP_PIN_GPIO133,
+	MFP_PIN_RF_MFP1,
+	MFP_PIN_RF_MFP2,
+	MFP_PIN_RF_MFP3,
+	MFP_PIN_RF_MFP4,
+	MFP_PIN_RF_MFP5,
+	MFP_PIN_RF_MFP6,
+	MFP_PIN_RF_MFP7,
+	MFP_PIN_RF_MFP8,
+	MFP_PIN_RF_MFP9,
+	MFP_PIN_RF_MFP10,
+	MFP_PIN_RF_MFP11,
+	MFP_PIN_RF_MFP12,
+	MFP_PIN_RF_MFP13,
+	MFP_PIN_RF_MFP14,
+	MFP_PIN_RF_MFP15,
+	MFP_PIN_RF_MFP16,
+	MFP_PIN_RF_MFP17,
+	MFP_PIN_RF_MFP18,
+	MFP_PIN_RF_MFP19,
+	MFP_PIN_RF_MFP20,
+	MFP_PIN_RF_MFP21,
+	MFP_PIN_RF_MFP22,
+	MFP_PIN_RF_MFP23,
+	MFP_PIN_RF_MFP24,
+	MFP_PIN_RF_MFP25,
+	MFP_PIN_RF_MFP26,
+	MFP_PIN_RF_MFP27,
+	MFP_PIN_RF_MFP28,
+	MFP_PIN_RF_MFP29,
+	MFP_PIN_RF_MFP30,
+
+	MFP_PIN_MEM_MFP0 = MFP_PIN_GPIO164,
+	MFP_PIN_MEM_MFP1,
+	MFP_PIN_MEM_MFP2,
+	MFP_PIN_MEM_MFP3,
+	MFP_PIN_MEM_MFP4,
+	MFP_PIN_MEM_MFP5,
+	MFP_PIN_MEM_MFP6,
+	MFP_PIN_MEM_MFP7,
+	MFP_PIN_MEM_MFP8,
+	MFP_PIN_MEM_MFP9,
+	MFP_PIN_MEM_MFP10,
+	MFP_PIN_MEM_MFP11,
+	MFP_PIN_MEM_MFP12,
+	MFP_PIN_MEM_MFP13,
+	MFP_PIN_MEM_MFP14,
+	MFP_PIN_MEM_MFP15,
+	MFP_PIN_MEM_MFP16,
+	MFP_PIN_MEM_MFP17,
+	MFP_PIN_MEM_MFP18,
+	MFP_PIN_MEM_MFP19,
+	MFP_PIN_MEM_MFP20,
+	MFP_PIN_MEM_MFP21,
+	MFP_PIN_MEM_MFP22,
+	MFP_PIN_MEM_MFP23,
+	MFP_PIN_MEM_MFP24,
+	MFP_PIN_MEM_MFP25,
+	MFP_PIN_MEM_MFP26,
+	MFP_PIN_MEM_MFP27,
+	MFP_PIN_MEM_MFP28,
+	MFP_PIN_MEM_MFP29,
+	MFP_PIN_MEM_MFP30,
+	MFP_PIN_MEM_MFP31,
+	MFP_PIN_MEM_MFP32,
+	MFP_PIN_MEM_MFP33,
+	MFP_PIN_MEM_MFP34,
+	MFP_PIN_MEM_MFP35,
+	MFP_PIN_MEM_MFP36,
+	MFP_PIN_MEM_MFP37,
+	MFP_PIN_MEM_MFP38,
+	MFP_PIN_MEM_MFP39,
+
 	MFP_PIN_GPIO255 = 255,
 
 	MFP_PIN_GPIO0_2,
@@ -308,6 +381,9 @@ enum {
 	MFP_PIN_MMC1_CD,
 	MFP_PIN_MMC1_WP,
 
+	/* additional pins on PXA910 */
+	MFP_PIN_VCXOREQ,
+
 	/* additional pins on PXA930 */
 	MFP_PIN_GSIM_UIO,
 	MFP_PIN_GSIM_UCLK,
@@ -323,6 +399,19 @@ enum {
 	MFP_PIN_TWSI4_SDA,
 	MFP_PIN_CLK_REQ,
 
+	/* additional pins on PXA988 */
+	MFP_PIN_ANT_SW4,
+	MFP_PIN_VCXO_OUT,
+	MFP_PIN_VCXO_REQ,
+
+#ifdef CONFIG_SEC_GPIO_DVS
+	MFP_PIN_PRI_TDI,
+	MFP_PIN_PRI_TMS,
+	MFP_PIN_PRI_TCK,
+	MFP_PIN_PRI_TDO,
+	MFP_PIN_SLAVE_RESET_OUT,
+#endif
+
 	MFP_PIN_MAX,
 };
 
@@ -423,6 +512,10 @@ typedef unsigned long mfp_cfg_t;
 	((MFP_CFG_DEFAULT & ~(MFP_AF_MASK | MFP_DS_MASK | MFP_LPM_STATE_MASK)) |\
 	 (MFP_PIN(MFP_PIN_##pin) | MFP_##af | MFP_##drv | MFP_LPM_##lpm))
 
+#define MFP_CFG_ALL(pin, af, drv, lpm, pull)    \
+	((MFP_CFG_DEFAULT & ~(MFP_AF_MASK | MFP_DS_MASK | MFP_LPM_STATE_MASK | MFP_PULL_MASK)) |\
+	 (MFP_PIN(MFP_PIN_##pin) | MFP_##af | MFP_##drv | MFP_LPM_##lpm | MFP_##pull))
+
 #if defined(CONFIG_PXA3xx) || defined(CONFIG_PXA95x) || defined(CONFIG_ARCH_MMP)
 /*
  * each MFP pin will have a MFPR register, since the offset of the
@@ -470,6 +563,7 @@ void mfp_write(int mfp, unsigned long mfpr_val);
 void mfp_config(unsigned long *mfp_cfgs, int num);
 void mfp_config_run(void);
 void mfp_config_lpm(void);
+void mfp_config_edge(int mfp, unsigned long edge);
 #endif /* CONFIG_PXA3xx || CONFIG_PXA95x || CONFIG_ARCH_MMP */
 
 #endif /* __ASM_PLAT_MFP_H */
diff --git a/arch/arm/plat-pxa/include/plat/pm.h b/arch/arm/plat-pxa/include/plat/pm.h
new file mode 100644
index 00000000..4b9a495e
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/pm.h
@@ -0,0 +1,35 @@
+/*
+ * Power Management Routines
+ *
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+ *
+ * (C) Copyright 2011 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#ifndef __PM_H__
+#define __PM_H__
+
+#include <linux/pm_qos.h>
+
+/* MMP2 cpuidle exit latency */
+#define EXIT_LATENCY_CORE_EXTIDLE		1
+#define EXIT_LATENCY_APPS_IDLE			10
+#define EXIT_LATENCY_APPS_SLEEP			20
+#define EXIT_LATENCY_CHIP_SLEEP			100
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define PM_QOS_CONSTRAINT 1
+#elif defined(CONFIG_CPU_MMP3)
+#define PM_QOS_CONSTRAINT PM_QOS_DEFAULT_VALUE
+#define HDMI_FREQ_CONSTRAINT 200
+#else
+#define PM_QOS_CONSTRAINT PM_QOS_DEFAULT_VALUE
+#define HDMI_FREQ_CONSTRAINT PM_QOS_DEFAULT_VALUE
+#endif
+
+static inline void pwr_i2c_conflict_mutex_lock(void) {}
+static inline void pwr_i2c_conflict_mutex_unlock(void) {}
+
+#endif
diff --git a/arch/arm/plat-pxa/include/plat/pxa27x_keypad.h b/arch/arm/plat-pxa/include/plat/pxa27x_keypad.h
index abcc36eb..b8c0ec9d 100644
--- a/arch/arm/plat-pxa/include/plat/pxa27x_keypad.h
+++ b/arch/arm/plat-pxa/include/plat/pxa27x_keypad.h
@@ -44,6 +44,11 @@ struct pxa27x_keypad_platform_data {
 	/* direct keys */
 	int		direct_key_num;
 	unsigned int	direct_key_map[MAX_DIRECT_KEY_NUM];
+	int		direct_wakeup_pad[MAX_DIRECT_KEY_NUM];
+	/* the key output may be low active */
+	int		direct_key_low_active;
+	/* give board a chance to choose the start direct key */
+	unsigned int	direct_key_mask;
 
 	/* rotary encoders 0 */
 	int		enable_rotary0;
diff --git a/arch/arm/plat-pxa/include/plat/pxa3xx_nand.h b/arch/arm/plat-pxa/include/plat/pxa3xx_nand.h
index c42f39f2..9d2c6b39 100644
--- a/arch/arm/plat-pxa/include/plat/pxa3xx_nand.h
+++ b/arch/arm/plat-pxa/include/plat/pxa3xx_nand.h
@@ -31,11 +31,13 @@ struct pxa3xx_nand_cmdset {
 
 struct pxa3xx_nand_flash {
 	char		*name;
-	uint32_t	chip_id;
+	uint16_t	chip_id;
+	uint16_t	ext_id;
 	unsigned int	page_per_block; /* Pages per block (PG_PER_BLK) */
 	unsigned int	page_size;	/* Page size in bytes (PAGE_SZ) */
 	unsigned int	flash_width;	/* Width of Flash memory (DWIDTH_M) */
 	unsigned int	dfc_width;	/* Width of flash controller(DWIDTH_C) */
+	unsigned int	ecc_strength;   /* How strong ecc should be applied */
 	unsigned int	num_blocks;	/* Number of physical blocks in Flash */
 
 	struct pxa3xx_nand_timing *timing;	/* NAND Flash timing */
@@ -60,10 +62,21 @@ struct pxa3xx_nand_platform_data {
 	 * Controller and the Data Flash Controller,  the arbiter
 	 * controls the ownership of the bus
 	 */
-	int	enable_arbiter;
-
+#define ARBI_EN		(1 << 0)
 	/* allow platform code to keep OBM/bootloader defined NFC config */
-	int	keep_config;
+#define CONFIG_KEEP	(1 << 1)
+	/* whether disable dma operation by default */
+#define DMA_DIS		(1 << 2)
+	/* whether current nand controller ip support naked command */
+#define NAKED_CMD	(1 << 3)
+	/*
+	 * for the scenario that smc and nand controller share the dfi bus,
+	 * ensure nand cs don't assert when smc has the bus
+	 */
+#define FORCE_CS	(1 << 4)
+	/* whether use polling mode */
+#define POLLING		(1 << 5)
+	int	attr;
 
 	/* indicate how many chip selects will be used */
 	int	num_cs;
diff --git a/arch/arm/plat-pxa/include/plat/pxa9xx_acipc.h b/arch/arm/plat-pxa/include/plat/pxa9xx_acipc.h
new file mode 100644
index 00000000..6b18a7f4
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/pxa9xx_acipc.h
@@ -0,0 +1,191 @@
+/*
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+
+ * (C) Copyright 2012 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#ifndef _PXA9XX_ACIPC_H_
+#define _PXA9XX_ACIPC_H_
+
+#define API_ALIGNMENT
+
+/* user level ioctl commands for accessing APIs */
+#define ACIPC_SET_EVENT		0
+#define ACIPC_GET_EVENT		1
+#define ACIPC_SEND_DATA		2
+#define ACIPC_READ_DATA		3
+#define ACIPC_BIND_EVENT	4
+#define ACIPC_UNBIND_EVENT	5
+#define ACIPC_GET_BIND_EVENT_ARG	6
+
+#define ACIPC_NUMBER_OF_EVENTS (10)
+#define ACIPC_NUMBER_OF_INTERRUPTS (3)
+#define ACIPC_INT0_EVENTS (0xff)
+
+#define MAX_ACIPC_REACT_TIME 32500 /* 10msec in 3.25MHz clocl cycles */
+
+#if defined(CONFIG_CPU_PXA910) || defined(CONFIG_CPU_PXA988) \
+	|| defined(CONFIG_CPU_PXA1088)
+#define ACIPC_INT1_EVENTS (ACIPC_SHM_PACKET_NOTIFY)
+#define ACIPC_INT2_EVENTS (ACIPC_IPM)
+#endif
+
+#if defined(CONFIG_PXA95x) || defined(CONFIG_PXA93x)
+#define ACIPC_INT1_EVENTS (ACIPC_DDR_260_READY_REQ)
+#define ACIPC_INT2_EVENTS (ACIPC_DDR_READY_REQ)
+#endif
+
+/*
+ * clients callback type
+ * ICAT EXPORTED FUNCTION_TYPEDEF
+ */
+typedef u32(*acipc_rec_event_callback) (u32 events_status);
+typedef u32 acipc_data;
+typedef u32(*ACIPC_RecEventCB) (u32 eventsStatus);
+typedef u32 ACIPC_Data;
+
+enum DDR_mode {
+	DDR_NOREQ = 0,
+	DDR_208MHZ = 0x1,
+	DDR_260MHZ = 0x2,
+};
+
+struct DDR_status {
+	int mode;
+	int needed_modes;
+};
+
+/*
+ * this enum define the event type
+ * ICAT EXPORTED ENUM
+ */
+enum acipc_events {
+	/* pxa930 specific */
+	ACIPC_DDR_RELQ_REQ = 0x00000001,
+	ACIPC_DDR_RELQ_ACK = 0x00000001,
+	ACIPC_DDR_260_RELQ_REQ = 0x00000002,
+	ACIPC_DDR_260_RELQ_ACK = 0x00000002,
+	ACIPC_MSL_SLEEP_ALLOW = 0x00000004,
+	ACIPC_MSL_WAKEUP_ACK = 0x00000008,
+	ACIPC_MSL_WAKEUP_REQ = 0x00000010,
+	ACIPC_DATA_Q_ADRS = 0x00000020,
+	ACIPC_DATA_IND = 0x00000040,
+	ACIPC_SPARE_1 = 0x00000080,
+	ACIPC_DDR_260_READY_REQ = 0x00000100,
+	ACIPC_DDR_260_READY_ACK = 0x00000100,
+	ACIPC_DDR_READY_REQ = 0x00000200,
+	ACIPC_DDR_READY_ACK = 0x00000200,
+
+#if defined(CONFIG_CPU_PXA910)
+	/* pxa910 specific */
+	ACIPC_SPARE = 0x00000000,
+	ACIPC_RINGBUF_TX_STOP = 0x00000001,
+	ACIPC_RINGBUF_TX_RESUME = 0x00000002,
+	ACIPC_PORT_FLOWCONTROL = 0x00000004,
+	ACIPC_SHM_PACKET_NOTIFY = 0x00000100,
+	ACIPC_IPM = 0x00000200,
+#elif defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	/* pxa988 specific */
+	ACIPC_SPARE = 0x00000000,
+	ACIPC_RINGBUF_TX_STOP = 0x00000001,
+	ACIPC_RINGBUF_TX_RESUME = 0x00000002,
+	ACIPC_PORT_FLOWCONTROL = 0x00000004,
+	ACIPC_MODEM_DDR_UPDATE_REQ = 0x00000008,
+	ACIPC_RINGBUF_PSD_TX_STOP = 0x00000010,
+	ACIPC_RINGBUF_PSD_TX_RESUME = 0x00000020,
+	ACIPC_SHM_PSD_PACKET_NOTIFY = 0x00000040,
+	ACIPC_SHM_DIAG_PACKET_NOTIFY = 0x00000080,
+	ACIPC_SHM_PACKET_NOTIFY = 0x00000100,
+	ACIPC_IPM = 0x00000200,
+#endif
+
+#ifdef CONFIG_CPU_PXA978
+	/* pxa978 TD specific */
+	ACIPC_SPARE = 0x00000000,
+	ACIPC_RINGBUF_TX_STOP = 0x00000004,
+	ACIPC_RINGBUF_TX_RESUME = 0x00000008,
+	ACIPC_PORT_FLOWCONTROL = 0x000000010,
+	ACIPC_SHM_PACKET_NOTIFY = 0x00000020,
+	ACIPC_SHM_PEER_SYNC = 0x00000040,
+#endif
+} /* ACIPC_EventsE */ ;
+
+enum acipc_return_code {
+	ACIPC_RC_OK = 0,
+	ACIPC_HISTORICAL_EVENT_OCCUR,
+	ACIPC_EVENT_ALREADY_BIND,
+	ACIPC_RC_FAILURE,
+	ACIPC_RC_API_FAILURE,
+	ACIPC_RC_WRONG_PARAM
+} /* ACIPC_ReturnCodeE */ ;
+
+/*
+ * used by clients when binding a callback to an event
+ * ICAT EXPORTED ENUM
+ */
+enum acipc_callback_mode {
+	/* callback will be called only if the DDR available */
+	ACIPC_CB_NORMAL = 0,
+	/* called always ,even if the DDR is not available */
+	ACIPC_CB_ALWAYS_NO_DDR
+} /* ACIPC_CBModeE */ ;
+
+struct acipc_database_cell {
+	enum acipc_events IIR_bit;
+	enum acipc_callback_mode mode;
+	/*
+	 * add to support multiple events binding
+	 * see ACIPCEventBind for more details
+	 */
+	u32 mask;
+	acipc_rec_event_callback cb;
+};
+
+/* CAT EXPORTED STRUCT */
+struct acipc_database {
+	struct acipc_database_cell event_db[ACIPC_NUMBER_OF_EVENTS];
+	enum acipc_callback_mode driver_mode;
+	u32 int0_events_cnt;
+	/*
+	 * hold status of events that occur
+	 * before the clients bind their callback
+	 */
+	u32 historical_event_status;
+};
+
+#ifdef ACIPC_DEBUG
+#define IPCTRACE(format, args...) \
+	printk(KERN_INFO format, ## args)
+#define	IPC_ENTER()	\
+	printk(KERN_INFO "IPC: ENTER %s\n", __func__)
+#define	IPC_LEAVE()	\
+	printk(KERN_INFO "IPC: LEAVE %s\n", __func__)
+#else
+#define IPCTRACE(s...)	do {} while (0)
+#define	IPC_ENTER()	do {} while (0)
+#define	IPC_LEAVE()	do {} while (0)
+#endif
+
+struct acipc_ioctl_arg {
+	u32 arg;
+	enum acipc_events set_event;
+	enum acipc_callback_mode cb_mode;
+};
+
+/* declared the export APIs for TD telephony */
+#if defined(CONFIG_CPU_PXA910) || defined(CONFIG_CPU_PXA978) || \
+	defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+extern enum acipc_return_code ACIPCEventBind(u32 user_event,
+					     acipc_rec_event_callback cb,
+					     enum acipc_callback_mode cb_mode,
+					     u32 *historical_event_status);
+extern enum acipc_return_code ACIPCEventUnBind(u32 user_event);
+extern enum acipc_return_code ACIPCEventSet(enum acipc_events user_event);
+extern enum acipc_return_code ACIPCDataSend(enum acipc_events user_event,
+					    acipc_data data);
+extern enum acipc_return_code ACIPCDataRead(acipc_data *data);
+#endif
+
+#endif	/* _PXA9XX_ACIPC_H_ */
diff --git a/arch/arm/plat-pxa/include/plat/pxa_trace.h b/arch/arm/plat-pxa/include/plat/pxa_trace.h
new file mode 100644
index 00000000..f2cf8003
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/pxa_trace.h
@@ -0,0 +1,424 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM pxa_trace
+
+#if !defined(_TRACE_PXA_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_PXA_TRACE_H
+
+#include <linux/tracepoint.h>
+
+#define LPM_ENTRY(index)	((index << 16) | 0)
+#define LPM_EXIT(index)		((index << 16) | 1)
+
+#define CLK_CHG_ENTRY	1
+#define CLK_CHG_EXIT	2
+
+#define CLK_ENABLE	1
+#define CLK_DISABLE	2
+
+#define HOTPLUG_ENTRY	1
+#define HOTPLUG_EXIT	2
+
+
+TRACE_EVENT(pxa_cpu_idle,
+	TP_PROTO(u32 state, u32 cpu_id),
+
+	TP_ARGS(state, cpu_id),
+
+	TP_STRUCT__entry(
+		__field(u32, state)
+		__field(u32, cpu_id)
+	),
+
+	TP_fast_assign(
+		__entry->state = state;
+		__entry->cpu_id = cpu_id;
+	),
+
+	TP_printk("state: 0x%x cpu_id: %u", __entry->state, __entry->cpu_id)
+);
+
+TRACE_EVENT(pxa_core_clk_chg,
+	TP_PROTO(u32 state, u32 val1, u32 val2),
+
+	TP_ARGS(state, val1, val2),
+
+	TP_STRUCT__entry(
+		__field(u32, state)
+		__field(u32, val1)
+		__field(u32, val2)
+	),
+
+	TP_fast_assign(
+		__entry->state = state;
+		__entry->val1 = val1;
+		__entry->val2 = val2;
+	),
+
+	TP_printk("state: %u freq: %u -> %u",
+		__entry->state, __entry->val1, __entry->val2)
+);
+
+TRACE_EVENT(pxa_ddraxi_clk_chg,
+	TP_PROTO(u32 state, u32 val1, u32 val2),
+
+	TP_ARGS(state, val1, val2),
+
+	TP_STRUCT__entry(
+		__field(u32, state)
+		__field(u32, val1)
+		__field(u32, val2)
+	),
+
+	TP_fast_assign(
+		__entry->state = state;
+		__entry->val1 = val1;
+		__entry->val2 = val2;
+	),
+
+	TP_printk("state: %u freq: %u -> %u",
+		__entry->state, __entry->val1, __entry->val2)
+);
+
+TRACE_EVENT(pxa_gc_clk,
+	TP_PROTO(u32 state, u32 val),
+
+	TP_ARGS(state, val),
+
+	TP_STRUCT__entry(
+		__field(u32, state)
+		__field(u32, val)
+	),
+
+	TP_fast_assign(
+		__entry->state = state;
+		__entry->val = val;
+	),
+
+	TP_printk("state: %u clk: 0x%x", __entry->state, __entry->val)
+);
+
+TRACE_EVENT(pxa_gc_clk_chg,
+	TP_PROTO(u32 val1, u32 val2),
+
+	TP_ARGS(val1, val2),
+
+	TP_STRUCT__entry(
+		__field(u32, val1)
+		__field(u32, val2)
+	),
+
+	TP_fast_assign(
+		__entry->val1 = val1;
+		__entry->val2 = val2;
+	),
+
+	TP_printk("freq: %u -> %u", __entry->val1, __entry->val2)
+);
+
+TRACE_EVENT(pxa_gc2d_clk,
+	TP_PROTO(u32 state, u32 val),
+
+	TP_ARGS(state, val),
+
+	TP_STRUCT__entry(
+		__field(u32, state)
+		__field(u32, val)
+	),
+
+	TP_fast_assign(
+		__entry->state = state;
+		__entry->val = val;
+	),
+
+	TP_printk("state: %u clk: 0x%x", __entry->state, __entry->val)
+);
+
+TRACE_EVENT(pxa_gc2d_clk_chg,
+	TP_PROTO(u32 val1, u32 val2),
+
+	TP_ARGS(val1, val2),
+
+	TP_STRUCT__entry(
+		__field(u32, val1)
+		__field(u32, val2)
+	),
+
+	TP_fast_assign(
+		__entry->val1 = val1;
+		__entry->val2 = val2;
+	),
+
+	TP_printk("freq: %u -> %u", __entry->val1, __entry->val2)
+);
+
+TRACE_EVENT(pxa_vpu_clk,
+	TP_PROTO(u32 state, u32 val),
+
+	TP_ARGS(state, val),
+
+	TP_STRUCT__entry(
+		__field(u32, state)
+		__field(u32, val)
+	),
+
+	TP_fast_assign(
+		__entry->state = state;
+		__entry->val = val;
+	),
+
+	TP_printk("state: %u clk: 0x%x", __entry->state, __entry->val)
+);
+
+TRACE_EVENT(pxa_vpu_clk_chg,
+	TP_PROTO(u32 val1, u32 val2),
+
+	TP_ARGS(val1, val2),
+
+	TP_STRUCT__entry(
+		__field(u32, val1)
+		__field(u32, val2)
+	),
+
+	TP_fast_assign(
+		__entry->val1 = val1;
+		__entry->val2 = val2;
+	),
+
+	TP_printk("freq: %u -> %u", __entry->val1, __entry->val2)
+);
+
+TRACE_EVENT(pxa_pll_vco_enable,
+	TP_PROTO(u32 num, u32 val1, u32 val2),
+
+	TP_ARGS(num, val1, val2),
+
+	TP_STRUCT__entry(
+		__field(u32, num)
+		__field(u32, val1)
+		__field(u32, val2)
+	),
+
+	TP_fast_assign(
+		__entry->num = num;
+		__entry->val1 = val1;
+		__entry->val2 = val2;
+	),
+
+	TP_printk("pll%u, swcr: 0x%x, pllcr: 0x%x",
+		__entry->num, __entry->val1, __entry->val2)
+);
+
+TRACE_EVENT(pxa_pll_vco_disable,
+	TP_PROTO(u32 num),
+
+	TP_ARGS(num),
+
+	TP_STRUCT__entry(
+		__field(u32, num)
+	),
+
+	TP_fast_assign(
+		__entry->num = num;
+	),
+
+	TP_printk("pll%u", __entry->num)
+);
+
+TRACE_EVENT(pxa_isp_dxo_clk,
+	TP_PROTO(u32 state),
+
+	TP_ARGS(state),
+
+	TP_STRUCT__entry(
+		__field(u32, state)
+	),
+
+	TP_fast_assign(
+		__entry->state = state;
+	),
+
+	TP_printk("state: %u", __entry->state)
+);
+
+TRACE_EVENT(pxa_isp_dxo_clk_chg,
+	TP_PROTO(u32 val),
+
+	TP_ARGS(val),
+
+	TP_STRUCT__entry(
+		__field(u32, val)
+	),
+
+	TP_fast_assign(
+		__entry->val = val;
+	),
+
+	TP_printk("freq: %u", __entry->val)
+);
+
+TRACE_EVENT(pxa_set_voltage,
+	TP_PROTO(u32 val0, u32 val1, u32 val2),
+
+	TP_ARGS(val0, val1, val2),
+
+	TP_STRUCT__entry(
+		__field(u32, val0)
+		__field(u32, val1)
+		__field(u32, val2)
+	),
+
+	TP_fast_assign(
+		__entry->val0 = val0;
+		__entry->val1 = val1;
+		__entry->val2 = val2;
+	),
+
+	TP_printk("rail %x set voltage: %umV -> %umV",
+		__entry->val0, __entry->val1, __entry->val2)
+);
+
+TRACE_EVENT(pxa_core_hotplug,
+	TP_PROTO(u32 state, u32 id),
+
+	TP_ARGS(state, id),
+
+	TP_STRUCT__entry(
+		__field(u32, state)
+		__field(u32, id)
+	),
+
+	TP_fast_assign(
+		__entry->state = state;
+		__entry->id = id;
+	),
+
+	TP_printk("state: %u cpu_id: %u", __entry->state, __entry->id)
+);
+
+/* Show id, task number and mips for each online cpus */
+TRACE_EVENT(pxa_hp_single,
+	TP_PROTO(u32 id, u32 task, u32 load, u32 mips),
+
+	TP_ARGS(id, task, load, mips),
+
+	TP_STRUCT__entry(
+		__field(u32, id)
+		__field(u32, task)
+		__field(u32, load)
+		__field(u32, mips)
+	),
+
+	TP_fast_assign(
+		__entry->id = id;
+		__entry->task = task;
+		__entry->load = load;
+		__entry->mips = mips;
+	),
+
+	TP_printk("id:%1u task:%3u load:%3u mips:%6u",
+		  __entry->id, __entry->task, __entry->load, __entry->mips)
+);
+
+/* This trace is for print mips in every hotplug window size */
+TRACE_EVENT(pxa_hotplug_stand_mips,
+	TP_PROTO(u32 cur_freq, u32 mips, u32 cpu_num),
+
+	TP_ARGS(cur_freq, mips, cpu_num),
+
+	TP_STRUCT__entry(
+		__field(u32, cur_freq)
+		__field(u32, mips)
+		__field(u32, cpu_num)
+	),
+
+	TP_fast_assign(
+		__entry->cur_freq = cur_freq;
+		__entry->mips = mips;
+		__entry->cpu_num = cpu_num;
+	),
+
+	TP_printk("cur_freq:%4uMHz mips:%6u cpu_num:%1u",
+		  __entry->cur_freq, __entry->mips, __entry->cpu_num)
+);
+
+
+TRACE_EVENT(pxa_ddr_workload,
+	TP_PROTO(u32 workload, u32 freq, s32 throughput),
+
+	TP_ARGS(workload, freq, throughput),
+
+	TP_STRUCT__entry(
+		__field(u32, workload)
+		__field(u32, freq)
+		__field(s32, throughput)
+	),
+
+	TP_fast_assign(
+		__entry->workload = workload;
+		__entry->freq = freq;
+		__entry->throughput = throughput;
+	),
+
+	TP_printk("workload: %u freq: %u throughput: %u", __entry->workload,
+					__entry->freq,  __entry->throughput)
+);
+
+TRACE_EVENT(pxa_ddr_upthreshold,
+	TP_PROTO(u32 upthreshold),
+
+	TP_ARGS(upthreshold),
+
+	TP_STRUCT__entry(
+		__field(u32, upthreshold)
+	),
+
+	TP_fast_assign(
+		__entry->upthreshold = upthreshold;
+	),
+
+	TP_printk("ddr devfreq upthreshold: %u", __entry->upthreshold)
+);
+
+TRACE_EVENT(pxa_ddr_lpm,
+	TP_PROTO(u32 value),
+
+	TP_ARGS(value),
+
+	TP_STRUCT__entry(
+		__field(u32, value)
+	),
+
+	TP_fast_assign(
+		__entry->value = value;
+	),
+
+	TP_printk("dll val: 0x%x", __entry->value)
+);
+
+TRACE_EVENT(pxa_ddr_lpm_tbl_update,
+	TP_PROTO(u32 value),
+
+	TP_ARGS(value),
+
+	TP_STRUCT__entry(
+		__field(u32, value)
+	),
+
+	TP_fast_assign(
+		__entry->value = value;
+	),
+
+	TP_printk("lpm_tbl: 0x%x", __entry->value)
+);
+
+/* This file can get included multiple times, TRACE_HEADER_MULTI_READ at top */
+
+#endif /* _TRACE_PXA_TRACE_H */
+
+#undef TRACE_INCLUDE_PATH
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_PATH plat
+
+#define TRACE_INCLUDE_FILE pxa_trace
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/arch/arm/plat-pxa/mfp.c b/arch/arm/plat-pxa/mfp.c
index 2c4dbb1f..5b78f605 100644
--- a/arch/arm/plat-pxa/mfp.c
+++ b/arch/arm/plat-pxa/mfp.c
@@ -18,25 +18,43 @@
 #include <linux/init.h>
 #include <linux/io.h>
 
+#ifdef CONFIG_ARCH_MMP
+#include <mach/cputype.h>
+#elif defined(CONFIG_ARCH_PXA)
+#include <mach/hardware.h>
+#endif
+
 #include <plat/mfp.h>
 
+#ifdef CONFIG_SEC_GPIO_DVS
+#include <linux/secgpio_dvs.h>
+#include <linux/platform_device.h>
+#include <linux/gpio-pxa.h>
+#include <asm/gpio.h>
+#endif
+
 #define MFPR_SIZE	(PAGE_SIZE)
 
 /* MFPR register bit definitions */
 #define MFPR_PULL_SEL		(0x1 << 15)
 #define MFPR_PULLUP_EN		(0x1 << 14)
 #define MFPR_PULLDOWN_EN	(0x1 << 13)
+#if !defined(CONFIG_CPU_PXA988) && !defined(CONFIG_CPU_PXA1088)
 #define MFPR_SLEEP_SEL		(0x1 << 9)
+#else
+#define MFPR_SLEEP_SEL		((0x1 << 9) | (0x1 << 3))
+#endif
 #define MFPR_SLEEP_OE_N		(0x1 << 7)
 #define MFPR_EDGE_CLEAR		(0x1 << 6)
 #define MFPR_EDGE_FALL_EN	(0x1 << 5)
 #define MFPR_EDGE_RISE_EN	(0x1 << 4)
+#define MFPR_EDGE_MASK		(0x7 << 4)
 
-#define MFPR_SLEEP_DATA(x)	((x) << 8)
+#define MFPR_SLEEP_DATA(x)	(((x) & 0x1) << 8)
 #define MFPR_DRIVE(x)		(((x) & 0x7) << 10)
 #define MFPR_AF_SEL(x)		(((x) & 0x7) << 0)
 
-#define MFPR_EDGE_NONE		(0)
+#define MFPR_EDGE_NONE		(MFPR_EDGE_CLEAR)
 #define MFPR_EDGE_RISE		(MFPR_EDGE_RISE_EN)
 #define MFPR_EDGE_FALL		(MFPR_EDGE_FALL_EN)
 #define MFPR_EDGE_BOTH		(MFPR_EDGE_RISE | MFPR_EDGE_FALL)
@@ -57,13 +75,33 @@
  * Pull lo (0)      1          X(0)        0           1	  0
  * Z (float)        1          X(0)        0           0	  0
  */
+#if !defined(CONFIG_CPU_PXA988) && !defined(CONFIG_CPU_PXA1088)
 #define MFPR_LPM_INPUT		(0)
+#define MFPR_LPM_NONE		MFPR_LPM_INPUT
 #define MFPR_LPM_DRIVE_LOW	(MFPR_SLEEP_DATA(0) | MFPR_PULLDOWN_EN)
 #define MFPR_LPM_DRIVE_HIGH    	(MFPR_SLEEP_DATA(1) | MFPR_PULLUP_EN)
 #define MFPR_LPM_PULL_LOW      	(MFPR_LPM_DRIVE_LOW  | MFPR_SLEEP_OE_N)
 #define MFPR_LPM_PULL_HIGH     	(MFPR_LPM_DRIVE_HIGH | MFPR_SLEEP_OE_N)
 #define MFPR_LPM_FLOAT         	(MFPR_SLEEP_OE_N)
 #define MFPR_LPM_MASK		(0xe080)
+#else /* CONFIG_CPU_PXA988 */
+/*
+ * Output value sleep_oe_n sleep_data sleep_sel
+ *               (bit 7)    (bit 8)   (bit 9/3)
+ * None            X(0)       X(0)      00
+ * Drive 0         0          0         11
+ * Drive 1         0          1         11
+ * Z (float)       1          X(0)      11
+ */
+#define MFPR_LPM_NONE		0
+#define MFPR_LPM_DRIVE_LOW	(MFPR_SLEEP_SEL | MFPR_SLEEP_DATA(0))
+#define MFPR_LPM_DRIVE_HIGH	(MFPR_SLEEP_SEL | MFPR_SLEEP_DATA(1))
+#define MFPR_LPM_PULL_LOW	0 /* Not supported */
+#define MFPR_LPM_PULL_HIGH	0 /* Not supported */
+#define MFPR_LPM_FLOAT		(MFPR_SLEEP_SEL | MFPR_SLEEP_OE_N)
+#define MFPR_LPM_INPUT		MFPR_LPM_FLOAT
+#define MFPR_LPM_MASK		(0x0388)
+#endif /* CONFIG_CPU_PXA988 */
 
 /*
  * The pullup and pulldown state of the MFP pin at run mode is by default
@@ -103,7 +141,7 @@ static struct mfp_pin mfp_table[MFP_PIN_MAX];
 
 /* mapping of MFP_LPM_* definitions to MFPR_LPM_* register bits */
 static const unsigned long mfpr_lpm[] = {
-	MFPR_LPM_INPUT,
+	MFPR_LPM_NONE,
 	MFPR_LPM_DRIVE_LOW,
 	MFPR_LPM_DRIVE_HIGH,
 	MFPR_LPM_PULL_LOW,
@@ -164,8 +202,18 @@ static inline void __mfp_config_lpm(struct mfp_pin *p)
 void mfp_config(unsigned long *mfp_cfgs, int num)
 {
 	unsigned long flags;
-	int i;
-
+	int i, drv_b11 = 0, no_lpm = 0;
+
+#ifdef CONFIG_ARCH_MMP
+	if (cpu_is_pxa910() || cpu_is_pxa988() || cpu_is_pxa986() ||
+		cpu_is_mmp2() || cpu_is_mmp3() || cpu_is_pxa1088())
+		drv_b11 = 1;
+	if (cpu_is_pxa168() || cpu_is_pxa910())
+		no_lpm = 1;
+#elif defined(CONFIG_ARCH_PXA)
+	if (cpu_is_pxa95x())
+		drv_b11 = 1;
+#endif
 	spin_lock_irqsave(&mfp_spin_lock, flags);
 
 	for (i = 0; i < num; i++, mfp_cfgs++) {
@@ -182,20 +230,15 @@ void mfp_config(unsigned long *mfp_cfgs, int num)
 		lpm = MFP_LPM_STATE(c);
 		edge = MFP_LPM_EDGE(c);
 		pull = MFP_PULL(c);
+		if (drv_b11)
+			drv = drv << 1;
+		if (no_lpm)
+			lpm = 0;
 
-		/* run-mode pull settings will conflict with MFPR bits of
-		 * low power mode state,  calculate mfpr_run and mfpr_lpm
-		 * individually if pull != MFP_PULL_NONE
-		 */
 		tmp = MFPR_AF_SEL(af) | MFPR_DRIVE(drv);
-
-		if (likely(pull == MFP_PULL_NONE)) {
-			p->mfpr_run = tmp | mfpr_lpm[lpm] | mfpr_edge[edge];
-			p->mfpr_lpm = p->mfpr_run;
-		} else {
-			p->mfpr_lpm = tmp | mfpr_lpm[lpm] | mfpr_edge[edge];
-			p->mfpr_run = tmp | mfpr_pull[pull];
-		}
+		tmp |= mfpr_pull[pull] | mfpr_lpm[lpm] | mfpr_edge[edge];
+		p->mfpr_run = tmp;
+		p->mfpr_lpm = p->mfpr_run;
 
 		p->config = c; __mfp_config_run(p);
 	}
@@ -240,6 +283,254 @@ void __init mfp_init_base(void __iomem *mfpr_base)
 	mfpr_mmio_base = mfpr_base;
 }
 
+#ifdef CONFIG_SEC_GPIO_DVS
+struct dvs_mfpr_offset {
+	unsigned long offset;
+	int gpio;
+	int func;
+};
+static struct dvs_mfpr_offset dvs_offset[] = {
+	{MFP_PIN(MFP_PIN_GPIO0), 0, 0},
+	{MFP_PIN(MFP_PIN_GPIO1), 1, 0},
+	{MFP_PIN(MFP_PIN_GPIO2), 2, 0},
+	{MFP_PIN(MFP_PIN_GPIO3), 3, 0},
+	{MFP_PIN(MFP_PIN_GPIO4), 4, 0},
+	{MFP_PIN(MFP_PIN_GPIO5), 5, 0},
+	{MFP_PIN(MFP_PIN_GPIO6), 6, 0},
+	{MFP_PIN(MFP_PIN_GPIO7), 7, 0},
+	{MFP_PIN(MFP_PIN_GPIO8), 8, 0},
+	{MFP_PIN(MFP_PIN_GPIO9), 9, 0},
+	{MFP_PIN(MFP_PIN_GPIO10), 10, 0},
+	{MFP_PIN(MFP_PIN_GPIO11), 11, 0},
+	{MFP_PIN(MFP_PIN_GPIO12), 12, 0},
+	{MFP_PIN(MFP_PIN_GPIO13), 13, 0},
+	{MFP_PIN(MFP_PIN_GPIO14), 14, 0},
+	{MFP_PIN(MFP_PIN_GPIO15), 15, 0},
+	{MFP_PIN(MFP_PIN_GPIO16), 16, 0},
+	{MFP_PIN(MFP_PIN_GPIO17), 17, 0},
+	{MFP_PIN(MFP_PIN_GPIO18), 18, 0},
+	{MFP_PIN(MFP_PIN_GPIO19), 19, 0},
+	{MFP_PIN(MFP_PIN_GPIO20), 20, 0},
+	{MFP_PIN(MFP_PIN_GPIO21), 21, 0},
+	{MFP_PIN(MFP_PIN_GPIO22), 22, 0},
+	{MFP_PIN(MFP_PIN_GPIO23), 23, 0},
+	{MFP_PIN(MFP_PIN_GPIO24), 24, 0},
+	{MFP_PIN(MFP_PIN_GPIO25), 25, 0},
+	{MFP_PIN(MFP_PIN_GPIO26), 26, 0},
+	{MFP_PIN(MFP_PIN_GPIO27), 27, 0},
+	{MFP_PIN(MFP_PIN_GPIO28), 28, 0},
+	{MFP_PIN(MFP_PIN_GPIO29), 29, 0},
+	{MFP_PIN(MFP_PIN_GPIO30), 30, 0},
+	{MFP_PIN(MFP_PIN_GPIO31), 31, 0},
+	{MFP_PIN(MFP_PIN_GPIO32), 32, 0},
+	{MFP_PIN(MFP_PIN_GPIO33), 33, 0},
+	{MFP_PIN(MFP_PIN_GPIO34), 34, 0},
+	{MFP_PIN(MFP_PIN_GPIO35), 35, 0},
+	{MFP_PIN(MFP_PIN_GPIO36), 36, 0},
+	{MFP_PIN(MFP_PIN_GPIO37), 37, 0},
+	{MFP_PIN(MFP_PIN_GPIO38), 38, 0},
+	{MFP_PIN(MFP_PIN_GPIO39), 39, 0},
+	{MFP_PIN(MFP_PIN_GPIO40), 40, 0},
+	{MFP_PIN(MFP_PIN_GPIO41), 41, 0},
+	{MFP_PIN(MFP_PIN_GPIO42), 42, 0},
+	{MFP_PIN(MFP_PIN_GPIO43), 43, 0},
+	{MFP_PIN(MFP_PIN_GPIO44), 44, 0},
+	{MFP_PIN(MFP_PIN_GPIO45), 45, 0},
+	{MFP_PIN(MFP_PIN_GPIO46), 46, 0},
+	{MFP_PIN(MFP_PIN_GPIO47), 47, 0},
+	{MFP_PIN(MFP_PIN_GPIO48), 48, 0},
+	{MFP_PIN(MFP_PIN_GPIO49), 49, 0},
+	{MFP_PIN(MFP_PIN_GPIO50), 50, 0},
+	{MFP_PIN(MFP_PIN_GPIO51), 51, 0},
+	{MFP_PIN(MFP_PIN_GPIO52), 52, 0},
+	{MFP_PIN(MFP_PIN_GPIO53), 53, 0},
+	{MFP_PIN(MFP_PIN_GPIO54), 54, 0},
+	{MFP_PIN(MFP_PIN_DF_IO15), 60, 1},
+	{MFP_PIN(MFP_PIN_DF_IO14), 61, 1},
+	{MFP_PIN(MFP_PIN_DF_IO13), 62, 1},
+	{MFP_PIN(MFP_PIN_DF_IO12), 63, 1},
+	{MFP_PIN(MFP_PIN_DF_IO11), 64, 1},
+	{MFP_PIN(MFP_PIN_DF_IO10), 65, 1},
+	{MFP_PIN(MFP_PIN_DF_IO9), 66, 1},
+	{MFP_PIN(MFP_PIN_GPIO67), 67, 0},
+	{MFP_PIN(MFP_PIN_GPIO68), 68, 0},
+	{MFP_PIN(MFP_PIN_GPIO69), 69, 0},
+	{MFP_PIN(MFP_PIN_GPIO70), 70, 0},
+	{MFP_PIN(MFP_PIN_GPIO71), 71, 0},
+	{MFP_PIN(MFP_PIN_GPIO72), 72, 0},
+	{MFP_PIN(MFP_PIN_GPIO73), 73, 0},
+	{MFP_PIN(MFP_PIN_GPIO74), 74, 0},
+	{MFP_PIN(MFP_PIN_GPIO75), 75, 0},
+	{MFP_PIN(MFP_PIN_GPIO76), 76, 0},
+	{MFP_PIN(MFP_PIN_GPIO77), 77, 0},
+	{MFP_PIN(MFP_PIN_GPIO78), 78, 0},
+	{MFP_PIN(MFP_PIN_GPIO79), 79, 0},
+	{MFP_PIN(MFP_PIN_GPIO80), 80, 0},
+	{MFP_PIN(MFP_PIN_GPIO81), 81, 0},
+	{MFP_PIN(MFP_PIN_GPIO82), 82, 0},
+	{MFP_PIN(MFP_PIN_GPIO83), 83, 0},
+	{MFP_PIN(MFP_PIN_GPIO84), 84, 0},
+	{MFP_PIN(MFP_PIN_GPIO85), 85, 0},
+	{MFP_PIN(MFP_PIN_GPIO86), 86, 0},
+	{MFP_PIN(MFP_PIN_GPIO87), 87, 0},
+	{MFP_PIN(MFP_PIN_GPIO88), 88, 0},
+	{MFP_PIN(MFP_PIN_GPIO89), 89, 0},
+	{MFP_PIN(MFP_PIN_GPIO90), 90, 0},
+	{MFP_PIN(MFP_PIN_GPIO91), 91, 0},
+	{MFP_PIN(MFP_PIN_GPIO92), 92, 0},
+	{MFP_PIN(MFP_PIN_GPIO93), 93, 0},
+	{MFP_PIN(MFP_PIN_GPIO94), 94, 0},
+	{MFP_PIN(MFP_PIN_GPIO95), 95, 0},
+	{MFP_PIN(MFP_PIN_GPIO96), 96, 0},
+	{MFP_PIN(MFP_PIN_GPIO97), 97, 0},
+	{MFP_PIN(MFP_PIN_GPIO98), 98, 0},
+	{MFP_PIN(MFP_PIN_MMC1_WP), 99, 1},
+	{MFP_PIN(MFP_PIN_DF_IO8), 100, 1},
+	{MFP_PIN(MFP_PIN_DF_nCS0_SM_nCS2), 101, 1},
+	{MFP_PIN(MFP_PIN_DF_nCS1_SM_nCS3), 102, 1},
+	{MFP_PIN(MFP_PIN_SM_nCS0), 103, 1},
+	{MFP_PIN(MFP_PIN_SM_nCS1), 104, 1},
+	{MFP_PIN(MFP_PIN_DF_WEn), 105, 0},
+	{MFP_PIN(MFP_PIN_DF_REn), 106, 0},
+	{MFP_PIN(MFP_PIN_DF_ALE_SM_WEn), 107, 0},
+	{MFP_PIN(MFP_PIN_DF_RDY0), 108, 1},
+	{MFP_PIN(MFP_PIN_PRI_TDI), 117, 1},
+	{MFP_PIN(MFP_PIN_PRI_TMS), 118, 1},
+	{MFP_PIN(MFP_PIN_PRI_TCK), 119, 1},
+	{MFP_PIN(MFP_PIN_PRI_TDO), 120, 1},
+	{MFP_PIN(MFP_PIN_SLAVE_RESET_OUT), 122, 1},
+	{MFP_PIN(MFP_PIN_CLK_REQ), 123, 1},
+	{MFP_PIN(MFP_PIN_GPIO124), 124, 0},
+	{MFP_PIN(MFP_PIN_VCXOREQ), 125, 1},
+	{MFP_PIN(MFP_PIN_SM_BE0), 126, 0},
+	{MFP_PIN(MFP_PIN_SM_BE1), 127, 0},
+};
+
+/****************************************************************/
+/* Define value in accordance with
+	the specification of each BB vendor. */
+#define AP_GPIO_COUNT	MFP_PIN_MAX
+/****************************************************************/
+
+#define GET_RESULT_GPIO(a, b, c)	\
+	((a<<4 & 0xF0) | (b<<1 & 0xE) | (c & 0x1))
+
+/****************************************************************/
+/* Pre-defined variables. (DO NOT CHANGE THIS!!) */
+static unsigned char checkgpiomap_result[GDVS_PHONE_STATUS_MAX][AP_GPIO_COUNT];
+static struct gpiomap_result gpiomap_result = {
+	.init = checkgpiomap_result[PHONE_INIT],
+	.sleep = checkgpiomap_result[PHONE_SLEEP]
+};
+/****************************************************************/
+
+static unsigned __check_init_direction(int gpio)
+{
+	int index = gpio / 32;
+	int offset = gpio % 32;
+	unsigned int gpdr[4];
+
+	pxa_direction_get(gpdr);
+
+	return (gpdr[index] & (0x1 << offset)) > 0 ? 2 : 1;
+}
+
+static unsigned __check_mfp_direction(unsigned mfpr_val, int func)
+{
+	u32 ret = 0;
+	if (MFPR_AF_SEL(mfpr_val) != func) ret = 0x0; /* FUNC */
+	else {
+		if (mfpr_val & MFPR_SLEEP_OE_N) ret = 0x01; /* INPUT */
+		else ret = 0x2; /*OUTPUT */
+	}
+	return ret;
+}
+
+static unsigned __check_mfp_pull_status(unsigned mfpr_val)
+{
+	u32 ret = 0;
+	if (mfpr_val & MFPR_PULL_SEL) {
+		if (mfpr_val & MFPR_PULLUP_EN) ret = 0x2; /* PULL_UP */
+		else if (mfpr_val & MFPR_PULLDOWN_EN) ret = 0x01; /* PULL_DOWN */
+		else ret = 0x0; /* NO_PULL */
+	} else
+		ret = 0x0; /* NO_PULL */
+	return ret;
+}
+
+static unsigned __check_mfp_data_status(unsigned mfpr_val, int gpio, unsigned dir)
+{
+	u32 ret = 0;
+
+	switch (dir) {
+		case 0:
+			ret = 0x0; /* FUNC */
+			break;
+		case 1:
+			ret = gpio_get_value(gpio);
+			break;
+		case 2:
+			if (mfpr_val & (0x1 << 8)) ret = 0x1; /* HIGH */
+			else ret = 0x0; /* LOW */
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+static void pxa_check_mfp_configuration(unsigned char phonestate)
+{
+	u8 temp_io = 0, temp_pdpu = 0, temp_lh = 0;
+	int i;
+
+	pr_info("[secgpio_dvs][%s] state : %s\n", __func__,
+		(phonestate == PHONE_INIT) ? "init" : "sleep");
+
+	for (i = 0; i < ARRAY_SIZE(dvs_offset); i++) {
+		unsigned long mfpr_val, offset;
+		int gpio, sleep_mode;
+
+		offset = dvs_offset[i].offset;
+		gpio = dvs_offset[i].gpio;
+		mfpr_val = mfp_read(offset);
+		sleep_mode = mfpr_val & ((0x1 << 9) | (0x1 << 3));
+
+		if ((phonestate == PHONE_INIT) || (sleep_mode == 0)) {
+			temp_io = __check_mfp_direction(mfpr_val, dvs_offset[i].func);
+			if (temp_io == 0) {
+				temp_lh = 0;
+			} else {
+				temp_io = __check_init_direction(gpio);
+				temp_lh = gpio_get_value(gpio);
+			}
+		} else {
+			temp_io = __check_mfp_direction(mfpr_val, dvs_offset[i].func);
+			temp_lh = __check_mfp_data_status(mfpr_val, gpio, temp_io);
+		}
+		temp_pdpu = __check_mfp_pull_status(mfpr_val);
+
+		checkgpiomap_result[phonestate][i] =
+			GET_RESULT_GPIO(temp_io, temp_pdpu, temp_lh);
+	}
+
+	pr_info("[secgpio_dvs][%s]-\n", __func__);
+
+	return;
+}
+
+/****************************************************************/
+/* Define appropriate variable in accordance with
+	the specification of each BB vendor */
+static struct gpio_dvs pxa_gpio_dvs = {
+	.result = &gpiomap_result,
+	.check_gpio_status = pxa_check_mfp_configuration,
+	.count = AP_GPIO_COUNT,
+};
+/****************************************************************/
+#endif
+
 void __init mfp_init_addr(struct mfp_addr_map *map)
 {
 	struct mfp_addr_map *p;
@@ -248,6 +539,10 @@ void __init mfp_init_addr(struct mfp_addr_map *map)
 
 	spin_lock_irqsave(&mfp_spin_lock, flags);
 
+#ifdef CONFIG_SEC_GPIO_DVS
+	pxa_gpio_dvs.count = ARRAY_SIZE(dvs_offset);
+#endif
+
 	/* mfp offset for readback */
 	mfpr_off_readback = map[0].offset;
 
@@ -271,6 +566,10 @@ void mfp_config_lpm(void)
 	struct mfp_pin *p = &mfp_table[0];
 	int pin;
 
+#ifdef CONFIG_ARCH_MMP
+	if (cpu_is_pxa168() || cpu_is_pxa910())
+		return;
+#endif
 	for (pin = 0; pin < ARRAY_SIZE(mfp_table); pin++, p++)
 		__mfp_config_lpm(p);
 }
@@ -283,3 +582,35 @@ void mfp_config_run(void)
 	for (pin = 0; pin < ARRAY_SIZE(mfp_table); pin++, p++)
 		__mfp_config_run(p);
 }
+
+void mfp_config_edge(int mfp, unsigned long val)
+{
+	mfp_cfg_t m;
+	m = mfp_read(mfp);
+	m &= ~(MFPR_EDGE_MASK);
+	m |= mfpr_edge[MFP_LPM_EDGE(val)];
+	mfp_write(mfp, m);
+}
+
+#ifdef CONFIG_SEC_GPIO_DVS
+static struct platform_device secgpio_dvs_device = {
+	.name	= "secgpio_dvs",
+	.id		= -1,
+/****************************************************************/
+/* Designate appropriate variable pointer
+	in accordance with the specification of each BB vendor. */
+	.dev.platform_data = &pxa_gpio_dvs,
+/****************************************************************/
+};
+
+static struct platform_device *secgpio_dvs_devices[] __initdata = {
+	&secgpio_dvs_device,
+};
+
+static int __init secgpio_dvs_device_init(void)
+{
+	return platform_add_devices(
+		secgpio_dvs_devices, ARRAY_SIZE(secgpio_dvs_devices));
+}
+arch_initcall(secgpio_dvs_device_init);
+#endif
diff --git a/arch/arm/plat-pxa/panic.c b/arch/arm/plat-pxa/panic.c
new file mode 100644
index 00000000..1bc9a9ff
--- /dev/null
+++ b/arch/arm/plat-pxa/panic.c
@@ -0,0 +1,169 @@
+/*
+ *  Do flush operation when panic to save those stuff still in cache to mem
+ *
+ *  Copyright (C) 2012 Marvell International Ltd.
+ *  Lei Wen <leiwen@marvell.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  publishhed by the Free Software Foundation.
+ */
+
+#include <linux/reboot.h>
+#include <linux/kexec.h>
+#include <linux/kdebug.h>
+#include <linux/kobject.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <asm/cacheflush.h>
+#include <asm/setup.h>
+
+#include <mach/regs-coresight.h>
+#include <mach/cputype.h>
+#include <linux/regdump_ops.h>
+
+static void *indicator;
+static DEFINE_RAW_SPINLOCK(panic_lock);
+extern void arm_machine_flush_console(void);
+extern void (*arm_pm_restart)(char str, const char *cmd);
+#define PANIC_TIMER_STEP 100
+
+extern int sec_crash_key_panic;
+extern int sec_debug_panic_dump(char *);
+extern int i2c_set_pio_mode(void);
+
+void panic_flush(struct pt_regs *regs)
+{
+	struct pt_regs fixed_regs;
+	int i;
+
+	hardlockup_enable = 0;
+	raw_spin_lock(&panic_lock);
+
+	for (i = 0; i < nr_cpu_ids; i++)
+		coresight_dump_pcsr(i);
+
+	if (cpu_is_pxa1088())
+		dump_reg_to_console();
+
+	printk(KERN_EMERG "EMMD: ready to perform memory dump\n");
+
+#ifndef CONFIG_SEC_DEBUG
+	memset(indicator, 0 ,PAGE_SIZE);
+	*(unsigned long *)indicator = 0x454d4d44;
+#endif
+
+	crash_setup_regs(&fixed_regs, regs);
+	crash_save_vmcoreinfo();
+	machine_crash_shutdown(&fixed_regs);
+
+#ifdef CONFIG_SEC_DEBUG
+	if (sec_crash_key_panic) {
+		sec_debug_panic_dump("Crash Key");
+	} else {
+		sec_debug_panic_dump("");
+	}
+#endif
+
+	printk(KERN_EMERG "EMMD: done\n");
+	arm_machine_flush_console();
+
+	flush_cache_all();
+	outer_flush_all();
+
+	if (panic_timeout > 0) {
+		/*
+		 * Delay timeout seconds before rebooting the machine.
+		 * We can't use the "normal" timers since we just panicked.
+		 */
+		printk(KERN_EMERG "Rebooting in %d seconds..", panic_timeout);
+
+		for (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP)
+			mdelay(PANIC_TIMER_STEP);
+	}
+
+	printk(KERN_EMERG "EMMD: update mm done\n");
+	if (panic_timeout != 0) {
+		i2c_set_pio_mode();
+		/*
+		 * This will not be a clean reboot, with everything
+		 * shutting down.  But if there is a chance of
+		 * rebooting the system it will be rebooted.
+		 */
+		arm_pm_restart(0, NULL);
+	}
+
+	raw_spin_unlock(&panic_lock);
+	while (1)
+		cpu_relax();
+}
+
+static int dump_reg_handler(struct notifier_block *self,
+			     unsigned long val,
+			     void *data)
+{
+	struct die_args *args = data;
+
+	crash_update(args->regs);
+	return 0;
+}
+
+static struct notifier_block die_dump_reg_notifier = {
+	.notifier_call = dump_reg_handler,
+	.priority = 200
+};
+
+#if (defined CONFIG_PM)
+static ssize_t panic_store(struct kobject *kobj, struct kobj_attribute *attr,
+			   const char *buf, size_t len)
+{
+	char _buf[80];
+
+	if (strncmp(buf, "PID", 3) == 0) {
+		snprintf(_buf, 80, "\nUser Space Panic:%s", buf);
+		panic(_buf);
+		goto OUT;
+	}
+
+	printk(KERN_WARNING "Not valid value!!!\n");
+OUT:
+	return len;
+}
+
+static struct kobj_attribute panic_attr = {
+	.attr	= {
+		.name = __stringify(panic),
+		.mode = 0644,
+	},
+	.store	= panic_store,
+};
+
+static struct attribute * g[] = {
+	&panic_attr.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = g,
+};
+
+#endif /* CONFIG_PM */
+
+static int __init pxa_panic_notifier(void)
+{
+	struct page *page;
+#if (defined CONFIG_PM)
+	if (sysfs_create_group(power_kobj, &attr_group))
+		return -1;
+#endif
+
+#ifndef CONFIG_SEC_DEBUG
+	page = pfn_to_page(crashk_res.end >> PAGE_SHIFT);
+	indicator = page_address(page);
+#endif
+
+	panic_on_oops = 1;
+	return 0;
+}
+
+core_initcall_sync(pxa_panic_notifier);
diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index 58b79809..a504c4a6 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -193,6 +193,9 @@ static const struct platform_device_id ssp_id_table[] = {
 	{ "pxa25x-nssp",	PXA25x_NSSP },
 	{ "pxa27x-ssp",		PXA27x_SSP },
 	{ "pxa168-ssp",		PXA168_SSP },
+	{ "pxa910-ssp",		PXA910_SSP },
+	{ "pxa988-ssp",		PXA988_SSP },
+	{ "eden-ssp",		EDEN_SSP },
 	{ },
 };
 
diff --git a/arch/arm/plat-pxa/usb.c b/arch/arm/plat-pxa/usb.c
new file mode 100644
index 00000000..0a9c4ef6
--- /dev/null
+++ b/arch/arm/plat-pxa/usb.c
@@ -0,0 +1,83 @@
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/notifier.h>
+#include <linux/platform_data/mv_usb.h>
+
+struct pxa_usb_extern_dev {
+	unsigned int id;
+	struct pxa_usb_extern_ops ops;
+	struct atomic_notifier_head *head;
+};
+
+static struct pxa_usb_extern_dev pxa_usb[PXA_USB_DEV_MAX];
+
+struct pxa_usb_extern_ops *pxa_usb_get_extern_ops(unsigned int id)
+{
+	if (id >= PXA_USB_DEV_MAX)
+		return NULL;
+
+	return &pxa_usb[id].ops;
+}
+
+int pxa_usb_register_notifier(unsigned int id, struct notifier_block *nb)
+{
+	struct pxa_usb_extern_dev *dev;
+	int ret;
+
+	if (id >= PXA_USB_DEV_MAX)
+		return -ENODEV;
+
+	dev = &pxa_usb[id];
+	if (dev->head == NULL) {
+		dev->head = kzalloc(sizeof(*dev->head), GFP_KERNEL);
+		if (dev->head == NULL)
+			return -ENOMEM;
+		ATOMIC_INIT_NOTIFIER_HEAD(dev->head);
+	}
+
+	ret = atomic_notifier_chain_register(dev->head, nb);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+int pxa_usb_unregister_notifier(unsigned int id, struct notifier_block *nb)
+{
+	struct pxa_usb_extern_dev *dev;
+	int ret;
+
+	if (id >= PXA_USB_DEV_MAX)
+		return -ENODEV;
+
+	dev = &pxa_usb[id];
+	if (dev->head == NULL)
+		return -EINVAL;
+
+	ret = atomic_notifier_chain_unregister(dev->head, nb);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+int pxa_usb_notify(unsigned int id, unsigned long val, void *v)
+{
+	struct pxa_usb_extern_dev *dev;
+	int ret;
+
+	if (id >= PXA_USB_DEV_MAX)
+		return -ENODEV;
+
+	dev = &pxa_usb[id];
+	if (dev->head == NULL)
+		return -EINVAL;
+
+	ret = atomic_notifier_call_chain(dev->head, val, v);
+	if (ret)
+		return ret;
+
+	return 0;
+}
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index f9c9f33f..9cb00ac3 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1169,3 +1169,22 @@ elite_ulk		MACH_ELITE_ULK		ELITE_ULK		3888
 pov2			MACH_POV2		POV2			3889
 ipod_touch_2g		MACH_IPOD_TOUCH_2G	IPOD_TOUCH_2G		3890
 da850_pqab		MACH_DA850_PQAB		DA850_PQAB		3891
+yellowstone		MACH_YELLOWSTONE	YELLOWSTONE		3892
+nevodkb			MACH_NEVODKB		NEVODKB			3893
+emeidkb			MACH_EMEIDKB		EMEIDKB			3499
+aruba_td		MACH_ARUBA_TD		ARUBA_TD		3500
+lt02			MACH_LT02		LT02			3894
+helandkb		MACH_HELANDKB		HELANDKB		3895
+eden_fpga		MACH_EDEN_FPGA		EDEN_FPGA		3896
+harrison		MACH_HARRISON		HARRISON                3897
+waruba			MACH_WARUBA		WARUBA                  3899
+helandelos		MACH_HELANDELOS		HELANDELOS		3900
+wilcox			MACH_WILCOX		WILCOX			3901
+cs02			MACH_CS02		CS02			3902
+baffin			MACH_BAFFIN		BAFFIN			3903
+cs05			MACH_CS05		CS05			3904
+ct01			MACH_CT01		CT01			3905
+baffinq			MACH_BAFFINQ		BAFFINQ		3906	
+golden			MACH_GOLDEN		GOLDEN			3907
+goya			MACH_GOYA		GOYA		3908
+degas			MACH_DEGAS		DEGAS			3909
diff --git a/arch/arm/vfp/entry.S b/arch/arm/vfp/entry.S
index 4fa9903b..c1a97840 100644
--- a/arch/arm/vfp/entry.S
+++ b/arch/arm/vfp/entry.S
@@ -10,7 +10,7 @@
  *
  * Basic entry code, called from the kernel's undefined instruction trap.
  *  r0  = faulted instruction
- *  r5  = faulted PC+4
+ *  r2  = faulted PC+4
  *  r9  = successful return
  *  r10 = thread_info structure
  *  lr  = failure return
@@ -26,6 +26,7 @@ ENTRY(do_vfp)
 	str	r11, [r10, #TI_PREEMPT]
 #endif
 	enable_irq
+	str	r2, [sp, #S_PC]		@ update regs->ARM_pc for Thumb 2 case
  	ldr	r4, .LCvfp
 	ldr	r11, [r10, #TI_CPU]	@ CPU number
 	add	r10, r10, #TI_VFPSTATE	@ r10 = workspace
diff --git a/arch/arm/vfp/vfpmodule.c b/arch/arm/vfp/vfpmodule.c
index b0197b2c..1ef803aa 100644
--- a/arch/arm/vfp/vfpmodule.c
+++ b/arch/arm/vfp/vfpmodule.c
@@ -457,10 +457,16 @@ static int vfp_pm_suspend(void)
 
 		/* disable, just in case */
 		fmxr(FPEXC, fmrx(FPEXC) & ~FPEXC_EN);
+	} else if (vfp_current_hw_state[ti->cpu]) {
+#ifndef CONFIG_SMP
+		fmxr(FPEXC, fpexc | FPEXC_EN);
+		vfp_save_state(vfp_current_hw_state[ti->cpu], fpexc);
+		fmxr(FPEXC, fpexc);
+#endif
 	}
 
 	/* clear any information we had about last context state */
-	memset(vfp_current_hw_state, 0, sizeof(vfp_current_hw_state));
+	vfp_current_hw_state[ti->cpu] = NULL;
 
 	return 0;
 }
diff --git a/drivers/Kconfig b/drivers/Kconfig
index d236aef7..6078487a 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -48,6 +48,8 @@ source "drivers/char/Kconfig"
 
 source "drivers/i2c/Kconfig"
 
+# source "drivers/sensor/Kconfig"
+
 source "drivers/spi/Kconfig"
 
 source "drivers/hsi/Kconfig"
@@ -64,6 +66,8 @@ source "drivers/w1/Kconfig"
 
 source "drivers/power/Kconfig"
 
+source "drivers/battery/Kconfig"
+
 source "drivers/hwmon/Kconfig"
 
 source "drivers/thermal/Kconfig"
@@ -96,6 +100,8 @@ source "drivers/memstick/Kconfig"
 
 source "drivers/leds/Kconfig"
 
+# source "drivers/switch/Kconfig"
+
 source "drivers/accessibility/Kconfig"
 
 source "drivers/infiniband/Kconfig"
@@ -140,4 +146,6 @@ source "drivers/virt/Kconfig"
 
 source "drivers/devfreq/Kconfig"
 
+source "drivers/nfc/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 95952c82..6e1be4b0 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -84,6 +84,7 @@ obj-$(CONFIG_PPS)		+= pps/
 obj-$(CONFIG_PTP_1588_CLOCK)	+= ptp/
 obj-$(CONFIG_W1)		+= w1/
 obj-$(CONFIG_POWER_SUPPLY)	+= power/
+obj-$(CONFIG_BATTERY_SAMSUNG)   += battery/
 obj-$(CONFIG_HWMON)		+= hwmon/
 obj-$(CONFIG_THERMAL)		+= thermal/
 obj-$(CONFIG_WATCHDOG)		+= watchdog/
@@ -100,6 +101,7 @@ obj-$(CONFIG_CPU_IDLE)		+= cpuidle/
 obj-y				+= mmc/
 obj-$(CONFIG_MEMSTICK)		+= memstick/
 obj-y				+= leds/
+#obj-$(CONFIG_SWITCH)		+= switch/
 obj-$(CONFIG_INFINIBAND)	+= infiniband/
 obj-$(CONFIG_SGI_SN)		+= sn/
 obj-y				+= firmware/
@@ -134,3 +136,10 @@ obj-$(CONFIG_VIRT_DRIVERS)	+= virt/
 obj-$(CONFIG_HYPERV)		+= hv/
 
 obj-$(CONFIG_PM_DEVFREQ)	+= devfreq/
+# obj-y				+= marvell/
+
+#obj-$(CONFIG_SENSOR_DIR)	+= sensor/
+
+ifeq (1, $(shell if [ -d ../../../../../../kernel/drivers/exfat ] ; then echo 1 ; fi))
+obj-y                           += exfat/
+endif
diff --git a/drivers/base/Kconfig b/drivers/base/Kconfig
index 9aa618ac..60753db4 100644
--- a/drivers/base/Kconfig
+++ b/drivers/base/Kconfig
@@ -181,6 +181,33 @@ config SOC_BUS
 
 source "drivers/base/regmap/Kconfig"
 
+config SYNC
+	bool "Synchronization framework"
+	default n
+	select ANON_INODES
+	help
+	  This option enables the framework for synchronization between multiple
+	  drivers.  Sync implementations can take advantage of hardware
+	  synchronization built into devices like GPUs.
+
+config SW_SYNC
+	bool "Software synchronization objects"
+	default n
+	depends on SYNC
+	help
+	  A sync object driver that uses a 32bit counter to coordinate
+	  syncrhronization.  Useful when there is no hardware primitive backing
+	  the synchronization.
+
+config SW_SYNC_USER
+       bool "Userspace API for SW_SYNC"
+       default n
+       depends on SW_SYNC
+       help
+         Provides a user space API to the sw sync object.
+         *WARNING* improper use of this can result in deadlocking kernel
+	 drivers from userspace.
+
 config DMA_SHARED_BUFFER
 	bool
 	default n
@@ -192,4 +219,93 @@ config DMA_SHARED_BUFFER
 	  APIs extension; the file's descriptor can then be passed on to other
 	  driver.
 
+config CMA
+	bool "Contiguous Memory Allocator (EXPERIMENTAL)"
+	depends on HAVE_DMA_CONTIGUOUS && HAVE_MEMBLOCK && EXPERIMENTAL
+	select MIGRATION
+	help
+	  This enables the Contiguous Memory Allocator which allows drivers
+	  to allocate big physically-contiguous blocks of memory for use with
+	  hardware components that do not support I/O map nor scatter-gather.
+
+	  For more information see <include/linux/dma-contiguous.h>.
+	  If unsure, say "n".
+
+if CMA
+
+config CMA_DEBUG
+	bool "CMA debug messages (DEVELOPMENT)"
+	depends on DEBUG_KERNEL
+	help
+	  Turns on debug messages in CMA.  This produces KERN_DEBUG
+	  messages for every CMA call as well as various messages while
+	  processing calls such as dma_alloc_from_contiguous().
+	  This option does not affect warning and error messages.
+
+comment "Default contiguous memory area size:"
+
+config CMA_SIZE_MBYTES
+	int "Size in Mega Bytes"
+	depends on !CMA_SIZE_SEL_PERCENTAGE
+	default 16
+	help
+	  Defines the size (in MiB) of the default memory area for Contiguous
+	  Memory Allocator.
+
+config CMA_SIZE_PERCENTAGE
+	int "Percentage of total memory"
+	depends on !CMA_SIZE_SEL_MBYTES
+	default 10
+	help
+	  Defines the size of the default memory area for Contiguous Memory
+	  Allocator as a percentage of the total memory in the system.
+
+choice
+	prompt "Selected region size"
+	default CMA_SIZE_SEL_ABSOLUTE
+
+config CMA_SIZE_SEL_MBYTES
+	bool "Use mega bytes value only"
+
+config CMA_SIZE_SEL_PERCENTAGE
+	bool "Use percentage value only"
+
+config CMA_SIZE_SEL_MIN
+	bool "Use lower value (minimum)"
+
+config CMA_SIZE_SEL_MAX
+	bool "Use higher value (maximum)"
+
+endchoice
+
+config CMA_ALIGNMENT
+	int "Maximum PAGE_SIZE order of alignment for contiguous buffers"
+	range 4 9
+	default 8
+	help
+	  DMA mapping framework by default aligns all buffers to the smallest
+	  PAGE_SIZE order which is greater than or equal to the requested buffer
+	  size. This works well for buffers up to a few hundreds kilobytes, but
+	  for larger buffers it just a memory waste. With this parameter you can
+	  specify the maximum PAGE_SIZE order for contiguous buffers. Larger
+	  buffers will be aligned only to this specified order. The order is
+	  expressed as a power of two multiplied by the PAGE_SIZE.
+
+	  For example, if your system defaults to 4KiB pages, the order value
+	  of 8 means that the buffers will be aligned up to 1MiB only.
+
+	  If unsure, leave the default value "8".
+
+config CMA_AREAS
+	int "Maximum count of the CMA device-private areas"
+	default 7
+	help
+	  CMA allows to create CMA areas for particular devices. This parameter
+	  sets the maximum number of such device private CMA areas in the
+	  system.
+
+	  If unsure, leave the default value "7".
+
+endif
+
 endmenu
diff --git a/drivers/base/Makefile b/drivers/base/Makefile
index b6d1b9c4..ff069742 100644
--- a/drivers/base/Makefile
+++ b/drivers/base/Makefile
@@ -6,6 +6,7 @@ obj-y			:= core.o bus.o dd.o syscore.o \
 			   attribute_container.o transport_class.o \
 			   topology.o
 obj-$(CONFIG_DEVTMPFS)	+= devtmpfs.o
+obj-$(CONFIG_CMA) += dma-contiguous.o
 obj-y			+= power/
 obj-$(CONFIG_HAS_DMA)	+= dma-mapping.o
 obj-$(CONFIG_HAVE_GENERIC_DMA_COHERENT) += dma-coherent.o
@@ -19,7 +20,11 @@ obj-$(CONFIG_MODULES)	+= module.o
 endif
 obj-$(CONFIG_SYS_HYPERVISOR) += hypervisor.o
 obj-$(CONFIG_REGMAP)	+= regmap/
+obj-$(CONFIG_REGDUMP) += regdump.o
 obj-$(CONFIG_SOC_BUS) += soc.o
 
+obj-$(CONFIG_SYNC)	+= sync.o
+obj-$(CONFIG_SW_SYNC)	+= sw_sync.o
+
 ccflags-$(CONFIG_DEBUG_DRIVER) := -DDEBUG
 
diff --git a/drivers/base/cpu.c b/drivers/base/cpu.c
index adf937bf..e56faee1 100644
--- a/drivers/base/cpu.c
+++ b/drivers/base/cpu.c
@@ -13,6 +13,7 @@
 #include <linux/gfp.h>
 #include <linux/slab.h>
 #include <linux/percpu.h>
+#include <linux/kthread.h>
 
 #include "base.h"
 
@@ -39,6 +40,8 @@ static ssize_t __ref store_online(struct device *dev,
 				  const char *buf, size_t count)
 {
 	struct cpu *cpu = container_of(dev, struct cpu, dev);
+	struct sched_param param_normal = { .sched_priority = 0 };
+	struct sched_param param_rt = { .sched_priority = 1 };
 	ssize_t ret;
 
 	cpu_hotplug_driver_lock();
@@ -49,7 +52,9 @@ static ssize_t __ref store_online(struct device *dev,
 			kobject_uevent(&dev->kobj, KOBJ_OFFLINE);
 		break;
 	case '1':
+		sched_setscheduler_nocheck(kthreadd_task, SCHED_FIFO, &param_rt);
 		ret = cpu_up(cpu->dev.id);
+		sched_setscheduler_nocheck(kthreadd_task, SCHED_NORMAL, &param_normal);
 		if (!ret)
 			kobject_uevent(&dev->kobj, KOBJ_ONLINE);
 		break;
diff --git a/drivers/base/dma-buf.c b/drivers/base/dma-buf.c
index 07cbbc6f..7cfb405b 100644
--- a/drivers/base/dma-buf.c
+++ b/drivers/base/dma-buf.c
@@ -44,8 +44,26 @@ static int dma_buf_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
+static int dma_buf_mmap_internal(struct file *file, struct vm_area_struct *vma)
+{
+	struct dma_buf *dmabuf;
+
+	if (!is_dma_buf_file(file))
+		return -EINVAL;
+
+	dmabuf = file->private_data;
+
+	/* check for overflowing the buffer's size */
+	if (vma->vm_pgoff + ((vma->vm_end - vma->vm_start) >> PAGE_SHIFT) >
+	    dmabuf->size >> PAGE_SHIFT)
+		return -EINVAL;
+
+	return dmabuf->ops->mmap(dmabuf, vma);
+}
+
 static const struct file_operations dma_buf_fops = {
 	.release	= dma_buf_release,
+	.mmap		= dma_buf_mmap_internal,
 };
 
 /*
@@ -82,7 +100,8 @@ struct dma_buf *dma_buf_export(void *priv, const struct dma_buf_ops *ops,
 			  || !ops->unmap_dma_buf
 			  || !ops->release
 			  || !ops->kmap_atomic
-			  || !ops->kmap)) {
+			  || !ops->kmap
+			  || !ops->mmap)) {
 		return ERR_PTR(-EINVAL);
 	}
 
@@ -406,3 +425,46 @@ void dma_buf_kunmap(struct dma_buf *dmabuf, unsigned long page_num,
 		dmabuf->ops->kunmap(dmabuf, page_num, vaddr);
 }
 EXPORT_SYMBOL_GPL(dma_buf_kunmap);
+
+
+/**
+ * dma_buf_mmap - Setup up a userspace mmap with the given vma
+ * @dma_buf:	[in]	buffer that should back the vma
+ * @vma:	[in]	vma for the mmap
+ * @pgoff:	[in]	offset in pages where this mmap should start within the
+ * 			dma-buf buffer.
+ *
+ * This function adjusts the passed in vma so that it points at the file of the
+ * dma_buf operation. It alsog adjusts the starting pgoff and does bounds
+ * checking on the size of the vma. Then it calls the exporters mmap function to
+ * set up the mapping.
+ *
+ * Can return negative error values, returns 0 on success.
+ */
+int dma_buf_mmap(struct dma_buf *dmabuf, struct vm_area_struct *vma,
+		 unsigned long pgoff)
+{
+	if (WARN_ON(!dmabuf || !vma))
+		return -EINVAL;
+
+	/* check for offset overflow */
+	if (pgoff + ((vma->vm_end - vma->vm_start) >> PAGE_SHIFT) < pgoff)
+		return -EOVERFLOW;
+
+	/* check for overflowing the buffer's size */
+	if (pgoff + ((vma->vm_end - vma->vm_start) >> PAGE_SHIFT) >
+	    dmabuf->size >> PAGE_SHIFT)
+		return -EINVAL;
+
+	/* readjust the vma */
+	if (vma->vm_file)
+		fput(vma->vm_file);
+
+	vma->vm_file = dmabuf->file;
+	get_file(vma->vm_file);
+
+	vma->vm_pgoff = pgoff;
+
+	return dmabuf->ops->mmap(dmabuf, vma);
+}
+EXPORT_SYMBOL_GPL(dma_buf_mmap);
diff --git a/drivers/base/dma-contiguous.c b/drivers/base/dma-contiguous.c
new file mode 100644
index 00000000..42d38af9
--- /dev/null
+++ b/drivers/base/dma-contiguous.c
@@ -0,0 +1,536 @@
+/*
+ * Contiguous Memory Allocator for DMA mapping framework
+ * Copyright (c) 2010-2011 by Samsung Electronics.
+ * Written by:
+ *	Marek Szyprowski <m.szyprowski@samsung.com>
+ *	Michal Nazarewicz <mina86@mina86.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License or (at your optional) any later version of the license.
+ */
+
+#define pr_fmt(fmt) "cma: " fmt
+
+#ifdef CONFIG_CMA_DEBUG
+#ifndef DEBUG
+#  define DEBUG
+#endif
+#endif
+
+#include <asm/page.h>
+#include <asm/dma-contiguous.h>
+
+#include <linux/memblock.h>
+#include <linux/err.h>
+#include <linux/mm.h>
+#include <linux/mutex.h>
+#include <linux/page-isolation.h>
+#include <linux/slab.h>
+#include <linux/swap.h>
+#include <linux/mm_types.h>
+#include <linux/dma-contiguous.h>
+
+#ifndef SZ_1M
+#define SZ_1M (1 << 20)
+#endif
+
+struct cma {
+	unsigned long	base_pfn;
+	unsigned long	count;
+	unsigned long	*bitmap;
+};
+
+struct cma *dma_contiguous_default_area;
+
+int cma_available;
+
+#ifdef CONFIG_CMA_SIZE_MBYTES
+#define CMA_SIZE_MBYTES CONFIG_CMA_SIZE_MBYTES
+#else
+#define CMA_SIZE_MBYTES 0
+#endif
+
+/*
+ * Default global CMA area size can be defined in kernel's .config.
+ * This is usefull mainly for distro maintainers to create a kernel
+ * that works correctly for most supported systems.
+ * The size can be set in bytes or as a percentage of the total memory
+ * in the system.
+ *
+ * Users, who want to set the size of global CMA area for their system
+ * should use cma= kernel parameter.
+ */
+static const unsigned long size_bytes = CMA_SIZE_MBYTES * SZ_1M;
+static long size_cmdline = -1;
+
+static int __init early_cma(char *p)
+{
+	pr_debug("%s(%s)\n", __func__, p);
+	size_cmdline = memparse(p, &p);
+	return 0;
+}
+early_param("cma", early_cma);
+
+#ifdef CONFIG_CMA_SIZE_PERCENTAGE
+
+static unsigned long __init __maybe_unused cma_early_percent_memory(void)
+{
+	struct memblock_region *reg;
+	unsigned long total_pages = 0;
+
+	/*
+	 * We cannot use memblock_phys_mem_size() here, because
+	 * memblock_analyze() has not been called yet.
+	 */
+	for_each_memblock(memory, reg)
+		total_pages += memblock_region_memory_end_pfn(reg) -
+			       memblock_region_memory_base_pfn(reg);
+
+	return (total_pages * CONFIG_CMA_SIZE_PERCENTAGE / 100) << PAGE_SHIFT;
+}
+
+#else
+
+static inline __maybe_unused unsigned long cma_early_percent_memory(void)
+{
+	return 0;
+}
+
+#endif
+
+/**
+ * dma_contiguous_reserve() - reserve area for contiguous memory handling
+ * @limit: End address of the reserved memory (optional, 0 for any).
+ *
+ * This function reserves memory from early allocator. It should be
+ * called by arch specific code once the early allocator (memblock or bootmem)
+ * has been activated and all other subsystems have already allocated/reserved
+ * memory.
+ */
+void __init dma_contiguous_reserve(phys_addr_t limit)
+{
+	unsigned long selected_size = 0;
+
+	pr_debug("%s(limit %08lx)\n", __func__, (unsigned long)limit);
+
+	if (size_cmdline != -1) {
+		selected_size = size_cmdline;
+	} else {
+#ifdef CONFIG_CMA_SIZE_SEL_MBYTES
+		selected_size = size_bytes;
+#elif defined(CONFIG_CMA_SIZE_SEL_PERCENTAGE)
+		selected_size = cma_early_percent_memory();
+#elif defined(CONFIG_CMA_SIZE_SEL_MIN)
+		selected_size = min(size_bytes, cma_early_percent_memory());
+#elif defined(CONFIG_CMA_SIZE_SEL_MAX)
+		selected_size = max(size_bytes, cma_early_percent_memory());
+#endif
+	}
+
+	if (selected_size) {
+		pr_debug("%s: reserving %ld MiB for global area\n", __func__,
+			 selected_size / SZ_1M);
+
+		dma_declare_contiguous(NULL, selected_size, 0, limit);
+	}
+};
+
+static DEFINE_MUTEX(cma_mutex);
+
+static __init int cma_activate_area(unsigned long base_pfn, unsigned long count)
+{
+	unsigned long pfn = base_pfn;
+	unsigned i = count >> pageblock_order;
+	struct zone *zone;
+
+	WARN_ON_ONCE(!pfn_valid(pfn));
+	zone = page_zone(pfn_to_page(pfn));
+
+	do {
+		unsigned j;
+		base_pfn = pfn;
+		for (j = pageblock_nr_pages; j; --j, pfn++) {
+			WARN_ON_ONCE(!pfn_valid(pfn));
+			if (page_zone(pfn_to_page(pfn)) != zone)
+				return -EINVAL;
+		}
+		init_cma_reserved_pageblock(pfn_to_page(base_pfn));
+	} while (--i);
+	return 0;
+}
+
+static __init struct cma *cma_create_area(unsigned long base_pfn,
+				     unsigned long count)
+{
+	int bitmap_size = BITS_TO_LONGS(count) * sizeof(long);
+	struct cma *cma;
+	int ret = -ENOMEM;
+
+	pr_debug("%s(base %08lx, count %lx)\n", __func__, base_pfn, count);
+
+	cma = kmalloc(sizeof *cma, GFP_KERNEL);
+	if (!cma)
+		return ERR_PTR(-ENOMEM);
+
+	cma->base_pfn = base_pfn;
+	cma->count = count;
+	cma->bitmap = kzalloc(bitmap_size, GFP_KERNEL);
+
+	if (!cma->bitmap)
+		goto no_mem;
+
+	ret = cma_activate_area(base_pfn, count);
+	if (ret)
+		goto error;
+
+	pr_debug("%s: returned %p\n", __func__, (void *)cma);
+	return cma;
+
+error:
+	kfree(cma->bitmap);
+no_mem:
+	kfree(cma);
+	return ERR_PTR(ret);
+}
+
+static struct cma_reserved {
+	phys_addr_t start;
+	unsigned long size;
+	struct device *dev;
+} cma_reserved[MAX_CMA_AREAS] __initdata;
+static unsigned cma_reserved_count __initdata;
+
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+extern unsigned long migrate_page_copy_count;
+static int cma_info_show(struct seq_file *s, void *unused)
+{
+	struct cma *cma = dev_get_cma_area(NULL);
+	unsigned long start = 0, set = 0, end = 0, sum = 0;
+	int nr_per_order[32];
+	int i, total = 0, order, order_max = 0;
+	struct page *pg;
+
+	seq_printf(s, "CMA Region: pfn(%lx:%lx) phy(%08x:%08x)\n",
+		cma->base_pfn, cma->base_pfn + cma->count - 1,
+		__pfn_to_phys(cma->base_pfn),
+		__pfn_to_phys(cma->base_pfn + cma->count) - 1);
+
+	seq_printf(s, "\n( Un-Set    )           [ Set       ]\n");
+	while (1) {
+		set = find_next_bit(cma->bitmap, cma->count, start);
+		if (set >= cma->count)
+			break;
+		end = find_next_zero_bit(cma->bitmap, cma->count, set);
+
+		if (set > 0)
+			seq_printf(s, "(%5lx:%5lx) %5lx ",
+				cma->base_pfn + start, cma->base_pfn + set - 1,
+				set - start);
+		else
+			seq_printf(s, "%16.s", "");
+
+		seq_printf(s, "\t[%5lx:%5lx] %5lx\n", cma->base_pfn + set,
+			cma->base_pfn + end - 1, end - set);
+
+		start = end;
+		sum += (end - set);
+	}
+
+	if (start < cma->count)
+		seq_printf(s, "(%5lx:%5lx) %5lx\n",
+			cma->base_pfn + start, cma->base_pfn + cma->count - 1,
+			cma->count - start);
+
+	seq_printf(s, "Total: %12lx%24lx%12lx\n",
+		cma->count - sum, sum, cma->count);
+	seq_printf(s, "\nMigrate copy count: %lx\n", migrate_page_copy_count);
+
+	for (i = 0; i < 32; i++)
+		nr_per_order[i] = 0;
+	pg = pfn_to_page(cma->base_pfn);
+	start = -1;
+	for (i = 0; i < cma->count; i++, pg++) {
+		if (!test_bit(i, cma->bitmap) && !page_count(pg)) {
+			if (start == -1)
+				start = i;
+			end = i;
+
+			if (i < (cma->count - 1))
+				continue;
+		}
+		if (start != -1) {
+			total += (end - start + 1);
+			order = fls(end - start + 1) - 1;
+
+			nr_per_order[order]++;
+			start = -1;
+			if (order_max < order)
+				order_max = order;
+		}
+	}
+
+	seq_printf(s, "\nIdle pages per order, total: %d\nOrder:", total);
+	for (i = 0; i <= order_max; i++)
+		seq_printf(s, "%6d ", i);
+
+	seq_printf(s, "\nCount:");
+	for (i = 0; i <= order_max; i++)
+		seq_printf(s, "%6d ", nr_per_order[i]);
+	seq_printf(s, "\n");
+
+	return 0;
+}
+
+static int cma_info_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cma_info_show, inode->i_private);
+}
+
+static const struct file_operations cma_info_fops = {
+	.open = cma_info_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int __init cma_init_reserved_areas(void)
+{
+	struct cma_reserved *r = cma_reserved;
+	unsigned i = cma_reserved_count;
+
+	if (!cma_available)
+		return 0;
+
+	pr_debug("%s()\n", __func__);
+
+	for (; i; --i, ++r) {
+		struct cma *cma;
+		cma = cma_create_area(PFN_DOWN(r->start),
+				      r->size >> PAGE_SHIFT);
+		if (!IS_ERR(cma))
+			dev_set_cma_area(r->dev, cma);
+	}
+
+	proc_create("cmainfo", S_IRUGO, NULL, &cma_info_fops);
+	return 0;
+}
+core_initcall(cma_init_reserved_areas);
+
+/**
+ * dma_declare_contiguous() - reserve area for contiguous memory handling
+ *			      for particular device
+ * @dev:   Pointer to device structure.
+ * @size:  Size of the reserved memory.
+ * @base:  Start address of the reserved memory (optional, 0 for any).
+ * @limit: End address of the reserved memory (optional, 0 for any).
+ *
+ * This function reserves memory for specified device. It should be
+ * called by board specific code when early allocator (memblock or bootmem)
+ * is still activate.
+ */
+int __init dma_declare_contiguous(struct device *dev, unsigned long size,
+				  phys_addr_t base, phys_addr_t limit)
+{
+	struct cma_reserved *r = &cma_reserved[cma_reserved_count];
+	unsigned long alignment;
+
+	pr_debug("%s(size %lx, base %08lx, limit %08lx)\n", __func__,
+		 (unsigned long)size, (unsigned long)base,
+		 (unsigned long)limit);
+
+	/* Sanity checks */
+	if (cma_reserved_count == ARRAY_SIZE(cma_reserved)) {
+		pr_err("Not enough slots for CMA reserved regions!\n");
+		return -ENOSPC;
+	}
+
+	if (!size)
+		return -EINVAL;
+
+	/* Sanitise input arguments */
+	alignment = PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order);
+	base = ALIGN(base, alignment);
+	size = ALIGN(size, alignment);
+	limit &= ~(alignment - 1);
+
+	/* Reserve memory */
+	if (base) {
+		if (memblock_is_region_reserved(base, size) ||
+		    memblock_reserve(base, size) < 0) {
+			base = -EBUSY;
+			goto err;
+		}
+	} else {
+		/*
+		 * Use __memblock_alloc_base() since
+		 * memblock_alloc_base() panic()s.
+		 */
+		phys_addr_t addr = __memblock_alloc_base(size, alignment, limit);
+		if (!addr) {
+			base = -ENOMEM;
+			goto err;
+		} else if (addr + size > ~(unsigned long)0) {
+			memblock_free(addr, size);
+			base = -EINVAL;
+			goto err;
+		} else {
+			base = addr;
+		}
+	}
+
+	/*
+	 * Each reserved area must be initialised later, when more kernel
+	 * subsystems (like slab allocator) are available.
+	 */
+	r->start = base;
+	r->size = size;
+	r->dev = dev;
+	cma_reserved_count++;
+	pr_info("CMA: reserved %ld MiB at %08lx\n", size / SZ_1M,
+		(unsigned long)base);
+
+	/* Architecture specific contiguous memory fixup. */
+	dma_contiguous_early_fixup(base, size);
+
+	cma_available = 1;
+	return 0;
+err:
+	pr_err("CMA: failed to reserve %ld MiB\n", size / SZ_1M);
+	return base;
+}
+
+static int cma_bitmap_show(struct device *dev)
+{
+	struct cma *cma = dev_get_cma_area(dev);
+	unsigned long start = 0, set = 0, end = 0, sum = 0;
+
+	pr_info("cma free list pfn[%lx %lx]: dev(%s)\n", cma->base_pfn,
+		cma->base_pfn + cma->count - 1, dev ? dev_name(dev) : "");
+
+	while (1) {
+		set = find_next_bit(cma->bitmap, cma->count, start);
+		if (set >= cma->count)
+			break;
+		end = find_next_zero_bit(cma->bitmap, cma->count, set);
+
+		if (set > 0)
+			pr_info("[%6lx:%6lx] %6lx %6lx",
+				cma->base_pfn + start, cma->base_pfn + set - 1,
+				set - start, end - set);
+		start = end;
+		sum += (end - set);
+	}
+
+	if (start < cma->count)
+		pr_info("[%6lx:%6lx] %6lx ",
+			cma->base_pfn + start, cma->base_pfn + cma->count - 1,
+			cma->count - start);
+
+	pr_info("Total: free(%lx) set(%lx) all(%lx)\n",
+		cma->count - sum, sum, cma->count);
+	return 0;
+}
+
+/**
+ * dma_alloc_from_contiguous() - allocate pages from contiguous area
+ * @dev:   Pointer to device for which the allocation is performed.
+ * @count: Requested number of pages.
+ * @align: Requested alignment of pages (in PAGE_SIZE order).
+ *
+ * This function allocates memory buffer for specified device. It uses
+ * device specific contiguous memory area if available or the default
+ * global one. Requires architecture specific get_dev_cma_area() helper
+ * function.
+ */
+struct page *dma_alloc_from_contiguous(struct device *dev, int count,
+				       unsigned int align)
+{
+	unsigned long mask, pfn = -1, pageno, start = 0;
+	struct cma *cma = dev_get_cma_area(dev);
+	struct page *page = NULL;
+	int ret;
+
+	if (!cma || !cma->count)
+		return NULL;
+
+	if (align > CONFIG_CMA_ALIGNMENT)
+		align = CONFIG_CMA_ALIGNMENT;
+
+	pr_debug("%s(cma %p, count %d, align %d)\n", __func__, (void *)cma,
+		 count, align);
+
+	if (!count)
+		return NULL;
+
+	mask = (1 << align) - 1;
+
+	mutex_lock(&cma_mutex);
+
+	for (;;) {
+		pageno = bitmap_find_next_zero_area(cma->bitmap, cma->count,
+						    start, count, mask);
+		if (pageno >= cma->count)
+			break;
+
+		pfn = cma->base_pfn + pageno;
+		ret = alloc_contig_range(pfn, pfn + count, MIGRATE_CMA);
+		if (ret == 0) {
+			bitmap_set(cma->bitmap, pageno, count);
+			page = pfn_to_page(pfn);
+			break;
+		} else if (ret != -EBUSY) {
+			break;
+		}
+		pr_debug("%s(): memory range at %p (%lx, %lx) is busy,"\
+			" retrying\n", __func__, pfn_to_page(pfn),
+			pfn, pfn + count);
+		/* try again with a bit different memory target */
+		start = pageno + mask + 1;
+	}
+
+	if (!page)
+		cma_bitmap_show(dev);
+
+	mutex_unlock(&cma_mutex);
+	pr_debug("%s(): returned %p pfn(%lx)\n", __func__, page, pfn);
+	return page;
+}
+
+/**
+ * dma_release_from_contiguous() - release allocated pages
+ * @dev:   Pointer to device for which the pages were allocated.
+ * @pages: Allocated pages.
+ * @count: Number of allocated pages.
+ *
+ * This function releases memory allocated by dma_alloc_from_contiguous().
+ * It returns false when provided pages do not belong to contiguous area and
+ * true otherwise.
+ */
+bool dma_release_from_contiguous(struct device *dev, struct page *pages,
+				 int count)
+{
+	struct cma *cma = dev_get_cma_area(dev);
+	unsigned long pfn;
+
+	if (!cma || !pages)
+		return false;
+
+	pr_debug("%s(page %p)\n", __func__, (void *)pages);
+
+	pfn = page_to_pfn(pages);
+
+	if (pfn < cma->base_pfn || pfn >= cma->base_pfn + cma->count)
+		return false;
+
+	VM_BUG_ON(pfn + count > cma->base_pfn + cma->count);
+
+	mutex_lock(&cma_mutex);
+	bitmap_clear(cma->bitmap, pfn - cma->base_pfn, count);
+	free_contig_range(pfn, count);
+	mutex_unlock(&cma_mutex);
+
+	return true;
+}
diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index 3085f9bc..5be7fe2f 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -28,6 +28,7 @@
 #include <linux/sched.h>
 #include <linux/async.h>
 #include <linux/suspend.h>
+#include <linux/timer.h>
 
 #include "../base.h"
 #include "power.h"
@@ -54,6 +55,12 @@ struct suspend_stats suspend_stats;
 static DEFINE_MUTEX(dpm_list_mtx);
 static pm_message_t pm_transition;
 
+struct dpm_watchdog {
+	struct device		*dev;
+	struct task_struct	*tsk;
+	struct timer_list	timer;
+};
+
 static int async_error;
 
 /**
@@ -389,6 +396,56 @@ static int dpm_run_callback(pm_callback_t cb, struct device *dev,
 	return error;
 }
 
+/**
+ * dpm_wd_handler - Driver suspend / resume watchdog handler.
+ *
+ * Called when a driver has timed out suspending or resuming.
+ * There's not much we can do here to recover so BUG() out for
+ * a crash-dump
+ */
+static void dpm_wd_handler(unsigned long data)
+{
+	struct dpm_watchdog *wd = (void *)data;
+	struct device *dev      = wd->dev;
+	struct task_struct *tsk = wd->tsk;
+
+	dev_emerg(dev, "**** DPM device timeout ****\n");
+	show_stack(tsk, NULL);
+
+	BUG();
+}
+
+/**
+ * dpm_wd_set - Enable pm watchdog for given device.
+ * @wd: Watchdog. Must be allocated on the stack.
+ * @dev: Device to handle.
+ */
+static void dpm_wd_set(struct dpm_watchdog *wd, struct device *dev)
+{
+	struct timer_list *timer = &wd->timer;
+
+	wd->dev = dev;
+	wd->tsk = get_current();
+
+	init_timer_on_stack(timer);
+	timer->expires = jiffies + HZ * 12;
+	timer->function = dpm_wd_handler;
+	timer->data = (unsigned long)wd;
+	add_timer(timer);
+}
+
+/**
+ * dpm_wd_clear - Disable pm watchdog.
+ * @wd: Watchdog to disable.
+ */
+static void dpm_wd_clear(struct dpm_watchdog *wd)
+{
+	struct timer_list *timer = &wd->timer;
+
+	del_timer_sync(timer);
+	destroy_timer_on_stack(timer);
+}
+
 /*------------------------- Resume routines -------------------------*/
 
 /**
@@ -565,6 +622,7 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 	char *info = NULL;
 	int error = 0;
 	bool put = false;
+	struct dpm_watchdog wd;
 
 	TRACE_DEVICE(dev);
 	TRACE_RESUME(0);
@@ -577,6 +635,7 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 	 * a resumed device, even if the device hasn't been completed yet.
 	 */
 	dev->power.is_prepared = false;
+	dpm_wd_set(&wd, dev);
 
 	if (!dev->power.is_suspended)
 		goto Unlock;
@@ -631,6 +690,7 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 
  Unlock:
 	device_unlock(dev);
+	dpm_wd_clear(&wd);
 	complete_all(&dev->power.completion);
 
 	TRACE_RESUME(error);
@@ -889,6 +949,11 @@ static int dpm_suspend_noirq(pm_message_t state)
 		if (!list_empty(&dev->power.entry))
 			list_move(&dev->power.entry, &dpm_noirq_list);
 		put_device(dev);
+
+		if (pm_wakeup_pending()) {
+			error = -EBUSY;
+			break;
+		}
 	}
 	mutex_unlock(&dpm_list_mtx);
 	if (error)
@@ -962,6 +1027,11 @@ static int dpm_suspend_late(pm_message_t state)
 		if (!list_empty(&dev->power.entry))
 			list_move(&dev->power.entry, &dpm_late_early_list);
 		put_device(dev);
+
+		if (pm_wakeup_pending()) {
+			error = -EBUSY;
+			break;
+		}
 	}
 	mutex_unlock(&dpm_list_mtx);
 	if (error)
@@ -979,8 +1049,16 @@ static int dpm_suspend_late(pm_message_t state)
 int dpm_suspend_end(pm_message_t state)
 {
 	int error = dpm_suspend_late(state);
+	if (error)
+		return error;
 
-	return error ? : dpm_suspend_noirq(state);
+	error = dpm_suspend_noirq(state);
+	if (error) {
+		dpm_resume_early(state);
+		return error;
+	}
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(dpm_suspend_end);
 
@@ -1017,6 +1095,7 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
 	pm_callback_t callback = NULL;
 	char *info = NULL;
 	int error = 0;
+	struct dpm_watchdog wd;
 
 	dpm_wait_for_children(dev, async);
 
@@ -1033,6 +1112,8 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
 		goto Complete;
 	}
 
+	dpm_wd_set(&wd, dev);
+
 	device_lock(dev);
 
 	if (dev->pm_domain) {
@@ -1088,7 +1169,9 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
 
 	device_unlock(dev);
 
- Complete:
+	dpm_wd_clear(&wd);
+
+Complete:
 	complete_all(&dev->power.completion);
 
 	if (error) {
diff --git a/drivers/base/power/qos.c b/drivers/base/power/qos.c
index 71855570..fd849a2c 100644
--- a/drivers/base/power/qos.c
+++ b/drivers/base/power/qos.c
@@ -352,21 +352,26 @@ EXPORT_SYMBOL_GPL(dev_pm_qos_remove_request);
  *
  * Will register the notifier into a notification chain that gets called
  * upon changes to the target value for the device.
+ *
+ * If the device's constraints object doesn't exist when this routine is called,
+ * it will be created (or error code will be returned if that fails).
  */
 int dev_pm_qos_add_notifier(struct device *dev, struct notifier_block *notifier)
 {
-	int retval = 0;
+	int ret = 0;
 
 	mutex_lock(&dev_pm_qos_mtx);
 
-	/* Silently return if the constraints object is not present. */
-	if (dev->power.constraints)
-		retval = blocking_notifier_chain_register(
-				dev->power.constraints->notifiers,
-				notifier);
+	if (!dev->power.constraints)
+		ret = dev->power.power_state.event != PM_EVENT_INVALID ?
+			dev_pm_qos_constraints_allocate(dev) : -ENODEV;
+
+	if (!ret)
+		ret = blocking_notifier_chain_register(
+				dev->power.constraints->notifiers, notifier);
 
 	mutex_unlock(&dev_pm_qos_mtx);
-	return retval;
+	return ret;
 }
 EXPORT_SYMBOL_GPL(dev_pm_qos_add_notifier);
 
diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index bd0f3949..59894873 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -282,47 +282,6 @@ static int rpm_callback(int (*cb)(struct device *), struct device *dev)
 	return retval != -EACCES ? retval : -EIO;
 }
 
-struct rpm_qos_data {
-	ktime_t time_now;
-	s64 constraint_ns;
-};
-
-/**
- * rpm_update_qos_constraint - Update a given PM QoS constraint data.
- * @dev: Device whose timing data to use.
- * @data: PM QoS constraint data to update.
- *
- * Use the suspend timing data of @dev to update PM QoS constraint data pointed
- * to by @data.
- */
-static int rpm_update_qos_constraint(struct device *dev, void *data)
-{
-	struct rpm_qos_data *qos = data;
-	unsigned long flags;
-	s64 delta_ns;
-	int ret = 0;
-
-	spin_lock_irqsave(&dev->power.lock, flags);
-
-	if (dev->power.max_time_suspended_ns < 0)
-		goto out;
-
-	delta_ns = dev->power.max_time_suspended_ns -
-		ktime_to_ns(ktime_sub(qos->time_now, dev->power.suspend_time));
-	if (delta_ns <= 0) {
-		ret = -EBUSY;
-		goto out;
-	}
-
-	if (qos->constraint_ns > delta_ns || qos->constraint_ns == 0)
-		qos->constraint_ns = delta_ns;
-
- out:
-	spin_unlock_irqrestore(&dev->power.lock, flags);
-
-	return ret;
-}
-
 /**
  * rpm_suspend - Carry out runtime suspend of given device.
  * @dev: Device to suspend.
@@ -349,7 +308,6 @@ static int rpm_suspend(struct device *dev, int rpmflags)
 {
 	int (*callback)(struct device *);
 	struct device *parent = NULL;
-	struct rpm_qos_data qos;
 	int retval;
 
 	trace_rpm_suspend(dev, rpmflags);
@@ -445,38 +403,14 @@ static int rpm_suspend(struct device *dev, int rpmflags)
 		goto out;
 	}
 
-	qos.constraint_ns = __dev_pm_qos_read_value(dev);
-	if (qos.constraint_ns < 0) {
-		/* Negative constraint means "never suspend". */
+	if (__dev_pm_qos_read_value(dev) < 0) {
+		/* Negative PM QoS constraint means "never suspend". */
 		retval = -EPERM;
 		goto out;
 	}
-	qos.constraint_ns *= NSEC_PER_USEC;
-	qos.time_now = ktime_get();
 
 	__update_runtime_status(dev, RPM_SUSPENDING);
 
-	if (!dev->power.ignore_children) {
-		if (dev->power.irq_safe)
-			spin_unlock(&dev->power.lock);
-		else
-			spin_unlock_irq(&dev->power.lock);
-
-		retval = device_for_each_child(dev, &qos,
-					       rpm_update_qos_constraint);
-
-		if (dev->power.irq_safe)
-			spin_lock(&dev->power.lock);
-		else
-			spin_lock_irq(&dev->power.lock);
-
-		if (retval)
-			goto fail;
-	}
-
-	dev->power.suspend_time = qos.time_now;
-	dev->power.max_time_suspended_ns = qos.constraint_ns ? : -1;
-
 	if (dev->pm_domain)
 		callback = dev->pm_domain->ops.runtime_suspend;
 	else if (dev->type && dev->type->pm)
@@ -529,8 +463,6 @@ static int rpm_suspend(struct device *dev, int rpmflags)
 
  fail:
 	__update_runtime_status(dev, RPM_ACTIVE);
-	dev->power.suspend_time = ktime_set(0, 0);
-	dev->power.max_time_suspended_ns = -1;
 	dev->power.deferred_resume = false;
 	wake_up_all(&dev->power.wait_queue);
 
@@ -704,9 +636,6 @@ static int rpm_resume(struct device *dev, int rpmflags)
 	if (dev->power.no_callbacks)
 		goto no_callback;	/* Assume success. */
 
-	dev->power.suspend_time = ktime_set(0, 0);
-	dev->power.max_time_suspended_ns = -1;
-
 	__update_runtime_status(dev, RPM_RESUMING);
 
 	if (dev->pm_domain)
@@ -1369,9 +1298,6 @@ void pm_runtime_init(struct device *dev)
 	setup_timer(&dev->power.suspend_timer, pm_suspend_timer_fn,
 			(unsigned long)dev);
 
-	dev->power.suspend_time = ktime_set(0, 0);
-	dev->power.max_time_suspended_ns = -1;
-
 	init_waitqueue_head(&dev->power.wait_queue);
 }
 
@@ -1389,28 +1315,3 @@ void pm_runtime_remove(struct device *dev)
 	if (dev->power.irq_safe && dev->parent)
 		pm_runtime_put_sync(dev->parent);
 }
-
-/**
- * pm_runtime_update_max_time_suspended - Update device's suspend time data.
- * @dev: Device to handle.
- * @delta_ns: Value to subtract from the device's max_time_suspended_ns field.
- *
- * Update the device's power.max_time_suspended_ns field by subtracting
- * @delta_ns from it.  The resulting value of power.max_time_suspended_ns is
- * never negative.
- */
-void pm_runtime_update_max_time_suspended(struct device *dev, s64 delta_ns)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&dev->power.lock, flags);
-
-	if (delta_ns > 0 && dev->power.max_time_suspended_ns > 0) {
-		if (dev->power.max_time_suspended_ns > delta_ns)
-			dev->power.max_time_suspended_ns -= delta_ns;
-		else
-			dev->power.max_time_suspended_ns = 0;
-	}
-
-	spin_unlock_irqrestore(&dev->power.lock, flags);
-}
diff --git a/drivers/base/power/sysfs.c b/drivers/base/power/sysfs.c
index 95c12f6c..48be2ad4 100644
--- a/drivers/base/power/sysfs.c
+++ b/drivers/base/power/sysfs.c
@@ -314,22 +314,41 @@ static ssize_t wakeup_active_count_show(struct device *dev,
 
 static DEVICE_ATTR(wakeup_active_count, 0444, wakeup_active_count_show, NULL);
 
-static ssize_t wakeup_hit_count_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+static ssize_t wakeup_abort_count_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	unsigned long count = 0;
+	bool enabled = false;
+
+	spin_lock_irq(&dev->power.lock);
+	if (dev->power.wakeup) {
+		count = dev->power.wakeup->wakeup_count;
+		enabled = true;
+	}
+	spin_unlock_irq(&dev->power.lock);
+	return enabled ? sprintf(buf, "%lu\n", count) : sprintf(buf, "\n");
+}
+
+static DEVICE_ATTR(wakeup_abort_count, 0444, wakeup_abort_count_show, NULL);
+
+static ssize_t wakeup_expire_count_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
 {
 	unsigned long count = 0;
 	bool enabled = false;
 
 	spin_lock_irq(&dev->power.lock);
 	if (dev->power.wakeup) {
-		count = dev->power.wakeup->hit_count;
+		count = dev->power.wakeup->expire_count;
 		enabled = true;
 	}
 	spin_unlock_irq(&dev->power.lock);
 	return enabled ? sprintf(buf, "%lu\n", count) : sprintf(buf, "\n");
 }
 
-static DEVICE_ATTR(wakeup_hit_count, 0444, wakeup_hit_count_show, NULL);
+static DEVICE_ATTR(wakeup_expire_count, 0444, wakeup_expire_count_show, NULL);
 
 static ssize_t wakeup_active_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
@@ -398,6 +417,27 @@ static ssize_t wakeup_last_time_show(struct device *dev,
 }
 
 static DEVICE_ATTR(wakeup_last_time_ms, 0444, wakeup_last_time_show, NULL);
+
+#ifdef CONFIG_PM_AUTOSLEEP
+static ssize_t wakeup_prevent_sleep_time_show(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	s64 msec = 0;
+	bool enabled = false;
+
+	spin_lock_irq(&dev->power.lock);
+	if (dev->power.wakeup) {
+		msec = ktime_to_ms(dev->power.wakeup->prevent_sleep_time);
+		enabled = true;
+	}
+	spin_unlock_irq(&dev->power.lock);
+	return enabled ? sprintf(buf, "%lld\n", msec) : sprintf(buf, "\n");
+}
+
+static DEVICE_ATTR(wakeup_prevent_sleep_time_ms, 0444,
+		   wakeup_prevent_sleep_time_show, NULL);
+#endif /* CONFIG_PM_AUTOSLEEP */
 #endif /* CONFIG_PM_SLEEP */
 
 #ifdef CONFIG_PM_ADVANCED_DEBUG
@@ -486,11 +526,15 @@ static struct attribute *wakeup_attrs[] = {
 	&dev_attr_wakeup.attr,
 	&dev_attr_wakeup_count.attr,
 	&dev_attr_wakeup_active_count.attr,
-	&dev_attr_wakeup_hit_count.attr,
+	&dev_attr_wakeup_abort_count.attr,
+	&dev_attr_wakeup_expire_count.attr,
 	&dev_attr_wakeup_active.attr,
 	&dev_attr_wakeup_total_time_ms.attr,
 	&dev_attr_wakeup_max_time_ms.attr,
 	&dev_attr_wakeup_last_time_ms.attr,
+#ifdef CONFIG_PM_AUTOSLEEP
+	&dev_attr_wakeup_prevent_sleep_time_ms.attr,
+#endif
 #endif
 	NULL,
 };
diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 2a3e581b..6ccd3cc2 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -14,16 +14,15 @@
 #include <linux/suspend.h>
 #include <linux/seq_file.h>
 #include <linux/debugfs.h>
+#include <trace/events/power.h>
 
 #include "power.h"
 
-#define TIMEOUT		100
-
 /*
  * If set, the suspend/hibernate code will abort transitions to a sleep state
  * if wakeup events are registered during or immediately before the transition.
  */
-bool events_check_enabled;
+bool events_check_enabled __read_mostly;
 
 /*
  * Combined counters of registered wakeup events and wakeup events in progress.
@@ -52,6 +51,8 @@ static void pm_wakeup_timer_fn(unsigned long data);
 
 static LIST_HEAD(wakeup_sources);
 
+static DECLARE_WAIT_QUEUE_HEAD(wakeup_count_wait_queue);
+
 /**
  * wakeup_source_prepare - Prepare a new wakeup source for initialization.
  * @ws: Wakeup source to prepare.
@@ -126,16 +127,19 @@ EXPORT_SYMBOL_GPL(wakeup_source_destroy);
  */
 void wakeup_source_add(struct wakeup_source *ws)
 {
+	unsigned long flags;
+
 	if (WARN_ON(!ws))
 		return;
 
 	spin_lock_init(&ws->lock);
 	setup_timer(&ws->timer, pm_wakeup_timer_fn, (unsigned long)ws);
 	ws->active = false;
+	ws->last_time = ktime_get();
 
-	spin_lock_irq(&events_lock);
+	spin_lock_irqsave(&events_lock, flags);
 	list_add_rcu(&ws->entry, &wakeup_sources);
-	spin_unlock_irq(&events_lock);
+	spin_unlock_irqrestore(&events_lock, flags);
 }
 EXPORT_SYMBOL_GPL(wakeup_source_add);
 
@@ -145,12 +149,14 @@ EXPORT_SYMBOL_GPL(wakeup_source_add);
  */
 void wakeup_source_remove(struct wakeup_source *ws)
 {
+	unsigned long flags;
+
 	if (WARN_ON(!ws))
 		return;
 
-	spin_lock_irq(&events_lock);
+	spin_lock_irqsave(&events_lock, flags);
 	list_del_rcu(&ws->entry);
-	spin_unlock_irq(&events_lock);
+	spin_unlock_irqrestore(&events_lock, flags);
 	synchronize_rcu();
 }
 EXPORT_SYMBOL_GPL(wakeup_source_remove);
@@ -374,12 +380,33 @@ EXPORT_SYMBOL_GPL(device_set_wakeup_enable);
  */
 static void wakeup_source_activate(struct wakeup_source *ws)
 {
+	unsigned int cec;
+
 	ws->active = true;
 	ws->active_count++;
 	ws->last_time = ktime_get();
+	if (ws->autosleep_enabled)
+		ws->start_prevent_time = ws->last_time;
 
 	/* Increment the counter of events in progress. */
-	atomic_inc(&combined_event_count);
+	cec = atomic_inc_return(&combined_event_count);
+
+	trace_wakeup_source_activate(ws->name, cec);
+}
+
+/**
+ * wakeup_source_report_event - Report wakeup event using the given source.
+ * @ws: Wakeup source to report the event for.
+ */
+static void wakeup_source_report_event(struct wakeup_source *ws)
+{
+	ws->event_count++;
+	/* This is racy, but the counter is approximate anyway. */
+	if (events_check_enabled)
+		ws->wakeup_count++;
+
+	if (!ws->active)
+		wakeup_source_activate(ws);
 }
 
 /**
@@ -397,10 +424,7 @@ void __pm_stay_awake(struct wakeup_source *ws)
 
 	spin_lock_irqsave(&ws->lock, flags);
 
-	ws->event_count++;
-	if (!ws->active)
-		wakeup_source_activate(ws);
-
+	wakeup_source_report_event(ws);
 	del_timer(&ws->timer);
 	ws->timer_expires = 0;
 
@@ -432,6 +456,17 @@ void pm_stay_awake(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(pm_stay_awake);
 
+#ifdef CONFIG_PM_AUTOSLEEP
+static void update_prevent_sleep_time(struct wakeup_source *ws, ktime_t now)
+{
+	ktime_t delta = ktime_sub(now, ws->start_prevent_time);
+	ws->prevent_sleep_time = ktime_add(ws->prevent_sleep_time, delta);
+}
+#else
+static inline void update_prevent_sleep_time(struct wakeup_source *ws,
+					     ktime_t now) {}
+#endif
+
 /**
  * wakup_source_deactivate - Mark given wakeup source as inactive.
  * @ws: Wakeup source to handle.
@@ -442,6 +477,7 @@ EXPORT_SYMBOL_GPL(pm_stay_awake);
  */
 static void wakeup_source_deactivate(struct wakeup_source *ws)
 {
+	unsigned int cnt, inpr, cec;
 	ktime_t duration;
 	ktime_t now;
 
@@ -468,14 +504,23 @@ static void wakeup_source_deactivate(struct wakeup_source *ws)
 	if (ktime_to_ns(duration) > ktime_to_ns(ws->max_time))
 		ws->max_time = duration;
 
+	ws->last_time = now;
 	del_timer(&ws->timer);
 	ws->timer_expires = 0;
 
+	if (ws->autosleep_enabled)
+		update_prevent_sleep_time(ws, now);
+
 	/*
 	 * Increment the counter of registered wakeup events and decrement the
 	 * couter of wakeup events in progress simultaneously.
 	 */
-	atomic_add(MAX_IN_PROGRESS, &combined_event_count);
+	cec = atomic_add_return(MAX_IN_PROGRESS, &combined_event_count);
+	trace_wakeup_source_deactivate(ws->name, cec);
+
+	split_counters(&cnt, &inpr);
+	if (!inpr && waitqueue_active(&wakeup_count_wait_queue))
+		wake_up(&wakeup_count_wait_queue);
 }
 
 /**
@@ -536,8 +581,10 @@ static void pm_wakeup_timer_fn(unsigned long data)
 	spin_lock_irqsave(&ws->lock, flags);
 
 	if (ws->active && ws->timer_expires
-	    && time_after_eq(jiffies, ws->timer_expires))
+	    && time_after_eq(jiffies, ws->timer_expires)) {
 		wakeup_source_deactivate(ws);
+		ws->expire_count++;
+	}
 
 	spin_unlock_irqrestore(&ws->lock, flags);
 }
@@ -564,9 +611,7 @@ void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)
 
 	spin_lock_irqsave(&ws->lock, flags);
 
-	ws->event_count++;
-	if (!ws->active)
-		wakeup_source_activate(ws);
+	wakeup_source_report_event(ws);
 
 	if (!msec) {
 		wakeup_source_deactivate(ws);
@@ -608,21 +653,28 @@ void pm_wakeup_event(struct device *dev, unsigned int msec)
 }
 EXPORT_SYMBOL_GPL(pm_wakeup_event);
 
-/**
- * pm_wakeup_update_hit_counts - Update hit counts of all active wakeup sources.
- */
-static void pm_wakeup_update_hit_counts(void)
+static void print_active_wakeup_sources(void)
 {
-	unsigned long flags;
 	struct wakeup_source *ws;
+	int active = 0;
+	struct wakeup_source *last_activity_ws = NULL;
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
-		spin_lock_irqsave(&ws->lock, flags);
-		if (ws->active)
-			ws->hit_count++;
-		spin_unlock_irqrestore(&ws->lock, flags);
+		if (ws->active) {
+			pr_info("active wakeup source: %s\n", ws->name);
+			active = 1;
+		} else if (!active &&
+			   (!last_activity_ws ||
+			    ktime_to_ns(ws->last_time) >
+			    ktime_to_ns(last_activity_ws->last_time))) {
+			last_activity_ws = ws;
+		}
 	}
+
+	if (!active && last_activity_ws)
+		pr_info("last active wakeup source: %s\n",
+			last_activity_ws->name);
 	rcu_read_unlock();
 }
 
@@ -648,32 +700,42 @@ bool pm_wakeup_pending(void)
 		events_check_enabled = !ret;
 	}
 	spin_unlock_irqrestore(&events_lock, flags);
+
 	if (ret)
-		pm_wakeup_update_hit_counts();
+		print_active_wakeup_sources();
+
 	return ret;
 }
 
 /**
  * pm_get_wakeup_count - Read the number of registered wakeup events.
  * @count: Address to store the value at.
+ * @block: Whether or not to block.
  *
- * Store the number of registered wakeup events at the address in @count.  Block
- * if the current number of wakeup events being processed is nonzero.
+ * Store the number of registered wakeup events at the address in @count.  If
+ * @block is set, block until the current number of wakeup events being
+ * processed is zero.
  *
- * Return 'false' if the wait for the number of wakeup events being processed to
- * drop down to zero has been interrupted by a signal (and the current number
- * of wakeup events being processed is still nonzero).  Otherwise return 'true'.
+ * Return 'false' if the current number of wakeup events being processed is
+ * nonzero.  Otherwise return 'true'.
  */
-bool pm_get_wakeup_count(unsigned int *count)
+bool pm_get_wakeup_count(unsigned int *count, bool block)
 {
 	unsigned int cnt, inpr;
 
-	for (;;) {
-		split_counters(&cnt, &inpr);
-		if (inpr == 0 || signal_pending(current))
-			break;
-		pm_wakeup_update_hit_counts();
-		schedule_timeout_interruptible(msecs_to_jiffies(TIMEOUT));
+	if (block) {
+		DEFINE_WAIT(wait);
+
+		for (;;) {
+			prepare_to_wait(&wakeup_count_wait_queue, &wait,
+					TASK_INTERRUPTIBLE);
+			split_counters(&cnt, &inpr);
+			if (inpr == 0 || signal_pending(current))
+				break;
+
+			schedule();
+		}
+		finish_wait(&wakeup_count_wait_queue, &wait);
 	}
 
 	split_counters(&cnt, &inpr);
@@ -694,20 +756,47 @@ bool pm_get_wakeup_count(unsigned int *count)
 bool pm_save_wakeup_count(unsigned int count)
 {
 	unsigned int cnt, inpr;
+	unsigned long flags;
 
 	events_check_enabled = false;
-	spin_lock_irq(&events_lock);
+	spin_lock_irqsave(&events_lock, flags);
 	split_counters(&cnt, &inpr);
 	if (cnt == count && inpr == 0) {
 		saved_count = count;
 		events_check_enabled = true;
 	}
-	spin_unlock_irq(&events_lock);
-	if (!events_check_enabled)
-		pm_wakeup_update_hit_counts();
+	spin_unlock_irqrestore(&events_lock, flags);
 	return events_check_enabled;
 }
 
+#ifdef CONFIG_PM_AUTOSLEEP
+/**
+ * pm_wakep_autosleep_enabled - Modify autosleep_enabled for all wakeup sources.
+ * @enabled: Whether to set or to clear the autosleep_enabled flags.
+ */
+void pm_wakep_autosleep_enabled(bool set)
+{
+	struct wakeup_source *ws;
+	ktime_t now = ktime_get();
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
+		spin_lock_irq(&ws->lock);
+		if (ws->autosleep_enabled != set) {
+			ws->autosleep_enabled = set;
+			if (ws->active) {
+				if (set)
+					ws->start_prevent_time = now;
+				else
+					update_prevent_sleep_time(ws, now);
+			}
+		}
+		spin_unlock_irq(&ws->lock);
+	}
+	rcu_read_unlock();
+}
+#endif /* CONFIG_PM_AUTOSLEEP */
+
 static struct dentry *wakeup_sources_stats_dentry;
 
 /**
@@ -723,33 +812,54 @@ static int print_wakeup_source_stats(struct seq_file *m,
 	ktime_t max_time;
 	unsigned long active_count;
 	ktime_t active_time;
+	ktime_t prevent_sleep_time;
 	int ret;
 
 	spin_lock_irqsave(&ws->lock, flags);
 
 	total_time = ws->total_time;
 	max_time = ws->max_time;
+	prevent_sleep_time = ws->prevent_sleep_time;
 	active_count = ws->active_count;
 	if (ws->active) {
-		active_time = ktime_sub(ktime_get(), ws->last_time);
+		ktime_t now = ktime_get();
+
+		active_time = ktime_sub(now, ws->last_time);
 		total_time = ktime_add(total_time, active_time);
 		if (active_time.tv64 > max_time.tv64)
 			max_time = active_time;
+
+		if (ws->autosleep_enabled)
+			prevent_sleep_time = ktime_add(prevent_sleep_time,
+				ktime_sub(now, ws->start_prevent_time));
 	} else {
 		active_time = ktime_set(0, 0);
 	}
 
-	ret = seq_printf(m, "%-12s\t%lu\t\t%lu\t\t%lu\t\t"
-			"%lld\t\t%lld\t\t%lld\t\t%lld\n",
-			ws->name, active_count, ws->event_count, ws->hit_count,
+	ret = seq_printf(m, "%-12s\t%d\t%lu\t\t%lu\t\t%lu\t\t%lu\t\t"
+			"%lld\t\t%lld\t\t%lld\t\t%lld\t\t%lld\n",
+			ws->name, (ws->active) ? 1 : 0, active_count,
+			ws->event_count, ws->wakeup_count, ws->expire_count,
 			ktime_to_ms(active_time), ktime_to_ms(total_time),
-			ktime_to_ms(max_time), ktime_to_ms(ws->last_time));
+			ktime_to_ms(max_time), ktime_to_ms(ws->last_time),
+			ktime_to_ms(prevent_sleep_time));
 
 	spin_unlock_irqrestore(&ws->lock, flags);
 
 	return ret;
 }
 
+void print_active_wakeup_events(void)
+{
+	struct wakeup_source *ws;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
+		if (ws->active)
+			pr_info("Active wakeup event %s\n", ws->name);
+	rcu_read_unlock();
+}
+
 /**
  * wakeup_sources_stats_show - Print wakeup sources statistics information.
  * @m: seq_file to print the statistics into.
@@ -758,8 +868,9 @@ static int wakeup_sources_stats_show(struct seq_file *m, void *unused)
 {
 	struct wakeup_source *ws;
 
-	seq_puts(m, "name\t\tactive_count\tevent_count\thit_count\t"
-		"active_since\ttotal_time\tmax_time\tlast_change\n");
+	seq_puts(m, "name\t\tcurrent_active\tactive_count\tevent_count\t"
+		"wakeup_count\texpire_count\tactive_since\ttotal_time\t"
+		"max_time\tlast_change\tprevent_suspend_time\n");
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
diff --git a/drivers/base/regdump.c b/drivers/base/regdump.c
new file mode 100644
index 00000000..0ea5a181
--- /dev/null
+++ b/drivers/base/regdump.c
@@ -0,0 +1,544 @@
+/*
+ *  regdump.c - framework for dump the system periperal registers.
+ *
+ *  Copyright (C) 2012 Lei Wen <leiwen@marvell.com>, Marvell Inc.
+ *
+ *  This file is released under the GPLv2.
+ */
+
+#include <linux/regdump_ops.h>
+#include <linux/mutex.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/seq_file.h>
+#include <linux/module.h>
+#include <asm/io.h>
+
+
+#define REGDUMP_READLINE_NUM		80
+#ifdef CONFIG_SMP
+static DECLARE_RWSEM(all_cpu_access_lock);
+
+static inline void dump_access_lock(void)
+{
+	down_write(&all_cpu_access_lock);
+}
+
+static inline void dump_access_unlock(void)
+{
+	up_write(&all_cpu_access_lock);
+}
+
+#else
+
+static DEFINE_MUTEX(access_lock);
+
+static inline void dump_access_lock(void)
+{
+	mutex_lock(&access_lock);
+}
+
+static inline void dump_access_unlock(void)
+{
+	mutex_unlock(&access_lock);
+}
+#endif
+
+struct dentry *d_regdump;
+struct dentry *regdump_init_dentry(void)
+{
+	static int once;
+
+	if (d_regdump)
+		return d_regdump;
+
+	if (!debugfs_initialized()) {
+		pr_warning("Debugfs not init yet!!!\n");
+		return NULL;
+	}
+
+	d_regdump = debugfs_create_dir("regdump", NULL);
+	if (!d_regdump && !once) {
+		once = 1;
+		pr_warning("Could not create debugfs directory 'regdump'\n");
+		return NULL;
+	}
+
+	return d_regdump;
+}
+
+static LIST_HEAD(regdump_ops_list);
+static DEFINE_MUTEX(regdump_ops_lock);
+
+static unsigned long regdump_read_region(struct regdump_ops *ops,
+					 struct regdump_region *region)
+{
+	unsigned long val, avail;
+
+	avail = region->cond(ops);
+	if (!avail)
+		return 0;
+
+	switch (region->size) {
+	case 4:
+		val = readl(ops->base + region->start);
+		break;
+	case 2:
+		val = readw(ops->base + region->start);
+		break;
+	case 1:
+		val = readb(ops->base + region->start);
+		break;
+	default:
+		printk(KERN_ERR "not valid reg size %lx\n", region->size);
+		return 0;
+	}
+
+	return val;
+}
+
+int dump_reg_to_mem(void)
+{
+	struct regdump_ops *ops;
+	struct regdump_region *region;
+	unsigned long val;
+	void *buf;
+	int i;
+
+	dump_access_lock();
+	list_for_each_entry_reverse(ops, &regdump_ops_list, node)
+		if (ops->enable) {
+			region = ops->regions;
+			buf = ops->buffer;
+			for (i = 0; i < ops->reg_nums; i ++, region ++) {
+				val = regdump_read_region(ops, region);
+				memcpy(buf, &val, region->size);
+				buf += region->size;
+			}
+		}
+	dump_access_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dump_reg_to_mem);
+
+int dump_reg_to_console(void)
+{
+	struct regdump_ops *ops;
+	struct regdump_region *region;
+	unsigned long val;
+	int i;
+
+	dump_access_lock();
+	list_for_each_entry_reverse(ops, &regdump_ops_list, node)
+	{
+		printk(KERN_EMERG "======== dump %s start ========\n",
+				ops->dev_name);
+		if (ops->enable) {
+			region = ops->regions;
+			for (i = 0; i < ops->reg_nums; i++, region++) {
+				val = regdump_read_region(ops, region);
+				printk(KERN_ERR"%-26s: 0x%lx: 0x%08lx\n",
+				region->name, ops->phy_base + region->start,
+				val);
+			}
+		}
+		printk(KERN_EMERG "======== dump %s end ========\n",
+				ops->dev_name);
+	}
+	dump_access_unlock();
+
+	return 0;
+}
+
+
+DEFINE_MUTEX(dev_mutex);
+static int regdump_generic_open(struct inode *inode, struct file *filp)
+{
+	filp->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t
+dev_reg_enable_read(struct file *filp, char __user *ubuf, size_t cnt,
+		    loff_t *ppos)
+{
+	struct regdump_ops *ops= filp->private_data;
+	char buf[2];
+	int ret;
+
+	mutex_lock(&dev_mutex);
+	buf[0] = ops->enable ? '1' : '0';
+	mutex_unlock(&dev_mutex);
+	buf[1] = '\n';
+
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);
+
+	return ret;
+}
+
+static ssize_t
+dev_reg_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,
+		     loff_t *ppos)
+{
+	struct regdump_ops *ops= filp->private_data;
+	char buf[64];
+	unsigned long val;
+	int ret;
+
+	if (cnt >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(&buf, ubuf, cnt))
+		return -EFAULT;
+
+	buf[cnt] = 0;
+
+	ret = strict_strtoul(buf, 10, &val);
+	if (ret < 0)
+		return ret;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	*ppos += cnt;
+	ops->enable = val;
+
+	return cnt;
+}
+
+static const struct file_operations dev_enable_fops = {
+	.open = regdump_generic_open,
+	.read = dev_reg_enable_read,
+	.write = dev_reg_enable_write,
+};
+
+static ssize_t format_reg(struct regdump_ops *ops, char *buf, size_t cnt)
+{
+	unsigned long val;
+	int i, ret, n = 0, limit;
+	struct regdump_region *region;
+
+	n = snprintf(buf, REGDUMP_READLINE_NUM, "\nDev: %s\n", ops->dev_name);
+	if (n < 0)
+		return n;
+
+	cnt -= n;
+	region = ops->regions;
+	for (i = 0; i < ops->reg_nums; i ++, region ++) {
+		val = regdump_read_region(ops, region);
+		limit = (cnt > REGDUMP_READLINE_NUM) ?
+			REGDUMP_READLINE_NUM : cnt;
+		ret = snprintf(buf + n, limit, "%s: 0x%08lx\n",
+				region->name, val);
+		if (ret < 0)
+			return ret;
+
+		n += ret;
+		cnt -= ret;
+	}
+
+	return n;
+}
+
+static ssize_t
+dev_reg_read(struct file *filp, char __user *ubuf, size_t cnt,
+		    loff_t *ppos)
+{
+	struct regdump_ops *ops= filp->private_data;
+	int ret;
+	static void *buf = NULL;
+	static int buf_sz = 0;
+
+	if (!ops->enable) {
+		pr_err("Dev %s regdump not enabled!\n", ops->dev_name);
+		return 0;
+	}
+
+	if (!buf) {
+		buf_sz = REGDUMP_READLINE_NUM * (ops->reg_nums + 1);
+		buf = kmalloc(buf_sz, GFP_KERNEL);
+		if (!buf)
+			return -ENOMEM;
+
+		buf_sz = format_reg(ops, buf, buf_sz);
+		if (buf_sz < 0) {
+			kfree(buf);
+			return buf_sz;
+		}
+	}
+
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, buf_sz);
+
+	if (ret <= 0) {
+		kfree(buf);
+		buf = NULL;
+	}
+
+	return ret;
+}
+
+static const struct file_operations dev_regdump_fops = {
+	.open = regdump_generic_open,
+	.read = dev_reg_read,
+};
+
+static void *
+r_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	struct regdump_ops *ops = v;
+
+	(*pos)++;
+
+	list_for_each_entry_continue(ops, &regdump_ops_list, node)
+		if (ops->enable)
+			return ops;
+
+	return NULL;
+}
+
+static void *r_start(struct seq_file *m, loff_t *pos)
+{
+	struct regdump_ops *ops;
+	loff_t l;
+
+	mutex_lock(&dev_mutex);
+	ops = list_entry(&regdump_ops_list, struct regdump_ops, node);
+	for (l = 0; l <= *pos; ) {
+		ops = r_next(m, ops, &l);
+		if (!ops)
+			break;
+	}
+
+	return ops;
+}
+
+static void r_stop(struct seq_file *m, void *p)
+{
+	mutex_unlock(&dev_mutex);
+}
+
+static int r_show(struct seq_file *m, void *v)
+{
+	struct regdump_ops *ops = v;
+
+	if (!ops)
+		return 0;
+
+	seq_printf(m, "%s\n", ops->dev_name);
+
+	return 0;
+}
+
+static const struct seq_operations show_regdump_seq_ops = {
+	.start		= r_start,
+	.next		= r_next,
+	.stop		= r_stop,
+	.show		= r_show,
+};
+
+static int regdump_seqfile_generic_open(struct inode *inode, struct file *file)
+{
+	const struct seq_operations *seq_ops;
+
+	seq_ops = inode->i_private;
+	return seq_open(file, seq_ops);
+}
+
+static const struct file_operations show_regdump_fops = {
+	.open		= regdump_seqfile_generic_open,
+	.read		= seq_read,
+	.release	= seq_release,
+	.llseek		= seq_lseek,
+};
+
+static int d_show(struct seq_file *m, void *v)
+{
+	struct regdump_ops *ops = v;
+	int ret;
+
+	if (!ops)
+		return 0;
+
+	ret = format_reg(ops, m->buf, m->size);
+	if (ret < 0)
+		return ret;
+
+	m->count += ret;
+	return 0;
+}
+
+static const struct seq_operations dump_all_regs_seq_ops = {
+	.start		= r_start,
+	.next		= r_next,
+	.stop		= r_stop,
+	.show		= d_show,
+};
+
+static const struct file_operations dump_allregs_fops = {
+	.open		= regdump_seqfile_generic_open,
+	.read		= seq_read,
+	.release	= seq_release,
+	.llseek		= seq_lseek,
+};
+
+static ssize_t
+regdump_all_status(struct file *filp, char __user *ubuf, size_t cnt,
+		    loff_t *ppos)
+{
+	struct regdump_ops *ops;
+	char buf[2];
+	int enable = 1, ret;
+
+	mutex_lock(&dev_mutex);
+	list_for_each_entry_reverse(ops, &regdump_ops_list, node)
+		if (!ops->enable) {
+			enable = 0;
+			break;
+		}
+	mutex_unlock(&dev_mutex);
+
+	buf[0] = enable ? '1' : '0';
+	buf[1] = '\n';
+
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);
+
+	return ret;
+}
+
+static ssize_t
+regdump_all_enable(struct file *filp, const char __user *ubuf, size_t cnt,
+		     loff_t *ppos)
+{
+	struct regdump_ops *ops;
+	char buf[64];
+	unsigned long val;
+	int ret;
+
+	if (cnt >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(&buf, ubuf, cnt))
+		return -EFAULT;
+
+	buf[cnt] = 0;
+
+	ret = strict_strtoul(buf, 10, &val);
+	if (ret < 0)
+		return ret;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	*ppos += cnt;
+	mutex_lock(&dev_mutex);
+	list_for_each_entry_reverse(ops, &regdump_ops_list, node)
+		ops->enable = val;
+	mutex_unlock(&dev_mutex);
+
+	return cnt;
+}
+
+static const struct file_operations enable_regdump_fops = {
+	.read = regdump_all_status,
+	.write = regdump_all_enable,
+};
+
+/**
+ * register_regdump_ops - Register a set of system core operations.
+ * @ops: System core operations to register.
+ */
+int register_regdump_ops(struct regdump_ops *ops)
+{
+	int i, total_sz = 0;
+	struct dentry *d_regdump, *d_dev;
+
+	mutex_lock(&regdump_ops_lock);
+	for (i = 0; i < ops->reg_nums; i ++)
+		total_sz += ops->regions[i].size;
+
+	if (!total_sz) {
+		ops->buffer = kmalloc(total_sz, GFP_KERNEL);
+		if (!ops->buffer) {
+			printk(KERN_ERR "REGDUMP: fail to alloc mem for %s\n",
+					ops->dev_name);
+			mutex_unlock(&regdump_ops_lock);
+			return -ENOMEM;
+		}
+	} else
+		ops->buffer = NULL;
+	ops->enable = 1;
+
+	list_add_tail(&ops->node, &regdump_ops_list);
+	mutex_unlock(&regdump_ops_lock);
+
+	d_regdump = regdump_init_dentry();
+	if (!d_regdump)
+		return -ENODEV;
+
+	if (!ops->dev_name) {
+		pr_warning("Regdump: need specify name\n");
+		return -EINVAL;
+	}
+
+	d_dev = debugfs_create_dir(ops->dev_name, d_regdump);
+	if (!d_dev) {
+		pr_warning("Could not create debugfs directory \'%s\'",
+				ops->dev_name);
+		return -EINVAL;
+	}
+	debugfs_create_file("enable", 0644, d_dev,
+			ops, &dev_enable_fops);
+	debugfs_create_file("dump", 0444, d_dev,
+			ops, &dev_regdump_fops);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(register_regdump_ops);
+
+/**
+ * unregister_regdump_ops - Unregister a set of system core operations.
+ * @ops: System core operations to unregister.
+ */
+int unregister_regdump_ops(struct regdump_ops *ops)
+{
+	mutex_lock(&regdump_ops_lock);
+	if (ops->buffer)
+		kfree(ops->buffer);
+
+	list_del(&ops->node);
+	mutex_unlock(&regdump_ops_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(unregister_regdump_ops);
+
+static __init int regdump_init_debugfs(void)
+{
+	struct dentry *d_regdump;
+	struct dentry *dentry;
+
+	d_regdump = regdump_init_dentry();
+	dentry = debugfs_create_file("current_enabled_devices", 0444, d_regdump,
+			(void *)&show_regdump_seq_ops, &show_regdump_fops);
+	if(!dentry) {
+		pr_err("Failed to create current_enabled_devices debug file\n");
+		return -ENOMEM;
+	} 
+	dentry = debugfs_create_file("dump_all", 0444, d_regdump,
+			(void *)&dump_all_regs_seq_ops, &dump_allregs_fops);
+	if(!dentry) {
+		pr_err("Failed to create dump_all debug file\n");
+		return -ENOMEM;
+	} 
+	dentry = debugfs_create_file("enable_all", 0644, d_regdump,
+			NULL, &enable_regdump_fops);
+	if(!dentry) {
+		pr_err("Failed to create enable_all debug file\n");
+		return -ENOMEM;
+	} 
+
+	return 0;
+}
+
+fs_initcall(regdump_init_debugfs);
diff --git a/drivers/base/regmap/regmap-irq.c b/drivers/base/regmap/regmap-irq.c
index 1befaa7a..ece80079 100644
--- a/drivers/base/regmap/regmap-irq.c
+++ b/drivers/base/regmap/regmap-irq.c
@@ -18,6 +18,9 @@
 #include <linux/slab.h>
 
 #include "internal.h"
+#ifdef CONFIG_MFD_88PM805
+#include <linux/delay.h>
+#endif
 
 struct regmap_irq_chip_data {
 	struct mutex lock;
@@ -58,11 +61,20 @@ static void regmap_irq_sync_unlock(struct irq_data *data)
 	 * suppress pointless writes.
 	 */
 	for (i = 0; i < d->chip->num_regs; i++) {
-		ret = regmap_update_bits(d->map, d->chip->mask_base + i,
+		if (d->chip->mask_invert)
+			ret = regmap_update_bits(d->map, d->chip->mask_base + i,
+					 d->mask_buf_def[i], ~d->mask_buf[i]);
+		else
+			ret = regmap_update_bits(d->map, d->chip->mask_base + i,
 					 d->mask_buf_def[i], d->mask_buf[i]);
 		if (ret != 0)
 			dev_err(d->map->dev, "Failed to sync masks in %x\n",
 				d->chip->mask_base + i);
+	/* need to wait between 32K register for 88PM805 */
+#ifdef CONFIG_MFD_88PM805
+		if (!strcmp("88pm805", d->chip->name))
+		msleep(1);
+#endif
 	}
 
 	mutex_unlock(&d->lock);
@@ -192,6 +204,10 @@ int regmap_add_irq_chip(struct regmap *map, int irq, int irq_flags,
 	if (!d)
 		return -ENOMEM;
 
+	*data = d;
+
+	*data = d;
+
 	d->status_buf = kzalloc(sizeof(unsigned int) * chip->num_regs,
 				GFP_KERNEL);
 	if (!d->status_buf)
@@ -224,12 +240,22 @@ int regmap_add_irq_chip(struct regmap *map, int irq, int irq_flags,
 	/* Mask all the interrupts by default */
 	for (i = 0; i < chip->num_regs; i++) {
 		d->mask_buf[i] = d->mask_buf_def[i];
-		ret = regmap_write(map, chip->mask_base + i, d->mask_buf[i]);
+		if (chip->mask_invert)
+			ret = regmap_write(map, chip->mask_base + i,
+					~d->mask_buf[i]);
+		else
+			ret = regmap_write(map, chip->mask_base + i,
+					d->mask_buf[i]);
 		if (ret != 0) {
 			dev_err(map->dev, "Failed to set masks in 0x%x: %d\n",
 				chip->mask_base + i, ret);
 			goto err_alloc;
 		}
+/* need to wait between 32K register for 88PM805 */
+#ifdef CONFIG_MFD_88PM805
+		if (!strcmp("88pm805", chip->name))
+			msleep(1);
+#endif
 	}
 
 	/* Register them with genirq */
diff --git a/drivers/base/regmap/regmap.c b/drivers/base/regmap/regmap.c
index bb80853f..167959e2 100644
--- a/drivers/base/regmap/regmap.c
+++ b/drivers/base/regmap/regmap.c
@@ -558,7 +558,13 @@ EXPORT_SYMBOL_GPL(regmap_write);
 int regmap_raw_write(struct regmap *map, unsigned int reg,
 		     const void *val, size_t val_len)
 {
-	int ret;
+	int ret, regnum;
+
+#if !defined(CONFIG_GOYA_WIFI)
+	for (regnum = 0xea; regnum <= 0xed; regnum++) {
+		WARN(reg == regnum, "---------0x%x be changed----------\n", regnum);
+	}
+#endif
 
 	mutex_lock(&map->lock);
 
diff --git a/drivers/battery/88pm80x_fuelgauge.c b/drivers/battery/88pm80x_fuelgauge.c
new file mode 100755
index 00000000..5cf61336
--- /dev/null
+++ b/drivers/battery/88pm80x_fuelgauge.c
@@ -0,0 +1,1860 @@
+/*
+ * Battery driver for Marvell 88PM80x PMIC
+ *
+ * Copyright (c) 2012 Marvell International Ltd.
+ * Author:	Yi Zhang <yizhang@marvell.com>
+ * Author:	Jett Zhou <jtzhou@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/88pm822.h>
+#include <linux/mfd/88pm80x.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/battery/fuelgauge/88pm80x_fg.h>
+#if defined(CONFIG_MACH_GOLDEN) || defined(CONFIG_MACH_CS05) \
+	|| defined(CONFIG_MACH_DEGAS)
+#include <linux/battery/fuelgauge/88pm80x_table_golden.h>
+#elif defined(CONFIG_MACH_GOYA)
+#include <linux/battery/fuelgauge/88pm80x_table_goya.h>
+#else
+#include <linux/battery/fuelgauge/88pm80x_table.h>  //use default one
+#endif
+
+#include <linux/battery/sec_fuelgauge.h>
+
+static int pm80x_battery_suspend(struct sec_fg_info *info);
+static int pm80x_battery_resume(struct sec_fg_info *info);
+
+static void get_batt_status(struct sec_fg_info *info)
+{
+	union power_supply_propval value;
+
+	psy_do_property("sec-charger", get,
+			POWER_SUPPLY_PROP_STATUS, value);
+	info->bat_params.status = value.intval;
+}
+
+static int get_power_status(struct sec_fg_info *info)
+{
+	union power_supply_propval value;
+
+#if defined(CONFIG_MACH_GOLDEN)
+	psy_do_property("sec-charger", get,
+			POWER_SUPPLY_PROP_POWER_STATUS, value);
+#else
+	/*
+	 * for Goya rev0.4:
+	 * psy_do_property("sec-charger", get,
+	 * POWER_SUPPLY_PROP_POWER_STATUS, value);
+	 */
+	struct power_supply *psy;
+	int ret;
+	psy = get_power_supply_by_name("sec-charger");
+	if (!psy) {
+		pr_err("%s: Fail to find psy sec-charger\n", __func__);
+		/* report discharging */
+		value.intval = 0;
+		return value.intval;
+	} else {
+		ret = psy->get_property(psy, POWER_SUPPLY_PROP_POWER_STATUS, &(value));
+		if (ret < 0) {
+			pr_debug("%s: Fail to get psy sec-charger\n", __func__);
+			goto goyav05;
+		} else
+			return value.intval;
+	}
+
+goyav05:
+	/* for Goya rev0.5 */
+	pr_debug("##############for Goya rev0.5############\n");
+	psy_do_property("sec-charger", get,
+			POWER_SUPPLY_PROP_CHARGE_NOW, value);
+	pr_debug("########charger[0x33].1 = 0x%x\n", value.intval);
+#endif
+
+	return value.intval;
+}
+
+static void get_batt_present(fuelgauge_variable_t *fuelgauge)
+{
+	int ret, volt;
+	unsigned char buf[2];
+	/*
+	 * on Goldenve, the battery NTC resistor is 2.4Kohm +-6%
+	 * so, with the bias current = 76uA,
+	 * if the GPADC0 voltage is in [171.456mV, 193.344mV],
+	 * we think battery is present when the voltage is in [140mV, 220mV]
+	 * for redundancy, else not;
+	 */
+#if defined(CONFIG_MACH_GOLDEN) || defined(CONFIG_MACH_CS05) \
+	|| defined(CONFIG_MACH_DEGAS)
+	ret = regmap_bulk_read(fuelgauge->info.chip->subchip->regmap_gpadc,
+			       PM800_GPADC0_MEAS1, buf, 2);
+	if (ret < 0) {
+		dev_err(fuelgauge->info.dev,
+			"Attention: failed to get battery present voltage!\n");
+		fuelgauge->info.bat_params.present = 1;
+		return;
+	}
+
+	volt = ((buf[0] & 0xff) << 4) | (buf[1] & 0x0f);
+	dev_dbg(fuelgauge->info.dev,
+		"%s: volt value = 0x%x\n", __func__, volt);
+	/* tbat = value * 1.4 *1000/(2^12) */
+	volt = ((volt & 0xfff) * 7 * 100) >> 11;
+	dev_dbg(fuelgauge->info.dev,
+		"%s: VF voltage = %dmV\n", __func__, volt);
+
+	if ((volt <= 220) && (volt >= 140))
+		fuelgauge->info.bat_params.present = 1;
+	else
+		fuelgauge->info.bat_params.present = 0;
+#elif defined(GONFIG_MACH_GOYA)
+	fuelgauge->info.bat_params.present = 1;
+#else
+	fuelgauge->info.bat_params.present = 1;
+#endif
+}
+
+
+static int get_gpadc(struct sec_fg_info *info, int bias_current)
+{
+	int ret, tbat, data;
+	unsigned char buf[2];
+	int batt_gp_bias, batt_gp_meas;
+
+	switch (info->chip->batt_gp_nr) {
+	case PM822_GPADC0:
+		batt_gp_bias = PM800_GPADC_BIAS1;
+		batt_gp_meas = PM800_GPADC0_MEAS1;
+		break;
+	case PM822_GPADC1:
+		batt_gp_bias = PM800_GPADC_BIAS2;
+		batt_gp_meas = PM800_GPADC1_MEAS1;
+		break;
+	case PM822_GPADC2:
+		batt_gp_bias = PM800_GPADC_BIAS3;
+		batt_gp_meas = PM800_GPADC2_MEAS1;
+		break;
+	case PM822_GPADC3:
+		batt_gp_bias = PM800_GPADC_BIAS4;
+		batt_gp_meas = PM800_GPADC3_MEAS1;
+		break;
+	default:
+		dev_err(info->chip->dev, "get GPADC failed!\n");
+		return -EINVAL;
+
+	}
+
+	regmap_read(info->chip->subchip->regmap_gpadc, batt_gp_bias, &data);
+	data &= 0xF0;
+	data |= bias_current;
+	regmap_write(info->chip->subchip->regmap_gpadc, batt_gp_bias, data);
+
+	ret = regmap_bulk_read(info->chip->subchip->regmap_gpadc,
+			       batt_gp_meas, buf, 2);
+	if (ret < 0) {
+		dev_err(info->dev, "Attention: failed to get battery tbat!\n");
+		return -EINVAL;
+	}
+
+	tbat = ((buf[0] & 0xff) << 4) | (buf[1] & 0x0f);
+	dev_dbg(info->dev, "%s: tbat value = 0x%x\n", __func__, tbat);
+	/* tbat = value * 1.4 *1000/(2^12) */
+	tbat = ((tbat & 0xfff) * 7 * 100) >> 11;
+	dev_dbg(info->dev, "%s: tbat voltage = %dmV\n", __func__, tbat);
+
+	return tbat;
+}
+
+static void get_batt_temp(struct sec_fg_info *info)
+{
+	int temp, tbat, i;
+	/* bias register value */
+	unsigned int bias_value[5] = {0x06, 0x0C, 0x03, 0x02, 0x01};
+	/* bias current value: mA; _MUST_ be aligned with bias_value */
+	unsigned int bias_current[5] = {31, 61, 16, 11, 6};
+
+	/*
+	 *1) set bias as 31uA firstly for root remp environment,
+	 *2) check the voltage whether it's in [0.3V, 1.25V];
+	 *   if yes, tbat = tbat/31; break;
+	 *   else
+	 *   set bias as 61uA/16uA/11uA/6uA...
+	 *   for lower or higher temp environment.
+	 */
+	for(i = 0; i < 5; i++) {
+		tbat = get_gpadc(info, bias_value[i]);
+		if ((tbat > 300) && (tbat < 1250)) {
+			tbat *= 10000;
+			tbat /= bias_current[i];
+			break;
+		}
+	}
+
+	/* ABNORMAL: report the fake value 25C */
+	if (i == 5) {
+		info->bat_params.temp = 25;
+		dev_err(info->dev, "Fake raw temperature is %dC\n", info->bat_params.temp);
+		return;
+	}
+	dev_dbg(info->dev, "%s: tbat resistor = %dKohm, i = %d\n", __func__, tbat, i);
+
+	/* [-25 ~ 65] */
+	for (i = 0; i < 91; i++) {
+		if (tbat >= temperature_table[i]) {
+			temp = -25 + i;
+			break;
+		}
+	}
+	if (i == 91) /* max temperature */
+		temp = 65;
+	dev_dbg(info->dev, "raw temperature is %dC\n", temp);
+#if defined(CONFIG_MACH_GOYA_USA)
+	info->bat_params.temp = temp < 50 ? temp - 1 : temp;
+#else
+	info->bat_params.temp = temp < 50 ? temp - 3 : temp;
+#endif
+}
+
+/*
+ * register 1 bit[7:0] -- bit[11:4] of measured value of voltage
+ * register 0 bit[3:0] -- bit[3:0] of measured value of voltage
+ */
+static int get_batt_vol(struct sec_fg_info *info,
+			int *data, int active)
+{
+	int ret;
+	unsigned char buf[2];
+	if (!data)
+		return -EINVAL;
+
+	if (active) {
+		ret = regmap_bulk_read(info->chip->subchip->regmap_gpadc,
+				       PM800_VBAT_AVG, buf, 2);
+		if (ret < 0)
+			return ret;
+	} else {
+		ret = regmap_bulk_read(info->chip->subchip->regmap_gpadc,
+				       PM800_VBAT_SLP, buf, 2);
+		if (ret < 0)
+			return ret;
+	}
+
+	*data = ((buf[0] & 0xff) << 4) | (buf[1] & 0x0f);
+	dev_dbg(info->dev,
+		"%s buf[0]:[0x42: 0x%x], buf[1]:[0x43: 0x%x], data: 0x%x\n",
+		__func__, buf[0], buf[1], *data);
+	/* measure(mv) = value * 4 * 1.4 *1000/(2^12) */
+	*data = ((*data & 0xfff) * 7 * 100) >> 9;
+	dev_dbg(info->dev, "+++++++>%s: battery voltage = %d\n", __func__, *data);
+	/* Ccalibrate vbat measurement only for un-trimed PMIC
+	 * VBATmeas = VBATreal * gain + offset, so VBATreal = (VBATmeas - offset)/ gain;
+	 * According to our test of vbat_sleep in bootup, the calculated gain as below:
+	 * for aruba 0.1, offset is -13.4ma, gain is 1.008.
+	 * For Aruba 0.2, offset=-0.0087V and gain=1.007.
+	 */
+	/*
+	 *data = (*data + 13) * 1000/1008;
+	 *data = (*data + 9) * 1000/1007;
+	 *data = (*data + 9) * 1000/1002;
+	 */
+
+	return 0;
+}
+
+/*
+ * Calculate the rtot according to different ib and temp info, we think about
+ * ib is y coordinate, temp is x coordinate to do interpolation.
+ * eg. dischg case, ib are 300/500/700/1000/1500mA, temp are -5/10/25/40C.
+ * We divide them into 3 kind of case to interpolate, they are 1/2/4 point
+ * case, the refered point is top-right.
+ *
+ *        |-5C       |10C        |25C         |40C
+ *        |          |           |            |    1 point
+ * -------|----------|-----------|------------|------------- 1500mA
+ *        |          |           | 4 point    |    2 point
+ * -------|----------|-----------|------------|------------- 1000mA
+ *        |          |           |            |
+ * -------|----------|-----------|------------|------------- 700mA
+ *        |          |           |            |
+ * -------|----------|-----------|------------|------------- 500mA
+ *        |          |           |            |
+ * -------|----------|-----------|------------|------------- 300mA
+ *        |          |           |            |
+ *        |	     |           |            |
+ */
+
+static int calc_resistor(struct sec_fg_info *info, int temp, int ib)
+{
+	int x1, x2;
+	int y1, y2;
+	int p_num = 4;
+	int i, j;
+	static int chg_status;
+	static int PWR_Rdy_status;
+
+	get_batt_status(info);
+	chg_status = info->bat_params.status;
+
+	PWR_Rdy_status = get_power_status(info);
+
+	dev_dbg(info->dev, "-----> %s ib : %d temp: %d \n", __func__, ib, temp);
+
+	if ((chg_status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+		(chg_status == POWER_SUPPLY_STATUS_UNKNOWN) ||
+		(chg_status == POWER_SUPPLY_STATUS_FULL) ||
+		(PWR_Rdy_status == POWER_SUPPLY_PWR_RDY_FALSE)) {
+		for(i = 0; i < 6; i++ ) {
+			if (ib <= dischg_ib[i])
+				break;
+		}
+		if (i == 0 || i == 6) {
+			p_num = 2;
+			if (i == 6)
+				i --;
+		}
+		for(j = 0; j < 5; j++) {
+			if (temp <= -20 + j*15)
+				break;
+		}
+		if ((j == 0 || j == 5) ) {
+			if (j == 5)
+				j --;
+			if (p_num == 2) {
+				/* 1 point case */
+				p_num = 1;
+				if (v3 == 100)
+					rtot = *(dis_chg_rtot[i][j] + 99);
+				else
+					rtot = *(dis_chg_rtot[i][j] + v3);
+
+			} else {
+				/* 2 point case , between two ib */
+				p_num = 2;
+				if (v3 == 100)
+					y1 = *(dis_chg_rtot[i-1][j] + 99);
+				else
+					y1 = *(dis_chg_rtot[i-1][j] + v3);
+				x1 = dischg_ib[i-1];
+				if (v3 == 100)
+					y2 = *(dis_chg_rtot[i][j] + 99);
+				else
+					y2 = *(dis_chg_rtot[i][j] + v3);
+				x2 = dischg_ib[i];
+				rtot = y1 + (y2 - y1) * (ib - x1)/(x2-x1);
+			}
+			dev_dbg(info->dev, "1 p_num: %d i: %d j: %d \n",
+				p_num, i, j);
+		} else if(p_num == 2) {
+			/* 2 point case, between two temp */
+			dev_dbg(info->dev, "2 p_num: %d i: %d j: %d \n",
+				p_num, i, j);
+			if (v3 == 100)
+				y1 = *(dis_chg_rtot[i][j-1] + 99);
+			else
+				y1 = *(dis_chg_rtot[i][j-1] + v3);
+			x1 = (j - 1) * 15 + (-20);
+			if (v3 == 100)
+				y2 = *(dis_chg_rtot[i][j] + 99);
+			else
+				y2 = *(dis_chg_rtot[i][j] + v3);
+			x2 = j * 15 + (-20);
+			rtot = y1 + (y2 - y1) * (temp - x1)/(x2-x1);
+			dev_dbg(info->dev,
+				"x1: %d, y1: %d, x2: %d, y2: %d \n",
+				x1, y1, x2, y2 );
+		}
+		if (p_num == 4) {
+			int rtot1, rtot2;
+
+			dev_dbg(info->dev, "3 p_num: %d i: %d j: %d \n",
+				p_num, i, j);
+			// step1, interpolate two ib in low temp
+			if (v3 == 100)
+				y1 = *(dis_chg_rtot[i-1][j-1] + 99);
+			else
+				y1 = *(dis_chg_rtot[i-1][j-1] + v3);
+			x1 = dischg_ib[i-1];
+			if (v3 == 100)
+				y2 = *(dis_chg_rtot[i][j-1] + 99);
+			else
+				y2 = *(dis_chg_rtot[i][j-1] + v3);
+			x2 = dischg_ib[i];
+			dev_dbg(info->dev,
+				"step1 x1: %d , y1, %d , x2 : %d y2: %d \n",
+				x1, y1, x2, y2);
+			rtot1 = y1 + (y2 - y1) * (ib - x1)/(x2-x1);
+
+			// step2, interpolate two ib in high temp
+			if (v3 == 100)
+				y1 = *(dis_chg_rtot[i-1][j] + 99);
+			else
+				y1 = *(dis_chg_rtot[i-1][j] + v3);
+			x1 = dischg_ib[i-1];
+			if (v3 == 100)
+				y2 = *(dis_chg_rtot[i][j] + 99);
+			else
+				y2 = *(dis_chg_rtot[i][j] + v3);
+			x2 = dischg_ib[i];
+			dev_dbg(info->dev,
+				"step2 x1: %d , y1, %d , x2 : %d y2: %d \n",
+				x1, y1, x2, y2);
+			rtot2 = y1 + (y2 - y1) * (ib - x1)/(x2-x1);
+
+			// step3
+			y1 = rtot1;
+			x1 = (j - 1) * 15 + (-20);
+			y2 = rtot2;
+			x2 = j * 15 + (-20);
+			rtot = y1 + (y2 - y1) * (temp - x1)/(x2-x1);
+			dev_dbg(info->dev,
+				"step3: rtot : %d, rtot1: %d, rtot2: %d \n",
+				rtot, rtot1, rtot2);
+		}
+
+	} else if (chg_status == POWER_SUPPLY_STATUS_CHARGING) {
+#if defined (CONFIG_MACH_GOLDEN) || defined(CONFIG_MACH_CS05) \
+		|| defined(CONFIG_MACH_DEGAS)
+		for(i = 0; i < 5; i++ ) {
+			if (ib <= chg_ib[i])
+				break;
+		}
+		if (i == 0 || i == 5) {
+			p_num = 2;
+			if (i == 5)
+				i --;
+		}
+#else /* for goya */
+		for(i = 0; i < 4; i++ ) {
+			if (ib <= chg_ib[i])
+				break;
+		}
+		if (i == 0 || i == 4) {
+			p_num = 2;
+			if (i == 4)
+				i --;
+		}
+#endif
+		for(j = 0; j < 4; j++) {
+			if (temp <= -5 + j*15)
+				break;
+		}
+
+		if ((j == 0 || j == 4) ) {
+			/* Need double check */
+			if (j == 4)
+				j --;
+
+			if (p_num == 2) {
+				/* 1 point case */
+				p_num = 1;
+				if (v3 == 100)
+					rtot = *(chg_rtot[i][j] + 99);
+				else
+					rtot = *(chg_rtot[i][j] + v3);
+			} else {
+				/* 2 point case , between two ib */
+				p_num = 2;
+				if (v3 == 100)
+					y1 = *(chg_rtot[i-1][j] + 99);
+				else
+					y1 = *(chg_rtot[i-1][j] + v3);
+				x1 = chg_ib[i-1];
+				if (v3 == 100)
+					y2 = *(chg_rtot[i][j] + 99);
+				else
+					y2 = *(chg_rtot[i][j] + v3);
+				x2 = chg_ib[i];
+				rtot = y1 + (y2 - y1) * (ib - x1)/(x2-x1);
+			}
+			dev_dbg(info->dev, "1 p_num: %d i: %d j: %d \n",
+				p_num, i, j);
+		} else if(p_num == 2) {
+			/* 2 point case, between two temp */
+			dev_dbg(info->dev, "2 p_num: %d i: %d j: %d \n",
+				p_num, i, j);
+			if (v3 == 100)
+				y1 = *(chg_rtot[i][j-1] + 99);
+			else
+				y1 = *(chg_rtot[i][j-1] + v3);
+			x1 = (j - 1) * 15 + (-5);
+			if (v3 == 100)
+				y2 = *(chg_rtot[i][j] + 99);
+			else
+				y2 = *(chg_rtot[i][j] + v3);
+			x2 = j * 15 + (-5);
+			rtot = y1 + (y2 - y1) * (temp - x1)/(x2-x1);
+			dev_dbg(info->dev,
+				"x1: %d, y1: %d, x2: %d, y2: %d \n",
+				x1, y1, x2, y2 );
+		}
+
+		if (p_num == 4) {
+			int rtot1, rtot2;
+
+			dev_dbg(info->dev, "3 p_num: %d i: %d j: %d \n",
+				p_num, i, j);
+			// step1, interpolate two ib in low temp
+			if (v3 == 100)
+				y1 = *(chg_rtot[i-1][j-1] + 99);
+			else
+				y1 = *(chg_rtot[i-1][j-1] + v3);
+			x1 = chg_ib[i-1];
+			if (v3 == 100)
+				y2 = *(chg_rtot[i][j-1] + 99);
+			else
+				y2 = *(chg_rtot[i][j-1] + v3);
+			x2 = chg_ib[i];
+			dev_dbg(info->dev,
+				"step1 x1: %d , y1, %d , x2 : %d y2: %d \n",
+				x1, y1, x2, y2);
+			rtot1 = y1 + (y2 - y1) * (ib - x1)/(x2-x1);
+
+			// step2, interpolate two ib in high temp
+			if (v3 == 100)
+				y1 = *(chg_rtot[i-1][j] + 99);
+			else
+				y1 = *(chg_rtot[i-1][j] + v3);
+			x1 = chg_ib[i-1];
+			if (v3 == 100)
+				y2 = *(chg_rtot[i][j] + 99);
+			else
+				y2 = *(chg_rtot[i][j] + v3);
+			x2 = chg_ib[i];
+			dev_dbg(info->dev, "step2 x1: %d , y1, %d , x2 : %d y2: %d \n",
+				x1, y1, x2, y2);
+			rtot2 = y1 + (y2 - y1) * (ib - x1)/(x2-x1);
+
+			// step3
+			y1 = rtot1;
+			x1 = (j - 1) * 15 + (-5);
+			y2 = rtot2;
+			x2 = j * 15 + (-5);
+			rtot = y1 + (y2 - y1) * (temp - x1)/(x2-x1);
+			dev_dbg(info->dev,
+				"step3: rtot : %d, rtot1: %d, rtot2: %d \n",
+				rtot, rtot1, rtot2);
+		}
+	}
+	dev_dbg(info->dev, "<-----%s r_tot : %d p_num: %d \n",
+		__func__, rtot, p_num);
+	return rtot;
+}
+
+/* PM800_RTC_MISC5:E7[1] and PM800_RTC_CONTROL:D0[3:2] can be used */
+static void fg_store(struct sec_fg_info *info)
+{
+	int data;
+
+	deltaR_to_store = r_off - r_off_initial;
+	//deltaR_to_store = 0; // uncomment to reset the value of deltaR
+	deltaR_to_store = (deltaR_to_store >= 0) ? min(deltaR_to_store, 127) : max(deltaR_to_store, -128);
+
+	if (v3 < 0)
+		v3 = 0;
+	else if (v3 > 100)
+		v3 = 100;
+	else
+		v3 &= 0x7F;
+
+	regmap_read(info->chip->regmap, PM800_USER_DATA5, &data);
+	data = (data & 0x80) | v3;
+	regmap_write(info->chip->regmap, PM800_USER_DATA5, data);
+
+	/* v1 is Volt with factor(2^20) */
+	v1_mv = v1 >> 10;
+	/* v1_mv resolution is 3mV */
+	v1_mv /= 3;
+	v1_mv = (v1_mv >= 0) ? min(v1_mv, 31) : max(v1_mv, -32);
+	v1_mv &= 0x3F;
+	//regmap_write(info->chip->regmap, PM800_USER_DATA6, v1_mv);
+
+	/* v2 is Volt with factor(2^20) */
+	v2_mv = v2 >> 10;
+	v2_mv /= 3;
+	v2_mv = (v2_mv >= 0) ? min(v2_mv, 31) : max(v2_mv, -32);
+	v2_mv &= 0x3F;
+	regmap_write(info->chip->regmap, 0xDD, v1_mv);
+	regmap_write(info->chip->regmap, 0xDE, v2_mv);
+	regmap_write(info->chip->regmap, 0xDF, deltaR_to_store);
+	regmap_read(info->chip->regmap, 0xDF, &data);
+	data = v3_res % factor2 /100;
+	data &= 0x0F;
+	regmap_write(info->chip->regmap, 0xE0, data);
+
+	dev_dbg(info->dev, "%s, writing to 0xDD: 0x%x \n", __func__, v1_mv);
+	dev_dbg(info->dev, "%s, writing to 0xDE: 0x%x \n", __func__, v2_mv);
+	dev_dbg(info->dev, "%s, writing to 0xDF: 0x%x \n", __func__, deltaR_to_store);
+	dev_dbg(info->dev, "%s, writing to 0xE0: 0x%x \n", __func__, data);
+
+	regmap_read(info->chip->regmap, 0xDD, &data);
+	dev_dbg(info->dev, "%s, reading of 0xDD: 0x%x \n", __func__, data);
+	regmap_read(info->chip->regmap, 0xDE, &data);
+	dev_dbg(info->dev, "%s, reading of 0xDE: 0x%x \n", __func__, data);
+	regmap_read(info->chip->regmap, 0xDF, &data);
+	dev_dbg(info->dev, "%s, reading of 0xDF: 0x%x \n", __func__, data);
+	regmap_read(info->chip->regmap, 0xE0, &data);
+	dev_dbg(info->dev, "%s, reading of 0xE0: 0x%x \n", __func__, data);
+
+	regmap_read(info->chip->regmap, 0xDF, &data);
+
+	dev_dbg(info->dev, "%s deltaR_to_store: %d \n", __func__,
+		(deltaR_to_store & 1 << 7) ? deltaR_to_store | 0xFFFFFF00: deltaR_to_store & 0x7F);
+	dev_dbg(info->dev, "%s v1_mv: 0x%x , v2_mv : 0x%x\n",
+		__func__, v1_mv, v2_mv);
+	dev_dbg(info->dev, "%s v1_mv: %d \n", __func__,
+		(v1_mv & 1 << 5) ? v1_mv | 0xFFFFFFC0: v1_mv & 0x1F);
+	dev_dbg(info->dev, "%s v2_mv: %d \n", __func__,
+		(v2_mv & 1 << 5) ? v2_mv | 0xFFFFFFC0: v2_mv & 0x1F);
+}
+
+/*
+ * From OCV curves, extract OCV for a given v3 (SOC).
+ * Ib= (OCV - Vbatt - v1 - v2) / Rs;
+ * v1 = (1-1/(C1*R1))*v1+(1/C1)*Ib;
+ * v2 = (1-1/(C2*R2))*v2+(1/C2)*Ib;
+ * v3 = v3-(1/Csoc)*Ib;
+ */
+/* factor is for enlarge v1 and v2
+ * eg: orignal v1= 0.001736 V
+ * v1 with factor will be 0.001736 *(1024* 1024) =1820
+ */
+static struct timespec  old, new;
+static struct timespec  delta;
+unsigned long long old_ns, new_ns, delta_ns;
+
+static int fg_active_mode(struct sec_fg_info *info)
+{
+	int data = 0;
+	int ret, ib, tmp, delta_ms = 0;
+	int ocv, vbat;
+	int temp, ib_ma, slp_cnt_app;
+	int *ocv_table = ocv_dischg;
+	static int chg_status;
+	static int PWR_Rdy_status;
+
+	PWR_Rdy_status = get_power_status(info);
+	dev_dbg(info->dev, "%s ------------->PWR_Rdy_status = %d \n", __func__,PWR_Rdy_status);
+
+	regmap_read(info->chip->subchip->regmap_gpadc, 0x38, &data);
+	dev_dbg(info->dev, "%s, VBAT_SLP_AVG: 0x%x \n", __func__, data);
+
+	mutex_lock(&info->lock);
+	new_ns = sched_clock();
+	delta_ns = new_ns - old_ns;
+	delta_ms = delta_ns >> 20;
+	old_ns = new_ns;
+	t1_start = t1_start + delta_ms;
+	dev_dbg(info->dev, "t1_start: %d \n", t1_start);
+	mutex_unlock(&info->lock);
+
+	ret = get_batt_vol(info, &vbat, 1);
+	if (ret)
+		return -EINVAL;
+
+	get_batt_status(info);
+	chg_status = info->bat_params.status;
+
+	if ((chg_status == POWER_SUPPLY_STATUS_DISCHARGING) || (chg_status == POWER_SUPPLY_STATUS_UNKNOWN) ||
+	    (chg_status == POWER_SUPPLY_STATUS_CHARGING))
+		dev_dbg(info->dev, "%s, delta_ms: %d, vbat: %d, v3: %d\n",
+			__func__, delta_ms, vbat, v3);
+
+	vbat_mv = vbat;
+
+	if (v3 > 100)
+		v3 = 100;
+	else if (v3 < 0)
+		v3 = 0;
+
+	/* get OCV from SOC-OCV curves */
+	if ((PWR_Rdy_status == POWER_SUPPLY_PWR_RDY_FALSE) ||
+	    (chg_status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+	    (chg_status == POWER_SUPPLY_STATUS_UNKNOWN)) {
+		ocv_table = ocv_dischg;
+		dev_dbg(info->dev, "%s, chg_status: dis-chging ...\n", __func__);
+	} else if (chg_status == POWER_SUPPLY_STATUS_CHARGING) {
+		ocv_table = ocv_chg;
+		dev_dbg(info->dev, "%s, chg_status: chging ...\n", __func__);
+	} else if (chg_status == POWER_SUPPLY_STATUS_FULL) {
+		dev_dbg(info->dev, "%s, chg_status: full\n", __func__);
+#if 0
+		v3_res = 100000;
+		v3     = 100;
+#endif
+		/* chg done, keep v3 as 100 and no need calculation of v3 */
+		goto out;
+	} else {
+		ocv_table = ocv_dischg;
+		dev_dbg(info->dev, "%s, chg_status: %d\n", __func__, chg_status);
+	}
+
+	ocv = ocv_table[v3];
+	dev_dbg(info->dev, "%s, ocv: %d , v1:%d, v2:%d, v3:%d \n",
+		__func__, ocv, v1, v2, v3);
+
+	/* (mV/m-Ohm) = A , so, the ib current unit is A with factor */
+	//ib = (ocv - vbat - v1 - v2) * factor/ r_s;
+	ib = (ocv - vbat) * factor - (v1 + v2) * 1000;
+	dev_dbg(info->dev, "%s, voltage with factor: %d\n", __func__, ib);
+	ib /= r_s;
+	dev_dbg(info->dev, "%s, ib with factor: %d\n", __func__, ib);
+
+	get_batt_temp(info);
+	/*
+	 * (~, -10C): -10C, too cold: res = 94
+	 * [-10C, 0C): -5C: res = 60;
+	 * [0C, 15C): 10C:  res = 32;
+	 * [15C, 40C): 25C: res = 13;
+	 * [40C, 55C): 40C: res = 9;
+	 * [45C, ~): 45C, too hot
+	 */
+/*
+	if (info->bat_params.temp < -10) {
+		dev_dbg(info->dev,
+			"temperature for fg is lower than -10C\n");
+		temp = -10;
+	} else if (info->bat_params.temp < 0) {
+		dev_dbg(info->dev, "temperature for fg is -5C\n");
+		temp = -5;
+	} else if (info->bat_params.temp < 15) {
+		dev_dbg(info->dev, "temperature for fg is 10C\n");
+		temp = 10;
+	} else if (info->bat_params.temp < 40) {
+		dev_dbg(info->dev, "temperature for fg is 25C\n");
+		temp = 25;
+	} else if (info->bat_params.temp < 55) {
+		dev_dbg(info->dev, "temperature for fg is 40C\n");
+		temp = 40;
+	} else {
+		dev_dbg(info->dev, "temperature is more than 50C\n");
+		temp = 55;
+	}
+*/
+	temp = info->bat_params.temp;
+
+	dev_dbg(info->dev, "%s bat temperature : %d \n", __func__, temp);
+
+	ib_ma = ib >> 10;
+	calc_resistor(info, temp, ib_ma);
+	//r1 = r2 = r_s = rtot / 3;
+	/* added by M.C. to account for Rsense */
+	//r1 = r2 = r_s = (rtot + 10) / 3;
+	if (rtot != 0)
+		r1 = r2 = rtot / 3;
+	//r_off = r_off + deltaR;// original, adaptive
+/*
+	if (chg_status == POWER_SUPPLY_STATUS_DISCHARGING) {
+		if (v3 > 60)
+			r_off = 60;
+		else if (v3 <= 60 && v3 >= 30 )
+			r_off = 50;
+		else
+			r_off = 105;
+	} else if (chg_status == POWER_SUPPLY_STATUS_CHARGING)
+		r_off = 105;
+*/
+
+	if (chg_status == POWER_SUPPLY_STATUS_CHARGING) {
+#if defined(CONFIG_MACH_GOLDEN) || defined(CONFIG_MACH_CS05) \
+		|| defined(CONFIG_MACH_DEGAS)
+		if (temp > 10) {
+			if (v3 < 6)
+				r_off = 240;
+			else if (v3 < 60)
+				r_off = r_off_initial - 20;
+			else
+				r_off = r_off_initial - 75;
+		} else {
+			if (v3 < 6)
+				r_off = 240;
+			else
+				r_off = r_off_initial + 100;
+		}
+#else
+		if (v3 < 2)
+			r_off = 240;
+		else
+			r_off = r_off_initial;
+#endif
+	}
+
+	if ((chg_status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+	   (chg_status == POWER_SUPPLY_STATUS_UNKNOWN)) {
+#if defined(CONFIG_MACH_GOLDEN) || defined(CONFIG_MACH_CS05) \
+		|| defined(CONFIG_MACH_DEGAS)
+		if (v3 <= 60 && v3 >= 10)
+			r_off = 15;
+		else
+			r_off = r_off_initial;
+#elif defined(CONFIG_MACH_GOYA)
+		r_off = r_off_initial;
+#else
+		r_off = r_off_initial;
+#endif
+	}
+
+	dev_dbg(info->dev, "%s, roff: %d, deltaR: %d \n",
+		__func__, r_off, deltaR);
+
+	r_s = (rtot / 3)+ r_off;
+	dev_dbg(info->dev, "%s, new r1=r2: %d \n", __func__, r1);
+	dev_dbg(info->dev, "%s, new r_s: %d \n", __func__, r_s);
+	deltaR = 0;
+
+	tmp = ((c1 * r1 - delta_ms)/r1) * v1 / c1;
+	dev_dbg(info->dev, "%s, v1-1: %d \n", __func__, tmp);
+	v1 = tmp + ib/c1 * delta_ms/1000;
+	dev_dbg(info->dev, "%s, v1 with factor: %d \n", __func__, v1);
+
+	tmp = ((c2 * r2 - delta_ms)/r2) * v2 / c2;
+	dev_dbg(info->dev, "%s, v2-1: %d \n", __func__, tmp);
+	v2 = tmp + ib/c2 * delta_ms/1000;
+	dev_dbg(info->dev, "%s, v2: with factor %d \n", __func__, v2);
+
+	tmp = (ib / c_soc) * delta_ms / 1000;
+	/* we change x3 from 0~1 to 0~100 , so mutiply 100 here */
+	tmp = tmp * 100 * factor2;
+	dev_dbg(info->dev, "%s, v3: tmp1: %d \n", __func__, tmp);
+	/* remove  factor */
+	tmp >>=  20;
+	dev_dbg(info->dev, "%s, v3: tmp2: %d v3_res: %d \n",
+		__func__, tmp, v3_res);
+	v3_res = v3_res - tmp;
+	dev_dbg(info->dev, "%s, v3: v3_res: %d \n", __func__, v3_res);
+
+#if 0
+	if ((PWR_Rdy_status == POWER_SUPPLY_PWR_RDY_TRUE) && (chg_status == POWER_SUPPLY_STATUS_FULL)) {
+			v3_res = 100000;
+	}
+#endif
+
+	//v3 = v3_res / factor2; //floor
+	v3 = (v3_res + factor2/2) / factor2;  //round
+	/*////////////////////////////////////////////////////////////////////////
+	if (chg_status == POWER_SUPPLY_STATUS_DISCHARGING) {
+		if (temp < 0) {
+			dev_dbg(info->dev,
+				"temperature for fg is lower than 0C\n");
+			v3 = G_T0 * v3 + Off_T0;
+		} else if (temp < -10) {
+			dev_dbg(info->dev, "temperature for fg is lower than -10C\n");
+			v3 = G_Tm10 * v3 + Off_Tm10;
+		}
+	}
+	///////////////////////////////////////////////////////////////////////*/
+
+
+	if ((chg_status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+	   (chg_status == POWER_SUPPLY_STATUS_UNKNOWN)) {
+		if (temp < -10) {
+			dev_dbg(info->dev,
+				"temperature for fg is lower than -10C\n");
+			v3 = G_Tm10 * v3 / 10 + Off_Tm10;
+		} else if (temp < 0) {
+			dev_dbg(info->dev, "temperature for fg is lower than 0C\n");
+			v3 = G_T0 * v3 + Off_T0;
+		}
+	}
+	dev_dbg(info->dev, "%s, v3 after T correction: %d \n", __func__, v3);
+
+	/* fg_store(info); */
+
+	dev_dbg(info->dev, "%s, End v3: %d \n", __func__, v3);
+	dev_dbg(info->dev, "%s <------------- \n", __func__);
+
+	/*
+	 * sleep cnt reading, added to solve sw reboot problem
+	 * (slp_cnt is not zero after a sw reboot)
+	 */
+#if 0
+	regmap_update_bits(info->chip->regmap, PM800_RTC_MISC6,
+			   SLP_CNT_RD_LSB, 0);
+	regmap_read(info->chip->regmap,
+		    PM800_RTC_MISC6, &data);
+	dev_dbg(info->dev, "%s, 0xE8: 0x%x \n", __func__, data);
+	regmap_read(info->chip->regmap,
+		    PM800_RTC_MISC7, &data);
+	slp_cnt_app = data << 3;
+	dev_dbg(info->dev, "%s, MSB: data: %d 0x%x \n", __func__, data, data);
+
+	regmap_update_bits(info->chip->regmap, PM800_RTC_MISC6,
+			   SLP_CNT_RD_LSB, 1);
+	regmap_read(info->chip->regmap,
+		    PM800_RTC_MISC6, &data);
+	dev_dbg(info->dev, "%s, 0xE8: 0x%x \n", __func__, data);
+	regmap_read(info->chip->regmap,
+		    PM800_RTC_MISC7, &data);
+	slp_cnt_app |= data & 0x07;
+	dev_dbg(info->dev, "%s, LSB: data: %d 0x%x \n", __func__, data, data);
+
+	dev_dbg(info->dev, "%s, slp_cnt: %d 0x%x \n",
+		__func__, slp_cnt_app, slp_cnt_app);
+#endif
+out:
+	fg_store(info);
+
+	return 0;
+}
+
+static int fg_lookup_v3(struct sec_fg_info *info)
+{
+	int ret, i;
+	int vbat_slp, count;
+	int *ocv_table = ocv_dischg;
+	static int chg_status;
+	static int PWR_Rdy_status;
+
+	get_batt_status(info);
+	chg_status = info->bat_params.status;
+	PWR_Rdy_status = get_power_status(info);
+
+	if ((PWR_Rdy_status == POWER_SUPPLY_PWR_RDY_FALSE) ||
+	    (chg_status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+	    (chg_status == POWER_SUPPLY_STATUS_UNKNOWN)) {
+		ocv_table = ocv_dischg;
+		dev_dbg(info->dev, "%s, chg_status: dis-chging...\n", __func__);
+	} else if (chg_status == POWER_SUPPLY_STATUS_CHARGING) {
+		ocv_table = ocv_chg;
+		dev_dbg(info->dev, "%s, chg_status: chging...\n", __func__);
+	} else if (chg_status == POWER_SUPPLY_STATUS_FULL) {
+		dev_dbg(info->dev, "%s, chg_status: full\n", __func__);
+	} else {
+		ocv_table = ocv_dischg;
+		dev_dbg(info->dev, "%s, chg_status: %d \n", __func__, chg_status);
+	}
+
+	ret = get_batt_vol(info, &vbat_slp, 0);
+	if (ret)
+		return -EINVAL;
+
+	if (vbat_slp < ocv_table[0]) {
+		v3 = 0;
+		goto out;
+	}
+
+	count = 100;
+	for (i = count - 1; i >= 0; i--) {
+		if (vbat_slp >= ocv_table[i]) {
+			v3 = i + 1;
+			break;
+		}
+	}
+out:
+	v3_res = v3 * factor2;
+	dev_info(info->dev, "%s, vbat_slp: %d , v3: %d , v3_res: %d\n",
+		__func__, vbat_slp, v3, v3_res);
+	return 0;
+}
+/*
+ *  From OCV curves, extract v3=SOC for a given VBATT_SLP.
+ *  v1 = v2 = 0;
+ *  v3 = v3;
+ */
+static int fg_long_slp_mode(struct sec_fg_info *info)
+{
+
+	dev_dbg(info->dev, "%s -------------> \n", __func__);
+	v3_res_t2 = v3_res;
+	dev_dbg(info->dev, "%s, v3_res_before: %d \n",
+		__func__, v3_res);
+	fg_lookup_v3(info);
+	dev_dbg(info->dev, "%s, v3_res_after: %d \n",
+		__func__, v3_res);
+
+	dev_dbg(info->dev, "%s, first_long_sleep_flag_adaptive: %d\n",
+		__func__, first_long_sleep_flag_adaptive);
+
+	if (first_long_sleep_flag_adaptive == 1) {
+		deltat_t2mt1 = t1_start;
+		delta_soc_t1mt3 = v3_res_t1 - v3_res;
+		delta_soc_t1mt2 = v3_res_t1 - v3_res_t2;
+		dev_dbg(info->dev, "%s, deltat_t2mt1: %d, delta_soc_t1mt3: %d, delta_soc_t1mt2: %d\n",
+			__func__, deltat_t2mt1, delta_soc_t1mt3, delta_soc_t1mt2);
+		ib_adaptive = (delta_soc_t1mt3) * c_soc / (deltat_t2mt1/factor2);
+		dev_dbg(info->dev, "%s, ib_adaptive with factor: %d \n",
+			__func__, ib_adaptive);
+
+		if ((deltat_t2mt1/1000 > 900) &&
+		    (deltat_t2mt1/1000 < 7200) &&
+		    (max(delta_soc_t1mt3,delta_soc_t1mt2)-min(delta_soc_t1mt3,delta_soc_t1mt2)>1000) &&
+		    (v3_res_t1/1000 < 90) &&
+		    (v3_res/1000 < 90) &&
+		    (v3_res_t1/1000 > 30) &&
+		    (v3_res/1000 > 30) &&
+		    (delta_soc_t1mt3 > 0) &&
+		    (delta_soc_t1mt2 > 0)) {
+			term1 = adaptive_gain_x_I0/60;
+			term2 = (delta_soc_t1mt2-delta_soc_t1mt3)/factor2;
+			term3 = (10800-deltat_t2mt1/1000)/60;
+			dev_dbg(info->dev, "%s, term1: %d , term2: %d , term3: %d\n",
+				__func__, term1, term2, term3);
+
+			deltaR = term1 * term2 * term3/ib_adaptive;
+			dev_dbg(info->dev, "%s, deltaRnew : %d \n",
+				__func__, deltaR);
+		}
+
+		dev_dbg(info->dev, "%s, deltaR : %d \n",
+			__func__, deltaR);
+	}
+
+	v3_res_t1 = v3_res;
+	t1_start = 0;
+	if (first_long_sleep_flag_adaptive == 0) {
+		first_long_sleep_flag_adaptive = 1;
+	}
+	//short_sleep_flag_adaptive = 0;
+	dev_dbg(info->dev, "%s, v3_res_t1: %d, t1_start: %d, first_long_sleep_flag_adaptive: %d\n",
+		__func__, v3_res_t1,t1_start,first_long_sleep_flag_adaptive);
+
+	v1 = v2 = 0;
+	fg_store(info);
+	dev_dbg(info->dev, "%s <------------- \n", __func__);
+	return 0;
+}
+
+/* exp(-x) function , x is enlarged by mutiply 100,
+ * y is already enlarged by 10000 in the table.
+ * y0=y1+(y2-y1)*(x0-x1)/(x2-x1)
+ */
+static int factor_exp = 10000;
+static int calc_exp(struct sec_fg_info *info, int x)
+{
+	int y1, y2, y;
+	int x1, x2;
+
+	dev_dbg(info->dev, "%s -------------> \n", __func__);
+	if(x > 500)
+		return 0;
+
+	if (x < 475) {
+		x1 = (x / 25 * 25);
+		x2 = (x + 25) / 25 * 25;
+
+		y1 = exp_data[x / 25];
+		y2 = exp_data[(x + 25) / 25];
+
+		y = y1 + (y2 - y1) * (x - x1)/(x2 - x1);
+	} else {
+		x1 = x2 = y1 = y2 =0;
+		y = exp_data[19];
+	}
+
+	dev_dbg(info->dev, "%s, x1: %d, y1: %d \n", __func__, x1, y1);
+	dev_dbg(info->dev, "%s, x2: %d, y2: %d \n", __func__, x2, y2);
+	dev_dbg(info->dev, "%s, x: %d, y: %d \n", __func__, x, y);
+	dev_dbg(info->dev, "%s <------------- \n", __func__);
+
+	return y;
+}
+/*
+ * LUT of exp(-x) function, we need to calcolate exp(-x) with x=SLEEP_CNT/RC,
+ * Since 0<SLEEP_CNT<1000 and RCmin=20 we should calculate exp function in [0-50]
+ * Because exp(-5)= 0.0067 we can use following approximation:
+ *	f(x)= exp(-x) = 0   (if x>5);
+ *  v1 = v1 * exp (-SLEEP_CNT/(R1*C1));
+ *  v2 = v2 * exp (-SLEEP_CNT/(R2*C2));
+ *  v3 = v3;
+ */
+static int fg_short_slp_mode(struct sec_fg_info *info, int slp_cnt)
+{
+	int tmp;
+
+	dev_dbg(info->dev, "%s, v1: %d, v2: %d, v3: %d, slp_cnt: %d \n",
+		__func__, v1, v2, v3, slp_cnt);
+
+	dev_dbg(info->dev, "%s -------------> \n", __func__);
+	/* v1 calculation*/
+	tmp = r1 * c1 / 1000;
+	/* enlarge */
+	tmp = slp_cnt * 100/tmp;
+	v1 = v1 * calc_exp(info, tmp);
+	//v1 = v1 * factor/ factor_exp;
+	v1 = v1 / factor_exp;
+
+	/* v2 calculation*/
+	tmp = r2 * c2 / 1000;
+	tmp = slp_cnt * 100/tmp;
+	v2 = v2 * calc_exp(info, tmp);
+	//v2 = v2 * factor/ factor_exp;
+	v2 = v2 / factor_exp;
+	dev_dbg(info->dev, "%s, v1: %d, v2: %d \n", __func__, v1, v2);
+
+	fg_store(info);
+	dev_dbg(info->dev, "%s <------------- \n", __func__);
+	return 0;
+}
+
+static void read_soc(struct sec_fg_info *info)
+{
+	static int full_charge_count = 0;
+	static int disch_count = 0;
+	static int is_boot = 2;
+	static int chg_status;
+	static int PWR_Rdy_status;
+	static int power_off_cnt, safe_flag;
+
+	get_batt_status(info);
+	chg_status = info->bat_params.status;
+	PWR_Rdy_status = get_power_status(info);
+
+	if ((PWR_Rdy_status == POWER_SUPPLY_PWR_RDY_FALSE) ||
+	    (chg_status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+	    (chg_status == POWER_SUPPLY_STATUS_UNKNOWN))  {
+		dev_dbg(info->dev, "%s, cap: %d, v3: %d before discharging protection \n", __func__,cap, v3);
+		/* cap decrease only in dis charge case */
+		//if (max(cap, v3) - min(cap, v3) > 10) {
+		if (safe_flag == 1) {
+			cap = 0;
+		} else if (is_boot > 0) {
+			/*
+			 * initial value of cap is 100.
+			 * If output v3 from table is much lower than this avoid long count down.
+			 */
+			cap = v3;
+			dev_dbg(info->dev, "%s, is_boot branch, cap=v3: %d  \n", __func__,cap);
+		} else if (v3 < cap) {
+			if (cap - v3 > 1) {
+				disch_count++;
+				dev_dbg(info->dev, "%s, cap: %d, disch_count: %d  \n", __func__,cap, disch_count);
+				if (disch_count == 60)	{
+					cap--;
+					disch_count = 0;
+				}
+			} else
+				cap = v3;
+		}
+		/*
+		 * the voltage is lower than 3.0V when discharge,
+		 * just report 0%, then power off, hardcode here;
+		 * it's a protection for the system when the temperature is low;
+		 */
+		pr_debug(".....> vbat_mv = %d, safe_flag = %d, cap = %d\n", vbat_mv, safe_flag, cap);
+		if ((!is_boot) && (vbat_mv < SAFE_POWER_OFF_THRESHOLD) && (!safe_flag)) {
+			cap = 1;
+			safe_flag = 1;
+		}
+
+		/* vbat < POWER_OFF_THRESHOLD, decrease the cap */
+		else if (vbat_mv <= POWER_OFF_THRESHOLD) {
+			if (cap != 0) {
+				/* protection for power off threshold */
+				power_off_cnt++;
+				dev_info(info->dev, "voltage is lower than %d\n", POWER_OFF_THRESHOLD);
+				if (power_off_cnt >= 5 && cap > 0) {
+					cap--;
+					power_off_cnt = 0;
+				}
+			}
+		} else if (cap == 0)
+			cap = 1;
+		dev_dbg(info->dev, "%s, cap: %d, v3: %d after discharging protection \n", __func__,cap, v3);
+	} else if (chg_status == POWER_SUPPLY_STATUS_CHARGING) {
+		dev_dbg(info->dev, "%s, cap: %d, v3: %d before charging protection \n", __func__,cap, v3);
+		if (v3 >= 100 && cap < 100)
+			cap = 99;
+		else if (v3 > cap)
+			/* cap increase only in charge case */
+			cap = v3;
+		/* In charging case, cap should not be 100 */
+		if (cap == 100)
+			cap = v3;
+		/*section added to reset adaptive variables and to wait for an other long sleep */
+		first_long_sleep_flag_adaptive = 0;
+		v3_res_t1 = v3_res;
+		t1_start = 0;
+		dev_dbg(info->dev, "%s, cap: %d, v3: %d after charging protection \n", __func__,cap, v3);
+
+	} else if (chg_status == POWER_SUPPLY_STATUS_FULL) {
+		dev_dbg(info->dev, "%s, cap: %d, v3: %d before full protection \n", __func__,cap, v3);
+
+		/*
+		 * workaround: the capacity is increased every 60s
+		 * every cycle(MONITOR_INTERVAL),
+		 * 3 psy(battery, ac, usb)are read
+		 */
+		if (cap < 100)   {
+			full_charge_count++;
+			dev_dbg(info->dev, "%s, cap: %d, full_charge_count: %d  \n", __func__,cap, full_charge_count);
+			if (full_charge_count == 150)	{
+				cap++;
+				v3 = cap;
+				v3_res = v3 * 1000;
+				full_charge_count = 0;
+			}
+		} else if (v3 >= 100 || cap == 100) {
+			cap = 100;
+			v3 = 100;
+			v3_res = 100000;
+		}
+
+		pr_debug("%s, line: %d, chg_status: %d \n", __func__, __LINE__, chg_status);
+		/* section added to reset adaptive variables and to wait for an other long sleep */
+		first_long_sleep_flag_adaptive = 0;
+		v3_res_t1 = v3_res;
+		t1_start = 0;
+		dev_dbg(info->dev, "%s, cap: %d, v3: %d after full protection \n", __func__,cap, v3);
+	} else {
+		pr_debug("%s, line: %d, chg_status: %d \n", __func__, __LINE__, chg_status);
+	}
+
+	info->bat_params.cap = cap;
+	is_boot--;
+	//pr_info("%s, count_cap_after: %d \n", __func__, count_cap);
+	//pr_info("%s, Android soc: %d \n", __func__, *soc); //to uncomment if SSG setup is not used
+}
+
+/* update battery status */
+static int pm80x_bat_update_status(struct sec_fg_info *info)
+{
+	static int chg_status;
+	int cap_soc;
+
+	get_batt_status(info);
+	chg_status = info->bat_params.status;
+
+	read_soc(info);
+	cap_soc = info->bat_params.cap;
+	dev_dbg(info->dev, "----->Android soc: %d\n", cap_soc);
+
+	fg_active_mode(info);
+
+	return 0;
+}
+
+static void pm80x_battery_work(struct work_struct *work)
+{
+	struct sec_fg_info *info =
+		container_of(work, struct sec_fg_info,
+			     monitor_work.work);
+	dev_dbg(info->dev, "88pm80x fg update start\n");
+	pm80x_bat_update_status(info);
+	queue_delayed_work(info->bat_wqueue, &info->monitor_work,
+			   MONITOR_INTERVAL);
+	dev_dbg(info->dev, "88pm80x fg update end\n");
+}
+
+static void pm80x_init_battery(fuelgauge_variable_t *fuelgauge)
+{
+	int data = 0;
+	int data1 = 0;
+	int data2 = 0;
+	int battery_removal_threshold = 85;
+	int previous_v3 = 0;
+	int slp_cnt;
+	int reg_0xdd;
+	int reg_0xde;
+	int reg_0xdf;
+	int reg_0xe0;
+	int reg_0xee;
+	int flag_false_pwrdown = 0;
+	int rtc_reset = 0;
+
+	pr_info("%s: init battery start\n", __func__);
+	regmap_read(fuelgauge->info.chip->regmap, 0xE5, &data1);
+	regmap_read(fuelgauge->info.chip->regmap, 0xE6, &data2);
+	dev_info(fuelgauge->info.dev,
+		"%s read fault event [0xe5]: 0x%x, [0xe6]: 0x%x\n",
+		 __func__, data1, data2);
+
+ 	/* for sw reboot */
+	regmap_read(fuelgauge->info.chip->subchip->regmap_power, 0xa9, &data);
+	pr_info(">>>>[0xA9] = 0x%x\n", data);
+	if (data == 0x5A) {
+		flag_false_pwrdown = 1;
+	} else {
+		/* power off */
+		flag_false_pwrdown = 0;
+	}
+	dev_info(fuelgauge->info.dev,
+		"%s flag_false_pwrdown: %d\n", __func__, flag_false_pwrdown);
+	data = 0x5A;
+	regmap_write(fuelgauge->info.chip->subchip->regmap_power, 0xA9, data);
+
+	data = 0xFF;
+	regmap_write(fuelgauge->info.chip->regmap, 0xE5, data);
+	regmap_read(fuelgauge->info.chip->regmap, 0xE5, &data);
+	dev_info(fuelgauge->info.dev,
+		"%s after clear [0xe5]: 0x%x\n", __func__, data);
+
+	data = 0xFF;
+	regmap_write(fuelgauge->info.chip->regmap, 0xE6, data);
+	regmap_read(fuelgauge->info.chip->regmap, 0xE6, &data);
+	dev_info(fuelgauge->info.dev,
+		"%s after clear [0xe6]: 0x%x\n", __func__, data);
+
+	regmap_read(fuelgauge->info.chip->regmap, 0xDF, &data);
+	deltaR=data;
+	deltaR = (deltaR & 1 << 7) ? (deltaR | 0xFFFFFF00): (deltaR & 0x7F);
+	dev_info(fuelgauge->info.dev,
+		"%s read back [0xdf]: 0x%x\n", __func__, deltaR);
+
+	/*
+	 * enable VBAT, used to measure voltage
+	 */
+	regmap_read(fuelgauge->info.chip->subchip->regmap_gpadc,
+		    PM800_GPADC_MEAS_EN1, &data);
+	data |= PM800_MEAS_EN1_VBAT;
+	regmap_write(fuelgauge->info.chip->subchip->regmap_gpadc,
+		     PM800_GPADC_MEAS_EN1, data);
+
+#if defined(CONFIG_MACH_GOLDEN) || defined(CONFIG_MACH_CS05) \
+		|| defined(CONFIG_MACH_DEGAS)
+	/* enable GPADC0, used to detect battery */
+	regmap_read(fuelgauge->info.chip->subchip->regmap_gpadc,
+		    PM800_GPADC_MEAS_EN2, &data);
+	data |= PM800_MEAS_GP0_EN;
+	regmap_write(fuelgauge->info.chip->subchip->regmap_gpadc,
+		    PM800_GPADC_MEAS_EN2, data);
+
+	regmap_read(fuelgauge->info.chip->subchip->regmap_gpadc,
+		PM800_GPADC_BIAS1, &data);
+	data |= 0x0f; /* 76uA */
+	regmap_write(fuelgauge->info.chip->subchip->regmap_gpadc,
+		PM800_GPADC_BIAS1, data);
+
+	regmap_read(fuelgauge->info.chip->subchip->regmap_gpadc,
+		    PM822_GPADC_BIAS_EN1, &data);
+	data |= ((1 << 0)| (1 << 4));
+	regmap_write(fuelgauge->info.chip->subchip->regmap_gpadc,
+		     PM822_GPADC_BIAS_EN1, data);
+#endif
+	/* set VBAT low threshold as 3.5V */
+	regmap_write(fuelgauge->info.chip->subchip->regmap_gpadc,
+		     PM800_VBAT_LOW_TH, 0xa0);
+
+	regmap_read(fuelgauge->info.chip->subchip->regmap_gpadc,
+		    0x07, &data);
+	dev_info(fuelgauge->info.dev, "%s, 0x07: 0x%x \n", __func__, data);
+
+	regmap_read(fuelgauge->info.chip->subchip->regmap_gpadc,          //MSB of OFF_TIME
+		    0x08, &data);
+	dev_info(fuelgauge->info.dev, "%s, 0x08: 0x%x \n", __func__, data);
+	data &= 0xf0;
+	//regmap_write(info->chip->subchip->regmap_gpadc, 0x08, data);
+	regmap_read(fuelgauge->info.chip->subchip->regmap_gpadc,
+		    0x08, &data);
+	dev_info(fuelgauge->info.dev, "%s, 0x08: 0x%x \n", __func__, data);
+
+	/* check whether battery present */
+	/*
+	get_batt_present(info);
+	dev_info(info->dev, "%s: >>>>>88pm80x battery present: %d\n", __func__,
+		info->bat_params.present);
+	*/
+
+	/* sleep cnt */
+	regmap_update_bits(fuelgauge->info.chip->regmap, PM800_RTC_MISC6,
+			   SLP_CNT_RD_LSB, 0);
+	regmap_read(fuelgauge->info.chip->regmap,
+		    PM800_RTC_MISC6, &data);
+	dev_info(fuelgauge->info.dev, "%s, 0xE8: 0x%x \n", __func__, data);
+	regmap_read(fuelgauge->info.chip->regmap,
+		    PM800_RTC_MISC7, &data);
+	slp_cnt = data << 3;
+	dev_info(fuelgauge->info.dev, "%s, MSB: data: %d 0x%x \n",
+		__func__, data, data);
+#if 0
+	regmap_update_bits(info->chip->regmap, PM800_RTC_MISC6,
+			   SLP_CNT_RD_LSB, 1);
+	regmap_read(info->chip->regmap,
+		    PM800_RTC_MISC6, &data);
+	dev_info(info->dev, "%s, 0xE8: 0x%x \n", __func__, data);
+	regmap_read(info->chip->regmap,
+		    PM800_RTC_MISC7, &data);
+	slp_cnt |= data & 0x07;
+	dev_info(info->dev, "%s, MSB: data: %d 0x%x \n", __func__, data, data);
+#endif
+	dev_info(fuelgauge->info.dev, "%s, slp_cnt: %d 0x%x \n", __func__, slp_cnt, slp_cnt);
+
+	memset(&old, 0, sizeof(old));
+	memset(&new, 0, sizeof(new));
+	memset(&delta, 0, sizeof(delta));
+
+	regmap_read(fuelgauge->info.chip->regmap, PM800_POWER_UP_LOG, &data);
+	dev_info(fuelgauge->info.dev,
+		"%s, power up flag: 0x%x \n", __func__, data);
+	dev_info(fuelgauge->info.dev, "%s, flag_false_pwrdown : 0x%x \n",
+		__func__, flag_false_pwrdown);
+
+	dev_info(fuelgauge->info.dev,
+		"%s: before calculate: v3 = %d, v3_res = %d\n",
+		__func__, v3, v3_res);
+
+	regmap_read(fuelgauge->info.chip->regmap, 0xDD, &reg_0xdd);
+	regmap_read(fuelgauge->info.chip->regmap, 0xDE, &reg_0xde);
+	regmap_read(fuelgauge->info.chip->regmap, 0xDF, &reg_0xdf);
+	regmap_read(fuelgauge->info.chip->regmap, 0xE0, &reg_0xe0);
+	regmap_read(fuelgauge->info.chip->regmap, PM800_USER_DATA5, &reg_0xee);
+	dev_info(fuelgauge->info.dev, "%s, 0xdd: 0x%x, 0xde: 0x%x, 0xdf: 0x%x, "
+		"0xe0: 0x%x, 0xee : 0x%x\n", __func__,
+		reg_0xdd, reg_0xde, reg_0xdf, reg_0xe0, reg_0xee);
+
+	if ((reg_0xdd == 0) && (reg_0xde == 0) && (reg_0xdf == 0) &&
+			(reg_0xe0 == 0) && (reg_0xee == 0)) {
+		rtc_reset = 1;
+	} else {
+		rtc_reset = 0;
+	}
+
+	if (fuelgauge->pdata->check_jig_status &&
+			fuelgauge->pdata->check_jig_status()) {
+		dev_info(fuelgauge->info.dev,
+			"%s: Bootup by JIG !!!!\n", __func__);
+		regmap_write(fuelgauge->info.chip->regmap, PM800_USER_DATA5,
+			reg_0xee | 0x80);
+
+		regmap_read(fuelgauge->info.chip->regmap,
+			PM800_USER_DATA5, &reg_0xee);
+		sec_hal_fg_reset(fuelgauge);
+		dev_info(fuelgauge->info.dev,
+			"%s: USER DATA 5: 0x%x\n", __func__, reg_0xee);
+		goto end;
+	} else if (reg_0xee & 0x80) {
+		dev_info(fuelgauge->info.dev,
+			"%s: Last bootup by JIG !!!!\n", __func__);
+		sec_hal_fg_reset(fuelgauge);
+		regmap_write(fuelgauge->info.chip->regmap, PM800_USER_DATA5,
+			reg_0xee & ~0x80);
+		goto end;
+	}
+
+	dev_info(fuelgauge->info.dev, "%s: rtc_reset  = %d, \n", __func__, rtc_reset);
+
+	if (flag_false_pwrdown == 1) {
+		dev_info(fuelgauge->info.dev,
+			"%s, flag_false_pwrdown inside if: 0x%x \n",
+			__func__, flag_false_pwrdown);
+
+		regmap_read(fuelgauge->info.chip->regmap, PM800_USER_DATA5, &data);
+		dev_info(fuelgauge->info.dev, "%s read back: 0xEE: 0x%x \n", __func__, data);
+		data &= 0x7F;
+		dev_info(fuelgauge->info.dev, "%s, data(v3): %d \n", __func__, data);
+		v3 = data;
+		// read the fraction bit of v3_res
+		regmap_read(fuelgauge->info.chip->regmap, 0xE0, &data);
+		if (data > 0x09) {
+			data = 0;
+			dev_info(fuelgauge->info.dev,
+				"%s decimal part of v3 set to 0 \n", __func__);
+		}
+		v3_res = v3 * factor2 + data * 100;
+		dev_info(fuelgauge->info.dev, "%s v3_res: %d \n",
+			__func__, v3_res);
+		//v3_res = v3_res + 50;//added to take in account of reboot sw
+		dev_info(fuelgauge->info.dev, "%s v3_res after: %d \n",
+			__func__, v3_res);
+
+		regmap_read(fuelgauge->info.chip->regmap, 0xDD, &data);
+		dev_info(fuelgauge->info.dev,
+			"%s read back: 0xDD: 0x%x \n", __func__, data);
+		/* extract v1_mv */
+		v1_mv = (data & 0x3F);
+		v1_mv = (v1_mv & 1 << 5) ? (v1_mv | 0xFFFFFFC0): (v1_mv & 0x1F);
+
+		regmap_read(fuelgauge->info.chip->regmap, 0xDE, &data);
+		dev_info(fuelgauge->info.dev,
+			"%s read back: 0xDE: 0x%x \n", __func__, data);
+		/* extract v2_mv */
+		v2_mv = data;
+		v2_mv = (v2_mv & 0x3F);
+		v2_mv = (v2_mv & 1 << 5) ? (v2_mv | 0xFFFFFFC0): (v2_mv & 0x1F);
+		dev_info(fuelgauge->info.dev, "%s v1_mv: 0x%x , v2_mv : 0x%x\n",
+			__func__, v1_mv, v2_mv);
+		dev_info(fuelgauge->info.dev, "%s v1_mv: %d , v2_mv : %d\n",
+			__func__, v1_mv, v2_mv);
+		v1_mv *= 3;
+		v2_mv *= 3;
+		v1 = v1_mv << 10;
+		v2 = v2_mv << 10;
+		dev_info(fuelgauge->info.dev, "%s v1: %d, v2 : %d \n",
+			__func__, v1, v2);
+	} else if ((slp_cnt < 1000 ) && (rtc_reset == 0)) {
+		regmap_read(fuelgauge->info.chip->regmap, PM800_USER_DATA5, &data);
+		dev_info(fuelgauge->info.dev,
+			"%s read back: 0xEE: 0x%x \n", __func__, data);
+		data &= 0x7F;
+		dev_info(fuelgauge->info.dev, "%s, data(v3): %d \n", __func__, data);
+		previous_v3=data;
+
+		/* Only look up ocv table to avoid big error of v3 */
+		fg_lookup_v3(&fuelgauge->info);
+
+		if (v3 < 1)
+			battery_removal_threshold = 1;
+		else if (v3 < 85)
+			battery_removal_threshold = 15;
+		else
+			battery_removal_threshold = 5;
+
+		dev_info(fuelgauge->info.dev,
+			"v3 = %d, battery_removal_threshold = %d\n",
+			v3, battery_removal_threshold);
+
+		if (max(data, v3) - min(data, v3) < battery_removal_threshold) {
+			v3 = data;
+			//v3_res = data * factor2 + factor2 / 2;
+			// read the fraction bit of v3_res
+			regmap_read(fuelgauge->info.chip->regmap, 0xE0, &data);
+			dev_info(fuelgauge->info.dev,
+				"%s read back: 0xE0: 0x%x \n", __func__, data);
+			if (data > 0x09) {
+				data = 0;
+				dev_info(fuelgauge->info.dev,
+					"%s decimal part of v3 set to 0 \n",
+					__func__);
+			}
+			v3_res = v3 * factor2 + data * 100;
+			dev_info(fuelgauge->info.dev, "%s v3_res: %d \n",
+				__func__, v3_res);
+			//v3_res = v3_res + 50;//added to take in account of reboot sw
+			dev_info(fuelgauge->info.dev, "%s v3_res after: %d \n",
+				__func__, v3_res);
+		}
+		dev_info(fuelgauge->info.dev, "%s, v3: %d, v3_res: %d \n",
+			__func__, v3, v3_res);
+
+		if (max(previous_v3, v3) - min(previous_v3, v3) < battery_removal_threshold) {
+
+			regmap_read(fuelgauge->info.chip->regmap, 0xDD, &data);
+			dev_info(fuelgauge->info.dev,
+				"%s read back: 0xDD: 0x%x \n", __func__, data);
+			/* extract v1_mv */
+			v1_mv = (data & 0x3F);
+			v1_mv = (v1_mv & 1 << 5) ? (v1_mv | 0xFFFFFFC0): (v1_mv & 0x1F);
+
+			regmap_read(fuelgauge->info.chip->regmap, 0xDE, &data);
+			dev_info(fuelgauge->info.dev,
+				"%s read back: 0xDE: 0x%x \n",
+				__func__, data);
+			/* extract v2_mv */
+			v2_mv = data;
+			v2_mv = (v2_mv & 0x3F);
+			v2_mv = (v2_mv & 1 << 5) ? (v2_mv | 0xFFFFFFC0): (v2_mv & 0x1F);
+			dev_info(fuelgauge->info.dev,
+				"%s v1_mv: 0x%x , v2_mv : 0x%x\n",
+				__func__, v1_mv, v2_mv);
+			dev_info(fuelgauge->info.dev, "%s v1_mv: %d , v2_mv : %d\n",
+				__func__, v1_mv, v2_mv);
+			v1_mv *= 3;
+			v2_mv *= 3;
+			v1 = v1_mv << 10;
+			v2 = v2_mv << 10;
+			dev_info(fuelgauge->info.dev, "%s v1: %d, v2 : %d \n",
+				__func__, v1, v2);
+		} else {
+			v1 = 0;
+			v2 = 0;
+		}
+
+		fg_short_slp_mode(&fuelgauge->info, slp_cnt);
+	} else
+		fg_long_slp_mode(&fuelgauge->info);
+
+end:
+	dev_info(fuelgauge->info.dev,
+		"%s: after calculate: v3 = %d, v3_res = %d\n",
+		__func__, v3, v3_res);
+
+	get_batt_vol(&fuelgauge->info, &vbat_mv, 1);
+	regmap_write(fuelgauge->info.chip->subchip->regmap_gpadc, 0x38, 0x20); // AVG samples
+}
+
+bool sec_hal_fg_init(fuelgauge_variable_t *fuelgauge)
+{
+	mutex_init(&fuelgauge->info.lock);
+	pm80x_init_battery(fuelgauge);
+
+	fuelgauge->info.bat_wqueue =
+		create_singlethread_workqueue("bat-88pm800");
+	if (!fuelgauge->info.bat_wqueue) {
+		dev_info(fuelgauge->info.chip->dev,
+			 "[%s]Failed to create bat_wqueue\n", __func__);
+		return -ESRCH;
+	}
+
+	INIT_DELAYED_WORK_DEFERRABLE(&fuelgauge->info.monitor_work,
+				     pm80x_battery_work);
+	queue_delayed_work(fuelgauge->info.bat_wqueue, &fuelgauge->info.monitor_work,
+			   MONITOR_INTERVAL);
+	return true;
+}
+
+bool sec_hal_fg_suspend(fuelgauge_variable_t *fuelgauge)
+{
+	pm80x_battery_suspend(&fuelgauge->info);
+	return true;
+}
+
+bool sec_hal_fg_resume(fuelgauge_variable_t *fuelgauge)
+{
+	pm80x_battery_resume(&fuelgauge->info);
+	return true;
+}
+
+bool sec_hal_fg_fuelalert_init(fuelgauge_variable_t *fuelgauge, int soc)
+{
+	return true;
+}
+
+bool sec_hal_fg_is_fuelalerted(fuelgauge_variable_t *fuelgauge)
+{
+	return false;
+}
+
+bool sec_hal_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	return true;
+}
+
+bool sec_hal_fg_full_charged(fuelgauge_variable_t *fuelgauge)
+{
+	return true;
+}
+
+bool sec_hal_fg_reset(fuelgauge_variable_t *fuelgauge)
+{
+	int ret, i, reg_0xee;
+	int vbat_slp, count;
+	int *ocv_table = ocv_dischg;
+	static int chg_status;
+	static int PWR_Rdy_status;
+
+	regmap_read(fuelgauge->info.chip->regmap, PM800_USER_DATA5, &reg_0xee);
+	
+	if ((fuelgauge->pdata->check_jig_status &&
+		fuelgauge->pdata->check_jig_status()) ||
+			(reg_0xee & 0x80)) {
+		get_batt_status(&fuelgauge->info);
+		chg_status = fuelgauge->info.bat_params.status;
+		PWR_Rdy_status = get_power_status(&fuelgauge->info);
+
+		if ((PWR_Rdy_status == POWER_SUPPLY_PWR_RDY_FALSE) ||
+			(chg_status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+				(chg_status == POWER_SUPPLY_STATUS_UNKNOWN)) {
+			ocv_table = ocv_dischg;
+		} else if (chg_status == POWER_SUPPLY_STATUS_CHARGING) {
+			ocv_table = ocv_chg;
+		} else if (chg_status == POWER_SUPPLY_STATUS_FULL) {
+			dev_dbg(fuelgauge->info.dev, "%s, chg_status: full\n", __func__);
+		} else {
+			ocv_table = ocv_dischg;
+		}
+
+		ret = get_batt_vol(&fuelgauge->info, &vbat_slp, 1);
+		if (ret)
+			return -EINVAL;
+
+		if (vbat_slp < ocv_table[0]) {
+			v3 = 0;
+			goto out;
+		}
+
+		count = 100;
+		for (i = count - 1; i >= 0; i--) {
+			if (vbat_slp >= ocv_table[i]) {
+				v3 = i + 1;
+				break;
+			}
+		}
+out:
+		v3_res = v3 * factor2;
+		cap = v3;
+		dev_info(fuelgauge->info.dev, "%s, vbat_slp: %d , v3: %d , v3_res: %d\n",
+				__func__, vbat_slp, v3, v3_res);
+	}
+
+	return true;
+}
+
+bool sec_hal_fg_get_property(fuelgauge_variable_t *fuelgauge,
+			     enum power_supply_property psp,
+			     union power_supply_propval *val)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_PRESENT:
+		get_batt_present(fuelgauge);
+		val->intval = (fuelgauge->info.bat_params).present;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		val->intval = vbat_mv;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		read_soc(&fuelgauge->info);
+		val->intval = (fuelgauge->info.bat_params).cap;
+		/* report raw capacity: max = 1000 */
+		val->intval *= 10;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		get_batt_temp(&fuelgauge->info);
+		val->intval = (fuelgauge->info.bat_params).temp * 10;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = 250;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		if ((fuelgauge->info.bat_params).temp >= 450)
+			val->intval = POWER_SUPPLY_HEALTH_OVERHEAT;
+		else if ((fuelgauge->info.bat_params).temp <= -100)
+			val->intval = POWER_SUPPLY_HEALTH_DEAD;
+		else if ((fuelgauge->info.bat_params).temp <= -500)
+			val->intval = POWER_SUPPLY_HEALTH_COLD;
+		else
+			val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+
+	default:
+		return false;
+	}
+	return true;
+}
+
+bool sec_hal_fg_set_property(fuelgauge_variable_t *fuelgauge,
+			     enum power_supply_property psp,
+			     const union power_supply_propval *val)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		break;
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+ssize_t sec_hal_fg_show_attrs(struct device *dev,
+				const ptrdiff_t offset, char *buf)
+{
+	int i = 0;
+
+	switch (offset) {
+	case FG_DATA:
+	case FG_REGS:
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sec_hal_fg_store_attrs(struct device *dev,
+				const ptrdiff_t offset,
+				const char *buf, size_t count)
+{
+	int ret = 0;
+
+	switch (offset) {
+	case FG_REG:
+	case FG_DATA:
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+static int pm80x_battery_remove(struct platform_device *pdev)
+{
+	struct sec_fg_info *info = platform_get_drvdata(pdev);
+
+	cancel_delayed_work(&info->monitor_work);
+	flush_workqueue(info->bat_wqueue);
+	kfree(info);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int pm80x_battery_suspend(struct sec_fg_info *info)
+{
+	cancel_delayed_work_sync(&info->monitor_work);
+	return 0;
+}
+
+static int pm80x_battery_resume(struct sec_fg_info *info)
+{
+	int data;
+	int slp_cnt;
+
+	mutex_lock(&info->lock);
+	old_ns = sched_clock();
+	printk("==== %s old_ns: %llu \n",__func__, old_ns);
+	mutex_unlock(&info->lock);
+	/* sleep cnt */
+	regmap_update_bits(info->chip->regmap, PM800_RTC_MISC6,
+			   SLP_CNT_RD_LSB, 0);
+	regmap_read(info->chip->regmap,
+		    PM800_RTC_MISC6, &data);
+	dev_info(info->dev, "%s, 0xE8: 0x%x \n", __func__, data);
+	regmap_read(info->chip->regmap,
+		    PM800_RTC_MISC7, &data);
+	dev_info(info->dev, "%s, MSB before shift: data: %d 0x%x \n", __func__, data, data);
+	slp_cnt = data << 3;
+	dev_info(info->dev, "%s, MSB: data: %d 0x%x \n", __func__, data, data);
+
+#if 0
+	regmap_update_bits(info->chip->regmap, PM800_RTC_MISC6,
+			   SLP_CNT_RD_LSB, 1);
+	regmap_read(info->chip->regmap,
+		    PM800_RTC_MISC6, &data);
+	dev_info(info->dev, "%s, 0xE8: 0x%x \n", __func__, data);
+	regmap_read(info->chip->regmap,
+		    PM800_RTC_MISC7, &data);
+	slp_cnt |= data & 0x07;
+	dev_info(info->dev, "%s, MSB: data: %d 0x%x \n", __func__, data, data);
+#endif
+
+	regmap_read(info->chip->regmap,
+		    PM800_POWER_DOWN_LOG2, &data);
+
+	dev_info(info->dev, "%s, POWERDOWNLOG2 after sleep: data: %d 0x%x \n", __func__, data, data);
+
+	if(data & HYB_DONE) {
+		dev_info(info->dev, "%s HYB_DONE, slp_cnt: %d \n",
+			 __func__, slp_cnt);
+		if(slp_cnt < 1000)  {
+			dev_dbg(info->dev, "%s,  v3_res before: %d \n", __func__, v3_res);
+			dev_dbg(info->dev, "%s, short_slp_counter: %d 0x%x \n",
+				__func__, short_slp_counter, short_slp_counter);
+			if(short_slp_counter == 6)  { // v3_res - 9 each 7 sec
+				v3_res = v3_res - 9;
+				v3 = (v3_res  + factor2/2)/ factor2;
+				short_slp_counter = 0;
+			} else {
+				short_slp_counter = short_slp_counter + 1;
+			}
+			dev_dbg(info->dev, "%s,  v3_res after: %d \n", __func__, v3_res);
+			fg_short_slp_mode(info, slp_cnt);
+			fg_active_mode(info);
+
+		} else if(slp_cnt >= 1000)
+			fg_long_slp_mode(info);
+	}
+
+	queue_delayed_work(info->bat_wqueue, &info->monitor_work, 0);
+
+	return 0;
+}
+#endif
diff --git a/drivers/battery/Kconfig b/drivers/battery/Kconfig
new file mode 100755
index 00000000..e9663773
--- /dev/null
+++ b/drivers/battery/Kconfig
@@ -0,0 +1,315 @@
+
+config BATTERY_SAMSUNG
+	tristate "samsung battery driver"
+	help
+	 Say Y to include support for samsung battery driver
+	 This battery driver integrated all battery-related functions
+	 To see battery-related functions,
+	 refer to sec_charging_common.h
+
+config SAMSUNG_LPM_MODE
+	bool "Off charging mode support in sec battery driver"
+	default n
+	help
+	 Say Y to include support for sec off charging support
+	 This value defiend at bootloader.
+	 Before enable this feature,
+	 implement power off charging in the bootloader.
+
+config STBC_SAMSUNG
+       tristate "sec stbc driver"
+       default n
+       help
+	 Say Y to include support
+	 for fuelgauge driver with mfd.
+	 This driver source code implemented
+	 fuelgauge driver with mfd.
+
+# Fuel Gauge
+
+config FUELGAUGE_MFD
+	tristate "use mfd driver for fuelgauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for fuelgauge driver with mfd.
+	 This driver source code implemented
+	 fuelgauge driver with mfd.
+
+config FUELGAUGE_DUMMY
+	tristate "dummy fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for dummy fuel gauge driver.
+	 This driver source code implemented
+	 skeleton source code for fuel gauge functions.
+
+config FUELGAUGE_MAX17042
+	tristate "MAX17042 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17042 fuel gauge driver.
+	 This fuel-gauge can be used in voltage-tracking mode
+	 or coulomb-counting mode.
+
+config FUELGAUGE_MAX17042_VOLTAGE_TRACKING
+	tristate "use MAX17042 fuel gauge only as voltage tracking"
+	default n
+	depends on FUELGAUGE_MAX17042
+	help
+	 Say Y to use MAX17042 fuel gauge
+	 only as voltage tracking.
+	 This mode is for target that consumes low current
+	 like smart-phone.
+
+config FUELGAUGE_MAX17042_COULOMB_COUNTING
+	tristate "use MAX17042 fuel gauge as coulomb counting (including voltage tracking)"
+	default n
+	depends on FUELGAUGE_MAX17042
+	help
+	 Say Y to use MAX17042 fuel gauge
+	 as coulomb counting (including voltage tracking).
+	 This mode is for target that consumes high current
+	 like tablet.
+
+config FUELGAUGE_MAX17048
+	tristate "MAX17048 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17048 fuel gauge driver.
+	 This fuel-gauge can be used
+	 only in voltage-tracking mode.
+
+config FUELGAUGE_D2199
+	tristate "D2199 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for Dialog D2199 fuel gauge driver.
+	 This fuel-gauge can be used
+	 only in voltage-tracking mode.
+
+config FUELGAUGE_MAX17050
+	tristate "MAX17050 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17047 or MAX17050 fuel gauge driver.
+	 This fuel-gauge can be used in voltage-tracking mode
+	 or coulomb-counting mode.
+
+config FUELGAUGE_MAX17050_VOLTAGE_TRACKING
+	tristate "use MAX17050 fuel gauge only as voltage tracking"
+	default n
+	depends on FUELGAUGE_MAX17050
+	help
+	 Say Y to use MAX17050 fuel gauge
+	 only as voltage tracking.
+	 This mode is for target that consumes low current
+	 like smart-phone.
+
+config FUELGAUGE_MAX17050_COULOMB_COUNTING
+	tristate "use MAX17050 fuel gauge as coulomb counting (including voltage tracking)"
+	default n
+	depends on FUELGAUGE_MAX17050
+	help
+	 Say Y to use MAX17050 fuel gauge
+	 as coulomb counting (including voltage tracking).
+	 This mode is for target that consumes high current
+	 like tablet.
+
+config FUELGAUGE_PM8917
+	tristate "PM8917 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for PM8917 fuel gauge driver.
+	 This driver source code implemented
+	 all functions for PM8917 fuel gauge.
+
+config FUELGAUGE_STC3115
+	tristate "STC3115 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for STC3115 fuel gauge driver.
+	 This driver source code implemented
+	 all functions for STC3115 fuel gauge.
+
+config FUELGAUGE_RT5033
+	tristate "RT5033 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for RT5033 fuel gauge driver.
+	 This driver source code implemented
+	 all functions for RT5033 fuel gauge.
+
+config FUELGAUGE_88PM822
+	tristate "Marvell 88PM822 fuel gauge driver"
+	depends on MFD_88PM822
+	help
+	  Say Y here to enable battery monitor for Marvell 88PM822 chip.
+	  This driver uses the ADC function of 88PM822. The capacity of the
+	  battery is calculated via the voltage
+	  
+# Charger
+
+config CHARGER_MFD
+	tristate "use mfd driver for charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for charger driver with mfd.
+	 This driver source code implemented
+	 charger driver with mfd.
+
+config CHARGER_DUMMY
+	tristate "dummy charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for dummy charger driver.
+	 This driver source code implemented
+	 skeleton source code for charger functions.
+
+config CHARGER_MAX8903
+	tristate "MAX8903 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX8903 charger driver.
+	 This driver source code implemented
+	 all functions for MAX8903 charger.
+
+config CHARGER_SMB328
+	tristate "SMB328 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for Summit SMB328 charger driver.
+	 This driver source code implemented
+	 all functions for SMB328 charger.
+
+config CHARGER_SMB347
+	tristate "SMB347 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for Summit SMB347 charger driver.
+	 This driver source code implemented
+	 all functions for SMB347 charger.
+
+config CHARGER_PM8917
+	tristate "PM8917 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for PM8917 fuel gauge driver.
+	 This driver source code implemented
+	 all functions for PM8917 fuel gauge.
+
+config CHARGER_SMB358
+        tristate "SMB358 charger driver"
+	default n
+        depends on BATTERY_SAMSUNG
+        help
+         Say Y to include support
+         for Summit SMB358 charger driver.
+         This driver source code implemented
+         all functions for SMB358 charger.
+
+config CHARGER_BQ24157
+	tristate "BQ24157 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for TI BQ24157 charger driver.
+	 This driver source code implemented
+	 all functions for BQ24157 charger.
+
+config CHARGER_BQ24190
+	tristate "BQ24190 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for TI BQ24190 charger driver.
+	 This driver source code implemented
+	 all functions for BQ24190 charger.
+
+config CHARGER_BQ24191
+	tristate "BQ24191 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for TI BQ24191 charger driver.
+	 This driver source code implemented
+	 all functions for BQ24191 charger.
+
+config CHARGER_RT9455
+	tristate "RT9455 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for Richtek RT9455 charger driver.
+	 This driver source code implemented
+	 all functions for RT9455 charger.
+
+config CHARGER_RT9455_DBG
+	tristate "RT9455 charger driver debug message"
+	default n
+	depends on CHARGER_RT9455
+	help
+	 Say Y to print
+	 Richtek RT9455 charger debug message.
+
+config CHARGER_RT5033
+	tristate "RT5033 charger driver"
+	depends on MFD_RT5033 && I2C
+	default n
+	help
+	 Say Y to include support
+	 for Richtek RT5033 charger driver..
+
+config CHARGER_NCP1851
+	tristate "NCP1851 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for NCP1851 charger driver.
+	 This driver source code implemented
+	 all functions for NCP1851 charger.
+
+config CHARGER_PM8917
+	tristate "PM8917 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for PM8917 charger driver.
+	 This driver source code implemented
+	 all functions for PM8917 charger.
+
diff --git a/drivers/battery/Makefile b/drivers/battery/Makefile
new file mode 100755
index 00000000..752d2120
--- /dev/null
+++ b/drivers/battery/Makefile
@@ -0,0 +1,35 @@
+obj-$(CONFIG_CHARGER_MAX8903)	+= sec_charger.o
+obj-$(CONFIG_CHARGER_SMB328)	+= sec_charger.o
+obj-$(CONFIG_CHARGER_SMB347)	+= sec_charger.o
+obj-$(CONFIG_CHARGER_SMB358)	+= sec_charger.o
+obj-$(CONFIG_CHARGER_BQ24157)	+= sec_charger.o
+obj-$(CONFIG_CHARGER_BQ24190)	+= sec_charger.o
+obj-$(CONFIG_CHARGER_BQ24191)	+= sec_charger.o
+obj-$(CONFIG_CHARGER_NCP1851)	+= sec_charger.o
+obj-$(CONFIG_CHARGER_RT9455)	+= sec_charger.o
+
+obj-$(CONFIG_BATTERY_SAMSUNG)	+= sec_fuelgauge.o		\
+				sec_battery.o
+
+obj-$(CONFIG_STBC_SAMSUNG)		+= stbc_charger.o stbc_fuelgauge.o \
+									sec_charger.o
+
+
+obj-$(CONFIG_FUELGAUGE_MAX17042)	+= max17042_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX17048)	+= max17048_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX17050)	+= max17050_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_STC3115)		+= stc3115_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_D2199)		+= d2199_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_RT5033)		+= rt5033_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_88PM822)		+= 88pm80x_fuelgauge.o
+
+obj-$(CONFIG_CHARGER_MAX8903)	+= max8903_charger.o
+obj-$(CONFIG_CHARGER_SMB328)	+= smb328_charger.o
+obj-$(CONFIG_CHARGER_SMB347)	+= smb347_charger.o
+obj-$(CONFIG_CHARGER_SMB358)	+= smb358_charger.o
+obj-$(CONFIG_CHARGER_BQ24157)	+= bq24157_charger.o
+obj-$(CONFIG_CHARGER_BQ24190)	+= bq24190_charger.o
+obj-$(CONFIG_CHARGER_BQ24191)	+= bq24190_charger.o
+obj-$(CONFIG_CHARGER_NCP1851)	+= ncp1851_charger.o
+obj-$(CONFIG_CHARGER_RT9455)	+= rt9455_charger.o
+obj-$(CONFIG_CHARGER_RT5033)    += rt5033_charger.o
diff --git a/drivers/battery/sec_battery.c b/drivers/battery/sec_battery.c
new file mode 100755
index 00000000..f0767e14
--- /dev/null
+++ b/drivers/battery/sec_battery.c
@@ -0,0 +1,3358 @@
+/*
+ *  sec_battery.c
+ *  Samsung Mobile Battery Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/battery/sec_battery.h>
+#include <linux/battery/sec_fuelgauge.h>
+
+#if defined(CONFIG_MFD_88PM800)
+#include <linux/mfd/88pm80x.h>
+#elif defined(CONFIG_FUELGAUGE_D2199)
+#include <linux/d2199/d2199_reg.h>
+#endif
+
+#if defined(CONFIG_SEC_GPIO_DVS)
+#include <linux/secgpio_dvs.h>
+#endif
+
+static struct device_attribute sec_usb_attr[] = {
+	SEC_USB_ATTR(charging_mode_booting),
+};
+
+static struct device_attribute sec_battery_attrs[] = {
+	SEC_BATTERY_ATTR(batt_reset_soc),
+	SEC_BATTERY_ATTR(batt_read_raw_soc),
+	SEC_BATTERY_ATTR(batt_read_adj_soc),
+	SEC_BATTERY_ATTR(batt_type),
+	SEC_BATTERY_ATTR(batt_vfocv),
+	SEC_BATTERY_ATTR(batt_vol_adc),
+	SEC_BATTERY_ATTR(batt_vol_adc_cal),
+	SEC_BATTERY_ATTR(batt_vol_aver),
+	SEC_BATTERY_ATTR(batt_vol_adc_aver),
+	SEC_BATTERY_ATTR(batt_temp_adc),
+	SEC_BATTERY_ATTR(batt_temp_aver),
+	SEC_BATTERY_ATTR(batt_temp_adc_aver),
+	SEC_BATTERY_ATTR(batt_vf_adc),
+	SEC_BATTERY_ATTR(batt_slate_mode),
+
+	SEC_BATTERY_ATTR(batt_lp_charging),
+	SEC_BATTERY_ATTR(siop_activated),
+	SEC_BATTERY_ATTR(siop_level),
+	SEC_BATTERY_ATTR(batt_charging_source),
+	SEC_BATTERY_ATTR(fg_reg_dump),
+	SEC_BATTERY_ATTR(fg_reset_cap),
+	SEC_BATTERY_ATTR(fg_capacity),
+	SEC_BATTERY_ATTR(auth),
+	SEC_BATTERY_ATTR(chg_current_adc),
+	SEC_BATTERY_ATTR(wc_adc),
+	SEC_BATTERY_ATTR(wc_status),
+	SEC_BATTERY_ATTR(wc_enable),
+	SEC_BATTERY_ATTR(factory_mode),
+	SEC_BATTERY_ATTR(update),
+	SEC_BATTERY_ATTR(test_mode),
+
+	SEC_BATTERY_ATTR(call),
+	SEC_BATTERY_ATTR(2g_call),
+	SEC_BATTERY_ATTR(talk_gsm),
+	SEC_BATTERY_ATTR(3g_call),
+	SEC_BATTERY_ATTR(talk_wcdma),
+	SEC_BATTERY_ATTR(music),
+	SEC_BATTERY_ATTR(video),
+	SEC_BATTERY_ATTR(browser),
+	SEC_BATTERY_ATTR(hotspot),
+	SEC_BATTERY_ATTR(camera),
+	SEC_BATTERY_ATTR(camcorger),
+	SEC_BATTERY_ATTR(data_call),
+	SEC_BATTERY_ATTR(wifi),
+	SEC_BATTERY_ATTR(wibro),
+	SEC_BATTERY_ATTR(lte),
+	SEC_BATTERY_ATTR(lcd),
+	SEC_BATTERY_ATTR(gps),
+	SEC_BATTERY_ATTR(event),
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	SEC_BATTERY_ATTR(test_charge_current),
+#endif
+};
+
+static enum power_supply_property sec_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+};
+
+static enum power_supply_property sec_power_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static char *supply_list[] = {
+	"battery",
+};
+
+char *sec_bat_charging_mode_str[] = {
+	"None",
+	"Normal",
+	"Additional",
+	"Re-Charging"
+};
+
+char *sec_bat_status_str[] = {
+	"Unknown",
+	"Charging",
+	"Discharging",
+	"Not-charging",
+	"Full"
+};
+
+char *sec_bat_health_str[] = {
+	"Unknown",
+	"Good",
+	"Overheat",
+	"Dead",
+	"OverVoltage",
+	"UnspecFailure",
+	"Cold",
+	"UnderVoltage"
+};
+
+static int sec_bat_set_charge(
+				struct sec_battery_info *battery,
+				bool enable)
+{
+	union power_supply_propval val;
+
+	struct timespec ts;
+	ktime_t current_time;
+
+	val.intval = battery->status;
+	psy_do_property("sec-charger", set,
+		POWER_SUPPLY_PROP_STATUS, val);
+#if defined(ANDROID_ALARM_ACTIVATED)
+	current_time = alarm_get_elapsed_realtime();
+	ts = ktime_to_timespec(current_time);
+#else
+	current_time = ktime_get_boottime();
+	ts = ktime_to_timespec(current_time);
+#endif
+
+	if (enable) {
+		val.intval = battery->cable_type;
+		/*Reset charging start time only in initial charging start */
+		if (battery->charging_start_time == 0) {
+			battery->charging_start_time = ts.tv_sec;
+			battery->charging_next_time =
+				battery->pdata->charging_reset_time;
+		}
+	} else {
+		val.intval = POWER_SUPPLY_TYPE_BATTERY;
+		battery->charging_start_time = 0;
+		battery->charging_passed_time = 0;
+		battery->charging_next_time = 0;
+		battery->charging_fullcharged_time = 0;
+		battery->full_check_cnt = 0;
+	}
+
+	battery->temp_high_cnt = 0;
+	battery->temp_low_cnt = 0;
+	battery->temp_recover_cnt = 0;
+
+	psy_do_property("sec-charger", set,
+		POWER_SUPPLY_PROP_ONLINE, val);
+
+	psy_do_property("sec-fuelgauge", set,
+		POWER_SUPPLY_PROP_ONLINE, val);
+
+	return 0;
+}
+
+static int sec_bat_get_adc_data(struct sec_battery_info *battery,
+			int adc_ch, int count)
+{
+	int adc_data;
+	int adc_max;
+	int adc_min;
+	int adc_total;
+	int i;
+
+	adc_data = 0;
+	adc_max = 0;
+	adc_min = 0;
+	adc_total = 0;
+
+	for (i = 0; i < count; i++) {
+		mutex_lock(&battery->adclock);
+		adc_data = adc_read(battery->pdata, adc_ch);
+		mutex_unlock(&battery->adclock);
+
+		if (adc_data < 0)
+			goto err;
+
+		if (i != 0) {
+			if (adc_data > adc_max)
+				adc_max = adc_data;
+			else if (adc_data < adc_min)
+				adc_min = adc_data;
+		} else {
+			adc_max = adc_data;
+			adc_min = adc_data;
+		}
+		adc_total += adc_data;
+
+		msleep(10);
+	}
+
+	return (adc_total - adc_max - adc_min) / (count - 2);
+err:
+	return adc_data;
+}
+
+/*
+static unsigned long calculate_average_adc(
+			struct sec_battery_info *battery,
+			int channel, int adc)
+{
+	unsigned int cnt = 0;
+	int total_adc = 0;
+	int average_adc = 0;
+	int index = 0;
+
+	cnt = battery->adc_sample[channel].cnt;
+	total_adc = battery->adc_sample[channel].total_adc;
+
+	if (adc < 0) {
+		dev_err(battery->dev,
+			"%s : Invalid ADC : %d\n", __func__, adc);
+		adc = battery->adc_sample[channel].average_adc;
+	}
+
+	if (cnt < ADC_SAMPLE_COUNT) {
+		battery->adc_sample[channel].adc_arr[cnt] = adc;
+		battery->adc_sample[channel].index = cnt;
+		battery->adc_sample[channel].cnt = ++cnt;
+
+		total_adc += adc;
+		average_adc = total_adc / cnt;
+	} else {
+		index = battery->adc_sample[channel].index;
+		if (++index >= ADC_SAMPLE_COUNT)
+			index = 0;
+
+		total_adc = total_adc -
+			battery->adc_sample[channel].adc_arr[index] + adc;
+		average_adc = total_adc / ADC_SAMPLE_COUNT;
+
+		battery->adc_sample[channel].adc_arr[index] = adc;
+		battery->adc_sample[channel].index = index;
+	}
+
+	battery->adc_sample[channel].total_adc = total_adc;
+	battery->adc_sample[channel].average_adc = average_adc;
+
+	return average_adc;
+}
+*/
+
+static int sec_bat_get_adc_value(
+		struct sec_battery_info *battery, int channel)
+{
+	int adc;
+
+	adc = sec_bat_get_adc_data(battery, channel,
+		battery->pdata->adc_check_count);
+
+	if (adc < 0) {
+		dev_err(battery->dev,
+			"%s: Error in ADC\n", __func__);
+		return adc;
+	}
+
+	return adc;
+}
+
+static int sec_bat_get_charger_type_adc
+				(struct sec_battery_info *battery)
+{
+	/* It is true something valid is
+	connected to the device for charging.
+	By default this something is considered to be USB.*/
+	int result = POWER_SUPPLY_TYPE_USB;
+
+	int adc = 0;
+	int i;
+
+	/* Do NOT check cable type when cable_switch_check() returns false
+	 * and keep current cable type
+	 */
+	if (battery->pdata->cable_switch_check &&
+	    !battery->pdata->cable_switch_check())
+		return battery->cable_type;
+
+	adc = sec_bat_get_adc_value(battery,
+		SEC_BAT_ADC_CHANNEL_CABLE_CHECK);
+
+	/* Do NOT check cable type when cable_switch_normal() returns false
+	 * and keep current cable type
+	 */
+	if (battery->pdata->cable_switch_normal &&
+	    !battery->pdata->cable_switch_normal())
+		return battery->cable_type;
+
+	for (i = 0; i < SEC_SIZEOF_POWER_SUPPLY_TYPE; i++)
+		if ((adc > battery->pdata->cable_adc_value[i].min) &&
+			(adc < battery->pdata->cable_adc_value[i].max))
+			break;
+	if (i >= SEC_SIZEOF_POWER_SUPPLY_TYPE)
+		dev_err(battery->dev,
+			"%s : default USB\n", __func__);
+	else
+		result = i;
+
+	dev_dbg(battery->dev, "%s : result(%d), adc(%d)\n",
+		__func__, result, adc);
+
+	return result;
+}
+
+static bool sec_bat_check_vf_adc(struct sec_battery_info *battery)
+{
+	int adc;
+
+	adc = sec_bat_get_adc_data(battery,
+		SEC_BAT_ADC_CHANNEL_BAT_CHECK,
+		battery->pdata->adc_check_count);
+
+	if (adc < 0) {
+		dev_err(battery->dev, "%s: VF ADC error\n", __func__);
+		adc = battery->check_adc_value;
+	} else
+		battery->check_adc_value = adc;
+
+	if ((battery->check_adc_value < battery->pdata->check_adc_max) &&
+		(battery->check_adc_value > battery->pdata->check_adc_min))
+		return true;
+	else
+		return false;
+}
+
+static bool sec_bat_check_by_psy(struct sec_battery_info *battery)
+{
+	char *psy_name;
+	union power_supply_propval value;
+	bool ret;
+	ret = true;
+
+	switch (battery->pdata->battery_check_type) {
+	case SEC_BATTERY_CHECK_PMIC:
+		psy_name = battery->pdata->pmic_name;
+		break;
+	case SEC_BATTERY_CHECK_FUELGAUGE:
+		psy_name = "sec-fuelgauge";
+		break;
+	case SEC_BATTERY_CHECK_CHARGER:
+		psy_name = "sec-charger";
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Battery Check Type\n", __func__);
+		ret = false;
+		goto battery_check_error;
+		break;
+	}
+
+	psy_do_property(psy_name, get,
+		POWER_SUPPLY_PROP_PRESENT, value);
+	ret = (bool)value.intval;
+
+battery_check_error:
+	return ret;
+}
+
+static bool sec_bat_check(struct sec_battery_info *battery)
+{
+	bool ret;
+	ret = true;
+
+	if (battery->factory_mode || battery->pdata->check_jig_status()) {
+		dev_dbg(battery->dev, "%s: No need to check in factory mode\n",
+			__func__);
+		return ret;
+	}
+
+	if (battery->health != POWER_SUPPLY_HEALTH_GOOD &&
+		battery->health != POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) {
+		dev_dbg(battery->dev, "%s: No need to check\n", __func__);
+		return ret;
+	}
+
+	switch (battery->pdata->battery_check_type) {
+	case SEC_BATTERY_CHECK_ADC:
+		ret = sec_bat_check_vf_adc(battery);
+		break;
+	case SEC_BATTERY_CHECK_CALLBACK:
+		ret = battery->pdata->check_battery_callback();
+		break;
+	case SEC_BATTERY_CHECK_PMIC:
+	case SEC_BATTERY_CHECK_FUELGAUGE:
+	case SEC_BATTERY_CHECK_CHARGER:
+		ret = sec_bat_check_by_psy(battery);
+		break;
+	case SEC_BATTERY_CHECK_INT:
+		ret = battery->present;
+		break;
+	case SEC_BATTERY_CHECK_NONE:
+		dev_dbg(battery->dev, "%s: No Check\n", __func__);
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static bool sec_bat_get_cable_type(
+			struct sec_battery_info *battery,
+			int cable_source_type)
+{
+	bool ret;
+	int cable_type;
+
+	ret = false;
+	cable_type = battery->cable_type;
+
+	if (cable_source_type & SEC_BATTERY_CABLE_SOURCE_CALLBACK) {
+		if (battery->pdata->check_cable_callback)
+			cable_type =
+				battery->pdata->check_cable_callback();
+	}
+
+	if (cable_source_type & SEC_BATTERY_CABLE_SOURCE_ADC) {
+		if (gpio_get_value_cansleep(
+			battery->pdata->bat_gpio_ta_nconnected) ^
+			battery->pdata->bat_polarity_ta_nconnected)
+			cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		else
+			cable_type =
+				sec_bat_get_charger_type_adc(battery);
+	}
+
+	if (battery->cable_type == cable_type) {
+		dev_dbg(battery->dev,
+			"%s: No need to change cable status\n", __func__);
+	} else {
+		if (cable_type < POWER_SUPPLY_TYPE_BATTERY ||
+			cable_type >= SEC_SIZEOF_POWER_SUPPLY_TYPE) {
+			dev_err(battery->dev,
+				"%s: Invalid cable type\n", __func__);
+		} else {
+			battery->cable_type = cable_type;
+			if (battery->pdata->check_cable_result_callback)
+				battery->pdata->check_cable_result_callback(
+					battery->cable_type);
+
+			ret = true;
+
+			dev_dbg(battery->dev, "%s: Cable Changed (%d)\n",
+				__func__, battery->cable_type);
+		}
+	}
+
+	return ret;
+}
+
+static bool sec_bat_battery_cable_check(struct sec_battery_info *battery)
+{
+	if (!sec_bat_check(battery)) {
+		if (battery->check_count < battery->pdata->check_count)
+			battery->check_count++;
+		else {
+			dev_err(battery->dev,
+				"%s: Battery Disconnected\n", __func__);
+			battery->present = false;
+			battery->health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+
+			if (battery->status !=
+				POWER_SUPPLY_STATUS_DISCHARGING) {
+				battery->status =
+					POWER_SUPPLY_STATUS_NOT_CHARGING;
+				sec_bat_set_charge(battery, false);
+			}
+
+			if (battery->pdata->check_battery_result_callback)
+				battery->pdata->
+					check_battery_result_callback();
+			return false;
+		}
+	} else
+		battery->check_count = 0;
+
+	battery->present = true;
+
+	if (battery->health == POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) {
+		battery->health = POWER_SUPPLY_HEALTH_GOOD;
+
+		if (battery->status == POWER_SUPPLY_STATUS_NOT_CHARGING) {
+			battery->status = POWER_SUPPLY_STATUS_CHARGING;
+
+			sec_bat_set_charge(battery, true);
+		}
+	}
+
+	dev_dbg(battery->dev, "%s: Battery Connected\n", __func__);
+
+	if (battery->pdata->cable_check_type &
+		SEC_BATTERY_CABLE_CHECK_POLLING) {
+		if (sec_bat_get_cable_type(battery,
+			battery->pdata->cable_source_type)) {
+			wake_lock(&battery->cable_wake_lock);
+			queue_work(battery->monitor_wqueue,
+				&battery->cable_work);
+		}
+	}
+	return true;
+};
+
+static int sec_bat_ovp_uvlo_by_psy(struct sec_battery_info *battery)
+{
+	char *psy_name;
+	union power_supply_propval value;
+
+	value.intval = POWER_SUPPLY_HEALTH_GOOD;
+
+	switch (battery->pdata->ovp_uvlo_check_type) {
+	case SEC_BATTERY_OVP_UVLO_PMICPOLLING:
+		psy_name = battery->pdata->pmic_name;
+		break;
+	case SEC_BATTERY_OVP_UVLO_CHGPOLLING:
+		psy_name = "sec-charger";
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid OVP/UVLO Check Type\n", __func__);
+		goto ovp_uvlo_check_error;
+		break;
+	}
+
+	psy_do_property(psy_name, get,
+		POWER_SUPPLY_PROP_HEALTH, value);
+
+ovp_uvlo_check_error:
+	return value.intval;
+}
+
+static bool sec_bat_ovp_uvlo_result(
+		struct sec_battery_info *battery, int health)
+{
+	if (battery->health != health) {
+		battery->health = health;
+		switch (health) {
+		case POWER_SUPPLY_HEALTH_GOOD:
+			dev_dbg(battery->dev, "%s: Safe voltage\n", __func__);
+			battery->status =
+				POWER_SUPPLY_STATUS_CHARGING;
+			break;
+		case POWER_SUPPLY_HEALTH_OVERVOLTAGE:
+		case POWER_SUPPLY_HEALTH_UNDERVOLTAGE:
+			dev_info(battery->dev,
+				"%s: Unsafe voltage (%d)\n",
+				__func__, health);
+			battery->status =
+				POWER_SUPPLY_STATUS_NOT_CHARGING;
+			break;
+		}
+		power_supply_changed(&battery->psy_bat);
+		return true;
+	}
+
+	return false;
+}
+
+static bool sec_bat_ovp_uvlo(struct sec_battery_info *battery)
+{
+	int health;
+
+	if (battery->health != POWER_SUPPLY_HEALTH_GOOD &&
+		battery->health != POWER_SUPPLY_HEALTH_OVERVOLTAGE &&
+		battery->health != POWER_SUPPLY_HEALTH_UNDERVOLTAGE) {
+		dev_dbg(battery->dev, "%s: No need to check\n", __func__);
+		return false;
+	}
+
+	health = battery->health;
+
+	switch (battery->pdata->ovp_uvlo_check_type) {
+	case SEC_BATTERY_OVP_UVLO_CALLBACK:
+		if (battery->pdata->ovp_uvlo_callback)
+			health = battery->pdata->ovp_uvlo_callback();
+		break;
+	case SEC_BATTERY_OVP_UVLO_PMICPOLLING:
+	case SEC_BATTERY_OVP_UVLO_CHGPOLLING:
+		health = sec_bat_ovp_uvlo_by_psy(battery);
+		break;
+	case SEC_BATTERY_OVP_UVLO_PMICINT:
+	case SEC_BATTERY_OVP_UVLO_CHGINT:
+		/* nothing for interrupt check */
+	default:
+		break;
+	}
+
+	return sec_bat_ovp_uvlo_result(battery, health);
+}
+
+static bool sec_bat_check_recharge(struct sec_battery_info *battery)
+{
+	pr_info("%s: check recharge condition\n", __func__);
+	if ((battery->status == POWER_SUPPLY_STATUS_CHARGING) &&
+			(battery->pdata->full_condition_type &
+			 SEC_BATTERY_FULL_CONDITION_NOTIMEFULL) &&
+			(battery->charging_mode == SEC_BATTERY_CHARGING_NONE)) {
+		dev_info(battery->dev,
+				"%s: Re-charging by NOTIMEFULL (%d)\n",
+				__func__, battery->capacity);
+		goto check_recharge_check_count;
+	}
+
+	if (battery->status == POWER_SUPPLY_STATUS_FULL &&
+			battery->charging_mode == SEC_BATTERY_CHARGING_NONE) {
+		if ((battery->pdata->recharge_condition_type &
+			SEC_BATTERY_RECHARGE_CONDITION_SOC) &&
+			(battery->capacity <=
+			battery->pdata->recharge_condition_soc)) {
+			dev_info(battery->dev,
+				"%s: Re-charging by SOC (%d)\n",
+				__func__, battery->capacity);
+			goto check_recharge_check_count;
+		}
+
+		if ((battery->pdata->recharge_condition_type &
+			SEC_BATTERY_RECHARGE_CONDITION_AVGVCELL) &&
+			(battery->voltage_avg <=
+			battery->pdata->recharge_condition_avgvcell)) {
+			dev_info(battery->dev,
+				"%s: Re-charging by average VCELL (%d)\n",
+				__func__, battery->voltage_avg);
+			goto check_recharge_check_count;
+		}
+
+		if ((battery->pdata->recharge_condition_type &
+			SEC_BATTERY_RECHARGE_CONDITION_VCELL) &&
+			(battery->voltage_now <=
+			battery->pdata->recharge_condition_vcell)) {
+			dev_info(battery->dev,
+				"%s: Re-charging by VCELL (%d)\n",
+				__func__, battery->voltage_now);
+			goto check_recharge_check_count;
+		}
+	}
+
+	battery->recharge_check_cnt = 0;
+	return false;
+
+check_recharge_check_count:
+	if (battery->recharge_check_cnt <
+		battery->pdata->recharge_check_count)
+		battery->recharge_check_cnt++;
+	dev_dbg(battery->dev,
+		"%s: recharge count = %d\n",
+		__func__, battery->recharge_check_cnt);
+
+	if (battery->recharge_check_cnt >=
+		battery->pdata->recharge_check_count)
+		return true;
+	else
+	return false;
+}
+
+static bool sec_bat_voltage_check(struct sec_battery_info *battery)
+{
+	if (battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+		dev_info(battery->dev,
+			"%s: Charging Disabled\n", __func__);
+		return true;
+	}
+
+	/* OVP/UVLO check */
+	if (sec_bat_ovp_uvlo(battery)) {
+		if (battery->pdata->ovp_uvlo_result_callback)
+			battery->pdata->
+				ovp_uvlo_result_callback(battery->health);
+		return false;
+	}
+
+	/* Re-Charging check */
+	if (sec_bat_check_recharge(battery)) {
+		if (battery->pdata->full_check_type !=
+			SEC_BATTERY_FULLCHARGED_NONE)
+			battery->charging_mode = SEC_BATTERY_CHARGING_1ST;
+		else
+			battery->charging_mode = SEC_BATTERY_CHARGING_2ND;
+		battery->is_recharging = true;
+		sec_bat_set_charge(battery, true);
+		return false;
+	}
+
+	return true;
+}
+
+static bool sec_bat_get_temperature_by_adc(
+				struct sec_battery_info *battery,
+				enum power_supply_property psp,
+				union power_supply_propval *value)
+{
+	int temp = 0;
+	int temp_adc;
+	int low = 0;
+	int high = 0;
+	int mid = 0;
+	int channel;
+	const sec_bat_adc_table_data_t *temp_adc_table;
+	unsigned int temp_adc_table_size;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_TEMP:
+		channel = SEC_BAT_ADC_CHANNEL_TEMP;
+		temp_adc_table = battery->pdata->temp_adc_table;
+		temp_adc_table_size =
+			battery->pdata->temp_adc_table_size;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		channel = SEC_BAT_ADC_CHANNEL_TEMP_AMBIENT;
+		temp_adc_table = battery->pdata->temp_amb_adc_table;
+		temp_adc_table_size =
+			battery->pdata->temp_amb_adc_table_size;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Property\n", __func__);
+		return false;
+	}
+
+	temp_adc = sec_bat_get_adc_value(battery, channel);
+	if (temp_adc < 0)
+		return true;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_TEMP:
+		battery->temp_adc = temp_adc;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		battery->temp_ambient_adc = temp_adc;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Property\n", __func__);
+		return false;
+	}
+
+	if (temp_adc_table[0].adc >= temp_adc) {
+		temp = temp_adc_table[0].temperature;
+		goto temp_by_adc_goto;
+	} else if (temp_adc_table[temp_adc_table_size-1].adc <= temp_adc) {
+		temp = temp_adc_table[temp_adc_table_size-1].temperature;
+		goto temp_by_adc_goto;
+	}
+
+	high = temp_adc_table_size - 1;
+
+	while (low <= high) {
+		mid = (low + high) / 2;
+		if (temp_adc_table[mid].adc > temp_adc)
+			high = mid - 1;
+		else if (temp_adc_table[mid].adc < temp_adc)
+			low = mid + 1;
+		else {
+		temp = temp_adc_table[mid].temperature;
+			goto temp_by_adc_goto;
+		}
+	}
+
+	temp = temp_adc_table[high].temperature;
+		temp +=
+		((temp_adc_table[low].temperature -
+		temp_adc_table[high].temperature) *
+		(temp_adc - temp_adc_table[high].adc)) /
+		(temp_adc_table[low].adc - temp_adc_table[high].adc);
+
+temp_by_adc_goto:
+	value->intval = temp;
+
+	dev_dbg(battery->dev,
+		"%s: Temp(%d), Temp-ADC(%d)\n",
+		__func__, temp, temp_adc);
+
+	return true;
+}
+
+static bool sec_bat_temperature(
+				struct sec_battery_info *battery)
+{
+	bool ret;
+	ret = true;
+
+	if (battery->pdata->event_check && battery->event) {
+		battery->temp_high_threshold =
+			battery->pdata->temp_high_threshold_event;
+		battery->temp_high_recovery =
+			battery->pdata->temp_high_recovery_event;
+		battery->temp_low_recovery =
+			battery->pdata->temp_low_recovery_event;
+		battery->temp_low_threshold =
+			battery->pdata->temp_low_threshold_event;
+	} else if (battery->pdata->is_lpm && battery->pdata->is_lpm()) {
+		battery->temp_high_threshold =
+			battery->pdata->temp_high_threshold_lpm;
+		battery->temp_high_recovery =
+			battery->pdata->temp_high_recovery_lpm;
+		battery->temp_low_recovery =
+			battery->pdata->temp_low_recovery_lpm;
+		battery->temp_low_threshold =
+			battery->pdata->temp_low_threshold_lpm;
+	} else {
+		battery->temp_high_threshold =
+			battery->pdata->temp_high_threshold_normal;
+		battery->temp_high_recovery =
+			battery->pdata->temp_high_recovery_normal;
+		battery->temp_low_recovery =
+			battery->pdata->temp_low_recovery_normal;
+		battery->temp_low_threshold =
+			battery->pdata->temp_low_threshold_normal;
+	}
+
+	dev_dbg(battery->dev,
+		"%s: HT(%d), HR(%d), LT(%d), LR(%d)\n",
+		__func__, battery->temp_high_threshold,
+		battery->temp_high_recovery,
+		battery->temp_low_threshold,
+		battery->temp_low_recovery);
+	return ret;
+}
+
+static bool sec_bat_temperature_check(
+				struct sec_battery_info *battery)
+{
+	int temp_value;
+	bool health_changed;
+
+	/* set health_changed true as default
+	 * this value will be changed after temperature check
+	 */
+	health_changed = true;
+
+	if (battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+		dev_dbg(battery->dev,
+			"%s: Charging Disabled\n", __func__);
+		return true;
+	}
+
+	if (battery->health != POWER_SUPPLY_HEALTH_GOOD &&
+		battery->health != POWER_SUPPLY_HEALTH_OVERHEAT &&
+		battery->health != POWER_SUPPLY_HEALTH_COLD) {
+		dev_dbg(battery->dev, "%s: No need to check\n", __func__);
+		return false;
+	}
+
+	sec_bat_temperature(battery);
+
+	switch (battery->pdata->temp_check_type) {
+	case SEC_BATTERY_TEMP_CHECK_ADC:
+		temp_value = battery->temp_adc;
+		break;
+	case SEC_BATTERY_TEMP_CHECK_TEMP:
+		temp_value = battery->temperature;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Temp Check Type\n", __func__);
+		return true;
+	}
+
+	if (temp_value >= battery->temp_high_threshold) {
+		if (battery->health != POWER_SUPPLY_HEALTH_OVERHEAT) {
+			if (battery->temp_high_cnt <
+				battery->pdata->temp_check_count)
+				battery->temp_high_cnt++;
+			dev_dbg(battery->dev,
+				"%s: high count = %d\n",
+				__func__, battery->temp_high_cnt);
+		}
+	} else if ((temp_value <= battery->temp_high_recovery) &&
+				(temp_value >= battery->temp_low_recovery)) {
+		if (battery->health == POWER_SUPPLY_HEALTH_OVERHEAT ||
+		    battery->health == POWER_SUPPLY_HEALTH_COLD) {
+			if (battery->temp_recover_cnt <
+				battery->pdata->temp_check_count)
+				battery->temp_recover_cnt++;
+			dev_dbg(battery->dev,
+				"%s: recovery count = %d\n",
+				__func__, battery->temp_recover_cnt);
+		}
+	} else if (temp_value <= battery->temp_low_threshold) {
+		if (battery->health != POWER_SUPPLY_HEALTH_COLD) {
+			if (battery->temp_low_cnt <
+				battery->pdata->temp_check_count)
+				battery->temp_low_cnt++;
+			dev_dbg(battery->dev,
+				"%s: low count = %d\n",
+				__func__, battery->temp_low_cnt);
+		}
+	} else {
+		battery->temp_high_cnt = 0;
+		battery->temp_low_cnt = 0;
+		battery->temp_recover_cnt = 0;
+	}
+
+	if (battery->temp_high_cnt >=
+		battery->pdata->temp_check_count)
+		battery->health = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (battery->temp_low_cnt >=
+		battery->pdata->temp_check_count)
+		battery->health = POWER_SUPPLY_HEALTH_COLD;
+	else if (battery->temp_recover_cnt >=
+		battery->pdata->temp_check_count)
+		battery->health = POWER_SUPPLY_HEALTH_GOOD;
+	else
+		health_changed = false;
+
+	if (health_changed) {
+		if ((battery->health == POWER_SUPPLY_HEALTH_OVERHEAT) ||
+			(battery->health == POWER_SUPPLY_HEALTH_COLD)) {
+			dev_info(battery->dev,
+				"%s: Unsafe Temperature\n", __func__);
+			battery->status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+			/* change charging current to battery (default 0mA) */
+			sec_bat_set_charge(battery, false);
+		} else {
+			dev_info(battery->dev,
+				"%s: Safe Temperature\n", __func__);
+			/* if recovered from not charging */
+			if ((battery->health == POWER_SUPPLY_HEALTH_GOOD) &&
+				(battery->status ==
+				 POWER_SUPPLY_STATUS_NOT_CHARGING)) {
+				if (battery->is_recharging)
+					battery->status =
+						POWER_SUPPLY_STATUS_FULL;
+				else	/* Normal Charging */
+					battery->status =
+						POWER_SUPPLY_STATUS_CHARGING;
+				/* turn on charger by cable type */
+				sec_bat_set_charge(battery, true);
+			}
+		}
+		return false;
+	}
+	return true;
+};
+
+static void  sec_bat_event_program_alarm(
+	struct sec_battery_info *battery, int seconds)
+{
+#if defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+	ktime_t low_interval = ktime_set(seconds - 10, 0);
+	ktime_t slack = ktime_set(20, 0);
+	ktime_t next;
+
+	next = ktime_add(battery->last_event_time, low_interval);
+
+	alarm_start_range(&battery->event_termination_alarm,
+		next, ktime_add(next, slack));
+#else
+	alarm_start(&battery->event_termination_alarm,
+		ktime_add(battery->last_event_time, ktime_set(seconds - 10, 0)));
+#endif
+}
+
+#if defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+static void sec_bat_event_expired_timer_func(struct alarm *alarm)
+#else
+static enum alarmtimer_restart sec_bat_event_expired_timer_func(
+	struct alarm *alarm, ktime_t now)
+#endif
+{
+	struct sec_battery_info *battery =
+		container_of(alarm, struct sec_battery_info,
+			event_termination_alarm);
+
+	battery->event &= (~battery->event_wait);
+	dev_dbg(battery->dev,
+		"%s: event expired (0x%x)\n", __func__, battery->event);
+
+#if !defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+	return ALARMTIMER_NORESTART;
+#endif
+}
+
+static void sec_bat_event_set(
+	struct sec_battery_info *battery, int event, int enable)
+{
+	if (!battery->pdata->event_check)
+		return;
+
+	/* ignore duplicated deactivation of same event
+	 * only if the event is one last event
+	 */
+	if (!enable && (battery->event == battery->event_wait)) {
+		dev_info(battery->dev,
+			"%s: ignore duplicated deactivation of same event\n",
+			__func__);
+		return;
+	}
+
+	alarm_cancel(&battery->event_termination_alarm);
+
+	battery->event &= (~battery->event_wait);
+
+	if (enable) {
+		battery->event_wait = 0;
+		battery->event |= event;
+
+		dev_info(battery->dev,
+			"%s: event set (0x%x)\n", __func__, battery->event);
+	} else {
+		if (battery->event == 0) {
+			dev_dbg(battery->dev,
+				"%s: nothing to clear\n", __func__);
+			return;	/* nothing to clear */
+		}
+		battery->event_wait = event;
+#if defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+		battery->last_event_time = alarm_get_elapsed_realtime();
+#else
+		battery->last_event_time = ktime_get_boottime();
+#endif
+		sec_bat_event_program_alarm(battery,
+			battery->pdata->event_waiting_time);
+
+		dev_info(battery->dev,
+			"%s: start timer (curr 0x%x, wait 0x%x)\n",
+			__func__, battery->event, battery->event_wait);
+	}
+}
+
+static bool sec_bat_check_fullcharged_condition(
+					struct sec_battery_info *battery)
+{
+	int full_check_type;
+
+	if (battery->charging_mode == SEC_BATTERY_CHARGING_1ST)
+		full_check_type = battery->pdata->full_check_type;
+	else
+		full_check_type = battery->pdata->full_check_type_2nd;
+
+	switch (full_check_type) {
+	case SEC_BATTERY_FULLCHARGED_CHGINT:
+		return false;
+	case SEC_BATTERY_FULLCHARGED_CHGGPIO:
+	case SEC_BATTERY_FULLCHARGED_CHGPSY:
+#if !defined(CONFIG_MACH_GOYA)
+		return true;
+#endif
+	case SEC_BATTERY_FULLCHARGED_ADC:
+	case SEC_BATTERY_FULLCHARGED_FG_CURRENT:
+	case SEC_BATTERY_FULLCHARGED_TIME:
+	case SEC_BATTERY_FULLCHARGED_SOC:
+		break;
+
+	/* If these is NOT full check type or NONE full check type,
+	 * it is full-charged
+	 */
+	case SEC_BATTERY_FULLCHARGED_NONE:
+	default:
+		return true;
+		break;
+	}
+
+	if (battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_SOC) {
+		if (battery->capacity <
+			battery->pdata->full_condition_soc) {
+			dev_dbg(battery->dev,
+				"%s: Not enough SOC (%d%%)\n",
+				__func__, battery->capacity);
+			return false;
+		}
+	}
+
+	if (battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_VCELL) {
+		if (battery->voltage_now <
+			battery->pdata->full_condition_vcell) {
+			dev_dbg(battery->dev,
+				"%s: Not enough VCELL (%dmV)\n",
+				__func__, battery->voltage_now);
+			return false;
+		}
+	}
+
+	if (battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_AVGVCELL) {
+		if (battery->voltage_avg <
+			battery->pdata->full_condition_avgvcell) {
+			dev_dbg(battery->dev,
+				"%s: Not enough AVGVCELL (%dmV)\n",
+				__func__, battery->voltage_avg);
+			return false;
+		}
+	}
+
+	if (battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_OCV) {
+		if (battery->voltage_ocv <
+			battery->pdata->full_condition_ocv) {
+			dev_dbg(battery->dev,
+				"%s: Not enough OCV (%dmV)\n",
+				__func__, battery->voltage_ocv);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+static void sec_bat_do_test_function(
+				struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	switch (battery->test_activated) {
+	case 1:
+		if (battery->status == POWER_SUPPLY_STATUS_CHARGING) {
+			sec_bat_set_charge(battery, false);
+			battery->status = POWER_SUPPLY_STATUS_DISCHARGING;
+		}
+		break;
+	case 2:
+		if(battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+			sec_bat_set_charge(battery, true);
+			psy_do_property("sec-charger", get,
+				POWER_SUPPLY_PROP_STATUS, value);
+			battery->status = value.intval;
+		}
+		battery->test_activated = 0;
+		break;
+	case 3: // clear temp block
+		battery->health = POWER_SUPPLY_HEALTH_GOOD;
+		battery->status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case 4:
+		if(battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+			sec_bat_set_charge(battery, true);
+			psy_do_property("sec-charger", get,
+				POWER_SUPPLY_PROP_STATUS, value);
+			battery->status = value.intval;
+		}
+		break;
+	default:
+		pr_info("%s: error test: unknown state\n", __func__);
+		break;
+	}
+}
+
+static bool sec_bat_time_management(
+				struct sec_battery_info *battery)
+{
+	unsigned long charging_time;
+	struct timespec ts;
+#if defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+	ktime_t current_time;
+
+	current_time = alarm_get_elapsed_realtime();
+	ts = ktime_to_timespec(current_time);
+#else
+	get_monotonic_boottime(&ts);
+#endif
+
+	if (battery->charging_start_time == 0) {
+		dev_dbg(battery->dev,
+			"%s: Charging Disabled\n", __func__);
+		return true;
+	}
+
+	if (ts.tv_sec >= battery->charging_start_time)
+		charging_time = ts.tv_sec - battery->charging_start_time;
+	else
+		charging_time = 0xFFFFFFFF - battery->charging_start_time
+		    + ts.tv_sec;
+
+	battery->charging_passed_time = charging_time;
+
+	dev_dbg(battery->dev,
+		"%s: Charging Time : %ld secs\n", __func__,
+		battery->charging_passed_time);
+
+	switch (battery->status) {
+	case POWER_SUPPLY_STATUS_FULL:
+		if (battery->is_recharging && (charging_time >
+			battery->pdata->recharging_total_time)) {
+			dev_info(battery->dev,
+				"%s: Recharging Timer Expired\n", __func__);
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->is_recharging = false;
+			if (sec_bat_set_charge(battery, false)) {
+				dev_err(battery->dev,
+					"%s: Fail to Set Charger\n", __func__);
+				return true;
+			}
+
+			return false;
+		}
+		break;
+	case POWER_SUPPLY_STATUS_CHARGING:
+		if ((battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_NOTIMEFULL) &&
+			(battery->is_recharging && (charging_time >
+		battery->pdata->recharging_total_time))) {
+			dev_info(battery->dev,
+			"%s: Recharging Timer Expired\n", __func__);
+			if (battery->capacity >= 100)
+				battery->status = POWER_SUPPLY_STATUS_FULL;
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->is_recharging = false;
+			if (sec_bat_set_charge(battery, false)) {
+				dev_err(battery->dev,
+					"%s: Fail to Set Charger\n", __func__);
+				return true;
+			}
+			return false;
+		} else if (!battery->is_recharging &&
+			(charging_time > battery->pdata->charging_total_time)) {
+			dev_info(battery->dev,
+				"%s: Charging Timer Expired\n", __func__);
+			if (battery->pdata->full_condition_type &
+				SEC_BATTERY_FULL_CONDITION_NOTIMEFULL) {
+				if (battery->capacity >= 100)
+					battery->status =
+						POWER_SUPPLY_STATUS_FULL;
+			} else
+				battery->status = POWER_SUPPLY_STATUS_FULL;
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			if (sec_bat_set_charge(battery, false)) {
+				dev_err(battery->dev,
+					"%s: Fail to Set Charger\n", __func__);
+				return true;
+			}
+
+			return false;
+		}
+		if (battery->pdata->charging_reset_time) {
+			if (charging_time > battery->charging_next_time) {
+				/*reset current in charging status */
+				battery->charging_next_time =
+					battery->charging_passed_time +
+					(battery->pdata->charging_reset_time);
+
+				dev_dbg(battery->dev,
+					"%s: Reset charging current\n",
+					__func__);
+				if (sec_bat_set_charge(battery, true)) {
+					dev_err(battery->dev,
+						"%s: Fail to Set Charger\n",
+						__func__);
+					return true;
+				}
+			}
+		}
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Undefine Battery Status\n", __func__);
+		return true;
+	}
+
+	return true;
+}
+
+static bool sec_bat_check_fullcharged(
+				struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+	int current_adc;
+	int full_check_type;
+	bool ret;
+	int err;
+
+	ret = false;
+
+	if (!sec_bat_check_fullcharged_condition(battery))
+		goto not_full_charged;
+
+	if (battery->charging_mode == SEC_BATTERY_CHARGING_1ST)
+		full_check_type = battery->pdata->full_check_type;
+	else
+		full_check_type = battery->pdata->full_check_type_2nd;
+
+	switch (full_check_type) {
+	case SEC_BATTERY_FULLCHARGED_ADC:
+			current_adc =
+				sec_bat_get_adc_value(battery,
+				SEC_BAT_ADC_CHANNEL_FULL_CHECK);
+
+			dev_dbg(battery->dev,
+				"%s: Current ADC (%d)\n",
+				__func__, current_adc);
+
+			if (current_adc < 0)
+				break;
+			battery->current_adc = current_adc;
+
+			if (battery->current_adc <
+			(battery->charging_mode ==
+			SEC_BATTERY_CHARGING_1ST ?
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st :
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_2nd)) {
+				battery->full_check_cnt++;
+				dev_dbg(battery->dev,
+				"%s: Full Check ADC (%d)\n",
+				__func__,
+				battery->full_check_cnt);
+			} else
+				battery->full_check_cnt = 0;
+			break;
+
+	case SEC_BATTERY_FULLCHARGED_FG_CURRENT:
+		if (battery->current_avg <
+			(battery->charging_mode ==
+			SEC_BATTERY_CHARGING_1ST ?
+				battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st :
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_2nd)) {
+			battery->full_check_cnt++;
+			dev_dbg(battery->dev,
+				"%s: Full Check Current (%d)\n",
+				__func__,
+				battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_TIME:
+		if ((battery->charging_mode ==
+			SEC_BATTERY_CHARGING_2ND ?
+			(battery->charging_passed_time -
+			battery->charging_fullcharged_time) :
+			battery->charging_passed_time) >
+			(battery->charging_mode ==
+			SEC_BATTERY_CHARGING_1ST ?
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st :
+				battery->pdata->charging_current[
+			battery->cable_type].full_check_current_2nd)) {
+				battery->full_check_cnt++;
+				dev_dbg(battery->dev,
+				"%s: Full Check Time (%d)\n",
+				__func__,
+				battery->full_check_cnt);
+			} else
+				battery->full_check_cnt = 0;
+			break;
+
+	case SEC_BATTERY_FULLCHARGED_SOC:
+		if (battery->capacity <=
+			(battery->charging_mode ==
+			SEC_BATTERY_CHARGING_1ST ?
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st :
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_2nd)) {
+			battery->full_check_cnt++;
+			dev_dbg(battery->dev,
+				"%s: Full Check SOC (%d)\n",
+				__func__,
+				battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_CHGGPIO:
+		err = gpio_request(
+			battery->pdata->chg_gpio_full_check,
+			"GPIO_CHG_FULL");
+		if (err) {
+			dev_err(battery->dev,
+				"%s: Error in Request of GPIO\n", __func__);
+			break;
+		}
+		if (!(gpio_get_value_cansleep(
+			battery->pdata->chg_gpio_full_check) ^
+			!battery->pdata->chg_polarity_full_check)) {
+			battery->full_check_cnt++;
+			dev_dbg(battery->dev,
+				"%s: Full Check GPIO (%d)\n",
+				__func__, battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		gpio_free(battery->pdata->chg_gpio_full_check);
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_CHGPSY:
+		psy_do_property("sec-charger", get,
+			POWER_SUPPLY_PROP_STATUS, value);
+
+		if (value.intval == POWER_SUPPLY_STATUS_FULL) {
+			battery->full_check_cnt++;
+			dev_dbg(battery->dev,
+				"%s: Full Check Charger (%d)\n",
+				__func__, battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	/* If these is NOT full check type or NONE full check type,
+	 * it is full-charged
+	 */
+	case SEC_BATTERY_FULLCHARGED_NONE:
+		battery->full_check_cnt = 0;
+		ret = true;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Full Check\n", __func__);
+		break;
+	}
+
+	if (battery->full_check_cnt >=
+		battery->pdata->full_check_count) {
+		battery->full_check_cnt = 0;
+		ret = true;
+	}
+
+not_full_charged:
+	return ret;
+}
+
+static void sec_bat_do_fullcharged(
+				struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	/* To let charger/fuel gauge know the full status,
+	 * set status before calling sec_bat_set_charge()
+	 */
+	battery->status = POWER_SUPPLY_STATUS_FULL;
+
+	if (battery->charging_mode == SEC_BATTERY_CHARGING_1ST) {
+		battery->charging_mode = SEC_BATTERY_CHARGING_2ND;
+		battery->charging_fullcharged_time =
+			battery->charging_passed_time;
+		sec_bat_set_charge(battery, true);
+	} else {
+		battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+		battery->is_recharging = false;
+		sec_bat_set_charge(battery, false);
+
+		value.intval = POWER_SUPPLY_STATUS_FULL;
+		psy_do_property("sec-fuelgauge", set,
+			POWER_SUPPLY_PROP_STATUS, value);
+	}
+
+	/* platform can NOT get information of battery
+	 * because wakeup time is too short to check uevent
+	 * To make sure that target is wakeup if full-charged,
+	 * activated wake lock in a few seconds
+	 */
+	if (battery->pdata->polling_type == SEC_BATTERY_MONITOR_ALARM)
+		wake_lock_timeout(&battery->vbus_wake_lock, HZ * 10);
+}
+
+static bool sec_bat_fullcharged_check(
+				struct sec_battery_info *battery)
+{
+	if ((battery->charging_mode == SEC_BATTERY_CHARGING_NONE) ||
+		(battery->status == POWER_SUPPLY_STATUS_NOT_CHARGING)) {
+		dev_dbg(battery->dev,
+			"%s: No Need to Check Full-Charged\n", __func__);
+		return true;
+	}
+
+	if (sec_bat_check_fullcharged(battery))
+		sec_bat_do_fullcharged(battery);
+
+	dev_dbg(battery->dev,
+		"%s: Charging Mode : %s\n", __func__,
+		battery->is_recharging ?
+		sec_bat_charging_mode_str[SEC_BATTERY_CHARGING_RECHARGING] :
+		sec_bat_charging_mode_str[battery->charging_mode]);
+
+	return true;
+};
+
+#define DISCHARGE_SAMPLE_CNT 20
+static int discharge_cnt=0;
+static int all_vcell[20] = {0,};
+
+/* if ret < 0, discharge */
+static int sec_bat_check_discharge(struct sec_battery_info *battery)
+{
+	int i, cnt, ret = 0;
+
+	all_vcell[discharge_cnt++] = battery->voltage_now;
+	if (discharge_cnt >= DISCHARGE_SAMPLE_CNT)
+		discharge_cnt = 0;
+
+	cnt = discharge_cnt;
+
+	/* check after last value is set */
+	if (all_vcell[cnt] == 0)
+		return 0;
+
+	for (i = 0; i < DISCHARGE_SAMPLE_CNT; i++) {
+		if (cnt == i)
+			continue;
+		if (all_vcell[cnt] > all_vcell[i])
+			ret--;
+		else
+			ret++;
+	}
+	return ret;
+}
+
+/* judge power off or not by current_avg */
+static int sec_bat_get_current_average(
+				struct sec_battery_info *battery)
+{
+	int curr_avg;
+	int check_discharge;
+
+	pr_debug("%s\n", __func__);
+	check_discharge = sec_bat_check_discharge(battery);
+	/* if 0% && under 3.4v && low power charging(1000mA), power off */
+	if (!battery->pdata->is_lpm() &&
+		(battery->capacity <= 0) &&
+		(battery->voltage_now < 3400) &&
+			(check_discharge < 0) &&
+		((battery->current_now < 1000) ||
+		((battery->health == POWER_SUPPLY_HEALTH_OVERHEAT) ||
+		(battery->health == POWER_SUPPLY_HEALTH_COLD)))) {
+			pr_info("%s: SOC(%d), Vnow(%d), Vocv(%d), Inow(%d)\n",
+				__func__, battery->capacity,
+				battery->voltage_now,
+				battery->voltage_ocv,
+				battery->current_now);
+		curr_avg = -1;
+	} else {
+		curr_avg = battery->current_now;
+	}
+
+	return curr_avg;
+}
+
+void sec_bat_reset_discharge(struct sec_battery_info *battery)
+{
+	int i;
+
+	for (i = 0; i < DISCHARGE_SAMPLE_CNT ; i++)
+		all_vcell[i] = 0;
+	discharge_cnt = 0;
+}
+
+static void sec_bat_get_battery_info(
+				struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	psy_do_property("sec-fuelgauge", get,
+		POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+	battery->voltage_now = value.intval;
+	msleep(10);
+	value.intval = SEC_BATTEY_VOLTAGE_AVERAGE;
+	psy_do_property("sec-fuelgauge", get,
+		POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+	battery->voltage_avg = value.intval;
+	msleep(10);
+
+	value.intval = SEC_BATTEY_VOLTAGE_OCV;
+	psy_do_property("sec-fuelgauge", get,
+		POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+	battery->voltage_ocv = value.intval;
+	msleep(10);
+
+#if 0
+	/* read from fuelgauge */
+	psy_do_property("sec-fuelgauge", get,
+		POWER_SUPPLY_PROP_CURRENT_NOW, value);
+	battery->current_now = value.intval;
+	msleep(10);
+
+	psy_do_property("sec-fuelgauge", get,
+		POWER_SUPPLY_PROP_CURRENT_AVG, value);
+	battery->current_avg = value.intval;
+	msleep(10);
+#endif
+	/* read current info from charger */
+	psy_do_property("sec-charger", get,
+		POWER_SUPPLY_PROP_CURRENT_NOW, value);
+	battery->current_now = value.intval;
+	battery->current_avg = sec_bat_get_current_average(battery);
+
+	/* To get SOC value (NOT raw SOC), need to reset value */
+	value.intval = 0;
+	psy_do_property("sec-fuelgauge", get,
+		POWER_SUPPLY_PROP_CAPACITY, value);
+	battery->capacity = value.intval;
+	msleep(10);
+
+	switch (battery->pdata->thermal_source) {
+	case SEC_BATTERY_THERMAL_SOURCE_FG:
+		psy_do_property("sec-fuelgauge", get,
+			POWER_SUPPLY_PROP_TEMP, value);
+		battery->temperature = value.intval;
+
+		psy_do_property("sec-fuelgauge", get,
+			POWER_SUPPLY_PROP_TEMP_AMBIENT, value);
+		battery->temper_amb = value.intval;
+		break;
+	case SEC_BATTERY_THERMAL_SOURCE_CALLBACK:
+		battery->pdata->get_temperature_callback(
+			POWER_SUPPLY_PROP_TEMP, &value);
+		battery->temperature = value.intval;
+		psy_do_property("sec-fuelgauge", set,
+			POWER_SUPPLY_PROP_TEMP, value);
+
+		battery->pdata->get_temperature_callback(
+			POWER_SUPPLY_PROP_TEMP_AMBIENT, &value);
+		battery->temper_amb = value.intval;
+		psy_do_property("sec-fuelgauge", set,
+			POWER_SUPPLY_PROP_TEMP_AMBIENT, value);
+		break;
+	case SEC_BATTERY_THERMAL_SOURCE_ADC:
+		sec_bat_get_temperature_by_adc(battery,
+			POWER_SUPPLY_PROP_TEMP, &value);
+		/* battery->temperature = value.intval; */
+		battery->temperature = 300;
+		psy_do_property("sec-fuelgauge", set,
+			POWER_SUPPLY_PROP_TEMP, value);
+
+		sec_bat_get_temperature_by_adc(battery,
+			POWER_SUPPLY_PROP_TEMP_AMBIENT, &value);
+		battery->temper_amb = value.intval;
+		psy_do_property("sec-fuelgauge", set,
+			POWER_SUPPLY_PROP_TEMP_AMBIENT, value);
+		break;
+	default:
+		break;
+	}
+
+	dev_info(battery->dev,
+		"%s:Vnow(%dmV),Inow(%dmA),SOC(%d%%),Tbat(%d)\n", __func__,
+		battery->voltage_now, battery->current_now,
+		battery->capacity, battery->temperature);
+	dev_dbg(battery->dev,
+		"%s,Vavg(%dmV),Vocv(%dmV),Tamb(%d),Iavg(%dmA),Iadc(%d)\n",
+		battery->present ? "Connected" : "Disconnected",
+		battery->voltage_avg, battery->voltage_ocv,
+		battery->temper_amb,
+		battery->current_avg, battery->current_adc);
+};
+
+static void sec_bat_polling_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(
+		work, struct sec_battery_info, polling_work.work);
+
+	wake_lock(&battery->monitor_wake_lock);
+	queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+	dev_dbg(battery->dev, "%s: Activated\n", __func__);
+}
+
+static void sec_bat_program_alarm(
+				struct sec_battery_info *battery, int seconds)
+{
+#if defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+	ktime_t low_interval = ktime_set(seconds, 0);
+	ktime_t slack = ktime_set(10, 0);
+	ktime_t next;
+
+	next = ktime_add(battery->last_poll_time, low_interval);
+	alarm_start_range(&battery->polling_alarm,
+		next, ktime_add(next, slack));
+#else
+	dev_dbg(battery->dev,
+			"%s: Call alarm_start\n", __func__);
+	alarm_start(&battery->polling_alarm,
+		    ktime_add(battery->last_poll_time, ktime_set(seconds, 0)));
+#endif
+}
+
+static unsigned int sec_bat_get_polling_time(
+	struct sec_battery_info *battery)
+{
+	if (battery->status ==
+		POWER_SUPPLY_STATUS_FULL)
+		battery->polling_time =
+			battery->pdata->polling_time[
+			POWER_SUPPLY_STATUS_CHARGING];
+	else
+		battery->polling_time =
+			battery->pdata->polling_time[
+			battery->status];
+
+	battery->polling_short = true;
+
+	switch (battery->status) {
+	case POWER_SUPPLY_STATUS_CHARGING:
+		if (battery->polling_in_sleep)
+			battery->polling_short = false;
+		break;
+	case POWER_SUPPLY_STATUS_DISCHARGING:
+		if (battery->polling_in_sleep)
+			battery->polling_time =
+				battery->pdata->polling_time[
+				SEC_BATTERY_POLLING_TIME_SLEEP];
+		else
+			battery->polling_time =
+				battery->pdata->polling_time[
+				battery->status];
+		battery->polling_short = false;
+		break;
+	case POWER_SUPPLY_STATUS_FULL:
+		if (battery->polling_in_sleep) {
+			if (!(battery->pdata->full_condition_type &
+				SEC_BATTERY_FULL_CONDITION_NOSLEEPINFULL) &&
+				battery->charging_mode ==
+				SEC_BATTERY_CHARGING_NONE)
+				battery->polling_time =
+					battery->pdata->polling_time[
+					SEC_BATTERY_POLLING_TIME_SLEEP];
+			battery->polling_short = false;
+		} else {
+			if (battery->charging_mode ==
+				SEC_BATTERY_CHARGING_NONE)
+				battery->polling_short = false;
+		}
+		break;
+	}
+
+	if (battery->polling_short)
+		return battery->pdata->polling_time[
+			SEC_BATTERY_POLLING_TIME_BASIC];
+	else
+		return battery->polling_time;
+}
+
+static bool sec_bat_is_short_polling(
+	struct sec_battery_info *battery)
+{
+	/* Change the full and short monitoring sequence
+	 * Originally, full monitoring was the last time of polling_count
+	 * But change full monitoring to first time
+	 * because temperature check is too late
+	 */
+	if (!battery->polling_short || battery->polling_count == 1)
+		return false;
+	else
+		return true;
+}
+
+static void sec_bat_update_polling_count(
+	struct sec_battery_info *battery)
+{
+	/* do NOT change polling count in sleep
+	 * even though it is short polling
+	 * to keep polling count along sleep/wakeup
+	 */
+	if (battery->polling_short && battery->polling_in_sleep)
+		return;
+
+	if (battery->polling_short &&
+		((battery->polling_time /
+		battery->pdata->polling_time[
+		SEC_BATTERY_POLLING_TIME_BASIC])
+		> battery->polling_count))
+		battery->polling_count++;
+	else
+		battery->polling_count = 1;	/* initial value = 1 */
+}
+
+static void sec_bat_set_polling(
+	struct sec_battery_info *battery)
+{
+	unsigned int polling_time_temp;
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	polling_time_temp = sec_bat_get_polling_time(battery);
+
+	dev_dbg(battery->dev,
+		"%s: Status:%s, Sleep:%s, Charging:%s, Short Poll:%s\n",
+		__func__, sec_bat_status_str[battery->status],
+		battery->polling_in_sleep ? "Yes" : "No",
+		(battery->charging_mode ==
+		SEC_BATTERY_CHARGING_NONE) ? "No" : "Yes",
+		battery->polling_short ? "Yes" : "No");
+	dev_dbg(battery->dev,
+		"%s: Polling time %d/%d sec.\n", __func__,
+		battery->polling_short ?
+		(polling_time_temp * battery->polling_count) :
+		polling_time_temp, battery->polling_time);
+
+	/* To sync with log above,
+	 * change polling count after log is displayed
+	 * Do NOT update polling count in initial monitor
+	 */
+	if (!battery->pdata->monitor_initial_count)
+		sec_bat_update_polling_count(battery);
+	else
+		dev_dbg(battery->dev,
+			"%s: Initial monitor %d times left.\n", __func__,
+			battery->pdata->monitor_initial_count);
+
+	switch (battery->pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		cancel_delayed_work(&battery->polling_work);
+		if (battery->pdata->monitor_initial_count) {
+			battery->pdata->monitor_initial_count--;
+			schedule_delayed_work(&battery->polling_work, HZ);
+		} else
+			schedule_delayed_work(&battery->polling_work,
+				polling_time_temp * HZ);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+#if defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+		battery->last_poll_time = alarm_get_elapsed_realtime();
+#else
+		battery->last_poll_time = ktime_get_boottime();
+#endif
+
+		if (battery->pdata->monitor_initial_count) {
+			battery->pdata->monitor_initial_count--;
+			sec_bat_program_alarm(battery, 1);
+		} else
+			sec_bat_program_alarm(battery, polling_time_temp);
+		break;
+	case SEC_BATTERY_MONITOR_TIMER:
+		break;
+	default:
+		break;
+	}
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+}
+
+#if defined(CONFIG_SEC_GPIO_DVS)&& defined(CONFIG_MACH_BAFFINQ)
+extern void  dvs_setting_initialize(void);
+#endif
+
+#if defined(CONFIG_SEC_GPIO_DVS)
+static void sec_init_dvs_work(
+				struct work_struct *work)
+{
+	printk("linhe:%s: checking_initial gpio", __func__);
+ #if defined(CONFIG_SEC_GPIO_DVS)&& defined(CONFIG_MACH_BAFFINQ)
+	dvs_setting_initialize();
+ #endif
+	gpio_dvs_check_initgpio();
+}
+#endif
+
+static void sec_bat_monitor_work(
+				struct work_struct *work)
+{
+	struct sec_battery_info *battery =
+		container_of(work, struct sec_battery_info,
+		monitor_work.work);
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	/* monitor once after wakeup */
+	if (battery->polling_in_sleep)
+		battery->polling_in_sleep = false;
+
+	sec_bat_get_battery_info(battery);
+
+	/* 0. test mode */
+	if (battery->test_activated) {
+		dev_dbg(battery->dev, "%s: Test Mode\n", __func__);
+		sec_bat_do_test_function(battery);
+		if (battery->test_activated != 0)
+			goto continue_monitor;
+	}
+
+	/* 1. battery check */
+	if (!sec_bat_battery_cable_check(battery))
+		goto continue_monitor;
+
+	/* 2. voltage check */
+	if (!sec_bat_voltage_check(battery))
+		goto continue_monitor;
+
+	/* monitor short routine in initial monitor */
+	if (battery->pdata->monitor_initial_count ||
+		sec_bat_is_short_polling(battery))
+		goto continue_monitor;
+
+	/* 3. time management */
+	if (!sec_bat_time_management(battery))
+		goto continue_monitor;
+
+	/* 4. temperature check */
+	if (!sec_bat_temperature_check(battery))
+		goto continue_monitor;
+
+	/* 5. full charging check */
+	sec_bat_fullcharged_check(battery);
+
+continue_monitor:
+	dev_info(battery->dev,
+		"%s: Status(%s), mode(%s), Health(%s), Cable(%d), siop_level(%d)\n",
+		__func__,
+		sec_bat_status_str[battery->status],
+		sec_bat_charging_mode_str[battery->charging_mode],
+		sec_bat_health_str[battery->health],
+		battery->cable_type, battery->pdata->siop_level);
+
+	power_supply_changed(&battery->psy_bat);
+
+	dev_dbg(battery->dev,
+			"%s: Call sec_bat_set_polling\n", __func__);
+	sec_bat_set_polling(battery);
+
+	wake_unlock(&battery->monitor_wake_lock);
+
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+
+	return;
+}
+
+#if defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+static void sec_bat_alarm(struct alarm *alarm)
+#else
+static enum alarmtimer_restart sec_bat_alarm(
+	struct alarm *alarm, ktime_t now)
+
+#endif
+{
+	struct sec_battery_info *battery = container_of(alarm,
+				struct sec_battery_info, polling_alarm);
+
+	dev_dbg(battery->dev,
+			"%s\n", __func__);
+
+	/* In wake up, monitor work will be queued in complete function
+	 * To avoid duplicated queuing of monitor work,
+	 * do NOT queue monitor work in wake up by polling alarm
+	 */
+	if (!battery->polling_in_sleep) {
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+		dev_info(battery->dev, "%s: Activated\n", __func__);
+	}
+#if !defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+	return ALARMTIMER_NORESTART;
+#endif
+}
+
+
+static void sec_bat_cable_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, cable_work);
+	union power_supply_propval val;
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+	/* platform can NOT get information of cable connection
+	 * because wakeup time is too short to check uevent
+	 * To make sure that target is wakeup
+	 * if cable is connected and disconnected,
+	 * activated wake lock in a few seconds
+	 */
+	wake_lock_timeout(&battery->vbus_wake_lock, HZ * 5);
+
+	if (battery->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+		((battery->pdata->cable_check_type &
+		SEC_BATTERY_CABLE_CHECK_NOINCOMPATIBLECHARGE) &&
+		battery->cable_type == POWER_SUPPLY_TYPE_UNKNOWN)) {
+		if (battery->status == POWER_SUPPLY_STATUS_FULL) {
+			val.intval = POWER_SUPPLY_TYPE_BATTERY;
+			psy_do_property("sec-fuelgauge", set,
+					POWER_SUPPLY_PROP_CHARGE_FULL, val);
+		}
+		battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+		battery->is_recharging = false;
+		battery->status = POWER_SUPPLY_STATUS_DISCHARGING;
+		battery->health = POWER_SUPPLY_HEALTH_GOOD;
+
+		if (sec_bat_set_charge(battery, false))
+			goto end_of_cable_work;
+	} else {
+		/* Do NOT display the charging icon when OTG is enabled */
+		if (battery->cable_type == POWER_SUPPLY_TYPE_OTG) {
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->status = POWER_SUPPLY_STATUS_DISCHARGING;
+		} else {
+			if (battery->pdata->full_check_type !=
+				SEC_BATTERY_FULLCHARGED_NONE)
+				battery->charging_mode =
+					SEC_BATTERY_CHARGING_1ST;
+			else
+				battery->charging_mode =
+					SEC_BATTERY_CHARGING_2ND;
+			battery->status = POWER_SUPPLY_STATUS_CHARGING;
+		}
+
+		if (sec_bat_set_charge(battery, true))
+			goto end_of_cable_work;
+
+#if defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+		/* No need for wakelock in Alarm */
+		if (battery->pdata->polling_type != SEC_BATTERY_MONITOR_ALARM)
+			wake_lock(&battery->vbus_wake_lock);
+#endif
+	}
+
+	/* polling time should be reset when cable is changed
+	 * polling_in_sleep should be reset also
+	 * before polling time is re-calculated
+	 * to prevent from counting 1 for events
+	 * right after cable is connected
+	 */
+	battery->polling_in_sleep = false;
+	sec_bat_get_polling_time(battery);
+
+	dev_dbg(battery->dev,
+		"%s: Status:%s, Sleep:%s, Charging:%s, Short Poll:%s\n",
+		__func__, sec_bat_status_str[battery->status],
+		battery->polling_in_sleep ? "Yes" : "No",
+		(battery->charging_mode ==
+		SEC_BATTERY_CHARGING_NONE) ? "No" : "Yes",
+		battery->polling_short ? "Yes" : "No");
+	dev_dbg(battery->dev,
+		"%s: Polling time is reset to %d sec.\n", __func__,
+		battery->polling_time);
+
+	battery->polling_count = 1;	/* initial value = 1 */
+
+	wake_lock(&battery->monitor_wake_lock);
+	queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work,
+					msecs_to_jiffies(500));
+end_of_cable_work:
+#if defined(CONFIG_MACH_GOLDEN) || defined(CONFIG_MACH_GOYA)
+	if (battery->cable_type == POWER_SUPPLY_TYPE_BATTERY)
+		wake_unlock(&battery->cable_wake_lock);
+#else
+	wake_unlock(&battery->cable_wake_lock);
+#endif
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+}
+
+ssize_t sec_bat_show_attrs(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_bat);
+	const ptrdiff_t offset = attr - sec_battery_attrs;
+	int i = 0;
+
+	switch (offset) {
+	case BATT_RESET_SOC:
+		break;
+	case BATT_READ_RAW_SOC:
+	{
+		union power_supply_propval value;
+
+		value.intval =
+			SEC_FUELGAUGE_CAPACITY_TYPE_RAW;
+		psy_do_property("sec-fuelgauge", get,
+				POWER_SUPPLY_PROP_CAPACITY, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       value.intval);
+	}
+	break;
+	case BATT_READ_ADJ_SOC:
+		break;
+	case BATT_TYPE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+			       battery->pdata->vendor);
+		break;
+	case BATT_VFOCV:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->voltage_ocv);
+		break;
+	case BATT_VOL_ADC:
+		break;
+	case BATT_VOL_ADC_CAL:
+		break;
+	case BATT_VOL_AVER:
+		break;
+	case BATT_VOL_ADC_AVER:
+		break;
+	case BATT_TEMP_ADC:
+	{
+		if (battery->pdata->thermal_source == SEC_BATTERY_THERMAL_SOURCE_FG) {
+			struct power_supply *psy_fuelgague = get_power_supply_by_name("sec-fuelgauge");
+			struct sec_fuelgauge_info *fuelgauge =
+				container_of(psy_fuelgague, struct sec_fuelgauge_info, psy_fg);
+
+			if (fuelgauge)
+				battery->temp_adc = fuelgauge->info.current_temp_adc;
+		}
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->temp_adc);
+	}
+		break;
+	case BATT_TEMP_AVER:
+		break;
+	case BATT_TEMP_ADC_AVER:
+		break;
+	case BATT_VF_ADC:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->pdata->vf_adc);
+		break;
+	case BATT_SLATE_MODE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->slate_mode);
+		break;
+
+	case BATT_LP_CHARGING:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->pdata->is_lpm() ? 1 : 0);
+		break;
+	case SIOP_ACTIVATED:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->pdata->siop_activated);
+		break;
+	case SIOP_LEVEL:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->pdata->siop_level);
+		break;
+	case BATT_CHARGING_SOURCE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->cable_type);
+		break;
+	case FG_REG_DUMP:
+		break;
+	case FG_RESET_CAP:
+		break;
+	case FG_CAPACITY:
+	{
+		union power_supply_propval value;
+
+		value.intval =
+			SEC_BATTEY_CAPACITY_DESIGNED;
+		psy_do_property("sec-fuelgauge", get,
+				POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%04x ",
+			       value.intval);
+
+		value.intval =
+			SEC_BATTEY_CAPACITY_ABSOLUTE;
+		psy_do_property("sec-fuelgauge", get,
+				POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%04x ",
+			       value.intval);
+
+		value.intval =
+			SEC_BATTEY_CAPACITY_TEMPERARY;
+		psy_do_property("sec-fuelgauge", get,
+				POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%04x ",
+			       value.intval);
+
+		value.intval =
+			SEC_BATTEY_CAPACITY_CURRENT;
+		psy_do_property("sec-fuelgauge", get,
+				POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%04x\n",
+			       value.intval);
+	}
+	break;
+	case AUTH:
+		break;
+	case CHG_CURRENT_ADC:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->current_adc);
+		break;
+	case WC_ADC:
+		break;
+	case WC_STATUS:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->cable_type == POWER_SUPPLY_TYPE_WPC));
+		break;
+	case WC_ENABLE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->wc_enable);
+		break;
+	case FACTORY_MODE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->factory_mode);
+		break;
+	case UPDATE:
+		break;
+	case TEST_MODE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->test_activated);
+		break;
+
+	case BATT_EVENT_CALL:
+	case BATT_EVENT_2G_CALL:
+	case BATT_EVENT_TALK_GSM:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->event & EVENT_2G_CALL) ? 1 : 0);
+		break;
+	case BATT_EVENT_3G_CALL:
+	case BATT_EVENT_TALK_WCDMA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->event & EVENT_3G_CALL) ? 1 : 0);
+		break;
+	case BATT_EVENT_MUSIC:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->event & EVENT_MUSIC) ? 1 : 0);
+		break;
+	case BATT_EVENT_VIDEO:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->event & EVENT_VIDEO) ? 1 : 0);
+		break;
+	case BATT_EVENT_BROWSER:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->event & EVENT_BROWSER) ? 1 : 0);
+		break;
+	case BATT_EVENT_HOTSPOT:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->event & EVENT_HOTSPOT) ? 1 : 0);
+		break;
+	case BATT_EVENT_CAMERA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->event & EVENT_CAMERA) ? 1 : 0);
+		break;
+	case BATT_EVENT_CAMCORDER:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->event & EVENT_CAMCORDER) ? 1 : 0);
+		break;
+	case BATT_EVENT_DATA_CALL:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->event & EVENT_DATA_CALL) ? 1 : 0);
+		break;
+	case BATT_EVENT_WIFI:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->event & EVENT_WIFI) ? 1 : 0);
+		break;
+	case BATT_EVENT_WIBRO:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->event & EVENT_WIBRO) ? 1 : 0);
+		break;
+	case BATT_EVENT_LTE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       (battery->event & EVENT_LTE) ? 1 : 0);
+		break;
+	case BATT_EVENT_LCD:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			(battery->event & EVENT_LCD) ? 1 : 0);
+		break;
+	case BATT_EVENT_GPS:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			(battery->event & EVENT_GPS) ? 1 : 0);
+		break;
+	case BATT_EVENT:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->event);
+		break;
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	case BATT_TEST_CHARGE_CURRENT:
+		{
+			union power_supply_propval value;
+
+			psy_do_property("sec-charger", get,
+				POWER_SUPPLY_PROP_CURRENT_NOW, value);
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					value.intval);
+		}
+		break;
+#endif
+	default:
+		i = -EINVAL;
+	}
+	return i;
+}
+
+ssize_t sec_usb_show_attrs(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_usb);
+	const ptrdiff_t offset = attr - sec_usb_attr;
+	int i = 0;
+
+	switch (offset) {
+	case CHARGING_MODE_BOOTING:
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", battery->pdata->is_lpm());
+			break;
+	default:
+		i = -EINVAL;
+	}
+	return i;
+}
+
+ssize_t sec_bat_store_attrs(
+					struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_bat);
+	const ptrdiff_t offset = attr - sec_battery_attrs;
+	int ret = -EINVAL;
+	int x = 0;
+
+	switch (offset) {
+	case BATT_RESET_SOC:
+		/* Do NOT reset fuel gauge in charging mode */
+		if (battery->pdata->check_cable_callback() ==
+			POWER_SUPPLY_TYPE_BATTERY) {
+			union power_supply_propval value;
+
+			value.intval =
+				SEC_FUELGAUGE_CAPACITY_TYPE_RESET;
+			psy_do_property("sec-fuelgauge", set,
+				POWER_SUPPLY_PROP_CAPACITY, value);
+			dev_info(battery->dev,"Do reset SOC\n");
+			/* update battery info */
+			sec_bat_get_battery_info(battery);
+		}
+		ret = count;
+		break;
+	case BATT_READ_RAW_SOC:
+		break;
+	case BATT_READ_ADJ_SOC:
+		break;
+	case BATT_TYPE:
+		break;
+	case BATT_VFOCV:
+		break;
+	case BATT_VOL_ADC:
+		break;
+	case BATT_VOL_ADC_CAL:
+		break;
+	case BATT_VOL_AVER:
+		break;
+	case BATT_VOL_ADC_AVER:
+		break;
+	case BATT_TEMP_ADC:
+		break;
+	case BATT_TEMP_AVER:
+		break;
+	case BATT_TEMP_ADC_AVER:
+		break;
+	case BATT_VF_ADC:
+		break;
+	case BATT_SLATE_MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			if (x == 1) {
+				value.intval = POWER_SUPPLY_TYPE_BATTERY;
+				battery->slate_mode = true;
+			} else if (x == 0) {
+				value.intval = POWER_SUPPLY_TYPE_USB;
+				battery->slate_mode = false;
+			} else {
+				dev_info(battery->dev,
+					"%s: SLATE MODE unknown command\n",
+					__func__);
+				return -EINVAL;
+			}
+			value.intval = value.intval<<ONLINE_TYPE_MAIN_SHIFT;
+			psy_do_property("battery", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+			if (battery->slate_mode) {
+				value.intval = 0;
+				psy_do_property("sec-charger", set,
+						POWER_SUPPLY_PROP_POWER_NOW, value);
+				}
+
+			ret = count;
+		}
+		break;
+
+	case BATT_LP_CHARGING:
+		break;
+	case SIOP_ACTIVATED:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			dev_info(battery->dev,
+				"%s: siop activated: %d\n", __func__, x);
+				battery->pdata->siop_activated = x;
+				if (x == 0) {
+					value.intval = battery->pdata->charging_current[battery->cable_type].input_current_limit;
+					psy_do_property("sec-charger", set,
+							POWER_SUPPLY_PROP_CURRENT_NOW, value);
+				}
+				ret = count;
+		}
+		break;
+	case SIOP_LEVEL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			dev_info(battery->dev,
+				"%s: siop level: %d\n", __func__, x);
+#if defined(CONFIG_MACH_BAFFIN)
+			if(x>100)
+				x=100;
+			else if(x<50)
+				x=50;
+#endif
+			battery->pdata->siop_level = x;
+
+			if (battery->cable_type == POWER_SUPPLY_TYPE_MAINS ||
+			    battery->cable_type == POWER_SUPPLY_TYPE_MISC)
+			{
+#if defined(CONFIG_MACH_GOYA)
+				value.intval = battery->pdata->siop_level;
+#else
+				value.intval = 800;
+#endif
+				psy_do_property("sec-charger", set,
+					POWER_SUPPLY_PROP_CURRENT_NOW, value);
+			}
+
+			ret = count;
+		}
+		break;
+	case BATT_CHARGING_SOURCE:
+		break;
+	case FG_REG_DUMP:
+		break;
+	case FG_RESET_CAP:
+		break;
+	case FG_CAPACITY:
+		break;
+	case AUTH:
+		break;
+	case CHG_CURRENT_ADC:
+		break;
+	case WC_ADC:
+		break;
+	case WC_STATUS:
+		break;
+	case WC_ENABLE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			if (x == 0) {
+				battery->wc_enable = false;
+				if (battery->cable_type == POWER_SUPPLY_TYPE_WPC) {
+					value.intval = POWER_SUPPLY_TYPE_BATTERY;
+					value.intval = value.intval<<ONLINE_TYPE_MAIN_SHIFT;
+					psy_do_property("battery", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+				} else
+					dev_info(battery->dev,
+					"%s: ignore wpc disable: %d\n", __func__, x);
+			} else if (x == 1) {
+				battery->wc_enable = true;
+				/* set cable type forced not wpc but battery
+				    then call charger online prop then, it can check
+				    wireless pin status and reupdate as wireless charging mode */
+				if (battery->cable_type ==
+					POWER_SUPPLY_TYPE_BATTERY) {
+					value.intval = POWER_SUPPLY_TYPE_BATTERY;
+					psy_do_property("sec-charger", set,
+						POWER_SUPPLY_PROP_ONLINE, value);
+				} else
+					dev_info(battery->dev,
+					"%s: ignore wpc enable: %d\n", __func__, x);
+			} else {
+				dev_info(battery->dev,
+					"%s: WPC ENABLE unknown command\n",
+					__func__);
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+	case FACTORY_MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			battery->factory_mode = x ? true : false;
+			ret = count;
+		}
+		break;
+	case UPDATE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			/* update battery info */
+			dev_info(battery->dev,"Do update\n");
+			sec_bat_get_battery_info(battery);
+			ret = count;
+		}
+		break;
+	case TEST_MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			battery->test_activated = x;// ? true : false;
+			wake_lock(&battery->monitor_wake_lock);
+			queue_delayed_work(battery->monitor_wqueue,
+				&battery->monitor_work, 0);
+			ret = count;
+		}
+		break;
+
+	case BATT_EVENT_CALL:
+	case BATT_EVENT_2G_CALL:
+	case BATT_EVENT_TALK_GSM:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_2G_CALL, x);
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_3G_CALL:
+	case BATT_EVENT_TALK_WCDMA:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_3G_CALL, x);
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_MUSIC:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_MUSIC, x);
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_VIDEO:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_VIDEO, x);
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_BROWSER:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_BROWSER, x);
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_HOTSPOT:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_HOTSPOT, x);
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_CAMERA:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_CAMERA, x);
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_CAMCORDER:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_CAMCORDER, x);
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_DATA_CALL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_DATA_CALL, x);
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_WIFI:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_WIFI, x);
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_WIBRO:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_WIBRO, x);
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_LTE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_LTE, x);
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_LCD:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			/* we need to test
+			sec_bat_event_set(battery, EVENT_LCD, x);
+			*/
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_GPS:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			sec_bat_event_set(battery, EVENT_GPS, x);
+			ret = count;
+		}
+		break;
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	case BATT_TEST_CHARGE_CURRENT:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x >= 0 && x <= 2000) {
+				union power_supply_propval value;
+				dev_err(battery->dev,
+					"%s: BATT_TEST_CHARGE_CURRENT(%d)\n", __func__, x);
+				battery->pdata->charging_current[
+					POWER_SUPPLY_TYPE_USB].input_current_limit = x;
+				battery->pdata->charging_current[
+					POWER_SUPPLY_TYPE_USB].fast_charging_current = x;
+				if (x > 500) {
+					battery->pdata->temp_check_type =
+						SEC_BATTERY_TEMP_CHECK_NONE;
+					battery->pdata->charging_total_time =
+						10000 * 60 * 60;
+				}
+				if (battery->cable_type == POWER_SUPPLY_TYPE_USB) {
+					value.intval = x;
+					psy_do_property("sec-charger", set,
+						POWER_SUPPLY_PROP_POWER_NOW, value);
+				}
+			}
+			ret = count;
+		}
+		break;
+#endif
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int sec_usb_create_attrs(struct device *dev)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(sec_usb_attr); i++) {
+		rc = device_create_file(dev, &sec_usb_attr[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	goto create_attrs_succeed;
+
+create_attrs_failed:
+	while(i--)
+		device_remove_file(dev, &sec_usb_attr[i]);
+create_attrs_succeed:
+	return rc;
+}
+
+static int sec_bat_create_attrs(struct device *dev)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(sec_battery_attrs); i++) {
+		rc = device_create_file(dev, &sec_battery_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	goto create_attrs_succeed;
+
+create_attrs_failed:
+	while (i--)
+		device_remove_file(dev, &sec_battery_attrs[i]);
+create_attrs_succeed:
+	return rc;
+}
+
+static void sec_bat_save_extended_cable_type(
+	struct sec_battery_info *battery,
+	int extended_cable_type)
+{
+	int cable_main, cable_sub, cable_power;
+
+	/* If type is unknown(0) value, save nothing for that cable type
+	 * If type is chagned, clear old value and set new one
+	 */
+	cable_main = GET_MAIN_CABLE_TYPE(extended_cable_type);
+		battery->extended_cable_type =
+			(battery->extended_cable_type &
+			~(int)ONLINE_TYPE_MAIN_MASK) |
+			(cable_main << ONLINE_TYPE_MAIN_SHIFT);
+	cable_sub = GET_SUB_CABLE_TYPE(extended_cable_type);
+		battery->extended_cable_type =
+			(battery->extended_cable_type &
+			~(int)ONLINE_TYPE_SUB_MASK) |
+			(cable_sub << ONLINE_TYPE_SUB_SHIFT);
+
+	cable_power = GET_POWER_CABLE_TYPE(extended_cable_type);
+		battery->extended_cable_type =
+			(battery->extended_cable_type &
+			~(int)ONLINE_TYPE_PWR_MASK) |
+			(cable_power << ONLINE_TYPE_PWR_SHIFT);
+}
+
+static int sec_bat_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_bat);
+	int current_cable_type;
+	int full_check_type;
+
+	dev_dbg(battery->dev,
+		"%s: (%d,%d)\n", __func__, psp, val->intval);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (battery->charging_mode == SEC_BATTERY_CHARGING_1ST)
+			full_check_type = battery->pdata->full_check_type;
+		else
+			full_check_type = battery->pdata->full_check_type_2nd;
+		if ((full_check_type == SEC_BATTERY_FULLCHARGED_CHGINT) &&
+			(val->intval == POWER_SUPPLY_STATUS_FULL))
+			sec_bat_do_fullcharged(battery);
+		battery->status = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		sec_bat_ovp_uvlo_result(battery, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (battery->pdata->cable_source_type &
+			SEC_BATTERY_CABLE_SOURCE_EXTENDED) {
+			sec_bat_save_extended_cable_type(battery, val->intval);
+			current_cable_type =
+				battery->pdata->
+				get_cable_from_extended_cable_type(
+				battery->extended_cable_type);
+		 } else
+			current_cable_type = val->intval;
+		sec_bat_reset_discharge(battery);
+
+		  /* if another cable is connected,
+		  * ignore wireless charing event
+		  */
+		if ((current_cable_type == POWER_SUPPLY_TYPE_WPC) &&
+			((battery->cable_type != POWER_SUPPLY_TYPE_BATTERY)||
+			(battery->wc_enable == false)))
+			break;
+		/* cable is attached or detached
+		 * if current_cable_type is minus value,
+		 * check cable by sec_bat_get_cable_type()
+		 * although SEC_BATTERY_CABLE_SOURCE_EXTERNAL is set
+		 * (0 is POWER_SUPPLY_TYPE_UNKNOWN)
+		 */
+		if ((current_cable_type >= 0) &&
+			(current_cable_type <= SEC_SIZEOF_POWER_SUPPLY_TYPE) &&
+			(battery->pdata->cable_source_type &
+			SEC_BATTERY_CABLE_SOURCE_EXTERNAL ||
+			battery->pdata->cable_source_type &
+			SEC_BATTERY_CABLE_SOURCE_EXTENDED)) {
+			/* skip cable work if cable is NOT changed */
+			if (battery->cable_type != current_cable_type) {
+				battery->cable_type = current_cable_type;
+				battery->pdata->check_cable_result_callback(
+					battery->cable_type);
+
+				wake_lock(&battery->cable_wake_lock);
+				queue_work(battery->monitor_wqueue,
+					&battery->cable_work);
+			} else {
+				dev_dbg(battery->dev,
+					"%s: Cable is NOT Changed(%d)\n",
+					__func__, battery->cable_type);
+				/* Do NOT activate cable work for NOT changed */
+			}
+		} else {
+			if (sec_bat_get_cable_type(battery,
+				battery->pdata->cable_source_type)) {
+				wake_lock(&battery->cable_wake_lock);
+				queue_work(battery->monitor_wqueue,
+					&battery->cable_work);
+			}
+		}
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		battery->capacity = val->intval;
+		power_supply_changed(&battery->psy_bat);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_bat_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_bat);
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if ((battery->pdata->cable_check_type &
+		     SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE) && (!battery->pdata->is_lpm())) {
+			switch (battery->cable_type) {
+			case POWER_SUPPLY_TYPE_USB:
+			case POWER_SUPPLY_TYPE_USB_DCP:
+			case POWER_SUPPLY_TYPE_USB_CDP:
+			case POWER_SUPPLY_TYPE_USB_ACA:
+				val->intval =
+					POWER_SUPPLY_STATUS_DISCHARGING;
+				return 0;
+			}
+		}
+		val->intval = battery->status;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		psy_do_property("sec-charger", get,
+			POWER_SUPPLY_PROP_CHARGE_TYPE, value);
+		if (value.intval == POWER_SUPPLY_CHARGE_TYPE_UNKNOWN)
+			/* if error in CHARGE_TYPE of charger
+			 * set CHARGE_TYPE as NONE
+			 */
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		else
+		val->intval = value.intval;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = battery->health;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = battery->present;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = battery->cable_type;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = battery->pdata->technology;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		/* voltage value should be in uV */
+		psy_do_property("sec-fuelgauge", get,
+		POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+		val->intval =  value.intval * 1000;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		/* voltage value should be in uV */
+		val->intval = battery->voltage_avg * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = battery->current_now;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = battery->current_avg;
+		break;
+	/* charging mode (differ from power supply) */
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+		val->intval = battery->charging_mode;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		/* In full-charged status, SOC is always 100% */
+		if (battery->status == POWER_SUPPLY_STATUS_FULL)
+			val->intval = 100;
+		else
+			val->intval = battery->capacity;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = battery->temperature;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = battery->temper_amb;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sec_usb_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_usb);
+
+	if (psp != POWER_SUPPLY_PROP_ONLINE)
+		return -EINVAL;
+
+	/* Set enable=1 only if the USB charger is connected */
+	switch (battery->cable_type) {
+	case POWER_SUPPLY_TYPE_USB:
+	case POWER_SUPPLY_TYPE_USB_DCP:
+	case POWER_SUPPLY_TYPE_USB_CDP:
+	case POWER_SUPPLY_TYPE_USB_ACA:
+		val->intval = 1;
+		break;
+	default:
+		val->intval = 0;
+		break;
+	}
+
+	return 0;
+}
+
+static int sec_ac_get_property(struct power_supply *psy,
+			       enum power_supply_property psp,
+			       union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_ac);
+
+	if (psp != POWER_SUPPLY_PROP_ONLINE)
+		return -EINVAL;
+
+	/* Set enable=1 only if the AC charger is connected */
+	switch (battery->cable_type) {
+	case POWER_SUPPLY_TYPE_MAINS:
+	case POWER_SUPPLY_TYPE_MISC:
+	case POWER_SUPPLY_TYPE_CARDOCK:
+	case POWER_SUPPLY_TYPE_UARTOFF:
+	case POWER_SUPPLY_TYPE_WPC:
+	case POWER_SUPPLY_TYPE_UNKNOWN:
+		val->intval = 1;
+		break;
+	default:
+		val->intval = 0;
+		break;
+	}
+
+	return 0;
+}
+
+static irqreturn_t sec_bat_irq_thread(int irq, void *irq_data)
+{
+	struct sec_battery_info *battery = irq_data;
+
+	if (battery->pdata->cable_check_type &
+		SEC_BATTERY_CABLE_CHECK_INT) {
+		if (battery->pdata->is_interrupt_cable_check_possible &&
+			!battery->pdata->is_interrupt_cable_check_possible(
+			battery->extended_cable_type))
+				goto no_cable_check;
+		else {
+			if (sec_bat_get_cable_type(battery,
+						   battery->pdata->cable_source_type)) {
+				wake_lock(&battery->cable_wake_lock);
+				queue_work(battery->monitor_wqueue,
+					   &battery->cable_work);
+			}
+		}
+	}
+
+no_cable_check:
+	if (battery->pdata->battery_check_type ==
+		SEC_BATTERY_CHECK_INT) {
+		battery->present = battery->pdata->check_battery_callback();
+
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit sec_battery_probe(struct platform_device *pdev)
+{
+	sec_battery_platform_data_t *pdata = dev_get_platdata(&pdev->dev);
+	struct sec_battery_info *battery;
+	int ret = 0;
+	int i;
+
+	union power_supply_propval value;
+
+	dev_info(&pdev->dev,
+		"%s: SEC Battery Driver Loading\n", __func__);
+
+	battery = kzalloc(sizeof(*battery), GFP_KERNEL);
+	if (!battery)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, battery);
+
+	battery->dev = &pdev->dev;
+	battery->pdata = pdata;
+
+	mutex_init(&battery->adclock);
+	dev_dbg(battery->dev, "%s: ADC init\n", __func__);
+	for (i = 0; i < SEC_BAT_ADC_CHANNEL_FULL_CHECK; i++)
+		adc_init(pdev, pdata, i);
+
+	wake_lock_init(&battery->monitor_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-monitor");
+	wake_lock_init(&battery->cable_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-cable");
+	wake_lock_init(&battery->vbus_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-vbus");
+
+	/* initialization of battery info */
+	battery->status = POWER_SUPPLY_STATUS_DISCHARGING;
+	battery->health = POWER_SUPPLY_HEALTH_GOOD;
+	battery->present = true;
+
+	battery->polling_count = 1;	/* initial value = 1 */
+	battery->polling_time = pdata->polling_time[
+		SEC_BATTERY_POLLING_TIME_DISCHARGING];
+	battery->polling_in_sleep = false;
+	battery->polling_short = false;
+
+	battery->check_count = 0;
+	battery->check_adc_count = 0;
+	battery->check_adc_value = 0;
+
+	battery->charging_start_time = 0;
+	battery->charging_passed_time = 0;
+	battery->charging_next_time = 0;
+	battery->charging_fullcharged_time = 0;
+
+#if defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+	alarm_init(&battery->event_termination_alarm,
+			ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
+			sec_bat_event_expired_timer_func);
+#else
+	alarm_init(&battery->event_termination_alarm,
+			ALARM_BOOTTIME,
+			sec_bat_event_expired_timer_func);
+#endif
+
+	battery->temp_high_threshold =
+		pdata->temp_high_threshold_normal;
+	battery->temp_high_recovery =
+		pdata->temp_high_recovery_normal;
+	battery->temp_low_recovery =
+		pdata->temp_low_recovery_normal;
+	battery->temp_low_threshold =
+		pdata->temp_low_threshold_normal;
+
+	battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+	battery->is_recharging = false;
+	battery->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+	battery->test_activated = 0;
+	battery->factory_mode = false;
+	battery->slate_mode = false;
+
+	battery->psy_bat.name = "battery",
+	battery->psy_bat.type = POWER_SUPPLY_TYPE_BATTERY,
+	battery->psy_bat.properties = sec_battery_props,
+	battery->psy_bat.num_properties = ARRAY_SIZE(sec_battery_props),
+	battery->psy_bat.get_property = sec_bat_get_property,
+	battery->psy_bat.set_property = sec_bat_set_property,
+	battery->psy_usb.name = "usb",
+	battery->psy_usb.type = POWER_SUPPLY_TYPE_USB,
+	battery->psy_usb.supplied_to = supply_list,
+	battery->psy_usb.num_supplicants = ARRAY_SIZE(supply_list),
+	battery->psy_usb.properties = sec_power_props,
+	battery->psy_usb.num_properties = ARRAY_SIZE(sec_power_props),
+	battery->psy_usb.get_property = sec_usb_get_property,
+	battery->psy_ac.name = "ac",
+	battery->psy_ac.type = POWER_SUPPLY_TYPE_MAINS,
+	battery->psy_ac.supplied_to = supply_list,
+	battery->psy_ac.num_supplicants = ARRAY_SIZE(supply_list),
+	battery->psy_ac.properties = sec_power_props,
+	battery->psy_ac.num_properties = ARRAY_SIZE(sec_power_props),
+	battery->psy_ac.get_property = sec_ac_get_property;
+
+	/* create work queue */
+	battery->monitor_wqueue =
+		alloc_workqueue(dev_name(&pdev->dev), WQ_FREEZABLE, 1);
+	if (!battery->monitor_wqueue) {
+		dev_err(battery->dev,
+			"%s: Fail to Create Workqueue\n", __func__);
+		goto err_wake_lock;
+	}
+
+	INIT_DELAYED_WORK(&battery->monitor_work, sec_bat_monitor_work);
+#if defined(CONFIG_SEC_GPIO_DVS)
+	INIT_DELAYED_WORK(&battery->initdvs_work, sec_init_dvs_work);
+	schedule_delayed_work(&battery->initdvs_work, msecs_to_jiffies(15000));
+#endif
+	INIT_WORK(&battery->cable_work, sec_bat_cable_work);
+
+	switch (pdata->polling_type) {
+		case SEC_BATTERY_MONITOR_WORKQUEUE:
+			INIT_DELAYED_WORK_DEFERRABLE(&battery->polling_work,
+				sec_bat_polling_work);
+			break;
+		case SEC_BATTERY_MONITOR_ALARM:
+#if defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+			battery->last_poll_time = alarm_get_elapsed_realtime();
+			alarm_init(&battery->polling_alarm,
+				ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
+				sec_bat_alarm);
+#else
+			battery->last_poll_time = ktime_get_boottime();
+			alarm_init(&battery->polling_alarm, ALARM_BOOTTIME,
+				sec_bat_alarm);
+#endif
+			break;
+
+		default:
+			break;
+		}
+
+	ret = power_supply_register(&pdev->dev, &battery->psy_usb);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_usb\n", __func__);
+		goto err_supply_unreg_bat;
+	}
+
+	ret = power_supply_register(&pdev->dev, &battery->psy_ac);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_ac\n", __func__);
+		goto err_supply_unreg_usb;
+	}
+
+	ret = power_supply_register(&pdev->dev, &battery->psy_bat);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_bat\n", __func__);
+		goto err_workqueue;
+	}
+
+	if (!battery->pdata->bat_gpio_init()) {
+		dev_err(battery->dev,
+			"%s: Failed to Initialize GPIO\n", __func__);
+		goto err_supply_unreg_ac;
+	}
+
+	if (battery->pdata->bat_irq) {
+		ret = request_threaded_irq(battery->pdata->bat_irq,
+				NULL, sec_bat_irq_thread,
+				battery->pdata->bat_irq_attr,
+				"battery-irq", battery);
+		if (ret) {
+			dev_err(battery->dev,
+				"%s: Failed to Request IRQ\n", __func__);
+			goto err_supply_unreg_ac;
+		}
+
+		ret = enable_irq_wake(battery->pdata->bat_irq);
+		if (ret < 0)
+			dev_err(battery->dev,
+			"%s: Failed to Enable Wakeup Source(%d)\n",
+			__func__, ret);
+	}
+
+	ret = sec_bat_create_attrs(battery->psy_bat.dev);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s : Failed to create_attrs\n", __func__);
+		goto err_req_irq;
+	}
+
+	ret = sec_usb_create_attrs(battery->psy_usb.dev);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s : Failed to create_usb_attr\n", __func__);
+		goto err_req_irq;
+	}
+
+	pdata->initial_check();
+
+	psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_ONLINE, value);
+
+	if (value.intval == POWER_SUPPLY_TYPE_BATTERY) {
+		dev_info(&pdev->dev,
+		"%s: SEC Battery Driver Monitorwork\n", __func__);
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+	}
+
+	battery->present = battery->pdata->check_battery_callback();
+
+	dev_dbg(battery->dev,
+		"%s: SEC Battery Driver Loaded\n", __func__);
+	return 0;
+
+err_req_irq:
+	if (battery->pdata->bat_irq)
+		free_irq(battery->pdata->bat_irq, battery);
+err_supply_unreg_ac:
+	power_supply_unregister(&battery->psy_ac);
+err_supply_unreg_usb:
+	power_supply_unregister(&battery->psy_usb);
+err_supply_unreg_bat:
+	power_supply_unregister(&battery->psy_bat);
+err_workqueue:
+	destroy_workqueue(battery->monitor_wqueue);
+err_wake_lock:
+	wake_lock_destroy(&battery->monitor_wake_lock);
+	wake_lock_destroy(&battery->cable_wake_lock);
+	wake_lock_destroy(&battery->vbus_wake_lock);
+	mutex_destroy(&battery->adclock);
+	kfree(battery);
+
+	return ret;
+}
+
+static int __devexit sec_battery_remove(struct platform_device *pdev)
+{
+	struct sec_battery_info *battery = platform_get_drvdata(pdev);
+	int i;
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	switch (battery->pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		cancel_delayed_work(&battery->polling_work);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		alarm_cancel(&battery->polling_alarm);
+		break;
+	default:
+		break;
+	}
+
+	alarm_cancel(&battery->event_termination_alarm);
+	flush_workqueue(battery->monitor_wqueue);
+	destroy_workqueue(battery->monitor_wqueue);
+	wake_lock_destroy(&battery->monitor_wake_lock);
+	wake_lock_destroy(&battery->cable_wake_lock);
+	wake_lock_destroy(&battery->vbus_wake_lock);
+#if defined(CONFIG_SEC_GPIO_DVS)
+	cancel_delayed_work(&battery->initdvs_work);
+#endif
+
+	mutex_destroy(&battery->adclock);
+	for (i = 0; i < SEC_BAT_ADC_CHANNEL_FULL_CHECK; i++)
+		adc_exit(battery->pdata, i);
+
+	power_supply_unregister(&battery->psy_ac);
+	power_supply_unregister(&battery->psy_usb);
+	power_supply_unregister(&battery->psy_bat);
+
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+
+	kfree(battery);
+
+	return 0;
+}
+
+static int sec_battery_prepare(struct device *dev)
+{
+	struct sec_battery_info *battery
+		= dev_get_drvdata(dev);
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	switch (battery->pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		cancel_delayed_work(&battery->polling_work);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		/*alarm_cancel(&battery->polling_alarm);*/
+		break;
+	default:
+		break;
+	}
+	cancel_delayed_work_sync(&battery->monitor_work);
+
+	battery->polling_in_sleep = true;
+
+	dev_info(battery->dev,
+			"%s: Call sec_bat_set_polling\n", __func__);
+	sec_bat_set_polling(battery);
+
+	/* cancel work for polling
+	 * that is set in sec_bat_set_polling()
+	 * no need for polling in sleep
+	 */
+	if (battery->pdata->polling_type ==
+		SEC_BATTERY_MONITOR_WORKQUEUE)
+		cancel_delayed_work(&battery->polling_work);
+
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+
+	return 0;
+}
+
+static int sec_battery_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int sec_battery_resume(struct device *dev)
+{
+	return 0;
+}
+
+static void sec_battery_complete(struct device *dev)
+{
+	struct sec_battery_info *battery
+		= dev_get_drvdata(dev);
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	wake_lock(&battery->monitor_wake_lock);
+	queue_delayed_work(battery->monitor_wqueue,
+		&battery->monitor_work, 0);
+
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+
+	return;
+}
+
+static void sec_battery_shutdown(struct device *dev)
+{
+	struct sec_battery_info *battery
+		= dev_get_drvdata(dev);
+
+	dev_info(battery->dev, "%s: Start\n", __func__);
+
+	switch (battery->pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		cancel_delayed_work(&battery->polling_work);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		alarm_cancel(&battery->polling_alarm);
+		break;
+	default:
+		break;
+	}
+
+	alarm_cancel(&battery->event_termination_alarm);
+	cancel_delayed_work_sync(&battery->monitor_work);
+
+	return;
+}
+
+static const struct dev_pm_ops sec_battery_pm_ops = {
+	.prepare = sec_battery_prepare,
+	.suspend = sec_battery_suspend,
+	.resume = sec_battery_resume,
+	.complete = sec_battery_complete,
+};
+
+static struct platform_driver sec_battery_driver = {
+	.driver = {
+		   .name = "sec-battery",
+		   .owner = THIS_MODULE,
+		   .pm = &sec_battery_pm_ops,
+		   .shutdown = sec_battery_shutdown,
+		   },
+	.probe = sec_battery_probe,
+	.remove = __devexit_p(sec_battery_remove),
+};
+
+static int __init sec_battery_init(void)
+{
+	return platform_driver_register(&sec_battery_driver);
+}
+
+static void __exit sec_battery_exit(void)
+{
+	platform_driver_unregister(&sec_battery_driver);
+}
+
+module_init(sec_battery_init);
+module_exit(sec_battery_exit);
+
+MODULE_DESCRIPTION("Samsung Battery Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff --git a/drivers/battery/sec_fuelgauge.c b/drivers/battery/sec_fuelgauge.c
new file mode 100755
index 00000000..22d460a5
--- /dev/null
+++ b/drivers/battery/sec_fuelgauge.c
@@ -0,0 +1,743 @@
+/*
+ *  sec_fuelgauge.c
+ *  Samsung Mobile Fuel Gauge Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/battery/sec_fuelgauge.h>
+
+static struct device_attribute sec_fg_attrs[] = {
+	SEC_FG_ATTR(reg),
+	SEC_FG_ATTR(data),
+	SEC_FG_ATTR(regs),
+};
+
+static enum power_supply_property sec_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+};
+
+/* capacity is  0.1% unit */
+static void sec_fg_get_scaled_capacity(
+				struct sec_fuelgauge_info *fuelgauge,
+				union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: scaled capacity (%d.%d)\n",
+		__func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void sec_fg_get_atomic_capacity(
+				struct sec_fuelgauge_info *fuelgauge,
+				union power_supply_propval *val)
+{
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+		if (fuelgauge->capacity_old < val->intval)
+			val->intval = fuelgauge->capacity_old + 1;
+		else if (fuelgauge->capacity_old > val->intval)
+			val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if ((fuelgauge->is_charging &&
+			fuelgauge->capacity_old > val->intval) ||
+			(!fuelgauge->is_charging &&
+			fuelgauge->capacity_old < val->intval)) {
+			dev_err(&fuelgauge->client->dev,
+				"%s: abnormal capacity (old %d : new %d)\n",
+				__func__, fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int sec_fg_get_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    union power_supply_propval *val)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+	int soc_type = val->intval;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_CAPACITY:
+	case POWER_SUPPLY_PROP_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		if (!sec_hal_fg_get_property(fuelgauge_variable, psp, val))
+			return -EINVAL;
+		if (psp == POWER_SUPPLY_PROP_CAPACITY) {
+			if (soc_type == SEC_FUELGAUGE_CAPACITY_TYPE_RAW)
+				break;
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+				 SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				sec_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			/* get only integer part */
+				val->intval /= 10;
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+				fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				sec_hal_fg_fuelalert_init(fuelgauge_variable,
+					fuelgauge->pdata->fuel_alert_soc);
+			}
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if (fuelgauge->initial_update_of_soc) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+				 SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				sec_fg_get_atomic_capacity(fuelgauge, val);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sec_fg_calculate_dynamic_scale(
+				struct sec_fuelgauge_info *fuelgauge)
+{
+	union power_supply_propval raw_soc_val;
+
+	raw_soc_val.intval = SEC_FUELGAUGE_CAPACITY_TYPE_RAW;
+	if (!sec_hal_fg_get_property(fuelgauge_variable,
+		POWER_SUPPLY_PROP_CAPACITY,
+		&raw_soc_val))
+		return -EINVAL;
+	raw_soc_val.intval /= 10;
+
+	if (raw_soc_val.intval <
+		fuelgauge->pdata->capacity_max -
+		fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		dev_dbg(&fuelgauge->client->dev, "%s: capacity_max (%d)",
+			__func__, fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		dev_dbg(&fuelgauge->client->dev, "%s: raw soc (%d)",
+			__func__, fuelgauge->capacity_max);
+	}
+
+	fuelgauge->capacity_max =
+		(fuelgauge->capacity_max * 99 / 100);
+
+	dev_info(&fuelgauge->client->dev, "%s: %d is used for capacity_max\n",
+		__func__, fuelgauge->capacity_max);
+
+	return fuelgauge->capacity_max;
+}
+
+static int sec_fg_set_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    const union power_supply_propval *val)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (val->intval == POWER_SUPPLY_STATUS_FULL)
+			sec_hal_fg_full_charged(fuelgauge_variable);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			if (fuelgauge->pdata->capacity_calculation_type &
+				SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE)
+				sec_fg_calculate_dynamic_scale(fuelgauge);
+		}
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		fuelgauge->cable_type = val->intval;
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY)
+			fuelgauge->is_charging = false;
+		else
+			fuelgauge->is_charging = true;
+
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+			if (!sec_hal_fg_reset(fuelgauge_variable))
+				return -EINVAL;
+			else
+				break;
+		}
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+	case POWER_SUPPLY_PROP_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		if (!sec_hal_fg_set_property(fuelgauge_variable, psp, val))
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void sec_fg_isr_work(struct work_struct *work)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(work, struct sec_fuelgauge_info, isr_work.work);
+
+	/* process for fuel gauge chip */
+	sec_hal_fg_fuelalert_process(fuelgauge, fuelgauge->is_fuel_alerted);
+
+	/* process for others */
+	fuelgauge->pdata->fuelalert_process(fuelgauge->is_fuel_alerted);
+}
+
+static irqreturn_t sec_fg_irq_thread(int irq, void *irq_data)
+{
+	struct sec_fuelgauge_info *fuelgauge = irq_data;
+	bool fuel_alerted;
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		fuel_alerted =
+			sec_hal_fg_is_fuelalerted(fuelgauge_variable);
+
+		dev_info(&fuelgauge->client->dev,
+			"%s: Fuel-alert %salerted!\n",
+			__func__, fuel_alerted ? "" : "NOT ");
+
+		if (fuel_alerted == fuelgauge->is_fuel_alerted) {
+			if (!fuelgauge->pdata->repeated_fuelalert) {
+				dev_dbg(&fuelgauge->client->dev,
+					"%s: Fuel-alert Repeated (%d)\n",
+					__func__, fuelgauge->is_fuel_alerted);
+				return IRQ_HANDLED;
+			}
+		}
+
+		if (fuel_alerted)
+			wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		else
+			wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+
+		fuelgauge->is_fuel_alerted = fuel_alerted;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sec_fg_create_attrs(struct device *dev)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(sec_fg_attrs); i++) {
+		rc = device_create_file(dev, &sec_fg_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	goto create_attrs_succeed;
+
+create_attrs_failed:
+	dev_err(dev, "%s: failed (%d)\n", __func__, rc);
+	while (i--)
+		device_remove_file(dev, &sec_fg_attrs[i]);
+create_attrs_succeed:
+	return rc;
+}
+
+ssize_t sec_fg_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	const ptrdiff_t offset = attr - sec_fg_attrs;
+	int i = 0;
+
+	switch (offset) {
+	case FG_REG:
+	case FG_DATA:
+	case FG_REGS:
+		i = sec_hal_fg_show_attrs(dev, offset, buf);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sec_fg_store_attrs(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	const ptrdiff_t offset = attr - sec_fg_attrs;
+	int ret = 0;
+
+	switch (offset) {
+	case FG_REG:
+	case FG_DATA:
+		ret = sec_hal_fg_store_attrs(dev, offset, buf, count);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+#if defined(CONFIG_FUELGAUGE_MFD)
+static int __devinit sec_fuelgauge_probe(struct platform_device *pdev)
+{
+	struct sec_fuelgauge_info *fuelgauge;
+#if defined(CONFIG_FUELGAUGE_D2199)
+	sec_fuelgauge_dev_t *mfd_dev = platform_get_drvdata(pdev);
+	sec_fuelgauge_pdata_t *pdata = mfd_dev->pdata;
+#else
+	sec_fuelgauge_dev_t *mfd_dev = dev_get_drvdata(pdev->dev.parent);
+	sec_fuelgauge_pdata_t *pdata = dev_get_platdata(mfd_dev->dev);
+#endif
+	int ret = 0;
+	bool fuelalert_init_ret = false;
+	union power_supply_propval raw_soc_val;
+
+	dev_info(&pdev->dev,
+		"%s: SEC Fuelgauge Driver Loading\n", __func__);
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, fuelgauge);
+#if defined(CONFIG_FUELGAUGE_D2199)
+	fuelgauge->client = mfd_dev->pmic_i2c_client;
+	fuelgauge->pdata = pdata->pbat_platform;
+#else
+	fuelgauge->client = mfd_dev->i2c;
+	fuelgauge->pdata = pdata->fuelgauge_data;
+#endif
+
+#if defined(CONFIG_FUELGAUGE_D2199)
+	fuelgauge->info.pd2199 = mfd_dev;
+#elif defined(CONFIG_FUELGAUGE_88PM822)
+	fuelgauge->info.chip = mfd_dev;
+	fuelgauge->info.dev = &pdev->dev;
+#endif
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->psy_fg.name		= "sec-fuelgauge";
+	fuelgauge->psy_fg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property	= sec_fg_get_property;
+	fuelgauge->psy_fg.set_property	= sec_fg_set_property;
+	fuelgauge->psy_fg.properties	= sec_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+		ARRAY_SIZE(sec_fuelgauge_props);
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = SEC_FUELGAUGE_CAPACITY_TYPE_RAW;
+	sec_hal_fg_get_property(fuelgauge,
+			POWER_SUPPLY_PROP_CAPACITY, &raw_soc_val);
+	raw_soc_val.intval /= 10;
+
+	if(raw_soc_val.intval > fuelgauge->pdata->capacity_max)
+		sec_fg_calculate_dynamic_scale(fuelgauge);
+	if (!fuelgauge->pdata->fg_gpio_init()) {
+		dev_err(&pdev->dev,
+			"%s: Failed to Initialize GPIO\n", __func__);
+		goto err_free;
+	}
+
+	if (!sec_hal_fg_init(fuelgauge)) {
+		dev_err(&pdev->dev,
+			"%s: Failed to Initialize Fuelgauge\n", __func__);
+		goto err_free;
+	}
+	ret = power_supply_register(&pdev->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"%s: Failed to Register psy_fg\n", __func__);
+		goto err_free;
+	}
+
+	fuelgauge->is_fuel_alerted = false;
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		fuelalert_init_ret =
+			sec_hal_fg_fuelalert_init(fuelgauge,
+					fuelgauge->pdata->fuel_alert_soc);
+		if (fuelalert_init_ret)
+			wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+				WAKE_LOCK_SUSPEND, "fuel_alerted");
+		else {
+			dev_err(&pdev->dev,
+				"%s: Failed to Initialize Fuel-alert\n",
+				__func__);
+			goto err_irq;
+		}
+	}
+
+	if (fuelgauge->pdata->fg_irq) {
+		INIT_DELAYED_WORK_DEFERRABLE(
+			&fuelgauge->isr_work, sec_fg_isr_work);
+
+		ret = request_threaded_irq(fuelgauge->pdata->fg_irq,
+				NULL, sec_fg_irq_thread,
+				fuelgauge->pdata->fg_irq_attr,
+				"fuelgauge-irq", fuelgauge);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_supply_unreg;
+		}
+
+		ret = enable_irq_wake(fuelgauge->pdata->fg_irq);
+		if (ret < 0)
+			dev_err(&pdev->dev,
+				"%s: Failed to Enable Wakeup Source(%d)\n",
+				__func__, ret);
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+
+	ret = sec_fg_create_attrs(fuelgauge->psy_fg.dev);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"%s : Failed to create_attrs\n", __func__);
+		goto err_irq;
+	}
+
+	dev_dbg(&pdev->dev,
+		"%s: SEC Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_irq:
+	if (fuelgauge->pdata->fg_irq)
+		free_irq(fuelgauge->pdata->fg_irq, fuelgauge);
+	if (fuelalert_init_ret)
+	wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_free:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static int __devexit sec_fuelgauge_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int sec_fuelgauge_suspend(struct device *dev)
+{
+	struct sec_fuelgauge_info *fuelgauge = dev_get_drvdata(dev);
+
+	if (!sec_hal_fg_suspend(fuelgauge))
+		dev_err(&fuelgauge->client->dev,
+			"%s: Failed to Suspend Fuelgauge\n", __func__);
+
+	return 0;
+}
+
+static int sec_fuelgauge_resume(struct device *dev)
+{
+	struct sec_fuelgauge_info *fuelgauge = dev_get_drvdata(dev);
+
+	if (!sec_hal_fg_resume(fuelgauge))
+		dev_err(&fuelgauge->client->dev,
+			"%s: Failed to Resume Fuelgauge\n", __func__);
+
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+
+static void sec_fuelgauge_shutdown(struct device *dev)
+{
+}
+
+static const struct dev_pm_ops sec_fuelgauge_pm_ops = {
+	.suspend = sec_fuelgauge_suspend,
+	.resume = sec_fuelgauge_resume,
+};
+
+static struct platform_driver sec_fuelgauge_driver = {
+	.driver = {
+		   .name = "sec-fuelgauge",
+		   .pm = &sec_fuelgauge_pm_ops,
+		   .shutdown = sec_fuelgauge_shutdown,
+		   },
+	.probe	= sec_fuelgauge_probe,
+	.remove	= __devexit_p(sec_fuelgauge_remove),
+};
+
+static int __init sec_fuelgauge_init(void)
+{
+	pr_info("###################### %s init!!!!!!!! ############################\n", __func__);
+	return platform_driver_register(&sec_fuelgauge_driver);
+}
+
+static void __exit sec_fuelgauge_exit(void)
+{
+	platform_driver_unregister(&sec_fuelgauge_driver);
+}
+
+#else
+static int __devinit sec_fuelgauge_probe(struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	struct sec_fuelgauge_info *fuelgauge;
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	int ret = 0;
+	bool fuelalert_init_ret = false;
+	union power_supply_propval raw_soc_val;
+
+	dev_dbg(&client->dev,
+		"%s: SEC Fuelgauge Driver Loading\n", __func__);
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+		return -EIO;
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->client = client;
+	fuelgauge->pdata = client->dev.platform_data;
+
+	i2c_set_clientdata(client, fuelgauge);
+
+	fuelgauge->psy_fg.name		= "sec-fuelgauge";
+	fuelgauge->psy_fg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property	= sec_fg_get_property;
+	fuelgauge->psy_fg.set_property	= sec_fg_set_property;
+	fuelgauge->psy_fg.properties	= sec_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+		ARRAY_SIZE(sec_fuelgauge_props);
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = SEC_FUELGAUGE_CAPACITY_TYPE_RAW;
+	sec_hal_fg_get_property(fuelgauge->client,
+			POWER_SUPPLY_PROP_CAPACITY, &raw_soc_val);
+	raw_soc_val.intval /= 10;
+	if(raw_soc_val.intval > fuelgauge->pdata->capacity_max)
+		sec_fg_calculate_dynamic_scale(fuelgauge);
+
+	if (!fuelgauge->pdata->fg_gpio_init()) {
+		dev_err(&client->dev,
+			"%s: Failed to Initialize GPIO\n", __func__);
+		goto err_free;
+	}
+
+	if (!sec_hal_fg_init(fuelgauge->client)) {
+		dev_err(&client->dev,
+			"%s: Failed to Initialize Fuelgauge\n", __func__);
+		goto err_free;
+	}
+
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		dev_err(&client->dev,
+			"%s: Failed to Register psy_fg\n", __func__);
+		goto err_free;
+	}
+
+	fuelgauge->is_fuel_alerted = false;
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		fuelalert_init_ret =
+			sec_hal_fg_fuelalert_init(fuelgauge->client,
+					fuelgauge->pdata->fuel_alert_soc);
+		if (fuelalert_init_ret)
+			wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+				WAKE_LOCK_SUSPEND, "fuel_alerted");
+		else {
+			dev_err(&client->dev,
+				"%s: Failed to Initialize Fuel-alert\n",
+				__func__);
+			goto err_irq;
+		}
+	}
+
+	if (fuelgauge->pdata->fg_irq) {
+		INIT_DELAYED_WORK_DEFERRABLE(
+			&fuelgauge->isr_work, sec_fg_isr_work);
+
+		ret = request_threaded_irq(fuelgauge->pdata->fg_irq,
+				NULL, sec_fg_irq_thread,
+				fuelgauge->pdata->fg_irq_attr,
+				"fuelgauge-irq", fuelgauge);
+		if (ret) {
+			dev_err(&client->dev,
+				"%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_supply_unreg;
+		}
+
+		ret = enable_irq_wake(fuelgauge->pdata->fg_irq);
+		if (ret < 0)
+			dev_err(&client->dev,
+				"%s: Failed to Enable Wakeup Source(%d)\n",
+				__func__, ret);
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+
+	ret = sec_fg_create_attrs(fuelgauge->psy_fg.dev);
+	if (ret) {
+		dev_err(&client->dev,
+			"%s : Failed to create_attrs\n", __func__);
+		goto err_irq;
+	}
+
+	dev_dbg(&client->dev,
+		"%s: SEC Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_irq:
+	if (fuelgauge->pdata->fg_irq)
+		free_irq(fuelgauge->pdata->fg_irq, fuelgauge);
+	if (fuelalert_init_ret)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_free:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static int __devexit sec_fuelgauge_remove(
+						struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+static int sec_fuelgauge_suspend(
+				struct i2c_client *client, pm_message_t state)
+{
+	if (!sec_hal_fg_suspend(client))
+		dev_err(&client->dev,
+			"%s: Failed to Suspend Fuelgauge\n", __func__);
+
+	return 0;
+}
+
+static int sec_fuelgauge_resume(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	if (!sec_hal_fg_resume(client))
+		dev_err(&client->dev,
+			"%s: Failed to Resume Fuelgauge\n", __func__);
+
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+
+static void sec_fuelgauge_shutdown(struct i2c_client *client)
+{
+}
+
+static const struct i2c_device_id sec_fuelgauge_id[] = {
+	{"sec-fuelgauge", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, sec_fuelgauge_id);
+
+static struct i2c_driver sec_fuelgauge_driver = {
+	.driver = {
+		   .name = "sec-fuelgauge",
+		   },
+	.probe	= sec_fuelgauge_probe,
+	.remove	= __devexit_p(sec_fuelgauge_remove),
+	.suspend    = sec_fuelgauge_suspend,
+	.resume		= sec_fuelgauge_resume,
+	.shutdown   = sec_fuelgauge_shutdown,
+	.id_table   = sec_fuelgauge_id,
+};
+
+static int __init sec_fuelgauge_init(void)
+{
+	return i2c_add_driver(&sec_fuelgauge_driver);
+}
+
+static void __exit sec_fuelgauge_exit(void)
+{
+	i2c_del_driver(&sec_fuelgauge_driver);
+}
+#endif
+
+module_init(sec_fuelgauge_init);
+module_exit(sec_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/88pm822_usb.c b/drivers/char/88pm822_usb.c
new file mode 100644
index 00000000..00382e3a
--- /dev/null
+++ b/drivers/char/88pm822_usb.c
@@ -0,0 +1,372 @@
+/*
+ * 88pm822 VBus driver for Marvell USB
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/88pm822.h>
+#include <linux/delay.h>
+#include <linux/platform_data/mv_usb.h>
+
+#if defined(CONFIG_SM5502_MUIC)
+#include <mach/sm5502-muic.h>
+extern int extert_muic_read_reg(u8 reg, u8 * data);
+#endif
+#if defined(CONFIG_MFD_RT8973)
+extern int rt8973_check_usb_status();
+#endif
+
+struct pm822_usb_info {
+	struct pm822_chip	*chip;
+	struct pm822_subchip	*subchip;
+	int			irq;
+	int			vbus_gpio;
+	int			id_gpadc;
+};
+
+/* bit definitions of PM822_GPADC_MEAS_EN2 : 0x02 */
+#define PM822_MEAS_GP0_EN			(1 << 2)
+#define PM822_MEAS_GP1_EN			(1 << 3)
+#define PM822_MEAS_GP2_EN			(1 << 4)
+#define PM822_MEAS_GP3_EN			(1 << 5)
+
+/* bit definitions of PM800_GPADC_MISC_GPFSM_EN : 0x06*/
+#define PM822_GPADC_MISC_GPFSM_EN	(1 << 0)
+
+static struct pm822_usb_info *vbus_info;
+
+static int pm822_read_usb_val(unsigned int *level)
+{
+	int ret;
+	unsigned int val;
+#if defined(CONFIG_SM5502_MUIC)
+	u8 data;
+#endif
+
+	ret = regmap_read(vbus_info->chip->regmap, PM822_STATUS1, &val);
+	if (ret)
+		return ret;
+#if defined(CONFIG_SM5502_MUIC)
+	extert_muic_read_reg(REG_DEV_T2, &data);
+	pr_info("%s: val=0x%x, data=0x%x\n", __func__, val, data);
+
+	if (data & DEV_JIG_ALL)
+		*level = VBUS_LOW;
+	else {
+		if (val & PM822_CHG_STS1)
+			*level = VBUS_HIGH;
+		else
+			*level = VBUS_LOW;
+	}
+#elif defined(CONFIG_MFD_RT8973)
+	if(rt8973_check_usb_status())
+		*level = VBUS_HIGH;
+	else
+		*level = VBUS_LOW;
+#else
+	if (val & PM822_CHG_STS1)
+		*level = VBUS_HIGH;
+	else
+		*level = VBUS_LOW;
+#endif
+	pr_info("pm822_read_usb_val VBUS = %d\n", *level);
+	return 0;
+}
+
+static int pm822_read_id_val(unsigned int *level)
+{
+	int ret, data;
+	unsigned int val;
+	unsigned int meas1, meas2, upp_th, low_th;
+
+	switch (vbus_info->id_gpadc) {
+	case PM822_GPADC0:
+		meas1 = PM822_GPADC0_MEAS1;
+		meas2 = PM822_GPADC0_MEAS2;
+		low_th = PM822_GPADC0_LOW_TH;
+		upp_th = PM822_GPADC0_UPP_TH;
+		break;
+	case PM822_GPADC1:
+		meas1 = PM822_GPADC1_MEAS1;
+		meas2 = PM822_GPADC1_MEAS2;
+		low_th = PM822_GPADC1_LOW_TH;
+		upp_th = PM822_GPADC1_UPP_TH;
+		break;
+	case PM822_GPADC2:
+		meas1 = PM822_GPADC2_MEAS1;
+		meas2 = PM822_GPADC2_MEAS2;
+		low_th = PM822_GPADC2_LOW_TH;
+		upp_th = PM822_GPADC2_UPP_TH;
+		break;
+	case PM822_GPADC3:
+		meas1 = PM822_GPADC3_MEAS1;
+		meas2 = PM822_GPADC3_MEAS2;
+		low_th = PM822_GPADC3_LOW_TH;
+		upp_th = PM822_GPADC3_UPP_TH;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	ret = regmap_read(vbus_info->subchip->regmap_gpadc, meas1, &val);
+	data = val << 4;
+	if (ret)
+		return ret;
+
+	ret = regmap_read(vbus_info->subchip->regmap_gpadc, meas2, &val);
+	data |= val & 0x0F;
+	if (ret)
+		return ret;
+	if (data > 0x10) {
+		regmap_write(vbus_info->subchip->regmap_gpadc, low_th, 0x10);
+		if (ret)
+			return ret;
+
+		regmap_write(vbus_info->subchip->regmap_gpadc, upp_th, 0xff);
+		if (ret)
+			return ret;
+
+		*level = 1;
+	} else {
+		regmap_write(vbus_info->subchip->regmap_gpadc, low_th, 0);
+		if (ret)
+			return ret;
+
+		regmap_write(vbus_info->subchip->regmap_gpadc, upp_th, 0x10);
+		if (ret)
+			return ret;
+
+		*level = 0;
+	}
+
+	return 0;
+};
+
+int pm822_init_id(void)
+{
+	int ret;
+	unsigned int en;
+
+	switch (vbus_info->id_gpadc) {
+	case PM822_GPADC0:
+		en = PM822_MEAS_GP0_EN;
+		break;
+	case PM822_GPADC1:
+		en = PM822_MEAS_GP1_EN;
+		break;
+	case PM822_GPADC2:
+		en = PM822_MEAS_GP2_EN;
+		break;
+	case PM822_GPADC3:
+		en = PM822_MEAS_GP3_EN;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+
+	ret = regmap_update_bits(vbus_info->subchip->regmap_gpadc,
+					PM822_GPADC_MEAS_EN2, en, en);
+	if (ret)
+		return ret;
+
+	ret = regmap_update_bits(vbus_info->subchip->regmap_gpadc,
+		PM822_GPADC_MISC_CONFIG2, PM822_GPADC_MISC_GPFSM_EN,
+		PM822_GPADC_MISC_GPFSM_EN);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int pm822_set_vbus(unsigned int vbus)
+{
+	int ret;
+	unsigned int data = 0, mask, reg = 0;
+
+	switch (vbus_info->vbus_gpio) {
+	case PM822_NO_GPIO:
+		/* OTG5V not supported - Do nothing */
+		return 0;
+
+	case PM822_GPIO0:
+		/* OTG5V Enable/Disable is connected to GPIO_0 */
+		mask = PM822_GPIO0_GPIO_MODE(0x01) | PM822_GPIO0_VAL;
+		reg = PM822_GPIO0_CTRL;
+		break;
+
+	case PM822_GPIO1:
+		/* OTG5V Enable/Disable is connected to GPIO_1 */
+		mask = PM822_GPIO1_GPIO_MODE(0x01) | PM822_GPIO1_VAL;
+		reg = PM822_GPIO1_CTRL;
+		break;
+
+	case PM822_GPIO2:
+		/* OTG5V Enable/Disable is connected to GPIO_2 */
+		mask = PM822_GPIO2_GPIO_MODE(0x01) | PM822_GPIO2_VAL;
+		reg = PM822_GPIO2_CTRL;
+		break;
+
+	case PM822_GPIO3:
+		/* OTG5V Enable/Disable is connected to GPIO_3 */
+		mask = PM822_GPIO3_GPIO_MODE(0x01) | PM822_GPIO3_VAL;
+		reg = PM822_GPIO3_CTRL;
+		break;
+
+	default:
+		return -ENODEV;
+	}
+
+	if (vbus == VBUS_HIGH)
+		data = mask;
+
+	ret = regmap_update_bits(vbus_info->chip->regmap, reg, mask, data);
+	if (ret)
+		return ret;
+
+	mdelay(20);
+
+	ret = pm822_read_usb_val(&data);
+	if (ret)
+		return ret;
+
+	if (ret != vbus)
+		pr_info("vbus set failed %x\n", vbus);
+	else
+		pr_info("vbus set done %x\n", vbus);
+
+	return 0;
+}
+
+static irqreturn_t vbus_irq(int irq, void *dev)
+{
+	pxa_usb_notify(PXA_USB_DEV_OTG, EVENT_VBUS, 0);
+
+	return IRQ_HANDLED;
+}
+
+
+static int __devinit pm822_usb_probe(struct platform_device *pdev)
+{
+	struct pm822_chip *chip = dev_get_drvdata(pdev->dev.parent);
+	struct pm822_platform_data *pm822_pdata;
+	struct pm822_usb_info *usb;
+	int ret;
+
+	if (pdev->dev.parent->platform_data) {
+		pm822_pdata = pdev->dev.parent->platform_data;
+	} else {
+		pr_debug("Invalid pm822 platform data!\n");
+		return -EINVAL;
+	}
+
+	usb = kzalloc(sizeof(struct pm822_usb_info), GFP_KERNEL);
+	if (!usb)
+		return -ENOMEM;
+
+	usb->chip = chip;
+	usb->subchip = chip->subchip;
+
+	if (pm822_pdata->usb) {
+		usb->vbus_gpio = pm822_pdata->usb->vbus_gpio;
+		usb->id_gpadc = pm822_pdata->usb->id_gpadc;
+	}
+
+	usb->irq = platform_get_irq(pdev, 0);
+	if (usb->irq < 0) {
+		dev_err(&pdev->dev, "failed to get vbus irq\n");
+		ret = -ENXIO;
+		goto out;
+	}
+
+	usb->irq += chip->irq_base;
+
+	ret = request_threaded_irq(usb->irq, NULL,
+			vbus_irq, IRQF_ONESHOT, "88pm800-usb-vbus", usb);
+	if (ret) {
+		dev_info(&pdev->dev,
+			"Can not request irq for VBUS, "
+			"disable clock gating\n");
+	}
+
+	vbus_info = usb;
+	platform_set_drvdata(pdev, usb);
+	device_init_wakeup(&pdev->dev, 1);
+
+	pxa_usb_set_extern_call(PXA_USB_DEV_OTG, vbus, set_vbus,
+				pm822_set_vbus);
+	pxa_usb_set_extern_call(PXA_USB_DEV_OTG, vbus, get_vbus,
+				pm822_read_usb_val);
+
+	pxa_usb_set_extern_call(PXA_USB_DEV_OTG, idpin, get_idpin,
+				pm822_read_id_val);
+	pxa_usb_set_extern_call(PXA_USB_DEV_OTG, idpin, init,
+				pm822_init_id);
+	return 0;
+
+out:
+	kfree(usb);
+	return ret;
+}
+
+static int __devexit pm822_usb_remove(struct platform_device *pdev)
+{
+	struct pm822_usb_info *usb = platform_get_drvdata(pdev);
+
+	if (usb) {
+		platform_set_drvdata(pdev, NULL);
+		kfree(usb);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int pm822_usb_suspend(struct device *dev)
+{
+	return pm822_dev_suspend(dev);
+}
+
+static int pm822_usb_resume(struct device *dev)
+{
+	return pm822_dev_resume(dev);
+}
+
+static const struct dev_pm_ops pm822_usb_pm_ops = {
+	.suspend	= pm822_usb_suspend,
+	.resume		= pm822_usb_resume,
+};
+#endif
+
+static struct platform_driver pm822_usb_driver = {
+	.driver		= {
+		.name	= "88pm822-usb",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm	= &pm822_usb_pm_ops,
+#endif
+	},
+	.probe		= pm822_usb_probe,
+	.remove		= __devexit_p(pm822_usb_remove),
+};
+
+static int __init pm822_usb_init(void)
+{
+	return platform_driver_register(&pm822_usb_driver);
+}
+module_init(pm822_usb_init);
+
+static void __exit pm822_usb_exit(void)
+{
+	platform_driver_unregister(&pm822_usb_driver);
+}
+module_exit(pm822_usb_exit);
+
+MODULE_DESCRIPTION("VBUS driver for Marvell Semiconductor 88PM822");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:88pm822-usb");
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index ee946865..f518c8b6 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -6,6 +6,19 @@ menu "Character devices"
 
 source "drivers/tty/Kconfig"
 
+config DEVMEM
+	bool "Memory device driver"
+	default y
+	help
+	  The memory driver provides two character devices, mem and kmem, which
+	  provide access to the system's memory. The mem device is a view of
+	  physical memory, and each byte in the device corresponds to the
+	  matching physical address. The kmem device is the same as mem, but
+	  the addresses correspond to the kernel's virtual address space rather
+	  than physical memory. These devices are standard parts of a Linux
+	  system and most users should say Y here. You might say N if very
+	  security conscience or memory is tight.
+
 config DEVKMEM
 	bool "/dev/kmem virtual device support"
 	default y
@@ -583,6 +596,10 @@ config DEVPORT
 	depends on ISA || PCI
 	default y
 
+config DCC_TTY
+	tristate "DCC tty driver"
+	depends on ARM
+
 source "drivers/s390/char/Kconfig"
 
 config RAMOOPS
@@ -593,6 +610,32 @@ config RAMOOPS
 	  This enables panic and oops messages to be logged to a circular
 	  buffer in RAM where it can be read back at some later point.
 
+config VIBRATOR_88PM80X
+        tristate "88pm80X based vibrator"
+        depends on MFD_88PM800
+        depends on ANDROID_TIMED_OUTPUT
+        default y
+        help
+          Say Y here if you want to enable 88pm860x or 88pm80x vibrator driver
+
+config VIBRATOR_88PM822
+        tristate "88pm822 based vibrator"
+        depends on MFD_88PM822
+        depends on ANDROID_TIMED_OUTPUT
+        default y
+        help
+          Say Y here if you want to enable 88pm860x or 88pm822 vibrator driver
+	   it depends on ANDROID_TIMED_OUTPUT,
+	   so if you want to use vibrator driver
+	   you have to enbale ANDROID_TIMED_OUTPUT config.
+
+config VIBRATOR_ANDROID
+        tristate "vibrator"
+	depends on ANDROID_TIMED_OUTPUT
+        default y
+        help
+          Say Y here if you want to enable defualt vibrator driver
+
 config MSM_SMD_PKT
 	bool "Enable device interface for some SMD packet ports"
 	default n
@@ -601,6 +644,34 @@ config MSM_SMD_PKT
 	  Enables userspace clients to read and write to some packet SMD
 	  ports via device interface for MSM chipset.
 
+config PXA9XX_ACIPC
+	tristate "PXA9xx AC-IPC Driver"
+	depends on CPU_PXA910 || CPU_PXA988 || CPU_PXA1088 || PXA93x || PXA95x
+	help
+	  Please say Y here if want to support Application to
+	  Communication Intel-Processor Communication on PXA910,
+	  PXA93x,PXA95x, PXA978, PXA988 and PXA1088 chip
+
+config USB_88PM80X
+	tristate "Marvell USB 88PM80x PMIC support"
+	depends on MFD_88PM800
+	help
+	  Say Y here if you have a 88PM860x PMIC to detect USB Vbus/IDpin event.
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the module will
+	  be called 88pm80x_usb.
+
+config USB_88PM822
+	tristate "Marvell USB 88PM822 PMIC support"
+	depends on MFD_88PM822
+	help
+	  Say Y here if you have a 88PM822 PMIC to detect USB Vbus/IDpin event.
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the module will
+	  be called 88pm822_usb.
+
 config TILE_SROM
 	bool "Character-device access via hypervisor to the Tilera SPI ROM"
 	depends on TILE
@@ -612,5 +683,7 @@ config TILE_SROM
 	  device appear much like a simple EEPROM, and knows
 	  how to partition a single ROM for multiple purposes.
 
+source "drivers/char/maxscend/Kconfig"
+
 endmenu
 
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 0dc5d7ce..d816913c 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -57,10 +57,17 @@ obj-$(CONFIG_IPMI_HANDLER)	+= ipmi/
 obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM)		+= tpm/
 
+obj-$(CONFIG_DCC_TTY)		+= dcc_tty.o
 obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
 obj-$(CONFIG_RAMOOPS)		+= ramoops.o
+obj-$(CONFIG_VIBRATOR_88PM80X)  += 88pm80x_vibrator.o
+obj-$(CONFIG_VIBRATOR_88PM822)  += 88pm822_vibrator.o
+obj-$(CONFIG_VIBRATOR_ANDROID) += android_vibrator.o
 
 obj-$(CONFIG_JS_RTC)		+= js-rtc.o
 js-rtc-y = rtc.o
-
+obj-$(CONFIG_PXA9XX_ACIPC)	+= pxa9xx_acipc.o
+obj-$(CONFIG_MXDCMMB)		+= maxscend/
 obj-$(CONFIG_TILE_SROM)		+= tile-srom.o
+obj-$(CONFIG_USB_88PM80X)	+= 88pm80x_usb.o
+obj-$(CONFIG_USB_88PM822)	+= 88pm822_usb.o
diff --git a/drivers/char/maxscend/Kconfig b/drivers/char/maxscend/Kconfig
new file mode 100644
index 00000000..0b8153fb
--- /dev/null
+++ b/drivers/char/maxscend/Kconfig
@@ -0,0 +1,16 @@
+#
+# maxscend cmmb driver configuration
+#
+#
+menuconfig MXDCMMB
+	tristate "Maxscend cmmb driver"
+help
+	Maxdscend cmmb driver support spi/sdio mode transfer base on mxd0265.
+
+if MXDCMMB
+	config MXDCMMB_DEBUG
+		boolean "Debug support for mxd cmmb drivers"
+	help
+		Say "yes" to enable debug messaging (like dev_dbg and pr_debug),
+		in mxd cmmb drivers.
+endif
diff --git a/drivers/char/maxscend/Makefile b/drivers/char/maxscend/Makefile
new file mode 100644
index 00000000..0cf2dcf5
--- /dev/null
+++ b/drivers/char/maxscend/Makefile
@@ -0,0 +1,3 @@
+cmmb_mxd-objs:= mxdspi_pxa.o
+
+obj-$(CONFIG_MXDCMMB) += cmmb_mxd.o
diff --git a/drivers/char/maxscend/mxdchar.h b/drivers/char/maxscend/mxdchar.h
new file mode 100644
index 00000000..19c16277
--- /dev/null
+++ b/drivers/char/maxscend/mxdchar.h
@@ -0,0 +1,34 @@
+/*
+* Copyright (C) 2011 Marvell International Ltd.
+*		Jialing Fu <jlfu@marvell.com>
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+*/
+
+#ifndef __MXD_CHAR_IOCTL_H__
+#define __MXD_CHAR_IOCTL_H__
+#include <linux/ioctl.h>
+
+struct mxdchar_spi_t {
+	unsigned char *txbuffer;	/* if no tx, set to NULL */
+	unsigned char *rxbuffer;	/* if no rx, set to NULL */
+	int txlength;		/* if no tx, set to 0 */
+	int rxlength;		/* if no rx, set to 0 */
+	/* if both rxbuffer and txbuffer are not NULL
+	* rx_len and tx_len should be equal
+	*/
+};
+
+#define MXDSPI_IOC_RW		_IOWR('K', 40, struct mxdchar_spi_t)
+#define MXDSPI_IOC_R		_IOR('K', 41, struct mxdchar_spi_t)
+#define MXDSPI_IOC_W		_IOW('K', 42, struct mxdchar_spi_t)
+
+#endif	/* __MXD_CHAR_IOCTL_H__ */
diff --git a/drivers/char/maxscend/mxdspi_pxa.c b/drivers/char/maxscend/mxdspi_pxa.c
new file mode 100644
index 00000000..05eaef6d
--- /dev/null
+++ b/drivers/char/maxscend/mxdspi_pxa.c
@@ -0,0 +1,879 @@
+/*
+ * Copyright (C) 2011 Marvell International Ltd.
+ *		Jialing Fu <jlfu@marvell.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*
+ * TODO:
+ * 1. clean the comment
+ * 2. double check the lock mechanism
+ * 3. remove unnecessary h file
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/ioctl.h>
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spidev.h>
+#include <linux/spi/cmmb.h>
+
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+
+#include <mach/dma.h>
+#include <mach/addr-map.h>
+#include "mxdchar.h"
+
+#ifdef CONFIG_MXDCMMB_DEBUG
+#define LOG_ERR(fmt, x...) pr_err(fmt, ##x)
+#define LOG_INFO(fmt, x...) pr_info(fmt, ##x)
+#define LOG_DEBUG(fmt, x...) pr_info(fmt, ##x)
+#else
+#define LOG_ERR(fmt, x...) pr_err(fmt, ##x)
+#define LOG_INFO(fmt, x...)
+#define LOG_DEBUG(fmt, x...)
+#endif
+
+#define DRIVER_NAME "cmmb_if"
+
+/*Begin of SPI interface */
+/*
+ * Here is a spi transfer limitation:
+ * some platform can't support very large spi burst transfer
+ * example:the pxa910 spi driver code support 8191B maxinum
+ *
+ * the transfer can split to muti transfer in chip_spi_xfer
+ * if the xfer len is larger then the limit
+ */
+#define PXA_SPI_MAX_SIZE		4096
+
+/* some SPI definition*/
+#define MXD_SPI_BITS_PER_WORD	(8)
+#define MXD_SPI_WORK_SPEED_HZ	(13000000)
+#define MXD_SPI_INIT_SPEED_HZ	(13000000)
+/* Bit masks for spi_device.mode management.  Note that incorrect
+ * settings for CS_HIGH and 3WIRE can cause *lots* of trouble for other
+ * devices on a shared bus:  CS_HIGH, because this device will be
+ * active when it shouldn't be;  3WIRE, because when active it won't
+ * behave as it should.
+ *
+ * REVISIT should changing those two modes be privileged?
+ */
+#define SPI_MODE_MASK           (SPI_CPHA | SPI_CPOL | SPI_CS_HIGH \
+					| SPI_LSB_FIRST | SPI_3WIRE | SPI_LOOP)
+/*End of SPI interface */
+
+/*
+ * If the platform dosen't provide the callback functions to
+ * control the POWER or RESET, or the driver want to control
+ * the pin directlly,
+ * define "DRIVER_HANDLE_GPIO" Here
+ */
+#define DRIVER_HANDLE_GPIO
+
+/*
+ * If the platform dosen't pass the pin definition,or the
+ * driver want to set the pin num directlly,
+ * define the "PIN_DEFINED_BY_DRIVE" Here.
+ *
+ * You can define the power/reset/spi_cs pin num in this file
+ * directlly. By this way,the driver is easy to debug or port
+ */
+/*#define PIN_DEFINED_BY_DRIVE*/
+#define POWER_PIN_NUM			150
+#define RESET_PIN_NUM			151
+#define SPI_CS_PIN_NUM			34
+
+#define SPIDEV_MAJOR            0	/* assigned */
+#define N_SPI_MINORS            32	/* ... up to 256 */
+static unsigned long minors[N_SPI_MINORS / BITS_PER_LONG];
+static int mxdspi_major = SPIDEV_MAJOR;
+
+static LIST_HEAD(device_list);
+static DEFINE_MUTEX(device_list_lock);
+
+struct cmmbspi_dev {
+	dev_t devt;
+	spinlock_t spi_lock;
+	struct spi_device *spi;
+	struct list_head device_entry;
+
+	/* Interrupt Register */
+	int irq;
+	unsigned long irq_flag;	/* irq flag */
+	unsigned char irq_enable;
+	wait_queue_head_t iowait;	/* use for user space polling */
+
+	/* HW Subsystem structures */
+	int gpio_power;		/* the pin to power on/off the module */
+	int gpio_reset;		/* the pin to reset  the module */
+	int gpio_cs;		/* spi cs pin num */
+	int gpio_defined;	/* The platform has set the GPIO */
+
+	/* DMA buffers */
+	int mapcount;
+	unsigned int dma_buf_size;	/* allocated size */
+	int order;		/* Internal buffer addresses */
+
+	void *dma_rx_bufs;	/* Internal Rx buffer addresses */
+	dma_addr_t dma_rx_handles;	/* Buffer Rx bus addresses */
+	void *dma_tx_bufs;	/* Internal Tx buffer addresses */
+	dma_addr_t dma_tx_handles;	/* Tx Buffer bus addresses */
+	int is_tx_clean;	/* whether dma_tx_bufs has be cleaned */
+
+	/* buffer is NULL unless this device is open (users > 0) */
+	struct mutex buf_lock;
+	unsigned int users;
+	unsigned char *buffer;
+};
+
+/*
+ * The porting layer, according to different host platform.
+ *
+ * The below SPI functions use the struct cmmbspi_dev,instead of
+ * struct spi_device.
+ * The purposes are
+ *  1.make the interface simple
+ *  2.easy to add other features in the further if need
+ *
+ * if the chip_xxx return 0, it is OK, other is not OK
+ */
+
+static int chip_power_reset(struct cmmbspi_dev *cmmb_dev)
+{
+#ifdef DRIVER_HANDLE_GPIO
+	int chip_rst;
+	int rst_loop;
+	LOG_DEBUG("sms smschipreset\n");
+	chip_rst = cmmb_dev->gpio_reset;
+	if (gpio_request(chip_rst, "cmmb rst")) {
+		LOG_ERR("failed to request GPIO for CMMB RST\n");
+		return -EIO;
+	}
+
+	/* reset chip twice,work around to fix reset fail sometimes */
+	rst_loop = 1;		/* change to 1 for mxd device */
+	while (rst_loop--) {
+		/* reset cmmb, keep low for about 1ms */
+		gpio_direction_output(chip_rst, 0);
+		msleep(20);	/* 10ms enough */
+
+		/* get cmmb go out of reset state */
+		gpio_direction_output(chip_rst, 1);
+		/* wait for at least 100ms after reset */
+		msleep(20);	/* TODO:Check with HW Engineer */
+
+	}
+
+	gpio_free(chip_rst);
+	return 0;
+#else
+	struct cmmb_platform_data *pdata;
+	pdata = cmmb_dev->spi->dev.platform_data;
+	if (!pdata || !pdata->power_reset)
+		return -EIO;
+	pdata->power_reset();
+	return 0;
+#endif
+}
+
+static int chip_power_on(struct cmmbspi_dev *cmmb_dev)
+{
+#ifdef DRIVER_HANDLE_GPIO
+	int chip_en;
+
+	chip_en = cmmb_dev->gpio_power;
+	if (gpio_request(chip_en, "cmmb power")) {
+		LOG_ERR("[ERROR] failed to request GPIO for CMMB POWER\n");
+		return -EIO;
+	}
+	gpio_direction_output(chip_en, 0);
+	msleep(20);		/* TODO:Check with HW Engineer */
+
+	gpio_direction_output(chip_en, 1);
+	msleep(20);		/* TODO:Check with HW Engineer */
+
+	gpio_free(chip_en);
+
+	return chip_power_reset(cmmb_dev);
+#else
+	struct cmmb_platform_data *pdata;
+
+	pdata = cmmb_dev->spi->dev.platform_data;
+	if (!pdata || !pdata->power_on)
+		return -EIO;
+	pdata->power_on();
+
+	return 0;
+#endif
+}
+
+static int chip_power_down(struct cmmbspi_dev *cmmb_dev)
+{
+#ifdef DRIVER_HANDLE_GPIO
+	int chip_en;
+
+	chip_en = cmmb_dev->gpio_power;
+	if (gpio_request(chip_en, "cmmb power")) {
+		LOG_ERR("failed to request GPIO for CMMB POWER\n");
+		return -EIO;
+	}
+
+	gpio_direction_output(chip_en, 0);
+	msleep(20);		/* TODO:Check with HW Engineer */
+	gpio_free(chip_en);
+
+	return 0;
+#else
+	struct cmmb_platform_data *pdata;
+
+	pdata = cmmb_dev->spi->dev.platform_data;
+	if (!pdata || !pdata->power_off)
+		return -EIO;
+	pdata->power_off();
+
+	return 0;
+#endif
+}
+
+static void chip_cs_assert(struct cmmbspi_dev *cmmb_dev)
+{
+#ifdef DRIVER_HANDLE_GPIO
+	int cs;
+	cs = cmmb_dev->gpio_cs;
+	gpio_direction_output(cs, 0);
+#else
+	struct cmmb_platform_data *pdata;
+
+	pdata = cmmb_dev->spi->dev.platform_data;
+	if (!pdata || !pdata->cs_assert)
+		return;
+	pdata->cs_assert();
+#endif
+}
+
+static void chip_cs_deassert(struct cmmbspi_dev *cmmb_dev)
+{
+#ifdef DRIVER_HANDLE_GPIO
+	int cs;
+	cs = cmmb_dev->gpio_cs;
+	gpio_direction_output(cs, 1);
+#else
+	struct cmmb_platform_data *pdata;
+
+	pdata = cmmb_dev->spi->dev.platform_data;
+	if (!pdata || !pdata->cs_deassert)
+		return;
+	pdata->cs_deassert();
+#endif
+}
+
+/* -------------------------------------------------------------------- */
+/*
+ * DMA buffer management.  These functions need s_mutex held.
+ */
+static int chip_alloc_dma_bufs(struct cmmbspi_dev *cmmb_dev)
+{
+	LOG_DEBUG("enter to chip_alloc_dma_bufs\n");
+
+	cmmb_dev->dma_buf_size = PXA_SPI_MAX_SIZE;
+
+	cmmb_dev->order = get_order(cmmb_dev->dma_buf_size);
+	cmmb_dev->dma_rx_bufs =
+	    (unsigned long *)__get_free_pages(GFP_KERNEL, cmmb_dev->order);
+	if (cmmb_dev->dma_rx_bufs == NULL) {
+		LOG_ERR("Failed to allocate Rx DMA buffer\n");
+		return -ENOMEM;
+	}
+	cmmb_dev->dma_rx_handles = __pa(cmmb_dev->dma_rx_bufs);
+
+	cmmb_dev->dma_tx_bufs =
+	    (unsigned long *)__get_free_pages(GFP_KERNEL, cmmb_dev->order);
+	if (cmmb_dev->dma_tx_bufs == NULL) {
+		LOG_ERR("Failed to allocate Tx DMA buffer\n");
+		free_pages((unsigned long)cmmb_dev->dma_rx_bufs,
+			   cmmb_dev->order);
+		cmmb_dev->dma_rx_bufs = NULL;
+		return -ENOMEM;
+	}
+	cmmb_dev->dma_tx_handles = __pa(cmmb_dev->dma_tx_bufs);
+
+	/* For debug, remove eventually */
+	memset(cmmb_dev->dma_rx_bufs, 0xcc, cmmb_dev->dma_buf_size);
+	memset(cmmb_dev->dma_tx_bufs, 0x00, cmmb_dev->dma_buf_size);
+
+	return 0;
+}
+
+static void chip_free_dma_bufs(struct cmmbspi_dev *cmmb_dev)
+{
+	LOG_DEBUG("enter to chip free_dma_bufs\n");
+	if (cmmb_dev->dma_rx_bufs) {
+		free_pages((unsigned long)cmmb_dev->dma_rx_bufs,
+			   cmmb_dev->order);
+		cmmb_dev->dma_rx_bufs = NULL;
+	}
+
+	if (cmmb_dev->dma_tx_bufs) {
+		free_pages((unsigned long)cmmb_dev->dma_tx_bufs,
+			   cmmb_dev->order);
+		cmmb_dev->dma_tx_bufs = NULL;
+	}
+}
+
+static int spi_duplex_xfer(struct spi_device *spi,
+			   const u8 *txbuffer, u8 *rxbuffer, int length)
+{
+	struct spi_transfer t = {
+		.tx_buf = txbuffer,
+		.rx_buf = rxbuffer,
+		.len = length,
+	};
+	struct spi_message m;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	return spi_sync(spi, &m);
+}
+
+static int chip_spi_xfer(struct cmmbspi_dev *cmmb_dev,
+			 const u8 *txbuffer, u8 *rxbuffer, int length)
+{
+	struct spi_device *spi = cmmb_dev->spi;
+	int offset = 0;
+	int temp_size = 0;
+	int ret;
+
+	if (!txbuffer) {
+		if (!cmmb_dev->is_tx_clean) {
+			memset(cmmb_dev->dma_tx_bufs, 0x00, PXA_SPI_MAX_SIZE);
+			cmmb_dev->is_tx_clean = 1;
+		}
+	}
+
+	while (length) {
+		temp_size =
+		    (length >= PXA_SPI_MAX_SIZE) ? PXA_SPI_MAX_SIZE : length;
+
+		if (txbuffer) {
+			/* Spi Write has real data */
+			cmmb_dev->is_tx_clean = 0;
+			/* memcpy(cmmb_dev->dma_tx_bufs, txbuffer + offset,
+			   temp_size); */
+			ret = copy_from_user((u8 *) cmmb_dev->dma_tx_bufs,
+					     (unsigned char *)txbuffer + offset,
+					     temp_size);
+			if (ret) {
+				LOG_ERR("%s: copy_from_user error!", __func__);
+				break;
+			}
+
+		}
+		ret = spi_duplex_xfer(spi,
+				      (const u8 *)cmmb_dev->dma_tx_bufs,
+				      (u8 *) cmmb_dev->dma_rx_bufs, temp_size);
+
+		if (ret) {
+			LOG_ERR
+			    ("%s: spi_write_read to cmmb device error! %d \r\n",
+			     __func__, ret);
+			break;
+		}
+		if (rxbuffer) {
+			/* Spi Read has read data */
+			/* memcpy(rxbuffer + offset, cmmb_dev->dma_rx_bufs,
+			   temp_size); */
+			ret = copy_to_user((unsigned char *)rxbuffer + offset,
+				(u8 *)cmmb_dev->dma_rx_bufs, temp_size);
+			if (ret) {
+				LOG_ERR("%s: copy_to_user error!", __func__);
+				break;
+			}
+		}
+		offset += temp_size;
+		length -= temp_size;
+	}
+	return length;
+}
+
+/*
+ * This function provide an API for user space SPI full duplex.
+ * txbuffer,rxbuffer is passed from user space.
+ *
+ */
+static int cmmb_spi_xfer(struct cmmbspi_dev *cmmb_dev,
+			 const u8 *txbuffer, int txlength,
+			 u8 *rxbuffer, int rxlength)
+{
+
+	int xfer_len, un_xfer;
+	xfer_len = (txlength >= rxlength) ? txlength : rxlength;
+
+	chip_cs_assert(cmmb_dev);
+	un_xfer = chip_spi_xfer(cmmb_dev, txbuffer, rxbuffer, xfer_len);
+	chip_cs_deassert(cmmb_dev);
+
+	return un_xfer;
+}
+
+/*
+ * SPI has a character major number assigned.  We allocate minor numbers
+ * dynamically using a bitmask.  You must use hotplug tools, such as udev
+ * (or mdev with busybox) to create and destroy the /dev/mxdspidevB.C device
+ * nodes, since there is no fixed association of minor numbers with any
+ * particular SPI bus or device.
+ */
+
+/*
+ * We can't use the standard synchronous wrappers for file I/O; we
+ * need to protect against async removal of the underlying spi_device.
+ */
+/*-------------------------------------------------------------------------*/
+
+/* Read-only message with current device setup */
+static ssize_t
+mxdspidev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	struct cmmbspi_dev *cmmb_dev = (struct cmmbspi_dev *)filp->private_data;
+	int un_xfer;
+	ssize_t xfer;
+
+	LOG_DEBUG("read buf:0x%x,len:%d\n", (unsigned int)buf, count);
+	un_xfer = cmmb_spi_xfer(cmmb_dev, NULL, 0, buf, count);
+	xfer = count - un_xfer;
+
+	return xfer;
+}
+
+/* Write-only message with current device setup */
+static ssize_t
+mxdspidev_write(struct file *filp, const char __user *buf,
+	size_t count, loff_t *f_pos)
+{
+	struct cmmbspi_dev *cmmb_dev = (struct cmmbspi_dev *)filp->private_data;
+	int un_xfer;
+	ssize_t xfer;
+
+	LOG_DEBUG("write buf:0x%x,len:%d\n", (unsigned int)buf, count);
+	un_xfer = cmmb_spi_xfer(cmmb_dev, buf, count, NULL, 0);
+	xfer = count - un_xfer;
+
+	return xfer;
+}
+
+static long
+mxdspidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int retval = -EIO;
+	int un_xfer;
+	struct cmmbspi_dev *cmmb_dev;
+	struct mxdchar_spi_t spi_msg;
+
+	/* Check type and command number */
+	mutex_lock(&device_list_lock);	/* TODO:check wether the lock is OK */
+
+	cmmb_dev = filp->private_data;
+
+	switch (cmd) {
+	case MXDSPI_IOC_RW:
+		retval = copy_from_user((unsigned char *)&spi_msg,
+			(unsigned char *)arg, sizeof(struct mxdchar_spi_t));
+		if (retval == 0) {
+			LOG_DEBUG("MXDSPI_IOC_RW start\n");
+			un_xfer = cmmb_spi_xfer(cmmb_dev,
+					spi_msg.txbuffer, spi_msg.txlength,
+					spi_msg.rxbuffer, spi_msg.rxlength);
+			retval = un_xfer ? (-EBUSY) : 0;
+		}
+		break;
+
+	case MXDSPI_IOC_R:
+		retval = copy_from_user((unsigned char *)&spi_msg,
+			(unsigned char *)arg, sizeof(struct mxdchar_spi_t));
+		if (retval == 0) {
+			LOG_DEBUG("MXDSPI_IOC_R start\n");
+			un_xfer = cmmb_spi_xfer(cmmb_dev, NULL, 0,
+				spi_msg.rxbuffer, spi_msg.rxlength);
+			retval = un_xfer ? (-EBUSY) : 0;
+		}
+		break;
+
+	case MXDSPI_IOC_W:
+		retval = copy_from_user((unsigned char *)&spi_msg,
+			(unsigned char *)arg, sizeof(struct mxdchar_spi_t));
+		if (retval == 0) {
+			LOG_DEBUG("MXDSPI_IOC_W start\n");
+			un_xfer = cmmb_spi_xfer(cmmb_dev,
+				spi_msg.txbuffer, spi_msg.txlength, NULL, 0);
+			retval = un_xfer ? (-EBUSY) : 0;
+		}
+		break;
+
+	default:
+		LOG_INFO("MXDSPI_IOC cmd:%x not support\n", cmd);
+		break;
+	}
+
+	mutex_unlock(&device_list_lock);	/* TODO: Check it */
+
+	return retval;
+}
+
+static int mxdspidev_open(struct inode *inode, struct file *filp)
+{
+	struct cmmbspi_dev *cmmb_dev;
+	int status = -ENXIO;
+
+	mutex_lock(&device_list_lock);
+
+	list_for_each_entry(cmmb_dev, &device_list, device_entry) {
+		if (cmmb_dev->devt == inode->i_rdev) {
+			status = 0;
+			break;
+		}
+	}
+
+	if (status == 0) {
+		if (!cmmb_dev->users) {
+			LOG_INFO("mxd chip power on\n");
+			chip_power_on(cmmb_dev);
+		}
+
+		cmmb_dev->users++;
+		filp->private_data = cmmb_dev;
+		nonseekable_open(inode, filp);
+	} else
+		LOG_ERR("mxdspidev: nothing for minor %d\n", iminor(inode));
+
+	mutex_unlock(&device_list_lock);
+
+	return status;
+}
+
+static int mxdspidev_release(struct inode *inode, struct file *filp)
+{
+	struct cmmbspi_dev *cmmb_dev;
+	int status = 0;
+
+	cmmb_dev = filp->private_data;
+	if (cmmb_dev == NULL) {
+		LOG_ERR("release err:cmmb_dev is NULL\n");
+		return status;
+	}
+
+	mutex_lock(&device_list_lock);
+	filp->private_data = NULL;
+
+	/* last close? */
+	cmmb_dev->users--;
+	if (!cmmb_dev->users) {
+		chip_power_down(cmmb_dev);
+		LOG_INFO("mxd chip power off\n");
+	}
+	mutex_unlock(&device_list_lock);
+
+	return status;
+}
+
+/* ---------------------------------------------------------------------- */
+/*
+ * Interrupt handler stuff
+ */
+
+static irqreturn_t mxdspidev_irq(int irq, void *data)
+{
+	struct cmmbspi_dev *cmmb_dev = data;
+	int frame = 0;
+
+	spin_lock(&cmmb_dev->spi_lock);
+	/*
+	 * Basic frame housekeeping.
+	 */
+	if (test_bit(frame, &cmmb_dev->irq_flag) && printk_ratelimit()) {
+		/* LOG_INFO("Frame overrun on %d, frames lost\n", frame); */
+		;
+	}
+	set_bit(frame, &cmmb_dev->irq_flag);
+
+	spin_unlock(&cmmb_dev->spi_lock);
+
+	wake_up_interruptible(&cmmb_dev->iowait);
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int mxdspidev_poll(struct file *filp,
+				   struct poll_table_struct *pt)
+{
+	int frame = 0;
+	int data_ready = 0;
+	struct cmmbspi_dev *cmmb_dev;
+
+	cmmb_dev = filp->private_data;
+
+	poll_wait(filp, &cmmb_dev->iowait, pt);
+
+	spin_lock(&cmmb_dev->spi_lock);	/* TODO: not need? */
+	data_ready = test_and_clear_bit(frame, &cmmb_dev->irq_flag);
+	spin_unlock(&cmmb_dev->spi_lock);
+
+	if (data_ready)
+		return POLLIN | POLLRDNORM;
+	else
+		return 0;
+}
+
+const struct file_operations mxdspidev_fops = {
+	.owner = THIS_MODULE,
+	/* REVISIT switch to aio primitives, so that userspace
+	 * gets more complete API coverage.  It'll simplify things
+	 * too, except for the locking.
+	 */
+	.write = mxdspidev_write,
+	.read = mxdspidev_read,
+	.poll = mxdspidev_poll,
+	.unlocked_ioctl = mxdspidev_ioctl,
+	.open = mxdspidev_open,
+	.release = mxdspidev_release,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* The main reason to have this class is to make mdev/udev create the
+ * /dev/mxdspidevB.C character device nodes exposing our userspace API.
+ * It also simplifies memory management.
+ */
+
+static struct class *mxdspidev_class;
+
+/*-------------------------------------------------------------------------*/
+
+static int mxdspidev_probe(struct spi_device *spi)
+{
+	struct cmmbspi_dev *cmmb_dev;
+	int status;
+	unsigned long minor;
+	struct cmmb_platform_data *pdata;
+	int ret;
+
+	pdata = spi->dev.platform_data;
+	if (!pdata) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	spi->bits_per_word = MXD_SPI_BITS_PER_WORD;
+	ret = spi_setup(spi);
+	if (ret < 0)
+		goto out;
+	LOG_DEBUG("Spi setup OK\n");
+
+	/* Allocate driver data */
+	cmmb_dev = kzalloc(sizeof(struct cmmbspi_dev), GFP_KERNEL);
+	if (!cmmb_dev) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* Initialize the driver data */
+	cmmb_dev->spi = spi;
+
+	spin_lock_init(&cmmb_dev->spi_lock);
+	mutex_init(&cmmb_dev->buf_lock);
+	INIT_LIST_HEAD(&cmmb_dev->device_entry);
+	init_waitqueue_head(&cmmb_dev->iowait);
+
+	/* Initialize chip control pins */
+#ifndef PIN_DEFINED_BY_DRIVE
+	if (pdata->gpio_defined) {
+		cmmb_dev->gpio_power = pdata->gpio_power;
+		cmmb_dev->gpio_reset = pdata->gpio_reset;
+		cmmb_dev->gpio_cs = pdata->gpio_cs;
+	} else
+#endif /* in case the pdata is not set outsize the dirver */
+	{
+		cmmb_dev->gpio_power = POWER_PIN_NUM;
+		cmmb_dev->gpio_reset = RESET_PIN_NUM;
+		cmmb_dev->gpio_cs = SPI_CS_PIN_NUM;
+	}
+
+	/* Alloc two dma buf for SPI tx and rx internally */
+	ret = chip_alloc_dma_bufs(cmmb_dev);
+	if (ret)
+		goto out_alloc_dma;
+
+	LOG_DEBUG("chip_alloc_dma_bufs OK\n");
+
+	/* Initialize the interrupt pin for chip */
+	cmmb_dev->irq = spi->irq;
+#if 1
+	irq_set_irq_type(cmmb_dev->irq, IRQ_TYPE_EDGE_FALLING);
+	/* IRQ_TYPE_EDGE_RISING*/
+
+	ret = request_irq(cmmb_dev->irq, mxdspidev_irq,
+			  IRQF_DISABLED, "CMMB Demodulator", cmmb_dev);
+#else
+	ret = request_irq(cmmb_dev->irq, mxdspidev_irq,
+			  IRQF_TRIGGER_RISING, "CMMB Demodulator", cmmb_dev);
+#endif
+	if (ret) {
+		LOG_ERR("CMMB request irq failed.\n");
+		goto out_request_irq;
+	}
+	LOG_DEBUG("request_irq OK\n");
+
+	/* If we can allocate a minor number, hook up this device.
+	 * Reusing minors is fine so long as udev or mdev is working.
+	 */
+	mutex_lock(&device_list_lock);
+	minor = find_first_zero_bit(minors, N_SPI_MINORS);
+	if (minor < N_SPI_MINORS) {
+		struct device *dev;
+
+		cmmb_dev->devt = MKDEV(mxdspi_major, minor);
+		dev = device_create(mxdspidev_class, &spi->dev, cmmb_dev->devt,
+				    cmmb_dev, "mxdspidev1.%ld", minor);
+		status = IS_ERR(dev) ? PTR_ERR(dev) : 0;
+	} else {
+		dev_dbg(&spi->dev, "no minor number available!\n");
+		status = -ENODEV;
+	}
+	if (status == 0) {
+		set_bit(minor, minors);
+		list_add(&cmmb_dev->device_entry, &device_list);
+	}
+	mutex_unlock(&device_list_lock);
+
+	if (status == 0)
+		spi_set_drvdata(spi, cmmb_dev);
+	else
+		goto out_creat_cdev;
+	LOG_DEBUG("device_create OK\n");
+
+	return status;
+
+out_creat_cdev:
+	free_irq(spi->irq, cmmb_dev);
+out_request_irq:
+	chip_free_dma_bufs(cmmb_dev);
+out_alloc_dma:
+	kfree(cmmb_dev);
+out:
+	LOG_ERR("mxdspidev probe fail\n");
+	return ret;
+}
+
+static int mxdspidev_remove(struct spi_device *spi)
+{
+	struct cmmbspi_dev *cmmb_dev = spi_get_drvdata(spi);
+
+	/* make sure ops on existing fds can abort cleanly */
+	spin_lock_irq(&cmmb_dev->spi_lock);
+	cmmb_dev->spi = NULL;
+	spi_set_drvdata(spi, NULL);
+	spin_unlock_irq(&cmmb_dev->spi_lock);
+
+	/* prevent new opens */
+	mutex_lock(&device_list_lock);
+	list_del(&cmmb_dev->device_entry);
+	device_destroy(mxdspidev_class, cmmb_dev->devt);
+	clear_bit(MINOR(cmmb_dev->devt), minors);
+	free_irq(cmmb_dev->irq, cmmb_dev);
+	chip_free_dma_bufs(cmmb_dev);
+	kfree(cmmb_dev);
+	mutex_unlock(&device_list_lock);
+	LOG_DEBUG("mxdspidev_remove\n");
+	return 0;
+}
+
+static struct spi_driver mxdspidev_spi = {
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mxdspidev_probe,
+	.remove = __devexit_p(mxdspidev_remove),
+
+	/* NOTE:  suspend/resume methods are not necessary here.
+	 * We don't do anything except pass the requests to/from
+	 * the underlying controller.  The refrigerator handles
+	 * most issues; the controller driver handles the rest.
+	 */
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init mxdspidev_init(void)
+{
+	int status;
+
+	/* Claim our 256 reserved device numbers.  Then register a class
+	 * that will key udev/mdev to add/remove /dev nodes.  Last, register
+	 * the driver which manages those device numbers.
+	 */
+	BUILD_BUG_ON(N_SPI_MINORS > 256);
+	LOG_DEBUG("mxdspidev_init\n");
+
+	status = register_chrdev(mxdspi_major, "spi", &mxdspidev_fops);
+	if (status < 0)
+		return status;
+	else if (mxdspi_major == 0)
+		mxdspi_major = status;
+	LOG_DEBUG("mxdspi major is %d\n", mxdspi_major);
+
+	mxdspidev_class = class_create(THIS_MODULE, "mxdspidev");
+	if (IS_ERR(mxdspidev_class)) {
+		unregister_chrdev(mxdspi_major, mxdspidev_spi.driver.name);
+		return PTR_ERR(mxdspidev_class);
+	}
+
+	status = spi_register_driver(&mxdspidev_spi);
+	if (status < 0) {
+		class_destroy(mxdspidev_class);
+		unregister_chrdev(mxdspi_major, mxdspidev_spi.driver.name);
+	}
+	return status;
+}
+module_init(mxdspidev_init);
+
+static void __exit mxdspidev_exit(void)
+{
+	spi_unregister_driver(&mxdspidev_spi);
+	class_destroy(mxdspidev_class);
+	unregister_chrdev(mxdspi_major, mxdspidev_spi.driver.name);
+}
+module_exit(mxdspidev_exit);
+
+MODULE_AUTHOR("Jialing Fu");
+MODULE_DESCRIPTION("SPI IF for Maxsecend CMMB module");
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/mem.c b/drivers/char/mem.c
index d6e9d081..67e19b63 100644
--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@ -57,6 +57,7 @@ static inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size)
 }
 #endif
 
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM)
 #ifdef CONFIG_STRICT_DEVMEM
 static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 {
@@ -82,7 +83,9 @@ static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 	return 1;
 }
 #endif
+#endif
 
+#ifdef CONFIG_DEVMEM
 void __weak unxlate_dev_mem_ptr(unsigned long phys, void *addr)
 {
 }
@@ -209,6 +212,9 @@ static ssize_t write_mem(struct file *file, const char __user *buf,
 	*ppos += written;
 	return written;
 }
+#endif	/* CONFIG_DEVMEM */
+
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM)
 
 int __weak phys_mem_access_prot_allowed(struct file *file,
 	unsigned long pfn, unsigned long size, pgprot_t *vma_prot)
@@ -330,6 +336,7 @@ static int mmap_mem(struct file *file, struct vm_area_struct *vma)
 	}
 	return 0;
 }
+#endif	/* CONFIG_DEVMEM */
 
 #ifdef CONFIG_DEVKMEM
 static int mmap_kmem(struct file *file, struct vm_area_struct *vma)
@@ -694,6 +701,8 @@ static loff_t null_lseek(struct file *file, loff_t offset, int orig)
 	return file->f_pos = 0;
 }
 
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM) || defined(CONFIG_DEVPORT)
+
 /*
  * The memory devices use the full 32/64 bits of the offset, and so we cannot
  * check against negative addresses: they are ok. The return value is weird,
@@ -727,10 +736,14 @@ static loff_t memory_lseek(struct file *file, loff_t offset, int orig)
 	return ret;
 }
 
+#endif
+
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM) || defined(CONFIG_DEVPORT)
 static int open_port(struct inode * inode, struct file * filp)
 {
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
 }
+#endif
 
 #define zero_lseek	null_lseek
 #define full_lseek      null_lseek
@@ -740,6 +753,7 @@ static int open_port(struct inode * inode, struct file * filp)
 #define open_kmem	open_mem
 #define open_oldmem	open_mem
 
+#ifdef CONFIG_DEVMEM
 static const struct file_operations mem_fops = {
 	.llseek		= memory_lseek,
 	.read		= read_mem,
@@ -748,6 +762,7 @@ static const struct file_operations mem_fops = {
 	.open		= open_mem,
 	.get_unmapped_area = get_unmapped_area_mem,
 };
+#endif
 
 #ifdef CONFIG_DEVKMEM
 static const struct file_operations kmem_fops = {
@@ -851,7 +866,9 @@ static const struct memdev {
 	const struct file_operations *fops;
 	struct backing_dev_info *dev_info;
 } devlist[] = {
+#ifdef CONFIG_DEVMEM
 	 [1] = { "mem", 0, &mem_fops, &directly_mappable_cdev_bdi },
+#endif
 #ifdef CONFIG_DEVKMEM
 	 [2] = { "kmem", 0, &kmem_fops, &directly_mappable_cdev_bdi },
 #endif
diff --git a/drivers/char/pxa9xx_acipc.c b/drivers/char/pxa9xx_acipc.c
new file mode 100644
index 00000000..c50d19fa
--- /dev/null
+++ b/drivers/char/pxa9xx_acipc.c
@@ -0,0 +1,1099 @@
+/*
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+
+ * (C) Copyright 2012 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+#include <linux/aio.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/moduleparam.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <asm/system.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <plat/pxa9xx_acipc.h>
+#if defined(CONFIG_PXA95x_DVFM)
+#include <mach/dvfm.h>
+#endif
+#ifdef CONFIG_PXA_MIPSRAM
+#include <mach/pxa_mips_ram.h>
+#else
+#define MIPS_RAM_ADD_PM_TRACE(a) {}
+#endif
+#include <asm/mach-types.h>
+
+#if defined(CONFIG_PXA95x) || defined(CONFIG_PXA93x)
+#include <mach/regs-ost.h>
+#include <mach/hardware.h>
+#endif
+
+struct pxa9xx_acipc {
+	struct resource *mem;
+	void __iomem *mmio_base;
+	int irq[ACIPC_NUMBER_OF_INTERRUPTS];
+	char irq_name[ACIPC_NUMBER_OF_INTERRUPTS][20];
+	u32 IIR_val;
+	struct acipc_database acipc_db;
+	u32 bind_event_arg;
+	wait_queue_head_t acipc_wait_q;
+	int poll_status;
+	spinlock_t poll_lock;
+	u32 historical_events;
+	struct DDR_status g_ddr_status;
+};
+
+static struct pxa9xx_acipc *acipc;
+
+#if defined(CONFIG_PXA95x) || defined(CONFIG_PXA93x)
+#define ACIPC_DDR_NOT_AVAIL		0
+#define ACIPC_DDR_AVAIL			1
+
+static u32 ddr_avail_flag;
+
+/* this parameter will hold information whether CP is availible */
+static int internal_acipc_pm_cp;
+
+u32 set_DDR_avail_flag(void)
+{
+	unsigned long flags;
+	/*
+	 * If there's no CP acipc request should return without
+	 * HW handling. SW returns expected value in order to avoid
+	 * warnings
+	 */
+	if (!internal_acipc_pm_cp)
+		return 1;
+
+	local_irq_save(flags);
+
+	if (ddr_avail_flag)
+		pr_warning("******EDDR ***WARNING*** shared flag=1 "\
+			   "althoght it already on\n");
+	/*
+	 * TODO - need to create a shadow for WDR
+	 * register and implement clear and set Marcos
+	 */
+	acipc_writel(IPC_WDR, ACIPC_DDR_AVAIL);
+	ddr_avail_flag = 1;
+
+	local_irq_restore(flags);
+
+	return 1;
+}
+EXPORT_SYMBOL(set_DDR_avail_flag);
+#endif
+
+/* PXA930/PXA910 ACIPC registers */
+#define IPC_WDR		0x0004
+#define IPC_ISRW	0x0008
+#define IPC_ICR		0x000C
+#define IPC_IIR		0x0010
+#define IPC_RDR		0x0014
+
+#define acipc_readl(off)	__raw_readl(acipc->mmio_base + (off))
+#define acipc_writel(off, v)	__raw_writel((v), acipc->mmio_base + (off))
+
+#if defined(CONFIG_CPU_PXA978)
+static const enum acipc_events acipc_priority_table_dkb[ACIPC_NUMBER_OF_EVENTS]
+	= {
+	ACIPC_DDR_READY_REQ,
+	ACIPC_DDR_RELQ_REQ,
+	ACIPC_RINGBUF_TX_STOP,
+	ACIPC_RINGBUF_TX_RESUME,
+	ACIPC_PORT_FLOWCONTROL,
+	ACIPC_SPARE,
+	ACIPC_SPARE,
+	ACIPC_SPARE,
+	ACIPC_SHM_PACKET_NOTIFY,
+	ACIPC_SHM_PEER_SYNC
+};
+#endif
+
+#if defined(CONFIG_CPU_PXA910)
+static const enum acipc_events
+	acipc_priority_table_dkb[ACIPC_NUMBER_OF_EVENTS] = {
+	ACIPC_RINGBUF_TX_STOP,
+	ACIPC_RINGBUF_TX_RESUME,
+	ACIPC_PORT_FLOWCONTROL,
+	ACIPC_SPARE,
+	ACIPC_SPARE,
+	ACIPC_SPARE,
+	ACIPC_SPARE,
+	ACIPC_SPARE,
+	ACIPC_SHM_PACKET_NOTIFY,
+	ACIPC_IPM
+};
+#elif defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+static const enum acipc_events
+	acipc_priority_table_dkb[ACIPC_NUMBER_OF_EVENTS] = {
+	ACIPC_RINGBUF_TX_STOP,
+	ACIPC_RINGBUF_TX_RESUME,
+	ACIPC_PORT_FLOWCONTROL,
+	ACIPC_MODEM_DDR_UPDATE_REQ,
+	ACIPC_RINGBUF_PSD_TX_STOP,
+	ACIPC_RINGBUF_PSD_TX_RESUME,
+	ACIPC_SHM_PSD_PACKET_NOTIFY,
+	ACIPC_SHM_DIAG_PACKET_NOTIFY,
+	ACIPC_SHM_PACKET_NOTIFY,
+	ACIPC_IPM
+};
+#endif
+
+/* PXA910 specific define */
+#if defined(CONFIG_CPU_PXA910) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define acipc_writel_withdummy(off, v)	acipc_writel((off), (v))
+#endif
+
+/* PXA95x/93x specific define */
+#if defined(CONFIG_PXA95x) || defined(CONFIG_PXA93x)
+static const enum acipc_events acipc_priority_table[ACIPC_NUMBER_OF_EVENTS] = {
+	ACIPC_DDR_READY_REQ,
+	ACIPC_DDR_260_READY_REQ,
+	ACIPC_DDR_RELQ_REQ,
+	ACIPC_DDR_260_RELQ_REQ,
+	ACIPC_DATA_Q_ADRS,
+	ACIPC_DATA_IND,
+	ACIPC_MSL_WAKEUP_REQ,
+	ACIPC_MSL_WAKEUP_ACK,
+	ACIPC_MSL_SLEEP_ALLOW,
+	ACIPC_SPARE_1
+};
+
+/* write ICR/ISRW (may require dummy access) */
+#define acipc_writel_withdummy(off, v)	\
+do {	\
+		acipc_writel((off), (v));\
+		if (cpu_is_pxa95x() || cpu_is_pxa935())	{\
+			/* A dummy read is required after write */\
+			volatile unsigned long *dummy =	\
+			(volatile unsigned long *)(acipc_readl(off));\
+			(void)dummy; /* prevent unused variable warning */ \
+	}	\
+} while (0)
+
+#endif
+
+/* read IIR */
+#define ACIPC_IIR_READ(IIR_val)			\
+{								\
+	/* dummy write to latch the IIR value */	\
+	acipc_writel(IPC_IIR, 0x0);		\
+	barrier();				\
+	(IIR_val) = acipc_readl(IPC_IIR);	\
+}
+
+static u32 acipc_default_callback(u32 status)
+{
+	IPC_ENTER();
+	/*
+	 * getting here means that the client didn't yet bind his callback.
+	 * we will save the event until the bind occur
+	 */
+	acipc->acipc_db.historical_event_status |= status;
+
+	IPC_LEAVE();
+	return 0;
+}
+
+static enum acipc_return_code acipc_event_set(enum acipc_events user_event)
+{
+	IPC_ENTER();
+	acipc_writel_withdummy(IPC_ISRW, user_event);
+	IPCTRACE("acipc_event_set userEvent 0x%x\n", user_event);
+
+	IPC_LEAVE();
+	return ACIPC_RC_OK;
+}
+
+static void acipc_int_enable(enum acipc_events event)
+{
+	IPCTRACE("acipc_int_enable event 0x%x\n", event);
+
+	if (event & ACIPC_INT0_EVENTS) {
+		/*
+		 * for the first 8 bits we enable the INTC_AC_IPC_0
+		 * only if this the first event that has been binded
+		 */
+		if (!(acipc->acipc_db.int0_events_cnt))
+			enable_irq(acipc->irq[0]);
+
+		acipc->acipc_db.int0_events_cnt |= event;
+		return;
+	}
+	if (event & ACIPC_INT1_EVENTS) {
+		enable_irq(acipc->irq[1]);
+		return;
+	}
+	if (event & ACIPC_INT2_EVENTS) {
+		enable_irq(acipc->irq[2]);
+		return;
+	}
+}
+
+static void acipc_int_disable(enum acipc_events event)
+{
+	IPC_ENTER();
+
+	IPCTRACE("acipc_int_disable event 0x%x\n", event);
+	if (event & ACIPC_INT0_EVENTS) {
+		if (!acipc->acipc_db.int0_events_cnt)
+			return;
+
+		acipc->acipc_db.int0_events_cnt &= ~event;
+		/*
+		 * for the first 8 bits we disable INTC_AC_IPC_0
+		 * only if this is the last unbind event
+		 */
+		if (!(acipc->acipc_db.int0_events_cnt))
+			disable_irq(acipc->irq[0]);
+		return;
+	}
+	if (event & ACIPC_INT1_EVENTS) {
+		disable_irq(acipc->irq[1]);
+		return;
+	}
+	if (event & ACIPC_INT2_EVENTS) {
+		disable_irq(acipc->irq[2]);
+		return;
+	}
+}
+
+#if defined(CONFIG_PXA95x) || defined(CONFIG_PXA93x)
+static void acipc_change_driver_state(int is_DDR_ready)
+{
+	IPC_ENTER();
+
+	IPCTRACE("acipc_change_driver_state isDDRReady %d\n", is_DDR_ready);
+	if (is_DDR_ready)
+		acipc->acipc_db.driver_mode = ACIPC_CB_NORMAL;
+	else
+		acipc->acipc_db.driver_mode = ACIPC_CB_ALWAYS_NO_DDR;
+
+	IPC_LEAVE();
+}
+#endif
+
+static enum acipc_return_code acipc_data_send(enum acipc_events user_event,
+					      acipc_data data)
+{
+	IPC_ENTER();
+	IPCTRACE("acipc_data_send userEvent 0x%x, data 0x%x\n",
+		 user_event, data);
+	/* writing the data to WDR */
+	acipc_writel(IPC_WDR, data);
+
+	/*
+	 * fire the event to the other subsystem
+	 * to indicate the data is ready for read
+	 */
+	acipc_writel_withdummy(IPC_ISRW, user_event);
+
+	IPC_LEAVE();
+	return ACIPC_RC_OK;
+}
+
+static enum acipc_return_code acipc_data_read(acipc_data *data)
+{
+	IPC_ENTER();
+	/* reading the data from RDR */
+	*data = acipc_readl(IPC_RDR);
+
+	IPC_LEAVE();
+
+	return ACIPC_RC_OK;
+}
+
+static enum acipc_return_code acipc_event_status_get(u32 user_event,
+						     u32 *status)
+{
+	u32 IIR_local_val;
+
+	IPC_ENTER();
+	/* reading the status from IIR */
+	ACIPC_IIR_READ(IIR_local_val);
+
+	/* clear the events hw status */
+	acipc_writel_withdummy(IPC_ICR, user_event);
+
+	/*
+	 * verify that this event will be cleared from the global IIR
+	 * variable. for cases this API is called from user callback
+	 */
+	acipc->IIR_val &= ~(user_event);
+
+	*status = IIR_local_val & user_event;
+
+	IPC_LEAVE();
+	return ACIPC_RC_OK;
+}
+
+static enum acipc_return_code acipc_event_bind(u32 user_event,
+					       acipc_rec_event_callback cb,
+					       enum acipc_callback_mode cb_mode,
+					       u32 *historical_event_status)
+{
+	u32 i;
+
+	IPC_ENTER();
+
+	for (i = 0; i < ACIPC_NUMBER_OF_EVENTS; i++) {
+		if (acipc->acipc_db.event_db[i].IIR_bit & user_event) {
+			if (acipc->acipc_db.event_db[i].cb !=
+			    acipc_default_callback)
+				return ACIPC_EVENT_ALREADY_BIND;
+			else {
+				acipc->acipc_db.event_db[i].cb = cb;
+				acipc->acipc_db.event_db[i].mode = cb_mode;
+				acipc->acipc_db.event_db[i].mask = user_event &
+				    acipc->acipc_db.event_db[i].IIR_bit;
+				acipc_int_enable(acipc->acipc_db.event_db[i].
+						 IIR_bit);
+			}
+		}
+	}
+	/* if there were historical events */
+	if (acipc->acipc_db.historical_event_status & user_event) {
+		if (historical_event_status)
+			*historical_event_status = user_event &
+			    acipc->acipc_db.historical_event_status;
+		/* clear the historical events from the database */
+		acipc->acipc_db.historical_event_status &= ~user_event;
+		return ACIPC_HISTORICAL_EVENT_OCCUR;
+	}
+
+	IPC_LEAVE();
+	return ACIPC_RC_OK;
+}
+
+static enum acipc_return_code acipc_event_unbind(u32 user_event)
+{
+	u32 i;
+
+	IPC_ENTER();
+
+	for (i = 0; i < ACIPC_NUMBER_OF_EVENTS; i++) {
+		if (acipc->acipc_db.event_db[i].mask & user_event) {
+			if (acipc->acipc_db.event_db[i].IIR_bit & user_event) {
+				acipc_int_disable(acipc->acipc_db.event_db[i].
+						  IIR_bit);
+				acipc->acipc_db.event_db[i].cb =
+				    acipc_default_callback;
+				acipc->acipc_db.event_db[i].mode =
+				    ACIPC_CB_NORMAL;
+				acipc->acipc_db.event_db[i].mask = 0;
+			}
+			/* clean this event from other event's mask */
+			acipc->acipc_db.event_db[i].mask &= ~user_event;
+		}
+	}
+
+	IPC_LEAVE();
+	return ACIPC_RC_OK;
+}
+
+static irqreturn_t acipc_interrupt_handler(int irq, void *dev_id)
+{
+	u32 i, on_events;
+
+	IPC_ENTER();
+	ACIPC_IIR_READ(acipc->IIR_val);	/* read the IIR */
+	/* using ACIPCEventStatusGet might cause getting here with IIR=0 */
+	if (acipc->IIR_val) {
+		for (i = 0; i < ACIPC_NUMBER_OF_EVENTS; i++) {
+			if ((acipc->acipc_db.event_db[i].IIR_bit &
+			     acipc->IIR_val)
+			    && (acipc->acipc_db.event_db[i].mode ==
+				ACIPC_CB_NORMAL)) {
+				on_events =
+				    (acipc->IIR_val) & (acipc->acipc_db.
+							event_db[i].mask);
+
+				/* clean the event(s) */
+				acipc_writel_withdummy(IPC_ICR, on_events);
+
+				/*
+				 * call the user callback with the status
+				 * of other events as define when the user
+				 * called ACIPCEventBind
+				 */
+				acipc->acipc_db.event_db[i].cb(on_events);
+
+				/*
+				 * if more then one event exist we clear
+				 * the rest of the bits from the global
+				 * IIR_val so user callback will be called
+				 * only once.
+				 */
+				acipc->IIR_val &= (~on_events);
+			}
+		}
+	}
+
+	IPC_LEAVE();
+
+	return IRQ_HANDLED;
+}
+
+static u32 user_callback(u32 events_status)
+{
+	acipc->bind_event_arg = events_status;
+	acipc->poll_status = 1;
+	wake_up_interruptible(&acipc->acipc_wait_q);
+
+	return 0;
+}
+
+#if defined(CONFIG_PXA95x_DVFM)
+struct acipc_lock {
+	spinlock_t lock;
+	int dev_idx;
+	int ddr208_cnt;
+	int ddr260_cnt;
+	int init;
+	unsigned long flags;
+};
+
+static struct acipc_lock acipc_lock = {
+	.lock = __SPIN_LOCK_UNLOCKED(),
+	.dev_idx = -1,
+	.ddr208_cnt = 0,
+	.ddr260_cnt = 0,
+	.init = 0,
+};
+
+/*
+ * The limitation is that constraint is added in initialization.
+ * It will be removed at the first DDR request constraint.
+ * Notice: At here, ddr208_cnt won't be updated.
+ */
+static void set_constraint(void)
+{
+	spin_lock_irqsave(&acipc_lock.lock, acipc_lock.flags);
+	if (cpu_is_pxa95x())
+		dvfm_disable_op_name("156M_HF", acipc_lock.dev_idx);
+
+	dvfm_disable_op_name_no_change("D1", acipc_lock.dev_idx);
+	dvfm_disable_op_name_no_change("D2", acipc_lock.dev_idx);
+	acipc_lock.init = 0;
+	spin_unlock_irqrestore(&acipc_lock.lock, acipc_lock.flags);
+}
+
+static unsigned int oscr_ts_1, oscr_ts_2;
+struct workqueue_struct *acipc_wq;
+struct work_struct acipc_ddr_hi_freq_acquire, acipc_ddr_hi_freq_release;
+
+static void acipc_ddr_hi_freq_acquire_handler(struct work_struct *work)
+{
+	unsigned long flags;
+	if (cpu_is_pxa95x())
+		dvfm_enable_op_name("156M_HF", acipc_lock.dev_idx);
+
+	dvfm_disable_op_name("156M", acipc_lock.dev_idx);
+	/* MIPSRAM and ACIPC event should be atomic */
+	local_irq_save(flags);
+	acipc_event_set(ACIPC_DDR_260_READY_ACK);
+	MIPS_RAM_ADD_PM_TRACE(ACIPC_HF_DDR_REQ_HANDHELD_MIPS_RAM);
+	oscr_ts_2 = OSCR;
+	local_irq_restore(flags);
+	if ((oscr_ts_2 - oscr_ts_1) > MAX_ACIPC_REACT_TIME) {
+		pr_warning("%s: constraint aquiring is slow %d cycles.\n",
+			   __func__, oscr_ts_2 - oscr_ts_1);
+		BUG_ON(1);
+	}
+}
+
+static void acipc_ddr_hi_freq_release_handler(struct work_struct *work)
+{
+	dvfm_enable_op_name("156M", acipc_lock.dev_idx);
+	if (cpu_is_pxa95x())
+		/* 208MHz and 208+HF should be reconsidered by System eng */
+		dvfm_disable_op_name("156M_HF", acipc_lock.dev_idx);
+
+	MIPS_RAM_ADD_PM_TRACE(ACIPC_HF_DDR_REL_HANDHELD_MIPS_RAM);
+}
+
+static u32 acipc_kernel_callback(u32 events_status)
+{
+	unsigned int ReceivedData;
+	IPC_ENTER();
+
+	spin_lock_irqsave(&acipc_lock.lock, acipc_lock.flags);
+
+	if (events_status & ACIPC_DDR_READY_REQ) {
+		MIPS_RAM_ADD_PM_TRACE(ACIPC_DDR_REQ_RECEIVED_MIPS_RAM);
+		if (acipc_lock.ddr208_cnt++ == 0) {
+			dvfm_disable_op_name_no_change("D1",
+						       acipc_lock.dev_idx);
+			dvfm_disable_op_name_no_change("D2",
+						       acipc_lock.dev_idx);
+			MIPS_RAM_ADD_PM_TRACE(ACIPC_DVFM_CONSTRAITNS_SET);
+		}
+		if (acipc_lock.init == 0)
+			acipc_lock.init = 1;
+		acipc_event_set(ACIPC_DDR_READY_ACK);
+		if (!ddr_avail_flag)
+			set_DDR_avail_flag();
+	}
+	if (events_status & ACIPC_DDR_RELQ_REQ) {
+		/*
+		 * geeting the relative time form the comm
+		 * side via ACIPC and notyfing dvfm when the
+		 * next comm wakup will be.
+		 */
+		acipc_data_read(&ReceivedData);
+		dvfm_notify_next_comm_wakeup_time(ReceivedData);
+		MIPS_RAM_ADD_PM_TRACE(ACIPC_DDR_REL_RECEIVED_MIPS_RAM);
+		if (acipc_lock.ddr208_cnt == 0)
+			pr_warning("%s: constraint was removed.\n", __func__);
+		else if (--acipc_lock.ddr208_cnt == 0) {
+			dvfm_enable_op_name_no_change("D1", acipc_lock.dev_idx);
+			dvfm_enable_op_name_no_change("D2", acipc_lock.dev_idx);
+			MIPS_RAM_ADD_PM_TRACE(ACIPC_DVFM_CONSTRAITNS_RELEASED);
+		}
+	}
+	if (events_status & ACIPC_DDR_260_READY_REQ) {
+		MIPS_RAM_ADD_PM_TRACE(ACIPC_HF_DDR_REQ_RECEIVED_MIPS_RAM);
+		if (acipc_lock.ddr260_cnt++ == 0) {
+#if defined(CONFIG_PXA95x) || defined(CONFIG_PXA93x)
+			oscr_ts_1 = OSCR;
+#endif
+			queue_work(acipc_wq, &acipc_ddr_hi_freq_acquire);
+		} else {
+			acipc_event_set(ACIPC_DDR_260_READY_ACK);
+			MIPS_RAM_ADD_PM_TRACE
+			    (ACIPC_HF_DDR_REQ_HANDHELD_MIPS_RAM);
+		}
+	}
+	if (events_status & ACIPC_DDR_260_RELQ_REQ) {
+		MIPS_RAM_ADD_PM_TRACE(ACIPC_HF_DDR_REL_RECEIVED_MIPS_RAM);
+		acipc_event_set(ACIPC_DDR_260_RELQ_ACK);
+		if (acipc_lock.ddr260_cnt == 0)
+			pr_warning("%s: constraint was removed.\n", __func__);
+		else if (--acipc_lock.ddr260_cnt == 0)
+			queue_work(acipc_wq, &acipc_ddr_hi_freq_release);
+		else
+			MIPS_RAM_ADD_PM_TRACE
+			    (ACIPC_HF_DDR_REL_HANDHELD_MIPS_RAM);
+	}
+	if (acipc_lock.ddr208_cnt || acipc_lock.ddr260_cnt)
+		acipc_change_driver_state(1);
+	else
+		acipc_change_driver_state(0);
+	spin_unlock_irqrestore(&acipc_lock.lock, acipc_lock.flags);
+
+	IPC_LEAVE();
+	return 0;
+}
+
+#else
+static void set_constraint(void)
+{
+}
+
+#if defined(CONFIG_PXA95x) || defined(CONFIG_PXA93x)
+static u32 acipc_kernel_callback(u32 events_status)
+{
+	IPC_ENTER();
+
+	if (events_status & ACIPC_DDR_READY_REQ) {
+		acipc_event_set(ACIPC_DDR_READY_ACK);
+		if (!ddr_avail_flag)
+			set_DDR_avail_flag();
+		/* Remove incorrect bit */
+		if (events_status & ACIPC_DDR_RELQ_REQ)
+			events_status &= ~ACIPC_DDR_RELQ_REQ;
+		acipc_change_driver_state(1);
+	}
+	if (events_status & ACIPC_DDR_RELQ_REQ) {
+		acipc_event_set(ACIPC_DDR_RELQ_ACK);
+		acipc_change_driver_state(0);
+	}
+	if (events_status & ACIPC_DDR_260_READY_REQ) {
+		acipc_event_set(ACIPC_DDR_260_READY_ACK);
+		acipc_change_driver_state(1);
+	}
+
+	if (events_status & ACIPC_DDR_260_RELQ_REQ) {
+		acipc_event_set(ACIPC_DDR_260_RELQ_ACK);
+		acipc_change_driver_state(0);
+	}
+	IPC_LEAVE();
+	return 0;
+}
+#endif /* CONFIG_CPU_PXA910 */
+#endif /* CONFIG_PXA95X_DVFM */
+
+#if defined(CONFIG_CPU_PXA910) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+static void register_pm_events(void)
+{
+	return;
+}
+
+#else
+static void register_pm_events(void)
+{
+	acipc_event_bind(ACIPC_DDR_RELQ_REQ | ACIPC_DDR_260_RELQ_REQ |
+			 ACIPC_DDR_260_READY_REQ | ACIPC_DDR_READY_REQ,
+			 acipc_kernel_callback, ACIPC_CB_NORMAL,
+			 &acipc->historical_events);
+}
+#endif /* CONFIG_CPU_PXA910 */
+
+static long acipc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct acipc_ioctl_arg acipc_arg;
+	u32 status;
+	int ret = 0;
+
+	IPC_ENTER();
+
+	if (copy_from_user(&acipc_arg,
+			   (void __user *)arg, sizeof(struct acipc_ioctl_arg)))
+		return -EFAULT;
+
+	switch (cmd) {
+	case ACIPC_SET_EVENT:
+		acipc_event_set(acipc_arg.set_event);
+		break;
+	case ACIPC_GET_EVENT:
+		acipc_event_status_get(acipc_arg.arg, &status);
+		acipc_arg.arg = status;
+		break;
+	case ACIPC_SEND_DATA:
+		acipc_data_send(acipc_arg.set_event, acipc_arg.arg);
+		break;
+	case ACIPC_READ_DATA:
+		acipc_data_read(&acipc_arg.arg);
+		break;
+	case ACIPC_BIND_EVENT:
+		acipc_event_bind(acipc_arg.arg, user_callback,
+				 acipc_arg.cb_mode, &status);
+		acipc_arg.arg = status;
+		break;
+	case ACIPC_UNBIND_EVENT:
+		acipc_event_unbind(acipc_arg.arg);
+		break;
+	case ACIPC_GET_BIND_EVENT_ARG:
+		acipc_arg.arg = acipc->bind_event_arg;
+		break;
+	default:
+		ret = -1;
+		break;
+	}
+
+	if (copy_to_user((void __user *)arg, &acipc_arg,
+			 sizeof(struct acipc_ioctl_arg)))
+		return -EFAULT;
+
+	IPC_LEAVE();
+
+	return ret;
+}
+
+static unsigned int acipc_poll(struct file *file, poll_table *wait)
+{
+	IPC_ENTER();
+
+	poll_wait(file, &acipc->acipc_wait_q, wait);
+
+	IPC_LEAVE();
+
+	if (acipc->poll_status == 0) {
+		return 0;
+	} else {
+		acipc->poll_status = 0;
+		return POLLIN | POLLRDNORM;
+	}
+}
+
+static const struct file_operations acipc_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = acipc_ioctl,
+	.poll = acipc_poll,
+};
+
+static struct miscdevice acipc_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "acipc",
+	.fops = &acipc_fops,
+};
+
+static int __devinit pxa9xx_acipc_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int ret = -EINVAL, irq;
+	char *irq_name;
+	int i;
+
+	ret = misc_register(&acipc_miscdev);
+	if (ret < 0)
+		return ret;
+
+	acipc =
+	    devm_kzalloc(&pdev->dev, sizeof(struct pxa9xx_acipc), GFP_KERNEL);
+	if (!acipc) {
+		ret = -ENOMEM;
+		goto failed_deregmisc;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		ret = -ENOMEM;
+		goto failed_deregmisc;
+	}
+
+	acipc->mmio_base = devm_request_and_ioremap(&pdev->dev, res);
+	if (acipc->mmio_base == NULL) {
+		ret = -ENODEV;
+		goto failed_deregmisc;
+	}
+#if defined(CONFIG_CPU_PXA910) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	set_constraint();
+#endif
+	/* init driver database */
+	for (i = 0; i < ACIPC_NUMBER_OF_EVENTS; i++) {
+#if defined(CONFIG_CPU_PXA910) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+		acipc->acipc_db.event_db[i].IIR_bit =
+		    acipc_priority_table_dkb[i];
+		acipc->acipc_db.event_db[i].mask = acipc_priority_table_dkb[i];
+#endif
+
+#if defined(CONFIG_PXA95x) || defined(CONFIG_PXA93x)
+			acipc->acipc_db.event_db[i].IIR_bit =
+			    acipc_priority_table[i];
+			acipc->acipc_db.event_db[i].mask =
+			    acipc_priority_table[i];
+#endif
+		acipc->acipc_db.event_db[i].cb = acipc_default_callback;
+		acipc->acipc_db.event_db[i].mode = ACIPC_CB_NORMAL;
+	}
+	acipc->acipc_db.driver_mode = ACIPC_CB_NORMAL;
+	acipc->acipc_db.int0_events_cnt = 0;
+
+	init_waitqueue_head(&acipc->acipc_wait_q);
+	spin_lock_init(&acipc->poll_lock);
+
+	platform_set_drvdata(pdev, acipc);
+
+	for (i = 0; i < ACIPC_NUMBER_OF_INTERRUPTS; i++) {
+		irq = platform_get_irq(pdev, i);
+		acipc->irq[i] = -1;
+		irq_name = acipc->irq_name[i];
+		memset(irq_name, 0, 20);
+		sprintf(irq_name, "pxa9xx-ACIPC%d", i);
+		if (irq >= 0) {
+			ret = devm_request_irq(&pdev->dev, irq,
+					       acipc_interrupt_handler,
+					       IRQF_NO_SUSPEND | IRQF_DISABLED |
+					       IRQF_TRIGGER_HIGH, irq_name,
+					       acipc);
+			disable_irq(irq);
+		}
+		if (irq < 0 || ret < 0) {
+			ret = -ENXIO;
+			goto failed_deregmisc;
+		}
+		acipc->irq[i] = irq;
+	}
+	register_pm_events();
+	pr_info("pxa9xx AC-IPC initialized!\n");
+
+#if defined(CONFIG_PXA95x) || defined(CONFIG_PXA93x)
+	INIT_WORK(&acipc_ddr_hi_freq_acquire,
+		  acipc_ddr_hi_freq_acquire_handler);
+	INIT_WORK(&acipc_ddr_hi_freq_release,
+		  acipc_ddr_hi_freq_release_handler);
+	acipc_wq = alloc_workqueue("ACIPC_WQ", WQ_HIGHPRI, 0);
+#endif
+
+	return 0;
+
+failed_deregmisc:
+	misc_deregister(&acipc_miscdev);
+	return ret;
+}
+
+static int __devexit pxa9xx_acipc_remove(struct platform_device *pdev)
+{
+	misc_deregister(&acipc_miscdev);
+	return 0;
+}
+
+static struct platform_driver pxa9xx_acipc_driver = {
+	.driver = {
+		   .name = "pxa9xx-acipc",
+		   },
+	.probe = pxa9xx_acipc_probe,
+	.remove = __devexit_p(pxa9xx_acipc_remove)
+};
+
+static int __init pxa9xx_acipc_init(void)
+{
+
+#ifdef CONFIG_PXA95x_DVFM
+	dvfm_register("ACIPC", &acipc_lock.dev_idx);
+#endif
+	return platform_driver_register(&pxa9xx_acipc_driver);
+}
+
+static void __exit pxa9xx_acipc_exit(void)
+{
+	platform_driver_unregister(&pxa9xx_acipc_driver);
+#ifdef CONFIG_PXA95x_DVFM
+	dvfm_unregister("ACIPC", &acipc_lock.dev_idx);
+#endif
+}
+
+#if defined(CONFIG_PXA95x) || defined(CONFIG_PXA93x)
+int set_acipc_cp_enable(unsigned int pm_cp)
+{
+	internal_acipc_pm_cp = pm_cp;
+	return 0;
+}
+EXPORT_SYMBOL(set_acipc_cp_enable);
+
+u32 clear_DDR_avail_flag(void)
+{
+	unsigned long flags, IIR_val;
+	/*
+	 * if there's no CP acipc request should return without HW handling.
+	 * SW returns expected value in order to avoid warnings
+	 */
+	if (!internal_acipc_pm_cp)
+		return 0;
+
+	local_irq_save(flags);
+
+	/* this should never be true */
+	if (ddr_avail_flag == 0) {
+		pr_warning("****WARNING - attempting to clear ddr_avail_flag "\
+			   "although it is allreday cleared - this should not"\
+			   "occur!!!\n");
+		local_irq_restore(flags);
+		return ddr_avail_flag;	/* returning 0 */
+	}
+
+	/*
+	 * In suspend, D2/CG will be entered without constraint checking.
+	 * This is to make sure D2 can't be entered if DDR request is acquired.
+	 */
+	if (acipc_lock.ddr208_cnt > 0) {
+		pr_debug("ACIPC has required DDR. Enter CG instead.\n");
+		local_irq_restore(flags);
+		return 1;
+	}
+
+	/* critical section ... */
+	ACIPC_IIR_READ(IIR_val);
+	if (!(IIR_val & ACIPC_DDR_READY_REQ)) {
+		/*
+		 * TODO - need to create a shadow for WDR
+		 * register and implement clear and set Marcos
+		 */
+		acipc_writel(IPC_WDR, ACIPC_DDR_NOT_AVAIL);
+		ddr_avail_flag = 0;
+
+		udelay(5);	/* ACIPC propagation delay */
+		/*
+		 * verify that DDR request did not arrive
+		 * after we clear the shared flag
+		 */
+		ACIPC_IIR_READ(IIR_val);
+		if (IIR_val & ACIPC_DDR_READY_REQ) {
+			pr_warning("******EDDR DDR_req arrive while trying to "\
+				   "clear shared flag. should be rare\n");
+			acipc_writel(IPC_WDR, ACIPC_DDR_AVAIL);
+			/*
+			 * restore shared DDR since comm
+			 * DDR request was pending
+			 */
+			ddr_avail_flag = 1;
+		}
+	} else {
+		if (ddr_avail_flag == 0)
+			/*
+			 * this can happen if ddr_req was pending while
+			 * entering D0CS (not D2 because apps-comm sync) in
+			 * that case comm is waiting for ddr_ack. since the
+			 * PM state machine is not design to abort D0CS entry,
+			 * in that case i rather ddr_req to take us out of
+			 * D0CS. this behavior will not hurt the efficiency
+			 * of this feature since we are setting the flag in
+			 * D0CS exit this should happen only if ddr_request
+			 * arrive between disable interrupt in the beginning
+			 * of pxa3xx_set_op, and the call to
+			 * clear_DDR_avail_flag so it is fairy rare case.
+			 */
+			pr_info("******EDDR DDR_req=1, shared flag=0 rare,"\
+				"not risky\n");
+		else
+			/* this can happen if ddr_req was pending while
+			 * entering D0CS (not D2 because apps-comm sync) in
+			 * that case comm is *not* waiting for ddr_ack.
+			 * returning the state of the flag, which in that case
+			 * true, will prevent D0CS. this should happen only if
+			 * ddr_request arrive between disable interrupt in the
+			 * beginning of pxa3xx_set_op, and the call to
+			 * clear_DDR_avail_flag so it is fairy rare case.
+			 */
+			pr_info("******EDDR DDR_req=1, shared flag=1 rare "\
+				"and risky\n");
+	}
+
+	local_irq_restore(flags);
+
+	return ddr_avail_flag;
+
+}
+
+#if defined(CONFIG_PXA95x_DVFM)
+void acipc_set_constraint_no_op_change(void)
+{
+	dvfm_disable_op_name_no_change("D1", acipc_lock.dev_idx);
+	dvfm_disable_op_name_no_change("D2", acipc_lock.dev_idx);
+}
+
+void acipc_unset_constraint_no_op_change(void)
+{
+	dvfm_enable_op_name_no_change("D1", acipc_lock.dev_idx);
+	dvfm_enable_op_name_no_change("D2", acipc_lock.dev_idx);
+}
+#endif
+
+void acipc_start_cp_constraints(void)
+{
+	set_constraint();
+	set_DDR_avail_flag();
+}
+EXPORT_SYMBOL(acipc_start_cp_constraints);
+
+u32 get_ddr_avail_state(void)
+{
+	return ddr_avail_flag;
+}
+
+u32 get_acipc_pending_events(void)
+{
+	u32 iir_val;
+	ACIPC_IIR_READ(iir_val);
+	return iir_val;
+}
+
+int acipc_handle_DDR_req_relq(void)
+{
+	int ret = 0;
+
+	IPC_ENTER();
+
+	ACIPC_IIR_READ(acipc->IIR_val);	/* read the IIR */
+
+	/*
+	 * If both events bit set, the only case happen here is
+	 * ACIPC_DDR_RELQ_REQ and then ACIPC_DDR_READY_REQ, because
+	 * ACIPC_DDR_RELQ_REQ will be sent by Comm side only the ACK for
+	 * ACIPC_DDR_READY_REQ has been sent.
+	 */
+	if ((acipc->IIR_val & ACIPC_DDR_READY_REQ) &&
+	    (acipc->IIR_val & ACIPC_DDR_RELQ_REQ)) {
+		if (acipc_lock.ddr208_cnt == 0) {
+			pr_err("Both DDR request and relinquish pending."\
+			       "And previous event is relinquish."\
+			       "This should not happen.\n");
+			BUG_ON(1);
+		}
+	}
+
+	if (ACIPC_DDR_RELQ_REQ & acipc->IIR_val) {
+		pr_debug("ACIPC_DDR_RELQ_REQ happen.\n");
+		/* Clean the event(s) and call callback */
+		acipc_writel_withdummy(IPC_ICR, ACIPC_DDR_RELQ_REQ);
+		acipc_kernel_callback(ACIPC_DDR_RELQ_REQ);
+	}
+
+	if (ACIPC_DDR_READY_REQ & acipc->IIR_val) {
+		pr_debug("ACIPC_DDR_READY_REQ happen.\n");
+		/* Clean the event(s) and call callback */
+		acipc_writel_withdummy(IPC_ICR, ACIPC_DDR_READY_REQ);
+		acipc_kernel_callback(ACIPC_DDR_READY_REQ);
+	}
+
+	/* If other events happen than DDR req and relq, start resume. */
+	if (acipc->IIR_val & ~(ACIPC_DDR_READY_REQ | ACIPC_DDR_RELQ_REQ)) {
+		pr_info("Other ACIPC events happen: 0x%08x, ", acipc->IIR_val);
+		pr_info("Exit suspend.\n");
+		ret = 1;
+	}
+
+	IPC_LEAVE();
+
+	return ret;
+}
+EXPORT_SYMBOL(acipc_handle_DDR_req_relq);
+#endif
+
+enum acipc_return_code ACIPCEventBind(u32 user_event,
+				      acipc_rec_event_callback cb,
+				      enum acipc_callback_mode cb_mode,
+				      u32 *historical_event_status)
+{
+	return acipc_event_bind(user_event, cb, cb_mode,
+				historical_event_status);
+}
+EXPORT_SYMBOL(ACIPCEventBind);
+
+enum acipc_return_code ACIPCEventUnBind(u32 user_event)
+{
+	return acipc_event_unbind(user_event);
+}
+EXPORT_SYMBOL(ACIPCEventUnBind);
+
+enum acipc_return_code ACIPCEventSet(enum acipc_events user_event)
+{
+	return acipc_event_set(user_event);
+}
+EXPORT_SYMBOL(ACIPCEventSet);
+
+enum acipc_return_code ACIPCDataSend(enum acipc_events user_event,
+				     acipc_data data)
+{
+	return acipc_data_send(user_event, data);
+}
+EXPORT_SYMBOL(ACIPCDataSend);
+
+enum acipc_return_code ACIPCDataRead(acipc_data *data)
+{
+	return acipc_data_read(data);
+}
+EXPORT_SYMBOL(ACIPCDataRead);
+
+enum acipc_return_code ACIPCEventStatusGet(u32 userEvent, u32 *status)
+{
+	return acipc_event_status_get(userEvent, status);
+}
+EXPORT_SYMBOL(ACIPCEventStatusGet);
+
+module_init(pxa9xx_acipc_init);
+module_exit(pxa9xx_acipc_exit);
+MODULE_AUTHOR("MARVELL");
+MODULE_DESCRIPTION("AC-IPC driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 6db161f6..a9a11378 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -89,6 +89,51 @@ void clk_put(struct clk *clk)
 }
 EXPORT_SYMBOL(clk_put);
 
+static void devm_clk_release(struct device *dev, void *res)
+{
+	clk_put(*(struct clk **)res);
+}
+
+struct clk *devm_clk_get(struct device *dev, const char *id)
+{
+	struct clk **ptr, *clk;
+
+	ptr = devres_alloc(devm_clk_release, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+
+	clk = clk_get(dev, id);
+	if (!IS_ERR(clk)) {
+		*ptr = clk;
+		devres_add(dev, ptr);
+	} else {
+		devres_free(ptr);
+	}
+
+	return clk;
+}
+EXPORT_SYMBOL(devm_clk_get);
+
+static int devm_clk_match(struct device *dev, void *res, void *data)
+{
+	struct clk **c = res;
+	if (!c || !*c) {
+		WARN_ON(!c || !*c);
+		return 0;
+	}
+	return *c == data;
+}
+
+void devm_clk_put(struct device *dev, struct clk *clk)
+{
+	int ret;
+
+	ret = devres_destroy(dev, devm_clk_release, devm_clk_match, clk);
+
+	WARN_ON(ret);
+}
+EXPORT_SYMBOL(devm_clk_put);
+
 void clkdev_add(struct clk_lookup *cl)
 {
 	mutex_lock(&clocks_mutex);
diff --git a/drivers/cpufreq/Kconfig b/drivers/cpufreq/Kconfig
index e24a2a1b..57f96ebb 100644
--- a/drivers/cpufreq/Kconfig
+++ b/drivers/cpufreq/Kconfig
@@ -99,6 +99,16 @@ config CPU_FREQ_DEFAULT_GOV_CONSERVATIVE
 	  Be aware that not all cpufreq drivers support the conservative
 	  governor. If unsure have a look at the help section of the
 	  driver. Fallback governor will be the performance governor.
+
+config CPU_FREQ_DEFAULT_GOV_INTERACTIVE
+	bool "interactive"
+	select CPU_FREQ_GOV_INTERACTIVE
+	help
+	  Use the CPUFreq governor 'interactive' as default. This allows
+	  you to get a full dynamic cpu frequency capable system by simply
+	  loading your cpufreq low-level hardware driver, using the
+	  'interactive' governor for latency-sensitive workloads.
+
 endchoice
 
 config CPU_FREQ_GOV_PERFORMANCE
@@ -156,6 +166,23 @@ config CPU_FREQ_GOV_ONDEMAND
 
 	  If in doubt, say N.
 
+config CPU_FREQ_GOV_INTERACTIVE
+	tristate "'interactive' cpufreq policy governor"
+	help
+	  'interactive' - This driver adds a dynamic cpufreq policy governor
+	  designed for latency-sensitive workloads.
+
+	  This governor attempts to reduce the latency of clock
+	  increases so that the system is more responsive to
+	  interactive workloads.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cpufreq_interactive.
+
+	  For details, take a look at linux/Documentation/cpu-freq.
+
+	  If in doubt, say N.
+
 config CPU_FREQ_GOV_CONSERVATIVE
 	tristate "'conservative' cpufreq governor"
 	depends on CPU_FREQ
diff --git a/drivers/cpufreq/Kconfig.arm b/drivers/cpufreq/Kconfig.arm
index 5961e641..f0542cd8 100644
--- a/drivers/cpufreq/Kconfig.arm
+++ b/drivers/cpufreq/Kconfig.arm
@@ -76,3 +76,11 @@ config ARM_EXYNOS5250_CPUFREQ
 	help
 	  This adds the CPUFreq driver for Samsung EXYNOS5250
 	  SoC.
+
+config ARM_PXA988_CPUFREQ
+	bool "MARVELL PXA988 SoCs"
+	depends on CPU_PXA988 || CPU_PXA1088
+	help
+	  This adds the CPUFreq driver for PXA988 and PXA1088
+
+	  If in doubt, say N.
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 9531fc2e..a2e3db88 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_CPU_FREQ_GOV_POWERSAVE)	+= cpufreq_powersave.o
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
+obj-$(CONFIG_CPU_FREQ_GOV_INTERACTIVE)	+= cpufreq_interactive.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
@@ -48,6 +49,7 @@ obj-$(CONFIG_ARM_EXYNOS4210_CPUFREQ)	+= exynos4210-cpufreq.o
 obj-$(CONFIG_ARM_EXYNOS4X12_CPUFREQ)	+= exynos4x12-cpufreq.o
 obj-$(CONFIG_ARM_EXYNOS5250_CPUFREQ)	+= exynos5250-cpufreq.o
 obj-$(CONFIG_ARM_OMAP2PLUS_CPUFREQ)     += omap-cpufreq.o
+obj-$(CONFIG_ARM_PXA988_CPUFREQ)     += pxa988-cpufreq.o
 
 ##################################################################################
 # PowerPC platform drivers
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 7f2f149a..85a81cb4 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -57,8 +57,6 @@ static DEFINE_SPINLOCK(cpufreq_driver_lock);
  *   mode before doing so.
  *
  * Additional rules:
- * - All holders of the lock should check to make sure that the CPU they
- *   are concerned with are online after they get the lock.
  * - Governor routines that can be called in cpufreq hotplug path should not
  *   take this sem as top level hotplug notifier handler takes this.
  * - Lock should not be held across
@@ -68,8 +66,7 @@ static DEFINE_PER_CPU(int, cpufreq_policy_cpu);
 static DEFINE_PER_CPU(struct rw_semaphore, cpu_policy_rwsem);
 
 #define lock_policy_rwsem(mode, cpu)					\
-static int lock_policy_rwsem_##mode					\
-(int cpu)								\
+static int lock_policy_rwsem_##mode(int cpu)				\
 {									\
 	int policy_cpu = per_cpu(cpufreq_policy_cpu, cpu);		\
 	BUG_ON(policy_cpu == -1);					\
@@ -83,23 +80,18 @@ static int lock_policy_rwsem_##mode					\
 }
 
 lock_policy_rwsem(read, cpu);
-
 lock_policy_rwsem(write, cpu);
 
-static void unlock_policy_rwsem_read(int cpu)
-{
-	int policy_cpu = per_cpu(cpufreq_policy_cpu, cpu);
-	BUG_ON(policy_cpu == -1);
-	up_read(&per_cpu(cpu_policy_rwsem, policy_cpu));
-}
-
-static void unlock_policy_rwsem_write(int cpu)
-{
-	int policy_cpu = per_cpu(cpufreq_policy_cpu, cpu);
-	BUG_ON(policy_cpu == -1);
-	up_write(&per_cpu(cpu_policy_rwsem, policy_cpu));
+#define unlock_policy_rwsem(mode, cpu)					\
+static void unlock_policy_rwsem_##mode(int cpu)				\
+{									\
+	int policy_cpu = per_cpu(cpufreq_policy_cpu, cpu);		\
+	BUG_ON(policy_cpu == -1);					\
+	up_##mode(&per_cpu(cpu_policy_rwsem, policy_cpu));		\
 }
 
+unlock_policy_rwsem(read, cpu);
+unlock_policy_rwsem(write, cpu);
 
 /* internal prototypes */
 static int __cpufreq_governor(struct cpufreq_policy *policy,
@@ -240,14 +232,21 @@ static inline void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci)
 void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state)
 {
 	struct cpufreq_policy *policy;
+	unsigned long flags;
 
 	BUG_ON(irqs_disabled());
 
+	if (!cpufreq_driver)
+		return;
+
 	freqs->flags = cpufreq_driver->flags;
 	pr_debug("notification %u of frequency transition to %u kHz\n",
 		state, freqs->new);
 
+	spin_lock_irqsave(&cpufreq_driver_lock, flags);
 	policy = per_cpu(cpufreq_cpu_data, freqs->cpu);
+	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+
 	switch (state) {
 
 	case CPUFREQ_PRECHANGE:
@@ -522,8 +521,6 @@ static ssize_t show_cpus(const struct cpumask *mask, char *buf)
  */
 static ssize_t show_related_cpus(struct cpufreq_policy *policy, char *buf)
 {
-	if (cpumask_empty(policy->related_cpus))
-		return show_cpus(policy->cpus, buf);
 	return show_cpus(policy->related_cpus, buf);
 }
 
@@ -607,6 +604,15 @@ static struct attribute *default_attrs[] = {
 };
 
 struct kobject *cpufreq_global_kobject;
+struct kset *cpufreq_kset;
+static int cpufreq_uevent_filter(struct kset *kset, struct kobject *kobj)
+{
+	return 1;
+}
+
+static const struct kset_uevent_ops cpufreq_uevent_ops = {
+	.filter = cpufreq_uevent_filter,
+};
 EXPORT_SYMBOL(cpufreq_global_kobject);
 
 #define to_policy(k) container_of(k, struct cpufreq_policy, kobj)
@@ -679,87 +685,6 @@ static struct kobj_type ktype_cpufreq = {
 	.release	= cpufreq_sysfs_release,
 };
 
-/*
- * Returns:
- *   Negative: Failure
- *   0:        Success
- *   Positive: When we have a managed CPU and the sysfs got symlinked
- */
-static int cpufreq_add_dev_policy(unsigned int cpu,
-				  struct cpufreq_policy *policy,
-				  struct device *dev)
-{
-	int ret = 0;
-#ifdef CONFIG_SMP
-	unsigned long flags;
-	unsigned int j;
-#ifdef CONFIG_HOTPLUG_CPU
-	struct cpufreq_governor *gov;
-
-	gov = __find_governor(per_cpu(cpufreq_cpu_governor, cpu));
-	if (gov) {
-		policy->governor = gov;
-		pr_debug("Restoring governor %s for cpu %d\n",
-		       policy->governor->name, cpu);
-	}
-#endif
-
-	for_each_cpu(j, policy->cpus) {
-		struct cpufreq_policy *managed_policy;
-
-		if (cpu == j)
-			continue;
-
-		/* Check for existing affected CPUs.
-		 * They may not be aware of it due to CPU Hotplug.
-		 * cpufreq_cpu_put is called when the device is removed
-		 * in __cpufreq_remove_dev()
-		 */
-		managed_policy = cpufreq_cpu_get(j);
-		if (unlikely(managed_policy)) {
-
-			/* Set proper policy_cpu */
-			unlock_policy_rwsem_write(cpu);
-			per_cpu(cpufreq_policy_cpu, cpu) = managed_policy->cpu;
-
-			if (lock_policy_rwsem_write(cpu) < 0) {
-				/* Should not go through policy unlock path */
-				if (cpufreq_driver->exit)
-					cpufreq_driver->exit(policy);
-				cpufreq_cpu_put(managed_policy);
-				return -EBUSY;
-			}
-
-			spin_lock_irqsave(&cpufreq_driver_lock, flags);
-			cpumask_copy(managed_policy->cpus, policy->cpus);
-			per_cpu(cpufreq_cpu_data, cpu) = managed_policy;
-			spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
-
-			pr_debug("CPU already managed, adding link\n");
-			ret = sysfs_create_link(&dev->kobj,
-						&managed_policy->kobj,
-						"cpufreq");
-			if (ret)
-				cpufreq_cpu_put(managed_policy);
-			/*
-			 * Success. We only needed to be added to the mask.
-			 * Call driver->exit() because only the cpu parent of
-			 * the kobj needed to call init().
-			 */
-			if (cpufreq_driver->exit)
-				cpufreq_driver->exit(policy);
-
-			if (!ret)
-				return 1;
-			else
-				return ret;
-		}
-	}
-#endif
-	return ret;
-}
-
-
 /* symlink affected CPUs */
 static int cpufreq_add_dev_symlink(unsigned int cpu,
 				   struct cpufreq_policy *policy)
@@ -864,6 +789,42 @@ err_out_kobj_put:
 	return ret;
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+static int cpufreq_add_policy_cpu(unsigned int cpu, unsigned int sibling,
+				  struct device *dev)
+{
+	struct cpufreq_policy *policy;
+	int ret = 0;
+	unsigned long flags;
+
+	lock_policy_rwsem_write(sibling);
+
+	policy = cpufreq_cpu_get(sibling);
+	WARN_ON(!policy);
+
+	__cpufreq_governor(policy, CPUFREQ_GOV_STOP);
+
+	spin_lock_irqsave(&cpufreq_driver_lock, flags);
+
+	cpumask_set_cpu(cpu, policy->cpus);
+	per_cpu(cpufreq_policy_cpu, cpu) = policy->cpu;
+	per_cpu(cpufreq_cpu_data, cpu) = policy;
+	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+
+	__cpufreq_governor(policy, CPUFREQ_GOV_START);
+	__cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
+
+	unlock_policy_rwsem_write(sibling);
+
+	ret = sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
+	if (ret) {
+		cpufreq_cpu_put(policy);
+		return ret;
+	}
+
+	return 0;
+}
+#endif
 
 /**
  * cpufreq_add_dev - add a CPU device
@@ -876,12 +837,12 @@ err_out_kobj_put:
  */
 static int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)
 {
-	unsigned int cpu = dev->id;
-	int ret = 0, found = 0;
+	unsigned int j, cpu = dev->id;
+	int ret = -ENOMEM, found = 0;
 	struct cpufreq_policy *policy;
 	unsigned long flags;
-	unsigned int j;
 #ifdef CONFIG_HOTPLUG_CPU
+	struct cpufreq_governor *gov;
 	int sibling;
 #endif
 
@@ -898,6 +859,19 @@ static int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)
 		cpufreq_cpu_put(policy);
 		return 0;
 	}
+
+#ifdef CONFIG_HOTPLUG_CPU
+	/* Check if this cpu was hot-unplugged earlier and has siblings */
+	spin_lock_irqsave(&cpufreq_driver_lock, flags);
+	for_each_online_cpu(sibling) {
+		struct cpufreq_policy *cp = per_cpu(cpufreq_cpu_data, sibling);
+		if (cp && cpumask_test_cpu(cpu, cp->related_cpus)) {
+			spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+			return cpufreq_add_policy_cpu(cpu, sibling, dev);
+		}
+	}
+	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+#endif
 #endif
 
 	if (!try_module_get(cpufreq_driver->owner)) {
@@ -905,7 +879,6 @@ static int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)
 		goto module_out;
 	}
 
-	ret = -ENOMEM;
 	policy = kzalloc(sizeof(struct cpufreq_policy), GFP_KERNEL);
 	if (!policy)
 		goto nomem_out;
@@ -921,8 +894,6 @@ static int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)
 
 	/* Initially set CPU itself as the policy_cpu */
 	per_cpu(cpufreq_policy_cpu, cpu) = cpu;
-	ret = (lock_policy_rwsem_write(cpu) < 0);
-	WARN_ON(ret);
 
 	init_completion(&policy->kobj_unregister);
 	INIT_WORK(&policy->update, handle_update);
@@ -947,36 +918,43 @@ static int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)
 	ret = cpufreq_driver->init(policy);
 	if (ret) {
 		pr_debug("initialization failed\n");
-		goto err_unlock_policy;
+		goto err_set_policy_cpu;
 	}
+
+	/* related cpus should atleast have policy->cpus */
+	cpumask_or(policy->related_cpus, policy->related_cpus, policy->cpus);
+
+	/*
+	 * affected cpus must always be the one, which are online. We aren't
+	 * managing offline cpus here.
+	 */
+	cpumask_and(policy->cpus, policy->cpus, cpu_online_mask);
+
 	policy->user_policy.min = policy->min;
 	policy->user_policy.max = policy->max;
 
 	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
 				     CPUFREQ_START, policy);
 
-	ret = cpufreq_add_dev_policy(cpu, policy, dev);
-	if (ret) {
-		if (ret > 0)
-			/* This is a managed cpu, symlink created,
-			   exit with 0 */
-			ret = 0;
-		goto err_unlock_policy;
+#ifdef CONFIG_HOTPLUG_CPU
+	gov = __find_governor(per_cpu(cpufreq_cpu_governor, cpu));
+	if (gov) {
+		policy->governor = gov;
+		pr_debug("Restoring governor %s for cpu %d\n",
+		       policy->governor->name, cpu);
 	}
+#endif
 
 	ret = cpufreq_add_dev_interface(cpu, policy, dev);
 	if (ret)
 		goto err_out_unregister;
 
-	unlock_policy_rwsem_write(cpu);
-
 	kobject_uevent(&policy->kobj, KOBJ_ADD);
 	module_put(cpufreq_driver->owner);
 	pr_debug("initialization complete\n");
 
 	return 0;
 
-
 err_out_unregister:
 	spin_lock_irqsave(&cpufreq_driver_lock, flags);
 	for_each_cpu(j, policy->cpus)
@@ -986,8 +964,8 @@ err_out_unregister:
 	kobject_put(&policy->kobj);
 	wait_for_completion(&policy->kobj_unregister);
 
-err_unlock_policy:
-	unlock_policy_rwsem_write(cpu);
+err_set_policy_cpu:
+	per_cpu(cpufreq_policy_cpu, cpu) = -1;
 	free_cpumask_var(policy->related_cpus);
 err_free_cpumask:
 	free_cpumask_var(policy->cpus);
@@ -999,6 +977,25 @@ module_out:
 	return ret;
 }
 
+static void update_policy_cpu(struct cpufreq_policy *policy, unsigned int cpu)
+{
+	int j;
+
+	policy->last_cpu = policy->cpu;
+	policy->cpu = cpu;
+
+	for_each_cpu(j, policy->cpus) {
+		if (!cpu_online(j))
+			continue;
+		per_cpu(cpufreq_policy_cpu, j) = cpu;
+	}
+
+#ifdef CONFIG_CPU_FREQ_TABLE
+	cpufreq_frequency_table_update_policy_cpu(policy);
+#endif
+	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
+			CPUFREQ_UPDATE_POLICY_CPU, policy);
+}
 
 /**
  * __cpufreq_remove_dev - remove a CPU device
@@ -1009,129 +1006,100 @@ module_out:
  */
 static int __cpufreq_remove_dev(struct device *dev, struct subsys_interface *sif)
 {
-	unsigned int cpu = dev->id;
+	unsigned int cpu = dev->id, ret, cpus;
 	unsigned long flags;
 	struct cpufreq_policy *data;
 	struct kobject *kobj;
 	struct completion *cmp;
-#ifdef CONFIG_SMP
 	struct device *cpu_dev;
-	unsigned int j;
-#endif
 
-	pr_debug("unregistering CPU %u\n", cpu);
+	pr_debug("%s: unregistering CPU %u\n", __func__, cpu);
 
 	spin_lock_irqsave(&cpufreq_driver_lock, flags);
+
 	data = per_cpu(cpufreq_cpu_data, cpu);
+	per_cpu(cpufreq_cpu_data, cpu) = NULL;
+
+	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 
 	if (!data) {
-		spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
-		unlock_policy_rwsem_write(cpu);
+		pr_debug("%s: No cpu_data found\n", __func__);
 		return -EINVAL;
 	}
-	per_cpu(cpufreq_cpu_data, cpu) = NULL;
-
 
-#ifdef CONFIG_SMP
-	/* if this isn't the CPU which is the parent of the kobj, we
-	 * only need to unlink, put and exit
-	 */
-	if (unlikely(cpu != data->cpu)) {
-		pr_debug("removing link\n");
-		cpumask_clear_cpu(cpu, data->cpus);
-		spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
-		kobj = &dev->kobj;
-		cpufreq_cpu_put(data);
-		unlock_policy_rwsem_write(cpu);
-		sysfs_remove_link(kobj, "cpufreq");
-		return 0;
-	}
-#endif
+	WARN_ON(lock_policy_rwsem_write(cpu));
 
-#ifdef CONFIG_SMP
+	if (cpufreq_driver->target)
+		__cpufreq_governor(data, CPUFREQ_GOV_STOP);
 
 #ifdef CONFIG_HOTPLUG_CPU
 	strncpy(per_cpu(cpufreq_cpu_governor, cpu), data->governor->name,
 			CPUFREQ_NAME_LEN);
 #endif
 
-	/* if we have other CPUs still registered, we need to unlink them,
-	 * or else wait_for_completion below will lock up. Clean the
-	 * per_cpu(cpufreq_cpu_data) while holding the lock, and remove
-	 * the sysfs links afterwards.
-	 */
-	if (unlikely(cpumask_weight(data->cpus) > 1)) {
-		for_each_cpu(j, data->cpus) {
-			if (j == cpu)
-				continue;
-			per_cpu(cpufreq_cpu_data, j) = NULL;
-		}
-	}
+	cpus = cpumask_weight(data->cpus);
+	cpumask_clear_cpu(cpu, data->cpus);
 
-	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+	if (cpu != data->cpu) {
+		sysfs_remove_link(&dev->kobj, "cpufreq");
+	} else if (cpus > 1) {
+		/* first sibling now owns the new sysfs dir */
+		cpu_dev = get_cpu_device(cpumask_first(data->cpus));
+		sysfs_remove_link(&cpu_dev->kobj, "cpufreq");
+		ret = kobject_move(&data->kobj, &cpu_dev->kobj);
+		if (ret) {
+			pr_err("%s: Failed to move kobj: %d", __func__, ret);
+
+			cpumask_set_cpu(cpu, data->cpus);
+
+			spin_lock_irqsave(&cpufreq_driver_lock, flags);
+			per_cpu(cpufreq_cpu_data, cpu) = data;
+			spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 
-	if (unlikely(cpumask_weight(data->cpus) > 1)) {
-		for_each_cpu(j, data->cpus) {
-			if (j == cpu)
-				continue;
-			pr_debug("removing link for cpu %u\n", j);
-#ifdef CONFIG_HOTPLUG_CPU
-			strncpy(per_cpu(cpufreq_cpu_governor, j),
-				data->governor->name, CPUFREQ_NAME_LEN);
-#endif
-			cpu_dev = get_cpu_device(j);
-			kobj = &cpu_dev->kobj;
 			unlock_policy_rwsem_write(cpu);
-			sysfs_remove_link(kobj, "cpufreq");
-			lock_policy_rwsem_write(cpu);
-			cpufreq_cpu_put(data);
-		}
-	}
-#else
-	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
-#endif
 
-	if (cpufreq_driver->target)
-		__cpufreq_governor(data, CPUFREQ_GOV_STOP);
+			ret = sysfs_create_link(&cpu_dev->kobj, &data->kobj,
+					"cpufreq");
+			return -EINVAL;
+		}
 
-	kobj = &data->kobj;
-	cmp = &data->kobj_unregister;
-	unlock_policy_rwsem_write(cpu);
-	kobject_put(kobj);
+		update_policy_cpu(data, cpu_dev->id);
+		pr_debug("%s: policy Kobject moved to cpu: %d from: %d\n",
+				__func__, cpu_dev->id, cpu);
+	}
 
-	/* we need to make sure that the underlying kobj is actually
-	 * not referenced anymore by anybody before we proceed with
-	 * unloading.
-	 */
-	pr_debug("waiting for dropping of refcount\n");
-	wait_for_completion(cmp);
-	pr_debug("wait complete\n");
+	pr_debug("%s: removing link, cpu: %d\n", __func__, cpu);
+	cpufreq_cpu_put(data);
 
-	lock_policy_rwsem_write(cpu);
-	if (cpufreq_driver->exit)
-		cpufreq_driver->exit(data);
-	unlock_policy_rwsem_write(cpu);
+	/* If cpu is last user of policy, free policy */
+	if (cpus == 1) {
+		lock_policy_rwsem_read(cpu);
+		kobj = &data->kobj;
+		cmp = &data->kobj_unregister;
+		unlock_policy_rwsem_read(cpu);
+		kobject_put(kobj);
+
+		/* we need to make sure that the underlying kobj is actually
+		 * not referenced anymore by anybody before we proceed with
+		 * unloading.
+		 */
+		pr_debug("waiting for dropping of refcount\n");
+		wait_for_completion(cmp);
+		pr_debug("wait complete\n");
 
-#ifdef CONFIG_HOTPLUG_CPU
-	/* when the CPU which is the parent of the kobj is hotplugged
-	 * offline, check for siblings, and create cpufreq sysfs interface
-	 * and symlinks
-	 */
-	if (unlikely(cpumask_weight(data->cpus) > 1)) {
-		/* first sibling now owns the new sysfs dir */
-		cpumask_clear_cpu(cpu, data->cpus);
-		cpufreq_add_dev(get_cpu_device(cpumask_first(data->cpus)), NULL);
+		if (cpufreq_driver->exit)
+			cpufreq_driver->exit(data);
 
-		/* finally remove our own symlink */
-		lock_policy_rwsem_write(cpu);
-		__cpufreq_remove_dev(dev, sif);
+		free_cpumask_var(data->related_cpus);
+		free_cpumask_var(data->cpus);
+		kfree(data);
+	} else if (cpufreq_driver->target) {
+		__cpufreq_governor(data, CPUFREQ_GOV_START);
+		__cpufreq_governor(data, CPUFREQ_GOV_LIMITS);
 	}
-#endif
-
-	free_cpumask_var(data->related_cpus);
-	free_cpumask_var(data->cpus);
-	kfree(data);
 
+	unlock_policy_rwsem_write(cpu);
+	per_cpu(cpufreq_policy_cpu, cpu) = -1;
 	return 0;
 }
 
@@ -1144,9 +1112,6 @@ static int cpufreq_remove_dev(struct device *dev, struct subsys_interface *sif)
 	if (cpu_is_offline(cpu))
 		return 0;
 
-	if (unlikely(lock_policy_rwsem_write(cpu)))
-		BUG();
-
 	retval = __cpufreq_remove_dev(dev, sif);
 	return retval;
 }
@@ -1550,6 +1515,13 @@ static int __cpufreq_governor(struct cpufreq_policy *policy,
 	if ((event == CPUFREQ_GOV_STOP) && !ret)
 		module_put(policy->governor->owner);
 
+	/*
+	 * send out uevent for userspace to modify the access permission
+	 * of related governor para file node
+	 */
+	if (event == CPUFREQ_GOV_START)
+		kobject_uevent(cpufreq_global_kobject, KOBJ_ADD);
+
 	return ret;
 }
 
@@ -1795,9 +1767,6 @@ static int __cpuinit cpufreq_cpu_callback(struct notifier_block *nfb,
 			break;
 		case CPU_DOWN_PREPARE:
 		case CPU_DOWN_PREPARE_FROZEN:
-			if (unlikely(lock_policy_rwsem_write(cpu)))
-				BUG();
-
 			__cpufreq_remove_dev(dev, NULL);
 			break;
 		case CPU_DOWN_FAILED:
@@ -1930,7 +1899,11 @@ static int __init cpufreq_core_init(void)
 		init_rwsem(&per_cpu(cpu_policy_rwsem, cpu));
 	}
 
+	cpufreq_kset = kset_create_and_add("cpufreq", &cpufreq_uevent_ops,
+					   NULL);
+
 	cpufreq_global_kobject = kobject_create_and_add("cpufreq", &cpu_subsys.dev_root->kobj);
+	cpufreq_global_kobject->kset = cpufreq_kset;
 	BUG_ON(!cpufreq_global_kobject);
 	register_syscore_ops(&cpufreq_syscore_ops);
 
diff --git a/drivers/cpufreq/cpufreq_conservative.c b/drivers/cpufreq/cpufreq_conservative.c
index 235a340e..d6b64545 100644
--- a/drivers/cpufreq/cpufreq_conservative.c
+++ b/drivers/cpufreq/cpufreq_conservative.c
@@ -424,7 +424,18 @@ static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
 	if (max_load < (dbs_tuners_ins.down_threshold - 10)) {
 		freq_target = (dbs_tuners_ins.freq_step * policy->max) / 100;
 
-		this_dbs_info->requested_freq -= freq_target;
+		/*
+		  * Only use freq_step to adjust requested_freq when it is
+		  * larger than freq_target, or requested_freq will be a
+		  * large unsigned int.
+		  * If freq_target is larger than requested_freq, we decrease
+		  * the cpu frequency to the min freq, or it can not be
+		  * decreased any more.
+		  */
+		if (this_dbs_info->requested_freq >= freq_target)
+			this_dbs_info->requested_freq -= freq_target;
+		else
+			this_dbs_info->requested_freq = policy->min;
 		if (this_dbs_info->requested_freq < policy->min)
 			this_dbs_info->requested_freq = policy->min;
 
diff --git a/drivers/cpufreq/cpufreq_interactive.c b/drivers/cpufreq/cpufreq_interactive.c
new file mode 100644
index 00000000..7d1952c5
--- /dev/null
+++ b/drivers/cpufreq/cpufreq_interactive.c
@@ -0,0 +1,1066 @@
+/*
+ * drivers/cpufreq/cpufreq_interactive.c
+ *
+ * Copyright (C) 2010 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Author: Mike Chan (mike@android.com)
+ *
+ */
+
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/cpufreq.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/rwsem.h>
+#include <linux/sched.h>
+#include <linux/tick.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+#include <asm/cputime.h>
+
+#define CREATE_TRACE_POINTS
+#include <trace/events/cpufreq_interactive.h>
+
+static int active_count;
+
+struct cpufreq_interactive_cpuinfo {
+	struct timer_list cpu_timer;
+	struct timer_list cpu_slack_timer;
+	spinlock_t load_lock; /* protects the next 4 fields */
+	u64 time_in_idle;
+	u64 time_in_idle_timestamp;
+	u64 cputime_speedadj;
+	u64 cputime_speedadj_timestamp;
+	struct cpufreq_policy *policy;
+	struct cpufreq_frequency_table *freq_table;
+	unsigned int target_freq;
+	unsigned int floor_freq;
+	u64 floor_validate_time;
+	u64 hispeed_validate_time;
+	struct rw_semaphore enable_sem;
+	int governor_enabled;
+};
+
+static DEFINE_PER_CPU(struct cpufreq_interactive_cpuinfo, cpuinfo);
+
+/* realtime thread handles frequency scaling */
+static struct task_struct *speedchange_task;
+static cpumask_t speedchange_cpumask;
+static spinlock_t speedchange_cpumask_lock;
+static struct mutex gov_lock;
+
+/* Hi speed to bump to from lo speed when load burst (default max) */
+static unsigned int hispeed_freq;
+
+/* Go to hi speed when CPU load at or above this value. */
+#define DEFAULT_GO_HISPEED_LOAD 99
+static unsigned long go_hispeed_load = DEFAULT_GO_HISPEED_LOAD;
+
+/* Target load.  Lower values result in higher CPU speeds. */
+#define DEFAULT_TARGET_LOAD 90
+static unsigned int default_target_loads[] = {DEFAULT_TARGET_LOAD};
+static spinlock_t target_loads_lock;
+static unsigned int *target_loads = default_target_loads;
+static int ntarget_loads = ARRAY_SIZE(default_target_loads);
+
+/*
+ * The minimum amount of time to spend at a frequency before we can ramp down.
+ */
+#define DEFAULT_MIN_SAMPLE_TIME (80 * USEC_PER_MSEC)
+static unsigned long min_sample_time = DEFAULT_MIN_SAMPLE_TIME;
+
+/*
+ * The sample rate of the timer used to increase frequency
+ */
+#define DEFAULT_TIMER_RATE (20 * USEC_PER_MSEC)
+static unsigned long timer_rate = DEFAULT_TIMER_RATE;
+
+/*
+ * Wait this long before raising speed above hispeed, by default a single
+ * timer interval.
+ */
+#define DEFAULT_ABOVE_HISPEED_DELAY DEFAULT_TIMER_RATE
+static unsigned long above_hispeed_delay_val = DEFAULT_ABOVE_HISPEED_DELAY;
+
+/* Non-zero means indefinite speed boost active */
+static int boost_val;
+/* Duration of a boot pulse in usecs */
+static int boostpulse_duration_val = DEFAULT_MIN_SAMPLE_TIME;
+/* End time of boost pulse in ktime converted to usecs */
+static u64 boostpulse_endtime;
+
+/*
+ * Max additional time to wait in idle, beyond timer_rate, at speeds above
+ * minimum before wakeup to reduce speed, or -1 if unnecessary.
+ */
+#define DEFAULT_TIMER_SLACK (4 * DEFAULT_TIMER_RATE)
+static int timer_slack_val = DEFAULT_TIMER_SLACK;
+
+static int cpufreq_governor_interactive(struct cpufreq_policy *policy,
+		unsigned int event);
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE
+static
+#endif
+struct cpufreq_governor cpufreq_gov_interactive = {
+	.name = "interactive",
+	.governor = cpufreq_governor_interactive,
+	.max_transition_latency = 10000000,
+	.owner = THIS_MODULE,
+};
+
+static void cpufreq_interactive_timer_resched(
+	struct cpufreq_interactive_cpuinfo *pcpu)
+{
+	unsigned long expires = jiffies + usecs_to_jiffies(timer_rate);
+	unsigned long flags;
+
+	mod_timer_pinned(&pcpu->cpu_timer, expires);
+	if (timer_slack_val >= 0 && pcpu->target_freq > pcpu->policy->min) {
+		expires += usecs_to_jiffies(timer_slack_val);
+		mod_timer_pinned(&pcpu->cpu_slack_timer, expires);
+	}
+
+	spin_lock_irqsave(&pcpu->load_lock, flags);
+	pcpu->time_in_idle =
+		get_cpu_idle_time_us(smp_processor_id(),
+				     &pcpu->time_in_idle_timestamp);
+	pcpu->cputime_speedadj = 0;
+	pcpu->cputime_speedadj_timestamp = pcpu->time_in_idle_timestamp;
+	spin_unlock_irqrestore(&pcpu->load_lock, flags);
+}
+
+static unsigned int freq_to_targetload(unsigned int freq)
+{
+	int i;
+	unsigned int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&target_loads_lock, flags);
+
+	for (i = 0; i < ntarget_loads - 1 && freq >= target_loads[i+1]; i += 2)
+		;
+
+	ret = target_loads[i];
+	spin_unlock_irqrestore(&target_loads_lock, flags);
+	return ret;
+}
+
+/*
+ * If increasing frequencies never map to a lower target load then
+ * choose_freq() will find the minimum frequency that does not exceed its
+ * target load given the current load.
+ */
+
+static unsigned int choose_freq(
+	struct cpufreq_interactive_cpuinfo *pcpu, unsigned int loadadjfreq)
+{
+	unsigned int freq = pcpu->policy->cur;
+	unsigned int prevfreq, freqmin, freqmax;
+	unsigned int tl;
+	int index;
+
+	freqmin = 0;
+	freqmax = UINT_MAX;
+
+	do {
+		prevfreq = freq;
+		tl = freq_to_targetload(freq);
+
+		/*
+		 * Find the lowest frequency where the computed load is less
+		 * than or equal to the target load.
+		 */
+
+		cpufreq_frequency_table_target(
+			pcpu->policy, pcpu->freq_table, loadadjfreq / tl,
+			CPUFREQ_RELATION_L, &index);
+		freq = pcpu->freq_table[index].frequency;
+
+		if (freq > prevfreq) {
+			/* The previous frequency is too low. */
+			freqmin = prevfreq;
+
+			if (freq >= freqmax) {
+				/*
+				 * Find the highest frequency that is less
+				 * than freqmax.
+				 */
+				cpufreq_frequency_table_target(
+					pcpu->policy, pcpu->freq_table,
+					freqmax - 1, CPUFREQ_RELATION_H,
+					&index);
+				freq = pcpu->freq_table[index].frequency;
+
+				if (freq == freqmin) {
+					/*
+					 * The first frequency below freqmax
+					 * has already been found to be too
+					 * low.  freqmax is the lowest speed
+					 * we found that is fast enough.
+					 */
+					freq = freqmax;
+					break;
+				}
+			}
+		} else if (freq < prevfreq) {
+			/* The previous frequency is high enough. */
+			freqmax = prevfreq;
+
+			if (freq <= freqmin) {
+				/*
+				 * Find the lowest frequency that is higher
+				 * than freqmin.
+				 */
+				cpufreq_frequency_table_target(
+					pcpu->policy, pcpu->freq_table,
+					freqmin + 1, CPUFREQ_RELATION_L,
+					&index);
+				freq = pcpu->freq_table[index].frequency;
+
+				/*
+				 * If freqmax is the first frequency above
+				 * freqmin then we have already found that
+				 * this speed is fast enough.
+				 */
+				if (freq == freqmax)
+					break;
+			}
+		}
+
+		/* If same frequency chosen as previous then done. */
+	} while (freq != prevfreq);
+
+	return freq;
+}
+
+static u64 update_load(int cpu)
+{
+	struct cpufreq_interactive_cpuinfo *pcpu = &per_cpu(cpuinfo, cpu);
+	u64 now;
+	u64 now_idle;
+	unsigned int delta_idle;
+	unsigned int delta_time;
+	u64 active_time;
+
+	now_idle = get_cpu_idle_time_us(cpu, &now);
+	delta_idle = (unsigned int)(now_idle - pcpu->time_in_idle);
+	delta_time = (unsigned int)(now - pcpu->time_in_idle_timestamp);
+	active_time = delta_time - delta_idle;
+	pcpu->cputime_speedadj += active_time * pcpu->policy->cur;
+
+	pcpu->time_in_idle = now_idle;
+	pcpu->time_in_idle_timestamp = now;
+	return now;
+}
+
+static void cpufreq_interactive_timer(unsigned long data)
+{
+	u64 now;
+	unsigned int delta_time;
+	u64 cputime_speedadj;
+	int cpu_load;
+	struct cpufreq_interactive_cpuinfo *pcpu =
+		&per_cpu(cpuinfo, data);
+	unsigned int new_freq;
+	unsigned int loadadjfreq;
+	unsigned int index;
+	unsigned long flags;
+	bool boosted;
+
+	if (!down_read_trylock(&pcpu->enable_sem))
+		return;
+	if (!pcpu->governor_enabled)
+		goto exit;
+
+	spin_lock_irqsave(&pcpu->load_lock, flags);
+	now = update_load(data);
+	delta_time = (unsigned int)(now - pcpu->cputime_speedadj_timestamp);
+	cputime_speedadj = pcpu->cputime_speedadj;
+	spin_unlock_irqrestore(&pcpu->load_lock, flags);
+
+	if (WARN_ON_ONCE(!delta_time))
+		goto rearm;
+
+	do_div(cputime_speedadj, delta_time);
+	loadadjfreq = (unsigned int)cputime_speedadj * 100;
+	cpu_load = loadadjfreq / pcpu->target_freq;
+	boosted = boost_val || now < boostpulse_endtime;
+
+	if (cpu_load >= go_hispeed_load || boosted) {
+		if (pcpu->target_freq < hispeed_freq) {
+			new_freq = hispeed_freq;
+		} else {
+			new_freq = choose_freq(pcpu, loadadjfreq);
+
+			if (new_freq < hispeed_freq)
+				new_freq = hispeed_freq;
+		}
+	} else {
+		new_freq = choose_freq(pcpu, loadadjfreq);
+	}
+
+	if (pcpu->target_freq >= hispeed_freq &&
+	    new_freq > pcpu->target_freq &&
+	    now - pcpu->hispeed_validate_time < above_hispeed_delay_val) {
+		trace_cpufreq_interactive_notyet(
+			data, cpu_load, pcpu->target_freq,
+			pcpu->policy->cur, new_freq);
+		goto rearm;
+	}
+
+	pcpu->hispeed_validate_time = now;
+
+	if (cpufreq_frequency_table_target(pcpu->policy, pcpu->freq_table,
+					   new_freq, CPUFREQ_RELATION_L,
+					   &index)) {
+		pr_warn_once("timer %d: cpufreq_frequency_table_target error\n",
+			     (int) data);
+		goto rearm;
+	}
+
+	new_freq = pcpu->freq_table[index].frequency;
+
+	/*
+	 * Do not scale below floor_freq unless we have been at or above the
+	 * floor frequency for the minimum sample time since last validated.
+	 */
+	if (new_freq < pcpu->floor_freq) {
+		if (now - pcpu->floor_validate_time < min_sample_time) {
+			trace_cpufreq_interactive_notyet(
+				data, cpu_load, pcpu->target_freq,
+				pcpu->policy->cur, new_freq);
+			goto rearm;
+		}
+	}
+
+	/*
+	 * Update the timestamp for checking whether speed has been held at
+	 * or above the selected frequency for a minimum of min_sample_time,
+	 * if not boosted to hispeed_freq.  If boosted to hispeed_freq then we
+	 * allow the speed to drop as soon as the boostpulse duration expires
+	 * (or the indefinite boost is turned off).
+	 */
+
+	if (!boosted || new_freq > hispeed_freq) {
+		pcpu->floor_freq = new_freq;
+		pcpu->floor_validate_time = now;
+	}
+
+	if (pcpu->target_freq == new_freq) {
+		trace_cpufreq_interactive_already(
+			data, cpu_load, pcpu->target_freq,
+			pcpu->policy->cur, new_freq);
+		goto rearm_if_notmax;
+	}
+
+	trace_cpufreq_interactive_target(data, cpu_load, pcpu->target_freq,
+					 pcpu->policy->cur, new_freq);
+
+	pcpu->target_freq = new_freq;
+	spin_lock_irqsave(&speedchange_cpumask_lock, flags);
+	cpumask_set_cpu(data, &speedchange_cpumask);
+	spin_unlock_irqrestore(&speedchange_cpumask_lock, flags);
+	wake_up_process(speedchange_task);
+
+rearm_if_notmax:
+	/*
+	 * Already set max speed and don't see a need to change that,
+	 * wait until next idle to re-evaluate, don't need timer.
+	 */
+	if (pcpu->target_freq == pcpu->policy->max)
+		goto exit;
+
+rearm:
+	if (!timer_pending(&pcpu->cpu_timer))
+		cpufreq_interactive_timer_resched(pcpu);
+
+exit:
+	up_read(&pcpu->enable_sem);
+	return;
+}
+
+static void cpufreq_interactive_idle_start(void)
+{
+	struct cpufreq_interactive_cpuinfo *pcpu =
+		&per_cpu(cpuinfo, smp_processor_id());
+	int pending;
+
+	if (!down_read_trylock(&pcpu->enable_sem))
+		return;
+	if (!pcpu->governor_enabled) {
+		up_read(&pcpu->enable_sem);
+		return;
+	}
+
+	pending = timer_pending(&pcpu->cpu_timer);
+
+	if (pcpu->target_freq != pcpu->policy->min) {
+		/*
+		 * Entering idle while not at lowest speed.  On some
+		 * platforms this can hold the other CPU(s) at that speed
+		 * even though the CPU is idle. Set a timer to re-evaluate
+		 * speed so this idle CPU doesn't hold the other CPUs above
+		 * min indefinitely.  This should probably be a quirk of
+		 * the CPUFreq driver.
+		 */
+		if (!pending)
+			cpufreq_interactive_timer_resched(pcpu);
+	}
+
+	up_read(&pcpu->enable_sem);
+}
+
+static void cpufreq_interactive_idle_end(void)
+{
+	struct cpufreq_interactive_cpuinfo *pcpu =
+		&per_cpu(cpuinfo, smp_processor_id());
+
+	if (!down_read_trylock(&pcpu->enable_sem))
+		return;
+	if (!pcpu->governor_enabled) {
+		up_read(&pcpu->enable_sem);
+		return;
+	}
+
+	/* Arm the timer for 1-2 ticks later if not already. */
+	if (!timer_pending(&pcpu->cpu_timer)) {
+		cpufreq_interactive_timer_resched(pcpu);
+	} else if (time_after_eq(jiffies, pcpu->cpu_timer.expires)) {
+		del_timer(&pcpu->cpu_timer);
+		del_timer(&pcpu->cpu_slack_timer);
+		cpufreq_interactive_timer(smp_processor_id());
+	}
+
+	up_read(&pcpu->enable_sem);
+}
+
+static int cpufreq_interactive_speedchange_task(void *data)
+{
+	unsigned int cpu;
+	cpumask_t tmp_mask;
+	unsigned long flags;
+	struct cpufreq_interactive_cpuinfo *pcpu;
+
+	while (1) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		spin_lock_irqsave(&speedchange_cpumask_lock, flags);
+
+		if (cpumask_empty(&speedchange_cpumask)) {
+			spin_unlock_irqrestore(&speedchange_cpumask_lock,
+					       flags);
+			schedule();
+
+			if (kthread_should_stop())
+				break;
+
+			spin_lock_irqsave(&speedchange_cpumask_lock, flags);
+		}
+
+		set_current_state(TASK_RUNNING);
+		tmp_mask = speedchange_cpumask;
+		cpumask_clear(&speedchange_cpumask);
+		spin_unlock_irqrestore(&speedchange_cpumask_lock, flags);
+
+		for_each_cpu(cpu, &tmp_mask) {
+			unsigned int j;
+			unsigned int max_freq = 0;
+
+			pcpu = &per_cpu(cpuinfo, cpu);
+			if (!down_read_trylock(&pcpu->enable_sem))
+				continue;
+			if (!pcpu->governor_enabled) {
+				up_read(&pcpu->enable_sem);
+				continue;
+			}
+
+			for_each_cpu(j, pcpu->policy->cpus) {
+				struct cpufreq_interactive_cpuinfo *pjcpu =
+					&per_cpu(cpuinfo, j);
+
+				if (pjcpu->target_freq > max_freq)
+					max_freq = pjcpu->target_freq;
+			}
+
+			if (max_freq != pcpu->policy->cur)
+				__cpufreq_driver_target(pcpu->policy,
+							max_freq,
+							CPUFREQ_RELATION_H);
+			trace_cpufreq_interactive_setspeed(cpu,
+						     pcpu->target_freq,
+						     pcpu->policy->cur);
+
+			up_read(&pcpu->enable_sem);
+		}
+	}
+
+	return 0;
+}
+
+static void cpufreq_interactive_boost(void)
+{
+	int i;
+	int anyboost = 0;
+	unsigned long flags;
+	struct cpufreq_interactive_cpuinfo *pcpu;
+
+	spin_lock_irqsave(&speedchange_cpumask_lock, flags);
+
+	for_each_online_cpu(i) {
+		pcpu = &per_cpu(cpuinfo, i);
+
+		if (pcpu->target_freq < hispeed_freq) {
+			pcpu->target_freq = hispeed_freq;
+			cpumask_set_cpu(i, &speedchange_cpumask);
+			pcpu->hispeed_validate_time =
+				ktime_to_us(ktime_get());
+			anyboost = 1;
+		}
+
+		/*
+		 * Set floor freq and (re)start timer for when last
+		 * validated.
+		 */
+
+		pcpu->floor_freq = hispeed_freq;
+		pcpu->floor_validate_time = ktime_to_us(ktime_get());
+	}
+
+	spin_unlock_irqrestore(&speedchange_cpumask_lock, flags);
+
+	if (anyboost)
+		wake_up_process(speedchange_task);
+}
+
+static int cpufreq_interactive_notifier(
+	struct notifier_block *nb, unsigned long val, void *data)
+{
+	struct cpufreq_freqs *freq = data;
+	struct cpufreq_interactive_cpuinfo *pcpu;
+	int cpu;
+	unsigned long flags;
+
+	if (val == CPUFREQ_POSTCHANGE) {
+		pcpu = &per_cpu(cpuinfo, freq->cpu);
+		if (!down_read_trylock(&pcpu->enable_sem))
+			return 0;
+		if (!pcpu->governor_enabled) {
+			up_read(&pcpu->enable_sem);
+			return 0;
+		}
+
+		for_each_cpu(cpu, pcpu->policy->cpus) {
+			struct cpufreq_interactive_cpuinfo *pjcpu =
+				&per_cpu(cpuinfo, cpu);
+			spin_lock_irqsave(&pjcpu->load_lock, flags);
+			update_load(cpu);
+			spin_unlock_irqrestore(&pjcpu->load_lock, flags);
+		}
+
+		up_read(&pcpu->enable_sem);
+	}
+	return 0;
+}
+
+static struct notifier_block cpufreq_notifier_block = {
+	.notifier_call = cpufreq_interactive_notifier,
+};
+
+static ssize_t show_target_loads(
+	struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	int i;
+	ssize_t ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&target_loads_lock, flags);
+
+	for (i = 0; i < ntarget_loads; i++)
+		ret += sprintf(buf + ret, "%u%s", target_loads[i],
+			       i & 0x1 ? ":" : " ");
+
+	ret += sprintf(buf + ret, "\n");
+	spin_unlock_irqrestore(&target_loads_lock, flags);
+	return ret;
+}
+
+static ssize_t store_target_loads(
+	struct kobject *kobj, struct attribute *attr, const char *buf,
+	size_t count)
+{
+	int ret;
+	const char *cp;
+	unsigned int *new_target_loads = NULL;
+	int ntokens = 1;
+	int i;
+	unsigned long flags;
+
+	cp = buf;
+	while ((cp = strpbrk(cp + 1, " :")))
+		ntokens++;
+
+	if (!(ntokens & 0x1))
+		goto err_inval;
+
+	new_target_loads = kmalloc(ntokens * sizeof(unsigned int), GFP_KERNEL);
+	if (!new_target_loads) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	cp = buf;
+	i = 0;
+	while (i < ntokens) {
+		if (sscanf(cp, "%u", &new_target_loads[i++]) != 1)
+			goto err_inval;
+
+		cp = strpbrk(cp, " :");
+		if (!cp)
+			break;
+		cp++;
+	}
+
+	if (i != ntokens)
+		goto err_inval;
+
+	spin_lock_irqsave(&target_loads_lock, flags);
+	if (target_loads != default_target_loads)
+		kfree(target_loads);
+	target_loads = new_target_loads;
+	ntarget_loads = ntokens;
+	spin_unlock_irqrestore(&target_loads_lock, flags);
+	return count;
+
+err_inval:
+	ret = -EINVAL;
+err:
+	kfree(new_target_loads);
+	return ret;
+}
+
+static struct global_attr target_loads_attr =
+	__ATTR(target_loads, S_IRUGO | S_IWUSR,
+		show_target_loads, store_target_loads);
+
+static ssize_t show_hispeed_freq(struct kobject *kobj,
+				 struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", hispeed_freq);
+}
+
+static ssize_t store_hispeed_freq(struct kobject *kobj,
+				  struct attribute *attr, const char *buf,
+				  size_t count)
+{
+	int ret;
+	long unsigned int val;
+
+	ret = strict_strtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	hispeed_freq = val;
+	return count;
+}
+
+static struct global_attr hispeed_freq_attr = __ATTR(hispeed_freq, 0644,
+		show_hispeed_freq, store_hispeed_freq);
+
+
+static ssize_t show_go_hispeed_load(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", go_hispeed_load);
+}
+
+static ssize_t store_go_hispeed_load(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = strict_strtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	go_hispeed_load = val;
+	return count;
+}
+
+static struct global_attr go_hispeed_load_attr = __ATTR(go_hispeed_load, 0644,
+		show_go_hispeed_load, store_go_hispeed_load);
+
+static ssize_t show_min_sample_time(struct kobject *kobj,
+				struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", min_sample_time);
+}
+
+static ssize_t store_min_sample_time(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = strict_strtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	min_sample_time = val;
+	return count;
+}
+
+static struct global_attr min_sample_time_attr = __ATTR(min_sample_time, 0644,
+		show_min_sample_time, store_min_sample_time);
+
+static ssize_t show_above_hispeed_delay(struct kobject *kobj,
+					struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", above_hispeed_delay_val);
+}
+
+static ssize_t store_above_hispeed_delay(struct kobject *kobj,
+					 struct attribute *attr,
+					 const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = strict_strtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	above_hispeed_delay_val = val;
+	return count;
+}
+
+define_one_global_rw(above_hispeed_delay);
+
+static ssize_t show_timer_rate(struct kobject *kobj,
+			struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", timer_rate);
+}
+
+static ssize_t store_timer_rate(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = strict_strtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	timer_rate = val;
+	return count;
+}
+
+static struct global_attr timer_rate_attr = __ATTR(timer_rate, 0644,
+		show_timer_rate, store_timer_rate);
+
+static ssize_t show_timer_slack(
+	struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", timer_slack_val);
+}
+
+static ssize_t store_timer_slack(
+	struct kobject *kobj, struct attribute *attr, const char *buf,
+	size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = kstrtol(buf, 10, &val);
+	if (ret < 0)
+		return ret;
+
+	timer_slack_val = val;
+	return count;
+}
+
+define_one_global_rw(timer_slack);
+
+static ssize_t show_boost(struct kobject *kobj, struct attribute *attr,
+			  char *buf)
+{
+	return sprintf(buf, "%d\n", boost_val);
+}
+
+static ssize_t store_boost(struct kobject *kobj, struct attribute *attr,
+			   const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+
+	boost_val = val;
+
+	if (boost_val) {
+		trace_cpufreq_interactive_boost("on");
+		cpufreq_interactive_boost();
+	} else {
+		trace_cpufreq_interactive_unboost("off");
+	}
+
+	return count;
+}
+
+define_one_global_rw(boost);
+
+static ssize_t store_boostpulse(struct kobject *kobj, struct attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+
+	boostpulse_endtime = ktime_to_us(ktime_get()) + boostpulse_duration_val;
+	trace_cpufreq_interactive_boost("pulse");
+	cpufreq_interactive_boost();
+	return count;
+}
+
+static struct global_attr boostpulse =
+	__ATTR(boostpulse, 0200, NULL, store_boostpulse);
+
+static ssize_t show_boostpulse_duration(
+	struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", boostpulse_duration_val);
+}
+
+static ssize_t store_boostpulse_duration(
+	struct kobject *kobj, struct attribute *attr, const char *buf,
+	size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+
+	boostpulse_duration_val = val;
+	return count;
+}
+
+define_one_global_rw(boostpulse_duration);
+
+static struct attribute *interactive_attributes[] = {
+	&target_loads_attr.attr,
+	&hispeed_freq_attr.attr,
+	&go_hispeed_load_attr.attr,
+	&above_hispeed_delay.attr,
+	&min_sample_time_attr.attr,
+	&timer_rate_attr.attr,
+	&timer_slack.attr,
+	&boost.attr,
+	&boostpulse.attr,
+	&boostpulse_duration.attr,
+	NULL,
+};
+
+static struct attribute_group interactive_attr_group = {
+	.attrs = interactive_attributes,
+	.name = "interactive",
+};
+
+static int cpufreq_interactive_idle_notifier(struct notifier_block *nb,
+					     unsigned long val,
+					     void *data)
+{
+	switch (val) {
+	case IDLE_START:
+		cpufreq_interactive_idle_start();
+		break;
+	case IDLE_END:
+		cpufreq_interactive_idle_end();
+		break;
+	}
+
+	return 0;
+}
+
+static struct notifier_block cpufreq_interactive_idle_nb = {
+	.notifier_call = cpufreq_interactive_idle_notifier,
+};
+
+static int cpufreq_governor_interactive(struct cpufreq_policy *policy,
+		unsigned int event)
+{
+	int rc;
+	unsigned int j;
+	struct cpufreq_interactive_cpuinfo *pcpu;
+	struct cpufreq_frequency_table *freq_table;
+
+	switch (event) {
+	case CPUFREQ_GOV_START:
+		if (!cpu_online(policy->cpu))
+			return -EINVAL;
+
+		mutex_lock(&gov_lock);
+
+		freq_table =
+			cpufreq_frequency_get_table(policy->cpu);
+		if (!hispeed_freq)
+			hispeed_freq = policy->max;
+
+		for_each_cpu(j, policy->cpus) {
+			unsigned long expires;
+
+			pcpu = &per_cpu(cpuinfo, j);
+			pcpu->policy = policy;
+			pcpu->target_freq = policy->cur;
+			pcpu->freq_table = freq_table;
+			pcpu->floor_freq = pcpu->target_freq;
+			pcpu->floor_validate_time =
+				ktime_to_us(ktime_get());
+			pcpu->hispeed_validate_time =
+				pcpu->floor_validate_time;
+			down_write(&pcpu->enable_sem);
+			expires = jiffies + usecs_to_jiffies(timer_rate);
+			pcpu->cpu_timer.expires = expires;
+			add_timer_on(&pcpu->cpu_timer, j);
+			if (timer_slack_val >= 0) {
+				expires += usecs_to_jiffies(timer_slack_val);
+				pcpu->cpu_slack_timer.expires = expires;
+				add_timer_on(&pcpu->cpu_slack_timer, j);
+			}
+			pcpu->governor_enabled = 1;
+			up_write(&pcpu->enable_sem);
+		}
+
+		/*
+		 * Do not register the idle hook and create sysfs
+		 * entries if we have already done so.
+		 */
+		if (++active_count > 1) {
+			mutex_unlock(&gov_lock);
+			return 0;
+		}
+
+		rc = sysfs_create_group(cpufreq_global_kobject,
+				&interactive_attr_group);
+		if (rc) {
+			mutex_unlock(&gov_lock);
+			return rc;
+		}
+
+		idle_notifier_register(&cpufreq_interactive_idle_nb);
+		cpufreq_register_notifier(
+			&cpufreq_notifier_block, CPUFREQ_TRANSITION_NOTIFIER);
+		mutex_unlock(&gov_lock);
+		break;
+
+	case CPUFREQ_GOV_STOP:
+		mutex_lock(&gov_lock);
+		for_each_cpu(j, policy->cpus) {
+			pcpu = &per_cpu(cpuinfo, j);
+			down_write(&pcpu->enable_sem);
+			pcpu->governor_enabled = 0;
+			del_timer_sync(&pcpu->cpu_timer);
+			del_timer_sync(&pcpu->cpu_slack_timer);
+			up_write(&pcpu->enable_sem);
+		}
+
+		if (--active_count > 0) {
+			mutex_unlock(&gov_lock);
+			return 0;
+		}
+
+		cpufreq_unregister_notifier(
+			&cpufreq_notifier_block, CPUFREQ_TRANSITION_NOTIFIER);
+		idle_notifier_unregister(&cpufreq_interactive_idle_nb);
+		sysfs_remove_group(cpufreq_global_kobject,
+				&interactive_attr_group);
+		mutex_unlock(&gov_lock);
+
+		break;
+
+	case CPUFREQ_GOV_LIMITS:
+		if (policy->max < policy->cur)
+			__cpufreq_driver_target(policy,
+					policy->max, CPUFREQ_RELATION_H);
+		else if (policy->min > policy->cur)
+			__cpufreq_driver_target(policy,
+					policy->min, CPUFREQ_RELATION_L);
+		break;
+	}
+	return 0;
+}
+
+static void cpufreq_interactive_nop_timer(unsigned long data)
+{
+}
+
+static int __init cpufreq_interactive_init(void)
+{
+	unsigned int i;
+	struct cpufreq_interactive_cpuinfo *pcpu;
+	struct sched_param param = { .sched_priority = MAX_RT_PRIO-1 };
+
+	/* Initalize per-cpu timers */
+	for_each_possible_cpu(i) {
+		pcpu = &per_cpu(cpuinfo, i);
+		init_timer_deferrable(&pcpu->cpu_timer);
+		pcpu->cpu_timer.function = cpufreq_interactive_timer;
+		pcpu->cpu_timer.data = i;
+		init_timer(&pcpu->cpu_slack_timer);
+		pcpu->cpu_slack_timer.function = cpufreq_interactive_nop_timer;
+		spin_lock_init(&pcpu->load_lock);
+		init_rwsem(&pcpu->enable_sem);
+	}
+
+	spin_lock_init(&target_loads_lock);
+	spin_lock_init(&speedchange_cpumask_lock);
+	mutex_init(&gov_lock);
+	speedchange_task =
+		kthread_create(cpufreq_interactive_speedchange_task, NULL,
+			       "cfinteractive");
+	if (IS_ERR(speedchange_task))
+		return PTR_ERR(speedchange_task);
+
+	sched_setscheduler_nocheck(speedchange_task, SCHED_FIFO, &param);
+	get_task_struct(speedchange_task);
+
+	/* NB: wake up so the thread does not look hung to the freezer */
+	wake_up_process(speedchange_task);
+
+	return cpufreq_register_governor(&cpufreq_gov_interactive);
+}
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE
+fs_initcall(cpufreq_interactive_init);
+#else
+module_init(cpufreq_interactive_init);
+#endif
+
+static void __exit cpufreq_interactive_exit(void)
+{
+	cpufreq_unregister_governor(&cpufreq_gov_interactive);
+	kthread_stop(speedchange_task);
+	put_task_struct(speedchange_task);
+}
+
+module_exit(cpufreq_interactive_exit);
+
+MODULE_AUTHOR("Mike Chan <mike@android.com>");
+MODULE_DESCRIPTION("'cpufreq_interactive' - A cpufreq governor for "
+	"Latency sensitive workloads");
+MODULE_LICENSE("GPL");
diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index b40ee140..5d0c0344 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -170,11 +170,13 @@ static int freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
 static void cpufreq_stats_free_table(unsigned int cpu)
 {
 	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, cpu);
+
 	if (stat) {
+		pr_debug("%s: Free stat table\n", __func__);
 		kfree(stat->time_in_state);
 		kfree(stat);
+		per_cpu(cpufreq_stats_table, cpu) = NULL;
 	}
-	per_cpu(cpufreq_stats_table, cpu) = NULL;
 }
 
 /* must be called early in the CPU removal sequence (before
@@ -183,8 +185,10 @@ static void cpufreq_stats_free_table(unsigned int cpu)
 static void cpufreq_stats_free_sysfs(unsigned int cpu)
 {
 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
-	if (policy && policy->cpu == cpu)
+	if (policy && (cpumask_weight(policy->cpus) == 1)) {
+		pr_debug("%s: Free sysfs stat\n", __func__);
 		sysfs_remove_group(&policy->kobj, &stats_attr_group);
+	}
 	if (policy)
 		cpufreq_cpu_put(policy);
 }
@@ -262,6 +266,19 @@ error_get_fail:
 	return ret;
 }
 
+static void cpufreq_stats_update_policy_cpu(struct cpufreq_policy *policy)
+{
+	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table,
+			policy->last_cpu);
+
+	pr_debug("Updating stats_table for new_cpu %u from last_cpu %u\n",
+			policy->cpu, policy->last_cpu);
+	per_cpu(cpufreq_stats_table, policy->cpu) = per_cpu(cpufreq_stats_table,
+			policy->last_cpu);
+	per_cpu(cpufreq_stats_table, policy->last_cpu) = NULL;
+	stat->cpu = policy->cpu;
+}
+
 static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
 		unsigned long val, void *data)
 {
@@ -269,6 +286,12 @@ static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
 	struct cpufreq_policy *policy = data;
 	struct cpufreq_frequency_table *table;
 	unsigned int cpu = policy->cpu;
+
+	if (val == CPUFREQ_UPDATE_POLICY_CPU) {
+		cpufreq_stats_update_policy_cpu(policy);
+		return 0;
+	}
+
 	if (val != CPUFREQ_NOTIFY)
 		return 0;
 	table = cpufreq_frequency_get_table(cpu);
@@ -316,6 +339,27 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 	return 0;
 }
 
+static int cpufreq_stats_create_table_cpu(unsigned int cpu)
+{
+	struct cpufreq_policy *policy;
+	struct cpufreq_frequency_table *table;
+	int ret = -ENODEV;
+
+	policy = cpufreq_cpu_get(cpu);
+	if (!policy)
+		return -ENODEV;
+
+	table = cpufreq_frequency_get_table(cpu);
+	if (!table)
+		goto out;
+
+	ret = cpufreq_stats_create_table(policy, table);
+
+out:
+	cpufreq_cpu_put(policy);
+	return ret;
+}
+
 static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 					       unsigned long action,
 					       void *hcpu)
@@ -334,6 +378,10 @@ static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 	case CPU_DEAD_FROZEN:
 		cpufreq_stats_free_table(cpu);
 		break;
+	case CPU_DOWN_FAILED:
+	case CPU_DOWN_FAILED_FROZEN:
+		cpufreq_stats_create_table_cpu(cpu);
+		break;
 	}
 	return NOTIFY_OK;
 }
diff --git a/drivers/cpufreq/freq_table.c b/drivers/cpufreq/freq_table.c
index 90431cb9..281e3b4d 100644
--- a/drivers/cpufreq/freq_table.c
+++ b/drivers/cpufreq/freq_table.c
@@ -225,6 +225,15 @@ void cpufreq_frequency_table_put_attr(unsigned int cpu)
 }
 EXPORT_SYMBOL_GPL(cpufreq_frequency_table_put_attr);
 
+void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy)
+{
+	pr_debug("Updating show_table for new_cpu %u from last_cpu %u\n",
+			policy->cpu, policy->last_cpu);
+	per_cpu(cpufreq_show_table, policy->cpu) = per_cpu(cpufreq_show_table,
+			policy->last_cpu);
+	per_cpu(cpufreq_show_table, policy->last_cpu) = NULL;
+}
+
 struct cpufreq_frequency_table *cpufreq_frequency_get_table(unsigned int cpu)
 {
 	return per_cpu(cpufreq_show_table, cpu);
diff --git a/drivers/cpufreq/pxa988-cpufreq.c b/drivers/cpufreq/pxa988-cpufreq.c
new file mode 100644
index 00000000..7c75b0cd
--- /dev/null
+++ b/drivers/cpufreq/pxa988-cpufreq.c
@@ -0,0 +1,360 @@
+/*
+ * arch/arm/mach-mmp/cpufreq-pxa988.c
+ *
+ * Copyright (C) 2012 Marvell, Inc.
+ *
+ * Author:
+ *	Zhoujie Wu <zjwu@marvell.com>
+ *	Based on arch/arm/mach-tegra/cpu-tegra.c
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/cpumask.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/suspend.h>
+#include <asm/system.h>
+#include <asm/cpu.h>
+#include <linux/pm_qos.h>
+#include <linux/reboot.h>
+
+#define NUM_CPUS	num_possible_cpus()
+
+#define KHZ_TO_HZ	(1000)
+#define MHZ_TO_KHZ	(1000)
+#define MHZ_TO_HZ	(1000000)
+
+static struct clk *cpu_clk;
+static DEFINE_MUTEX(pxa988_cpu_lock);
+static bool is_suspended;
+static struct cpufreq_frequency_table *freq_table;
+static bool is_qosreq_inited;
+
+
+/* Qos min request client cpufreq driver policy->cpuinfo.min */
+static struct pm_qos_request cpufreq_qos_req_min = {
+	.name = "cpu_freqmin",
+};
+/* Qos max request client  cpufreq driver policy->cpuinfo.min */
+static struct pm_qos_request cpufreq_qos_req_max = {
+	.name = "cpu_freqmax",
+};
+
+#ifdef CONFIG_SMP
+struct lpj_info {
+	unsigned long	ref;
+	unsigned int	freq;
+};
+static DEFINE_PER_CPU(struct lpj_info, lpj_ref);
+#endif
+
+int pxa988_verify_speed(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy, freq_table);
+}
+
+unsigned int pxa988_getspeed(unsigned int cpu)
+{
+	unsigned long rate;
+
+	if (cpu >= NUM_CPUS)
+		return 0;
+
+	rate = clk_get_rate(cpu_clk) / KHZ_TO_HZ;
+	return rate;
+}
+
+static int pxa988_update_cpu_speed(unsigned long rate)
+{
+	struct cpufreq_freqs freqs;
+	unsigned int i;
+	int ret = 0;
+
+	freqs.old = pxa988_getspeed(0);
+	freqs.new = rate;
+
+	if (freqs.old == freqs.new)
+		return 0;
+
+	/*
+	* cpufreq notifier is moved to cpu's ops->setrate
+	 * So that when other components call cpu's ops->setrate
+	 * the notifier can be called correctly.
+	 */
+#ifdef CONFIG_CPU_FREQ_DEBUG
+	printk(KERN_DEBUG "cpufreq-pxa988: transition: %u --> %u\n",
+	       freqs.old, freqs.new);
+#endif
+
+	ret = clk_set_rate(cpu_clk, freqs.new * KHZ_TO_HZ);
+	if (ret) {
+		freqs.new = freqs.old;
+		goto out;
+	}
+
+#ifdef CONFIG_SMP
+	/*
+	 * Note that loops_per_jiffy is not updated on SMP systems in
+	 * cpufreq driver. So, update the per-CPU loops_per_jiffy value
+	 * on frequency transition. We need to update all dependent CPUs.
+	 * But we don't adjust the global one as it will always
+	 * kept as the value according to the highest core freq,
+	 * and used for udelay.
+	 */
+	for_each_online_cpu(i) {
+		struct lpj_info *lpj = &per_cpu(lpj_ref, i);
+		if (!lpj->freq) {
+			lpj->ref = per_cpu(cpu_data, i).loops_per_jiffy;
+			lpj->freq = freqs.old;
+		}
+
+		per_cpu(cpu_data, i).loops_per_jiffy =
+			cpufreq_scale(lpj->ref, lpj->freq, freqs.new);
+	}
+#endif
+out:
+	return ret;
+}
+
+static int pxa988_target(struct cpufreq_policy *policy,
+		       unsigned int target_freq,
+		       unsigned int relation)
+{
+	int idx;
+	unsigned int freq;
+	int ret = 0;
+
+	mutex_lock(&pxa988_cpu_lock);
+
+	if (is_suspended) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	target_freq = max((unsigned int)pm_qos_request(PM_QOS_CPUFREQ_MIN),
+		target_freq);
+	target_freq = min((unsigned int)pm_qos_request(PM_QOS_CPUFREQ_MAX),
+		target_freq);
+	cpufreq_frequency_table_target(policy, freq_table, target_freq,
+		relation, &idx);
+	freq = freq_table[idx].frequency;
+	pr_debug("Qos_min:%d Qos_max:%d, Target:%d(KHZ)\n",
+		pm_qos_request(PM_QOS_CPUFREQ_MIN),
+		pm_qos_request(PM_QOS_CPUFREQ_MAX),
+		freq);
+
+	ret = pxa988_update_cpu_speed(freq);
+out:
+	mutex_unlock(&pxa988_cpu_lock);
+	return ret;
+}
+
+
+static int pxa988_pm_notify(struct notifier_block *nb, unsigned long event,
+	void *dummy)
+{
+	static unsigned int saved_cpuclk = 0;
+	mutex_lock(&pxa988_cpu_lock);
+	if (event == PM_SUSPEND_PREPARE) {
+		/* scaling to the min frequency before entering suspend */
+		saved_cpuclk = pxa988_getspeed(0);
+		pxa988_update_cpu_speed(freq_table[0].frequency);
+		is_suspended = true;
+		pr_info("%s: disable cpu freq-chg before suspend, cur"\
+				" rate %dKhz\n",
+				__func__, pxa988_getspeed(0));
+	} else if (event == PM_POST_SUSPEND) {
+		is_suspended = false;
+		pxa988_update_cpu_speed(saved_cpuclk);
+		pr_info("%s: enable cpu freq-chg after resume, cur"\
+				" rate %dKhz\n",
+				__func__, pxa988_getspeed(0));
+	}
+	mutex_unlock(&pxa988_cpu_lock);
+	return NOTIFY_OK;
+}
+
+static struct notifier_block pxa988_cpu_pm_notifier = {
+	.notifier_call = pxa988_pm_notify,
+};
+
+static int cpufreq_reboot_notify(struct notifier_block *nb,
+	unsigned long event, void *dummy)
+{
+	mutex_lock(&pxa988_cpu_lock);
+	/* scaling to the min frequency before reboot/powerdown */
+	pxa988_update_cpu_speed(freq_table[0].frequency);
+	is_suspended = true;
+	pr_info("%s: disable cpu freq-chg before reboot, cur"\
+		" rate %dKhz\n", __func__, pxa988_getspeed(0));
+	mutex_unlock(&pxa988_cpu_lock);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block pxa988_cpu_reboot_notifier = {
+	.notifier_call = cpufreq_reboot_notify,
+	.priority = 100,
+};
+
+/* cpufreq qos min/max notifier unit Khz */
+static int cpufreq_min_notify(struct notifier_block *b,
+			      unsigned long min, void *v)
+{
+	int ret;
+	unsigned long freq, val = min;
+	struct cpufreq_policy *policy;
+	int cpu = 0;
+
+	freq = pxa988_getspeed(cpu);
+	if (freq >= val)
+		return NOTIFY_OK;
+
+	policy = cpufreq_cpu_get(cpu);
+	if (!policy)
+		return NOTIFY_BAD;
+
+	ret = __cpufreq_driver_target(policy, val, CPUFREQ_RELATION_L);
+	cpufreq_cpu_put(policy);
+	if (ret < 0)
+		return NOTIFY_BAD;
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block cpufreq_min_notifier = {
+	.notifier_call = cpufreq_min_notify,
+};
+
+static int cpufreq_max_notify(struct notifier_block *b,
+			      unsigned long max, void *v)
+{
+	int ret;
+	unsigned long freq, val = max;
+	struct cpufreq_policy *policy;
+	int cpu = 0;
+
+	freq = pxa988_getspeed(cpu);
+	if (freq <= val)
+		return NOTIFY_OK;
+
+	policy = cpufreq_cpu_get(cpu);
+	if (!policy)
+		return NOTIFY_BAD;
+
+	ret = __cpufreq_driver_target(policy, val, CPUFREQ_RELATION_H);
+	cpufreq_cpu_put(policy);
+	if (ret < 0)
+		return NOTIFY_BAD;
+
+	return NOTIFY_OK;
+}
+
+
+static struct notifier_block cpufreq_max_notifier = {
+	.notifier_call = cpufreq_max_notify,
+};
+
+
+static int pxa988_cpufreq_init(struct cpufreq_policy *policy)
+{
+	if (policy->cpu >= NUM_CPUS)
+		return -EINVAL;
+
+	if (unlikely(!cpu_clk)) {
+		cpu_clk = clk_get_sys(NULL, "cpu");
+		if (IS_ERR(cpu_clk))
+			return PTR_ERR(cpu_clk);
+	}
+
+	freq_table = cpufreq_frequency_get_table(policy->cpu);
+	BUG_ON(!freq_table);
+	cpufreq_frequency_table_cpuinfo(policy, freq_table);
+	policy->cur = pxa988_getspeed(policy->cpu);
+
+	/*
+	 * FIXME: what's the actual transition time?
+	 * use 10ms as sampling rate for bring up
+	 */
+	policy->cpuinfo.transition_latency = 10 * 1000;
+	cpumask_setall(policy->cpus);
+	if (policy->cpu == 0)
+	{
+		register_reboot_notifier(&pxa988_cpu_reboot_notifier);
+	}
+	if (unlikely(!is_qosreq_inited)) {
+		pm_qos_add_request(&cpufreq_qos_req_min,
+			PM_QOS_CPUFREQ_MIN, policy->cpuinfo.min_freq);
+		pm_qos_add_request(&cpufreq_qos_req_max,
+			PM_QOS_CPUFREQ_MAX, policy->cpuinfo.max_freq);
+		is_qosreq_inited = true;
+	}
+
+	return 0;
+}
+
+static int pxa988_cpufreq_exit(struct cpufreq_policy *policy)
+{
+	unregister_pm_notifier(&pxa988_cpu_pm_notifier);
+	unregister_reboot_notifier(&pxa988_cpu_reboot_notifier);
+	cpufreq_frequency_table_cpuinfo(policy, freq_table);
+
+	return 0;
+}
+
+static struct freq_attr *pxa988_cpufreq_attr[] = {
+	&cpufreq_freq_attr_scaling_available_freqs,
+	NULL,
+};
+
+static struct cpufreq_driver pxa988_cpufreq_driver = {
+	.verify		= pxa988_verify_speed,
+	.target		= pxa988_target,
+	.get		= pxa988_getspeed,
+	.init		= pxa988_cpufreq_init,
+	.exit		= pxa988_cpufreq_exit,
+	.name		= "pxa988-cpufreq",
+	.attr		= pxa988_cpufreq_attr,
+};
+
+static int __init cpufreq_init(void)
+{
+	register_pm_notifier(&pxa988_cpu_pm_notifier);
+	pm_qos_add_notifier(PM_QOS_CPUFREQ_MIN,
+		&cpufreq_min_notifier);
+	pm_qos_add_notifier(PM_QOS_CPUFREQ_MAX,
+		&cpufreq_max_notifier);
+	return cpufreq_register_driver(&pxa988_cpufreq_driver);
+}
+
+static void __exit cpufreq_exit(void)
+{
+	unregister_pm_notifier(&pxa988_cpu_pm_notifier);
+	pm_qos_remove_notifier(PM_QOS_CPUFREQ_MIN,
+		&cpufreq_min_notifier);
+	pm_qos_remove_notifier(PM_QOS_CPUFREQ_MAX,
+		&cpufreq_max_notifier);
+	cpufreq_unregister_driver(&pxa988_cpufreq_driver);
+}
+
+
+MODULE_DESCRIPTION("cpufreq driver for Marvell PXA988");
+MODULE_LICENSE("GPL");
+module_init(cpufreq_init);
+module_exit(cpufreq_exit);
diff --git a/drivers/cpuidle/Kconfig b/drivers/cpuidle/Kconfig
index 78a666d1..a76b689e 100644
--- a/drivers/cpuidle/Kconfig
+++ b/drivers/cpuidle/Kconfig
@@ -18,3 +18,6 @@ config CPU_IDLE_GOV_MENU
 	bool
 	depends on CPU_IDLE && NO_HZ
 	default y
+
+config ARCH_NEEDS_CPU_IDLE_COUPLED
+	def_bool n
diff --git a/drivers/cpuidle/Makefile b/drivers/cpuidle/Makefile
index 5634f883..38c8f69f 100644
--- a/drivers/cpuidle/Makefile
+++ b/drivers/cpuidle/Makefile
@@ -3,3 +3,4 @@
 #
 
 obj-y += cpuidle.o driver.o governor.o sysfs.o governors/
+obj-$(CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED) += coupled.o
diff --git a/drivers/cpuidle/coupled.c b/drivers/cpuidle/coupled.c
new file mode 100644
index 00000000..5ca2a2ce
--- /dev/null
+++ b/drivers/cpuidle/coupled.c
@@ -0,0 +1,727 @@
+/*
+ * coupled.c - helper functions to enter the same idle state on multiple cpus
+ *
+ * Copyright (c) 2011 Google, Inc.
+ *
+ * Author: Colin Cross <ccross@android.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/cpu.h>
+#include <linux/cpuidle.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include "cpuidle.h"
+
+/**
+ * DOC: Coupled cpuidle states
+ *
+ * On some ARM SMP SoCs (OMAP4460, Tegra 2, and probably more), the
+ * cpus cannot be independently powered down, either due to
+ * sequencing restrictions (on Tegra 2, cpu 0 must be the last to
+ * power down), or due to HW bugs (on OMAP4460, a cpu powering up
+ * will corrupt the gic state unless the other cpu runs a work
+ * around).  Each cpu has a power state that it can enter without
+ * coordinating with the other cpu (usually Wait For Interrupt, or
+ * WFI), and one or more "coupled" power states that affect blocks
+ * shared between the cpus (L2 cache, interrupt controller, and
+ * sometimes the whole SoC).  Entering a coupled power state must
+ * be tightly controlled on both cpus.
+ *
+ * This file implements a solution, where each cpu will wait in the
+ * WFI state until all cpus are ready to enter a coupled state, at
+ * which point the coupled state function will be called on all
+ * cpus at approximately the same time.
+ *
+ * Once all cpus are ready to enter idle, they are woken by an smp
+ * cross call.  At this point, there is a chance that one of the
+ * cpus will find work to do, and choose not to enter idle.  A
+ * final pass is needed to guarantee that all cpus will call the
+ * power state enter function at the same time.  During this pass,
+ * each cpu will increment the ready counter, and continue once the
+ * ready counter matches the number of online coupled cpus.  If any
+ * cpu exits idle, the other cpus will decrement their counter and
+ * retry.
+ *
+ * requested_state stores the deepest coupled idle state each cpu
+ * is ready for.  It is assumed that the states are indexed from
+ * shallowest (highest power, lowest exit latency) to deepest
+ * (lowest power, highest exit latency).  The requested_state
+ * variable is not locked.  It is only written from the cpu that
+ * it stores (or by the on/offlining cpu if that cpu is offline),
+ * and only read after all the cpus are ready for the coupled idle
+ * state are are no longer updating it.
+ *
+ * Three atomic counters are used.  alive_count tracks the number
+ * of cpus in the coupled set that are currently or soon will be
+ * online.  waiting_count tracks the number of cpus that are in
+ * the waiting loop, in the ready loop, or in the coupled idle state.
+ * ready_count tracks the number of cpus that are in the ready loop
+ * or in the coupled idle state.
+ *
+ * To use coupled cpuidle states, a cpuidle driver must:
+ *
+ *    Set struct cpuidle_device.coupled_cpus to the mask of all
+ *    coupled cpus, usually the same as cpu_possible_mask if all cpus
+ *    are part of the same cluster.  The coupled_cpus mask must be
+ *    set in the struct cpuidle_device for each cpu.
+ *
+ *    Set struct cpuidle_device.safe_state to a state that is not a
+ *    coupled state.  This is usually WFI.
+ *
+ *    Set CPUIDLE_FLAG_COUPLED in struct cpuidle_state.flags for each
+ *    state that affects multiple cpus.
+ *
+ *    Provide a struct cpuidle_state.enter function for each state
+ *    that affects multiple cpus.  This function is guaranteed to be
+ *    called on all cpus at approximately the same time.  The driver
+ *    should ensure that the cpus all abort together if any cpu tries
+ *    to abort once the function is called.  The function should return
+ *    with interrupts still disabled.
+ */
+
+/**
+ * struct cpuidle_coupled - data for set of cpus that share a coupled idle state
+ * @coupled_cpus: mask of cpus that are part of the coupled set
+ * @requested_state: array of requested states for cpus in the coupled set
+ * @ready_waiting_counts: combined count of cpus  in ready or waiting loops
+ * @online_count: count of cpus that are online
+ * @refcnt: reference count of cpuidle devices that are using this struct
+ * @prevent: flag to prevent coupled idle while a cpu is hotplugging
+ */
+struct cpuidle_coupled {
+	cpumask_t coupled_cpus;
+	int requested_state[NR_CPUS];
+	atomic_t ready_waiting_counts;
+	int online_count;
+	int refcnt;
+	int prevent;
+};
+
+#define WAITING_BITS 16
+#define MAX_WAITING_CPUS (1 << WAITING_BITS)
+#define WAITING_MASK (MAX_WAITING_CPUS - 1)
+#define READY_MASK (~WAITING_MASK)
+
+#define CPUIDLE_COUPLED_NOT_IDLE	(-1)
+
+static DEFINE_MUTEX(cpuidle_coupled_lock);
+static DEFINE_PER_CPU(struct call_single_data, cpuidle_coupled_poke_cb);
+
+/*
+ * The cpuidle_coupled_poked_mask mask is used to avoid calling
+ * __smp_call_function_single with the per cpu call_single_data struct already
+ * in use.  This prevents a deadlock where two cpus are waiting for each others
+ * call_single_data struct to be available
+ */
+static cpumask_t cpuidle_coupled_poked_mask;
+
+/**
+ * cpuidle_coupled_parallel_barrier - synchronize all online coupled cpus
+ * @dev: cpuidle_device of the calling cpu
+ * @a:   atomic variable to hold the barrier
+ *
+ * No caller to this function will return from this function until all online
+ * cpus in the same coupled group have called this function.  Once any caller
+ * has returned from this function, the barrier is immediately available for
+ * reuse.
+ *
+ * The atomic variable a must be initialized to 0 before any cpu calls
+ * this function, will be reset to 0 before any cpu returns from this function.
+ *
+ * Must only be called from within a coupled idle state handler
+ * (state.enter when state.flags has CPUIDLE_FLAG_COUPLED set).
+ *
+ * Provides full smp barrier semantics before and after calling.
+ */
+void cpuidle_coupled_parallel_barrier(struct cpuidle_device *dev, atomic_t *a)
+{
+	int n = dev->coupled->online_count;
+
+	smp_mb__before_atomic_inc();
+	atomic_inc(a);
+
+	while (atomic_read(a) < n)
+		cpu_relax();
+
+	if (atomic_inc_return(a) == n * 2) {
+		atomic_set(a, 0);
+		return;
+	}
+
+	while (atomic_read(a) > n)
+		cpu_relax();
+}
+
+/**
+ * cpuidle_state_is_coupled - check if a state is part of a coupled set
+ * @dev: struct cpuidle_device for the current cpu
+ * @drv: struct cpuidle_driver for the platform
+ * @state: index of the target state in drv->states
+ *
+ * Returns true if the target state is coupled with cpus besides this one
+ */
+bool cpuidle_state_is_coupled(struct cpuidle_device *dev,
+	struct cpuidle_driver *drv, int state)
+{
+	return drv->states[state].flags & CPUIDLE_FLAG_COUPLED;
+}
+
+/**
+ * cpuidle_coupled_set_ready - mark a cpu as ready
+ * @coupled: the struct coupled that contains the current cpu
+ */
+static inline void cpuidle_coupled_set_ready(struct cpuidle_coupled *coupled)
+{
+	atomic_add(MAX_WAITING_CPUS, &coupled->ready_waiting_counts);
+}
+
+/**
+ * cpuidle_coupled_set_not_ready - mark a cpu as not ready
+ * @coupled: the struct coupled that contains the current cpu
+ *
+ * Decrements the ready counter, unless the ready (and thus the waiting) counter
+ * is equal to the number of online cpus.  Prevents a race where one cpu
+ * decrements the waiting counter and then re-increments it just before another
+ * cpu has decremented its ready counter, leading to the ready counter going
+ * down from the number of online cpus without going through the coupled idle
+ * state.
+ *
+ * Returns 0 if the counter was decremented successfully, -EINVAL if the ready
+ * counter was equal to the number of online cpus.
+ */
+static
+inline int cpuidle_coupled_set_not_ready(struct cpuidle_coupled *coupled)
+{
+	int all;
+	int ret;
+
+	all = coupled->online_count | (coupled->online_count << WAITING_BITS);
+	ret = atomic_add_unless(&coupled->ready_waiting_counts,
+		-MAX_WAITING_CPUS, all);
+
+	return ret ? 0 : -EINVAL;
+}
+
+/**
+ * cpuidle_coupled_no_cpus_ready - check if no cpus in a coupled set are ready
+ * @coupled: the struct coupled that contains the current cpu
+ *
+ * Returns true if all of the cpus in a coupled set are out of the ready loop.
+ */
+static inline int cpuidle_coupled_no_cpus_ready(struct cpuidle_coupled *coupled)
+{
+	int r = atomic_read(&coupled->ready_waiting_counts) >> WAITING_BITS;
+	return r == 0;
+}
+
+/**
+ * cpuidle_coupled_cpus_ready - check if all cpus in a coupled set are ready
+ * @coupled: the struct coupled that contains the current cpu
+ *
+ * Returns true if all cpus coupled to this target state are in the ready loop
+ */
+static inline bool cpuidle_coupled_cpus_ready(struct cpuidle_coupled *coupled)
+{
+	int r = atomic_read(&coupled->ready_waiting_counts) >> WAITING_BITS;
+	return r == coupled->online_count;
+}
+
+/**
+ * cpuidle_coupled_cpus_waiting - check if all cpus in a coupled set are waiting
+ * @coupled: the struct coupled that contains the current cpu
+ *
+ * Returns true if all cpus coupled to this target state are in the wait loop
+ */
+static inline bool cpuidle_coupled_cpus_waiting(struct cpuidle_coupled *coupled)
+{
+	int w = atomic_read(&coupled->ready_waiting_counts) & WAITING_MASK;
+	return w == coupled->online_count;
+}
+
+/**
+ * cpuidle_coupled_no_cpus_waiting - check if no cpus in coupled set are waiting
+ * @coupled: the struct coupled that contains the current cpu
+ *
+ * Returns true if all of the cpus in a coupled set are out of the waiting loop.
+ */
+static inline int cpuidle_coupled_no_cpus_waiting(struct cpuidle_coupled *coupled)
+{
+	int w = atomic_read(&coupled->ready_waiting_counts) & WAITING_MASK;
+	return w == 0;
+}
+
+/**
+ * cpuidle_coupled_get_state - determine the deepest idle state
+ * @dev: struct cpuidle_device for this cpu
+ * @coupled: the struct coupled that contains the current cpu
+ *
+ * Returns the deepest idle state that all coupled cpus can enter
+ */
+static inline int cpuidle_coupled_get_state(struct cpuidle_device *dev,
+		struct cpuidle_coupled *coupled)
+{
+	int i;
+	int state = INT_MAX;
+
+	/*
+	 * Read barrier ensures that read of requested_state is ordered after
+	 * reads of ready_count.  Matches the write barriers
+	 * cpuidle_set_state_waiting.
+	 */
+	smp_rmb();
+
+	for_each_cpu_mask(i, coupled->coupled_cpus)
+		if (cpu_online(i) && coupled->requested_state[i] < state)
+			state = coupled->requested_state[i];
+
+	return state;
+}
+
+static void cpuidle_coupled_poked(void *info)
+{
+	int cpu = (unsigned long)info;
+	cpumask_clear_cpu(cpu, &cpuidle_coupled_poked_mask);
+}
+
+/**
+ * cpuidle_coupled_poke - wake up a cpu that may be waiting
+ * @cpu: target cpu
+ *
+ * Ensures that the target cpu exits it's waiting idle state (if it is in it)
+ * and will see updates to waiting_count before it re-enters it's waiting idle
+ * state.
+ *
+ * If cpuidle_coupled_poked_mask is already set for the target cpu, that cpu
+ * either has or will soon have a pending IPI that will wake it out of idle,
+ * or it is currently processing the IPI and is not in idle.
+ */
+static void cpuidle_coupled_poke(int cpu)
+{
+	struct call_single_data *csd = &per_cpu(cpuidle_coupled_poke_cb, cpu);
+
+	if (!cpumask_test_and_set_cpu(cpu, &cpuidle_coupled_poked_mask))
+		__smp_call_function_single(cpu, csd, 0);
+}
+
+/**
+ * cpuidle_coupled_poke_others - wake up all other cpus that may be waiting
+ * @dev: struct cpuidle_device for this cpu
+ * @coupled: the struct coupled that contains the current cpu
+ *
+ * Calls cpuidle_coupled_poke on all other online cpus.
+ */
+static void cpuidle_coupled_poke_others(int this_cpu,
+		struct cpuidle_coupled *coupled)
+{
+	int cpu;
+
+	for_each_cpu_mask(cpu, coupled->coupled_cpus)
+		if (cpu != this_cpu && cpu_online(cpu))
+			cpuidle_coupled_poke(cpu);
+}
+
+/**
+ * cpuidle_coupled_set_waiting - mark this cpu as in the wait loop
+ * @dev: struct cpuidle_device for this cpu
+ * @coupled: the struct coupled that contains the current cpu
+ * @next_state: the index in drv->states of the requested state for this cpu
+ *
+ * Updates the requested idle state for the specified cpuidle device,
+ * poking all coupled cpus out of idle if necessary to let them see the new
+ * state.
+ */
+static void cpuidle_coupled_set_waiting(int cpu,
+		struct cpuidle_coupled *coupled, int next_state)
+{
+	int w;
+
+	coupled->requested_state[cpu] = next_state;
+
+	/*
+	 * If this is the last cpu to enter the waiting state, poke
+	 * all the other cpus out of their waiting state so they can
+	 * enter a deeper state.  This can race with one of the cpus
+	 * exiting the waiting state due to an interrupt and
+	 * decrementing waiting_count, see comment below.
+	 *
+	 * The atomic_inc_return provides a write barrier to order the write
+	 * to requested_state with the later write that increments ready_count.
+	 */
+	w = atomic_inc_return(&coupled->ready_waiting_counts) & WAITING_MASK;
+	if (w == coupled->online_count)
+		cpuidle_coupled_poke_others(cpu, coupled);
+}
+
+/**
+ * cpuidle_coupled_set_not_waiting - mark this cpu as leaving the wait loop
+ * @dev: struct cpuidle_device for this cpu
+ * @coupled: the struct coupled that contains the current cpu
+ *
+ * Removes the requested idle state for the specified cpuidle device.
+ */
+static void cpuidle_coupled_set_not_waiting(int cpu,
+		struct cpuidle_coupled *coupled)
+{
+	/*
+	 * Decrementing waiting count can race with incrementing it in
+	 * cpuidle_coupled_set_waiting, but that's OK.  Worst case, some
+	 * cpus will increment ready_count and then spin until they
+	 * notice that this cpu has cleared it's requested_state.
+	 */
+	atomic_dec(&coupled->ready_waiting_counts);
+
+	coupled->requested_state[cpu] = CPUIDLE_COUPLED_NOT_IDLE;
+}
+
+/**
+ * cpuidle_coupled_set_done - mark this cpu as leaving the ready loop
+ * @cpu: the current cpu
+ * @coupled: the struct coupled that contains the current cpu
+ *
+ * Marks this cpu as no longer in the ready and waiting loops.  Decrements
+ * the waiting count first to prevent another cpu looping back in and seeing
+ * this cpu as waiting just before it exits idle.
+ */
+static void cpuidle_coupled_set_done(int cpu, struct cpuidle_coupled *coupled)
+{
+	cpuidle_coupled_set_not_waiting(cpu, coupled);
+	atomic_sub(MAX_WAITING_CPUS, &coupled->ready_waiting_counts);
+}
+
+/**
+ * cpuidle_coupled_clear_pokes - spin until the poke interrupt is processed
+ * @cpu - this cpu
+ *
+ * Turns on interrupts and spins until any outstanding poke interrupts have
+ * been processed and the poke bit has been cleared.
+ *
+ * Other interrupts may also be processed while interrupts are enabled, so
+ * need_resched() must be tested after turning interrupts off again to make sure
+ * the interrupt didn't schedule work that should take the cpu out of idle.
+ *
+ * Returns 0 if need_resched was false, -EINTR if need_resched was true.
+ */
+static int cpuidle_coupled_clear_pokes(int cpu)
+{
+	local_irq_enable();
+	while (cpumask_test_cpu(cpu, &cpuidle_coupled_poked_mask))
+		cpu_relax();
+	local_irq_disable();
+
+	return need_resched() ? -EINTR : 0;
+}
+
+/**
+ * cpuidle_enter_state_coupled - attempt to enter a state with coupled cpus
+ * @dev: struct cpuidle_device for the current cpu
+ * @drv: struct cpuidle_driver for the platform
+ * @next_state: index of the requested state in drv->states
+ *
+ * Coordinate with coupled cpus to enter the target state.  This is a two
+ * stage process.  In the first stage, the cpus are operating independently,
+ * and may call into cpuidle_enter_state_coupled at completely different times.
+ * To save as much power as possible, the first cpus to call this function will
+ * go to an intermediate state (the cpuidle_device's safe state), and wait for
+ * all the other cpus to call this function.  Once all coupled cpus are idle,
+ * the second stage will start.  Each coupled cpu will spin until all cpus have
+ * guaranteed that they will call the target_state.
+ *
+ * This function must be called with interrupts disabled.  It may enable
+ * interrupts while preparing for idle, and it will always return with
+ * interrupts enabled.
+ */
+int cpuidle_enter_state_coupled(struct cpuidle_device *dev,
+		struct cpuidle_driver *drv, int next_state)
+{
+	int entered_state = -1;
+	struct cpuidle_coupled *coupled = dev->coupled;
+
+	if (!coupled)
+		return -EINVAL;
+
+	while (coupled->prevent) {
+		if (cpuidle_coupled_clear_pokes(dev->cpu)) {
+			local_irq_enable();
+			return entered_state;
+		}
+		entered_state = cpuidle_enter_state(dev, drv,
+			dev->safe_state_index);
+	}
+
+	/* Read barrier ensures online_count is read after prevent is cleared */
+	smp_rmb();
+
+	cpuidle_coupled_set_waiting(dev->cpu, coupled, next_state);
+
+retry:
+	/*
+	 * Wait for all coupled cpus to be idle, using the deepest state
+	 * allowed for a single cpu.
+	 */
+	while (!cpuidle_coupled_cpus_waiting(coupled)) {
+		if (cpuidle_coupled_clear_pokes(dev->cpu)) {
+			cpuidle_coupled_set_not_waiting(dev->cpu, coupled);
+			goto out;
+		}
+
+		if (coupled->prevent) {
+			cpuidle_coupled_set_not_waiting(dev->cpu, coupled);
+			goto out;
+		}
+
+		entered_state = cpuidle_enter_state(dev, drv,
+			dev->safe_state_index);
+	}
+
+	if (cpuidle_coupled_clear_pokes(dev->cpu)) {
+		cpuidle_coupled_set_not_waiting(dev->cpu, coupled);
+		goto out;
+	}
+
+	/*
+	 * All coupled cpus are probably idle.  There is a small chance that
+	 * one of the other cpus just became active.  Increment the ready count,
+	 * and spin until all coupled cpus have incremented the counter. Once a
+	 * cpu has incremented the ready counter, it cannot abort idle and must
+	 * spin until either all cpus have incremented the ready counter, or
+	 * another cpu leaves idle and decrements the waiting counter.
+	 */
+
+	cpuidle_coupled_set_ready(coupled);
+	while (!cpuidle_coupled_cpus_ready(coupled)) {
+		/* Check if any other cpus bailed out of idle. */
+		if (!cpuidle_coupled_cpus_waiting(coupled))
+			if (!cpuidle_coupled_set_not_ready(coupled))
+				goto retry;
+
+		cpu_relax();
+	}
+
+	/* all cpus have acked the coupled state */
+	next_state = cpuidle_coupled_get_state(dev, coupled);
+
+	entered_state = cpuidle_enter_state(dev, drv, next_state);
+
+	cpuidle_coupled_set_done(dev->cpu, coupled);
+
+out:
+	/*
+	 * Normal cpuidle states are expected to return with irqs enabled.
+	 * That leads to an inefficiency where a cpu receiving an interrupt
+	 * that brings it out of idle will process that interrupt before
+	 * exiting the idle enter function and decrementing ready_count.  All
+	 * other cpus will need to spin waiting for the cpu that is processing
+	 * the interrupt.  If the driver returns with interrupts disabled,
+	 * all other cpus will loop back into the safe idle state instead of
+	 * spinning, saving power.
+	 *
+	 * Calling local_irq_enable here allows coupled states to return with
+	 * interrupts disabled, but won't cause problems for drivers that
+	 * exit with interrupts enabled.
+	 */
+	local_irq_enable();
+
+	/*
+	 * Wait until all coupled cpus have exited idle.  There is no risk that
+	 * a cpu exits and re-enters the ready state because this cpu has
+	 * already decremented its waiting_count.
+	 */
+	while (!cpuidle_coupled_no_cpus_ready(coupled))
+		cpu_relax();
+
+	return entered_state;
+}
+
+static void cpuidle_coupled_update_online_cpus(struct cpuidle_coupled *coupled)
+{
+	cpumask_t cpus;
+	cpumask_and(&cpus, cpu_online_mask, &coupled->coupled_cpus);
+	coupled->online_count = cpumask_weight(&cpus);
+}
+
+/**
+ * cpuidle_coupled_register_device - register a coupled cpuidle device
+ * @dev: struct cpuidle_device for the current cpu
+ *
+ * Called from cpuidle_register_device to handle coupled idle init.  Finds the
+ * cpuidle_coupled struct for this set of coupled cpus, or creates one if none
+ * exists yet.
+ */
+int cpuidle_coupled_register_device(struct cpuidle_device *dev)
+{
+	int cpu;
+	struct cpuidle_device *other_dev;
+	struct call_single_data *csd;
+	struct cpuidle_coupled *coupled;
+
+	if (cpumask_empty(&dev->coupled_cpus))
+		return 0;
+
+	for_each_cpu_mask(cpu, dev->coupled_cpus) {
+		other_dev = per_cpu(cpuidle_devices, cpu);
+		if (other_dev && other_dev->coupled) {
+			coupled = other_dev->coupled;
+			goto have_coupled;
+		}
+	}
+
+	/* No existing coupled info found, create a new one */
+	coupled = kzalloc(sizeof(struct cpuidle_coupled), GFP_KERNEL);
+	if (!coupled)
+		return -ENOMEM;
+
+	coupled->coupled_cpus = dev->coupled_cpus;
+
+have_coupled:
+	dev->coupled = coupled;
+	if (WARN_ON(!cpumask_equal(&dev->coupled_cpus, &coupled->coupled_cpus)))
+		coupled->prevent++;
+
+	cpuidle_coupled_update_online_cpus(coupled);
+
+	coupled->refcnt++;
+
+	csd = &per_cpu(cpuidle_coupled_poke_cb, dev->cpu);
+	csd->func = cpuidle_coupled_poked;
+	csd->info = (void *)(unsigned long)dev->cpu;
+
+	return 0;
+}
+
+/**
+ * cpuidle_coupled_unregister_device - unregister a coupled cpuidle device
+ * @dev: struct cpuidle_device for the current cpu
+ *
+ * Called from cpuidle_unregister_device to tear down coupled idle.  Removes the
+ * cpu from the coupled idle set, and frees the cpuidle_coupled_info struct if
+ * this was the last cpu in the set.
+ */
+void cpuidle_coupled_unregister_device(struct cpuidle_device *dev)
+{
+	struct cpuidle_coupled *coupled = dev->coupled;
+
+	if (cpumask_empty(&dev->coupled_cpus))
+		return;
+
+	if (--coupled->refcnt)
+		kfree(coupled);
+	dev->coupled = NULL;
+}
+
+/**
+ * cpuidle_coupled_prevent_idle - prevent cpus from entering a coupled state
+ * @coupled: the struct coupled that contains the cpu that is changing state
+ *
+ * Disables coupled cpuidle on a coupled set of cpus.  Used to ensure that
+ * cpu_online_mask doesn't change while cpus are coordinating coupled idle.
+ */
+static void cpuidle_coupled_prevent_idle(struct cpuidle_coupled *coupled)
+{
+	int cpu = get_cpu();
+
+	/* Force all cpus out of the waiting loop. */
+	coupled->prevent++;
+	cpuidle_coupled_poke_others(cpu, coupled);
+	put_cpu();
+	while (!cpuidle_coupled_no_cpus_waiting(coupled))
+		cpu_relax();
+}
+
+/**
+ * cpuidle_coupled_allow_idle - allows cpus to enter a coupled state
+ * @coupled: the struct coupled that contains the cpu that is changing state
+ *
+ * Enables coupled cpuidle on a coupled set of cpus.  Used to ensure that
+ * cpu_online_mask doesn't change while cpus are coordinating coupled idle.
+ */
+static void cpuidle_coupled_allow_idle(struct cpuidle_coupled *coupled)
+{
+	int cpu = get_cpu();
+
+	/*
+	 * Write barrier ensures readers see the new online_count when they
+	 * see prevent == false.
+	 */
+	smp_wmb();
+	coupled->prevent--;
+	/* Force cpus out of the prevent loop. */
+	cpuidle_coupled_poke_others(cpu, coupled);
+	put_cpu();
+}
+
+/**
+ * cpuidle_coupled_cpu_notify - notifier called during hotplug transitions
+ * @nb: notifier block
+ * @action: hotplug transition
+ * @hcpu: target cpu number
+ *
+ * Called when a cpu is brought on or offline using hotplug.  Updates the
+ * coupled cpu set appropriately
+ */
+static int cpuidle_coupled_cpu_notify(struct notifier_block *nb,
+		unsigned long action, void *hcpu)
+{
+	int cpu = (unsigned long)hcpu;
+	struct cpuidle_device *dev;
+
+	switch (action & ~CPU_TASKS_FROZEN) {
+	case CPU_UP_PREPARE:
+	case CPU_DOWN_PREPARE:
+	case CPU_ONLINE:
+	case CPU_DEAD:
+	case CPU_UP_CANCELED:
+	case CPU_DOWN_FAILED:
+		break;
+	default:
+		return NOTIFY_OK;
+	}
+
+	mutex_lock(&cpuidle_lock);
+
+	dev = per_cpu(cpuidle_devices, cpu);
+	if (!dev->coupled)
+		goto out;
+
+	switch (action & ~CPU_TASKS_FROZEN) {
+	case CPU_UP_PREPARE:
+	case CPU_DOWN_PREPARE:
+		cpuidle_coupled_prevent_idle(dev->coupled);
+		break;
+	case CPU_ONLINE:
+	case CPU_DEAD:
+		cpuidle_coupled_update_online_cpus(dev->coupled);
+		/* Fall through */
+	case CPU_UP_CANCELED:
+	case CPU_DOWN_FAILED:
+		cpuidle_coupled_allow_idle(dev->coupled);
+		break;
+	}
+
+out:
+	mutex_unlock(&cpuidle_lock);
+	return NOTIFY_OK;
+}
+
+static struct notifier_block cpuidle_coupled_cpu_notifier = {
+	.notifier_call = cpuidle_coupled_cpu_notify,
+};
+
+static int __init cpuidle_coupled_init(void)
+{
+	return register_cpu_notifier(&cpuidle_coupled_cpu_notifier);
+}
+core_initcall(cpuidle_coupled_init);
diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c
index 2f0083a5..e81cfda2 100644
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@ -102,6 +102,34 @@ int cpuidle_play_dead(void)
 	return -ENODEV;
 }
 
+/**
+ * cpuidle_enter_state - enter the state and update stats
+ * @dev: cpuidle device for this cpu
+ * @drv: cpuidle driver for this cpu
+ * @next_state: index into drv->states of the state to enter
+ */
+int cpuidle_enter_state(struct cpuidle_device *dev, struct cpuidle_driver *drv,
+		int next_state)
+{
+	int entered_state;
+
+	entered_state = cpuidle_enter_ops(dev, drv, next_state);
+
+	if (entered_state >= 0) {
+		/* Update cpuidle counters */
+		/* This can be moved to within driver enter routine
+		 * but that results in multiple copies of same code.
+		 */
+		dev->states_usage[entered_state].time +=
+				(unsigned long long)dev->last_residency;
+		dev->states_usage[entered_state].usage++;
+	} else {
+		dev->last_residency = 0;
+	}
+
+	return entered_state;
+}
+
 /**
  * cpuidle_idle_call - the main idle loop
  *
@@ -143,23 +171,15 @@ int cpuidle_idle_call(void)
 	trace_power_start_rcuidle(POWER_CSTATE, next_state, dev->cpu);
 	trace_cpu_idle_rcuidle(next_state, dev->cpu);
 
-	entered_state = cpuidle_enter_ops(dev, drv, next_state);
+	if (cpuidle_state_is_coupled(dev, drv, next_state))
+		entered_state = cpuidle_enter_state_coupled(dev, drv,
+							    next_state);
+	else
+		entered_state = cpuidle_enter_state(dev, drv, next_state);
 
 	trace_power_end_rcuidle(dev->cpu);
 	trace_cpu_idle_rcuidle(PWR_EVENT_EXIT, dev->cpu);
 
-	if (entered_state >= 0) {
-		/* Update cpuidle counters */
-		/* This can be moved to within driver enter routine
-		 * but that results in multiple copies of same code.
-		 */
-		dev->states_usage[entered_state].time +=
-				(unsigned long long)dev->last_residency;
-		dev->states_usage[entered_state].usage++;
-	} else {
-		dev->last_residency = 0;
-	}
-
 	/* give the governor an opportunity to reflect on the outcome */
 	if (cpuidle_curr_governor->reflect)
 		cpuidle_curr_governor->reflect(dev, entered_state);
@@ -387,13 +407,25 @@ static int __cpuidle_register_device(struct cpuidle_device *dev)
 
 	per_cpu(cpuidle_devices, dev->cpu) = dev;
 	list_add(&dev->device_list, &cpuidle_detected_devices);
-	if ((ret = cpuidle_add_sysfs(cpu_dev))) {
-		module_put(cpuidle_driver->owner);
-		return ret;
-	}
+	ret = cpuidle_add_sysfs(cpu_dev);
+	if (ret)
+		goto err_sysfs;
+
+	ret = cpuidle_coupled_register_device(dev);
+	if (ret)
+		goto err_coupled;
 
 	dev->registered = 1;
 	return 0;
+
+err_coupled:
+	cpuidle_remove_sysfs(cpu_dev);
+	wait_for_completion(&dev->kobj_unregister);
+err_sysfs:
+	list_del(&dev->device_list);
+	per_cpu(cpuidle_devices, dev->cpu) = NULL;
+	module_put(cpuidle_driver->owner);
+	return ret;
 }
 
 /**
@@ -443,6 +475,8 @@ void cpuidle_unregister_device(struct cpuidle_device *dev)
 	wait_for_completion(&dev->kobj_unregister);
 	per_cpu(cpuidle_devices, dev->cpu) = NULL;
 
+	cpuidle_coupled_unregister_device(dev);
+
 	cpuidle_resume_and_unlock();
 
 	module_put(cpuidle_driver->owner);
diff --git a/drivers/cpuidle/cpuidle.h b/drivers/cpuidle/cpuidle.h
index 7db18668..76e7f696 100644
--- a/drivers/cpuidle/cpuidle.h
+++ b/drivers/cpuidle/cpuidle.h
@@ -14,6 +14,8 @@ extern struct list_head cpuidle_detected_devices;
 extern struct mutex cpuidle_lock;
 extern spinlock_t cpuidle_driver_lock;
 extern int cpuidle_disabled(void);
+extern int cpuidle_enter_state(struct cpuidle_device *dev,
+		struct cpuidle_driver *drv, int next_state);
 
 /* idle loop */
 extern void cpuidle_install_idle_handler(void);
@@ -30,4 +32,34 @@ extern void cpuidle_remove_state_sysfs(struct cpuidle_device *device);
 extern int cpuidle_add_sysfs(struct device *dev);
 extern void cpuidle_remove_sysfs(struct device *dev);
 
+#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED
+bool cpuidle_state_is_coupled(struct cpuidle_device *dev,
+		struct cpuidle_driver *drv, int state);
+int cpuidle_enter_state_coupled(struct cpuidle_device *dev,
+		struct cpuidle_driver *drv, int next_state);
+int cpuidle_coupled_register_device(struct cpuidle_device *dev);
+void cpuidle_coupled_unregister_device(struct cpuidle_device *dev);
+#else
+static inline bool cpuidle_state_is_coupled(struct cpuidle_device *dev,
+		struct cpuidle_driver *drv, int state)
+{
+	return false;
+}
+
+static inline int cpuidle_enter_state_coupled(struct cpuidle_device *dev,
+		struct cpuidle_driver *drv, int next_state)
+{
+	return -1;
+}
+
+static inline int cpuidle_coupled_register_device(struct cpuidle_device *dev)
+{
+	return 0;
+}
+
+static inline void cpuidle_coupled_unregister_device(struct cpuidle_device *dev)
+{
+}
+#endif
+
 #endif /* __DRIVER_CPUIDLE_H */
diff --git a/drivers/cpuidle/governors/menu.c b/drivers/cpuidle/governors/menu.c
index 06335756..746f1e6b 100644
--- a/drivers/cpuidle/governors/menu.c
+++ b/drivers/cpuidle/governors/menu.c
@@ -173,7 +173,12 @@ static inline int performance_multiplier(void)
 
 	/* for higher loadavg, we are more reluctant */
 
-	mult += 2 * get_loadavg();
+	/*
+	 * this doesn't work as intended - it is almost always 0, but can
+	 * sometimes, depending on workload, spike very high into the hundreds
+	 * even when the average cpu load is under 10%.
+	 */
+	/* mult += 2 * get_loadavg(); */
 
 	/* for IO wait tasks (per cpu!) we add 5x each */
 	mult += 10 * nr_iowait_cpu(smp_processor_id());
diff --git a/drivers/devfreq/Kconfig b/drivers/devfreq/Kconfig
index 464fa214..d9ebd49f 100644
--- a/drivers/devfreq/Kconfig
+++ b/drivers/devfreq/Kconfig
@@ -63,6 +63,16 @@ config DEVFREQ_GOV_USERSPACE
 	  Otherwise, the governor does not change the frequnecy
 	  given at the initialization.
 
+config DEVFREQ_GOV_THROUGHPUT
+        bool "Throughput"
+        help
+	  Set frequency based on recent throughput (e.g. how many MB/s).
+	  A device with throughput governor should provide current throughput
+	  value and available freq table. The throughput governor will choose
+	  a proper frequency according to current throughput. A device may
+	  provide tuned values to the governor with data field at
+	  devfreq_add_device().
+
 comment "DEVFREQ Drivers"
 
 config ARM_EXYNOS4_BUS_DEVFREQ
@@ -78,4 +88,56 @@ config ARM_EXYNOS4_BUS_DEVFREQ
 	  To operate with optimal voltages, ASV support is required
 	  (CONFIG_EXYNOS_ASV).
 
+config VPU_DEVFREQ
+	bool "Marvell Soc's VPU devfreq driver"
+	select DEVFREQ_GOV_USERSPACE
+	help
+	  This adds the DEVFREQ driver for Marvell Soc's VPU.
+	  Use the DEVFreq governor 'userspace' as default. This allows
+	  userspace to set the vpu frequency to dedicate frequency.
+
+config DDR_DEVFREQ
+	bool "DDR devfreq driver support"
+	help
+	  This adds the mck4 devfreq driver support.
+
+if DDR_DEVFREQ
+choice
+	bool "DDR devfreq default governor"
+	default DDR_DEVFREQ_GOV_THROUGHPUT
+	help
+	  this selects the default governor of DDR devfreq driver
+
+config DDR_DEVFREQ_GOV_THROUGHPUT
+	bool "Throughput"
+	select DEVFREQ_GOV_THROUGHPUT
+	help
+	  Use the DEVFreq governor 'Throughput' as default. This allows
+	  you to get a full dynamic frequency capable system by simply
+	  loading your devfreq low-level hardware driver.
+	  Be aware that not all devfreq drivers support the throughput
+	  governor.
+
+config DDR_DEVFREQ_GOV_ONDEMAND
+	bool "Simple Ondemand"
+	select DEVFREQ_GOV_SIMPLE_ONDEMAND
+	help
+	  Use the DEVFreq governor 'Simple Ondemand' as default. This allows
+	  you to get a full dynamic frequency capable system by simply
+	  loading your devfreq low-level hardware driver.
+	  Be aware that not all devfreq drivers support the simple ondemand
+	  governor.
+
+config DDR_DEVFREQ_GOV_USERSPACE
+	bool "Userspace"
+	select DEVFREQ_GOV_USERSPACE
+	help
+	  Use the DEVFreq governor 'Userspace' as default. This allows
+	  you to set the ddr frequency manually or when a userspace
+	  program shall be able to set the ddr dynamically without having
+	  to enable the userspace governor manually.
+endchoice
+
+endif # DDR_DEVFREQ
+
 endif # PM_DEVFREQ
diff --git a/drivers/devfreq/Makefile b/drivers/devfreq/Makefile
index 8c464234..ea155f06 100644
--- a/drivers/devfreq/Makefile
+++ b/drivers/devfreq/Makefile
@@ -3,6 +3,9 @@ obj-$(CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND)	+= governor_simpleondemand.o
 obj-$(CONFIG_DEVFREQ_GOV_PERFORMANCE)	+= governor_performance.o
 obj-$(CONFIG_DEVFREQ_GOV_POWERSAVE)	+= governor_powersave.o
 obj-$(CONFIG_DEVFREQ_GOV_USERSPACE)	+= governor_userspace.o
+obj-$(CONFIG_DEVFREQ_GOV_THROUGHPUT)    += governor_throughput.o
 
 # DEVFREQ Drivers
 obj-$(CONFIG_ARM_EXYNOS4_BUS_DEVFREQ)	+= exynos4_bus.o
+obj-$(CONFIG_VPU_DEVFREQ)     += devfreq-vpu.o
+obj-$(CONFIG_DDR_DEVFREQ)		+= mck4_memorybus.o
diff --git a/drivers/devfreq/devfreq-vpu.c b/drivers/devfreq/devfreq-vpu.c
new file mode 100644
index 00000000..07f51a94
--- /dev/null
+++ b/drivers/devfreq/devfreq-vpu.c
@@ -0,0 +1,156 @@
+/*
+ * devfreq-vpu: Generic Dynamic Voltage and Frequency Scaling (DVFS) Framework
+ *		  for vpu Device.
+ *
+ * Copyright (C) 2010 Marvell International Ltd.
+ *	Xiaoguang Chen <chenxg@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/devfreq.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <plat/devfreq.h>
+#include <mach/dvfs.h>
+
+#define DEVFREQ_DEFAULT_GOVERNOR	(&devfreq_userspace)
+
+#define KHZ_TO_HZ	1000
+
+struct vpu_devfreq_data {
+	struct devfreq *devfreq;
+	struct clk *vclk;
+};
+
+static struct vpu_devfreq_data *cur_data;
+
+static int dvfs_notifier_freq(struct notifier_block *nb,
+			      unsigned long val, void *data)
+{
+	struct dvfs_freqs *freqs = (struct dvfs_freqs *)data;
+	if (strcmp(freqs->dvfs->clk_name, cur_data->vclk->name))
+		return 0;
+
+	switch (val) {
+	case DVFS_FREQ_POSTCHANGE:
+		cur_data->devfreq->previous_freq = freqs->new;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static struct notifier_block notifier_freq_block = {
+	.notifier_call = dvfs_notifier_freq,
+};
+
+static int vpu_target(struct device *dev, unsigned long *freq, u32 flags)
+{
+	struct platform_device *pdev = container_of(dev, struct platform_device,
+						    dev);
+	struct vpu_devfreq_data *data = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	ret = clk_set_rate(data->vclk, *freq * KHZ_TO_HZ);
+	if (!ret)
+		*freq = clk_get_rate(data->vclk) / KHZ_TO_HZ;
+	return ret;
+}
+
+static struct devfreq_dev_profile vpu_devfreq_profile = {
+	.target = vpu_target,
+};
+
+static int vpu_devfreq_probe(struct platform_device *pdev)
+{
+	struct vpu_devfreq_data *data = NULL;
+	struct devfreq_platform_data *pdata;
+	int err = 0;
+	int i = 0;
+	struct device *dev = &pdev->dev;
+	pdata = (struct devfreq_platform_data *)dev->platform_data;
+	if (!pdata) {
+		dev_err(dev, "No platform data!\n");
+		goto out;
+	}
+
+	data = kzalloc(sizeof(struct vpu_devfreq_data), GFP_KERNEL);
+
+	if (data == NULL) {
+		dev_err(dev, "Cannot allocate memory for vpu devfreq!\n");
+		return -ENOMEM;
+	}
+	platform_set_drvdata(pdev, data);
+	data->vclk = clk_get(NULL, pdata->clk_name);
+	if (IS_ERR(data->vclk)) {
+		err = PTR_ERR(data->vclk);
+		goto out;
+	}
+	vpu_devfreq_profile.initial_freq =
+			clk_get_rate(data->vclk) / KHZ_TO_HZ;
+
+	data->devfreq = devfreq_add_device(dev, &vpu_devfreq_profile,
+					   DEVFREQ_DEFAULT_GOVERNOR, NULL);
+	if (IS_ERR(data->devfreq)) {
+		err = PTR_ERR(data->devfreq);
+		goto out;
+	}
+
+	cur_data = data;
+
+	dvfs_register_notifier(&notifier_freq_block, DVFS_FREQUENCY_NOTIFIER);
+
+	if (pdata->freq_table) {
+		devfreq_set_freq_table(data->devfreq, pdata->freq_table);
+
+		while (pdata->freq_table[i].frequency != DEVFREQ_TABLE_END)
+			i++;
+		data->devfreq->max_freq = data->devfreq->qos_max_freq = pdata->freq_table[i-1].frequency;
+		data->devfreq->min_freq = data->devfreq->qos_min_freq = pdata->freq_table[0].frequency;
+	}
+
+	return 0;
+out:
+	kfree(data);
+	return err;
+}
+
+static int vpu_devfreq_remove(struct platform_device *pdev)
+{
+	struct vpu_devfreq_data *data = platform_get_drvdata(pdev);
+	devfreq_remove_device(data->devfreq);
+	kfree(data);
+	dvfs_unregister_notifier(&notifier_freq_block, DVFS_FREQUENCY_NOTIFIER);
+	return 0;
+}
+
+static struct platform_driver vpu_devfreq_driver = {
+	.probe = vpu_devfreq_probe,
+	.remove = vpu_devfreq_remove,
+	.driver = {
+		   .name = "devfreq-vpu",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init vpu_devfreq_init(void)
+{
+	return platform_driver_register(&vpu_devfreq_driver);
+}
+
+static void __init vpu_devfreq_exit(void)
+{
+	platform_driver_unregister(&vpu_devfreq_driver);
+}
+
+module_init(vpu_devfreq_init);
+module_exit(vpu_devfreq_exit);
+
+MODULE_DESCRIPTION("vpu devfreq device driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/devfreq/devfreq.c b/drivers/devfreq/devfreq.c
index 70c31d43..68b82d93 100644
--- a/drivers/devfreq/devfreq.c
+++ b/drivers/devfreq/devfreq.c
@@ -25,6 +25,7 @@
 #include <linux/list.h>
 #include <linux/printk.h>
 #include <linux/hrtimer.h>
+#include <linux/pm_qos.h>
 #include "governor.h"
 
 struct class *devfreq_class;
@@ -99,18 +100,19 @@ int update_devfreq(struct devfreq *devfreq)
 	 * Adjust the freuqency with user freq and QoS.
 	 *
 	 * List from the highest proiority
+	 * Qos_freq
 	 * max_freq (probably called by thermal when it's too hot)
 	 * min_freq
 	 */
+	freq = max(freq, devfreq->qos_min_freq);
+	freq = max(freq, devfreq->min_freq);
+	freq = min(freq, devfreq->qos_max_freq);
+	freq = min(freq, devfreq->max_freq);
 
-	if (devfreq->min_freq && freq < devfreq->min_freq) {
-		freq = devfreq->min_freq;
-		flags &= ~DEVFREQ_FLAG_LEAST_UPPER_BOUND; /* Use GLB */
-	}
-	if (devfreq->max_freq && freq > devfreq->max_freq) {
-		freq = devfreq->max_freq;
+	if ((freq == devfreq->qos_max_freq) || (freq == devfreq->max_freq))
 		flags |= DEVFREQ_FLAG_LEAST_UPPER_BOUND; /* Use LUB */
-	}
+	else
+		flags &= ~DEVFREQ_FLAG_LEAST_UPPER_BOUND; /* Use GLB */
 
 	err = devfreq->profile->target(devfreq->dev.parent, &freq, flags);
 	if (err)
@@ -142,6 +144,92 @@ static int devfreq_notifier_call(struct notifier_block *nb, unsigned long type,
 	return ret;
 }
 
+/**
+ * devfreq_qos_min_notifier_call() - It is called when kernel driver
+ * has constraints
+ */
+static int devfreq_qos_min_notifier_call(struct notifier_block *nb,
+					unsigned long value, void *devp)
+{
+	struct devfreq *devfreq = container_of(nb, struct devfreq, qos_min_nb);
+	int ret;
+	int i;
+	s32 default_value = PM_QOS_DEFAULT_VALUE;
+	struct devfreq_pm_qos_table *qos_list = devfreq->profile->qos_list;
+	bool qos_use_max = devfreq->qos_use_max;
+
+	if (!qos_list)
+		return NOTIFY_DONE;
+
+	mutex_lock(&devfreq->lock);
+
+	if (value == default_value) {
+		devfreq->qos_min_freq = 0;
+		goto update;
+	}
+
+	for (i = 0; qos_list[i].freq; i++) {
+		/* QoS Met */
+		if ((qos_use_max && qos_list[i].qos_value >= value) ||
+		    (!qos_use_max && qos_list[i].qos_value <= value)) {
+			devfreq->qos_min_freq = qos_list[i].freq;
+			goto update;
+		}
+	}
+
+	/* Use the highest QoS freq */
+	if (i > 0)
+		devfreq->qos_min_freq = qos_list[i - 1].freq;
+
+update:
+	ret = update_devfreq(devfreq);
+	mutex_unlock(&devfreq->lock);
+
+	return ret;
+}
+
+/**
+ * devfreq_qos_max_notifier_call() - It is called when kernel driver
+ * has constraints
+ */
+static int devfreq_qos_max_notifier_call(struct notifier_block *nb,
+					unsigned long value, void *devp)
+{
+	struct devfreq *devfreq = container_of(nb, struct devfreq, qos_max_nb);
+	int ret;
+	int i;
+	s32 default_value = PM_QOS_DEFAULT_VALUE;
+	struct devfreq_pm_qos_table *qos_list = devfreq->profile->qos_list;
+
+	if (!qos_list)
+		return NOTIFY_DONE;
+
+	mutex_lock(&devfreq->lock);
+
+	if (value == default_value) {
+		devfreq->qos_max_freq = INT_MAX;
+	goto update;
+	}
+	devfreq->qos_max_freq = qos_list[0].freq;
+	for (i = 1; qos_list[i - 1].freq; i++) {
+		if (!qos_list[i].freq) {
+			devfreq->qos_max_freq = qos_list[i - 1].freq;
+			goto update;
+		}
+		if ((qos_list[i - 1].qos_value <= value) &&
+		    (qos_list[i].qos_value > value)) {
+			devfreq->qos_max_freq = qos_list[i - 1].freq;
+			goto update;
+		}
+	}
+
+update:
+	ret = update_devfreq(devfreq);
+	mutex_unlock(&devfreq->lock);
+
+	return ret;
+}
+
 /**
  * _remove_devfreq() - Remove devfreq from the device.
  * @devfreq:	the devfreq struct
@@ -350,7 +438,7 @@ struct devfreq *devfreq_add_device(struct device *dev,
 				   void *data)
 {
 	struct devfreq *devfreq;
-	int err = 0;
+	int err = 0, i;
 
 	if (!dev || !profile || !governor) {
 		dev_err(dev, "%s: Invalid parameters.\n", __func__);
@@ -389,12 +477,86 @@ struct devfreq *devfreq_add_device(struct device *dev,
 	devfreq->next_polling = devfreq->polling_jiffies
 			      = msecs_to_jiffies(devfreq->profile->polling_ms);
 	devfreq->nb.notifier_call = devfreq_notifier_call;
+	devfreq->qos_min_nb.notifier_call = devfreq_qos_min_notifier_call;
+	devfreq->qos_max_nb.notifier_call = devfreq_qos_max_notifier_call;
+
+	/* Check the sanity of qos_list/qos_type */
+	if (profile->qos_type || profile->qos_list) {
+		switch (profile->qos_type) {
+		/*
+		 * add supported devfreq Qos type here, now only
+		 * PM_QOS_DDR_DEVFREQ_MIN type is supported
+		 */
+#ifdef CONFIG_DDR_DEVFREQ
+		case PM_QOS_DDR_DEVFREQ_MIN:
+			devfreq->qos_use_max = true;
+			break;
+#endif
+		default:
+			WARN(true, "Unknown PM-QoS Class (%d).\n",\
+				profile->qos_type);
+			err = -EINVAL;
+			goto err_dev;
+		}
+
+		if (WARN(!profile->qos_type || !profile->qos_list,
+			"QoS requirement partially omitted for %s.\n",
+			dev_name(dev))) {
+			err = -EINVAL;
+			goto err_dev;
+		}
+
+		if (WARN(!profile->qos_list[0].freq,
+			"The first QoS requirement is the end of list for %s.\n",
+			dev_name(dev))) {
+			err = -EINVAL;
+			goto err_dev;
+		}
+
+		for (i = 1; profile->qos_list[i].freq; i++) {
+			if (WARN(profile->qos_list[i].freq <=
+				profile->qos_list[i - 1].freq,
+				"%s's qos_list[].freq not sorted in the "
+				"ascending order. ([%d]=%lu, [%d]=%lu)\n",
+				dev_name(dev), i - 1,
+				profile->qos_list[i - 1].freq, i,
+				profile->qos_list[i].freq)) {
+				err = -EINVAL;
+				goto err_dev;
+			}
+
+			/*
+			 * If QoS type is throughput(PM_QOS_MAX), qos_value
+			 * should be sorted in the ascending order.
+			 * If QoS type is latency(PM_QOS_MIN), qos_value
+			 * should be sorted in the descending order.
+			 */
+			if (WARN((devfreq->qos_use_max &&
+				profile->qos_list[i - 1].qos_value >
+				profile->qos_list[i].qos_value) ||
+				(!devfreq->qos_use_max &&
+				 profile->qos_list[i - 1].qos_value <
+				 profile->qos_list[i].qos_value),
+				"%s's qos_list[].qos_value is not sorted "
+				"according to its QoS class. max type ascending"
+				"min type descending\n",
+				dev_name(dev))) {
+				err = -EINVAL;
+				goto err_dev;
+			}
+		}
+
+		pm_qos_add_notifier(PM_QOS_DDR_DEVFREQ_MIN,
+				    &devfreq->qos_min_nb);
+		pm_qos_add_notifier(PM_QOS_DDR_DEVFREQ_MAX,
+				    &devfreq->qos_max_nb);
+	}
 
 	dev_set_name(&devfreq->dev, dev_name(dev));
 	err = device_register(&devfreq->dev);
 	if (err) {
 		put_device(&devfreq->dev);
-		goto err_dev;
+		goto err_qos_add;
 	}
 
 	if (governor->init)
@@ -422,6 +584,13 @@ out:
 
 err_init:
 	device_unregister(&devfreq->dev);
+err_qos_add:
+	if (profile->qos_type || profile->qos_list) {
+		pm_qos_remove_notifier(PM_QOS_DDR_DEVFREQ_MIN,
+				       &devfreq->qos_min_nb);
+		pm_qos_remove_notifier(PM_QOS_DDR_DEVFREQ_MAX,
+				       &devfreq->qos_max_nb);
+	}
 err_dev:
 	mutex_unlock(&devfreq->lock);
 	kfree(devfreq);
@@ -452,6 +621,14 @@ int devfreq_remove_device(struct devfreq *devfreq)
 	}
 
 	mutex_lock(&devfreq->lock);
+
+	if (devfreq->profile->qos_type) {
+		pm_qos_remove_notifier(devfreq->profile->qos_type,
+				  &devfreq->qos_min_nb);
+		pm_qos_remove_notifier(devfreq->profile->qos_type,
+				  &devfreq->qos_max_nb);
+	}
+
 	_remove_devfreq(devfreq, false); /* it unlocks devfreq->lock */
 
 	if (central_polling)
@@ -460,6 +637,12 @@ int devfreq_remove_device(struct devfreq *devfreq)
 	return 0;
 }
 
+void devfreq_set_freq_table(struct devfreq *devfreq,
+			struct devfreq_frequency_table *table)
+{
+	devfreq->freq_table = table;
+}
+
 static ssize_t show_governor(struct device *dev,
 			     struct device_attribute *attr, char *buf)
 {
@@ -472,6 +655,23 @@ static ssize_t show_freq(struct device *dev,
 	return sprintf(buf, "%lu\n", to_devfreq(dev)->previous_freq);
 }
 
+static ssize_t show_avail_freq(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int len = 0, i;
+	struct devfreq *devfreq = to_devfreq(dev);
+	if (devfreq->freq_table) {
+		for (i = 0; devfreq->freq_table[i].frequency !=\
+					DEVFREQ_TABLE_END; i++)
+			len += sprintf(buf + len, "%lu ",
+				       devfreq->freq_table[i].frequency);
+		len += sprintf(buf + len, "\n");
+	}
+	if (len == 0)
+		len += sprintf(buf + len, "No frequency table is provided\n");
+	return len;
+}
+
 static ssize_t show_polling_interval(struct device *dev,
 				     struct device_attribute *attr, char *buf)
 {
@@ -537,6 +737,10 @@ static ssize_t store_min_freq(struct device *dev, struct device_attribute *attr,
 		ret = -EINVAL;
 		goto unlock;
 	}
+	if (df->min_freq == value) {
+		ret = count;
+		goto unlock;
+	}
 
 	df->min_freq = value;
 	update_devfreq(df);
@@ -571,6 +775,10 @@ static ssize_t store_max_freq(struct device *dev, struct device_attribute *attr,
 		ret = -EINVAL;
 		goto unlock;
 	}
+	if (df->max_freq == value) {
+		ret = count;
+		goto unlock;
+	}
 
 	df->max_freq = value;
 	update_devfreq(df);
@@ -587,6 +795,13 @@ static ssize_t show_max_freq(struct device *dev, struct device_attribute *attr,
 	return sprintf(buf, "%lu\n", to_devfreq(dev)->max_freq);
 }
 
+static ssize_t show_qos_min_freq(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	return sprintf(buf, "%lu\n", to_devfreq(dev)->qos_min_freq);
+}
+
 static struct device_attribute devfreq_attrs[] = {
 	__ATTR(governor, S_IRUGO, show_governor, NULL),
 	__ATTR(cur_freq, S_IRUGO, show_freq, NULL),
@@ -595,6 +810,8 @@ static struct device_attribute devfreq_attrs[] = {
 	       store_polling_interval),
 	__ATTR(min_freq, S_IRUGO | S_IWUSR, show_min_freq, store_min_freq),
 	__ATTR(max_freq, S_IRUGO | S_IWUSR, show_max_freq, store_max_freq),
+	__ATTR(available_freqs, S_IRUGO, show_avail_freq, NULL),
+	__ATTR(qos_min_freq, S_IRUGO, show_qos_min_freq, NULL),
 	{ },
 };
 
diff --git a/drivers/devfreq/governor_performance.c b/drivers/devfreq/governor_performance.c
index 574a06b1..af75ddd4 100644
--- a/drivers/devfreq/governor_performance.c
+++ b/drivers/devfreq/governor_performance.c
@@ -10,6 +10,7 @@
  */
 
 #include <linux/devfreq.h>
+#include "governor.h"
 
 static int devfreq_performance_func(struct devfreq *df,
 				    unsigned long *freq)
@@ -25,8 +26,14 @@ static int devfreq_performance_func(struct devfreq *df,
 	return 0;
 }
 
+static int performance_init(struct devfreq *devfreq)
+{
+	return update_devfreq(devfreq);
+}
+
 const struct devfreq_governor devfreq_performance = {
 	.name = "performance",
+	.init = performance_init,
 	.get_target_freq = devfreq_performance_func,
 	.no_central_polling = true,
 };
diff --git a/drivers/devfreq/governor_powersave.c b/drivers/devfreq/governor_powersave.c
index d742d4a8..fec0cdbd 100644
--- a/drivers/devfreq/governor_powersave.c
+++ b/drivers/devfreq/governor_powersave.c
@@ -10,6 +10,7 @@
  */
 
 #include <linux/devfreq.h>
+#include "governor.h"
 
 static int devfreq_powersave_func(struct devfreq *df,
 				  unsigned long *freq)
@@ -22,8 +23,14 @@ static int devfreq_powersave_func(struct devfreq *df,
 	return 0;
 }
 
+static int powersave_init(struct devfreq *devfreq)
+{
+	return update_devfreq(devfreq);
+}
+
 const struct devfreq_governor devfreq_powersave = {
 	.name = "powersave",
+	.init = powersave_init,
 	.get_target_freq = devfreq_powersave_func,
 	.no_central_polling = true,
 };
diff --git a/drivers/devfreq/governor_simpleondemand.c b/drivers/devfreq/governor_simpleondemand.c
index a2e3eae7..7db7024d 100644
--- a/drivers/devfreq/governor_simpleondemand.c
+++ b/drivers/devfreq/governor_simpleondemand.c
@@ -12,10 +12,15 @@
 #include <linux/errno.h>
 #include <linux/devfreq.h>
 #include <linux/math64.h>
+#include <linux/device.h>
+#include "governor.h"
+
 
 /* Default constants for DevFreq-Simple-Ondemand (DFSO) */
 #define DFSO_UPTHRESHOLD	(90)
 #define DFSO_DOWNDIFFERENCTIAL	(5)
+#define DFSO_MAX_UPTHRESHOLD	(100)
+
 static int devfreq_simple_ondemand_func(struct devfreq *df,
 					unsigned long *freq)
 {
@@ -27,8 +32,14 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 	struct devfreq_simple_ondemand_data *data = df->data;
 	unsigned long max = (df->max_freq) ? df->max_freq : UINT_MAX;
 
-	if (err)
-		return err;
+	if (err) {
+		/* Used to represent ignoring the profiling result */
+		if (err == -EINVAL) {
+			*freq = stat.current_frequency;
+			return 0;
+		} else
+		  return err;
+	}
 
 	if (data) {
 		if (data->upthreshold)
@@ -52,12 +63,14 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 		stat.total_time >>= 7;
 	}
 
+#if !defined(CONFIG_CPU_PXA988) && !defined(CONFIG_CPU_PXA1088)
 	/* Set MAX if it's busy enough */
 	if (stat.busy_time * 100 >
 	    stat.total_time * dfso_upthreshold) {
 		*freq = max;
 		return 0;
 	}
+#endif
 
 	/* Set MAX if we do not know the initial frequency */
 	if (stat.current_frequency == 0) {
@@ -65,14 +78,20 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 		return 0;
 	}
 
-	/* Keep the current frequency */
-	if (stat.busy_time * 100 >
-	    stat.total_time * (dfso_upthreshold - dfso_downdifferential)) {
+	/*
+	 * if (upthreshold - downdifferential) <
+	 * workload < upthreshold
+	 * Keep the current frequency
+	 */
+	if ((stat.busy_time * 100 >
+	    stat.total_time * (dfso_upthreshold - dfso_downdifferential))
+				&& (stat.busy_time * 100 <
+					stat.total_time * dfso_upthreshold)) {
 		*freq = stat.current_frequency;
 		return 0;
 	}
 
-	/* Set the desired frequency based on the load */
+	/* else we set the desired frequency based on the load */
 	a = stat.busy_time;
 	a *= stat.current_frequency;
 	b = div_u64(a, stat.total_time);
@@ -88,7 +107,113 @@ static int devfreq_simple_ondemand_func(struct devfreq *df,
 	return 0;
 }
 
+static ssize_t upthreshold_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct devfreq *devfreq = to_devfreq(dev);
+	struct devfreq_simple_ondemand_data *data;
+	int rc = 0;
+
+	mutex_lock(&devfreq->lock);
+	data = devfreq->data;
+	rc = sprintf(buf, "%u\n", data->upthreshold);
+	mutex_unlock(&devfreq->lock);
+
+	return rc;
+}
+
+static ssize_t upthreshold_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	struct devfreq *devfreq = to_devfreq(dev);
+	struct devfreq_simple_ondemand_data *data;
+	int ret;
+	unsigned int input;
+
+	mutex_lock(&devfreq->lock);
+	data = devfreq->data;
+
+	ret = sscanf(buf, "%u", &input);
+	if (ret != 1 || input > DFSO_MAX_UPTHRESHOLD ||
+			input <= data->downdifferential) {
+		mutex_unlock(&devfreq->lock);
+		return -EINVAL;
+	}
+	data->upthreshold = input;
+	mutex_unlock(&devfreq->lock);
+
+	return count;
+}
+
+static ssize_t downdifferential_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct devfreq *devfreq = to_devfreq(dev);
+	struct devfreq_simple_ondemand_data *data;
+	int rc = 0;
+
+	mutex_lock(&devfreq->lock);
+	data = devfreq->data;
+	rc = sprintf(buf, "%u\n", data->downdifferential);
+	mutex_unlock(&devfreq->lock);
+	return rc;
+}
+
+static ssize_t downdifferential_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	struct devfreq *devfreq = to_devfreq(dev);
+	struct devfreq_simple_ondemand_data *data;
+	int ret;
+	unsigned int input;
+
+	mutex_lock(&devfreq->lock);
+	data = devfreq->data;
+
+	ret = sscanf(buf, "%u", &input);
+	if (ret != 1 || input > data->upthreshold) {
+		mutex_unlock(&devfreq->lock);
+		return -EINVAL;
+	}
+	data->downdifferential = input;
+	mutex_unlock(&devfreq->lock);
+
+	return count;
+}
+static DEVICE_ATTR(upthreshold, 0644,
+	upthreshold_show, upthreshold_store);
+
+static DEVICE_ATTR(downdifferential, 0644,
+	downdifferential_show, downdifferential_store);
+
+
+static struct attribute *dev_entries[] = {
+	&dev_attr_upthreshold.attr,
+	&dev_attr_downdifferential.attr,
+	NULL,
+};
+
+static struct attribute_group simpondemand_attributes = {
+	.name	= "ondemand",
+	.attrs	= dev_entries,
+};
+
+static int devfreq_simpleondemand_init(struct devfreq *devfreq)
+{
+	return sysfs_create_group(&devfreq->dev.kobj,
+			&simpondemand_attributes);
+}
+
+static void devfreq_simpleondemand_exit(struct devfreq *devfreq)
+{
+	sysfs_remove_group(&devfreq->dev.kobj, &simpondemand_attributes);
+}
+
 const struct devfreq_governor devfreq_simple_ondemand = {
 	.name = "simple_ondemand",
 	.get_target_freq = devfreq_simple_ondemand_func,
+	.init = devfreq_simpleondemand_init,
+	.exit = devfreq_simpleondemand_exit,
 };
diff --git a/drivers/devfreq/governor_throughput.c b/drivers/devfreq/governor_throughput.c
new file mode 100644
index 00000000..8419a19c
--- /dev/null
+++ b/drivers/devfreq/governor_throughput.c
@@ -0,0 +1,218 @@
+/*
+ *  linux/drivers/devfreq/governor_throughput.c
+ *
+ *  Copyright (C) 2013 Marvell
+ *	Leo Song <liangs@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/errno.h>
+#include <linux/devfreq.h>
+#include <linux/math64.h>
+#include <linux/device.h>
+#include "governor.h"
+
+
+/* Default constants for DevFreq-Throughput */
+#define DFSO_UPTHRESHOLD	(90)
+#define DFSO_DOWNDIFFERENCTIAL	(5)
+#define DFSO_MAX_UPTHRESHOLD	(100)
+#define MAX_TABLE_ITEM		(8)
+
+static int devfreq_throughput_func(struct devfreq *df, unsigned long *freq)
+{
+	struct devfreq_throughput_data *data = df->data;
+	struct throughput_threshold *throughput_table = data->throughput_table;
+	u32 *freq_table = data->freq_table;
+	u32 table_len = data->table_len;
+	struct devfreq_dev_status stat;
+	int i;
+	int err;
+
+	/* only 1 freq point can not use this governor */
+	if ((data->table_len <= 1) || (data->table_len > MAX_TABLE_ITEM)) {
+		dev_err(&df->dev, "freq table too small or too big!\n");
+		return -EINVAL;
+	}
+
+	err = df->profile->get_dev_status(df->dev.parent, &stat);
+	if (err) {
+		/* Used to represent ignoring the profiling result */
+		if (err == -EINVAL) {
+			*freq = stat.current_frequency;
+			return 0;
+		} else
+		  return err;
+	}
+
+	/*
+	 * make sure get_dev_status() has updated the current_frequency;
+	 * at least set *freq to a reansonable values
+	 */
+	*freq = stat.current_frequency;
+
+	/*
+	 * throughput == -1 is set by low level driver deliberately, to inform
+	 * the governor not to trust the throughput data. This is not fatal
+	 * error, just end this time's caculation, and do it next time.
+	 */
+	if (stat.throughput == -1) {
+		dev_dbg(&df->dev, "throughput is not suitable!\n");
+		return -EAGAIN;
+	} else if (stat.throughput < -1) {
+		dev_err(&df->dev, "fatal: throughput is not as expected!\n");
+		return -EINVAL;
+	}
+
+	if ((stat.throughput >= 0)
+	 && (stat.throughput < throughput_table[0].down)) {
+		/* set to lowest freq */
+		*freq = freq_table[0];
+	} else if (stat.throughput > throughput_table[table_len - 2].up) {
+		/* set to highest freq */
+		*freq = freq_table[table_len - 1];
+	} else {
+		for (i = 0; i <= (table_len - 2); i++) {
+			if ((stat.throughput >= throughput_table[i].down)
+			 && (stat.throughput <= throughput_table[i].up)) {
+				/*
+				 * If cur_speed is between UP and DOWN
+				 * keep freq unchanged in most cases
+				 */
+				*freq = stat.current_frequency;
+				/* Handle corner case */
+				if ((*freq != freq_table[i])
+				 && (*freq != freq_table[i + 1])) {
+					/* also can choose freq_table[i + 1] */
+					*freq = freq_table[i];
+				}
+				break;
+			} else if ((stat.throughput > throughput_table[i].up)
+			&& (stat.throughput < throughput_table[i + 1].down)) {
+				*freq = freq_table[i + 1];
+				break;
+			}
+		}
+	}
+
+	if (df->min_freq && *freq < df->min_freq)
+		*freq = df->min_freq;
+	if (df->max_freq && *freq > df->max_freq)
+		*freq = df->max_freq;
+
+	dev_dbg(&df->dev, "speed=%d, *freq=%lu\n", stat.throughput, *freq);
+
+	return 0;
+}
+
+
+static ssize_t threshold_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct devfreq *devfreq = to_devfreq(dev);
+	struct devfreq_throughput_data *data;
+	int rc = 0;
+	int i;
+
+	mutex_lock(&devfreq->lock);
+	data = devfreq->data;
+
+	rc = sprintf(buf, "down_threshold = %u%%, up_threshold = %u%%\n",
+		data->upthreshold - data->downdifferential, data->upthreshold);
+
+	rc += sprintf(buf + rc,
+			"  freq_point \t  down_level \t    up_level\n");
+
+	for (i = 0; i < data->table_len; i++) {
+		rc += sprintf(buf + rc, "%12d\t%12d\t%12d\n",
+			data->freq_table[i], data->throughput_table[i].down,
+			data->throughput_table[i].up);
+	}
+
+	mutex_unlock(&devfreq->lock);
+
+	return rc;
+}
+
+static ssize_t threshold_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	struct devfreq *devfreq = to_devfreq(dev);
+	struct devfreq_throughput_data *data;
+	int ret;
+	int i;
+	unsigned int up, down;
+
+	mutex_lock(&devfreq->lock);
+	data = devfreq->data;
+
+	ret = sscanf(buf, "%u,%u", &down, &up);
+	if (ret != 2 || up > DFSO_MAX_UPTHRESHOLD ||
+			down > up) {
+		dev_warn(dev, "input threshold error!\n");
+		mutex_unlock(&devfreq->lock);
+		return -EINVAL;
+	}
+
+	data->upthreshold = up;
+	data->downdifferential = up - down;
+	for (i = 0; i < data->table_len; i++) {
+		data->throughput_table[i].up =
+					up * data->freq_table[i] / 100;
+		data->throughput_table[i].down =
+					down * data->freq_table[i] / 100;
+	}
+	mutex_unlock(&devfreq->lock);
+	return count;
+}
+
+static ssize_t help_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	int rc = 0;
+
+	rc += sprintf(buf + rc, "Tips: echo xx,yy > threshold\n"
+			"to change down and up threshold, limit is 100\n"
+			"xx is the down level, yy is the up level\n\n");
+	return rc;
+}
+
+static DEVICE_ATTR(help, 0444,
+	help_show, NULL);
+
+static DEVICE_ATTR(threshold, 0644,
+	threshold_show, threshold_store);
+
+static struct attribute *dev_entries[] = {
+	&dev_attr_threshold.attr,
+	&dev_attr_help.attr,
+	NULL,
+};
+
+static struct attribute_group throughput_attributes = {
+	.name	= "throughput",
+	.attrs	= dev_entries,
+};
+
+static int devfreq_throughput_init(struct devfreq *devfreq)
+{
+	return sysfs_create_group(&devfreq->dev.kobj,
+			&throughput_attributes);
+}
+
+static void devfreq_throughput_exit(struct devfreq *devfreq)
+{
+	sysfs_remove_group(&devfreq->dev.kobj, &throughput_attributes);
+}
+
+
+const struct devfreq_governor devfreq_throughput = {
+	.name = "throughput",
+	.get_target_freq = devfreq_throughput_func,
+	.init = devfreq_throughput_init,
+	.exit = devfreq_throughput_exit,
+};
diff --git a/drivers/devfreq/mck4_memorybus.c b/drivers/devfreq/mck4_memorybus.c
new file mode 100644
index 00000000..e92e995c
--- /dev/null
+++ b/drivers/devfreq/mck4_memorybus.c
@@ -0,0 +1,1117 @@
+/*
+ * linux/drivers/devfreq/mck4_memorybus.c
+ *
+ *  Copyright (C) 2012 Marvell International Ltd.
+ *  All rights reserved.
+ *
+ *  2012-03-16  Yifan Zhang <zhangyf@marvell.com>
+ *		Zhoujie Wu<zjwu@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/devfreq.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_qos.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <plat/devfreq.h>
+#include <mach/dvfs.h>
+#include <linux/sched.h>
+#include <linux/reboot.h>
+#include <plat/pxa_trace.h>
+
+#define DDR_FREQ_MAX 8
+#define DDR_DEVFREQ_UPTHRESHOLD 65
+#define DDR_DEVFREQ_DOWNDIFFERENTIAL 5
+
+#define KHZ_TO_HZ   1000
+
+struct ddr_devfreq_data {
+	struct devfreq *pdev_ddr;
+	struct clk *ddr_clk;
+	u32 mc_base_pri;/* primary addr */
+	/* DDR frequency table used for platform */
+	u32 ddr_freq_tbl[DDR_FREQ_MAX];	/* unit Khz */
+	u32 ddr_freq_tbl_len;
+	unsigned long last_polled_at;
+	spinlock_t lock;
+
+	/* used for performance optimization */
+	u32 high_upthrd_swp;
+	u32 high_upthrd;
+
+	/* used for debug interface */
+	atomic_t is_disabled;
+	struct timespec last_ts;
+};
+
+static struct ddr_devfreq_data *cur_data;
+static int dvfs_notifier_freq(struct notifier_block *nb,
+			      unsigned long val, void *data)
+{
+	struct dvfs_freqs *freqs = (struct dvfs_freqs *)data;
+	if (strcmp(freqs->dvfs->clk_name, cur_data->ddr_clk->name))
+		return 0;
+
+	switch (val) {
+	case DVFS_FREQ_POSTCHANGE:
+		cur_data->pdev_ddr->previous_freq = freqs->new;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static struct notifier_block notifier_freq_block = {
+	.notifier_call = dvfs_notifier_freq,
+};
+
+#ifdef CONFIG_DDR_DEVFREQ_GOV_ONDEMAND
+/* notifier to change the devfreq govoner's upthreshold */
+static int upthreshold_freq_notifer_call(struct notifier_block *nb,
+	       unsigned long val, void *data)
+{
+	struct cpufreq_freqs *freq = data;
+	struct devfreq *devfreq = cur_data->pdev_ddr;
+	struct devfreq_simple_ondemand_data *gov_data;
+
+	if (val != CPUFREQ_POSTCHANGE)
+		return NOTIFY_OK;
+
+	mutex_lock(&devfreq->lock);
+	gov_data = devfreq->data;
+	if (freq->new >= cur_data->high_upthrd_swp)
+		gov_data->upthreshold = cur_data->high_upthrd;
+	else
+		gov_data->upthreshold = DDR_DEVFREQ_UPTHRESHOLD;
+	mutex_unlock(&devfreq->lock);
+
+	trace_pxa_ddr_upthreshold(gov_data->upthreshold);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block upthreshold_freq_notifier = {
+	.notifier_call = upthreshold_freq_notifer_call
+};
+#endif
+
+#ifdef CONFIG_DDR_DEVFREQ_GOV_THROUGHPUT
+/* default using 65% as upthreshold and 5% as downdifferential */
+static struct devfreq_throughput_data devfreq_gov_data = {
+	.upthreshold = DDR_DEVFREQ_UPTHRESHOLD,
+	.downdifferential = DDR_DEVFREQ_DOWNDIFFERENTIAL,
+};
+#define DEVFREQ_GOV_DATA		(&devfreq_gov_data)
+#define DEVFREQ_DEFAULT_GOVERNOR        (&devfreq_throughput)
+
+#elif defined(CONFIG_DDR_DEVFREQ_GOV_ONDEMAND)
+/* default using 65% as upthreshold and 5% as downdifferential */
+static struct devfreq_simple_ondemand_data devfreq_gov_data = {
+	.upthreshold = DDR_DEVFREQ_UPTHRESHOLD,
+	.downdifferential = DDR_DEVFREQ_DOWNDIFFERENTIAL,
+};
+#define DEVFREQ_GOV_DATA		(&devfreq_gov_data)
+#define DEVFREQ_DEFAULT_GOVERNOR        (&devfreq_simple_ondemand)
+
+#elif defined(CONFIG_DDR_DEVFREQ_GOV_USERSPACE)
+#define DEVFREQ_GOV_DATA		(NULL)
+#define DEVFREQ_DEFAULT_GOVERNOR        (&devfreq_userspace)
+
+#endif /* CONFIG_DDR_DEVFREQ_GOV_THROUGHPUT */
+
+#define PERF_CONFIG_REG 0x440
+#define PERF_STATUS_REG 0x444
+#define PERF_CONTRL_REG 0x448
+#define PERF_CNT_0_REG  0x450
+#define PERF_CNT_1_REG  0x454
+#define PERF_CNT_2_REG  0x458
+#define PERF_CNT_3_REG  0x45C
+
+/*
+ *  reg[0] ddr_totalticks
+ *  reg[1] ddr_DPC_idle
+ *  reg[2] ddr_rw_cmd
+ *  reg[3] axi_req
+ */
+struct ddr_cycle_type {
+	u64 reg[4];
+};
+
+static unsigned int ddr_perf_cnt_old[4];
+static struct ddr_cycle_type ddr_ticks_array[DDR_FREQ_MAX];
+static int is_ddr_stats_working;
+
+static void reset_ddr_performance_counter(void)
+{
+	void *mck4_base_vaddr = (void *)cur_data->mc_base_pri;
+
+	if (!mck4_base_vaddr) {
+		dev_err(&cur_data->pdev_ddr->dev,
+			"ddr_perf: mcu_base map failure!\n");
+		return ;
+	}
+
+	/* Step1: Write to Performance Counter Configuration Register to
+	  disable interrupts and counters */
+	writel(0x0, mck4_base_vaddr + PERF_CONFIG_REG);
+
+	/* Step2: Write to Performance Counter Control Register to select
+	   the desired settings
+	   bit18:16 0x0 = Divide clock by 1
+	   bit4     0x1 = Continue counting on any counter overflow
+	   bit0     0x0 = Enabled counters begin counting */
+	writel(0x10, mck4_base_vaddr + PERF_CONTRL_REG);
+
+	/* Step3: Write to Performance Counter Register to set the starting
+	   value */
+	writel(0x0, mck4_base_vaddr + PERF_CNT_0_REG);
+	writel(0x0, mck4_base_vaddr + PERF_CNT_1_REG);
+	writel(0x0, mck4_base_vaddr + PERF_CNT_2_REG);
+	writel(0x0, mck4_base_vaddr + PERF_CNT_3_REG);
+
+	/* clear overflow flag */
+	writel(0xf, mck4_base_vaddr + PERF_STATUS_REG);
+
+	/* reset old data */
+	memset(ddr_perf_cnt_old, 0, sizeof(ddr_perf_cnt_old));
+}
+
+static void stop_ddr_performance_counter(void)
+{
+	void *mck4_base_vaddr = (void *)cur_data->mc_base_pri;
+	/* Step1: Write to Performance Counter Configuration Register to
+	  disable interrupts and counters */
+	writel(0x0, mck4_base_vaddr + PERF_CONFIG_REG);
+}
+
+static void start_ddr_performance_counter(void)
+{
+	void *mck4_base_vaddr = (void *)cur_data->mc_base_pri;
+	/* Step4: Write to Performance Counter Configuration Register to
+	   enable counters and/or interrupts, choose the events for counters
+	   simultaneously.
+	   bit 0: 7 cnt0, event=0x00, clock cycles
+	   bit 8:15 cnt1, event=0x01, DPC idle cycles
+	   bit16:23 cnt2, event=0x14, Read + Write command count
+	   bit24:31 cnt3, event=0x04, no bus utilization when not idle */
+	writel((((0x80 | 0x00) <<  0) | ((0x80 | 0x01) <<  8) |
+		((0x80 | 0x14) << 16) | ((0x80 | 0x04) << 24)),
+		mck4_base_vaddr + PERF_CONFIG_REG);
+}
+
+static int ddr_rate2_index(u32 rate)
+{
+	int i;
+	for (i = 0; i < cur_data->ddr_freq_tbl_len; i++)
+		if (cur_data->ddr_freq_tbl[i] == rate)
+			return i;
+	dev_err(&cur_data->pdev_ddr->dev, "unknow ddr rate %d\n", rate);
+	return -1;
+}
+
+static u32 ddr_index2_rate(int index)
+{
+	if ((index >= 0) && (index < cur_data->ddr_freq_tbl_len))
+		return cur_data->ddr_freq_tbl[index];
+	else {
+		dev_err(&cur_data->pdev_ddr->dev,
+			"unknow ddr index %d\n", index);
+		return 0;
+	}
+}
+
+static void update_ddr_performance_data(void)
+{
+	void *mck4_base_vaddr = (void *)cur_data->mc_base_pri;
+	unsigned int reg[4], i, overflow_flag;
+	int ddr_idx;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cur_data->lock, flags);
+
+	/* stop counters, to keep data synchronized */
+	stop_ddr_performance_counter();
+
+	/* overflow flag seems has some hardware issue, when the counters
+	   overflows, the overflow flag can't be set reliably  */
+	overflow_flag = readl(mck4_base_vaddr + PERF_STATUS_REG) & 0xf;
+
+	ddr_idx = ddr_rate2_index(clk_get_rate(cur_data->ddr_clk) / KHZ_TO_HZ);
+
+	if ((ddr_idx >= 0) && (ddr_idx < cur_data->ddr_freq_tbl_len)) {
+		for (i = 0; i < 4; i++) {
+			reg[i] = readl(mck4_base_vaddr +
+					PERF_CNT_0_REG + i * 4);
+
+			if (overflow_flag & (1 << i)) {
+				dev_dbg(&cur_data->pdev_ddr->dev,
+					 "DDR perf counter overflow!\n");
+				ddr_ticks_array[ddr_idx].reg[i] +=
+						0x100000000LLU + reg[i] -
+						ddr_perf_cnt_old[i];
+			} else
+				ddr_ticks_array[ddr_idx].reg[i] += reg[i] -
+							ddr_perf_cnt_old[i];
+
+			ddr_perf_cnt_old[i] = reg[i];
+		}
+	} else
+		dev_err(&cur_data->pdev_ddr->dev, "%s: invalid ddr_idx %u\n",
+			__func__, ddr_idx);
+
+	spin_unlock_irqrestore(&cur_data->lock, flags);
+}
+
+static int __init ddr_perf_counter_init(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&cur_data->lock, flags);
+	memset(ddr_ticks_array, 0,
+		sizeof(ddr_ticks_array));
+	reset_ddr_performance_counter();
+	start_ddr_performance_counter();
+	spin_unlock_irqrestore(&cur_data->lock, flags);
+
+	return 0;
+}
+
+static inline void reset_mc_cnt(u32 mc_base,
+			struct ddr_devfreq_data *data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&data->lock, flags);
+	reset_ddr_performance_counter();
+	start_ddr_performance_counter();
+	spin_unlock_irqrestore(&data->lock, flags);
+}
+
+/* calculate ddr workload according to busy and total time, unit percent */
+static inline u32 cal_workload(unsigned long busy_time,
+	unsigned long total_time)
+{
+	u64 tmp0, tmp1;
+
+	if (!total_time || !busy_time)
+		return 0;
+	tmp0 = busy_time * 100;
+	tmp1 = div_u64(tmp0, total_time);
+	return (u32)tmp1;
+}
+
+/*
+ * get the mck4 total_ticks, data_ticks, speed.
+ */
+static void get_ddr_cycles(struct ddr_devfreq_data *data,
+	unsigned long *total_ticks, unsigned long *data_ticks, int *speed)
+{
+	u32 mc_base;
+	unsigned long flags;
+	unsigned int diff_ms;
+	unsigned long long time_stamp_cur;
+	static unsigned long long time_stamp_old;
+
+	mc_base = data->mc_base_pri;
+
+	spin_lock_irqsave(&data->lock, flags);
+	/* stop counters, to keep data synchronized */
+	stop_ddr_performance_counter();
+	*total_ticks = readl(mc_base + PERF_CNT_0_REG);
+	*data_ticks = readl(mc_base + PERF_CNT_2_REG) * 4;
+	start_ddr_performance_counter();
+	spin_unlock_irqrestore(&data->lock, flags);
+
+	time_stamp_cur = sched_clock();
+	diff_ms = (unsigned int)(time_stamp_cur - time_stamp_old) / 1000000;
+	time_stamp_old = time_stamp_cur;
+
+	/*
+	 * When the diff_ms is too small or too big, it's not suitable to
+	 * caculate the speed. In this case, we set the speed to -1
+	 * deliberately, so that the throughput governor will not use the
+	 * speed this time.
+	 */
+	if ((diff_ms >= 50) && (diff_ms < 5000))
+		*speed = *data_ticks / diff_ms;
+	else
+		*speed = -1;
+}
+
+/* reset both mc1 and mc0 */
+static void reset_ddr_counters(struct ddr_devfreq_data *data)
+{
+	reset_mc_cnt(data->mc_base_pri, data);
+}
+
+static int ddr_get_dev_status(struct device *dev,
+			       struct devfreq_dev_status *stat)
+{
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+	struct devfreq *df;
+	u32 workload;
+	unsigned long now = jiffies;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+	df = data->pdev_ddr;
+
+	stat->current_frequency = clk_get_rate(data->ddr_clk) / KHZ_TO_HZ;
+	/* ignore the profiling if it is not from devfreq_monitor or there is no profiling */
+	if (!df->polling_jiffies ||
+		(df->polling_jiffies && data->last_polled_at &&
+		time_before(now, (data->last_polled_at + df->polling_jiffies)))) {
+		dev_dbg(dev, "No profiling or "
+			"interval is not expired %lu, %lu, %lu\n",
+			df->polling_jiffies, now, data->last_polled_at);
+		return -EINVAL;
+	}
+
+	get_ddr_cycles(data, &stat->total_time,
+			&stat->busy_time, &stat->throughput);
+	if (is_ddr_stats_working)
+		update_ddr_performance_data();
+	reset_ddr_counters(data);
+	data->last_polled_at = now;
+
+	/* Ajust the workload calculation here to align with devfreq governor */
+	if (stat->busy_time >= (1 << 24) || stat->total_time >= (1 << 24)) {
+		stat->busy_time >>= 7;
+		stat->total_time >>= 7;
+	}
+
+	workload = cal_workload(stat->busy_time, stat->total_time);
+
+	dev_dbg(dev, "workload is %d precent\n", workload);
+	dev_dbg(dev, "busy time is 0x%x, %u\n", (u32)stat->busy_time,
+		 (u32)stat->busy_time);
+	dev_dbg(dev, "total time is 0x%x, %u\n\n",
+		(u32)stat->total_time,
+		(u32)stat->total_time);
+	dev_dbg(dev, "throughput is 0x%x, throughput * 8 (speed) is %u\n\n",
+		(u32)stat->throughput, 8 * stat->throughput);
+
+	trace_pxa_ddr_workload(workload, stat->current_frequency,
+				stat->throughput);
+
+	return 0;
+}
+
+static int ddr_set_rate(struct ddr_devfreq_data *data, unsigned long tgt_rate)
+{
+	unsigned long cur_freq, tgt_freq;
+
+	cur_freq = clk_get_rate(data->ddr_clk);
+	tgt_freq = tgt_rate * KHZ_TO_HZ;
+
+	if (cur_freq == tgt_freq)
+		return 0;
+
+	dev_dbg(&data->pdev_ddr->dev, "%s: curfreq %lu, tgtfreq %lu\n",
+		__func__, cur_freq, tgt_freq);
+
+	/* update performance data before ddr clock change */
+	if (is_ddr_stats_working)
+		update_ddr_performance_data();
+
+	/* clk_set_rate will find a frequency larger or equal tgt_freq */
+	clk_set_rate(data->ddr_clk, tgt_freq);
+
+	/* re-init ddr performance counters after ddr clock change */
+	if (is_ddr_stats_working)
+		reset_ddr_counters(data);
+
+	return 0;
+}
+
+static int ddr_target(struct device *dev, unsigned long *freq, u32 flags)
+{
+	unsigned long tgt_freq;
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+	struct devfreq *df;
+	u32 *ddr_freq_table, ddr_freq_len;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+
+	/* in normal case ddr fc will NOT be disabled */
+	if (unlikely(atomic_read(&data->is_disabled))) {
+		df = data->pdev_ddr;
+		/*
+		 * this function is called with df->locked, it is safe to
+		 * read the polling_ms here
+		 */
+		if (df->profile->polling_ms)
+			dev_err(dev, "[WARN] ddr ll fc is disabled from "\
+				"debug interface, suggest to disable "\
+				"the profiling at first!\n");
+		*freq = clk_get_rate(data->ddr_clk) / KHZ_TO_HZ;
+		return 0;
+	}
+
+	ddr_freq_table = &data->ddr_freq_tbl[0];
+	ddr_freq_len = data->ddr_freq_tbl_len;
+	dev_dbg(dev, "%s: %u\n", __func__, (u32)*freq);
+	/*
+	 * if freq is u32 max, change ddr to the max freq.
+	 * because pm_qos_update_request take u32 parameter, so
+	 * there would be truncation.
+	 */
+	if (*freq == UINT_MAX)
+		*freq = ddr_freq_table[ddr_freq_len - 1];
+
+	tgt_freq = min(*freq,
+			(unsigned long)ddr_freq_table[ddr_freq_len - 1]);
+	ddr_set_rate(data, tgt_freq);
+
+	*freq = clk_get_rate(data->ddr_clk) / KHZ_TO_HZ;
+	return 0;
+}
+
+/* interface to change the switch point of high aggresive upthreshold */
+static ssize_t high_swp_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+	struct devfreq *devfreq;
+	unsigned int swp;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+	devfreq = data->pdev_ddr;
+
+	if (0x1 != sscanf(buf, "%u", &swp)) {
+		dev_err(dev, "<ERR> wrong parameter\n");
+		return -E2BIG;
+	}
+
+	mutex_lock(&devfreq->lock);
+	data->high_upthrd_swp = swp;
+	mutex_unlock(&devfreq->lock);
+
+	return size;
+}
+
+static ssize_t high_swp_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+	return sprintf(buf, "%u\n", data->high_upthrd_swp);
+}
+
+/* interface to change the aggresive upthreshold value */
+static ssize_t high_upthrd_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+	struct devfreq *devfreq;
+	unsigned int high_upthrd;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+	devfreq = data->pdev_ddr;
+
+	if (0x1 != sscanf(buf, "%u", &high_upthrd)) {
+		dev_err(dev, "<ERR> wrong parameter\n");
+		return -E2BIG;
+	}
+
+	mutex_lock(&devfreq->lock);
+	data->high_upthrd = high_upthrd;
+	mutex_unlock(&devfreq->lock);
+
+	return size;
+}
+
+static ssize_t high_upthrd_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+	return sprintf(buf, "%u\n", data->high_upthrd);
+}
+
+/* debug interface used to totally disable ddr fc */
+static ssize_t disable_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+	int is_disabled;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+
+	if (0x1 != sscanf(buf, "%d", &is_disabled)) {
+		dev_err(dev, "<ERR> wrong parameter\n");
+		return -E2BIG;
+	}
+
+	is_disabled = !!is_disabled;
+	if (is_disabled == atomic_read(&data->is_disabled)) {
+		dev_info(dev, "[WARNING] ddr fc is already %s\n",
+			atomic_read(&data->is_disabled) ? \
+			"disabled" : "enabled");
+		return size;
+	}
+
+	if (is_disabled)
+		atomic_inc(&data->is_disabled);
+	else
+		atomic_dec(&data->is_disabled);
+
+	dev_info(dev, "[WARNING]ddr fc is %s from debug interface!\n",\
+		atomic_read(&data->is_disabled) ? "disabled" : "enabled");
+	return size;
+}
+
+static ssize_t disable_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+	return sprintf(buf, "ddr fc is_disabled = %d\n",
+		 atomic_read(&data->is_disabled));
+}
+
+/*
+ * Debug interface used to change ddr rate.
+ * It will ignore all devfreq and Qos requests.
+ * Use interface disable_ddr_fc prior to it.
+ */
+static ssize_t ddr_freq_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+	int freq;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+
+	if (!atomic_read(&data->is_disabled)) {
+		dev_err(dev, "<ERR> It will change ddr rate,"\
+			"disable ddr fc at first\n");
+		return -EPERM;
+	}
+
+	if (0x1 != sscanf(buf, "%d", &freq)) {
+		dev_err(dev, "<ERR> wrong parameter, "\
+			"echo freq > ddr_freq to set ddr rate(unit Khz)\n");
+		return -E2BIG;
+	}
+	clk_set_rate(data->ddr_clk, freq * KHZ_TO_HZ);
+
+	dev_dbg(dev, "ddr freq read back: %lu\n", \
+		clk_get_rate(data->ddr_clk) / KHZ_TO_HZ);
+
+	return size;
+}
+
+static ssize_t ddr_freq_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+	return sprintf(buf, "current ddr freq is: %lu\n",
+		 clk_get_rate(data->ddr_clk) / KHZ_TO_HZ);
+}
+
+/* used to collect ddr cnt during 20ms */
+static ssize_t dp_show(struct device *dev, struct device_attribute *attr,
+		       char *buf)
+{
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+	int len = 0;
+	unsigned long flags;
+
+	int i, j, k;
+	u32 glob_ratio, idle_ratio, busy_ratio, data_ratio;
+	u32 util_ratio;
+	u32 tmp_total, tmp_dpc_idle, tmp_rw_cmd, tmp_no_util;
+	u64 glob_ticks;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+
+
+	/* ddr ticks show */
+	len += sprintf(buf + len, "\nddr_ticks operating point list:\n");
+
+	len += sprintf(buf + len, "idx|dmcfs|  total_ticks   |"
+			" DPC_idle_ticks |   R+W_cmd_cnt  |no_util_not_idle\n");
+
+	len += sprintf(buf + len, "----------------------------------"
+			"-------------------------------------------\n");
+
+	spin_lock_irqsave(&data->lock, flags);
+
+	for (i = 0; i < cur_data->ddr_freq_tbl_len; i++) {
+		len += sprintf(buf + len,
+			"%3d|%5u|%16llu|%16llu|%16llu|%16llu\n",
+			i, ddr_index2_rate(i)/1000,
+			ddr_ticks_array[i].reg[0],
+			ddr_ticks_array[i].reg[1],
+			ddr_ticks_array[i].reg[2],
+			ddr_ticks_array[i].reg[3]);
+	}
+	spin_unlock_irqrestore(&data->lock, flags);
+
+	len += sprintf(buf + len, "\n");
+
+	/* ddr duty cycle show */
+	glob_ticks = 0;
+
+	len += sprintf(buf + len,
+			"\nddr_duty_cycle operating point list:\n");
+
+	len += sprintf(buf + len, "idx|dmcfs|glob_ratio|idle_ratio"
+			"|busy_ratio|data_ratio|util_ratio\n");
+
+	len += sprintf(buf + len, "-----------------------------"
+			"------------------------------------\n");
+
+	spin_lock_irqsave(&data->lock, flags);
+
+	for (i = 0; i < cur_data->ddr_freq_tbl_len; i++)
+		glob_ticks += ddr_ticks_array[i].reg[0];
+
+	k = 0;
+	while ((glob_ticks >> k) > 0x7FFF)
+		k++;
+
+	for (i = 0; i < cur_data->ddr_freq_tbl_len; i++) {
+
+		if ((u32)(glob_ticks>>k) != 0)
+			glob_ratio = (u32)(ddr_ticks_array[i].reg[0]>>k)
+					* 100000 / (u32)(glob_ticks>>k) + 5;
+		else
+			glob_ratio = 0;
+
+		j = 0;
+		while ((ddr_ticks_array[i].reg[0] >> j) > 0x7FFF)
+			j++;
+
+		tmp_total = ddr_ticks_array[i].reg[0] >> j;
+		tmp_dpc_idle = ddr_ticks_array[i].reg[1] >> j;
+		tmp_rw_cmd = ddr_ticks_array[i].reg[2] >> j;
+		tmp_no_util = ddr_ticks_array[i].reg[3] >> j;
+
+
+		if (tmp_total != 0) {
+			idle_ratio = (tmp_total - tmp_rw_cmd * 4 - tmp_no_util)
+					* 100000 / tmp_total + 5;
+
+			busy_ratio = (tmp_rw_cmd * 4 + tmp_no_util) * 100000
+					/ tmp_total + 5;
+
+			data_ratio = tmp_rw_cmd * 4 * 100000 / tmp_total + 5;
+
+			util_ratio = tmp_rw_cmd * 4 * 100000
+				/ (tmp_rw_cmd * 4 + tmp_no_util) + 5;
+		} else {
+			idle_ratio = 0;
+			busy_ratio = 0;
+			data_ratio = 0;
+			util_ratio = 0;
+		}
+
+		len += sprintf(buf + len, "%3d|%5u|%6u.%02u%%|%6u.%02u%%"
+			"|%6u.%02u%%|%6u.%02u%%|%6u.%02u%%\n",
+			       i, ddr_index2_rate(i)/1000,
+				glob_ratio/1000, (glob_ratio%1000)/10,
+				idle_ratio/1000, (idle_ratio%1000)/10,
+				busy_ratio/1000, (busy_ratio%1000)/10,
+				data_ratio/1000, (data_ratio%1000)/10,
+				util_ratio/1000, (util_ratio%1000)/10);
+	}
+	spin_unlock_irqrestore(&data->lock, flags);
+
+	len += sprintf(buf + len, "\n");
+
+	return len;
+}
+
+/* used to collect ddr cnt during a time */
+static ssize_t dp_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+	unsigned int cap_flag;
+	unsigned long flags;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+
+	sscanf(buf, "%u", &cap_flag);
+
+	if (cap_flag == 1) {
+		spin_lock_irqsave(&data->lock, flags);
+		memset(ddr_ticks_array, 0,
+			sizeof(ddr_ticks_array));
+		spin_unlock_irqrestore(&data->lock, flags);
+
+		is_ddr_stats_working = 1;
+
+	} else if (cap_flag == 0) {
+		is_ddr_stats_working = 0;
+	} else
+		dev_err(&data->pdev_ddr->dev,
+			"echo 1 > ddr_profiling to reset and start\n"
+			"echo 0 > ddr_profiling to stop\n"
+			"cat ddr_profiling to show ddr ticks and duty cycle\n");
+
+	return size;
+}
+
+static struct pm_qos_request ddrfreq_qos_req_max;
+static ssize_t ddr_max_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct platform_device *pdev;
+	struct ddr_devfreq_data *data;
+	int max_level, min_level = PM_QOS_DEFAULT_VALUE;
+	struct list_head *list_min;
+	struct plist_node *node;
+	struct pm_qos_request *req;
+
+	static int inited;
+	pdev = container_of(dev, struct platform_device, dev);
+	data = platform_get_drvdata(pdev);
+
+
+	if (0x1 != sscanf(buf, "%d", &max_level)) {
+		dev_err(dev, "<ERR> wrong parameter, "\
+			"echo level > ddr_max to set max ddr rate\n");
+		return -E2BIG;
+	}
+	if (!inited) {
+		ddrfreq_qos_req_max.name = "DIP";
+		pm_qos_add_request(&ddrfreq_qos_req_max,
+				PM_QOS_DDR_DEVFREQ_MAX,
+				PM_QOS_DEFAULT_VALUE);
+		inited = 1;
+	}
+	if (cur_data->ddr_freq_tbl[cur_data->ddr_freq_tbl_len - 2] > 400000000) {
+		if (max_level >= 3)
+			max_level = 4;
+	}
+	if (max_level == 1)
+		max_level = 2;
+
+	list_min = &pm_qos_array[PM_QOS_DDR_DEVFREQ_MIN]->constraints->list.node_list;
+	list_for_each_entry(node, list_min, node_list) {
+		req = container_of(node, struct pm_qos_request, node);
+		if (req->name && !strcmp(req->name, "cp")) {
+			min_level = node->prio;
+			break;
+		}
+	}
+	if ((max_level == PM_QOS_DEFAULT_VALUE) || (max_level >= min_level))
+		pm_qos_update_request(&ddrfreq_qos_req_max, max_level);
+
+	return size;
+}
+
+static DEVICE_ATTR(high_upthrd_swp, S_IRUGO | S_IWUSR, \
+	high_swp_show, high_swp_store);
+static DEVICE_ATTR(high_upthrd, S_IRUGO | S_IWUSR, \
+	high_upthrd_show, high_upthrd_store);
+static DEVICE_ATTR(disable_ddr_fc, S_IRUGO | S_IWUSR, \
+	disable_show, disable_store);
+static DEVICE_ATTR(ddr_freq, S_IRUGO | S_IWUSR, ddr_freq_show, ddr_freq_store);
+static DEVICE_ATTR(ddr_profiling, S_IRUGO | S_IWUSR, dp_show, dp_store);
+static DEVICE_ATTR(ddr_max, S_IRUGO | S_IWUSR, NULL, ddr_max_store);
+
+static struct devfreq_dev_profile ddr_devfreq_profile = {
+	/* FIXME turn off profiling until ddr devfreq tests are completed */
+	.polling_ms = 0,
+	.target = ddr_target,
+	.get_dev_status = ddr_get_dev_status,
+};
+
+static int ddr_reboot_notify(struct notifier_block *nb,
+	unsigned long event, void *dummy)
+{
+	struct devfreq *df = cur_data->pdev_ddr;
+	mutex_lock(&df->lock);
+	/* scaling to the min frequency before reboot/powerdown */
+	ddr_set_rate(cur_data, cur_data->ddr_freq_tbl[0]);
+	/* disable profiling and all request from userspace */
+	df->profile->polling_ms = 0;
+	if (likely(!atomic_read(&cur_data->is_disabled)))
+		atomic_inc(&cur_data->is_disabled);
+	pr_info("%s: disable ddr freq-chg before reboot, cur"\
+		" rate %luKhz\n", __func__,
+		clk_get_rate(cur_data->ddr_clk) / KHZ_TO_HZ);
+	mutex_unlock(&df->lock);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block ddr_devfreq_reboot_notifier = {
+	.notifier_call = ddr_reboot_notify,
+	.priority = 99,
+};
+
+static int ddr_devfreq_probe(struct platform_device *pdev)
+{
+	int i = 0, res;
+	int ret = 0;
+	struct device *dev = &pdev->dev;
+	struct devfreq_platform_data *pdata = NULL;
+	struct ddr_devfreq_data *data = NULL;
+	const char *ddr_clk_name;
+
+	pdata = (struct devfreq_platform_data *)dev->platform_data;
+	if (!pdata) {
+		dev_err(dev, "No platform data!\n");
+		return -EINVAL;
+	}
+
+	data = kzalloc(sizeof(struct ddr_devfreq_data), GFP_KERNEL);
+	if (data == NULL) {
+		dev_err(dev, "Cannot allocate memory.\n");
+		return -ENOMEM;
+	}
+
+	ddr_clk_name = (pdata->clk_name) ? (pdata->clk_name) : "ddr";
+	data->ddr_clk = clk_get_sys(NULL, ddr_clk_name);
+	if (IS_ERR(data->ddr_clk)) {
+		dev_err(dev, "Cannot get clk ptr.\n");
+		ret = PTR_ERR(data->ddr_clk);
+		goto err_clk_get;
+	}
+
+	data->mc_base_pri = pdata->hw_base[0];
+
+	/* save ddr frequency tbl */
+	if (pdata->freq_table != NULL) {
+		while (pdata->freq_table[i].frequency != DEVFREQ_TABLE_END) {
+			data->ddr_freq_tbl[i] = pdata->freq_table[i].frequency;
+			i++;
+		}
+		data->ddr_freq_tbl_len = i;
+	}
+
+#ifdef CONFIG_DDR_DEVFREQ_GOV_THROUGHPUT
+	devfreq_gov_data.table_len = data->ddr_freq_tbl_len;
+	devfreq_gov_data.freq_table = data->ddr_freq_tbl;
+
+	devfreq_gov_data.throughput_table =
+				kzalloc(devfreq_gov_data.table_len
+			* sizeof(struct throughput_threshold), GFP_KERNEL);
+	if (NULL == devfreq_gov_data.throughput_table) {
+		dev_err(dev,
+			"Cannot allocate memory for throughput table\n");
+		goto err_alloc_throughput_table;
+	}
+
+	for (i = 0; i < devfreq_gov_data.table_len; i++) {
+		devfreq_gov_data.throughput_table[i].up =
+		   DDR_DEVFREQ_UPTHRESHOLD * data->ddr_freq_tbl[i] / 100;
+		devfreq_gov_data.throughput_table[i].down =
+		   (DDR_DEVFREQ_UPTHRESHOLD - DDR_DEVFREQ_DOWNDIFFERENTIAL)
+		   * data->ddr_freq_tbl[i] / 100;
+	}
+#endif /* CONFIG_DDR_DEVFREQ_GOV_THROUGHPUT */
+
+	spin_lock_init(&data->lock);
+
+	ddr_devfreq_profile.initial_freq =
+		clk_get_rate(data->ddr_clk) / KHZ_TO_HZ;
+	/* Initilize the devfreq Qos if platform has registered the Qos req */
+	if (pdata->qos_list) {
+		ddr_devfreq_profile.qos_type = PM_QOS_DDR_DEVFREQ_MIN;
+		ddr_devfreq_profile.qos_list = pdata->qos_list;
+	}
+
+	data->pdev_ddr = devfreq_add_device(&pdev->dev, &ddr_devfreq_profile,
+				DEVFREQ_DEFAULT_GOVERNOR, DEVFREQ_GOV_DATA);
+	if (IS_ERR(data->pdev_ddr)) {
+		dev_err(dev, "devfreq add error !\n");
+		ret =  (unsigned long)data->pdev_ddr;
+		goto err_devfreq_add;
+	}
+
+	data->high_upthrd_swp = 800000;
+	data->high_upthrd = 30;
+
+	/* init default devfreq min_freq and max_freq */
+	if ((data->ddr_freq_tbl_len > 0) &&
+		(data->ddr_freq_tbl_len <= DDR_FREQ_MAX)) {
+		data->pdev_ddr->min_freq = data->pdev_ddr->qos_min_freq =
+			data->ddr_freq_tbl[0];
+		data->pdev_ddr->max_freq = data->pdev_ddr->qos_max_freq =
+			data->ddr_freq_tbl[data->ddr_freq_tbl_len - 1];
+	} else {
+		dev_err(dev, "invalid ddr freq_table length!\n");
+		ret = -EINVAL;
+		goto err_devfreq_add;
+	}
+	data->last_polled_at = jiffies;
+
+	/* Pass the frequency table to devfreq framework */
+	if (pdata->freq_table)
+		devfreq_set_freq_table(data->pdev_ddr, pdata->freq_table);
+
+	res = device_create_file(&pdev->dev, &dev_attr_disable_ddr_fc);
+	if (res) {
+		dev_err(dev,
+			"device attr disable_ddr_fc create fail: %d\n", res);
+		ret = -ENOENT;
+		goto err_file_create0;
+	}
+
+	res = device_create_file(&pdev->dev, &dev_attr_ddr_freq);
+	if (res) {
+		dev_err(dev, "device attr ddr_freq create fail: %d\n", res);
+		ret = -ENOENT;
+		goto err_file_create1;
+	}
+
+	res = device_create_file(&pdev->dev, &dev_attr_ddr_profiling);
+	if (res) {
+		dev_err(dev, \
+			"device attr ddr_profiling create fail: %d\n", res);
+		ret = -ENOENT;
+		goto err_file_create2;
+	}
+
+	res = device_create_file(&pdev->dev, &dev_attr_ddr_max);
+	if (res) {
+		dev_err(dev, \
+			"device attr ddr_max create fail: %d\n", res);
+		ret = -ENOENT;
+		goto err_file_create4;
+	}
+		
+	res = device_create_file(&pdev->dev, &dev_attr_high_upthrd_swp);
+	if (res) {
+		dev_err(dev, \
+			"device attr high_upthrd_swp create fail: %d\n", res);
+		ret = -ENOENT;
+		goto err_file_create5;
+	}
+
+	res = device_create_file(&pdev->dev, &dev_attr_high_upthrd);
+	if (res) {
+		dev_err(dev, \
+			"device attr high_upthrd create fail: %d\n", res);
+		ret = -ENOENT;
+		goto err_file_create6;
+	}
+
+	cur_data = data;
+	platform_set_drvdata(pdev, data);
+	dvfs_register_notifier(&notifier_freq_block, DVFS_FREQUENCY_NOTIFIER);
+	register_reboot_notifier(&ddr_devfreq_reboot_notifier);
+#ifdef CONFIG_DDR_DEVFREQ_GOV_ONDEMAND
+	/*
+	 * register the notifier to cpufreq driver,
+	 * it is triggered when core freq-chg is done
+	 */
+	cpufreq_register_notifier(&upthreshold_freq_notifier,
+		CPUFREQ_TRANSITION_NOTIFIER);
+#endif
+
+	ddr_perf_counter_init();
+	return 0;
+	
+err_file_create6:
+	device_remove_file(&pdev->dev, &dev_attr_high_upthrd);
+err_file_create5:
+	device_remove_file(&pdev->dev, &dev_attr_high_upthrd_swp);
+err_file_create4:
+	device_remove_file(&pdev->dev, &dev_attr_ddr_max);
+err_file_create2:
+	device_remove_file(&pdev->dev, &dev_attr_ddr_freq);
+err_file_create1:
+	device_remove_file(&pdev->dev, &dev_attr_disable_ddr_fc);
+err_file_create0:
+	devfreq_remove_device(data->pdev_ddr);
+err_devfreq_add:
+
+#ifdef CONFIG_DDR_DEVFREQ_GOV_THROUGHPUT
+	kfree(devfreq_gov_data.throughput_table);
+err_alloc_throughput_table:
+#endif /* CONFIG_DDR_DEVFREQ_GOV_THROUGHPUT */
+
+err_clk_get:
+	kfree(data);
+	return ret;
+}
+
+static int ddr_devfreq_remove(struct platform_device *pdev)
+{
+	struct ddr_devfreq_data *data = platform_get_drvdata(pdev);
+
+	device_remove_file(&pdev->dev, &dev_attr_disable_ddr_fc);
+	device_remove_file(&pdev->dev, &dev_attr_ddr_freq);
+	device_remove_file(&pdev->dev, &dev_attr_ddr_profiling);
+	device_remove_file(&pdev->dev, &dev_attr_ddr_max);
+	device_remove_file(&pdev->dev, &dev_attr_high_upthrd_swp);
+	device_remove_file(&pdev->dev, &dev_attr_high_upthrd);
+	devfreq_remove_device(data->pdev_ddr);
+
+#ifdef CONFIG_DDR_DEVFREQ_GOV_THROUGHPUT
+	kfree(devfreq_gov_data.throughput_table);
+#endif /* CONFIG_DDR_DEVFREQ_GOV_THROUGHPUT */
+
+	kfree(data);
+	dvfs_unregister_notifier(&notifier_freq_block, DVFS_FREQUENCY_NOTIFIER);
+	unregister_reboot_notifier(&ddr_devfreq_reboot_notifier);
+	return 0;
+}
+
+static struct platform_driver ddr_devfreq_driver = {
+	.probe = ddr_devfreq_probe,
+	.remove = ddr_devfreq_remove,
+	.driver = {
+		.name = "devfreq-ddr",
+		.owner = THIS_MODULE,
+	},
+};
+
+static void __init ddr_devfreq_exit(void)
+{
+	platform_driver_unregister(&ddr_devfreq_driver);
+}
+
+static int __init ddr_devfreq_init(void)
+{
+	return platform_driver_register(&ddr_devfreq_driver);
+}
+
+fs_initcall(ddr_devfreq_init);
+module_exit(ddr_devfreq_exit);
+
+MODULE_DESCRIPTION("mck4 memorybus devfreq driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index e03653d6..9546a7b1 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -514,4 +514,7 @@ config GPIO_TPS65910
 	help
 	  Select this option to enable GPIO driver for the TPS65910
 	  chip family.
+
+config SEC_GPIO_DVS
+	tristate "setting Samsung GPIO debugging and verification system"
 endif
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 007f54bd..df5d46e5 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -3,6 +3,7 @@
 ccflags-$(CONFIG_DEBUG_GPIO)	+= -DDEBUG
 
 obj-$(CONFIG_GPIOLIB)		+= gpiolib.o devres.o
+obj-$(CONFIG_SEC_GPIO_DVS)	+= secgpio_dvs.o
 
 # Device drivers. Generally keep list sorted alphabetically
 obj-$(CONFIG_GPIO_GENERIC)	+= gpio-generic.o
diff --git a/drivers/gpio/gpio-pxa.c b/drivers/gpio/gpio-pxa.c
index fc3ace3f..b374d956 100644
--- a/drivers/gpio/gpio-pxa.c
+++ b/drivers/gpio/gpio-pxa.c
@@ -11,17 +11,23 @@
  *  it under the terms of the GNU General Public License version 2 as
  *  published by the Free Software Foundation.
  */
+#include <linux/module.h>
 #include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/gpio.h>
 #include <linux/gpio-pxa.h>
 #include <linux/init.h>
 #include <linux/irq.h>
+#include <linux/irqdomain.h>
 #include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/syscore_ops.h>
 #include <linux/slab.h>
 
+#include <asm/mach/irq.h>
+
 #include <mach/irqs.h>
 
 /*
@@ -54,8 +60,14 @@
 
 #define BANK_OFF(n)	(((n) < 3) ? (n) << 2 : 0x100 + (((n) - 3) << 2))
 
+static int irq_base;
+
 int pxa_last_gpio;
 
+#ifdef CONFIG_OF
+static struct irq_domain *domain;
+#endif
+
 struct pxa_gpio_chip {
 	struct gpio_chip chip;
 	void __iomem	*regbase;
@@ -81,7 +93,6 @@ enum {
 	PXA3XX_GPIO,
 	PXA93X_GPIO,
 	MMP_GPIO = 0x10,
-	MMP2_GPIO,
 };
 
 static DEFINE_SPINLOCK(gpio_lock);
@@ -182,14 +193,14 @@ static inline int __pxa_irq_to_gpio(int irq) { return -1; }
 static inline int __mmp_gpio_to_irq(int gpio)
 {
 	if (gpio_is_mmp_type(gpio_type))
-		return MMP_GPIO_TO_IRQ(gpio);
+		return gpio + irq_base;
 	return -1;
 }
 
 static inline int __mmp_irq_to_gpio(int irq)
 {
 	if (gpio_is_mmp_type(gpio_type))
-		return irq - MMP_GPIO_TO_IRQ(0);
+		return irq - irq_base;
 	return -1;
 }
 #else
@@ -261,7 +272,10 @@ static int pxa_gpio_direction_output(struct gpio_chip *chip,
 
 static int pxa_gpio_get(struct gpio_chip *chip, unsigned offset)
 {
-	return readl_relaxed(gpio_chip_base(chip) + GPLR_OFFSET) & (1 << offset);
+	u32 gplr = __raw_readl(gpio_chip_base(chip) + GPLR_OFFSET);
+	u32 mask = 1 << offset;
+
+	return (gplr & mask) != 0;
 }
 
 static void pxa_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
@@ -270,6 +284,60 @@ static void pxa_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 				(value ? GPSR_OFFSET : GPCR_OFFSET));
 }
 
+#ifdef CONFIG_DEBUG_FS
+#include <linux/seq_file.h>
+static void pxa_gpio_dbg_show_one(struct seq_file *s,
+        struct gpio_chip *chip, unsigned offset, unsigned gpio)
+{
+        const char *label = gpiochip_is_requested(chip, offset);
+        struct pxa_gpio_chip *pxa_chip =
+                container_of(chip, struct pxa_gpio_chip, chip);
+        bool is_out;
+        uint32_t tmp,  mask = 1 << offset;
+        tmp = readl_relaxed(pxa_chip->regbase + GPDR_OFFSET);
+		is_out = tmp & mask;
+        seq_printf(s, " gpio-%-3d (%-20.20s) %s %s",
+                   gpio, label ?: "(null)",
+                   is_out ? "out" : "in ",
+                   chip->get
+                   ? (chip->get(chip, offset) ? "hi" : "lo")
+                   : "?  ");
+        if (label && !is_out) {
+                int             irq = gpio_to_irq(gpio);
+                struct irq_desc *desc = irq_to_desc(irq);
+                /* This races with request_irq(), set_irq_type(),
+                 * and set_irq_wake() ... but those are "rare".
+                 */
+                if (irq >= 0 && desc->action) {
+                        char *trigger;
+                        u32 bitmask = GPIO_bit(gpio);
+                        if (pxa_chip->irq_edge_rise & bitmask)
+                                trigger = "edge-rising";
+                        else if (pxa_chip->irq_edge_fall & bitmask)
+                                trigger = "edge-falling";
+                        else
+                                trigger = "edge-undefined";
+                        seq_printf(s, " irq-%d %s%s",
+                                   irq, trigger,
+                                   irqd_is_wakeup_set(&desc->irq_data)
+                                   ? " wakeup" : "");
+                }
+        }
+}
+
+static void  pxa_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
+{
+
+        unsigned                i;
+        unsigned                gpio = chip->base;
+
+        for (i = 0; i < chip->ngpio; i++, gpio++) {
+                pxa_gpio_dbg_show_one(s, chip, i, gpio);
+                seq_printf(s, "\n");
+        }
+}
+#endif
+
 static int __devinit pxa_init_gpio_chip(int gpio_end,
 					int (*set_wake)(unsigned int, unsigned int))
 {
@@ -297,6 +365,7 @@ static int __devinit pxa_init_gpio_chip(int gpio_end,
 		c->get = pxa_gpio_get;
 		c->set = pxa_gpio_set;
 		c->to_irq = pxa_gpio_to_irq;
+		c->dbg_show = pxa_gpio_dbg_show;
 
 		/* number of GPIOs on last bank may be less than 32 */
 		c->ngpio = (gpio + 31 > gpio_end) ? (gpio_end - gpio + 1) : 32;
@@ -372,6 +441,9 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irq_desc *desc)
 	struct pxa_gpio_chip *c;
 	int loop, gpio, gpio_base, n;
 	unsigned long gedr;
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+
+	chained_irq_enter(chip, desc);
 
 	do {
 		loop = 0;
@@ -391,6 +463,8 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irq_desc *desc)
 			}
 		}
 	} while (loop);
+
+	chained_irq_exit(chip, desc);
 }
 
 static void pxa_ack_muxed_gpio(struct irq_data *d)
@@ -470,27 +544,106 @@ static int pxa_gpio_nums(void)
 #endif /* CONFIG_ARCH_PXA */
 
 #ifdef CONFIG_ARCH_MMP
-	if (cpu_is_pxa168() || cpu_is_pxa910()) {
+	if (cpu_is_pxa168() || cpu_is_pxa910() ||
+	    cpu_is_pxa988() || cpu_is_pxa986() ||
+	    cpu_is_pxa1088()) {
 		count = 127;
 		gpio_type = MMP_GPIO;
-	} else if (cpu_is_mmp2()) {
+	} else if (cpu_is_mmp2() || cpu_is_mmp3() || cpu_is_eden()) {
 		count = 191;
-		gpio_type = MMP2_GPIO;
+		gpio_type = MMP_GPIO;
 	}
 #endif /* CONFIG_ARCH_MMP */
 	return count;
 }
 
+static struct of_device_id pxa_gpio_dt_ids[] = {
+	{ .compatible = "mrvl,pxa-gpio" },
+	{ .compatible = "mrvl,mmp-gpio", .data = (void *)MMP_GPIO },
+	{}
+};
+
+static int pxa_irq_domain_map(struct irq_domain *d, unsigned int irq,
+			      irq_hw_number_t hw)
+{
+	irq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,
+				 handle_edge_irq);
+	set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	return 0;
+}
+
+const struct irq_domain_ops pxa_irq_domain_ops = {
+	.map	= pxa_irq_domain_map,
+};
+
+#ifdef CONFIG_OF
+static int __devinit pxa_gpio_probe_dt(struct platform_device *pdev)
+{
+	int ret, nr_banks, nr_gpios;
+	struct device_node *prev, *next, *np = pdev->dev.of_node;
+	const struct of_device_id *of_id =
+				of_match_device(pxa_gpio_dt_ids, &pdev->dev);
+
+	if (!of_id) {
+		dev_err(&pdev->dev, "Failed to find gpio controller\n");
+		return -EFAULT;
+	}
+	gpio_type = (int)of_id->data;
+
+	next = of_get_next_child(np, NULL);
+	prev = next;
+	if (!next) {
+		dev_err(&pdev->dev, "Failed to find child gpio node\n");
+		ret = -EINVAL;
+		goto err;
+	}
+	for (nr_banks = 1; ; nr_banks++) {
+		next = of_get_next_child(np, prev);
+		if (!next)
+			break;
+		prev = next;
+	}
+	of_node_put(prev);
+	nr_gpios = nr_banks << 5;
+	pxa_last_gpio = nr_gpios - 1;
+
+	irq_base = irq_alloc_descs(-1, 0, nr_gpios, 0);
+	if (irq_base < 0) {
+		dev_err(&pdev->dev, "Failed to allocate IRQ numbers\n");
+		goto err;
+	}
+	domain = irq_domain_add_legacy(np, nr_gpios, irq_base, 0,
+				       &pxa_irq_domain_ops, NULL);
+	return 0;
+err:
+	iounmap(gpio_reg_base);
+	return ret;
+}
+#else
+#define pxa_gpio_probe_dt(pdev)		(-1)
+#endif
+
 static int __devinit pxa_gpio_probe(struct platform_device *pdev)
 {
 	struct pxa_gpio_chip *c;
 	struct resource *res;
 	struct clk *clk;
 	struct pxa_gpio_platform_data *info;
-	int gpio, irq, ret;
+	int gpio, irq, ret, use_of = 0;
 	int irq0 = 0, irq1 = 0, irq_mux, gpio_offset = 0;
 
-	pxa_last_gpio = pxa_gpio_nums();
+	ret = pxa_gpio_probe_dt(pdev);
+	if (ret < 0) {
+		pxa_last_gpio = pxa_gpio_nums();
+		irq_base = irq_alloc_descs(-1, 0, pxa_last_gpio, 0);
+		if (IS_ERR_VALUE(irq_base)) {
+			WARN(1, "Cannot allocate %d irq for gpio\n",
+				pxa_last_gpio);
+			return irq_base;
+		}
+	}
+	else
+		use_of = 1;
 	if (!pxa_last_gpio)
 		return -EINVAL;
 
@@ -545,25 +698,27 @@ static int __devinit pxa_gpio_probe(struct platform_device *pdev)
 			writel_relaxed(~0, c->regbase + ED_MASK_OFFSET);
 	}
 
+	if (!use_of) {
 #ifdef CONFIG_ARCH_PXA
-	irq = gpio_to_irq(0);
-	irq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,
-				 handle_edge_irq);
-	set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
-	irq_set_chained_handler(IRQ_GPIO0, pxa_gpio_demux_handler);
-
-	irq = gpio_to_irq(1);
-	irq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,
-				 handle_edge_irq);
-	set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
-	irq_set_chained_handler(IRQ_GPIO1, pxa_gpio_demux_handler);
-#endif
+		irq = gpio_to_irq(0);
+		irq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,
+					 handle_edge_irq);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+		irq_set_chained_handler(IRQ_GPIO0, pxa_gpio_demux_handler);
 
-	for (irq  = gpio_to_irq(gpio_offset);
-		irq <= gpio_to_irq(pxa_last_gpio); irq++) {
+		irq = gpio_to_irq(1);
 		irq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,
 					 handle_edge_irq);
 		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+		irq_set_chained_handler(IRQ_GPIO1, pxa_gpio_demux_handler);
+#endif
+
+		for (irq  = gpio_to_irq(gpio_offset);
+			irq <= gpio_to_irq(pxa_last_gpio); irq++) {
+			irq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,
+						 handle_edge_irq);
+			set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+		}
 	}
 
 	irq_set_chained_handler(irq_mux, pxa_gpio_demux_handler);
@@ -574,6 +729,7 @@ static struct platform_driver pxa_gpio_driver = {
 	.probe		= pxa_gpio_probe,
 	.driver		= {
 		.name	= "pxa-gpio",
+		.of_match_table = pxa_gpio_dt_ids,
 	},
 };
 
@@ -583,6 +739,21 @@ static int __init pxa_gpio_init(void)
 }
 postcore_initcall(pxa_gpio_init);
 
+#ifdef CONFIG_SEC_GPIO_DVS
+int pxa_direction_get(unsigned int* gpdr)
+{
+	struct pxa_gpio_chip *c;
+	int gpio, i = 0;
+
+	for_each_gpio_chip(gpio, c) {
+		gpdr[i] = readl_relaxed(c->regbase + GPDR_OFFSET);
+		i++;
+	}
+
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_PM
 static int pxa_gpio_suspend(void)
 {
@@ -625,10 +796,3 @@ struct syscore_ops pxa_gpio_syscore_ops = {
 	.suspend	= pxa_gpio_suspend,
 	.resume		= pxa_gpio_resume,
 };
-
-static int __init pxa_gpio_sysinit(void)
-{
-	register_syscore_ops(&pxa_gpio_syscore_ops);
-	return 0;
-}
-postcore_initcall(pxa_gpio_sysinit);
diff --git a/drivers/gpio/secgpio_dvs.c b/drivers/gpio/secgpio_dvs.c
new file mode 100755
index 00000000..aca601e1
--- /dev/null
+++ b/drivers/gpio/secgpio_dvs.c
@@ -0,0 +1,375 @@
+/*
+ * Samsung Mobile VE Group.
+ *
+ * drivers/gpio/secgpio_dvs.c
+ *
+ * Drivers for samsung gpio debugging & verification.
+ *
+ * Copyright (C) 2013, Samsung Electronics.
+ *
+ * This program is free software. You can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/proc_fs.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/timer.h>
+#include <linux/wakelock.h>
+#include <linux/power_supply.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+#include <linux/secgpio_dvs.h>
+
+/*sys fs*/
+struct class *secgpio_dvs_class;
+EXPORT_SYMBOL(secgpio_dvs_class);
+
+struct device *secgpio_dotest;
+EXPORT_SYMBOL(secgpio_dotest);
+
+/* extern GPIOMAP_RESULT GpioMap_result; */
+static struct gpio_dvs *gdvs_info;
+
+static ssize_t checked_secgpio_file_read(
+	struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t checked_sleep_secgpio_file_read(
+	struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t checked_secgpio_init_read_details(
+	struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t checked_secgpio_sleep_read_details(
+	struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t secgpio_ctrl_file_write(
+	struct device *dev, struct device_attribute *attr,
+	const char *buf, size_t size);
+static ssize_t secgpio_checked_sleepgpio_read(
+	struct device *dev, struct device_attribute *attr, char *buf);
+
+static DEVICE_ATTR(gpioinit_check, 0664,
+	checked_secgpio_file_read, NULL);
+static DEVICE_ATTR(gpiosleep_check, 0664,
+	checked_sleep_secgpio_file_read, NULL);
+static DEVICE_ATTR(check_init_detail, 0664,
+	checked_secgpio_init_read_details, NULL);
+static DEVICE_ATTR(check_sleep_detail, 0664,
+	checked_secgpio_sleep_read_details, NULL);
+static DEVICE_ATTR(secgpio_ctrl, 0664 , NULL, secgpio_ctrl_file_write);
+static DEVICE_ATTR(checked_sleepGPIO, 0664,
+	secgpio_checked_sleepgpio_read, NULL);
+
+static struct attribute *secgpio_dvs_attributes[] = {
+		&dev_attr_gpioinit_check.attr,
+		&dev_attr_gpiosleep_check.attr,
+		&dev_attr_check_init_detail.attr,
+		&dev_attr_check_sleep_detail.attr,
+		&dev_attr_secgpio_ctrl.attr,
+		&dev_attr_checked_sleepGPIO.attr,
+		NULL,
+};
+
+static struct attribute_group secgpio_dvs_attr_group = {
+		.attrs = secgpio_dvs_attributes,
+};
+
+static int atoi(const char *str)
+{
+	int result = 0;
+	int count = 0;
+	if (str == NULL)
+		return -EIO;
+	while (str[count] != 0	/* NULL */
+		&& str[count] >= '0' && str[count] <= '9')	{
+		result = result * 10 + str[count] - '0';
+		++count;
+	}
+	return result;
+}
+
+static char *
+strtok_r(char *s, const char *delim, char **last)
+{
+	char *spanp;
+	int c, sc;
+	char *tok;
+
+
+	/* if (s == NULL && (s = *last) == NULL)
+		return NULL;	 */
+	if (s == NULL) {
+		s = *last;
+		if (s == NULL)
+			return NULL;
+	}
+
+	/*
+	 * Skip (span) leading delimiters (s += strspn(s, delim), sort of).
+	 */
+cont:
+	c = *s++;
+	for (spanp = (char *)delim; (sc = *spanp++) != 0;) {
+		if (c == sc)
+			goto cont;
+	}
+
+	if (c == 0) {		/* no non-delimiter characters */
+		*last = NULL;
+		return NULL;
+	}
+	tok = s - 1;
+
+	/*
+	 * Scan token (scan for delimiters: s += strcspn(s, delim), sort of).
+	 * Note that delim must have one NUL; we stop if we see that, too.
+	 */
+	for (;;) {
+		c = *s++;
+		spanp = (char *)delim;
+		do {
+			sc = *spanp++;
+			if (sc == c) {
+				if (c == 0)
+					s = NULL;
+				else
+					s[-1] = 0;
+				*last = s;
+				return tok;
+			}
+		} while (sc != 0);
+	}
+	/* NOTREACHED */
+}
+
+static char *
+strtok(char *s, const char *delim)
+{
+	static char *last;
+
+	return strtok_r(s, delim, &last);
+}
+
+static ssize_t checked_secgpio_file_read(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int i = 0;
+	char temp_buf[20];
+	struct gpio_dvs *gdvs = dev_get_drvdata(dev);
+
+	for (i = 0; i < gdvs->count; i++) {
+		memset(temp_buf, 0, sizeof(char)*20);
+		snprintf(temp_buf, 20, "%x ", gdvs->result->init[i]);
+		strlcat(buf, temp_buf, PAGE_SIZE);
+	}
+
+	return strlen(buf);
+}
+
+static ssize_t checked_sleep_secgpio_file_read(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int i = 0;
+	char temp_buf[20];
+	struct gpio_dvs *gdvs = dev_get_drvdata(dev);
+
+	for (i = 0; i < gdvs->count; i++) {
+		memset(temp_buf, 0, sizeof(char)*20);
+		snprintf(temp_buf, 20, "%x ", gdvs->result->sleep[i]);
+		strlcat(buf, temp_buf, PAGE_SIZE);
+	}
+
+	return strlen(buf);
+}
+
+static ssize_t checked_secgpio_init_read_details(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int i = 0;
+	char temp_buf[20];
+	struct gpio_dvs *gdvs = dev_get_drvdata(dev);
+
+	for (i = 0; i < gdvs->count; i++) {
+		memset(temp_buf, 0, sizeof(char)*20);
+		snprintf(temp_buf, 20, "GI[%d] - %x\n ",
+			i, gdvs->result->init[i]);
+		strlcat(buf, temp_buf, PAGE_SIZE);
+	}
+
+	return strlen(buf);
+}
+static ssize_t checked_secgpio_sleep_read_details(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int i = 0;
+	char temp_buf[20];
+	struct gpio_dvs *gdvs = dev_get_drvdata(dev);
+
+	for (i = 0; i < gdvs->count; i++) {
+		memset(temp_buf, 0, sizeof(char)*20);
+		snprintf(temp_buf, 20, "GS[%d] - %x\n ",
+			i, gdvs->result->sleep[i]);
+		strlcat(buf, temp_buf, PAGE_SIZE);
+	}
+
+	return strlen(buf);
+
+}
+
+static ssize_t secgpio_ctrl_file_write(
+	struct device *dev, struct device_attribute *attr,
+	const char *buf, size_t size)
+{
+	char *token = NULL;
+	char comp[] = ",";
+	int gpio_ctrl[3] = {0,}, num = 0;
+	char temp_buf[50];
+
+	pr_info("[secgpio_dvs] GPIO onoff  buf = %s\n", buf);
+
+	memset(temp_buf, 0, 50);
+	strlcpy(temp_buf, buf, 50);
+	token = strtok(temp_buf, comp);
+
+	for (num = 0; num < 3; num++) {
+		if (token != NULL) {
+			pr_info("[secgpio_dvs] GPIO Control TOKEN = %s\n",
+				token);
+			gpio_ctrl[num] = atoi(token);
+			token = strtok(NULL, comp);
+		}
+		pr_info("[secgpio_dvs] GPIO Control[%d] = %d\n",
+			num, gpio_ctrl[num]);
+	}
+	/*
+		gpio_ctrl[0] = IN/OUT, gpio_ctrl[1] = GPIO NUMBER,
+		gpio_ctrl[2] = L/H
+	*/
+	 if (gpio_ctrl[0] == 1) {
+		gpio_request(gpio_ctrl[1], "gpio_output_test_on");
+		gpio_direction_input(gpio_ctrl[1]);
+		gpio_free(gpio_ctrl[1]);
+	} else {
+		gpio_request(gpio_ctrl[1], "gpio_output_test_on");
+		gpio_direction_output(gpio_ctrl[1], 1);
+		gpio_free(gpio_ctrl[1]);
+
+		if (gpio_ctrl[2] == 1) {
+			gpio_request(gpio_ctrl[1], "gpio_output_test_on");
+			gpio_set_value(gpio_ctrl[1], 1);
+			gpio_free(gpio_ctrl[1]);
+		} else if (gpio_ctrl[2] == 0) {
+			gpio_request(gpio_ctrl[1], "gpio_output_test_off");
+			gpio_set_value(gpio_ctrl[1], 0);
+			gpio_free(gpio_ctrl[1]);
+		}
+	}
+	return size;
+
+}
+
+static ssize_t secgpio_checked_sleepgpio_read(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct gpio_dvs *gdvs = dev_get_drvdata(dev);
+
+	if (gdvs->check_sleep)
+		return snprintf(buf, PAGE_SIZE, "1");
+	else
+		return snprintf(buf, PAGE_SIZE, "0");
+}
+
+void gpio_dvs_check_initgpio(void)
+{
+	if (gdvs_info && gdvs_info->check_gpio_status)
+		gdvs_info->check_gpio_status(PHONE_INIT);
+}
+
+void gpio_dvs_check_sleepgpio(void)
+{
+	if (unlikely(!gdvs_info->check_sleep)) {
+		gdvs_info->check_gpio_status(PHONE_SLEEP);
+		gdvs_info->check_sleep = true;
+	}
+}
+
+static int secgpio_dvs_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct class *secgpio_dvs_class;
+	struct device *secgpio_dotest;
+	struct gpio_dvs *gdvs = dev_get_platdata(&pdev->dev);
+
+	pr_info("[secgpio_dvs] %s has been created!!!\n", __func__);
+
+	secgpio_dvs_class = class_create(THIS_MODULE, "secgpio_check");
+	if (IS_ERR(secgpio_dvs_class)) {
+		ret = PTR_ERR(secgpio_dvs_class);
+		pr_err("Failed to create class(secgpio_check_all)");
+		goto fail_out;
+	}
+
+	secgpio_dotest = device_create(secgpio_dvs_class,
+				NULL, 0, NULL, "secgpio_check_all");
+	if (IS_ERR(secgpio_dotest)) {
+		ret = PTR_ERR(secgpio_dotest);
+		pr_err("Failed to create device(secgpio_check_all)");
+		goto fail_out;
+	}
+	dev_set_drvdata(secgpio_dotest, gdvs);
+	gdvs_info = gdvs;
+
+	ret = sysfs_create_group(&secgpio_dotest->kobj,
+			&secgpio_dvs_attr_group);
+	if (ret) {
+		pr_err("Failed to create sysfs group");
+		goto fail_out;
+	}
+
+fail_out:
+	if (ret)
+		pr_err(" (err = %d)!\n", ret);
+	return ret;
+
+}
+
+static int secgpio_dvs_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver secgpio_dvs = {
+	.probe = secgpio_dvs_probe,
+	.remove = secgpio_dvs_remove,
+	.driver = {
+		.name = "secgpio_dvs",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init secgpio_dvs_init(void)
+{
+	int ret;
+	ret = platform_driver_register(&secgpio_dvs);
+	pr_info("[secgpio_dvs] secgpio_dvs_init has been initialized!!!\n");
+	return ret;
+}
+
+static void __exit secgpio_dvs_exit(void)
+{
+	platform_driver_unregister(&secgpio_dvs);
+}
+
+module_init(secgpio_dvs_init);
+module_exit(secgpio_dvs_exit);
+
+MODULE_AUTHOR("intae.jun@samsung.com");
+MODULE_DESCRIPTION("BCM2165x GPIO debugging and verification");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/Makefile b/drivers/gpu/Makefile
index cc927788..ca2d3b34 100644
--- a/drivers/gpu/Makefile
+++ b/drivers/gpu/Makefile
@@ -1 +1 @@
-obj-y			+= drm/ vga/ stub/
+obj-y			+= drm/ vga/ stub/ ion/
diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index e354bc0b..47a415b9 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -179,6 +179,13 @@ config DRM_SAVAGE
 	  Choose this option if you have a Savage3D/4/SuperSavage/Pro/Twister
 	  chipset. If M is selected the module will be called savage.
 
+config DRM_VIVANTE
+	tristate "Vivante GCCore"
+	depends on DRM
+	help
+	  Choose this option if you have a Vivante graphics card.
+	  If M is selected, the module will be called vivante.
+
 source "drivers/gpu/drm/exynos/Kconfig"
 
 source "drivers/gpu/drm/vmwgfx/Kconfig"
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index c20da5bd..94b2d0c7 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_DRM)	+= drm.o
 obj-$(CONFIG_DRM_USB)   += drm_usb.o
 obj-$(CONFIG_DRM_TTM)	+= ttm/
 obj-$(CONFIG_DRM_TDFX)	+= tdfx/
+#obj-$(CONFIG_DRM_VIVANTE) += vivante/
 obj-$(CONFIG_DRM_R128)	+= r128/
 obj-$(CONFIG_DRM_RADEON)+= radeon/
 obj-$(CONFIG_DRM_MGA)	+= mga/
diff --git a/drivers/gpu/ion/Kconfig b/drivers/gpu/ion/Kconfig
new file mode 100644
index 00000000..d20f125a
--- /dev/null
+++ b/drivers/gpu/ion/Kconfig
@@ -0,0 +1,19 @@
+menuconfig ION
+	tristate "Ion Memory Manager"
+	select GENERIC_ALLOCATOR
+	select DMA_SHARED_BUFFER
+	help
+	  Chose this option to enable the ION Memory Manager.
+
+config ION_TEGRA
+	tristate "Ion for Tegra"
+	depends on ARCH_TEGRA && ION
+	help
+	  Choose this option if you wish to use ion on an nVidia Tegra.
+
+config ION_PXA
+       tristate "ION for PXA"
+       depends on ION && (ARCH_PXA || ARCH_MMP)
+       default y
+       help
+         Choose this option to enable ION on PXA.
diff --git a/drivers/gpu/ion/Makefile b/drivers/gpu/ion/Makefile
new file mode 100644
index 00000000..28d20c1a
--- /dev/null
+++ b/drivers/gpu/ion/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_ION) +=	ion.o ion_heap.o ion_page_pool.o ion_system_heap.o \
+			ion_carveout_heap.o
+#obj-$(CONFIG_ION_TEGRA) += tegra/
+obj-$(CONFIG_ION_PXA)  += pxa/
diff --git a/drivers/gpu/ion/ion.c b/drivers/gpu/ion/ion.c
new file mode 100644
index 00000000..e8f1cd69
--- /dev/null
+++ b/drivers/gpu/ion/ion.c
@@ -0,0 +1,1526 @@
+/*
+ * drivers/gpu/ion/ion.c
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/anon_inodes.h>
+#include <linux/ion.h>
+#include <linux/list.h>
+#include <linux/pxa_ion.h>
+#include <linux/memblock.h>
+#include <linux/miscdevice.h>
+#include <linux/export.h>
+#include <linux/mm.h>
+#include <linux/mm_types.h>
+#include <linux/rbtree.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include <linux/debugfs.h>
+#include <linux/dma-buf.h>
+#include <linux/oom.h>
+#include <linux/delay.h>
+
+#include "ion_priv.h"
+
+/**
+ * struct ion_device - the metadata of the ion device node
+ * @dev:		the actual misc device
+ * @buffers:	an rb tree of all the existing buffers
+ * @lock:		lock protecting the buffers & heaps trees
+ * @heaps:		list of all the heaps in the system
+ * @user_clients:	list of all the clients created from userspace
+ */
+struct ion_device {
+	struct miscdevice dev;
+	struct rb_root buffers;
+	struct mutex lock;
+	struct rb_root heaps;
+	long (*custom_ioctl) (struct ion_client *client, unsigned int cmd,
+			      unsigned long arg);
+	struct rb_root clients;
+	struct dentry *debug_root;
+};
+
+/**
+ * struct ion_client - a process/hw block local address space
+ * @node:		node in the tree of all clients
+ * @dev:		backpointer to ion device
+ * @handles:		an rb tree of all the handles in this client
+ * @lock:		lock protecting the tree of handles
+ * @heap_mask:		mask of all supported heaps
+ * @name:		used for debugging
+ * @task:		used for debugging
+ *
+ * A client represents a list of buffers this client may access.
+ * The mutex stored here is used to protect both handles tree
+ * as well as the handles themselves, and should be held while modifying either.
+ */
+struct ion_client {
+	struct rb_node node;
+	struct ion_device *dev;
+	struct rb_root handles;
+	struct mutex lock;
+	unsigned int heap_mask;
+	const char *name;
+	struct task_struct *task;
+	pid_t pid;
+	struct dentry *debug_root;
+};
+
+/**
+ * ion_handle - a client local reference to a buffer
+ * @ref:		reference count
+ * @client:		back pointer to the client the buffer resides in
+ * @buffer:		pointer to the buffer
+ * @node:		node in the client's handle rbtree
+ * @kmap_cnt:		count of times this client has mapped to kernel
+ * @task:		used for debugging and oom
+ * @pid:		used for debugging and oom
+ *
+ * Modifications to node, map_cnt or mapping should be protected by the
+ * lock in the client.  Other fields are never changed after initialization.
+ */
+struct ion_handle {
+	struct kref ref;
+	struct ion_client *client;
+	struct ion_buffer *buffer;
+	struct rb_node node;
+	unsigned int kmap_cnt;
+	struct task_struct *task;
+	pid_t pid;
+};
+
+struct ion_vma_list {
+	struct list_head list;
+	struct vm_area_struct *vma;
+};
+
+bool ion_buffer_fault_user_mappings(struct ion_buffer *buffer)
+{
+        return ((buffer->flags & ION_FLAG_CACHED) &&
+                !(buffer->flags & ION_FLAG_CACHED_NEEDS_SYNC));
+}
+
+bool ion_buffer_cached(struct ion_buffer *buffer)
+{
+        return !!(buffer->flags & ION_FLAG_CACHED);
+}
+
+/* this function should only be called while dev->lock is held */
+static void ion_buffer_add(struct ion_device *dev,
+			   struct ion_buffer *buffer)
+{
+	struct rb_node **p = &dev->buffers.rb_node;
+	struct rb_node *parent = NULL;
+	struct ion_buffer *entry;
+
+	while (*p) {
+		parent = *p;
+		entry = rb_entry(parent, struct ion_buffer, node);
+
+		if (buffer < entry) {
+			p = &(*p)->rb_left;
+		} else if (buffer > entry) {
+			p = &(*p)->rb_right;
+		} else {
+			pr_err("%s: buffer already found.", __func__);
+			BUG();
+		}
+	}
+
+	rb_link_node(&buffer->node, parent, p);
+	rb_insert_color(&buffer->node, &dev->buffers);
+}
+
+static int ion_buffer_alloc_dirty(struct ion_buffer *buffer);
+
+/* this function should only be called while dev->lock is held */
+static struct ion_buffer *ion_buffer_create(struct ion_heap *heap,
+				     struct ion_device *dev,
+				     unsigned long len,
+				     unsigned long align,
+				     unsigned long flags)
+{
+	struct ion_buffer *buffer;
+	struct sg_table *table;
+	struct scatterlist *sg;
+	int i, ret;
+
+	buffer = kzalloc(sizeof(struct ion_buffer), GFP_KERNEL);
+	if (!buffer)
+		return ERR_PTR(-ENOMEM);
+
+	buffer->heap = heap;
+	buffer->flags = flags;
+	kref_init(&buffer->ref);
+
+	ret = heap->ops->allocate(heap, buffer, len, align, flags);
+	if (ret) {
+		kfree(buffer);
+		return ERR_PTR(ret);
+	}
+
+	buffer->dev = dev;
+	buffer->size = len;
+
+	table = heap->ops->map_dma(heap, buffer);
+	if (IS_ERR_OR_NULL(table)) {
+		heap->ops->free(buffer);
+		kfree(buffer);
+		return ERR_PTR(PTR_ERR(table));
+	}
+	buffer->sg_table = table;
+	if (ion_buffer_fault_user_mappings(buffer)) {
+		for_each_sg(buffer->sg_table->sgl, sg, buffer->sg_table->nents,
+			    i) {
+			if (sg_dma_len(sg) == PAGE_SIZE)
+				continue;
+			pr_err("%s: cached mappings that will be faulted in "
+			       "must have pagewise sg_lists\n", __func__);
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ret = ion_buffer_alloc_dirty(buffer);
+		if (ret)
+			goto err;
+	}
+
+	buffer->pid = task_pid_nr(current->group_leader);
+	buffer->dev = dev;
+	buffer->size = len;
+	INIT_LIST_HEAD(&buffer->vmas);
+	mutex_init(&buffer->lock);
+	/* this will set up dma addresses for the sglist -- it is not
+	   technically correct as per the dma api -- a specific
+	   device isn't really taking ownership here.  However, in practice on
+	   our systems the only dma_address space is physical addresses.
+	   Additionally, we can't afford the overhead of invalidating every
+	   allocation via dma_map_sg. The implicit contract here is that
+	   memory comming from the heaps is ready for dma, ie if it has a
+	   cached mapping that mapping has been invalidated */
+	for_each_sg(buffer->sg_table->sgl, sg, buffer->sg_table->nents, i)
+		sg_dma_address(sg) = sg_phys(sg);
+	ion_buffer_add(dev, buffer);
+	return buffer;
+
+err:
+	heap->ops->unmap_dma(heap, buffer);
+	heap->ops->free(buffer);
+	kfree(buffer);
+	return ERR_PTR(ret);
+}
+
+static void ion_buffer_destroy(struct kref *kref)
+{
+	struct ion_buffer *buffer = container_of(kref, struct ion_buffer, ref);
+	struct ion_device *dev = buffer->dev;
+	struct ion_vma_list *vma_list, *tmp;
+
+	/* remove the vmas that won't be used */
+	mutex_lock(&buffer->lock);
+	list_for_each_entry_safe(vma_list, tmp, &buffer->vmas, list) {
+		list_del(&vma_list->list);
+		kfree(vma_list);
+	}
+	mutex_unlock(&buffer->lock);
+
+	if (WARN_ON(buffer->kmap_cnt > 0))
+		buffer->heap->ops->unmap_kernel(buffer->heap, buffer);
+	buffer->heap->ops->unmap_dma(buffer->heap, buffer);
+	buffer->heap->ops->free(buffer);
+	mutex_lock(&dev->lock);
+	rb_erase(&buffer->node, &dev->buffers);
+	mutex_unlock(&dev->lock);
+	if (buffer->flags & ION_FLAG_CACHED)
+		kfree(buffer->dirty);
+	kfree(buffer);
+}
+
+static void ion_buffer_get(struct ion_buffer *buffer)
+{
+	kref_get(&buffer->ref);
+}
+
+static int ion_buffer_put(struct ion_buffer *buffer)
+{
+	return kref_put(&buffer->ref, ion_buffer_destroy);
+}
+
+static void ion_buffer_add_to_handle(struct ion_buffer *buffer)
+{
+	mutex_lock(&buffer->dev->lock);
+	buffer->handle_count++;
+	mutex_unlock(&buffer->dev->lock);
+}
+
+static void ion_buffer_remove_from_handle(struct ion_buffer *buffer)
+{
+	/*
+	 * when a buffer is removed from a handle, if it is not in
+	 * any other handles, copy the taskcomm and the pid of the
+	 * process it's being removed from into the buffer.  At this
+	 * point there will be no way to track what processes this buffer is
+	 * being used by, it only exists as a dma_buf file descriptor.
+	 * The taskcomm and pid can provide a debug hint as to where this fd
+	 * is in the system
+	 */
+	mutex_lock(&buffer->dev->lock);
+	buffer->handle_count--;
+	BUG_ON(buffer->handle_count < 0);
+	if (!buffer->handle_count) {
+		struct task_struct *task;
+
+		task = current->group_leader;
+		get_task_comm(buffer->task_comm, task);
+		buffer->pid = task_pid_nr(task);
+	}
+	mutex_unlock(&buffer->dev->lock);
+}
+
+static struct ion_handle *ion_handle_create(struct ion_client *client,
+				     struct ion_buffer *buffer)
+{
+	struct ion_handle *handle;
+
+	handle = kzalloc(sizeof(struct ion_handle), GFP_KERNEL);
+	if (!handle)
+		return ERR_PTR(-ENOMEM);
+	kref_init(&handle->ref);
+	rb_init_node(&handle->node);
+	handle->client = client;
+	ion_buffer_get(buffer);
+	ion_buffer_add_to_handle(buffer);
+	handle->buffer = buffer;
+	handle->task = current->group_leader;
+	handle->pid = task_pid_nr(handle->task);
+
+	return handle;
+}
+
+static void ion_handle_kmap_put(struct ion_handle *);
+
+static void ion_handle_destroy(struct kref *kref)
+{
+	struct ion_handle *handle = container_of(kref, struct ion_handle, ref);
+	struct ion_client *client = handle->client;
+	struct ion_buffer *buffer = handle->buffer;
+
+	mutex_lock(&buffer->lock);
+	while (handle->kmap_cnt)
+		ion_handle_kmap_put(handle);
+	mutex_unlock(&buffer->lock);
+
+	if (!RB_EMPTY_NODE(&handle->node))
+		rb_erase(&handle->node, &client->handles);
+
+	ion_buffer_remove_from_handle(buffer);
+	ion_buffer_put(buffer);
+
+	kfree(handle);
+}
+
+struct ion_buffer *ion_handle_buffer(struct ion_handle *handle)
+{
+	return handle->buffer;
+}
+
+static void ion_handle_get(struct ion_handle *handle)
+{
+	kref_get(&handle->ref);
+}
+
+static int ion_handle_put(struct ion_handle *handle)
+{
+	return kref_put(&handle->ref, ion_handle_destroy);
+}
+
+static struct ion_handle *ion_handle_lookup(struct ion_client *client,
+					    struct ion_buffer *buffer)
+{
+	struct rb_node *n;
+
+	for (n = rb_first(&client->handles); n; n = rb_next(n)) {
+		struct ion_handle *handle = rb_entry(n, struct ion_handle,
+						     node);
+		if (handle->buffer == buffer)
+			return handle;
+	}
+	return NULL;
+}
+
+bool ion_handle_validate(struct ion_client *client, struct ion_handle *handle)
+{
+	struct rb_node *n = client->handles.rb_node;
+
+	while (n) {
+		struct ion_handle *handle_node = rb_entry(n, struct ion_handle,
+							  node);
+		if (handle < handle_node)
+			n = n->rb_left;
+		else if (handle > handle_node)
+			n = n->rb_right;
+		else
+			return true;
+	}
+	return false;
+}
+
+static void ion_handle_add(struct ion_client *client, struct ion_handle *handle)
+{
+	struct rb_node **p = &client->handles.rb_node;
+	struct rb_node *parent = NULL;
+	struct ion_handle *entry;
+
+	while (*p) {
+		parent = *p;
+		entry = rb_entry(parent, struct ion_handle, node);
+
+		if (handle < entry)
+			p = &(*p)->rb_left;
+		else if (handle > entry)
+			p = &(*p)->rb_right;
+		else
+			WARN(1, "%s: buffer already found.", __func__);
+	}
+
+	rb_link_node(&handle->node, parent, p);
+	rb_insert_color(&handle->node, &client->handles);
+}
+
+static int ion_shrink(struct ion_heap *heap, int kill_adj);
+
+struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
+			     size_t align, unsigned int heap_mask,
+			     unsigned int flags)
+{
+	struct rb_node *n;
+	struct ion_handle *handle;
+	struct ion_device *dev = client->dev;
+	struct ion_buffer *buffer = NULL;
+	struct ion_heap *heap_found = NULL;
+
+	pr_debug("%s: len %d align %d heap_mask %u flags %x\n", __func__, len,
+		 align, heap_mask, flags);
+	/*
+	 * traverse the list of heaps available in this system in priority
+	 * order.  If the heap type is supported by the client, and matches the
+	 * request of the caller allocate from it.  Repeat until allocate has
+	 * succeeded or all heaps have been tried
+	 */
+	if (WARN_ON(!len))
+		return ERR_PTR(-EINVAL);
+
+	len = PAGE_ALIGN(len);
+
+retry:
+	mutex_lock(&dev->lock);
+	for (n = rb_first(&dev->heaps); n != NULL; n = rb_next(n)) {
+		struct ion_heap *heap = rb_entry(n, struct ion_heap, node);
+		/* if the client doesn't support this heap type */
+		if (!((1 << heap->type) & client->heap_mask))
+			continue;
+		/* if the caller didn't specify this heap type */
+		if (!((1 << heap->id) & heap_mask))
+			continue;
+		heap_found = heap;
+		buffer = ion_buffer_create(heap, dev, len, align, flags);
+		if (!IS_ERR_OR_NULL(buffer))
+			break;
+	}
+	mutex_unlock(&dev->lock);
+
+	if ((buffer == ERR_PTR(-ENOMEM) && heap_found)) {
+		if (!ion_shrink(heap_found, 0))
+			goto retry;
+	}
+
+	if (buffer == NULL)
+		return ERR_PTR(-ENODEV);
+
+	if (IS_ERR(buffer))
+		return ERR_PTR(PTR_ERR(buffer));
+
+	handle = ion_handle_create(client, buffer);
+
+	if (!ion_buffer_cached(buffer)) {
+		struct scatterlist *sg;
+		int i;
+
+		mutex_lock(&buffer->lock);
+		for_each_sg(buffer->sg_table->sgl, sg,
+			buffer->sg_table->nents, i) {
+			dma_sync_sg_for_device(NULL, sg, 1, DMA_BIDIRECTIONAL);
+		}
+		mutex_unlock(&buffer->lock);
+	}
+
+	/*
+	 * ion_buffer_create will create a buffer with a ref_cnt of 1,
+	 * and ion_handle_create will take a second reference, drop one here
+	 */
+	ion_buffer_put(buffer);
+
+	if (!IS_ERR(handle)) {
+		mutex_lock(&client->lock);
+		ion_handle_add(client, handle);
+		mutex_unlock(&client->lock);
+	}
+
+
+	return handle;
+}
+EXPORT_SYMBOL(ion_alloc);
+
+void ion_free(struct ion_client *client, struct ion_handle *handle)
+{
+	bool valid_handle;
+
+	BUG_ON(client != handle->client);
+
+	mutex_lock(&client->lock);
+	valid_handle = ion_handle_validate(client, handle);
+
+	if (!valid_handle) {
+		WARN(1, "%s: invalid handle passed to free.\n", __func__);
+		mutex_unlock(&client->lock);
+		return;
+	}
+	ion_handle_put(handle);
+	mutex_unlock(&client->lock);
+}
+EXPORT_SYMBOL(ion_free);
+
+int ion_phys(struct ion_client *client, struct ion_handle *handle,
+	     ion_phys_addr_t *addr, size_t *len)
+{
+	struct ion_buffer *buffer;
+	int ret;
+
+	mutex_lock(&client->lock);
+	if (!ion_handle_validate(client, handle)) {
+		mutex_unlock(&client->lock);
+		return -EINVAL;
+	}
+
+	buffer = handle->buffer;
+
+	if (!buffer->heap->ops->phys) {
+		pr_err("%s: ion_phys is not implemented by this heap.\n",
+		       __func__);
+		mutex_unlock(&client->lock);
+		return -ENODEV;
+	}
+	mutex_unlock(&client->lock);
+	ret = buffer->heap->ops->phys(buffer->heap, buffer, addr, len);
+	return ret;
+}
+EXPORT_SYMBOL(ion_phys);
+
+static void *ion_buffer_kmap_get(struct ion_buffer *buffer)
+{
+	void *vaddr;
+
+	if (buffer->kmap_cnt) {
+		buffer->kmap_cnt++;
+		return buffer->vaddr;
+	}
+	vaddr = buffer->heap->ops->map_kernel(buffer->heap, buffer);
+	if (IS_ERR_OR_NULL(vaddr))
+		return vaddr;
+	buffer->vaddr = vaddr;
+	buffer->kmap_cnt++;
+	return vaddr;
+}
+
+static void *ion_handle_kmap_get(struct ion_handle *handle)
+{
+	struct ion_buffer *buffer = handle->buffer;
+	void *vaddr;
+
+	if (handle->kmap_cnt) {
+		handle->kmap_cnt++;
+		return buffer->vaddr;
+	}
+	vaddr = ion_buffer_kmap_get(buffer);
+	if (IS_ERR_OR_NULL(vaddr))
+		return vaddr;
+	handle->kmap_cnt++;
+	return vaddr;
+}
+
+static void ion_buffer_kmap_put(struct ion_buffer *buffer)
+{
+	buffer->kmap_cnt--;
+	if (!buffer->kmap_cnt) {
+		buffer->heap->ops->unmap_kernel(buffer->heap, buffer);
+		buffer->vaddr = NULL;
+	}
+}
+
+static void ion_handle_kmap_put(struct ion_handle *handle)
+{
+	struct ion_buffer *buffer = handle->buffer;
+
+	handle->kmap_cnt--;
+	if (!handle->kmap_cnt)
+		ion_buffer_kmap_put(buffer);
+}
+
+void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle)
+{
+	struct ion_buffer *buffer;
+	void *vaddr;
+
+	mutex_lock(&client->lock);
+	if (!ion_handle_validate(client, handle)) {
+		pr_err("%s: invalid handle passed to map_kernel.\n",
+		       __func__);
+		mutex_unlock(&client->lock);
+		return ERR_PTR(-EINVAL);
+	}
+
+	buffer = handle->buffer;
+
+	if (!handle->buffer->heap->ops->map_kernel) {
+		pr_err("%s: map_kernel is not implemented by this heap.\n",
+		       __func__);
+		mutex_unlock(&client->lock);
+		return ERR_PTR(-ENODEV);
+	}
+
+	mutex_lock(&buffer->lock);
+	vaddr = ion_handle_kmap_get(handle);
+	mutex_unlock(&buffer->lock);
+	mutex_unlock(&client->lock);
+	return vaddr;
+}
+EXPORT_SYMBOL(ion_map_kernel);
+
+void ion_unmap_kernel(struct ion_client *client, struct ion_handle *handle)
+{
+	struct ion_buffer *buffer;
+
+	mutex_lock(&client->lock);
+	buffer = handle->buffer;
+	mutex_lock(&buffer->lock);
+	ion_handle_kmap_put(handle);
+	mutex_unlock(&buffer->lock);
+	mutex_unlock(&client->lock);
+}
+EXPORT_SYMBOL(ion_unmap_kernel);
+
+static int ion_debug_client_show(struct seq_file *s, void *unused)
+{
+	struct ion_client *client = s->private;
+	struct rb_node *n;
+	size_t sizes[ION_NUM_HEAPS] = {0};
+	const char *names[ION_NUM_HEAPS] = {0};
+	int i;
+
+	mutex_lock(&client->lock);
+	for (n = rb_first(&client->handles); n; n = rb_next(n)) {
+		struct ion_handle *handle = rb_entry(n, struct ion_handle,
+						     node);
+		enum ion_heap_type type = handle->buffer->heap->type;
+
+		if (!names[type])
+			names[type] = handle->buffer->heap->name;
+		sizes[type] += handle->buffer->size;
+	}
+	mutex_unlock(&client->lock);
+
+	seq_printf(s, "%16.16s: %16.16s\n", "heap_name", "size_in_bytes");
+	for (i = 0; i < ION_NUM_HEAPS; i++) {
+		if (!names[i])
+			continue;
+		seq_printf(s, "%16.16s: %16u\n", names[i], sizes[i]);
+	}
+	return 0;
+}
+
+static int ion_debug_client_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ion_debug_client_show, inode->i_private);
+}
+
+static const struct file_operations debug_client_fops = {
+	.open = ion_debug_client_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+struct ion_client *ion_client_create(struct ion_device *dev,
+				     unsigned int heap_mask,
+				     const char *name)
+{
+	struct ion_client *client;
+	struct task_struct *task;
+	struct rb_node **p;
+	struct rb_node *parent = NULL;
+	struct ion_client *entry;
+	char debug_name[64];
+	pid_t pid;
+
+	get_task_struct(current->group_leader);
+	task_lock(current->group_leader);
+	pid = task_pid_nr(current->group_leader);
+	/* don't bother to store task struct for kernel threads,
+	   they can't be killed anyway */
+	if (current->group_leader->flags & PF_KTHREAD) {
+		put_task_struct(current->group_leader);
+		task = NULL;
+	} else {
+		task = current->group_leader;
+	}
+	task_unlock(current->group_leader);
+
+	client = kzalloc(sizeof(struct ion_client), GFP_KERNEL);
+	if (!client) {
+		if (task)
+			put_task_struct(current->group_leader);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	client->dev = dev;
+	client->handles = RB_ROOT;
+	mutex_init(&client->lock);
+	client->name = name;
+	client->heap_mask = heap_mask;
+	client->task = task;
+	client->pid = pid;
+
+	mutex_lock(&dev->lock);
+	p = &dev->clients.rb_node;
+	while (*p) {
+		parent = *p;
+		entry = rb_entry(parent, struct ion_client, node);
+
+		if (client < entry)
+			p = &(*p)->rb_left;
+		else if (client > entry)
+			p = &(*p)->rb_right;
+	}
+	rb_link_node(&client->node, parent, p);
+	rb_insert_color(&client->node, &dev->clients);
+
+	snprintf(debug_name, 64, "%u", client->pid);
+	client->debug_root = debugfs_create_file(debug_name, 0664,
+						 dev->debug_root, client,
+						 &debug_client_fops);
+	mutex_unlock(&dev->lock);
+
+	return client;
+}
+EXPORT_SYMBOL(ion_client_create);
+
+void ion_client_destroy(struct ion_client *client)
+{
+	struct ion_device *dev = client->dev;
+	struct rb_node *n;
+
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	while ((n = rb_first(&client->handles))) {
+		struct ion_handle *handle = rb_entry(n, struct ion_handle,
+						     node);
+		ion_handle_destroy(&handle->ref);
+	}
+	mutex_lock(&dev->lock);
+	if (client->task)
+		put_task_struct(client->task);
+	rb_erase(&client->node, &dev->clients);
+	debugfs_remove_recursive(client->debug_root);
+	mutex_unlock(&dev->lock);
+
+	kfree(client);
+}
+EXPORT_SYMBOL(ion_client_destroy);
+
+struct sg_table *ion_sg_table(struct ion_client *client,
+			      struct ion_handle *handle)
+{
+	struct ion_buffer *buffer;
+	struct sg_table *table;
+
+	mutex_lock(&client->lock);
+	if (!ion_handle_validate(client, handle)) {
+		pr_err("%s: invalid handle passed to map_dma.\n",
+		       __func__);
+		mutex_unlock(&client->lock);
+		return ERR_PTR(-EINVAL);
+	}
+	buffer = handle->buffer;
+	table = buffer->sg_table;
+	mutex_unlock(&client->lock);
+	return table;
+}
+EXPORT_SYMBOL(ion_sg_table);
+
+static void ion_buffer_sync_for_device(struct ion_buffer *buffer,
+				       struct device *dev,
+				       enum dma_data_direction direction);
+
+static struct sg_table *ion_map_dma_buf(struct dma_buf_attachment *attachment,
+					enum dma_data_direction direction)
+{
+	struct dma_buf *dmabuf = attachment->dmabuf;
+	struct ion_buffer *buffer = dmabuf->priv;
+
+	ion_buffer_sync_for_device(buffer, attachment->dev, direction);
+	return buffer->sg_table;
+}
+
+static void ion_unmap_dma_buf(struct dma_buf_attachment *attachment,
+			      struct sg_table *table,
+			      enum dma_data_direction direction)
+{
+}
+
+static int ion_buffer_alloc_dirty(struct ion_buffer *buffer)
+{
+	unsigned long pages = buffer->sg_table->nents;
+	unsigned long length = (pages + BITS_PER_LONG - 1)/BITS_PER_LONG;
+
+	buffer->dirty = kzalloc(length * sizeof(unsigned long), GFP_KERNEL);
+	if (!buffer->dirty)
+		return -ENOMEM;
+	return 0;
+}
+
+static void ion_buffer_sync_for_device(struct ion_buffer *buffer,
+				       struct device *dev,
+				       enum dma_data_direction dir)
+{
+	struct scatterlist *sg;
+	int i;
+	struct ion_vma_list *vma_list;
+
+	pr_debug("%s: syncing for device %s\n", __func__,
+		 dev ? dev_name(dev) : "null");
+
+	if (!ion_buffer_fault_user_mappings(buffer))
+		return;
+
+	mutex_lock(&buffer->lock);
+	for_each_sg(buffer->sg_table->sgl, sg, buffer->sg_table->nents, i) {
+		if (!test_bit(i, buffer->dirty))
+			continue;
+		dma_sync_sg_for_device(dev, sg, 1, dir);
+		clear_bit(i, buffer->dirty);
+	}
+	list_for_each_entry(vma_list, &buffer->vmas, list) {
+		struct vm_area_struct *vma = vma_list->vma;
+
+		zap_page_range(vma, vma->vm_start, vma->vm_end - vma->vm_start,
+			       NULL);
+	}
+	mutex_unlock(&buffer->lock);
+}
+
+/* in buffer->lock */
+struct vm_area_struct *pxa_ion_find_vma(struct ion_buffer *buffer)
+{
+	struct ion_vma_list *vma_list;
+
+	list_for_each_entry(vma_list, &buffer->vmas, list) {
+		struct vm_area_struct *vma = vma_list->vma;
+		if (vma->vm_mm == current->mm) {
+			return vma;
+		}
+	}
+	return NULL;
+}
+
+int ion_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	struct ion_buffer *buffer = vma->vm_private_data;
+	struct scatterlist *sg;
+	int i;
+
+	mutex_lock(&buffer->lock);
+	set_bit(vmf->pgoff, buffer->dirty);
+
+	for_each_sg(buffer->sg_table->sgl, sg, buffer->sg_table->nents, i) {
+		if (i != vmf->pgoff)
+			continue;
+		dma_sync_sg_for_cpu(NULL, sg, 1, DMA_BIDIRECTIONAL);
+		vm_insert_page(vma, (unsigned long)vmf->virtual_address,
+			       sg_page(sg));
+		break;
+	}
+	mutex_unlock(&buffer->lock);
+	return VM_FAULT_NOPAGE;
+}
+
+static void ion_vm_open(struct vm_area_struct *vma)
+{
+	struct ion_buffer *buffer = vma->vm_private_data;
+	struct ion_vma_list *vma_list;
+
+	vma_list = kmalloc(sizeof(struct ion_vma_list), GFP_KERNEL);
+	if (!vma_list)
+		return;
+	vma_list->vma = vma;
+	mutex_lock(&buffer->lock);
+	list_add(&vma_list->list, &buffer->vmas);
+	mutex_unlock(&buffer->lock);
+	pr_debug("%s: adding %p\n", __func__, vma);
+}
+
+static void ion_vm_close(struct vm_area_struct *vma)
+{
+	struct ion_buffer *buffer = vma->vm_private_data;
+	struct ion_vma_list *vma_list, *tmp;
+
+	pr_debug("%s\n", __func__);
+	mutex_lock(&buffer->lock);
+	list_for_each_entry_safe(vma_list, tmp, &buffer->vmas, list) {
+		if (vma_list->vma != vma)
+			continue;
+		list_del(&vma_list->list);
+		kfree(vma_list);
+		pr_debug("%s: deleting %p\n", __func__, vma);
+		break;
+	}
+	mutex_unlock(&buffer->lock);
+}
+
+struct vm_operations_struct ion_vma_ops = {
+	.open = ion_vm_open,
+	.close = ion_vm_close,
+	.fault = ion_vm_fault,
+};
+
+struct vm_operations_struct pxa_ion_vma_ops = {
+	.open = ion_vm_open,
+	.close = ion_vm_close,
+};
+
+static int ion_mmap(struct dma_buf *dmabuf, struct vm_area_struct *vma)
+{
+	struct ion_buffer *buffer = dmabuf->priv;
+	int ret = 0;
+
+	if (!buffer->heap->ops->map_user) {
+		pr_err("%s: this heap does not define a method for mapping "
+		       "to userspace\n", __func__);
+		return -EINVAL;
+	}
+
+	if (ion_buffer_fault_user_mappings(buffer)) {
+		vma->vm_private_data = buffer;
+		vma->vm_ops = &ion_vma_ops;
+		ion_vm_open(vma);
+		return 0;
+	}
+
+	if (!(buffer->flags & ION_FLAG_CACHED))
+		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+
+	mutex_lock(&buffer->lock);
+	/* now map it to userspace */
+	ret = buffer->heap->ops->map_user(buffer->heap, buffer, vma);
+	mutex_unlock(&buffer->lock);
+
+	/* set up the vma here, so that we can find it via pxa_ion_find_vma */
+	if ((buffer->flags & ION_FLAG_CACHED) &&
+		(buffer->flags & ION_FLAG_CACHED_NEEDS_SYNC)) {
+		vma->vm_private_data = buffer;
+		/* without vm fault hook */
+		vma->vm_ops = &pxa_ion_vma_ops;
+		ion_vm_open(vma);
+	}
+
+	if (ret)
+		pr_err("%s: failure mapping buffer to userspace\n",
+		       __func__);
+
+	return ret;
+}
+
+static void ion_dma_buf_release(struct dma_buf *dmabuf)
+{
+	struct ion_buffer *buffer = dmabuf->priv;
+	ion_buffer_put(buffer);
+}
+
+static void *ion_dma_buf_kmap(struct dma_buf *dmabuf, unsigned long offset)
+{
+	struct ion_buffer *buffer = dmabuf->priv;
+	return buffer->vaddr + offset * PAGE_SIZE;
+}
+
+static void ion_dma_buf_kunmap(struct dma_buf *dmabuf, unsigned long offset,
+			       void *ptr)
+{
+	return;
+}
+
+static int ion_dma_buf_begin_cpu_access(struct dma_buf *dmabuf, size_t start,
+					size_t len,
+					enum dma_data_direction direction)
+{
+	struct ion_buffer *buffer = dmabuf->priv;
+	void *vaddr;
+
+	if (!buffer->heap->ops->map_kernel) {
+		pr_err("%s: map kernel is not implemented by this heap.\n",
+		       __func__);
+		return -ENODEV;
+	}
+
+	mutex_lock(&buffer->lock);
+	vaddr = ion_buffer_kmap_get(buffer);
+	mutex_unlock(&buffer->lock);
+	if (IS_ERR(vaddr))
+		return PTR_ERR(vaddr);
+	if (!vaddr)
+		return -ENOMEM;
+	return 0;
+}
+
+static void ion_dma_buf_end_cpu_access(struct dma_buf *dmabuf, size_t start,
+				       size_t len,
+				       enum dma_data_direction direction)
+{
+	struct ion_buffer *buffer = dmabuf->priv;
+
+	mutex_lock(&buffer->lock);
+	ion_buffer_kmap_put(buffer);
+	mutex_unlock(&buffer->lock);
+}
+
+struct dma_buf_ops dma_buf_ops = {
+	.map_dma_buf = ion_map_dma_buf,
+	.unmap_dma_buf = ion_unmap_dma_buf,
+	.mmap = ion_mmap,
+	.release = ion_dma_buf_release,
+	.begin_cpu_access = ion_dma_buf_begin_cpu_access,
+	.end_cpu_access = ion_dma_buf_end_cpu_access,
+	.kmap_atomic = ion_dma_buf_kmap,
+	.kunmap_atomic = ion_dma_buf_kunmap,
+	.kmap = ion_dma_buf_kmap,
+	.kunmap = ion_dma_buf_kunmap,
+};
+
+int ion_share_dma_buf(struct ion_client *client, struct ion_handle *handle)
+{
+	struct ion_buffer *buffer;
+	struct dma_buf *dmabuf;
+	bool valid_handle;
+	int fd;
+
+	mutex_lock(&client->lock);
+	valid_handle = ion_handle_validate(client, handle);
+	mutex_unlock(&client->lock);
+	if (!valid_handle) {
+		WARN(1, "%s: invalid handle passed to share.\n", __func__);
+		return -EINVAL;
+	}
+
+	buffer = handle->buffer;
+	ion_buffer_get(buffer);
+	dmabuf = dma_buf_export(buffer, &dma_buf_ops, buffer->size, O_RDWR);
+	if (IS_ERR(dmabuf)) {
+		ion_buffer_put(buffer);
+		return PTR_ERR(dmabuf);
+	}
+	fd = dma_buf_fd(dmabuf, O_CLOEXEC);
+	if (fd < 0)
+		dma_buf_put(dmabuf);
+
+	return fd;
+}
+EXPORT_SYMBOL(ion_share_dma_buf);
+
+struct ion_handle *ion_import_dma_buf(struct ion_client *client, int fd)
+{
+	struct dma_buf *dmabuf;
+	struct ion_buffer *buffer;
+	struct ion_handle *handle;
+
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR_OR_NULL(dmabuf))
+		return ERR_PTR(PTR_ERR(dmabuf));
+	/* if this memory came from ion */
+
+	if (dmabuf->ops != &dma_buf_ops) {
+		pr_err("%s: can not import dmabuf from another exporter\n",
+		       __func__);
+		dma_buf_put(dmabuf);
+		return ERR_PTR(-EINVAL);
+	}
+	buffer = dmabuf->priv;
+
+	mutex_lock(&client->lock);
+	/* if a handle exists for this buffer just take a reference to it */
+	handle = ion_handle_lookup(client, buffer);
+	if (!IS_ERR_OR_NULL(handle)) {
+		ion_handle_get(handle);
+		goto end;
+	}
+	handle = ion_handle_create(client, buffer);
+	if (IS_ERR_OR_NULL(handle))
+		goto end;
+	ion_handle_add(client, handle);
+end:
+	mutex_unlock(&client->lock);
+	dma_buf_put(dmabuf);
+	return handle;
+}
+EXPORT_SYMBOL(ion_import_dma_buf);
+
+static int ion_sync_for_device(struct ion_client *client,
+			struct ion_pxa_cache_region *region)
+{
+	struct dma_buf *dmabuf;
+	struct ion_buffer *buffer;
+	int fd = region->fd;
+
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR_OR_NULL(dmabuf))
+		return PTR_ERR(dmabuf);
+
+	/* if this memory came from ion */
+	if (dmabuf->ops != &dma_buf_ops) {
+		pr_err("%s: can not sync dmabuf from another exporter\n",
+		       __func__);
+		dma_buf_put(dmabuf);
+		return -EINVAL;
+	}
+	buffer = dmabuf->priv;
+	dma_sync_sg_for_device(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, region->dir);
+	dma_buf_put(dmabuf);
+	return 0;
+}
+
+static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct ion_client *client = filp->private_data;
+
+	switch (cmd) {
+	case ION_IOC_ALLOC:
+	{
+		struct ion_allocation_data data;
+
+		if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
+			return -EFAULT;
+		data.handle = ion_alloc(client, data.len, data.align,
+					     data.heap_mask, data.flags);
+
+		if (IS_ERR(data.handle))
+			return PTR_ERR(data.handle);
+
+		if (copy_to_user((void __user *)arg, &data, sizeof(data))) {
+			ion_free(client, data.handle);
+			return -EFAULT;
+		}
+		break;
+	}
+	case ION_IOC_FREE:
+	{
+		struct ion_handle_data data;
+		bool valid;
+
+		if (copy_from_user(&data, (void __user *)arg,
+				   sizeof(struct ion_handle_data)))
+			return -EFAULT;
+		mutex_lock(&client->lock);
+		valid = ion_handle_validate(client, data.handle);
+		mutex_unlock(&client->lock);
+		if (!valid)
+			return -EINVAL;
+		ion_free(client, data.handle);
+		break;
+	}
+	case ION_IOC_SHARE:
+	{
+		struct ion_fd_data data;
+
+		if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
+			return -EFAULT;
+		data.fd = ion_share_dma_buf(client, data.handle);
+		if (copy_to_user((void __user *)arg, &data, sizeof(data)))
+			return -EFAULT;
+		if (data.fd < 0)
+			return data.fd;
+		break;
+	}
+	case ION_IOC_IMPORT:
+	{
+		struct ion_fd_data data;
+		int ret = 0;
+		if (copy_from_user(&data, (void __user *)arg,
+				   sizeof(struct ion_fd_data)))
+			return -EFAULT;
+		data.handle = ion_import_dma_buf(client, data.fd);
+		if (IS_ERR(data.handle)) {
+			ret = PTR_ERR(data.handle);
+			data.handle = NULL;
+		}
+		if (copy_to_user((void __user *)arg, &data,
+				 sizeof(struct ion_fd_data)))
+			return -EFAULT;
+		if (ret < 0)
+			return ret;
+		break;
+	}
+	case ION_IOC_SYNC:
+	{
+		struct ion_pxa_cache_region region;
+		if (copy_from_user(&region, (void __user *)arg,
+				   sizeof(struct ion_pxa_cache_region)))
+			return -EFAULT;
+		ion_sync_for_device(client, &region);
+		break;
+	}
+	case ION_IOC_CUSTOM:
+	{
+		struct ion_device *dev = client->dev;
+		struct ion_custom_data data;
+
+		if (!dev->custom_ioctl)
+			return -ENOTTY;
+		if (copy_from_user(&data, (void __user *)arg,
+				sizeof(struct ion_custom_data)))
+			return -EFAULT;
+		return dev->custom_ioctl(client, data.cmd, data.arg);
+	}
+	default:
+		return -ENOTTY;
+	}
+	return 0;
+}
+
+static int ion_release(struct inode *inode, struct file *file)
+{
+	struct ion_client *client = file->private_data;
+
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	ion_client_destroy(client);
+	return 0;
+}
+
+static int ion_open(struct inode *inode, struct file *file)
+{
+	struct miscdevice *miscdev = file->private_data;
+	struct ion_device *dev = container_of(miscdev, struct ion_device, dev);
+	struct ion_client *client;
+
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	client = ion_client_create(dev, -1, "user");
+	if (IS_ERR_OR_NULL(client))
+		return PTR_ERR(client);
+	file->private_data = client;
+
+	return 0;
+}
+
+static const struct file_operations ion_fops = {
+	.owner          = THIS_MODULE,
+	.open           = ion_open,
+	.release        = ion_release,
+	.unlocked_ioctl = ion_ioctl,
+};
+
+static size_t ion_debug_heap_total(struct ion_client *client,
+				   enum ion_heap_type type)
+{
+	size_t size = 0;
+	struct rb_node *n;
+
+	mutex_lock(&client->lock);
+	for (n = rb_first(&client->handles); n; n = rb_next(n)) {
+		struct ion_handle *handle = rb_entry(n,
+						     struct ion_handle,
+						     node);
+		if (handle->buffer->heap->type == type)
+			size += handle->buffer->size;
+	}
+	mutex_unlock(&client->lock);
+	return size;
+}
+
+static int ion_debug_heap_show(struct seq_file *s, void *unused)
+{
+	struct ion_heap *heap = s->private;
+	struct ion_device *dev = heap->dev;
+	struct rb_node *n;
+	size_t total_size = 0;
+	size_t total_orphaned_size = 0;
+
+	seq_printf(s, "%16.s %16.s %16.s %16.s\n",
+		"client", "pid", "size", "oom_score_adj");
+	seq_printf(s, "---------------------------------------------------\n");
+
+	/*
+	 * If pid is duplicate, it means that the same process opens
+	 * /dev/ion multiples.
+	 */
+	for (n = rb_first(&dev->clients); n; n = rb_next(n)) {
+		struct ion_client *client = rb_entry(n, struct ion_client,
+						     node);
+		size_t size = ion_debug_heap_total(client, heap->type);
+		if (!size)
+			continue;
+		if (client->task) {
+			char task_comm[TASK_COMM_LEN];
+
+			get_task_comm(task_comm, client->task);
+			seq_printf(s, "%16.s %16u %16u %16d\n", task_comm,
+				   client->pid, size,
+				   client->task->signal->oom_score_adj);
+		} else {
+			seq_printf(s, "%16.s %16u %16u\n", client->name,
+				   client->pid, size);
+		}
+	}
+	seq_printf(s, "----------------------------------------------------\n");
+	seq_printf(s, "orphaned allocations (info is from last known client):"
+		   "\n");
+	mutex_lock(&dev->lock);
+	for (n = rb_first(&dev->buffers); n; n = rb_next(n)) {
+		struct ion_buffer *buffer = rb_entry(n, struct ion_buffer,
+						     node);
+		if (buffer->heap->type != heap->type)
+			continue;
+		total_size += buffer->size;
+		if (!buffer->handle_count) {
+			seq_printf(s, "%16.s %16u %16u %d %d\n", buffer->task_comm,
+				buffer->pid, buffer->size, buffer->kmap_cnt,
+				atomic_read(&(&buffer->ref)->refcount));
+			total_orphaned_size += buffer->size;
+		}
+	}
+	mutex_unlock(&dev->lock);
+	seq_printf(s, "----------------------------------------------------\n");
+	seq_printf(s, "%16.s %16u\n", "total orphaned",
+		   total_orphaned_size);
+	seq_printf(s, "%16.s %16u\n", "total ", total_size);
+	seq_printf(s, "----------------------------------------------------\n");
+
+	if (heap->debug_show)
+		heap->debug_show(heap, s, unused);
+
+	seq_printf(s, "\n");
+	seq_printf(s, "%8.s %8.s %10.s %6.s %6.s %6.s %6.s %s\n",
+		"handle", "phy", "size", "flags", "cnt", "pid", "oom", "task");
+	for (n = rb_first(&dev->clients); n; n = rb_next(n)) {
+		struct ion_client *c;
+		struct rb_node *m;
+		c = rb_entry(n, struct ion_client, node);
+		for (m = rb_first(&c->handles); m; m = rb_next(m)) {
+			struct ion_handle *h;
+			h = rb_entry(m, struct ion_handle, node);
+			seq_printf(s,
+				"%08x %08x %10.d %6.lx %6.u %6.u %6.d %s\n",
+				(unsigned int)h,
+				(unsigned int)h->buffer->priv_phys,
+				h->buffer->size, h->buffer->flags,
+				h->buffer->handle_count, h->pid,
+				h->task->signal->oom_score_adj, h->task->comm);
+		}
+	}
+
+	seq_printf(s, "\n");
+	return 0;
+}
+
+static int ion_debug_heap_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ion_debug_heap_show, inode->i_private);
+}
+
+static ssize_t
+ion_debug_heap_write(struct file *file, const char __user *ubuf,
+					size_t count, loff_t *ppos)
+{
+	struct ion_heap *heap =
+		((struct seq_file *)file->private_data)->private;
+	char buf[16];
+	long kill_adj, ret;
+
+	memset(buf, 0, sizeof(buf));
+
+	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
+		return -EFAULT;
+
+	ret = kstrtol(buf, 10, &kill_adj);
+	if (ret)
+		return ret;
+
+	ion_shrink(heap, kill_adj);
+
+	return count;
+}
+static const struct file_operations debug_heap_fops = {
+	.open = ion_debug_heap_open,
+	.write = ion_debug_heap_write,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+/*
+ * ion_shrink
+ * kill all tasks referd the buffer by selected task
+ */
+static int ion_shrink(struct ion_heap *heap, int kill_adj)
+{
+	struct rb_node *n, *m;
+	struct ion_device *dev = heap->dev;
+	struct ion_client *c;
+	struct ion_handle *h;
+	struct task_struct *task_to_kill = NULL;
+	int score_max = 0;
+	pid_t pid_this, pid_to_kill = 0;
+
+	pid_this = task_pid_nr(current->group_leader);
+
+	for (n = rb_first(&dev->clients); n; n = rb_next(n)) {
+		c = rb_entry(n, struct ion_client, node);
+		for (m = rb_first(&c->handles); m; m = rb_next(m)) {
+			int score;
+			h = rb_entry(m, struct ion_handle, node);
+
+			if (!h->task || (h->pid == pid_this))
+				continue;
+			if (!find_task_by_vpid(h->pid))
+				continue;
+			if (h->buffer->heap->type != heap->type)
+				continue;
+			score = h->task->signal->oom_score_adj;
+			if (score <= kill_adj || score < score_max)
+				continue;
+			if (test_tsk_thread_flag(h->task, TIF_MEMDIE))
+				continue;
+
+			task_to_kill = h->task;
+			pid_to_kill = h->pid;
+			score_max = score;
+		}
+	}
+
+	if (task_to_kill) {
+		send_sig(SIGKILL, task_to_kill, 0);
+		set_tsk_thread_flag(task_to_kill, TIF_MEMDIE);
+		pr_info("SIGKILL pid: %u\n", pid_to_kill);
+		msleep(20);
+		return 0;
+	}
+
+	pr_info("no suitable task found to kill\n");
+	return -EAGAIN;
+}
+
+void ion_device_add_heap(struct ion_device *dev, struct ion_heap *heap)
+{
+	struct rb_node **p = &dev->heaps.rb_node;
+	struct rb_node *parent = NULL;
+	struct ion_heap *entry;
+
+	if (!heap->ops->allocate || !heap->ops->free || !heap->ops->map_dma ||
+	    !heap->ops->unmap_dma)
+		pr_err("%s: can not add heap with invalid ops struct.\n",
+		       __func__);
+
+	heap->dev = dev;
+	mutex_lock(&dev->lock);
+	while (*p) {
+		parent = *p;
+		entry = rb_entry(parent, struct ion_heap, node);
+
+		if (heap->id < entry->id) {
+			p = &(*p)->rb_left;
+		} else if (heap->id > entry->id ) {
+			p = &(*p)->rb_right;
+		} else {
+			pr_err("%s: can not insert multiple heaps with "
+				"id %d\n", __func__, heap->id);
+			goto end;
+		}
+	}
+
+	rb_link_node(&heap->node, parent, p);
+	rb_insert_color(&heap->node, &dev->heaps);
+	debugfs_create_file(heap->name, 0664, dev->debug_root, heap,
+			    &debug_heap_fops);
+end:
+	mutex_unlock(&dev->lock);
+}
+
+struct ion_device *ion_device_create(long (*custom_ioctl)
+				     (struct ion_client *client,
+				      unsigned int cmd,
+				      unsigned long arg))
+{
+	struct ion_device *idev;
+	int ret;
+
+	idev = kzalloc(sizeof(struct ion_device), GFP_KERNEL);
+	if (!idev)
+		return ERR_PTR(-ENOMEM);
+
+	idev->dev.minor = MISC_DYNAMIC_MINOR;
+	idev->dev.name = "ion";
+	idev->dev.fops = &ion_fops;
+	idev->dev.parent = NULL;
+	ret = misc_register(&idev->dev);
+	if (ret) {
+		pr_err("ion: failed to register misc device.\n");
+		return ERR_PTR(ret);
+	}
+
+	idev->debug_root = debugfs_create_dir("ion", NULL);
+	if (IS_ERR_OR_NULL(idev->debug_root))
+		pr_err("ion: failed to create debug files.\n");
+
+	idev->custom_ioctl = custom_ioctl;
+	idev->buffers = RB_ROOT;
+	mutex_init(&idev->lock);
+	idev->heaps = RB_ROOT;
+	idev->clients = RB_ROOT;
+	return idev;
+}
+
+void ion_device_destroy(struct ion_device *dev)
+{
+	misc_deregister(&dev->dev);
+	/* XXX need to free the heaps and clients ? */
+	kfree(dev);
+}
+
+void __init ion_reserve(struct ion_platform_data *data)
+{
+	int i, ret;
+
+	for (i = 0; i < data->nr; i++) {
+		if (data->heaps[i].size == 0)
+			continue;
+		ret = memblock_reserve(data->heaps[i].base,
+				       data->heaps[i].size);
+		if (ret)
+			pr_err("memblock reserve of %x@%lx failed\n",
+			       data->heaps[i].size,
+			       data->heaps[i].base);
+	}
+}
+
diff --git a/drivers/gpu/ion/ion_carveout_heap.c b/drivers/gpu/ion/ion_carveout_heap.c
new file mode 100644
index 00000000..45e02d00
--- /dev/null
+++ b/drivers/gpu/ion/ion_carveout_heap.c
@@ -0,0 +1,265 @@
+/*
+ * drivers/gpu/ion/ion_carveout_heap.c
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/spinlock.h>
+
+#include <linux/err.h>
+#include <linux/genalloc.h>
+#include <linux/io.h>
+#include <linux/ion.h>
+#include <linux/mm.h>
+#include <linux/scatterlist.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/dma-contiguous.h>
+#include "ion_priv.h"
+
+#include <asm/mach/map.h>
+
+#define ION_FLAG_CMA	(1 << 16)
+
+struct ion_carveout_heap {
+	struct ion_heap heap;
+	struct gen_pool *pool;
+	ion_phys_addr_t base;
+};
+
+ion_phys_addr_t ion_carveout_allocate(struct ion_heap *heap,
+				      unsigned long size,
+				      unsigned long align)
+{
+	struct ion_carveout_heap *carveout_heap =
+		container_of(heap, struct ion_carveout_heap, heap);
+	unsigned long offset = gen_pool_alloc(carveout_heap->pool, size);
+
+	if (!offset)
+		return ION_CARVEOUT_ALLOCATE_FAIL;
+
+	return offset;
+}
+
+void ion_carveout_free(struct ion_heap *heap, ion_phys_addr_t addr,
+		       unsigned long size)
+{
+	struct ion_carveout_heap *carveout_heap =
+		container_of(heap, struct ion_carveout_heap, heap);
+	if (addr == ION_CARVEOUT_ALLOCATE_FAIL)
+		return;
+	gen_pool_free(carveout_heap->pool, addr, size);
+}
+
+static int ion_carveout_heap_phys(struct ion_heap *heap,
+				  struct ion_buffer *buffer,
+				  ion_phys_addr_t *addr, size_t *len)
+{
+	*addr = buffer->priv_phys;
+	*len = buffer->size;
+	return 0;
+}
+
+static int ion_carveout_heap_allocate(struct ion_heap *heap,
+				      struct ion_buffer *buffer,
+				      unsigned long size, unsigned long align,
+				      unsigned long flags)
+{
+	struct page *page;
+	unsigned int alignfix = get_order(size);
+
+	buffer->priv_phys = ion_carveout_allocate(heap, size, align);
+	if (buffer->priv_phys != ION_CARVEOUT_ALLOCATE_FAIL) {
+		buffer->flags &= ~ION_FLAG_CMA;
+		return 0;
+	}
+
+	if (alignfix < get_order(align))
+		alignfix = get_order(align);
+
+	page = dma_alloc_from_contiguous(NULL, size >> PAGE_SHIFT, alignfix);
+
+	if (!page) {
+		buffer->priv_phys = ION_CARVEOUT_ALLOCATE_FAIL;
+		return -ENOMEM;
+	}
+
+	buffer->flags |= ION_FLAG_CMA;
+	buffer->priv_phys = page_to_phys(page);
+	return 0;
+}
+
+static void ion_carveout_heap_free(struct ion_buffer *buffer)
+{
+	struct ion_heap *heap = buffer->heap;
+
+	if (buffer->flags & ION_FLAG_CMA)
+		dma_release_from_contiguous(NULL,
+			phys_to_page(buffer->priv_phys),
+			buffer->size >> PAGE_SHIFT);
+	else
+		ion_carveout_free(heap, buffer->priv_phys, buffer->size);
+
+	buffer->priv_phys = ION_CARVEOUT_ALLOCATE_FAIL;
+}
+
+struct sg_table *ion_carveout_heap_map_dma(struct ion_heap *heap,
+					      struct ion_buffer *buffer)
+{
+	struct sg_table *table;
+	struct scatterlist *sg;
+	int ret, i;
+	int nents = PAGE_ALIGN(buffer->size) / PAGE_SIZE;
+	struct page *page = phys_to_page(buffer->priv_phys);
+
+	table = kzalloc(sizeof(struct sg_table), GFP_KERNEL);
+	if (!table)
+		return ERR_PTR(-ENOMEM);
+
+	ret = sg_alloc_table(table, nents, GFP_KERNEL);
+	if (ret) {
+		kfree(table);
+		return ERR_PTR(ret);
+	}
+
+	sg = table->sgl;
+	for (i = 0; i < nents; i++) {
+		sg_set_page(sg, page + i, PAGE_SIZE, 0);
+		sg = sg_next(sg);
+	}
+
+	return table;
+}
+
+void ion_carveout_heap_unmap_dma(struct ion_heap *heap,
+				 struct ion_buffer *buffer)
+{
+	if (buffer->sg_table)
+		sg_free_table(buffer->sg_table);
+	kfree(buffer->sg_table);
+}
+
+void *ion_carveout_heap_map_kernel(struct ion_heap *heap,
+				   struct ion_buffer *buffer)
+{
+	int mtype = MT_MEMORY_NONCACHED;
+
+	if (buffer->flags & ION_FLAG_CACHED)
+		mtype = MT_MEMORY;
+
+	return __arm_ioremap(buffer->priv_phys, buffer->size,
+			      mtype);
+}
+
+void ion_carveout_heap_unmap_kernel(struct ion_heap *heap,
+				    struct ion_buffer *buffer)
+{
+	__arm_iounmap(buffer->vaddr);
+	buffer->vaddr = NULL;
+	return;
+}
+
+int ion_carveout_heap_map_user(struct ion_heap *heap, struct ion_buffer *buffer,
+			       struct vm_area_struct *vma)
+{
+	return remap_pfn_range(vma, vma->vm_start,
+			       __phys_to_pfn(buffer->priv_phys) + vma->vm_pgoff,
+			       vma->vm_end - vma->vm_start,
+			       vma->vm_page_prot);
+}
+
+static struct ion_heap_ops carveout_heap_ops = {
+	.allocate = ion_carveout_heap_allocate,
+	.free = ion_carveout_heap_free,
+	.phys = ion_carveout_heap_phys,
+	.map_user = ion_carveout_heap_map_user,
+	.map_kernel = ion_carveout_heap_map_kernel,
+	.unmap_kernel = ion_carveout_heap_unmap_kernel,
+	.map_dma = ion_carveout_heap_map_dma,
+	.unmap_dma = ion_carveout_heap_unmap_dma,
+};
+
+void ion_carveout_heap_debug_show_chunk(struct gen_pool *pool,
+	struct gen_pool_chunk *chunk, void *data)
+{
+	struct seq_file *s = (struct seq_file *)data;
+	int order = pool->min_alloc_order;
+	unsigned long *map = chunk->bits;
+	unsigned long index, end, size, start;
+
+	size = (chunk->end_addr - chunk->start_addr) >> order;
+	start = 0;
+next:
+	index = find_next_zero_bit(map, size, start);
+	if (index >= size)
+		return;
+
+	end = find_next_bit(map, size, index + 1);
+	if (end >= size)
+		end = size;
+
+	seq_printf(s, "%08lx %12.lu\n",
+		chunk->start_addr + (index << order), (end - index) << order);
+	start = end;
+	if (start < size)
+		goto next;
+}
+
+static int ion_carveout_heap_debug_show(struct ion_heap *heap,
+	struct seq_file *s, void *unused)
+{
+	struct ion_carveout_heap *carveout_heap =
+		container_of(heap, struct ion_carveout_heap, heap);
+
+	seq_printf(s, "\ncarveout heap free list, avail: %u\n",
+		gen_pool_avail(carveout_heap->pool));
+
+	seq_printf(s, "%8.s %12.s\n", "phys", "size");
+	gen_pool_for_each_chunk(carveout_heap->pool,
+		ion_carveout_heap_debug_show_chunk, s);
+
+	return 0;
+}
+
+struct ion_heap *ion_carveout_heap_create(struct ion_platform_heap *heap_data)
+{
+	struct ion_carveout_heap *carveout_heap;
+
+	carveout_heap = kzalloc(sizeof(struct ion_carveout_heap), GFP_KERNEL);
+	if (!carveout_heap)
+		return ERR_PTR(-ENOMEM);
+
+	carveout_heap->pool = gen_pool_create(PAGE_SHIFT, -1);
+	if (!carveout_heap->pool) {
+		kfree(carveout_heap);
+		return ERR_PTR(-ENOMEM);
+	}
+	carveout_heap->base = heap_data->base;
+	gen_pool_add(carveout_heap->pool, carveout_heap->base, heap_data->size,
+		     -1);
+	carveout_heap->heap.ops = &carveout_heap_ops;
+	carveout_heap->heap.type = ION_HEAP_TYPE_CARVEOUT;
+	carveout_heap->heap.debug_show = ion_carveout_heap_debug_show;
+
+	return &carveout_heap->heap;
+}
+
+void ion_carveout_heap_destroy(struct ion_heap *heap)
+{
+	struct ion_carveout_heap *carveout_heap =
+	     container_of(heap, struct  ion_carveout_heap, heap);
+
+	gen_pool_destroy(carveout_heap->pool);
+	kfree(carveout_heap);
+	carveout_heap = NULL;
+}
diff --git a/drivers/gpu/ion/ion_heap.c b/drivers/gpu/ion/ion_heap.c
new file mode 100644
index 00000000..d5662e44
--- /dev/null
+++ b/drivers/gpu/ion/ion_heap.c
@@ -0,0 +1,73 @@
+/*
+ * drivers/gpu/ion/ion_heap.c
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/err.h>
+#include <linux/ion.h>
+#include "ion_priv.h"
+
+struct ion_heap *ion_heap_create(struct ion_platform_heap *heap_data)
+{
+	struct ion_heap *heap = NULL;
+
+	switch (heap_data->type) {
+	case ION_HEAP_TYPE_SYSTEM_CONTIG:
+		heap = ion_system_contig_heap_create(heap_data);
+		break;
+	case ION_HEAP_TYPE_SYSTEM:
+		heap = ion_system_heap_create(heap_data);
+		break;
+	case ION_HEAP_TYPE_CARVEOUT:
+		heap = ion_carveout_heap_create(heap_data);
+		break;
+	default:
+		pr_err("%s: Invalid heap type %d\n", __func__,
+		       heap_data->type);
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (IS_ERR_OR_NULL(heap)) {
+		pr_err("%s: error creating heap %s type %d base %lu size %u\n",
+		       __func__, heap_data->name, heap_data->type,
+		       heap_data->base, heap_data->size);
+		return ERR_PTR(-EINVAL);
+	}
+
+	heap->name = heap_data->name;
+	heap->id = heap_data->id;
+	heap->size = heap_data->size;
+	return heap;
+}
+
+void ion_heap_destroy(struct ion_heap *heap)
+{
+	if (!heap)
+		return;
+
+	switch (heap->type) {
+	case ION_HEAP_TYPE_SYSTEM_CONTIG:
+		ion_system_contig_heap_destroy(heap);
+		break;
+	case ION_HEAP_TYPE_SYSTEM:
+		ion_system_heap_destroy(heap);
+		break;
+	case ION_HEAP_TYPE_CARVEOUT:
+		ion_carveout_heap_destroy(heap);
+		break;
+	default:
+		pr_err("%s: Invalid heap type %d\n", __func__,
+		       heap->type);
+	}
+}
diff --git a/drivers/gpu/ion/ion_page_pool.c b/drivers/gpu/ion/ion_page_pool.c
new file mode 100644
index 00000000..f06a267e
--- /dev/null
+++ b/drivers/gpu/ion/ion_page_pool.c
@@ -0,0 +1,163 @@
+/*
+ * drivers/gpu/ion/ion_mem_pool.c
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/shrinker.h>
+#include "ion_priv.h"
+
+struct ion_page_pool_item {
+	struct page *page;
+	struct list_head list;
+};
+
+static void *ion_page_pool_alloc_pages(struct ion_page_pool *pool)
+{
+	struct page *page = alloc_pages(pool->gfp_mask, pool->order);
+
+	if (!page)
+		return NULL;
+	/* this is only being used to flush the page for dma,
+	   this api is not really suitable for calling from a driver
+	   but no better way to flush a page for dma exist at this time */
+	__dma_page_cpu_to_dev(page, 0, PAGE_SIZE << pool->order,
+			      DMA_BIDIRECTIONAL);
+	return page;
+}
+
+static void ion_page_pool_free_pages(struct ion_page_pool *pool,
+				     struct page *page)
+{
+	__free_pages(page, pool->order);
+}
+
+static int ion_page_pool_add(struct ion_page_pool *pool, struct page *page)
+{
+	struct ion_page_pool_item *item;
+
+	item = kmalloc(sizeof(struct ion_page_pool_item), GFP_KERNEL);
+	if (!item)
+		return -ENOMEM;
+	item->page = page;
+	list_add_tail(&item->list, &pool->items);
+	pool->count++;
+	return 0;
+}
+
+static struct page *ion_page_pool_remove(struct ion_page_pool *pool)
+{
+	struct ion_page_pool_item *item;
+	struct page *page;
+
+	BUG_ON(!pool->count);
+	BUG_ON(list_empty(&pool->items));
+
+	item = list_first_entry(&pool->items, struct ion_page_pool_item, list);
+	list_del(&item->list);
+	page = item->page;
+	kfree(item);
+	pool->count--;
+	return page;
+}
+
+void *ion_page_pool_alloc(struct ion_page_pool *pool)
+{
+	struct page *page = NULL;
+
+	BUG_ON(!pool);
+
+	mutex_lock(&pool->mutex);
+	if (pool->count)
+		page = ion_page_pool_remove(pool);
+	else
+		page = ion_page_pool_alloc_pages(pool);
+	mutex_unlock(&pool->mutex);
+
+	return page;
+}
+
+void ion_page_pool_free(struct ion_page_pool *pool, struct page* page)
+{
+	int ret;
+
+	mutex_lock(&pool->mutex);
+	ret = ion_page_pool_add(pool, page);
+	if (ret)
+		ion_page_pool_free_pages(pool, page);
+	mutex_unlock(&pool->mutex);
+}
+
+static int ion_page_pool_shrink(struct shrinker *shrinker,
+				 struct shrink_control *sc)
+{
+	struct ion_page_pool *pool = container_of(shrinker,
+						 struct ion_page_pool,
+						 shrinker);
+	int nr_freed = 0;
+	int i;
+
+	if (sc->nr_to_scan == 0)
+		return pool->count * (1 << pool->order);
+
+	mutex_lock(&pool->mutex);
+	for (i = 0; i < sc->nr_to_scan && pool->count; i++) {
+		struct ion_page_pool_item *item;
+		struct page *page;
+
+		item = list_first_entry(&pool->items, struct ion_page_pool_item, list);
+		page = item->page;
+		if (PageHighMem(page) && !(sc->gfp_mask & __GFP_HIGHMEM)) {
+			list_move_tail(&item->list, &pool->items);
+			continue;
+		}
+		BUG_ON(page != ion_page_pool_remove(pool));
+		ion_page_pool_free_pages(pool, page);
+		nr_freed += (1 << pool->order);
+	}
+	pr_info("%s: shrunk page_pool of order %d by %d pages\n", __func__,
+		pool->order, nr_freed);
+	mutex_unlock(&pool->mutex);
+
+	return pool->count * (1 << pool->order);
+}
+
+struct ion_page_pool *ion_page_pool_create(gfp_t gfp_mask, unsigned int order)
+{
+	struct ion_page_pool *pool = kmalloc(sizeof(struct ion_page_pool),
+					     GFP_KERNEL);
+	if (!pool)
+		return NULL;
+	pool->count = 0;
+	INIT_LIST_HEAD(&pool->items);
+	pool->shrinker.shrink = ion_page_pool_shrink;
+	pool->shrinker.seeks = DEFAULT_SEEKS * 16;
+	pool->shrinker.batch = 0;
+	register_shrinker(&pool->shrinker);
+	pool->gfp_mask = gfp_mask;
+	pool->order = order;
+	mutex_init(&pool->mutex);
+
+	return pool;
+}
+
+void ion_page_pool_destroy(struct ion_page_pool *pool)
+{
+	unregister_shrinker(&pool->shrinker);
+	kfree(pool);
+}
+
diff --git a/drivers/gpu/ion/ion_priv.h b/drivers/gpu/ion/ion_priv.h
new file mode 100644
index 00000000..63d5dbee
--- /dev/null
+++ b/drivers/gpu/ion/ion_priv.h
@@ -0,0 +1,253 @@
+/*
+ * drivers/gpu/ion/ion_priv.h
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _ION_PRIV_H
+#define _ION_PRIV_H
+
+#include <linux/ion.h>
+#include <linux/kref.h>
+#include <linux/mm_types.h>
+#include <linux/mutex.h>
+#include <linux/rbtree.h>
+#include <linux/sched.h>
+#include <linux/shrinker.h>
+#include <linux/types.h>
+
+struct ion_buffer *ion_handle_buffer(struct ion_handle *handle);
+
+/**
+ * struct ion_buffer - metadata for a particular buffer
+ * @ref:		refernce count
+ * @node:		node in the ion_device buffers tree
+ * @dev:		back pointer to the ion_device
+ * @heap:		back pointer to the heap the buffer came from
+ * @flags:		buffer specific flags
+ * @size:		size of the buffer
+ * @priv_virt:		private data to the buffer representable as
+ *			a void *
+ * @priv_phys:		private data to the buffer representable as
+ *			an ion_phys_addr_t (and someday a phys_addr_t)
+ * @lock:		protects the buffers cnt fields
+ * @kmap_cnt:		number of times the buffer is mapped to the kernel
+ * @vaddr:		the kenrel mapping if kmap_cnt is not zero
+ * @dmap_cnt:		number of times the buffer is mapped for dma
+ * @sg_table:		the sg table for the buffer if dmap_cnt is not zero
+ * @dirty:		bitmask representing which pages of this buffer have
+ *			been dirtied by the cpu and need cache maintenance
+ *			before dma
+ * @vmas:		list of vma's mapping this buffer
+ * @handle_count:	count of handles referencing this buffer
+ * @task_comm:		taskcomm of last client to reference this buffer in a
+ *			handle, used for debugging
+ * @pid:		pid of last client to reference this buffer in a
+ *			handle, used for debugging
+*/
+struct ion_buffer {
+	struct kref ref;
+	struct rb_node node;
+	struct ion_device *dev;
+	struct ion_heap *heap;
+	unsigned long flags;
+	size_t size;
+	union {
+		void *priv_virt;
+		ion_phys_addr_t priv_phys;
+	};
+	struct mutex lock;
+	int kmap_cnt;
+	void *vaddr;
+	int dmap_cnt;
+	struct sg_table *sg_table;
+	unsigned long *dirty;
+	struct list_head vmas;
+	/* used to track orphaned buffers */
+	int handle_count;
+	char task_comm[TASK_COMM_LEN];
+	pid_t pid;
+};
+
+/**
+ * struct ion_heap_ops - ops to operate on a given heap
+ * @allocate:		allocate memory
+ * @free:		free memory
+ * @phys		get physical address of a buffer (only define on
+ *			physically contiguous heaps)
+ * @map_dma		map the memory for dma to a scatterlist
+ * @unmap_dma		unmap the memory for dma
+ * @map_kernel		map memory to the kernel
+ * @unmap_kernel	unmap memory to the kernel
+ * @map_user		map memory to userspace
+ */
+struct ion_heap_ops {
+	int (*allocate) (struct ion_heap *heap,
+			 struct ion_buffer *buffer, unsigned long len,
+			 unsigned long align, unsigned long flags);
+	void (*free) (struct ion_buffer *buffer);
+	int (*phys) (struct ion_heap *heap, struct ion_buffer *buffer,
+		     ion_phys_addr_t *addr, size_t *len);
+	struct sg_table *(*map_dma) (struct ion_heap *heap,
+					struct ion_buffer *buffer);
+	void (*unmap_dma) (struct ion_heap *heap, struct ion_buffer *buffer);
+	void * (*map_kernel) (struct ion_heap *heap, struct ion_buffer *buffer);
+	void (*unmap_kernel) (struct ion_heap *heap, struct ion_buffer *buffer);
+	int (*map_user) (struct ion_heap *mapper, struct ion_buffer *buffer,
+			 struct vm_area_struct *vma);
+};
+
+/**
+ * struct ion_heap - represents a heap in the system
+ * @node:		rb node to put the heap on the device's tree of heaps
+ * @dev:		back pointer to the ion_device
+ * @type:		type of heap
+ * @ops:		ops struct as above
+ * @id:			id of heap, also indicates priority of this heap when
+ *			allocating.  These are specified by platform data and
+ *			MUST be unique
+ * @name:		used for debugging
+ * @debug_show:		called when heap debug file is read to add any
+ *			heap specific debug info to output
+ *
+ * Represents a pool of memory from which buffers can be made.  In some
+ * systems the only heap is regular system memory allocated via vmalloc.
+ * On others, some blocks might require large physically contiguous buffers
+ * that are allocated from a specially reserved heap.
+ */
+struct ion_heap {
+	struct rb_node node;
+	struct ion_device *dev;
+	enum ion_heap_type type;
+	struct ion_heap_ops *ops;
+	int id;
+	const char *name;
+	int (*debug_show)(struct ion_heap *heap, struct seq_file *, void *);
+	int size;
+};
+
+/**
+ * ion_buffer_cached - this ion buffer is cached
+ * @buffer:		buffer
+ *
+ * indicates whether this ion buffer is cached
+ */
+bool ion_buffer_cached(struct ion_buffer *buffer);
+
+/**
+ * ion_buffer_fault_user_mappings - fault in user mappings of this buffer
+ * @buffer:		buffer
+ *
+ * indicates whether userspace mappings of this buffer will be faulted
+ * in, this can affect how buffers are allocated from the heap.
+ */
+bool ion_buffer_fault_user_mappings(struct ion_buffer *buffer);
+
+/**
+ * ion_device_create - allocates and returns an ion device
+ * @custom_ioctl:	arch specific ioctl function if applicable
+ *
+ * returns a valid device or -PTR_ERR
+ */
+struct ion_device *ion_device_create(long (*custom_ioctl)
+				     (struct ion_client *client,
+				      unsigned int cmd,
+				      unsigned long arg));
+
+/**
+ * ion_device_destroy - free and device and it's resource
+ * @dev:		the device
+ */
+void ion_device_destroy(struct ion_device *dev);
+
+/**
+ * ion_device_add_heap - adds a heap to the ion device
+ * @dev:		the device
+ * @heap:		the heap to add
+ */
+void ion_device_add_heap(struct ion_device *dev, struct ion_heap *heap);
+
+/**
+ * functions for creating and destroying the built in ion heaps.
+ * architectures can add their own custom architecture specific
+ * heaps as appropriate.
+ */
+
+struct ion_heap *ion_heap_create(struct ion_platform_heap *);
+void ion_heap_destroy(struct ion_heap *);
+
+struct ion_heap *ion_system_heap_create(struct ion_platform_heap *);
+void ion_system_heap_destroy(struct ion_heap *);
+
+struct ion_heap *ion_system_contig_heap_create(struct ion_platform_heap *);
+void ion_system_contig_heap_destroy(struct ion_heap *);
+
+struct ion_heap *ion_carveout_heap_create(struct ion_platform_heap *);
+void ion_carveout_heap_destroy(struct ion_heap *);
+/**
+ * kernel api to allocate/free from carveout -- used when carveout is
+ * used to back an architecture specific custom heap
+ */
+ion_phys_addr_t ion_carveout_allocate(struct ion_heap *heap, unsigned long size,
+				      unsigned long align);
+void ion_carveout_free(struct ion_heap *heap, ion_phys_addr_t addr,
+		       unsigned long size);
+/**
+ * The carveout heap returns physical addresses, since 0 may be a valid
+ * physical address, this is used to indicate allocation failed
+ */
+#define ION_CARVEOUT_ALLOCATE_FAIL -1
+
+/**
+ * functions for creating and destroying a heap pool -- allows you
+ * to keep a pool of pre allocated memory to use from your heap.  Keeping
+ * a pool of memory that is ready for dma, ie any cached mapping have been
+ * invalidated from the cache, provides a significant peformance benefit on
+ * many systems */
+
+/**
+ * struct ion_page_pool - pagepool struct
+ * @count:		number of items in the pool
+ * @items:		list of items
+ * @shrinker:		a shrinker for the items
+ * @mutex:		lock protecting this struct and especially the count
+ *			item list
+ * @alloc:		function to be used to allocate pageory when the pool
+ *			is empty
+ * @free:		function to be used to free pageory back to the system
+ *			when the shrinker fires
+ * @gfp_mask:		gfp_mask to use from alloc
+ * @order:		order of pages in the pool
+ *
+ * Allows you to keep a pool of pre allocated pages to use from your heap.
+ * Keeping a pool of pages that is ready for dma, ie any cached mapping have
+ * been invalidated from the cache, provides a significant peformance benefit
+ * on many systems
+ */
+struct ion_page_pool {
+	int count;
+	struct list_head items;
+	struct shrinker shrinker;
+	struct mutex mutex;
+	void *(*alloc)(struct ion_page_pool *pool);
+	void (*free)(struct ion_page_pool *pool, struct page *page);
+	gfp_t gfp_mask;
+	unsigned int order;
+};
+
+struct ion_page_pool *ion_page_pool_create(gfp_t gfp_mask, unsigned int order);
+void ion_page_pool_destroy(struct ion_page_pool *);
+void *ion_page_pool_alloc(struct ion_page_pool *);
+void ion_page_pool_free(struct ion_page_pool *, struct page *);
+
+#endif /* _ION_PRIV_H */
diff --git a/drivers/gpu/ion/ion_system_heap.c b/drivers/gpu/ion/ion_system_heap.c
new file mode 100644
index 00000000..9761d1ab
--- /dev/null
+++ b/drivers/gpu/ion/ion_system_heap.c
@@ -0,0 +1,478 @@
+/*
+ * drivers/gpu/ion/ion_system_heap.c
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/page.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/highmem.h>
+#include <linux/ion.h>
+#include <linux/mm.h>
+#include <linux/scatterlist.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include "ion_priv.h"
+
+static unsigned int high_order_gfp_flags = (GFP_HIGHUSER | __GFP_ZERO |
+					    __GFP_NOWARN | __GFP_NORETRY |
+					    __GFP_NO_KSWAPD);
+static unsigned int low_order_gfp_flags  = (GFP_HIGHUSER | __GFP_ZERO |
+					 __GFP_NOWARN);
+static const unsigned int orders[] = {8, 4, 0};
+static const int num_orders = ARRAY_SIZE(orders);
+static int order_to_index(unsigned int order)
+{
+	int i;
+	for (i = 0; i < num_orders; i++)
+		if (order == orders[i])
+			return i;
+	BUG();
+	return -1;
+}
+
+static unsigned int order_to_size(int order)
+{
+	return PAGE_SIZE << order;
+}
+
+struct ion_system_heap {
+	struct ion_heap heap;
+	struct ion_page_pool **pools;
+};
+
+struct page_info {
+	struct page *page;
+	unsigned int order;
+	struct list_head list;
+};
+
+static struct page *alloc_buffer_page(struct ion_system_heap *heap,
+				      struct ion_buffer *buffer,
+				      unsigned long order)
+{
+	bool cached = ion_buffer_cached(buffer);
+	bool split_pages = ion_buffer_fault_user_mappings(buffer);
+	struct ion_page_pool *pool = heap->pools[order_to_index(order)];
+	struct page *page;
+
+	if (!cached) {
+		page = ion_page_pool_alloc(pool);
+	} else {
+		gfp_t gfp_flags = low_order_gfp_flags;
+
+		if (order > 0)
+			gfp_flags = high_order_gfp_flags;
+		page = alloc_pages(gfp_flags, order);
+	}
+	if (!page)
+		return 0;
+	if (split_pages)
+		split_page(page, order);
+	return page;
+}
+
+static void free_buffer_page(struct ion_system_heap *heap,
+			     struct ion_buffer *buffer, struct page *page,
+			     unsigned int order)
+{
+	bool cached = ion_buffer_cached(buffer);
+	bool split_pages = ion_buffer_fault_user_mappings(buffer);
+	int i;
+
+	if (!cached) {
+		struct ion_page_pool *pool = heap->pools[order_to_index(order)];
+		/* zero the pages before returning them to the pool for
+		   security.  This uses vmap as we want to set the pgprot so
+		   the writes to occur to noncached mappings, as the pool's
+		   purpose is to keep the pages out of the cache */
+		for (i = 0; i < order / PAGE_SIZE; i++) {
+			struct page *sub_page = page + i;
+			void *addr = vmap(&sub_page, 1, VM_MAP,
+					  pgprot_writecombine(PAGE_KERNEL));
+			memset(addr, 0, PAGE_SIZE);
+			vunmap(addr);
+		}
+		ion_page_pool_free(pool, page);
+	} else if (split_pages) {
+		for (i = 0; i < (1 << order); i++)
+			__free_page(page + i);
+	} else {
+		__free_pages(page, order);
+	}
+}
+
+
+static struct page_info *alloc_largest_available(struct ion_system_heap *heap,
+						 struct ion_buffer *buffer,
+						 unsigned long size,
+						 unsigned int max_order)
+{
+	struct page *page;
+	struct page_info *info;
+	int i;
+
+	for (i = 0; i < num_orders; i++) {
+		if (size < order_to_size(orders[i]))
+			continue;
+		if (max_order < orders[i])
+			continue;
+
+		page = alloc_buffer_page(heap, buffer, orders[i]);
+		if (!page)
+			continue;
+
+		info = kmalloc(sizeof(struct page_info), GFP_KERNEL);
+		info->page = page;
+		info->order = orders[i];
+		return info;
+	}
+	return NULL;
+}
+
+static int ion_system_heap_allocate(struct ion_heap *heap,
+				     struct ion_buffer *buffer,
+				     unsigned long size, unsigned long align,
+				     unsigned long flags)
+{
+	struct ion_system_heap *sys_heap = container_of(heap,
+							struct ion_system_heap,
+							heap);
+	struct sg_table *table;
+	struct scatterlist *sg;
+	int ret;
+	struct list_head pages;
+	struct page_info *info, *tmp_info;
+	int i = 0;
+	long size_remaining = PAGE_ALIGN(size);
+	unsigned int max_order = orders[0];
+	bool split_pages = ion_buffer_fault_user_mappings(buffer);
+
+	INIT_LIST_HEAD(&pages);
+	while (size_remaining > 0) {
+		info = alloc_largest_available(sys_heap, buffer, size_remaining, max_order);
+		if (!info)
+			goto err;
+		list_add_tail(&info->list, &pages);
+		size_remaining -= (1 << info->order) * PAGE_SIZE;
+		max_order = info->order;
+		i++;
+	}
+
+	table = kmalloc(sizeof(struct sg_table), GFP_KERNEL);
+	if (!table)
+		goto err;
+
+	if (split_pages)
+		ret = sg_alloc_table(table, PAGE_ALIGN(size) / PAGE_SIZE,
+				     GFP_KERNEL);
+	else
+		ret = sg_alloc_table(table, i, GFP_KERNEL);
+
+	if (ret)
+		goto err1;
+
+	sg = table->sgl;
+	list_for_each_entry_safe(info, tmp_info, &pages, list) {
+		struct page *page = info->page;
+		if (split_pages) {
+			for (i = 0; i < (1 << info->order); i++) {
+				sg_set_page(sg, page + i, PAGE_SIZE, 0);
+				sg = sg_next(sg);
+			}
+		} else {
+			sg_set_page(sg, page, (1 << info->order) * PAGE_SIZE,
+				    0);
+			sg = sg_next(sg);
+		}
+		list_del(&info->list);
+		kfree(info);
+	}
+
+	dma_sync_sg_for_device(NULL, table->sgl, table->nents,
+			       DMA_BIDIRECTIONAL);
+
+	buffer->priv_virt = table;
+	return 0;
+err1:
+	kfree(table);
+err:
+	list_for_each_entry(info, &pages, list) {
+		free_buffer_page(sys_heap, buffer, info->page, info->order);
+		kfree(info);
+	}
+	return -ENOMEM;
+}
+
+void ion_system_heap_free(struct ion_buffer *buffer)
+{
+	struct ion_heap *heap = buffer->heap;
+	struct ion_system_heap *sys_heap = container_of(heap,
+							struct ion_system_heap,
+							heap);
+	struct sg_table *table = buffer->priv_virt;
+	struct scatterlist *sg;
+	LIST_HEAD(pages);
+	int i;
+
+	for_each_sg(table->sgl, sg, table->nents, i)
+		free_buffer_page(sys_heap, buffer, sg_page(sg), get_order(sg_dma_len(sg)));
+	sg_free_table(table);
+	kfree(table);
+}
+
+struct sg_table *ion_system_heap_map_dma(struct ion_heap *heap,
+					 struct ion_buffer *buffer)
+{
+	return buffer->priv_virt;
+}
+
+void ion_system_heap_unmap_dma(struct ion_heap *heap,
+			       struct ion_buffer *buffer)
+{
+	return;
+}
+
+void *ion_system_heap_map_kernel(struct ion_heap *heap,
+				 struct ion_buffer *buffer)
+{
+	struct scatterlist *sg;
+	int i, j;
+	void *vaddr;
+	pgprot_t pgprot;
+	struct sg_table *table = buffer->priv_virt;
+	int npages = PAGE_ALIGN(buffer->size) / PAGE_SIZE;
+	struct page **pages = vmalloc(sizeof(struct page *) * npages);
+	struct page **tmp = pages;
+
+	if (!pages)
+		return 0;
+
+	if (buffer->flags & ION_FLAG_CACHED)
+		pgprot = PAGE_KERNEL;
+	else
+		pgprot = pgprot_writecombine(PAGE_KERNEL);
+
+	for_each_sg(table->sgl, sg, table->nents, i) {
+		int npages_this_entry = PAGE_ALIGN(sg_dma_len(sg)) / PAGE_SIZE;
+		struct page *page = sg_page(sg);
+		BUG_ON(i >= npages);
+		for (j = 0; j < npages_this_entry; j++) {
+			*(tmp++) = page++;
+		}
+	}
+	vaddr = vmap(pages, npages, VM_MAP, pgprot);
+	vfree(pages);
+
+	return vaddr;
+}
+
+void ion_system_heap_unmap_kernel(struct ion_heap *heap,
+				  struct ion_buffer *buffer)
+{
+	vunmap(buffer->vaddr);
+}
+
+int ion_system_heap_map_user(struct ion_heap *heap, struct ion_buffer *buffer,
+			     struct vm_area_struct *vma)
+{
+	struct sg_table *table = buffer->priv_virt;
+	unsigned long addr = vma->vm_start;
+	unsigned long offset = vma->vm_pgoff;
+	struct scatterlist *sg;
+	int i;
+
+	for_each_sg(table->sgl, sg, table->nents, i) {
+		if (offset) {
+			offset--;
+			continue;
+		}
+		remap_pfn_range(vma, addr, page_to_pfn(sg_page(sg)),
+				sg_dma_len(sg), vma->vm_page_prot);
+		addr += sg_dma_len(sg);
+		if (addr >= vma->vm_end)
+			return 0;
+	}
+	return 0;
+}
+
+static struct ion_heap_ops system_heap_ops = {
+	.allocate = ion_system_heap_allocate,
+	.free = ion_system_heap_free,
+	.map_dma = ion_system_heap_map_dma,
+	.unmap_dma = ion_system_heap_unmap_dma,
+	.map_kernel = ion_system_heap_map_kernel,
+	.unmap_kernel = ion_system_heap_unmap_kernel,
+	.map_user = ion_system_heap_map_user,
+};
+
+static int ion_system_heap_debug_show(struct ion_heap *heap, struct seq_file *s,
+				      void *unused)
+{
+
+	struct ion_system_heap *sys_heap = container_of(heap,
+							struct ion_system_heap,
+							heap);
+	int i;
+	for (i = 0; i < num_orders; i++) {
+		struct ion_page_pool *pool = sys_heap->pools[i];
+		seq_printf(s, "%d order %u pages in pool = %lu total\n",
+			   pool->count, pool->order,
+			   (1 << pool->order) * PAGE_SIZE * pool->count);
+	}
+	return 0;
+}
+
+struct ion_heap *ion_system_heap_create(struct ion_platform_heap *unused)
+{
+	struct ion_system_heap *heap;
+	int i;
+
+	heap = kzalloc(sizeof(struct ion_system_heap), GFP_KERNEL);
+	if (!heap)
+		return ERR_PTR(-ENOMEM);
+	heap->heap.ops = &system_heap_ops;
+	heap->heap.type = ION_HEAP_TYPE_SYSTEM;
+	heap->pools = kzalloc(sizeof(struct ion_page_pool *) * num_orders,
+			      GFP_KERNEL);
+	if (!heap->pools)
+		goto err_alloc_pools;
+	for (i = 0; i < num_orders; i++) {
+		struct ion_page_pool *pool;
+		gfp_t gfp_flags = low_order_gfp_flags;
+
+		if (orders[i] > 0)
+			gfp_flags = high_order_gfp_flags;
+		pool = ion_page_pool_create(gfp_flags, orders[i]);
+		if (!pool)
+			goto err_create_pool;
+		heap->pools[i] = pool;
+	}
+	heap->heap.debug_show = ion_system_heap_debug_show;
+	return &heap->heap;
+err_create_pool:
+	for (i = 0; i < num_orders; i++)
+		if (heap->pools[i])
+			ion_page_pool_destroy(heap->pools[i]);
+	kfree(heap->pools);
+err_alloc_pools:
+	kfree(heap);
+	return ERR_PTR(-ENOMEM);
+}
+
+void ion_system_heap_destroy(struct ion_heap *heap)
+{
+	struct ion_system_heap *sys_heap = container_of(heap,
+							struct ion_system_heap,
+							heap);
+	int i;
+
+	for (i = 0; i < num_orders; i++)
+		ion_page_pool_destroy(sys_heap->pools[i]);
+	kfree(sys_heap->pools);
+	kfree(sys_heap);
+}
+
+static int ion_system_contig_heap_allocate(struct ion_heap *heap,
+					   struct ion_buffer *buffer,
+					   unsigned long len,
+					   unsigned long align,
+					   unsigned long flags)
+{
+	buffer->priv_virt = kzalloc(len, GFP_KERNEL);
+	if (!buffer->priv_virt)
+		return -ENOMEM;
+	return 0;
+}
+
+void ion_system_contig_heap_free(struct ion_buffer *buffer)
+{
+	kfree(buffer->priv_virt);
+}
+
+static int ion_system_contig_heap_phys(struct ion_heap *heap,
+				       struct ion_buffer *buffer,
+				       ion_phys_addr_t *addr, size_t *len)
+{
+	*addr = virt_to_phys(buffer->priv_virt);
+	*len = buffer->size;
+	return 0;
+}
+
+struct sg_table *ion_system_contig_heap_map_dma(struct ion_heap *heap,
+						struct ion_buffer *buffer)
+{
+	struct sg_table *table;
+	int ret;
+
+	table = kzalloc(sizeof(struct sg_table), GFP_KERNEL);
+	if (!table)
+		return ERR_PTR(-ENOMEM);
+	ret = sg_alloc_table(table, 1, GFP_KERNEL);
+	if (ret) {
+		kfree(table);
+		return ERR_PTR(ret);
+	}
+	sg_set_page(table->sgl, virt_to_page(buffer->priv_virt), buffer->size,
+		    0);
+	return table;
+}
+
+void ion_system_contig_heap_unmap_dma(struct ion_heap *heap,
+				      struct ion_buffer *buffer)
+{
+	sg_free_table(buffer->sg_table);
+	kfree(buffer->sg_table);
+}
+
+int ion_system_contig_heap_map_user(struct ion_heap *heap,
+				    struct ion_buffer *buffer,
+				    struct vm_area_struct *vma)
+{
+	unsigned long pfn = __phys_to_pfn(virt_to_phys(buffer->priv_virt));
+	return remap_pfn_range(vma, vma->vm_start, pfn + vma->vm_pgoff,
+			       vma->vm_end - vma->vm_start,
+			       vma->vm_page_prot);
+
+}
+
+static struct ion_heap_ops kmalloc_ops = {
+	.allocate = ion_system_contig_heap_allocate,
+	.free = ion_system_contig_heap_free,
+	.phys = ion_system_contig_heap_phys,
+	.map_dma = ion_system_contig_heap_map_dma,
+	.unmap_dma = ion_system_contig_heap_unmap_dma,
+	.map_kernel = ion_system_heap_map_kernel,
+	.unmap_kernel = ion_system_heap_unmap_kernel,
+	.map_user = ion_system_contig_heap_map_user,
+};
+
+struct ion_heap *ion_system_contig_heap_create(struct ion_platform_heap *unused)
+{
+	struct ion_heap *heap;
+
+	heap = kzalloc(sizeof(struct ion_heap), GFP_KERNEL);
+	if (!heap)
+		return ERR_PTR(-ENOMEM);
+	heap->ops = &kmalloc_ops;
+	heap->type = ION_HEAP_TYPE_SYSTEM_CONTIG;
+	return heap;
+}
+
+void ion_system_contig_heap_destroy(struct ion_heap *heap)
+{
+	kfree(heap);
+}
+
diff --git a/drivers/gpu/ion/pxa/Makefile b/drivers/gpu/ion/pxa/Makefile
new file mode 100644
index 00000000..72e8abe0
--- /dev/null
+++ b/drivers/gpu/ion/pxa/Makefile
@@ -0,0 +1 @@
+obj-y += pxa_ion.o
diff --git a/drivers/gpu/ion/pxa/pxa_ion.c b/drivers/gpu/ion/pxa/pxa_ion.c
new file mode 100644
index 00000000..4558e112
--- /dev/null
+++ b/drivers/gpu/ion/pxa/pxa_ion.c
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/ion.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/pxa_ion.h>
+#include <asm/cacheflush.h>
+#include "../ion_priv.h"
+
+struct pxa_ion_info {
+	struct ion_device       *idev;
+	struct ion_heap         **heaps;
+	int                     heap_cnt;
+};
+
+struct ion_device *pxa_ion_dev;
+EXPORT_SYMBOL(pxa_ion_dev);
+
+static long pxa_ion_ioctl(struct ion_client *client, unsigned int cmd,
+							unsigned long arg)
+{
+	switch (cmd) {
+	case ION_PXA_PHYS:
+	       {
+			struct ion_pxa_region region ;
+			if (copy_from_user(&region, (void __user *)arg,
+						sizeof(struct ion_pxa_region)))
+				return -EFAULT;
+
+			ion_phys(client, region.handle,
+					&region.addr, &region.len);
+			if (copy_to_user((void __user *)arg, &region,
+						sizeof(struct ion_pxa_region)))
+				return -EFAULT;
+			break;
+		}
+	case ION_PXA_SYNC:
+	{
+		struct ion_pxa_cache_region region;
+		struct ion_buffer *buffer;
+		struct vm_area_struct *vma;
+		bool valid_handle;
+		phys_addr_t pstart, pend;
+		unsigned long start, end;
+
+		if (copy_from_user(&region, (void __user *)arg,
+				   sizeof(struct ion_pxa_cache_region)))
+			return -EFAULT;
+		valid_handle = ion_handle_validate(client, region.handle);
+		if (!valid_handle) {
+			pr_err("%s:invalid handle 0x%x\n",
+				__func__, (unsigned int)region.handle);
+			return -EINVAL;
+		}
+		buffer = ion_handle_buffer(region.handle);
+		mutex_lock(&buffer->lock);
+		if (region.offset > buffer->size) {
+			mutex_unlock(&buffer->lock);
+			pr_err("%s: invalid offset exceeds buffer size\n",
+				__func__);
+			return -EINVAL;
+		}
+		if (region.offset + region.len > buffer->size)
+			region.len = buffer->size - region.offset;
+		/*
+		 * Limitation: There's only one vma in one process context.
+		 * If we want to support multiple vmas in one process context,
+		 * we need to extend the interface.
+		 */
+		vma = pxa_ion_find_vma(buffer);
+		if (!vma) {
+			mutex_unlock(&buffer->lock);
+			pr_err("%s: Buffer doesn't map to virtual address\n",
+				__func__);
+			return -EINVAL;
+		}
+		start = vma->vm_start + region.offset;
+		end = start + region.len;
+		/* don't check direction */
+		dmac_flush_range((void *)start, (void *)end);
+
+		pstart = buffer->priv_phys + region.offset;
+		pend = pstart + region.len;
+		outer_flush_range(pstart, pend);
+		mutex_unlock(&buffer->lock);
+		break;
+	}
+	default:
+	       pr_err("%s: Unknown ioctl %d\n", __func__, cmd);
+	       return -EINVAL;
+	}
+	return 0;
+}
+
+static int pxa_ion_probe(struct platform_device *pdev)
+{
+	struct ion_platform_data *pdata = pdev->dev.platform_data;
+	struct pxa_ion_info *info;
+	int err, i;
+
+	if (!pdata)
+		return -EINVAL;
+
+	info = devm_kzalloc(&pdev->dev, sizeof(struct pxa_ion_info),
+								GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->heaps = devm_kzalloc(&pdev->dev,
+		sizeof(struct ion_heap *) * pdata->nr, GFP_KERNEL);
+	if (!info->heaps)
+		return -ENOMEM;
+
+	info->heap_cnt = pdata->nr;
+
+	info->idev = ion_device_create(pxa_ion_ioctl);
+	if (IS_ERR_OR_NULL(info->idev))
+		return PTR_ERR(info->idev);
+
+	pxa_ion_dev = info->idev;
+
+	/* create the heaps as specified in the board file */
+	for (i = 0; i < pdata->nr; i++) {
+		struct ion_platform_heap *heap_data = &pdata->heaps[i];
+
+		info->heaps[i] = ion_heap_create(heap_data);
+		if (IS_ERR_OR_NULL(info->heaps[i])) {
+			err = PTR_ERR(info->heaps[i]);
+			goto err_heap;
+		}
+		ion_device_add_heap(info->idev, info->heaps[i]);
+	}
+	platform_set_drvdata(pdev, info);
+
+	return 0;
+
+err_heap:
+	for (; i >= 0; i--)
+		ion_heap_destroy(info->heaps[i]);
+	ion_device_destroy(info->idev);
+	return err;
+}
+
+static int pxa_ion_remove(struct platform_device *pdev)
+{
+	struct pxa_ion_info *info = platform_get_drvdata(pdev);
+	int i;
+
+	if (info) {
+		for (i = 0; i < info->heap_cnt; i++)
+			ion_heap_destroy(info->heaps[i]);
+		ion_device_destroy(info->idev);
+		platform_set_drvdata(pdev, NULL);
+	}
+	return 0;
+}
+
+static struct platform_driver pxa_ion_driver = {
+	.probe = pxa_ion_probe,
+	.remove = pxa_ion_remove,
+	.driver = { .name = "pxa-ion" }
+};
+
+module_platform_driver(pxa_ion_driver);
+
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/i2c/Kconfig b/drivers/i2c/Kconfig
index 5f13c62e..7be84de5 100644
--- a/drivers/i2c/Kconfig
+++ b/drivers/i2c/Kconfig
@@ -86,6 +86,7 @@ config I2C_SMBUS
 
 source drivers/i2c/algos/Kconfig
 source drivers/i2c/busses/Kconfig
+source drivers/i2c/chips/Kconfig
 
 config I2C_DEBUG_CORE
 	bool "I2C Core debugging messages"
diff --git a/drivers/i2c/Makefile b/drivers/i2c/Makefile
index beee6b2d..002558a0 100644
--- a/drivers/i2c/Makefile
+++ b/drivers/i2c/Makefile
@@ -7,7 +7,7 @@ obj-$(CONFIG_I2C)		+= i2c-core.o
 obj-$(CONFIG_I2C_SMBUS)		+= i2c-smbus.o
 obj-$(CONFIG_I2C_CHARDEV)	+= i2c-dev.o
 obj-$(CONFIG_I2C_MUX)		+= i2c-mux.o
-obj-y				+= algos/ busses/ muxes/
+obj-y				+= algos/ busses/ muxes/ chips/
 
 ccflags-$(CONFIG_I2C_DEBUG_CORE) := -DDEBUG
 CFLAGS_i2c-core.o := -Wno-deprecated-declarations
diff --git a/drivers/i2c/busses/i2c-pxa.c b/drivers/i2c/busses/i2c-pxa.c
index f6733267..259dd379 100644
--- a/drivers/i2c/busses/i2c-pxa.c
+++ b/drivers/i2c/busses/i2c-pxa.c
@@ -38,9 +38,19 @@
 #include <linux/slab.h>
 #include <linux/io.h>
 #include <linux/i2c/pxa-i2c.h>
+#include <plat/pm.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
 
 #include <asm/irq.h>
-
+#if defined(CONFIG_MACH_HELANDELOS) || defined(CONFIG_MACH_WILCOX) || defined(CONFIG_MACH_CS02) || defined(CONFIG_MACH_BAFFIN) \
+	|| defined(CONFIG_MACH_CT01) || defined(CONFIG_MACH_CS05) || defined(CONFIG_MACH_BAFFINQ) || defined(CONFIG_MACH_GOLDEN)
+#include <mach/samsung_camera.h>
+#elif CONFIG_MACH_GOYA
+#include <mach/samsung_camera_goya.h>
+#elif CONFIG_MACH_DEGAS
+#include <mach/samsung_camera_degas.h>
+#endif
 #ifndef CONFIG_HAVE_CLK
 #define clk_get(dev, id)	NULL
 #define clk_put(clk)		do { } while (0)
@@ -54,12 +64,21 @@ struct pxa_reg_layout {
 	u32 icr;
 	u32 isr;
 	u32 isar;
+	u32 ilcr;
+	u32 iwcr;
+	u32 wfifo;
+	u32 wfifo_wptr;
+	u32 wfifo_rptr;
+	u32 rfifo;
+	u32 rfifo_wptr;
+	u32 rfifo_rptr;
 };
 
 enum pxa_i2c_types {
 	REGS_PXA2XX,
 	REGS_PXA3XX,
 	REGS_CE4100,
+	REGS_PXA910,
 };
 
 /*
@@ -87,12 +106,28 @@ static struct pxa_reg_layout pxa_reg_layout[] = {
 		.isr =	0x04,
 		/* no isar register */
 	},
+	[REGS_PXA910] = {
+		.ibmr = 0x00,
+		.idbr = 0x08,
+		.icr =	0x10,
+		.isr =	0x18,
+		.isar = 0x20,
+		.ilcr = 0x28,
+		.iwcr = 0x30,
+		.wfifo = 0x40,
+		.wfifo_wptr = 0x44,
+		.wfifo_rptr = 0x48,
+		.rfifo = 0x50,
+		.rfifo_wptr = 0x54,
+		.rfifo_rptr = 0x58,
+	},
 };
 
 static const struct platform_device_id i2c_pxa_id_table[] = {
 	{ "pxa2xx-i2c",		REGS_PXA2XX },
 	{ "pxa3xx-pwri2c",	REGS_PXA3XX },
 	{ "ce4100-i2c",		REGS_CE4100 },
+	{ "pxa910-i2c",		REGS_PXA910 },
 	{ },
 };
 MODULE_DEVICE_TABLE(platform, i2c_pxa_id_table);
@@ -117,6 +152,16 @@ MODULE_DEVICE_TABLE(platform, i2c_pxa_id_table);
 #define ICR_SADIE	(1 << 13)	   /* slave address detected int enable */
 #define ICR_UR		(1 << 14)	   /* unit reset */
 #define ICR_FM		(1 << 15)	   /* fast mode */
+#define ICR_HS		(1 << 16)	   /* High Speed mode */
+#define ICR_GPIOEN	(1 << 19)	   /* enable GPIO mode for SCL in HS */
+#define ICR_FIFOEN      (1 << 20)	   /* enable FIFO mode */
+#define ICR_TXBEGIN     (1 << 21)	   /* transaction begins */
+#define ICR_TXDONE_IE   (1 << 22)	   /* EN tx done interrupt */
+#define ICR_RXHF_IE     (1 << 23)	   /* EN rx FIFO half full interrupt */
+#define ICR_TXE_IE      (1 << 24)	   /* EN tx FIFO empty interrupt */
+#define ICR_RXF_IE      (1 << 25)	   /* EN rx FIFO full interrupt */
+#define ICR_RXOV_IE     (1 << 26)	   /* EN rx FIFO overrun interrupt */
+#define ICR_DMA_EN      (1 << 27)	   /* DMA enable for TX and RX FIFOs */
 
 #define ISR_RWM		(1 << 0)	   /* read/write mode */
 #define ISR_ACKNAK	(1 << 1)	   /* ack/nak status */
@@ -129,6 +174,13 @@ MODULE_DEVICE_TABLE(platform, i2c_pxa_id_table);
 #define ISR_GCAD	(1 << 8)	   /* general call address detected */
 #define ISR_SAD		(1 << 9)	   /* slave address detected */
 #define ISR_BED		(1 << 10)	   /* bus error no ACK/NAK */
+#define ISR_EBB		(1 << 11)	   /* early bus busy */
+#define ISR_MSD		(1 << 12)	   /* master stop detected */
+#define ISR_TXDONE      (1 << 13)	   /* transaction done */
+#define ISR_RXHF        (1 << 14)	   /* receive FIFO half full */
+#define ISR_TXE         (1 << 15)	   /* transmit FIFO empty */
+#define ISR_RXF         (1 << 16)	   /* receive FIFO full */
+#define ISR_RXOV        (1 << 17)	   /* receive FIFO overrun */
 
 struct pxa_i2c {
 	spinlock_t		lock;
@@ -138,6 +190,7 @@ struct pxa_i2c {
 	unsigned int		msg_idx;
 	unsigned int		msg_ptr;
 	unsigned int		slave_addr;
+	unsigned int		req_slave_addr;
 
 	struct i2c_adapter	adap;
 	struct clk		*clk;
@@ -155,6 +208,14 @@ struct pxa_i2c {
 	void __iomem		*reg_icr;
 	void __iomem		*reg_isr;
 	void __iomem		*reg_isar;
+	void __iomem		*reg_ilcr;
+	void __iomem		*reg_iwcr;
+	void __iomem		*reg_wfifo;
+	void __iomem		*reg_wfifo_wptr;
+	void __iomem		*reg_wfifo_rptr;
+	void __iomem		*reg_rfifo;
+	void __iomem		*reg_rfifo_wptr;
+	void __iomem		*reg_rfifo_rptr;
 
 	unsigned long		iobase;
 	unsigned long		iosize;
@@ -162,6 +223,16 @@ struct pxa_i2c {
 	int			irq;
 	unsigned int		use_pio :1;
 	unsigned int		fast_mode :1;
+	unsigned int		high_mode:1;
+	unsigned int		fifo_mode:1;
+	bool			highmode_enter;
+	bool			fifo_transmit_done;
+	unsigned char		master_code;
+	unsigned int		ilcr;
+	unsigned int		iwcr;
+	struct pm_qos_request	qos_idle;
+	u32			fifo_write_ptr;
+	u32			fifo_read_ptr;
 };
 
 #define _IBMR(i2c)	((i2c)->reg_ibmr)
@@ -169,12 +240,29 @@ struct pxa_i2c {
 #define _ICR(i2c)	((i2c)->reg_icr)
 #define _ISR(i2c)	((i2c)->reg_isr)
 #define _ISAR(i2c)	((i2c)->reg_isar)
+#define _ILCR(i2c)	((i2c)->reg_ilcr)
+#define _IWCR(i2c)	((i2c)->reg_iwcr)
+#define _WFIFO(i2c)		((i2c)->reg_wfifo)
+#define _WFIFO_WPTR(i2c)	((i2c)->reg_wfifo_wptr)
+#define _WFIFO_RPTR(i2c)	((i2c)->reg_wfifo_rptr)
+#define _RFIFO(i2c)		((i2c)->reg_rfifo)
+#define _RFIFO_WPTR(i2c)	((i2c)->reg_rfifo_wptr)
+#define _RFIFO_RPTR(i2c)	((i2c)->reg_rfifo_rptr)
+
+/*
+ * FIFO entry information
+ */
+#define I2C_PXA_FIFO_ENTRY_RX	0x10
+#define I2C_PXA_FIFO_ENTRY_TX	0x8
 
 /*
  * I2C Slave mode address
  */
 #define I2C_PXA_SLAVE_ADDR      0x1
 
+#define DEBUG 0
+static void i2c_pxa_reset(struct pxa_i2c *i2c);
+
 #ifdef DEBUG
 
 struct bits {
@@ -243,6 +331,7 @@ static void decode_ICR(unsigned int val)
 #endif
 
 static unsigned int i2c_debug = DEBUG;
+static struct pxa_i2c *i2c_global;
 
 static void i2c_pxa_show_state(struct pxa_i2c *i2c, int lno, const char *fname)
 {
@@ -255,15 +344,26 @@ static void i2c_pxa_show_state(struct pxa_i2c *i2c, int lno, const char *fname)
 static void i2c_pxa_scream_blue_murder(struct pxa_i2c *i2c, const char *why)
 {
 	unsigned int i;
-	printk(KERN_ERR "i2c: error: %s\n", why);
+	struct i2c_pxa_platform_data *plat =
+		(i2c->adap.dev.parent)->platform_data;
+
+	printk(KERN_ERR"i2c: <%s> slave_0x%x error: %s\n", i2c->adap.name,
+		i2c->req_slave_addr >> 1, why);
 	printk(KERN_ERR "i2c: msg_num: %d msg_idx: %d msg_ptr: %d\n",
 		i2c->msg_num, i2c->msg_idx, i2c->msg_ptr);
-	printk(KERN_ERR "i2c: ICR: %08x ISR: %08x\n",
-	       readl(_ICR(i2c)), readl(_ISR(i2c)));
+	printk(KERN_ERR "i2c: IBMR: %08x IDBR: %08x ICR: %08x ISR: %08x\n",
+		readl(_IBMR(i2c)), readl(_IDBR(i2c)), readl(_ICR(i2c)),
+		readl(_ISR(i2c)));
 	printk(KERN_DEBUG "i2c: log: ");
 	for (i = 0; i < i2c->irqlogidx; i++)
 		printk("[%08x:%08x] ", i2c->isrlog[i], i2c->icrlog[i]);
 	printk("\n");
+	if (strcmp(why, "exhausted retries") != 0) {
+		if (plat && plat->i2c_bus_reset)
+			plat->i2c_bus_reset(i2c->adap.nr);
+		/* reset i2c contorler when it's fail */
+		i2c_pxa_reset(i2c);
+	}
 }
 
 #else /* ifdef DEBUG */
@@ -316,6 +416,11 @@ static int i2c_pxa_wait_bus_not_busy(struct pxa_i2c *i2c)
 {
 	int timeout = DEF_TIMEOUT;
 
+	if (readl(_ISR(i2c)) & (ISR_IBB | ISR_UB)) {
+		i2c_pxa_reset(i2c);
+		timeout /= 2;
+	}
+
 	while (timeout-- && readl(_ISR(i2c)) & (ISR_IBB | ISR_UB)) {
 		if ((readl(_ISR(i2c)) & ISR_SAD) != 0)
 			timeout += 4;
@@ -449,6 +554,14 @@ static void i2c_pxa_set_slave(struct pxa_i2c *i2c, int errcode)
 #define i2c_pxa_set_slave(i2c, err)	do { } while (0)
 #endif
 
+static void flush_fifo_registers(struct pxa_i2c *i2c)
+{
+	writel(0, _WFIFO_WPTR(i2c));
+	writel(0, _WFIFO_RPTR(i2c));
+	writel(0, _RFIFO_WPTR(i2c));
+	writel(0, _RFIFO_RPTR(i2c));
+}
+
 static void i2c_pxa_reset(struct pxa_i2c *i2c)
 {
 	pr_debug("Resetting I2C Controller Unit\n");
@@ -461,11 +574,25 @@ static void i2c_pxa_reset(struct pxa_i2c *i2c)
 	writel(I2C_ISR_INIT, _ISR(i2c));
 	writel(readl(_ICR(i2c)) & ~ICR_UR, _ICR(i2c));
 
+#ifdef CONFIG_I2C_PXA_SLAVE
 	if (i2c->reg_isar)
 		writel(i2c->slave_addr, _ISAR(i2c));
+#endif
 
 	/* set control register values */
 	writel(I2C_ICR_INIT | (i2c->fast_mode ? ICR_FM : 0), _ICR(i2c));
+	writel(readl(_ICR(i2c)) | (i2c->high_mode ? ICR_HS : 0), _ICR(i2c));
+
+	/* There are 2 multi-masters on the I2C bus - APPS and COMM
+	 * It is important both uses the standard frequency
+	 * Adjust clock by ILCR, IWCR is important
+	 */
+	if (i2c->ilcr)
+		writel(i2c->ilcr, _ILCR(i2c));
+	if (i2c->iwcr)
+		writel(i2c->iwcr, _IWCR(i2c));
+	udelay(2);
+
 
 #ifdef CONFIG_I2C_PXA_SLAVE
 	dev_info(&i2c->adap.dev, "Enabling slave mode\n");
@@ -621,6 +748,38 @@ static void i2c_pxa_slave_stop(struct pxa_i2c *i2c)
  * PXA I2C Master mode
  */
 
+static int i2c_pxa_send_mastercode(struct pxa_i2c *i2c)
+{
+	u32 icr;
+	long timeout;
+
+	spin_lock_irq(&i2c->lock);
+
+	i2c->highmode_enter = true;
+
+	icr = readl(_ICR(i2c));
+	icr |= ICR_HS;  /* bit_15 clear or set already done by reset */
+
+	icr |= ICR_GPIOEN;
+	writel(i2c->master_code, _IDBR(i2c));
+
+	icr |= ICR_START | ICR_TB | ICR_ITEIE;
+	icr &= ~ICR_STOP;
+	icr &= ~ICR_ALDIE;
+	writel(icr, _ICR(i2c));
+
+	spin_unlock_irq(&i2c->lock);
+
+	timeout = wait_event_timeout(i2c->wait, \
+		i2c->highmode_enter == false, HZ * 1);
+	i2c->highmode_enter = false;
+
+	if (!timeout)
+		return 1;
+	else
+		return 0;
+}
+
 static inline unsigned int i2c_pxa_addr_byte(struct i2c_msg *msg)
 {
 	unsigned int addr = (msg->addr & 0x7f) << 1;
@@ -639,6 +798,7 @@ static inline void i2c_pxa_start_message(struct pxa_i2c *i2c)
 	 * Step 1: target slave address into IDBR
 	 */
 	writel(i2c_pxa_addr_byte(i2c->msg), _IDBR(i2c));
+	i2c->req_slave_addr = i2c_pxa_addr_byte(i2c->msg);
 
 	/*
 	 * Step 2: initiate the write.
@@ -659,6 +819,128 @@ static inline void i2c_pxa_stop_message(struct pxa_i2c *i2c)
 	writel(icr, _ICR(i2c));
 }
 
+static void i2c_pxa_start_fifo(struct pxa_i2c *i2c)
+{
+	u32 icr;
+
+	icr = readl(_ICR(i2c));
+	icr |= ICR_FIFOEN | ICR_TXE_IE | ICR_TXDONE_IE;
+	icr |= ICR_RXHF_IE | ICR_RXF_IE | ICR_RXOV_IE;
+	icr &= ~(ICR_DMA_EN | ICR_ITEIE | ICR_IRFIE);
+
+	writel(icr, _ICR(i2c));
+}
+
+static void i2c_pxa_exit_fifo(struct pxa_i2c *i2c)
+{
+	u32 icr;
+
+	icr = readl(_ICR(i2c));
+	icr &= ~(ICR_FIFOEN | ICR_TXE_IE | ICR_TXDONE_IE);
+	icr &= ~(ICR_RXHF_IE | ICR_RXF_IE | ICR_RXOV_IE);
+	icr &= ~(ICR_START | ICR_STOP | ICR_ACKNAK | ICR_TB);
+
+	writel(icr, _ICR(i2c));
+	writel(0xFFFFF, _ISR(i2c));
+}
+
+static inline void i2c_pxa_fifo_line(struct pxa_i2c *i2c, char data, char icr)
+{
+	u16 wfifo;
+
+	wfifo = readl(_WFIFO(i2c));
+	wfifo |= (icr & 0xF) << 8;
+	wfifo |= data;
+	writel(wfifo, _WFIFO(i2c));
+	i2c->fifo_write_ptr++;
+}
+
+static void i2c_pxa_fifo_load(struct pxa_i2c *i2c)
+{
+	char data, icr = 0;
+
+	i2c->fifo_write_ptr = 0;
+
+	if ((i2c->msg_ptr == 0) && (i2c->msg_idx == 0)) {
+		if (i2c->high_mode) {
+			writel(readl(_ICR(i2c)) | ICR_GPIOEN, _ICR(i2c));
+
+			icr |= ICR_START | ICR_TB;
+			icr &= ~(ICR_STOP | ICR_ACKNAK);
+			data = i2c->master_code;
+			i2c_pxa_fifo_line(i2c, data, icr);
+		}
+
+		icr |= ICR_START | ICR_TB;
+		icr &= ~(ICR_STOP | ICR_ACKNAK);
+		data = i2c_pxa_addr_byte(i2c->msg);
+		i2c_pxa_fifo_line(i2c, data, icr);
+	}
+
+	while (i2c->fifo_write_ptr < I2C_PXA_FIFO_ENTRY_TX) {
+		if (i2c->msg_ptr < i2c->msg->len) {
+			if (i2c->msg->buf == NULL) {
+				i2c_pxa_scream_blue_murder(i2c, "null buffer");
+				i2c->msg_idx = XFER_NAKED;
+				i2c->fifo_transmit_done = true;
+				wake_up(&i2c->wait);
+				return;
+			}
+
+			icr |= ICR_TB;
+			icr &= ~(ICR_START | ICR_STOP | ICR_ACKNAK);
+			data = i2c->msg->buf[i2c->msg_ptr++];
+
+			if ((i2c->msg_ptr == i2c->msg->len) && \
+				(i2c->msg_idx == i2c->msg_num - 1)) {
+				icr |= ICR_STOP;
+
+				if (i2c->msg->flags & I2C_M_RD)
+					icr |= ICR_ACKNAK;
+
+				i2c_pxa_fifo_line(i2c, data, icr);
+				writel((readl(_ICR(i2c)) & ~ICR_TXE_IE),
+					_ICR(i2c));
+
+				break;
+			}
+
+			i2c_pxa_fifo_line(i2c, data, icr);
+		} else if (i2c->msg_idx < i2c->msg_num - 1) {
+			/*
+			 * Next segment of the message.
+			 */
+			i2c->msg_ptr = 0;
+			i2c->msg_idx++;
+			i2c->msg++;
+
+			/*
+			 * If we aren't doing a repeated start and address,
+			 * go back and try to send the next byte.  Note that
+			 * we do not support switching the R/W direction here.
+			 */
+			if (i2c->msg->flags & I2C_M_NOSTART)
+				continue;
+
+			/* write the next address and trigger a repeat start */
+			icr |= ICR_START | ICR_TB;
+			icr &= ~(ICR_STOP | ICR_ACKNAK);
+			data = i2c_pxa_addr_byte(i2c->msg);
+			i2c_pxa_fifo_line(i2c, data, icr);
+		} else {
+			if (i2c->msg->len == 0) {
+				/*
+				 * Device probes have a message length of zero
+				 * and need the bus to be reset before it can
+				 * be used again.
+				 */
+				i2c_pxa_reset(i2c);
+			}
+			return;
+		}
+	}
+}
+
 static int i2c_pxa_pio_set_master(struct pxa_i2c *i2c)
 {
 	/* make timeout the same as for interrupt based functions */
@@ -690,7 +972,7 @@ static int i2c_pxa_pio_set_master(struct pxa_i2c *i2c)
 static int i2c_pxa_do_pio_xfer(struct pxa_i2c *i2c,
 			       struct i2c_msg *msg, int num)
 {
-	unsigned long timeout = 500000; /* 5 seconds */
+	unsigned long timeout = 100000; /* 1 seconds */
 	int ret = 0;
 
 	ret = i2c_pxa_pio_set_master(i2c);
@@ -703,6 +985,8 @@ static int i2c_pxa_do_pio_xfer(struct pxa_i2c *i2c,
 	i2c->msg_ptr = 0;
 	i2c->irqlogidx = 0;
 
+	pm_qos_update_request(&i2c->qos_idle, PM_QOS_CPUIDLE_BLOCK_DDR_VALUE);
+
 	i2c_pxa_start_message(i2c);
 
 	while (i2c->msg_num > 0 && --timeout) {
@@ -712,6 +996,8 @@ static int i2c_pxa_do_pio_xfer(struct pxa_i2c *i2c,
 
 	i2c_pxa_stop_message(i2c);
 
+	pm_qos_update_request(&i2c->qos_idle,
+			PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
 	/*
 	 * We place the return code in i2c->msg_idx.
 	 */
@@ -721,12 +1007,82 @@ out:
 	if (timeout == 0)
 		i2c_pxa_scream_blue_murder(i2c, "timeout");
 
+	if (ret < 0)
+		i2c_pxa_reset(i2c);
+
 	return ret;
 }
 
 /*
  * We are protected by the adapter bus mutex.
  */
+static int
+i2c_pxa_do_xfer_fifo(struct pxa_i2c *i2c, struct i2c_msg *msg, int num)
+{
+	long timeout;
+	int ret;
+
+	/*
+	 * Wait for the bus to become free.
+	 */
+	ret = i2c_pxa_wait_bus_not_busy(i2c);
+	if (ret) {
+		dev_err(&i2c->adap.dev, "i2c_pxa: timeout waiting for bus free\n");
+		goto out;
+	}
+
+	/*
+	 * Set master mode.
+	 */
+	ret = i2c_pxa_set_master(i2c);
+	if (ret) {
+		dev_err(&i2c->adap.dev, "i2c_pxa_set_master: error %d\n", ret);
+		goto out;
+	}
+
+	spin_lock_irq(&i2c->lock);
+
+	i2c->msg = msg;
+	i2c->msg_num = num;
+	i2c->msg_idx = 0;
+	i2c->msg_ptr = 0;
+	i2c->fifo_write_ptr = 0;
+	i2c->fifo_read_ptr = 0;
+	i2c->fifo_transmit_done = false;
+	i2c->irqlogidx = 0;
+	i2c->req_slave_addr = i2c_pxa_addr_byte(i2c->msg);
+
+	pm_qos_update_request(&i2c->qos_idle, PM_QOS_CPUIDLE_BLOCK_DDR_VALUE);
+
+	flush_fifo_registers(i2c);
+	i2c_pxa_start_fifo(i2c);
+
+	spin_unlock_irq(&i2c->lock);
+
+	timeout = wait_event_timeout(i2c->wait,
+		i2c->fifo_transmit_done == true, HZ * 1);
+	i2c_pxa_exit_fifo(i2c);
+
+	pm_qos_update_request(&i2c->qos_idle,
+			PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+
+	/*
+	 * We place the return code in i2c->msg_idx.
+	 */
+	ret = i2c->msg_idx;
+
+	if (!timeout && i2c->msg_num) {
+		i2c_pxa_scream_blue_murder(i2c, "timeout");
+		ret = I2C_RETRY;
+	}
+
+ out:
+	if (ret < 0)
+		i2c_pxa_reset(i2c);
+
+	return ret;
+}
+
 static int i2c_pxa_do_xfer(struct pxa_i2c *i2c, struct i2c_msg *msg, int num)
 {
 	long timeout;
@@ -750,6 +1106,16 @@ static int i2c_pxa_do_xfer(struct pxa_i2c *i2c, struct i2c_msg *msg, int num)
 		goto out;
 	}
 
+	if (i2c->high_mode) {
+		ret = i2c_pxa_send_mastercode(i2c);
+		if (ret) {
+			dev_err(&i2c->adap.dev, "i2c_pxa_send_mastercode timeout\n");
+			writel(readl(_ICR(i2c)) & ~(ICR_START | ICR_GPIOEN),
+				_ICR(i2c));
+			goto out;
+		}
+	}
+
 	spin_lock_irq(&i2c->lock);
 
 	i2c->msg = msg;
@@ -758,6 +1124,8 @@ static int i2c_pxa_do_xfer(struct pxa_i2c *i2c, struct i2c_msg *msg, int num)
 	i2c->msg_ptr = 0;
 	i2c->irqlogidx = 0;
 
+	pm_qos_update_request(&i2c->qos_idle, PM_QOS_CPUIDLE_BLOCK_DDR_VALUE);
+
 	i2c_pxa_start_message(i2c);
 
 	spin_unlock_irq(&i2c->lock);
@@ -765,9 +1133,12 @@ static int i2c_pxa_do_xfer(struct pxa_i2c *i2c, struct i2c_msg *msg, int num)
 	/*
 	 * The rest of the processing occurs in the interrupt handler.
 	 */
-	timeout = wait_event_timeout(i2c->wait, i2c->msg_num == 0, HZ * 5);
+	timeout = wait_event_timeout(i2c->wait, i2c->msg_num == 0, HZ * 1);
 	i2c_pxa_stop_message(i2c);
 
+	pm_qos_update_request(&i2c->qos_idle,
+			PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+
 	/*
 	 * We place the return code in i2c->msg_idx.
 	 */
@@ -779,6 +1150,9 @@ static int i2c_pxa_do_xfer(struct pxa_i2c *i2c, struct i2c_msg *msg, int num)
 	}
 
  out:
+	if (ret < 0)
+		i2c_pxa_reset(i2c);
+
 	return ret;
 }
 
@@ -787,6 +1161,7 @@ static int i2c_pxa_pio_xfer(struct i2c_adapter *adap,
 {
 	struct pxa_i2c *i2c = adap->algo_data;
 	int ret, i;
+	pr_info("--> %s is called to r/w i2c reg\n", __func__);
 
 	/* If the I2C controller is disabled we need to reset it
 	  (probably due to a suspend/resume destroying state). We do
@@ -826,6 +1201,93 @@ static void i2c_pxa_master_complete(struct pxa_i2c *i2c, int ret)
 		wake_up(&i2c->wait);
 }
 
+static void i2c_pxa_irq_txempty_fifo(struct pxa_i2c *i2c, u32 isr)
+{
+	/*
+	 * If ISR_ALD is set, we lost arbitration.
+	 */
+	if (isr & ISR_ALD) {
+		/*
+		 * Do we need to do anything here?  The PXA docs
+		 * are vague about what happens.
+		 */
+		i2c_pxa_scream_blue_murder(i2c, "ALD set");
+
+		/*
+		 * We ignore this error.  We seem to see spurious ALDs
+		 * for seemingly no reason.  If we handle them as I think
+		 * they should, we end up causing an I2C error, which
+		 * is painful for some systems.
+		 */
+		i2c->fifo_transmit_done = true;
+		wake_up(&i2c->wait);
+		return; /* ignore */
+	}
+
+	if (isr & ISR_BED) {
+		/*
+		 * I2C bus error - either the device NAK'd us, or
+		 * something more serious happened.  If we were NAK'd
+		 * on the initial address phase, we can retry.
+		 */
+		i2c->fifo_transmit_done = true;
+		i2c_pxa_master_complete(i2c, BUS_ERROR);
+		return;
+	}
+
+	if (isr & ISR_RXF) {
+		u32 i;
+
+		if (i2c->msg->flags & I2C_M_RD) {
+			for (i = 0; ((i < I2C_PXA_FIFO_ENTRY_RX) &&
+				(i2c->fifo_read_ptr < i2c->msg->len)); i++)
+				i2c->msg->buf[i2c->fifo_read_ptr++] =
+					readl(_RFIFO(i2c));
+		}
+		writel(ISR_RXF, _ISR(i2c));
+	}
+
+	if (isr & ISR_RXHF) {
+		u32 i;
+
+		/* if receive both RXF & RXHF, read one time in ISR_RXF */
+		if (!(isr & ISR_RXF) && (i2c->msg->flags & I2C_M_RD)) {
+			for (i = 0; ((i < I2C_PXA_FIFO_ENTRY_RX / 2) &&
+				(i2c->fifo_read_ptr < i2c->msg->len)); i++)
+				i2c->msg->buf[i2c->fifo_read_ptr++] =
+					readl(_RFIFO(i2c));
+		}
+		writel(ISR_RXHF, _ISR(i2c));
+	}
+
+	if (isr & ISR_RXOV) {
+		writel(ISR_RXOV, _ISR(i2c));
+		i2c_pxa_scream_blue_murder(i2c, "lost data");
+	}
+
+	if (isr & ISR_TXDONE) {
+		writel(readl(_ICR(i2c)) & ~(ICR_TXE_IE | \
+			ICR_RXHF_IE | ICR_RXF_IE), _ICR(i2c));
+		writel(0xFFFFF, _ISR(i2c));
+
+		if (i2c->msg->flags & I2C_M_RD)
+			while (i2c->fifo_read_ptr < i2c->msg->len)
+				i2c->msg->buf[i2c->fifo_read_ptr++] =
+					readl(_RFIFO(i2c));
+
+		i2c->fifo_transmit_done = true;
+		i2c_pxa_master_complete(i2c, 0);
+		return;
+	}
+
+	if (isr & ISR_TXE) {
+		i2c_pxa_fifo_load(i2c);
+		writel(ISR_TXE, _ISR(i2c));
+	}
+
+	show_state(i2c);
+}
+
 static void i2c_pxa_irq_txempty(struct pxa_i2c *i2c, u32 isr)
 {
 	u32 icr = readl(_ICR(i2c)) & ~(ICR_START|ICR_STOP|ICR_ACKNAK|ICR_TB);
@@ -910,6 +1372,7 @@ static void i2c_pxa_irq_txempty(struct pxa_i2c *i2c, u32 isr)
 		 * Write the next address.
 		 */
 		writel(i2c_pxa_addr_byte(i2c->msg), _IDBR(i2c));
+		i2c->req_slave_addr = i2c_pxa_addr_byte(i2c->msg);
 
 		/*
 		 * And trigger a repeated start, and send the byte.
@@ -963,12 +1426,14 @@ static void i2c_pxa_irq_rxfull(struct pxa_i2c *i2c, u32 isr)
 
 #define VALID_INT_SOURCE	(ISR_SSD | ISR_ALD | ISR_ITE | ISR_IRF | \
 				ISR_SAD | ISR_BED)
+#define FIFO_INT_SOURCE		(ISR_TXE | ISR_TXDONE | ISR_RXHF | \
+				ISR_RXF | ISR_RXOV)
 static irqreturn_t i2c_pxa_handler(int this_irq, void *dev_id)
 {
 	struct pxa_i2c *i2c = dev_id;
 	u32 isr = readl(_ISR(i2c));
 
-	if (!(isr & VALID_INT_SOURCE))
+	if (!(isr & VALID_INT_SOURCE) && !(isr & FIFO_INT_SOURCE))
 		return IRQ_NONE;
 
 	if (i2c_debug > 2 && 0) {
@@ -997,11 +1462,18 @@ static irqreturn_t i2c_pxa_handler(int this_irq, void *dev_id)
 			i2c_pxa_slave_txempty(i2c, isr);
 		if (isr & ISR_IRF)
 			i2c_pxa_slave_rxfull(i2c, isr);
-	} else if (i2c->msg) {
-		if (isr & ISR_ITE)
-			i2c_pxa_irq_txempty(i2c, isr);
-		if (isr & ISR_IRF)
-			i2c_pxa_irq_rxfull(i2c, isr);
+	} else if (i2c->msg && (!i2c->highmode_enter)) {
+		if (i2c->fifo_mode) {
+			i2c_pxa_irq_txempty_fifo(i2c, isr);
+		} else {
+			if (isr & ISR_ITE)
+				i2c_pxa_irq_txempty(i2c, isr);
+			if (isr & ISR_IRF)
+				i2c_pxa_irq_rxfull(i2c, isr);
+		}
+	} else if ((isr & ISR_ITE) && i2c->highmode_enter) {
+		i2c->highmode_enter = false;
+		wake_up(&i2c->wait);
 	} else {
 		i2c_pxa_scream_blue_murder(i2c, "spurious irq");
 	}
@@ -1015,8 +1487,12 @@ static int i2c_pxa_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num
 	struct pxa_i2c *i2c = adap->algo_data;
 	int ret, i;
 
+	enable_irq(i2c->irq);
 	for (i = adap->retries; i >= 0; i--) {
-		ret = i2c_pxa_do_xfer(i2c, msgs, num);
+		if (i2c->fifo_mode)
+			ret = i2c_pxa_do_xfer_fifo(i2c, msgs, num);
+		else
+			ret = i2c_pxa_do_xfer(i2c, msgs, num);
 		if (ret != I2C_RETRY)
 			goto out;
 
@@ -1028,6 +1504,7 @@ static int i2c_pxa_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num
 	ret = -EREMOTEIO;
  out:
 	i2c_pxa_set_slave(i2c, ret);
+	disable_irq(i2c->irq);
 	return ret;
 }
 
@@ -1046,6 +1523,25 @@ static const struct i2c_algorithm i2c_pxa_pio_algorithm = {
 	.functionality	= i2c_pxa_functionality,
 };
 
+int i2c_set_pio_mode(void)
+{
+	printk(KERN_EMERG "Set I2C to PIO mode\n");
+	i2c_global->adap.algo = &i2c_pxa_pio_algorithm;
+	return 0;
+}
+
+static int panic_notifier_func(struct notifier_block *this,
+		unsigned long code, void *cmd)
+{
+	i2c_global->adap.algo = &i2c_pxa_pio_algorithm;
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block panic_block = {
+	.notifier_call = panic_notifier_func,
+	.next = NULL,
+	.priority = INT_MAX,
+};
 static struct of_device_id i2c_pxa_dt_ids[] = {
 	{ .compatible = "mrvl,pxa-i2c", .data = (void *)REGS_PXA2XX },
 	{ .compatible = "mrvl,pwri2c", .data = (void *)REGS_PXA3XX },
@@ -1089,6 +1585,7 @@ static int i2c_pxa_probe_pdata(struct platform_device *pdev,
 	if (plat) {
 		i2c->use_pio = plat->use_pio;
 		i2c->fast_mode = plat->fast_mode;
+		i2c->fifo_mode = plat->fifo_mode;
 	}
 	return 0;
 }
@@ -1101,6 +1598,8 @@ static int i2c_pxa_probe(struct platform_device *dev)
 	struct resource *res = NULL;
 	int ret, irq;
 
+	int pm_qos_class = PM_QOS_CPUIDLE_BLOCK;
+
 	i2c = kzalloc(sizeof(struct pxa_i2c), GFP_KERNEL);
 	if (!i2c) {
 		ret = -ENOMEM;
@@ -1111,22 +1610,26 @@ static int i2c_pxa_probe(struct platform_device *dev)
 	if (ret > 0)
 		ret = i2c_pxa_probe_pdata(dev, i2c, &i2c_type);
 	if (ret < 0)
-		goto eclk;
+		goto eres;
 
 	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
 	irq = platform_get_irq(dev, 0);
 	if (res == NULL || irq < 0) {
 		ret = -ENODEV;
-		goto eclk;
+		goto eres;
 	}
 
 	if (!request_mem_region(res->start, resource_size(res), res->name)) {
 		ret = -ENOMEM;
-		goto eclk;
+		goto eres;
 	}
 
 	i2c->adap.owner   = THIS_MODULE;
-	i2c->adap.retries = 5;
+	i2c->adap.retries = 3;
+
+	i2c->qos_idle.name = i2c->adap.name;
+	pm_qos_add_request(&i2c->qos_idle, pm_qos_class,
+			PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
 
 	spin_lock_init(&i2c->lock);
 	init_waitqueue_head(&i2c->wait);
@@ -1158,6 +1661,21 @@ static int i2c_pxa_probe(struct platform_device *dev)
 	i2c->reg_isr = i2c->reg_base + pxa_reg_layout[i2c_type].isr;
 	if (i2c_type != REGS_CE4100)
 		i2c->reg_isar = i2c->reg_base + pxa_reg_layout[i2c_type].isar;
+	i2c->reg_ilcr = i2c->reg_base + pxa_reg_layout[i2c_type].ilcr;
+	i2c->reg_iwcr = i2c->reg_base + pxa_reg_layout[i2c_type].iwcr;
+
+	if (i2c->fifo_mode) {
+		i2c->reg_wfifo = i2c->reg_base + pxa_reg_layout[i2c_type].wfifo;
+		i2c->reg_wfifo_wptr = i2c->reg_base +
+				pxa_reg_layout[i2c_type].wfifo_wptr;
+		i2c->reg_wfifo_rptr = i2c->reg_base +
+				pxa_reg_layout[i2c_type].wfifo_rptr;
+		i2c->reg_rfifo = i2c->reg_base + pxa_reg_layout[i2c_type].rfifo;
+		i2c->reg_rfifo_wptr = i2c->reg_base +
+				pxa_reg_layout[i2c_type].rfifo_wptr;
+		i2c->reg_rfifo_rptr = i2c->reg_base +
+				pxa_reg_layout[i2c_type].rfifo_rptr;
+	}
 
 	i2c->iobase = res->start;
 	i2c->iosize = resource_size(res);
@@ -1165,6 +1683,7 @@ static int i2c_pxa_probe(struct platform_device *dev)
 	i2c->irq = irq;
 
 	i2c->slave_addr = I2C_PXA_SLAVE_ADDR;
+	i2c->highmode_enter = false;
 
 	if (plat) {
 #ifdef CONFIG_I2C_PXA_SLAVE
@@ -1172,6 +1691,20 @@ static int i2c_pxa_probe(struct platform_device *dev)
 		i2c->slave = plat->slave;
 #endif
 		i2c->adap.class = plat->class;
+		i2c->adap.hardware_lock = plat->hardware_lock;
+		i2c->adap.hardware_unlock = plat->hardware_unlock;
+		i2c->adap.hardware_trylock = plat->hardware_trylock;
+		i2c->high_mode = plat->high_mode;
+		i2c->master_code = plat->master_code;
+		i2c->ilcr = plat->ilcr;
+		i2c->iwcr = plat->iwcr;
+	}
+
+	if (i2c->high_mode) {
+		clk_set_rate(i2c->clk, 62400000);
+		printk(KERN_INFO "i2c: <%s> set rate to %ld\n", \
+			i2c->adap.name, clk_get_rate(i2c->clk));
+
 	}
 
 	clk_enable(i2c->clk);
@@ -1180,13 +1713,24 @@ static int i2c_pxa_probe(struct platform_device *dev)
 		i2c->adap.algo = &i2c_pxa_pio_algorithm;
 	} else {
 		i2c->adap.algo = &i2c_pxa_algorithm;
-		ret = request_irq(irq, i2c_pxa_handler, IRQF_SHARED,
-				  i2c->adap.name, i2c);
+		ret = request_irq(irq, i2c_pxa_handler,
+				IRQF_SHARED | IRQF_NO_SUSPEND,
+				i2c->adap.name, i2c);
 		if (ret)
 			goto ereqirq;
 	}
 
 	i2c_pxa_reset(i2c);
+#if defined(CONFIG_MACH_HELANDELOS) || defined(CONFIG_MACH_WILCOX) || defined(CONFIG_MACH_CS02) || defined(CONFIG_MACH_LT02) \
+	|| defined(CONFIG_MACH_BAFFIN) || defined(CONFIG_MACH_CT01) || defined(CONFIG_MACH_CS05) || defined(CONFIG_MACH_BAFFINQ) \
+	|| defined(CONFIG_MACH_GOLDEN) ||defined(CONFIG_MACH_GOYA) || defined(CONFIG_MACH_DEGAS)
+	/* For samsung aruba, camera maybe pull down all i2c pins which leads to wrong state of AP side*/
+	//if (i2c->adap.nr == 0x0) {
+	//	samsung_camera.i2c_pxa_reset = i2c_pxa_reset;
+	//	samsung_camera.i2c = i2c;
+	//}
+#endif 
+	disable_irq(i2c->irq);
 
 	i2c->adap.algo_data = i2c;
 	i2c->adap.dev.parent = &dev->dev;
@@ -1203,6 +1747,8 @@ static int i2c_pxa_probe(struct platform_device *dev)
 
 	platform_set_drvdata(dev, i2c);
 
+	i2c_global = i2c;
+
 #ifdef CONFIG_I2C_PXA_SLAVE
 	printk(KERN_INFO "I2C: %s: PXA I2C adapter, slave address %d\n",
 	       dev_name(&i2c->adap.dev), i2c->slave_addr);
@@ -1221,9 +1767,11 @@ ereqirq:
 eremap:
 	clk_put(i2c->clk);
 eclk:
+	pm_qos_remove_request(&i2c->qos_idle);
+	release_mem_region(res->start, resource_size(res));
+eres:
 	kfree(i2c);
 emalloc:
-	release_mem_region(res->start, resource_size(res));
 	return ret;
 }
 
@@ -1232,6 +1780,7 @@ static int __exit i2c_pxa_remove(struct platform_device *dev)
 	struct pxa_i2c *i2c = platform_get_drvdata(dev);
 
 	platform_set_drvdata(dev, NULL);
+	pm_qos_remove_request(&i2c->qos_idle);
 
 	i2c_del_adapter(&i2c->adap);
 	if (!i2c->use_pio)
@@ -1247,45 +1796,12 @@ static int __exit i2c_pxa_remove(struct platform_device *dev)
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int i2c_pxa_suspend_noirq(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct pxa_i2c *i2c = platform_get_drvdata(pdev);
-
-	clk_disable(i2c->clk);
-
-	return 0;
-}
-
-static int i2c_pxa_resume_noirq(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct pxa_i2c *i2c = platform_get_drvdata(pdev);
-
-	clk_enable(i2c->clk);
-	i2c_pxa_reset(i2c);
-
-	return 0;
-}
-
-static const struct dev_pm_ops i2c_pxa_dev_pm_ops = {
-	.suspend_noirq = i2c_pxa_suspend_noirq,
-	.resume_noirq = i2c_pxa_resume_noirq,
-};
-
-#define I2C_PXA_DEV_PM_OPS (&i2c_pxa_dev_pm_ops)
-#else
-#define I2C_PXA_DEV_PM_OPS NULL
-#endif
-
 static struct platform_driver i2c_pxa_driver = {
 	.probe		= i2c_pxa_probe,
 	.remove		= __exit_p(i2c_pxa_remove),
 	.driver		= {
 		.name	= "pxa2xx-i2c",
 		.owner	= THIS_MODULE,
-		.pm	= I2C_PXA_DEV_PM_OPS,
 		.of_match_table = i2c_pxa_dt_ids,
 	},
 	.id_table	= i2c_pxa_id_table,
@@ -1293,6 +1809,8 @@ static struct platform_driver i2c_pxa_driver = {
 
 static int __init i2c_adap_pxa_init(void)
 {
+	atomic_notifier_chain_register(&panic_notifier_list,
+				       &panic_block);
 	return platform_driver_register(&i2c_pxa_driver);
 }
 
diff --git a/drivers/i2c/chips/Kconfig b/drivers/i2c/chips/Kconfig
new file mode 100755
index 00000000..6512090b
--- /dev/null
+++ b/drivers/i2c/chips/Kconfig
@@ -0,0 +1,41 @@
+config SENSORS_CORE
+	tristate "Sensors core"
+	default n
+	help
+	  Say Y here to enable debugging messages for power supply class
+	  and drivers.
+
+config SENSORS_GP2A002S
+	tristate "gp2a proximity_sensor"
+	default n
+	help
+	  This option enables magnetic sensors using gp2a002s proximity driver.
+
+config SENSORS_GP2A030
+	depends on I2C
+	tristate "GP2AP030 driver"
+	default n
+	help
+	  This option enables proximity & light sensors using gp2ap030 driver.
+
+config SENSORS_BMA2X2
+	tristate "BMA255/BMA250E/BMA222E/BMA280 acceleration sensor support"
+	depends on I2C=y
+	help
+	  If you say yes here you get support for Bosch Sensortec's 
+	  acceleration sensors BMA255/BMA250E/BMA222E/BMA280.
+
+
+config SENSORS_BMM050
+	tristate "BMM050 Magnetic Sensor Driver"
+	depends on I2C=y
+	help
+	 BMM050 Magnetic Sensor Driver implemented by Bosch-Sensortec.
+	 
+config INPUT_BMA2x2_ACC_ALERT_INT
+	tristate "BMA255/BMA250E/BMA222E/BMA280 acceleration sensor support"
+	depends on I2C=y
+	help
+	  If you say yes here you get support for Bosch Sensortec's 
+	  acceleration sensors BMA255/BMA250E/BMA222E/BMA280.	
+	 
diff --git a/drivers/i2c/chips/Makefile b/drivers/i2c/chips/Makefile
new file mode 100755
index 00000000..8513848c
--- /dev/null
+++ b/drivers/i2c/chips/Makefile
@@ -0,0 +1,7 @@
+
+obj-$(CONFIG_SENSORS_CORE)		+= sensors_core.o
+obj-$(CONFIG_SENSORS_GP2A002S)	+= gp2a.o
+obj-$(CONFIG_SENSORS_GP2A030)		+= gp2ap030.o
+obj-$(CONFIG_SENSORS_BMA2X2)	+= bma2x2_driver.o bst_sensor_common.o      
+obj-$(CONFIG_SENSORS_BMM050)	+= bmm050_driver.o bmm050.o
+
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index feb7dc35..680601d1 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -449,8 +449,11 @@ void i2c_lock_adapter(struct i2c_adapter *adapter)
 
 	if (parent)
 		i2c_lock_adapter(parent);
-	else
+	else {
 		rt_mutex_lock(&adapter->bus_lock);
+		if (adapter->hardware_lock)
+			adapter->hardware_lock();
+	}
 }
 EXPORT_SYMBOL_GPL(i2c_lock_adapter);
 
@@ -461,11 +464,19 @@ EXPORT_SYMBOL_GPL(i2c_lock_adapter);
 static int i2c_trylock_adapter(struct i2c_adapter *adapter)
 {
 	struct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);
+	int ret = 0;
 
 	if (parent)
 		return i2c_trylock_adapter(parent);
-	else
-		return rt_mutex_trylock(&adapter->bus_lock);
+	else {
+		ret = rt_mutex_trylock(&adapter->bus_lock);
+		if (ret && adapter->hardware_trylock) {
+			ret = adapter->hardware_trylock();
+			if (!ret)
+				i2c_unlock_adapter(adapter);
+		}
+		return ret;
+	}
 }
 
 /**
@@ -478,8 +489,11 @@ void i2c_unlock_adapter(struct i2c_adapter *adapter)
 
 	if (parent)
 		i2c_unlock_adapter(parent);
-	else
+	else {
+		if (adapter->hardware_unlock)
+			adapter->hardware_unlock();
 		rt_mutex_unlock(&adapter->bus_lock);
+	}
 }
 EXPORT_SYMBOL_GPL(i2c_unlock_adapter);
 
diff --git a/drivers/input/Kconfig b/drivers/input/Kconfig
index 33259798..69d36863 100644
--- a/drivers/input/Kconfig
+++ b/drivers/input/Kconfig
@@ -165,6 +165,15 @@ config INPUT_APMPOWER
 	  To compile this driver as a module, choose M here: the
 	  module will be called apm-power.
 
+config INPUT_KEYRESET
+	tristate "Reset key"
+	depends on INPUT
+	---help---
+	  Say Y here if you want to reboot when some keys are pressed;
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called keyreset.
+
 comment "Input Device Drivers"
 
 source "drivers/input/keyboard/Kconfig"
diff --git a/drivers/input/Makefile b/drivers/input/Makefile
index b173a13a..cf643bee 100644
--- a/drivers/input/Makefile
+++ b/drivers/input/Makefile
@@ -25,3 +25,4 @@ obj-$(CONFIG_INPUT_MISC)	+= misc/
 
 obj-$(CONFIG_INPUT_APMPOWER)	+= apm-power.o
 obj-$(CONFIG_INPUT_OF_MATRIX_KEYMAP) += of_keymap.o
+obj-$(CONFIG_INPUT_KEYRESET)	+= keyreset.o
diff --git a/drivers/input/evdev.c b/drivers/input/evdev.c
index 4b2e10d5..a9374387 100644
--- a/drivers/input/evdev.c
+++ b/drivers/input/evdev.c
@@ -23,6 +23,7 @@
 #include <linux/input/mt.h>
 #include <linux/major.h>
 #include <linux/device.h>
+#include <linux/wakelock.h>
 #include "input-compat.h"
 
 struct evdev {
@@ -43,6 +44,9 @@ struct evdev_client {
 	unsigned int tail;
 	unsigned int packet_head; /* [future] position of the first element of next packet */
 	spinlock_t buffer_lock; /* protects access to buffer, head and tail */
+	struct wake_lock wake_lock;
+	bool use_wake_lock;
+	char name[28];
 	struct fasync_struct *fasync;
 	struct evdev *evdev;
 	struct list_head node;
@@ -80,10 +84,14 @@ static void evdev_pass_event(struct evdev_client *client,
 		client->buffer[client->tail].value = 0;
 
 		client->packet_head = client->tail;
+		if (client->use_wake_lock)
+			wake_unlock(&client->wake_lock);
 	}
 
 	if (event->type == EV_SYN && event->code == SYN_REPORT) {
 		client->packet_head = client->head;
+		if (client->use_wake_lock)
+			wake_lock(&client->wake_lock);
 		kill_fasync(&client->fasync, SIGIO, POLL_IN);
 	}
 
@@ -264,6 +272,8 @@ static int evdev_release(struct inode *inode, struct file *file)
 	mutex_unlock(&evdev->mutex);
 
 	evdev_detach_client(evdev, client);
+	if (client->use_wake_lock)
+		wake_lock_destroy(&client->wake_lock);
 	kfree(client);
 
 	evdev_close_device(evdev);
@@ -315,6 +325,8 @@ static int evdev_open(struct inode *inode, struct file *file)
 
 	client->bufsize = bufsize;
 	spin_lock_init(&client->buffer_lock);
+	snprintf(client->name, sizeof(client->name), "%s-%d",
+			dev_name(&evdev->dev), task_tgid_vnr(current));
 	client->evdev = evdev;
 	evdev_attach_client(evdev, client);
 
@@ -382,6 +394,9 @@ static int evdev_fetch_next_event(struct evdev_client *client,
 	if (have_event) {
 		*event = client->buffer[client->tail++];
 		client->tail &= client->bufsize - 1;
+		if (client->use_wake_lock &&
+		    client->packet_head == client->tail)
+			wake_unlock(&client->wake_lock);
 	}
 
 	spin_unlock_irq(&client->buffer_lock);
@@ -654,6 +669,35 @@ static int evdev_handle_mt_request(struct input_dev *dev,
 	return 0;
 }
 
+static int evdev_enable_suspend_block(struct evdev *evdev,
+				      struct evdev_client *client)
+{
+	if (client->use_wake_lock)
+		return 0;
+
+	spin_lock_irq(&client->buffer_lock);
+	wake_lock_init(&client->wake_lock, WAKE_LOCK_SUSPEND, client->name);
+	client->use_wake_lock = true;
+	if (client->packet_head != client->tail)
+		wake_lock(&client->wake_lock);
+	spin_unlock_irq(&client->buffer_lock);
+	return 0;
+}
+
+static int evdev_disable_suspend_block(struct evdev *evdev,
+				       struct evdev_client *client)
+{
+	if (!client->use_wake_lock)
+		return 0;
+
+	spin_lock_irq(&client->buffer_lock);
+	client->use_wake_lock = false;
+	wake_lock_destroy(&client->wake_lock);
+	spin_unlock_irq(&client->buffer_lock);
+
+	return 0;
+}
+
 static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 			   void __user *p, int compat_mode)
 {
@@ -735,6 +779,15 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 
 	case EVIOCSKEYCODE_V2:
 		return evdev_handle_set_keycode_v2(dev, p);
+
+	case EVIOCGSUSPENDBLOCK:
+		return put_user(client->use_wake_lock, ip);
+
+	case EVIOCSSUSPENDBLOCK:
+		if (p)
+			return evdev_enable_suspend_block(evdev, client);
+		else
+			return evdev_disable_suspend_block(evdev, client);
 	}
 
 	size = _IOC_SIZE(cmd);
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 8921c618..5d64aeae 100644
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -28,6 +28,9 @@
 #include <linux/rcupdate.h>
 #include "input-compat.h"
 
+#ifdef CONFIG_SEC_DEBUG
+#include <mach/sec_debug.h>
+#endif
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
 MODULE_DESCRIPTION("Input core");
 MODULE_LICENSE("GPL");
@@ -242,7 +245,10 @@ static void input_handle_event(struct input_dev *dev,
 	case EV_KEY:
 		if (is_event_supported(code, dev->keybit, KEY_MAX) &&
 		    !!test_bit(code, dev->key) != value) {
-
+#if defined(CONFIG_SEC_DEBUG)
+                if(code == KEY_VOLUMEDOWN || code == KEY_VOLUMEUP || code == KEY_POWER)
+                        sec_debug_check_crash_key(code, value);
+#endif
 			if (value != 2) {
 				__change_bit(code, dev->key);
 				if (value)
@@ -1592,7 +1598,10 @@ static int input_dev_suspend(struct device *dev)
 
 	if (input_dev->users)
 		input_dev_toggle(input_dev, false);
-
+#if defined(CONFIG_SEC_DEBUG)	// send dummy release event to avoid invalid key crash case
+	sec_debug_check_crash_key(KEY_VOLUMEUP, 0);
+	sec_debug_check_crash_key(KEY_VOLUMEDOWN, 0);
+#endif
 	mutex_unlock(&input_dev->mutex);
 
 	return 0;
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index f354813a..f69d301b 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -580,4 +580,13 @@ config KEYBOARD_W90P910
 	  To compile this driver as a module, choose M here: the
 	  module will be called w90p910_keypad.
 
+config KEYBOARD_TC360
+        tristate "CORERIVER TC360 touchkey support"
+        depends on I2C
+        help
+          Say Y here if you want to use the CORERIVER TC360 touchkey.
+
+          To compile this driver as a module, choose M here: the
+          module will be called touchcore.
+
 endif
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index df7061f1..1dc1cce3 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -52,3 +52,4 @@ obj-$(CONFIG_KEYBOARD_TNETV107X)	+= tnetv107x-keypad.o
 obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
 obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
 obj-$(CONFIG_KEYBOARD_W90P910)		+= w90p910_keypad.o
+obj-$(CONFIG_KEYBOARD_TC360)            += tc360-touchkey.o
diff --git a/drivers/input/keyboard/gpio_keys.c b/drivers/input/keyboard/gpio_keys.c
index 62bfce46..30a0725a 100644
--- a/drivers/input/keyboard/gpio_keys.c
+++ b/drivers/input/keyboard/gpio_keys.c
@@ -30,6 +30,38 @@
 #include <linux/of_gpio.h>
 #include <linux/spinlock.h>
 
+#if defined(CONFIG_MACH_LT02)
+#include <mach/mfp-pxa986-lt02.h>
+#elif defined(CONFIG_MACH_BAFFIN)
+#include <mach/mfp-pxa988-baffin.h>
+#elif defined(CONFIG_MACH_BAFFINQ)
+#include <mach/mfp-pxa1088-baffinq.h>
+#elif defined(CONFIG_MACH_GOLDEN)
+#include <mach/mfp-pxa986-golden.h>
+#elif defined(CONFIG_MACH_GOYA)
+#include <mach/mfp-pxa986-goya.h>
+#elif defined(CONFIG_MACH_DEGAS)
+#include <mach/mfp-pxa1088-degas.h>
+#endif
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#include <linux/delay.h>
+#include <mach/gpio-edge.h>
+#endif
+
+extern struct class *sec_class;
+#if defined(CONFIG_KERNEL_DEBUG_SEC) && defined(CONFIG_MACH_LT02)
+extern struct class *sec_class;
+extern struct class *touchkey_class;
+extern int jack_is_detected;
+extern unsigned int sec_debug_mode;
+static bool g_bVolUp;
+static bool g_bPower;
+static bool g_bHome;
+static struct timer_list debug_timer;
+struct device *led;
+#endif
+
 struct gpio_button_data {
 	const struct gpio_keys_button *button;
 	struct input_dev *input;
@@ -40,10 +72,20 @@ struct gpio_button_data {
 	spinlock_t lock;
 	bool disabled;
 	bool key_pressed;
+#if !defined(CONFIG_MACH_CS05) // "CS05 model" use gpio-key(projector key) and pxa27x-keypad both.
+	bool key_state;
+#endif
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	struct gpio_edge_desc *gpio_key;
+	struct delayed_work input_work;
+#endif
 };
 
 struct gpio_keys_drvdata {
 	struct input_dev *input;
+#if !defined(CONFIG_MACH_CS05) // "CS05 model" use gpio-key(projector key) and pxa27x-keypad both.
+	struct device *sec_key;
+#endif
 	struct mutex disable_lock;
 	unsigned int n_buttons;
 	int (*enable)(struct device *dev);
@@ -324,6 +366,97 @@ static struct attribute_group gpio_keys_attr_group = {
 	.attrs = gpio_keys_attrs,
 };
 
+#if defined(CONFIG_KERNEL_DEBUG_SEC) && defined(CONFIG_MACH_LT02)
+void enter_upload_mode(unsigned long val)
+{
+	if (g_bVolUp && jack_is_detected && g_bPower)
+		if (sec_debug_mode == DEBUG_LEVEL_MID || sec_debug_mode == DEBUG_LEVEL_HIGH) {
+			//dump_all_task_info();
+			//dump_cpu_stat();
+			panic("__forced_upload");
+		}
+}
+
+bool gpio_keys_getstate(int keycode)
+{
+	switch (keycode) {
+	case KEY_VOLUMEUP:
+		return g_bVolUp;
+	case KEY_POWER:
+		return g_bPower;
+	case KEY_HOMEPAGE:
+		return g_bHome;
+	default:
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(gpio_keys_getstate);
+
+void gpio_keys_setstate(int keycode, bool bState)
+{
+	switch (keycode) {
+	case KEY_VOLUMEUP:
+		g_bVolUp = bState;
+		break;
+	case KEY_POWER:
+		g_bPower = bState;
+		break;
+	case KEY_HOMEPAGE:
+		g_bHome = bState;
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_keys_setstate);
+
+void gpio_keys_start_upload_modtimer(void)
+{
+	mod_timer(&debug_timer, jiffies + HZ*1);
+	printk(KERN_ERR "%s Waiting for upload mode for 1 second.\n", __func__);
+}
+EXPORT_SYMBOL(gpio_keys_start_upload_modtimer);
+#endif
+
+#if !defined(CONFIG_MACH_CS05) // "CS05 model" use gpio-key(projector key) and pxa27x-keypad both.
+static ssize_t key_pressed_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct gpio_keys_drvdata *ddata = dev_get_drvdata(dev);
+	int i;
+	int keystate = 0;
+
+	for (i = 0; i < ddata->n_buttons; i++) {
+		struct gpio_button_data *bdata = &ddata->data[i];
+		keystate |= bdata->key_state;
+	}
+
+	if (keystate)
+		sprintf(buf, "PRESS");
+	else
+		sprintf(buf, "RELEASE");
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(sec_key_pressed, 0664, key_pressed_show, NULL);
+
+static struct attribute *sec_key_attrs[] = {
+	&dev_attr_sec_key_pressed.attr,
+	NULL,
+};
+
+static struct attribute_group sec_key_attr_group = {
+	.attrs = sec_key_attrs,
+};
+#endif
+
+#if defined(CONFIG_SEC_DEBUG)
+#if !defined(CONFIG_MACH_CS05) // "CS05 model" use gpio-key(projector key) and pxa27x-keypad both.
+extern void sec_debug_check_crash_key(unsigned int code, int value);
+#endif
+#endif
+
 static void gpio_keys_gpio_report_event(struct gpio_button_data *bdata)
 {
 	const struct gpio_keys_button *button = bdata->button;
@@ -331,10 +464,40 @@ static void gpio_keys_gpio_report_event(struct gpio_button_data *bdata)
 	unsigned int type = button->type ?: EV_KEY;
 	int state = (gpio_get_value_cansleep(button->gpio) ? 1 : 0) ^ button->active_low;
 
+#if defined(CONFIG_SEC_DEBUG)
+#if !defined(CONFIG_MACH_CS05) // "CS05 model" use gpio-key(projector key) and pxa27x-keypad both.
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+	printk(KERN_DEBUG "[KEY] key: %d gpio_keys_report_event state = %d \n", button->code, state);
+#endif
+	sec_debug_check_crash_key(button->code,state);
+#endif
+#endif
+
+//printk("[KEY] key: %s gpio_keys_report_event state = %d,  code :%d, real_state:%d\n", button->desc, state, button->code, gpio_get_value_cansleep(button->gpio));
+#if defined(CONFIG_KERNEL_DEBUG_SEC) && defined(CONFIG_MACH_LT02)
+	printk(KERN_DEBUG "[KEY] key: %s gpio_keys_report_event state = %d \n", button->desc, state);
+
+	bool bState = state ? true : false;
+	switch (button->code)
+	{
+	case KEY_VOLUMEUP:
+		g_bVolUp = bState;
+		break;
+	case KEY_HOMEPAGE:
+		g_bHome = bState;
+		break;
+	default:
+		break;
+	}
+#endif
+
 	if (type == EV_ABS) {
 		if (state)
 			input_event(input, type, button->code, button->value);
 	} else {
+#if !defined(CONFIG_MACH_CS05) // "CS05 model" use gpio-key(projector key) and pxa27x-keypad both.
+		bdata->key_state = !!state;
+#endif
 		input_event(input, type, button->code, !!state);
 	}
 	input_sync(input);
@@ -360,7 +523,9 @@ static irqreturn_t gpio_keys_gpio_isr(int irq, void *dev_id)
 	struct gpio_button_data *bdata = dev_id;
 
 	BUG_ON(irq != bdata->irq);
-
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+	printk("%s\n",__func__);
+#endif
 	if (bdata->timer_debounce)
 		mod_timer(&bdata->timer,
 			jiffies + msecs_to_jiffies(bdata->timer_debounce));
@@ -393,7 +558,9 @@ static irqreturn_t gpio_keys_irq_isr(int irq, void *dev_id)
 	unsigned long flags;
 
 	BUG_ON(irq != bdata->irq);
-
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+	printk("gpio_keys_irq_isr\n");
+#endif
 	spin_lock_irqsave(&bdata->lock, flags);
 
 	if (!bdata->key_pressed) {
@@ -417,6 +584,27 @@ out:
 	return IRQ_HANDLED;
 }
 
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+static void pxa27x_keypad_delay_wq(struct work_struct *work)
+{
+	struct gpio_button_data *bdata =
+		container_of(work, struct gpio_button_data, input_work.work);
+
+	input_report_key(bdata->input, bdata->button->code, 1);
+	input_report_key(bdata->input, bdata->button->code, 0);
+	input_sync(bdata->input);
+	return;
+}
+
+void trigger_wakeup(int mfp, void *data)
+{
+	struct gpio_button_data *bdata = ((struct gpio_button_data *)data);
+
+	//schedule_delayed_work(&bdata->input_work, msecs_to_jiffies(10));
+	return;
+}
+#endif
+
 static int __devinit gpio_keys_setup_key(struct platform_device *pdev,
 					 struct input_dev *input,
 					 struct gpio_button_data *bdata,
@@ -468,6 +656,16 @@ static int __devinit gpio_keys_setup_key(struct platform_device *pdev,
 		}
 		bdata->irq = irq;
 
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+		if (button->wakeup) {
+			bdata->gpio_key = kzalloc(sizeof(struct gpio_edge_desc), GFP_KERNEL);
+			bdata->gpio_key->mfp = button->gpio;
+			bdata->gpio_key->handler = trigger_wakeup;
+			bdata->gpio_key->data = bdata;
+			mmp_gpio_edge_add(bdata->gpio_key);
+			INIT_DELAYED_WORK(&bdata->input_work, pxa27x_keypad_delay_wq);
+		}
+#endif
 		INIT_WORK(&bdata->work, gpio_keys_gpio_work_func);
 		setup_timer(&bdata->timer,
 			    gpio_keys_gpio_timer, (unsigned long)bdata);
@@ -640,6 +838,7 @@ static void gpio_remove_key(struct gpio_button_data *bdata)
 	if (bdata->timer_debounce)
 		del_timer_sync(&bdata->timer);
 	cancel_work_sync(&bdata->work);
+	cancel_delayed_work_sync(&bdata->input_work);
 	if (gpio_is_valid(bdata->button->gpio))
 		gpio_free(bdata->button->gpio);
 }
@@ -653,7 +852,7 @@ static int __devinit gpio_keys_probe(struct platform_device *pdev)
 	struct input_dev *input;
 	int i, error;
 	int wakeup = 0;
-
+	printk("gpio_keys_probe\n");
 	if (!pdata) {
 		error = gpio_keys_get_devtree_pdata(dev, &alt_pdata);
 		if (error)
@@ -695,6 +894,11 @@ static int __devinit gpio_keys_probe(struct platform_device *pdev)
 	if (pdata->rep)
 		__set_bit(EV_REP, input->evbit);
 
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_set_capability(input, EV_MSC, MSC_SCAN);
+#endif
+
 	for (i = 0; i < pdata->nbuttons; i++) {
 		const struct gpio_keys_button *button = &pdata->buttons[i];
 		struct gpio_button_data *bdata = &ddata->data[i];
@@ -714,6 +918,18 @@ static int __devinit gpio_keys_probe(struct platform_device *pdev)
 		goto fail2;
 	}
 
+#if !defined(CONFIG_MACH_CS05) // "CS05 model" use gpio-key(projector key) and pxa27x-keypad both.
+	ddata->sec_key = device_create(sec_class, NULL, 0, ddata, "sec_key");
+	if (IS_ERR(ddata->sec_key))
+		dev_err(dev, "Failed to create sec_key device\n");
+
+	error = sysfs_create_group(&ddata->sec_key->kobj, &sec_key_attr_group);
+	if (error) {
+		dev_err(dev, "Unable to export sec_key device, error: %d\n", error);
+		goto fail2;
+	}
+#endif
+
 	error = input_register_device(input);
 	if (error) {
 		dev_err(dev, "Unable to register input device, error: %d\n",
@@ -731,10 +947,19 @@ static int __devinit gpio_keys_probe(struct platform_device *pdev)
 
 	device_init_wakeup(&pdev->dev, wakeup);
 
+#if defined(CONFIG_KERNEL_DEBUG_SEC) && defined(CONFIG_MACH_LT02)
+	/* Initialize for Forced Upload mode */
+	init_timer(&debug_timer);
+	debug_timer.function = enter_upload_mode;
+#endif
+
 	return 0;
 
  fail3:
 	sysfs_remove_group(&pdev->dev.kobj, &gpio_keys_attr_group);
+#if !defined(CONFIG_MACH_CS05) // "CS05 model" use gpio-key(projector key) and pxa27x-keypad both.
+	sysfs_remove_group(&ddata->sec_key->kobj, &sec_key_attr_group);
+#endif
  fail2:
 	while (--i >= 0)
 		gpio_remove_key(&ddata->data[i]);
@@ -829,15 +1054,17 @@ static struct platform_driver gpio_keys_device_driver = {
 
 static int __init gpio_keys_init(void)
 {
+	printk("%s\n",__func__);
 	return platform_driver_register(&gpio_keys_device_driver);
 }
 
 static void __exit gpio_keys_exit(void)
 {
+	printk("%s\n",__func__);
 	platform_driver_unregister(&gpio_keys_device_driver);
 }
 
-late_initcall(gpio_keys_init);
+module_init(gpio_keys_init);
 module_exit(gpio_keys_exit);
 
 MODULE_LICENSE("GPL");
diff --git a/drivers/input/keyreset.c b/drivers/input/keyreset.c
new file mode 100644
index 00000000..87efdd41
--- /dev/null
+++ b/drivers/input/keyreset.c
@@ -0,0 +1,263 @@
+/* drivers/input/keyreset.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/input.h>
+#include <linux/keyreset.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/reboot.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/syscalls.h>
+
+
+struct keyreset_state {
+	struct input_handler input_handler;
+	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
+	unsigned long upbit[BITS_TO_LONGS(KEY_CNT)];
+	unsigned long key[BITS_TO_LONGS(KEY_CNT)];
+	spinlock_t lock;
+	int key_down_target;
+	int key_down;
+	int key_up;
+	int restart_disabled;
+	int need_panic;
+	int (*reset_fn)(void);
+	int (*dump_fn)(int);
+	int dump_pressed;
+};
+
+int restart_requested;
+static void deferred_restart(struct work_struct *dummy)
+{
+	restart_requested = 2;
+	sys_sync();
+	restart_requested = 3;
+	kernel_restart(NULL);
+}
+static DECLARE_WORK(restart_work, deferred_restart);
+
+static void keyreset_event(struct input_handle *handle, unsigned int type,
+			   unsigned int code, int value)
+{
+	unsigned long flags;
+	struct keyreset_state *state = handle->private;
+
+	if (type != EV_KEY)
+		return;
+
+	if (code >= KEY_MAX)
+		return;
+
+	if (!test_bit(code, state->keybit))
+		return;
+
+	spin_lock_irqsave(&state->lock, flags);
+	if (!test_bit(code, state->key) == !value)
+		goto done;
+	__change_bit(code, state->key);
+	if (test_bit(code, state->upbit)) {
+		if (value) {
+			state->restart_disabled = 1;
+			state->key_up++;
+		} else
+			state->key_up--;
+	} else {
+		if (value)
+			state->key_down++;
+		else
+			state->key_down--;
+	}
+	if (state->key_down == 0 && state->key_up == 0)
+		state->restart_disabled = 0;
+
+	pr_debug("reset key changed %d %d new state %d-%d-%d\n", code, value,
+		 state->key_down, state->key_up, state->restart_disabled);
+
+	if (value && !state->restart_disabled &&
+	    state->key_down == state->key_down_target) {
+		state->restart_disabled = 1;
+		if (state->need_panic) {
+			panic("Kernel Panic trigger by keyboard!!!\n");
+			while(1);
+		}
+		if (restart_requested)
+			panic("keyboard reset failed, %d", restart_requested);
+		if (state->reset_fn) {
+			restart_requested = state->reset_fn();
+		} else {
+			pr_info("keyboard reset\n");
+			schedule_work(&restart_work);
+			restart_requested = 1;
+		}
+	}
+
+	if (state->key_down == state->key_down_target) {
+		state->dump_pressed = 1;
+		if (state->dump_fn)
+			restart_requested = state->dump_fn(1);
+	} else if (state->dump_pressed == 1) {
+		state->dump_pressed = 0;
+		if (state->dump_fn)
+			restart_requested = state->dump_fn(0);
+	}
+
+done:
+	spin_unlock_irqrestore(&state->lock, flags);
+}
+
+static int keyreset_connect(struct input_handler *handler,
+					  struct input_dev *dev,
+					  const struct input_device_id *id)
+{
+	int i;
+	int ret;
+	struct input_handle *handle;
+	struct keyreset_state *state =
+		container_of(handler, struct keyreset_state, input_handler);
+
+	for (i = 0; i < KEY_MAX; i++) {
+		if (test_bit(i, state->keybit) && test_bit(i, dev->keybit))
+			break;
+	}
+	if (i == KEY_MAX)
+		return -ENODEV;
+
+	handle = kzalloc(sizeof(*handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = "keyreset";
+	handle->private = state;
+
+	ret = input_register_handle(handle);
+	if (ret)
+		goto err_input_register_handle;
+
+	ret = input_open_device(handle);
+	if (ret)
+		goto err_input_open_device;
+
+	pr_info("using input dev %s for key reset\n", dev->name);
+
+	return 0;
+
+err_input_open_device:
+	input_unregister_handle(handle);
+err_input_register_handle:
+	kfree(handle);
+	return ret;
+}
+
+static void keyreset_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+static const struct input_device_id keyreset_ids[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(input, keyreset_ids);
+
+static int keyreset_probe(struct platform_device *pdev)
+{
+	int ret;
+	int key, *keyp;
+	struct keyreset_state *state;
+	struct keyreset_platform_data *pdata = pdev->dev.platform_data;
+
+	if (!pdata)
+		return -EINVAL;
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	spin_lock_init(&state->lock);
+	keyp = pdata->keys_down;
+	while ((key = *keyp++)) {
+		if (key >= KEY_MAX)
+			continue;
+		state->key_down_target++;
+		__set_bit(key, state->keybit);
+	}
+	if (pdata->keys_up) {
+		keyp = pdata->keys_up;
+		while ((key = *keyp++)) {
+			if (key >= KEY_MAX)
+				continue;
+			__set_bit(key, state->keybit);
+			__set_bit(key, state->upbit);
+		}
+	}
+
+	if (pdata->reset_fn)
+		state->reset_fn = pdata->reset_fn;
+	if (pdata->panic_before_reset)
+		state->need_panic = 1;
+	else
+		state->need_panic = 0;
+	if (pdata->dump_fn)
+		state->dump_fn = pdata->dump_fn;
+
+	state->input_handler.event = keyreset_event;
+	state->input_handler.connect = keyreset_connect;
+	state->input_handler.disconnect = keyreset_disconnect;
+	state->input_handler.name = KEYRESET_NAME;
+	state->input_handler.id_table = keyreset_ids;
+	ret = input_register_handler(&state->input_handler);
+	if (ret) {
+		kfree(state);
+		return ret;
+	}
+	platform_set_drvdata(pdev, state);
+	return 0;
+}
+
+int keyreset_remove(struct platform_device *pdev)
+{
+	struct keyreset_state *state = platform_get_drvdata(pdev);
+	input_unregister_handler(&state->input_handler);
+	kfree(state);
+	return 0;
+}
+
+
+struct platform_driver keyreset_driver = {
+	.driver.name = KEYRESET_NAME,
+	.probe = keyreset_probe,
+	.remove = keyreset_remove,
+};
+
+static int __init keyreset_init(void)
+{
+	return platform_driver_register(&keyreset_driver);
+}
+
+static void __exit keyreset_exit(void)
+{
+	return platform_driver_unregister(&keyreset_driver);
+}
+
+module_init(keyreset_init);
+module_exit(keyreset_exit);
diff --git a/drivers/input/misc/88pm822_onkey.c b/drivers/input/misc/88pm822_onkey.c
new file mode 100644
index 00000000..65d30374
--- /dev/null
+++ b/drivers/input/misc/88pm822_onkey.c
@@ -0,0 +1,275 @@
+/*
+ * Marvell 88PM822 ONKEY driver
+ *
+ * Copyright (C) 2013 Marvell International Ltd.
+ * Haojian Zhuang <haojian.zhuang@marvell.com>
+ * Qiao Zhou <zhouqiao@marvell.com>
+ * Mingliang Hu <mhu4@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/mfd/88pm822.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#ifdef CONFIG_SEC_DEBUG
+#include <mach/sec_debug.h>
+#endif
+
+#ifdef CONFIG_FAKE_SYSTEMOFF
+#include <linux/power/fake-sysoff.h>
+#define LONGPRESS_INTERVAL (3 * HZ)
+static void pm8xxx_longpress_report(struct work_struct *ignored);
+static DECLARE_DELAYED_WORK(presscheck_work, pm8xxx_longpress_report);
+static atomic_t longpress_work_state;
+static struct wakeup_source suspend_longkey_lock;
+static struct pm822_onkey_info *pm8xxx_info;
+#endif
+
+#define PM822_LONG_ONKEY_EN1		(1 << 0)
+#define PM822_LONG_ONKEY_EN2		(1 << 1)
+#define PM822_LONG_ONKEY_MASK		(0x03)
+#define PM822_LONG_KEY_DELAY		(8)	/* 1 .. 16 seconds */
+#define PM822_LONKEY_PRESS_TIME		((PM822_LONG_KEY_DELAY-1) << 4)
+#define PM822_LONKEY_PRESS_TIME_MASK	(0xF0)
+#define PM822_LONKEY_RESOUTN_PULSE 	(1 << 0 )
+#define PM822_LONKEY_RESOUTN_PULSE_MAKE (0x03)
+
+struct pm822_onkey_info {
+	struct input_dev *idev;
+	struct pm822_chip *pm822;
+	struct regmap *map;
+	int irq;
+};
+
+#ifdef CONFIG_FAKE_SYSTEMOFF
+void pm8xxx_longpress_report(struct work_struct *ignored)
+{
+	atomic_set(&longpress_work_state, 0);
+	input_report_key(pm8xxx_info->idev, KEY_POWER, 1);
+	input_report_key(pm8xxx_info->idev, KEY_POWER, 0);
+	input_sync(pm8xxx_info->idev);
+}
+#endif
+
+extern struct class *sec_class;
+static int is_power_key_pressed;
+/* 88PM822 gives us an interrupt when ONKEY is held */
+static irqreturn_t pm822_onkey_handler(int irq, void *data)
+{
+	struct pm822_onkey_info *info = data;
+	int ret = 0;
+	unsigned int val;
+
+	ret = regmap_read(info->map, PM822_STATUS1, &val);
+	if (ret < 0) {
+		dev_err(info->idev->dev.parent, "failed to read status: %d\n",
+			ret);
+		return IRQ_NONE;
+	}
+	val &= PM822_ONKEY_STS1;
+#ifdef CONFIG_FAKE_SYSTEMOFF
+	if (fake_sysoff_block_onkey())
+		goto out;
+	if (fake_sysoff_status_query()) {
+		if (val) { /*down key*/
+			if (!atomic_cmpxchg(&longpress_work_state, 0, 1)) {
+				schedule_delayed_work(&presscheck_work,
+						LONGPRESS_INTERVAL);
+				/* Think about following case: onkey down/up->
+				 * kernel will awake 5s ->after 4s->
+				 * user long down on key -> after 1s, suspend
+				 * -> have no chance for 3s timeout*/
+				__pm_wakeup_event(&suspend_longkey_lock,
+				jiffies_to_msecs(LONGPRESS_INTERVAL + HZ));
+			}
+		} else { /*up key*/
+			if (atomic_cmpxchg(&longpress_work_state, 1, 0)) {
+				/* short press */
+				cancel_delayed_work_sync(&presscheck_work);
+			}
+		}
+	} else {
+#endif
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+	printk("power key val =%d\n",val);
+#endif
+	input_report_key(info->idev, KEY_POWER, val);
+	input_sync(info->idev);
+#ifdef CONFIG_FAKE_SYSTEMOFF
+	}
+out:
+#endif
+	is_power_key_pressed = val;		// AT+KEYSHORT cmd
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_PM
+static SIMPLE_DEV_PM_OPS(pm822_onkey_pm_ops, pm822_dev_suspend,
+			 pm822_dev_resume);
+#endif
+
+// AT + KEYSHORT cmd
+static ssize_t keys_read(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int count;
+
+	if (is_power_key_pressed != 0)
+		count = sprintf(buf,"%s\n","PRESS");
+	else
+		count = sprintf(buf,"%s\n","RELEASE");
+
+       return count;
+}
+static DEVICE_ATTR(sec_power_key_pressed, S_IRUGO, keys_read, NULL);
+
+static int __devinit pm822_onkey_probe(struct platform_device *pdev)
+{
+
+	struct pm822_chip *chip = dev_get_drvdata(pdev->dev.parent);
+	struct pm822_onkey_info *info;
+	struct device *dev_t;
+	int irq, err;
+
+	info = kzalloc(sizeof(struct pm822_onkey_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->pm822 = chip;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "No IRQ resource!\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	info->irq = irq + chip->irq_base;
+	info->map = info->pm822->regmap;
+	if (!info->map) {
+		dev_err(&pdev->dev, "no regmap!\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	info->idev = input_allocate_device();
+	if (!info->idev) {
+		dev_err(&pdev->dev, "Failed to allocate input dev\n");
+		err = -ENOMEM;
+		goto out;
+	}
+
+	info->idev->name = "88pm822_on";
+	info->idev->phys = "88pm822_on/input0";
+	info->idev->id.bustype = BUS_I2C;
+	info->idev->dev.parent = &pdev->dev;
+	info->idev->evbit[0] = BIT_MASK(EV_KEY);
+	__set_bit(KEY_POWER, info->idev->keybit);
+
+	err = pm822_request_irq(info->pm822, info->irq, pm822_onkey_handler,
+				IRQF_ONESHOT, "onkey", info);
+	if (err < 0) {
+		dev_err(&pdev->dev, "Failed to request IRQ: #%d: %d\n",
+			info->irq, err);
+		goto out_reg;
+	}
+
+	err = input_register_device(info->idev);
+	if (err) {
+		dev_err(&pdev->dev, "Can't register input device: %d\n", err);
+		goto out_irq;
+	}
+
+	platform_set_drvdata(pdev, info);
+
+//	if (!sec_debug_level.en.kernel_fault) {
+		/* Debug Level LOW, Forces a supply power down */
+		/* Enable long onkey1  detection */
+//		regmap_update_bits(info->map, PM822_RTC_MISC4, PM822_LONG_ONKEY_MASK,
+//				   PM822_LONG_ONKEY_EN1);
+//	} else {
+		/* Enable long onkey2  detection */
+		regmap_update_bits(info->map, PM822_RTC_MISC4, PM822_LONG_ONKEY_MASK,
+				   PM822_LONG_ONKEY_EN2);
+//	}
+	/* Set 8-second interval */
+	regmap_update_bits(info->map, PM822_RTC_MISC3,
+			   PM822_LONKEY_PRESS_TIME_MASK,
+			   PM822_LONKEY_PRESS_TIME);
+	/* Set 1s the duration of resset outn pulse after a lone onkey envent */
+	regmap_update_bits(info->map, PM822_RTC_MISC3,
+			   PM822_LONKEY_RESOUTN_PULSE_MAKE,
+			   PM822_LONKEY_RESOUTN_PULSE);
+
+	device_init_wakeup(&pdev->dev, 1);
+#ifdef CONFIG_FAKE_SYSTEMOFF
+	pm8xxx_info = info;
+	atomic_set(&longpress_work_state, 0);
+	wakeup_source_init(&suspend_longkey_lock, "longkey_suspend");
+#endif
+
+	dev_t = device_create(sec_class, NULL, 0, "%s", "sec_power_key");
+	if (IS_ERR(dev_t))
+		dev_t = NULL;
+
+	if (dev_t) {
+		if(device_create_file(dev_t, &dev_attr_sec_power_key_pressed) < 0)
+			 printk("Failed to create device file(%s)!\n", dev_attr_sec_power_key_pressed.attr.name);
+	}
+	return 0;
+
+out_irq:
+	pm822_free_irq(info->pm822, info->irq, info);
+out_reg:
+	input_free_device(info->idev);
+out:
+	kfree(info);
+	return err;
+}
+
+static int __devexit pm822_onkey_remove(struct platform_device *pdev)
+{
+	struct pm822_onkey_info *info = platform_get_drvdata(pdev);
+
+	device_init_wakeup(&pdev->dev, 0);
+	pm822_free_irq(info->pm822, info->irq, info);
+	input_unregister_device(info->idev);
+	kfree(info);
+#ifdef CONFIG_FAKE_SYSTEMOFF
+	wakeup_source_trash(&suspend_longkey_lock);
+#endif
+	return 0;
+}
+
+static struct platform_driver pm822_onkey_driver = {
+	.driver = {
+		   .name = "88pm822-onkey",
+		   .owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		   .pm = &pm822_onkey_pm_ops,
+#endif
+		   },
+	.probe = pm822_onkey_probe,
+	.remove = __devexit_p(pm822_onkey_remove),
+};
+
+module_platform_driver(pm822_onkey_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Marvell 88PM822 ONKEY driver");
+MODULE_ALIAS("platform:88pm822-onkey");
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 7faf4a7f..0156d4dc 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -22,6 +22,26 @@ config INPUT_88PM860X_ONKEY
 	  To compile this driver as a module, choose M here: the module
 	  will be called 88pm860x_onkey.
 
+config INPUT_88PM80X_ONKEY
+	tristate "88PM80x ONKEY support"
+	depends on MFD_88PM800
+	help
+	  Support the ONKEY of Marvell 88PM80x PMICs as an input device
+	  reporting power button status.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called 88pm80x_onkey.
+
+config INPUT_88PM822_ONKEY
+	tristate "88PM822 ONKEY support"
+	depends on MFD_88PM822
+	help
+	  Support the ONKEY of Marvell 88PM822 PMICs as an input device
+	  reporting power button status.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called 88pm822_onkey.
+
 config INPUT_AB8500_PONKEY
 	tristate "AB8500 Pon (PowerOn) Key"
 	depends on AB8500_CORE
@@ -62,6 +82,13 @@ config INPUT_AD714X_SPI
 	  To compile this driver as a module, choose M here: the
 	  module will be called ad714x-spi.
 
+config INPUT_D2199_ONKEY
+	tristate "D2199 ONKEY support"
+	depends on MFD_D2199
+	help
+	  Say Y here if you want the ONKEY functionality from the
+	  Dialog D2199 multifunction device
+
 config INPUT_BMA150
 	tristate "BMA150/SMB380 acceleration sensor support"
 	depends on I2C
@@ -279,6 +306,17 @@ config INPUT_ATI_REMOTE2
 	  To compile this driver as a module, choose M here: the module will be
 	  called ati_remote2.
 
+config INPUT_KEYCHORD
+	tristate "Key chord input driver support"
+	help
+	  Say Y here if you want to enable the key chord driver
+	  accessible at /dev/keychord.  This driver can be used
+	  for receiving notifications when client specified key
+	  combinations are pressed.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called keychord.
+
 config INPUT_KEYSPAN_REMOTE
 	tristate "Keyspan DMR USB remote control (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
@@ -407,6 +445,11 @@ config INPUT_SGI_BTNS
 	  To compile this driver as a module, choose M here: the
 	  module will be called sgi_btns.
 
+config INPUT_GPIO
+	tristate "GPIO driver support"
+	help
+	  Say Y here if you want to support gpio based keys, wheels etc...
+
 config HP_SDC_RTC
 	tristate "HP SDC Real Time Clock"
 	depends on (GSC || HP300) && SERIO
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index f55cdf49..be874e80 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -5,6 +5,8 @@
 # Each configuration option enables a list of files.
 
 obj-$(CONFIG_INPUT_88PM860X_ONKEY)	+= 88pm860x_onkey.o
+obj-$(CONFIG_INPUT_88PM80X_ONKEY)	+= 88pm80x_onkey.o
+obj-$(CONFIG_INPUT_88PM822_ONKEY)	+= 88pm822_onkey.o
 obj-$(CONFIG_INPUT_AB8500_PONKEY)	+= ab8500-ponkey.o
 obj-$(CONFIG_INPUT_AD714X)		+= ad714x.o
 obj-$(CONFIG_INPUT_AD714X_I2C)		+= ad714x-i2c.o
@@ -21,12 +23,15 @@ obj-$(CONFIG_INPUT_CM109)		+= cm109.o
 obj-$(CONFIG_INPUT_CMA3000)		+= cma3000_d0x.o
 obj-$(CONFIG_INPUT_CMA3000_I2C)		+= cma3000_d0x_i2c.o
 obj-$(CONFIG_INPUT_COBALT_BTNS)		+= cobalt_btns.o
+obj-$(CONFIG_INPUT_D2199_ONKEY)		+= d2199_onkey.o
 obj-$(CONFIG_INPUT_DA9052_ONKEY)	+= da9052_onkey.o
 obj-$(CONFIG_INPUT_DM355EVM)		+= dm355evm_keys.o
 obj-$(CONFIG_INPUT_GP2A)		+= gp2ap002a00f.o
 obj-$(CONFIG_INPUT_GPIO_TILT_POLLED)	+= gpio_tilt_polled.o
+obj-$(CONFIG_INPUT_GPIO)		+= gpio_event.o gpio_matrix.o gpio_input.o gpio_output.o gpio_axis.o
 obj-$(CONFIG_HP_SDC_RTC)		+= hp_sdc_rtc.o
 obj-$(CONFIG_INPUT_IXP4XX_BEEPER)	+= ixp4xx-beeper.o
+obj-$(CONFIG_INPUT_KEYCHORD)		+= keychord.o
 obj-$(CONFIG_INPUT_KEYSPAN_REMOTE)	+= keyspan_remote.o
 obj-$(CONFIG_INPUT_KXTJ9)		+= kxtj9.o
 obj-$(CONFIG_INPUT_M68K_BEEP)		+= m68kspkr.o
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 2a214191..603af5d4 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -23,6 +23,19 @@ config TOUCHSCREEN_88PM860X
 	  To compile this driver as a module, choose M here: the
 	  module will be called 88pm860x-ts.
 
+config TOUCHSCREEN_FT5306
+	tristate "FT5306 Touchscreen interface support"
+	depends on I2C
+	help
+	  Say Y here if enable support for the FT5306 touchscreen controller.
+
+config TOUCHSCREEN_GT9XX
+	tristate "GT9XX Touchscreen interface support"
+	depends on I2C
+	help
+	  Say Y here if enable support for the Goodix GT9XX multi fingers
+	  touchscreen controller.
+
 config TOUCHSCREEN_ADS7846
 	tristate "ADS7846/TSC2046/AD7873 and AD(S)7843 based touchscreens"
 	depends on SPI_MASTER
@@ -42,6 +55,13 @@ config TOUCHSCREEN_ADS7846
 	  To compile this driver as a module, choose M here: the
 	  module will be called ads7846.
 
+config TOUCHSCREEN_VNC
+       tristate "VNC based touchscreen"
+       help
+        Say Y here to enable support for VNC virtual touch screen driver
+        If unsure, say N.
+        If sure, say Y.
+
 config TOUCHSCREEN_AD7877
 	tristate "AD7877 based touchscreens"
 	depends on SPI_MASTER
@@ -451,6 +471,22 @@ config TOUCHSCREEN_TNETV107X
 	  To compile this driver as a module, choose M here: the
 	  module will be called tnetv107x-ts.
 
+config TOUCHSCREEN_SYNAPTICS_I2C_RMI
+	tristate "Synaptics i2c touchscreen"
+	depends on I2C
+	help
+	  This enables support for Synaptics RMI over I2C based touchscreens.
+
+config TOUCHSCREEN_SYNAPTICS_DSX_I2C
+	tristate "Synaptics DSX I2C touchscreen"
+	depends on I2C
+	help
+	  Say Y here if you have a Synaptics DSX I2C touchscreen
+	  connected to your system. If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called synaptics_dsx_i2c.
+
 config TOUCHSCREEN_TOUCHRIGHT
 	tristate "Touchright serial touchscreen"
 	select SERIO
@@ -845,4 +881,75 @@ config TOUCHSCREEN_TPS6507X
 	  To compile this driver as a module, choose M here: the
 	  module will be called tps6507x_ts.
 
+config TOUCHSCREEN_MMS136_TS
+       tristate "MELFAS MMS-136 touchscreen driver"
+       depends on I2C
+       default n
+       help
+         Say Y here if you have a MELFAS MMS-100 series touchscreen.
+
+         If unsure, say N.
+
+config TOUCHSCREEN_MXT224S
+	tristate "Atmel MaxTouch 224S"
+	depends on I2C
+	default n
+	help
+	  Say Y here to enable support for the Atmel MaxTouch 224 touch
+	  controller.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called mxt336S.
+
+config TOUCHSCREEN_BT432_TS
+       tristate "ZINITIX BT432 touchscreen driver"
+       depends on I2C
+       default n
+       help
+         Say Y here if you have a ZINITIX BT432 touchscreen.
+
+         If unsure, say N.
+         
+config TOUCHSCREEN_BT531_TS
+       tristate "ZINITIX BT531 touchscreen driver"
+       depends on I2C
+       default n
+       help
+         Say Y here if you have a ZINITIX BT531 touchscreen.
+
+         If unsure, say N.
+	 
+config TOUCHSCREEN_BT532_TS
+	bool "ZINITIX BT532 touchscreen driver"
+	depends on I2C
+	default n
+	help
+	  Say Y here if you have a ZINITIX BT532 touchscreen.
+
+	  If unsure, say N.	  
+
+config TOUCHSCREEN_BT532_TS_ORIENTATION
+	int "ZINITIX BT532 touchscreen driver orientation"
+	depends on TOUCHSCREEN_BT532_TS
+	default "0"
+	help
+	  ZINITIX BT532 touchscreen driver orientation.
+	     0: portrait
+	     6: landscape
+
+config TOUCHSCREEN_CYPRESS_TMA46X
+	tristate "CYPRESS TMA46X I2C Touchscreen"
+	depends on I2C
+	help
+	  Say Y here if you have Cypress tma46x I2C touchscreen,
+	  such as TMA46x, connected to your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tma46x.
+# source "drivers/input/touchscreen/MMS144/Kconfig"
 endif
+
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 3d5cf8cb..d81b0b4e 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -7,6 +7,8 @@
 wm97xx-ts-y := wm97xx-core.o
 
 obj-$(CONFIG_TOUCHSCREEN_88PM860X)	+= 88pm860x-ts.o
+obj-$(CONFIG_TOUCHSCREEN_FT5306)	+= ft5306_touch.o
+obj-$(CONFIG_TOUCHSCREEN_GT9XX) 	+= gt9xx_touch.o gt9xx_update.o goodix_tool.o
 obj-$(CONFIG_TOUCHSCREEN_AD7877)	+= ad7877.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879_I2C)	+= ad7879-i2c.o
@@ -51,6 +53,8 @@ obj-$(CONFIG_TOUCHSCREEN_ST1232)	+= st1232.o
 obj-$(CONFIG_TOUCHSCREEN_STMPE)		+= stmpe-ts.o
 obj-$(CONFIG_TOUCHSCREEN_TI_TSCADC)	+= ti_tscadc.o
 obj-$(CONFIG_TOUCHSCREEN_TNETV107X)	+= tnetv107x-ts.o
+obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI)	+= synaptics_i2c_rmi.o
+obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C)	+= synaptics_dsx_i2c.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHIT213)	+= touchit213.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHRIGHT)	+= touchright.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHWIN)	+= touchwin.o
@@ -69,3 +73,11 @@ obj-$(CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE)	+= mainstone-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE)	+= zylonite-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
+obj-$(CONFIG_TOUCHSCREEN_VNC)		+= vnc_touch.o
+obj-$(CONFIG_TOUCHSCREEN_MMS136_TS) += mfs_gpio_i2c.o mms100_isp.o mms100_cfg_update.o mms136_ts.o
+obj-$(CONFIG_TOUCHSCREEN_BT531_TS) += bt531_ts.o
+obj-$(CONFIG_TOUCHSCREEN_BT532_TS) += bt532_ts.o
+obj-$(CONFIG_TOUCHSCREEN_BT432_TS) += bt432_ts.o
+obj-$(CONFIG_TOUCHSCREEN_MXT224S)	+= mxts.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_TMA46X)	+= cyttsp4_core.o	cyttsp4_i2c.o  cyttsp4_bus.o  cyttsp4_mtb.o  cyttsp4_mt_common.o cyttsp4_btn.o  cyttsp4_device_access.o cyttsp4_loader.o
+# obj-$(CONFIG_TOUCHSCREEN_MELFAS_MMS144)		+= MMS144/
diff --git a/drivers/input/touchscreen/bt532_ts.c b/drivers/input/touchscreen/bt532_ts.c
new file mode 100755
index 00000000..7d82fee4
--- /dev/null
+++ b/drivers/input/touchscreen/bt532_ts.c
@@ -0,0 +1,4296 @@
+/*
+ *
+ * Zinitix bt532 touchscreen driver
+ *
+ * Copyright (C) 2013 Samsung Electronics Co.Ltd
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+ * GNU General Public License for more details.
+ *
+ */
+
+
+#define TSP_VERBOSE_DEBUG
+#define SEC_FACTORY_TEST
+#define SUPPORTED_TOUCH_KEY
+
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/miscdevice.h>
+#include <linux/interrupt.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#if defined(CONFIG_PM_RUNTIME)
+#include <linux/pm_runtime.h>
+#endif
+#include <linux/semaphore.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/uaccess.h>
+#include <linux/regulator/consumer.h>
+
+#include <linux/input/bt532_ts.h>
+#include <linux/input/mt.h>
+
+#ifdef CONFIG_MACH_DEGAS
+#include "zinitix_touch_bt532_firmware_DEGAS.h"
+#else // #ifdef  CONFIG_MACH_GOYA
+#include "zinitix_touch_bt532_firmware.h"
+#endif
+
+
+#define ZINITIX_TSP_USE_LDO_POWER                  1
+#define ZINITIX_DEBUG				0
+
+/* added header file */
+
+#define TOUCH_POINT_MODE			0
+
+#define MAX_SUPPORTED_FINGER_NUM	5 /* max 10 */
+
+#ifdef SUPPORTED_TOUCH_KEY
+#define MAX_SUPPORTED_BUTTON_NUM	6 /* max 8 */
+#define SUPPORTED_BUTTON_NUM		4
+#endif
+
+/* Upgrade Method*/
+#define TOUCH_ONESHOT_UPGRADE		1
+/* if you use isp mode, you must add i2c device :
+name = "zinitix_isp" , addr 0x50*/
+
+/* resolution offset */
+#define ABS_PT_OFFSET				(-1)
+
+#define TOUCH_FORCE_UPGRADE			1
+#define USE_CHECKSUM				1
+#define CHECK_HWID					0
+
+#define CHIP_OFF_DELAY				50 /*ms*/
+#define CHIP_ON_DELAY				15 /*ms*/
+#define FIRMWARE_ON_DELAY			20 /*ms*/
+
+#define DELAY_FOR_SIGNAL_DELAY		30 /*us*/
+#define DELAY_FOR_TRANSCATION		50
+#define DELAY_FOR_POST_TRANSCATION	10
+
+enum power_control {
+	POWER_OFF,
+	POWER_ON,
+	POWER_ON_SEQUENCE,
+	PM_POWER_OFF,
+};
+
+/* Key Enum */
+enum key_event {
+	ICON_BUTTON_UNCHANGE,
+	ICON_BUTTON_DOWN,
+	ICON_BUTTON_UP,
+};
+
+/* ESD Protection */
+/*second : if 0, no use. if you have to use, 3 is recommended*/
+#define ESD_TIMER_INTERVAL			1
+#define SCAN_RATE_HZ				100
+#define CHECK_ESD_TIMER				3
+
+ /*Test Mode (Monitoring Raw Data) */
+#define SEC_DND_N_COUNT				20
+#define SEC_DND_U_COUNT				1
+#define SEC_DND_FREQUENCY			77 /* 307khz */
+
+#define SEC_PDND_N_COUNT			16
+#define SEC_PDND_U_COUNT			14
+#define SEC_PDND_FREQUENCY			79
+
+#define MAX_RAW_DATA_SZ				576 /* 32x18 */
+#define MAX_TRAW_DATA_SZ	\
+	(MAX_RAW_DATA_SZ + 4*MAX_SUPPORTED_FINGER_NUM + 2)
+/* preriod raw data interval */
+
+#define RAWDATA_DELAY_FOR_HOST		100
+
+struct raw_ioctl {
+	int sz;
+	u8 *buf;
+};
+
+struct reg_ioctl {
+	int addr;
+	int *val;
+};
+
+#define TOUCH_SEC_MODE				48
+#define TOUCH_REF_MODE				10
+#define TOUCH_NORMAL_MODE			5
+#define TOUCH_DELTA_MODE			3
+#define TOUCH_DND_MODE				6
+#define TOUCH_PDND_MODE				11
+
+/*  Other Things */
+#define INIT_RETRY_CNT				1
+#define I2C_SUCCESS					0
+#define I2C_FAIL					1
+
+/*---------------------------------------------------------------------*/
+
+/* Register Map*/
+#define BT532_SWRESET_CMD					0x0000
+#define BT532_WAKEUP_CMD					0x0001
+
+#define BT532_IDLE_CMD						0x0004
+#define BT532_SLEEP_CMD						0x0005
+
+#define BT532_CLEAR_INT_STATUS_CMD			0x0003
+#define BT532_CALIBRATE_CMD					0x0006
+#define BT532_SAVE_STATUS_CMD				0x0007
+#define BT532_SAVE_CALIBRATION_CMD			0x0008
+#define BT532_RECALL_FACTORY_CMD			0x000f
+
+#define BT532_THRESHOLD						0x0020
+
+#define BT532_DEBUG_REG						0x0115 /* 0~7 */
+
+#define BT532_TOUCH_MODE					0x0010
+#define BT532_CHIP_REVISION					0x0011
+#define BT532_FIRMWARE_VERSION				0x0012
+
+#define BT532_MINOR_FW_VERSION				0x0121
+
+#define BT532_VENDOR_ID						0x001C
+#define BT532_HW_ID							0x0014
+
+#define BT532_DATA_VERSION_REG				0x0013
+#define BT532_SUPPORTED_FINGER_NUM			0x0015
+#define BT532_EEPROM_INFO					0x0018
+#define BT532_INITIAL_TOUCH_MODE			0x0019
+
+#define BT532_TOTAL_NUMBER_OF_X				0x0060
+#define BT532_TOTAL_NUMBER_OF_Y				0x0061
+
+#define BT532_DELAY_RAW_FOR_HOST			0x007f
+
+#define BT532_BUTTON_SUPPORTED_NUM			0x00B0
+#define BT532_BUTTON_SENSITIVITY			0x00B2
+#define BT532_DUMMY_BUTTON_SENSITIVITY		0X00C8
+
+#define BT532_X_RESOLUTION					0x00C0
+#define BT532_Y_RESOLUTION					0x00C1
+
+#define BT532_POINT_STATUS_REG				0x0080
+#define BT532_ICON_STATUS_REG				0x00AA
+
+#define BT532_AFE_FREQUENCY					0x0100
+#define BT532_DND_N_COUNT					0x0122
+#define BT532_DND_U_COUNT					0x0135
+
+#define BT532_RAWDATA_REG					0x0200
+
+#define BT532_EEPROM_INFO_REG				0x0018
+
+#define BT532_INT_ENABLE_FLAG				0x00f0
+#define BT532_PERIODICAL_INTERRUPT_INTERVAL	0x00f1
+
+#define BT532_BTN_WIDTH						0x016d
+
+#define BT532_CHECKSUM_RESULT				0x012c
+
+#define BT532_INIT_FLASH					0x01d0
+#define BT532_WRITE_FLASH					0x01d1
+#define BT532_READ_FLASH					0x01d2
+
+
+/* Interrupt & status register flag bit
+-------------------------------------------------
+*/
+#define BIT_PT_CNT_CHANGE	0
+#define BIT_DOWN			1
+#define BIT_MOVE			2
+#define BIT_UP				3
+#define BIT_PALM			4
+#define BIT_PALM_REJECT		5
+#define RESERVED_0			6
+#define RESERVED_1			7
+#define BIT_WEIGHT_CHANGE	8
+#define BIT_PT_NO_CHANGE	9
+#define BIT_REJECT			10
+#define BIT_PT_EXIST		11
+#define RESERVED_2			12
+#define BIT_MUST_ZERO		13
+#define BIT_DEBUG			14
+#define BIT_ICON_EVENT		15
+
+/* button */
+#define BIT_O_ICON0_DOWN	0
+#define BIT_O_ICON1_DOWN	1
+#define BIT_O_ICON2_DOWN	2
+#define BIT_O_ICON3_DOWN	3
+#define BIT_O_ICON4_DOWN	4
+#define BIT_O_ICON5_DOWN	5
+#define BIT_O_ICON6_DOWN	6
+#define BIT_O_ICON7_DOWN	7
+
+#define BIT_O_ICON0_UP		8
+#define BIT_O_ICON1_UP		9
+#define BIT_O_ICON2_UP		10
+#define BIT_O_ICON3_UP		11
+#define BIT_O_ICON4_UP		12
+#define BIT_O_ICON5_UP		13
+#define BIT_O_ICON6_UP		14
+#define BIT_O_ICON7_UP		15
+
+
+#define SUB_BIT_EXIST		0
+#define SUB_BIT_DOWN		1
+#define SUB_BIT_MOVE		2
+#define SUB_BIT_UP			3
+#define SUB_BIT_UPDATE		4
+#define SUB_BIT_WAIT		5
+
+
+#define zinitix_bit_set(val, n)		((val) &= ~(1<<(n)), (val) |= (1<<(n)))
+#define zinitix_bit_clr(val, n)		((val) &= ~(1<<(n)))
+#define zinitix_bit_test(val, n)	((val) & (1<<(n)))
+#define zinitix_swap_v(a, b, t)		((t) = (a), (a) = (b), (b) = (t))
+#define zinitix_swap_16(s)			(((((s) & 0xff) << 8) | (((s) >> 8) & 0xff)))
+
+/* end header file */
+
+#ifdef SEC_FACTORY_TEST
+/* Touch Screen */
+#define TSP_CMD_STR_LEN			32
+#define TSP_CMD_RESULT_STR_LEN	512
+#define TSP_CMD_PARAM_NUM		8
+#define TSP_CMD_Y_NUM			18
+#define TSP_CMD_X_NUM			30
+#define TSP_CMD_NODE_NUM		(TSP_CMD_Y_NUM * TSP_CMD_X_NUM)
+
+struct tsp_factory_info {
+	struct list_head cmd_list_head;
+	char cmd[TSP_CMD_STR_LEN];
+	char cmd_param[TSP_CMD_PARAM_NUM];
+	char cmd_result[TSP_CMD_RESULT_STR_LEN];
+	char cmd_buff[TSP_CMD_RESULT_STR_LEN];
+	struct mutex cmd_lock;
+	bool cmd_is_running;
+	u8 cmd_state;
+};
+
+struct tsp_raw_data {
+	u16 ref_data[TSP_CMD_NODE_NUM];
+	u16 pref_data[TSP_CMD_NODE_NUM];
+	/*s16 scantime_data[TSP_CMD_NODE_NUM]; */
+	s16 delta_data[TSP_CMD_NODE_NUM];
+};
+
+enum {
+	WAITING = 0,
+	RUNNING,
+	OK,
+	FAIL,
+	NOT_APPLICABLE,
+};
+
+struct tsp_cmd {
+	struct list_head list;
+	const char *cmd_name;
+	void (*cmd_func)(void *device_data);
+};
+
+static void fw_update(void *device_data);
+static void get_fw_ver_bin(void *device_data);
+static void get_fw_ver_ic(void *device_data);
+static void get_threshold(void *device_data);
+static void module_off_master(void *device_data);
+static void module_on_master(void *device_data);
+static void module_off_slave(void *device_data);
+static void module_on_slave(void *device_data);
+static void get_chip_vendor(void *device_data);
+static void get_chip_name(void *device_data);
+static void get_x_num(void *device_data);
+static void get_y_num(void *device_data);
+static void not_support_cmd(void *device_data);
+
+/* Vendor dependant command */
+static void run_reference_read(void *device_data);
+static void get_reference(void *device_data);
+static void run_preference_read(void *device_data);
+static void get_preference(void *device_data);
+/*
+static void run_scantime_read(void *device_data);
+static void get_scantime(void *device_data);
+*/
+static void run_delta_read(void *device_data);
+static void get_delta(void *device_data);
+
+#define TSP_CMD(name, func) .cmd_name = name, .cmd_func = func
+
+static struct tsp_cmd tsp_cmds[] = {
+	{TSP_CMD("fw_update", fw_update),},
+	{TSP_CMD("get_fw_ver_bin", get_fw_ver_bin),},
+	{TSP_CMD("get_fw_ver_ic", get_fw_ver_ic),},
+	{TSP_CMD("get_threshold", get_threshold),},
+	{TSP_CMD("module_off_master", module_off_master),},
+	{TSP_CMD("module_on_master", module_on_master),},
+	{TSP_CMD("module_off_slave", module_off_slave),},
+	{TSP_CMD("module_on_slave", module_on_slave),},
+	{TSP_CMD("get_chip_vendor", get_chip_vendor),},
+	{TSP_CMD("get_chip_name", get_chip_name),},
+	{TSP_CMD("get_x_num", get_x_num),},
+	{TSP_CMD("get_y_num", get_y_num),},
+	{TSP_CMD("not_support_cmd", not_support_cmd),},
+
+	/* vendor dependant command */
+	{TSP_CMD("run_reference_read", run_reference_read),},
+	{TSP_CMD("get_reference", get_reference),},
+	{TSP_CMD("run_dnd_read", run_preference_read),},
+	{TSP_CMD("get_dnd", get_preference),},
+/*
+	{TSP_CMD("run_scantime_read", run_scantime_read),},
+	{TSP_CMD("get_scantime", get_scantime),},
+*/
+	{TSP_CMD("run_delta_read", run_delta_read),},
+	{TSP_CMD("get_delta", get_delta),},
+};
+#if 0
+#ifdef SUPPORTED_TOUCH_KEY
+/* Touch Key */
+static ssize_t touchkey_threshold(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static ssize_t touch_sensitivity(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static ssize_t touchkey_back(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static ssize_t touchkey_menu(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static ssize_t autocal_stat(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static ssize_t touchkey_raw_back(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static ssize_t touchkey_raw_menu(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static ssize_t touchkey_idac_back(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static ssize_t touchkey_idac_menu(struct device *dev,
+		struct device_attribute *attr, char *buf);
+#endif
+#endif
+#endif
+
+#define TSP_NORMAL_EVENT_MSG 1
+static int m_ts_debug_mode = ZINITIX_DEBUG;
+
+#if ESD_TIMER_INTERVAL
+static struct workqueue_struct *esd_tmr_workqueue;
+#endif
+
+struct coord {
+	u16	x;
+	u16	y;
+	u8	width;
+	u8	sub_status;
+#if (TOUCH_POINT_MODE == 2)
+	u8	minor_width;
+	u8	angle;
+#endif
+};
+
+struct point_info {
+	u16	status;
+#if (TOUCH_POINT_MODE == 1)
+	u16	event_flag;
+#else
+	u8	finger_cnt;
+	u8	time_stamp;
+#endif
+	struct coord coord[MAX_SUPPORTED_FINGER_NUM];
+};
+
+#define TOUCH_V_FLIP	0x01
+#define TOUCH_H_FLIP	0x02
+#define TOUCH_XY_SWAP	0x04
+
+struct capa_info {
+	u16	vendor_id;
+	u16	ic_revision;
+	u16	fw_version;
+	u16	fw_minor_version;
+	u16	reg_data_version;
+	u16	threshold;
+	u16	key_threshold;
+	u16	dummy_threshold;
+	u32	ic_fw_size;
+	u32	MaxX;
+	u32	MaxY;
+	u32	MinX;
+	u32	MinY;
+	u8	gesture_support;
+	u16	multi_fingers;
+	u16	button_num;
+	u16	ic_int_mask;
+	u16	x_node_num;
+	u16	y_node_num;
+	u16	total_node_num;
+	u16	hw_id;
+	u16	afe_frequency;
+	u16	N_cnt;
+	u16	u_cnt;
+};
+
+enum work_state {
+	NOTHING = 0,
+	NORMAL,
+	ESD_TIMER,
+	EALRY_SUSPEND,
+	SUSPEND,
+	RESUME,
+	LATE_RESUME,
+	UPGRADE,
+	REMOVE,
+	SET_MODE,
+	HW_CALIBRAION,
+	RAW_DATA,
+};
+
+enum {
+	BUILT_IN = 0,
+	UMS,
+	REQ_FW,
+};
+
+struct bt532_ts_info {
+	struct i2c_client				*client;
+	struct input_dev				*input_dev;
+	struct bt532_ts_platform_data	*pdata;
+	char							phys[32];
+	/*struct task_struct				*task;*/
+	/*wait_queue_head_t				wait;*/
+
+	/*struct semaphore				update_lock;*/
+	/*u32								i2c_dev_addr;*/
+	struct capa_info				cap_info;
+	struct point_info				touch_info;
+	struct point_info				reported_touch_info;
+	u16								icon_event_reg;
+	u16								prev_icon_event;
+	/*u16								event_type;*/
+	int								irq;
+	u8								button[MAX_SUPPORTED_BUTTON_NUM];
+	u8								work_state;
+	struct semaphore				work_lock;
+
+	/*u16								debug_reg[8];*/ /* for debug */
+
+#if ESD_TIMER_INTERVAL
+	struct work_struct				tmr_work;
+	struct timer_list				esd_timeout_tmr;
+	struct timer_list				*p_esd_timeout_tmr;
+	spinlock_t	lock;
+#endif
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend			early_suspend;
+#endif
+	struct semaphore				raw_data_lock;
+	u16								touch_mode;
+	s16								cur_data[MAX_TRAW_DATA_SZ];
+	u8								update;
+
+#ifdef SEC_FACTORY_TEST
+	struct tsp_factory_info			*factory_info;
+	struct tsp_raw_data				*raw_data;
+#endif
+};
+/* Dummy touchkey code */
+#define KEY_DUMMY_HOME1	249
+#define KEY_DUMMY_HOME2	250
+#define KEY_DUMMY_MENU	251
+#define KEY_DUMMY_HOME	252
+#define KEY_DUMMY_BACK	253
+/*<= you must set key button mapping*/
+u32 BUTTON_MAPPING_KEY[MAX_SUPPORTED_BUTTON_NUM] = {
+	KEY_DUMMY_MENU, KEY_MENU,// KEY_DUMMY_HOME1,
+	/*KEY_DUMMY_HOME2,*/ KEY_BACK, KEY_DUMMY_BACK};
+
+/* define i2c sub functions*/
+static inline s32 read_data(struct i2c_client *client,
+	u16 reg, u8 *values, u16 length)
+{
+	s32 ret;
+	int count = 0;
+retry:
+	/* select register*/
+	ret = i2c_master_send(client , (u8 *)&reg , 2);
+	if (ret < 0) {
+		mdelay(1);
+
+		if (++count < 8)
+			goto retry;
+
+		return ret;
+	}
+	/* for setup tx transaction. */
+	udelay(DELAY_FOR_TRANSCATION);
+	ret = i2c_master_recv(client , values , length);
+	if (ret < 0)
+		return ret;
+
+	udelay(DELAY_FOR_POST_TRANSCATION);
+	return length;
+}
+
+static inline s32 write_data(struct i2c_client *client,
+	u16 reg, u8 *values, u16 length)
+{
+	s32 ret;
+	int count = 0;
+	u8 pkt[10]; /* max packet */
+	pkt[0] = (reg) & 0xff; /* reg addr */
+	pkt[1] = (reg >> 8)&0xff;
+	memcpy((u8 *)&pkt[2], values, length);
+
+retry:
+	ret = i2c_master_send(client , pkt , length + 2);
+	if (ret < 0) {
+		mdelay(1);
+
+		if (++count < 8)
+			goto retry;
+
+		return ret;
+	}
+
+	udelay(DELAY_FOR_POST_TRANSCATION);
+	return length;
+}
+
+static inline s32 write_reg(struct i2c_client *client, u16 reg, u16 value)
+{
+	if (write_data(client, reg, (u8 *)&value, 2) < 0)
+		return I2C_FAIL;
+
+	return I2C_SUCCESS;
+}
+
+static inline s32 write_cmd(struct i2c_client *client, u16 reg)
+{
+	s32 ret;
+	int count = 0;
+
+retry:
+	ret = i2c_master_send(client , (u8 *)&reg , 2);
+	if (ret < 0) {
+		mdelay(1);
+
+		if (++count < 8)
+			goto retry;
+
+		return ret;
+	}
+
+	udelay(DELAY_FOR_POST_TRANSCATION);
+	return I2C_SUCCESS;
+}
+
+static inline s32 read_raw_data(struct i2c_client *client,
+		u16 reg, u8 *values, u16 length)
+{
+	s32 ret;
+	int count = 0;
+
+retry:
+	/* select register */
+	ret = i2c_master_send(client , (u8 *)&reg , 2);
+	if (ret < 0) {
+		mdelay(1);
+
+		if (++count < 8)
+			goto retry;
+
+		return ret;
+	}
+
+	/* for setup tx transaction. */
+	udelay(200);
+
+	ret = i2c_master_recv(client , values , length);
+	if (ret < 0)
+		return ret;
+
+	udelay(DELAY_FOR_POST_TRANSCATION);
+	return length;
+}
+
+static inline s32 read_firmware_data(struct i2c_client *client,
+	u16 addr, u8 *values, u16 length)
+{
+	s32 ret;
+	/* select register*/
+
+	ret = i2c_master_send(client , (u8 *)&addr , 2);
+	if (ret < 0)
+		return ret;
+
+	/* for setup tx transaction. */
+	mdelay(1);
+
+	ret = i2c_master_recv(client , values , length);
+	if (ret < 0)
+		return ret;
+
+	udelay(DELAY_FOR_POST_TRANSCATION);
+	return length;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bt532_ts_early_suspend(struct early_suspend *h);
+static void bt532_ts_late_resume(struct early_suspend *h);
+#endif
+
+static bool bt532_power_control(struct bt532_ts_info *info, u8 ctl);
+
+static bool init_touch(struct bt532_ts_info *info);
+static bool mini_init_touch(struct bt532_ts_info *info);
+static void clear_report_data(struct bt532_ts_info *info);
+static void esd_timer_start(u16 sec, struct bt532_ts_info *info);
+static void esd_timer_stop(struct bt532_ts_info *info);
+static void esd_timer_init(struct bt532_ts_info *info);
+static void esd_timeout_handler(unsigned long data);
+
+static long ts_misc_fops_ioctl(struct file *filp, unsigned int cmd,
+								unsigned long arg);
+static int ts_misc_fops_open(struct inode *inode, struct file *filp);
+static int ts_misc_fops_close(struct inode *inode, struct file *filp);
+
+static const struct file_operations ts_misc_fops = {
+	.owner = THIS_MODULE,
+	.open = ts_misc_fops_open,
+	.release = ts_misc_fops_close,
+	.unlocked_ioctl = ts_misc_fops_ioctl,
+};
+
+static struct miscdevice touch_misc_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "zinitix_touch_misc",
+	.fops = &ts_misc_fops,
+};
+
+#define TOUCH_IOCTL_BASE	0xbc
+#define TOUCH_IOCTL_GET_DEBUGMSG_STATE		_IOW(TOUCH_IOCTL_BASE, 0, int)
+#define TOUCH_IOCTL_SET_DEBUGMSG_STATE		_IOW(TOUCH_IOCTL_BASE, 1, int)
+#define TOUCH_IOCTL_GET_CHIP_REVISION		_IOW(TOUCH_IOCTL_BASE, 2, int)
+#define TOUCH_IOCTL_GET_FW_VERSION			_IOW(TOUCH_IOCTL_BASE, 3, int)
+#define TOUCH_IOCTL_GET_REG_DATA_VERSION	_IOW(TOUCH_IOCTL_BASE, 4, int)
+#define TOUCH_IOCTL_VARIFY_UPGRADE_SIZE		_IOW(TOUCH_IOCTL_BASE, 5, int)
+#define TOUCH_IOCTL_VARIFY_UPGRADE_DATA		_IOW(TOUCH_IOCTL_BASE, 6, int)
+#define TOUCH_IOCTL_START_UPGRADE			_IOW(TOUCH_IOCTL_BASE, 7, int)
+#define TOUCH_IOCTL_GET_X_NODE_NUM			_IOW(TOUCH_IOCTL_BASE, 8, int)
+#define TOUCH_IOCTL_GET_Y_NODE_NUM			_IOW(TOUCH_IOCTL_BASE, 9, int)
+#define TOUCH_IOCTL_GET_TOTAL_NODE_NUM		_IOW(TOUCH_IOCTL_BASE, 10, int)
+#define TOUCH_IOCTL_SET_RAW_DATA_MODE		_IOW(TOUCH_IOCTL_BASE, 11, int)
+#define TOUCH_IOCTL_GET_RAW_DATA			_IOW(TOUCH_IOCTL_BASE, 12, int)
+#define TOUCH_IOCTL_GET_X_RESOLUTION		_IOW(TOUCH_IOCTL_BASE, 13, int)
+#define TOUCH_IOCTL_GET_Y_RESOLUTION		_IOW(TOUCH_IOCTL_BASE, 14, int)
+#define TOUCH_IOCTL_HW_CALIBRAION			_IOW(TOUCH_IOCTL_BASE, 15, int)
+#define TOUCH_IOCTL_GET_REG					_IOW(TOUCH_IOCTL_BASE, 16, int)
+#define TOUCH_IOCTL_SET_REG					_IOW(TOUCH_IOCTL_BASE, 17, int)
+#define TOUCH_IOCTL_SEND_SAVE_STATUS		_IOW(TOUCH_IOCTL_BASE, 18, int)
+#define TOUCH_IOCTL_DONOT_TOUCH_EVENT		_IOW(TOUCH_IOCTL_BASE, 19, int)
+
+struct bt532_ts_info *misc_info;
+
+static bool get_raw_data(struct bt532_ts_info *info, u8 *buff, int skip_cnt)
+{
+	struct i2c_client *client = info->client;
+	struct bt532_ts_platform_data *pdata = info->pdata;
+	u32 total_node = info->cap_info.total_node_num;
+	u32 sz;
+	int i;
+
+	disable_irq(info->irq);
+
+	down(&info->work_lock);
+	if (info->work_state != NOTHING) {
+		printk(KERN_INFO "other process occupied.. (%d)\n",
+			info->work_state);
+		enable_irq(info->irq);
+		up(&info->work_lock);
+		return false;
+		}
+
+	info->work_state = RAW_DATA;
+
+	for(i = 0; i < skip_cnt; i++) {
+		while (gpio_get_value(pdata->gpio_int))
+			msleep(1);
+
+		write_cmd(client, BT532_CLEAR_INT_STATUS_CMD);
+		msleep(1);
+	}
+
+	zinitix_debug_msg("read raw data\r\n");
+	sz = total_node*2;
+
+	while (gpio_get_value(pdata->gpio_int))
+		msleep(1);
+
+	if (read_raw_data(client, BT532_RAWDATA_REG, (char *)buff, sz) < 0) {
+		zinitix_printk("error : read zinitix tc raw data\n");
+		info->work_state = NOTHING;
+		enable_irq(info->irq);
+		up(&info->work_lock);
+		return false;
+	}
+
+	write_cmd(client, BT532_CLEAR_INT_STATUS_CMD);
+	info->work_state = NOTHING;
+	enable_irq(info->irq);
+	up(&info->work_lock);
+
+	return true;
+}
+
+static bool ts_get_raw_data(struct bt532_ts_info *info)
+{
+	struct i2c_client *client = info->client;
+	u32 total_node = info->cap_info.total_node_num;
+	u32 sz;
+
+	if (down_trylock(&info->raw_data_lock)) {
+		dev_err(&client->dev, "Failed to occupy sema\n");
+		info->touch_info.status = 0;
+		return true;
+	}
+
+	sz = total_node * 2 + sizeof(struct point_info);
+
+	if (read_raw_data(info->client, BT532_RAWDATA_REG,
+			(char *)info->cur_data, sz) < 0) {
+		dev_err(&client->dev, "Failed to read raw data\n");
+		up(&info->raw_data_lock);
+		return false;
+	}
+
+	info->update = 1;
+	memcpy((u8 *)(&info->touch_info),
+		(u8 *)&info->cur_data[total_node],
+		sizeof(struct point_info));
+	up(&info->raw_data_lock);
+
+	return true;
+}
+
+static bool ts_read_coord(struct bt532_ts_info *info)
+{
+	struct i2c_client *client = info->client;
+#if (TOUCH_POINT_MODE == 1)
+	int i;
+#endif
+
+	/* zinitix_debug_msg("ts_read_coord+\r\n"); */
+
+	/* for  Debugging Tool */
+
+	if (info->touch_mode != TOUCH_POINT_MODE) {
+		if (ts_get_raw_data(info) == false)
+			return false;
+
+		dev_err(&client->dev, "status = 0x%04X\n", info->touch_info.status);
+
+		goto out;
+	}
+
+#if (TOUCH_POINT_MODE == 1)
+	memset(&info->touch_info,
+			0x0, sizeof(struct point_info));
+
+	if (read_data(info->client, BT532_POINT_STATUS_REG,
+			(u8 *)(&info->touch_info), 4) < 0) {
+		dev_err(&client->dev, "%s: Failed to read point info\n", __func__);
+
+		return false;
+	}
+
+	dev_info(&client->dev, "status reg = 0x%x , event_flag = 0x%04x\n",
+				info->touch_info.status, info->touch_info.event_flag);
+
+	if (info->touch_info.event_flag == 0)
+		goto out;
+
+	for (i = 0; i < info->cap_info.multi_fingers; i++) {
+		if (zinitix_bit_test(info->touch_info.event_flag, i)) {
+			udelay(20);
+
+			if (read_data(info->client, BT532_POINT_STATUS_REG + 2 + ( i * 4),
+					(u8 *)(&info->touch_info.coord[i]),
+					sizeof(struct coord)) < 0) {
+				dev_err(&client->dev, "Failed to read point info\n");
+
+				return false;
+			}
+		}
+	}
+
+#else
+	if (read_data(info->client, BT532_POINT_STATUS_REG,
+			(u8 *)(&info->touch_info), sizeof(struct point_info)) < 0) {
+		dev_err(&client->dev, "Failed to read point info\n");
+
+		return false;
+	}
+#endif
+
+out:
+	/* error */
+	if (zinitix_bit_test(info->touch_info.status, BIT_MUST_ZERO)) {
+		dev_err(&client->dev, "Invalid must zero bit(%04x)\n",
+			info->touch_info.status);
+		/*write_cmd(info->client, BT532_CLEAR_INT_STATUS_CMD);
+		udelay(DELAY_FOR_SIGNAL_DELAY);*/
+		return false;
+	}
+/*
+	if (zinitix_bit_test(info->touch_info.status, BIT_ICON_EVENT)) {
+		udelay(20);
+		if (read_data(info->client,
+			BT532_ICON_STATUS_REG,
+			(u8 *)(&info->icon_event_reg), 2) < 0) {
+			zinitix_printk("error read icon info using i2c.\n");
+			return false;
+		}
+	}
+*/
+	write_cmd(info->client, BT532_CLEAR_INT_STATUS_CMD);
+	/* udelay(DELAY_FOR_SIGNAL_DELAY); */
+	/* zinitix_debug_msg("ts_read_coord-\r\n"); */
+	return true;
+}
+
+#if ESD_TIMER_INTERVAL
+static void esd_timeout_handler(unsigned long data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)data;
+
+	info->p_esd_timeout_tmr = NULL;
+	queue_work(esd_tmr_workqueue, &info->tmr_work);
+}
+
+static void esd_timer_start(u16 sec, struct bt532_ts_info *info)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&info->lock, flags);
+	if (info->p_esd_timeout_tmr != NULL)
+#ifdef CONFIG_SMP
+		del_singleshot_timer_sync(info->p_esd_timeout_tmr);
+#else
+		del_timer(info->p_esd_timeout_tmr);
+#endif
+	info->p_esd_timeout_tmr = NULL;
+	init_timer(&(info->esd_timeout_tmr));
+	info->esd_timeout_tmr.data = (unsigned long)(info);
+	info->esd_timeout_tmr.function = esd_timeout_handler;
+	info->esd_timeout_tmr.expires = jiffies + (HZ * sec);
+	info->p_esd_timeout_tmr = &info->esd_timeout_tmr;
+	add_timer(&info->esd_timeout_tmr);
+	spin_unlock_irqrestore(&info->lock, flags);
+}
+
+static void esd_timer_stop(struct bt532_ts_info *info)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&info->lock, flags);
+	if (info->p_esd_timeout_tmr)
+#ifdef CONFIG_SMP
+		del_singleshot_timer_sync(info->p_esd_timeout_tmr);
+#else
+		del_timer(info->p_esd_timeout_tmr);
+#endif
+
+	info->p_esd_timeout_tmr = NULL;
+	spin_unlock_irqrestore(&info->lock, flags);
+}
+
+static void esd_timer_init(struct bt532_ts_info *info)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&info->lock, flags);
+	init_timer(&(info->esd_timeout_tmr));
+	info->esd_timeout_tmr.data = (unsigned long)(info);
+	info->esd_timeout_tmr.function = esd_timeout_handler;
+	info->p_esd_timeout_tmr = NULL;
+	spin_unlock_irqrestore(&info->lock, flags);
+}
+
+static void ts_tmr_work(struct work_struct *work)
+{
+	struct bt532_ts_info *info =
+				container_of(work, struct bt532_ts_info, tmr_work);
+	struct i2c_client *client = info->client;
+
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&client->dev, "tmr queue work ++\n");
+#endif
+
+	if(down_trylock(&info->work_lock)) {
+		dev_err(&client->dev, "%s: Failed to occupy work lock\n", __func__);
+		esd_timer_start(CHECK_ESD_TIMER, info);
+
+		return;
+	}
+
+	if (info->work_state != NOTHING) {
+		dev_info(&client->dev, "%s: Other process occupied (%d)\n",
+			__func__, info->work_state);
+		up(&info->work_lock);
+
+		return;
+	}
+	info->work_state = ESD_TIMER;
+
+	disable_irq(info->irq);
+	bt532_power_control(info, POWER_OFF);
+	bt532_power_control(info, POWER_ON_SEQUENCE);
+
+	clear_report_data(info);
+	if (mini_init_touch(info) == false)
+		goto fail_time_out_init;
+
+	info->work_state = NOTHING;
+	enable_irq(info->irq);
+	up(&info->work_lock);
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&client->dev, "tmr queue work--\n");
+#endif
+
+	return;
+fail_time_out_init:
+	dev_err(&client->dev, "%s: Failed to restart\n", __func__);
+	esd_timer_start(CHECK_ESD_TIMER, info);
+	info->work_state = NOTHING;
+	enable_irq(info->irq);
+	up(&info->work_lock);
+
+	return;
+}
+#endif
+
+static bool bt532_power_sequence(struct bt532_ts_info *info)
+{
+	struct i2c_client *client = info->client;
+	int retry = 0;
+	u16 chip_code;
+
+retry_power_sequence:
+	if (write_reg(client, 0xc000, 0x0001) != I2C_SUCCESS) {
+		dev_err(&client->dev, "Failed to send power sequence(vendor cmd enable)\n");
+		goto fail_power_sequence;
+	}
+	udelay(10);
+
+	if (read_data(client, 0xcc00, (u8 *)&chip_code, 2) < 0) {
+		dev_err(&client->dev, "Failed to read chip code\n");
+		goto fail_power_sequence;
+	}
+
+	dev_info(&client->dev, "%s: chip code = 0x%x\n", __func__, chip_code);
+	udelay(10);
+
+	if (write_cmd(client, 0xc004) != I2C_SUCCESS) {
+		dev_err(&client->dev, "Failed to send power sequence(intn clear)\n");
+		goto fail_power_sequence;
+	}
+	udelay(10);
+
+	if (write_reg(client, 0xc002, 0x0001) != I2C_SUCCESS) {
+		dev_err(&client->dev, "Failed to send power sequence(nvm init)\n");
+		goto fail_power_sequence;
+	}
+	mdelay(2);
+
+	if (write_reg(client, 0xc001, 0x0001) != I2C_SUCCESS) {
+		dev_err(&client->dev, "Failed to send power sequence(program start)\n");
+		goto fail_power_sequence;
+	}
+	msleep(FIRMWARE_ON_DELAY);	/* wait for checksum cal */
+
+	return true;
+
+fail_power_sequence:
+	if (retry++ < 3) {
+		msleep(CHIP_ON_DELAY);
+		dev_info(&client->dev, "retry = %d\n", retry);
+		goto retry_power_sequence;
+	}
+
+	return false;
+}
+
+static bool bt532_power_control(struct bt532_ts_info *info, u8 ctl)
+{
+#if ZINITIX_TSP_USE_LDO_POWER
+	int ret = 0;
+	pr_info("[TSP] %s, %d\n", __func__, ctl);
+
+	ret = info->pdata->tsp_power(ctl);
+	if (ret)
+		return false;
+
+	if (ctl == POWER_ON_SEQUENCE) {
+		msleep(CHIP_ON_DELAY);
+		return bt532_power_sequence(info);
+	}
+	return true;
+#else
+	if ((ctl == POWER_OFF) || (ctl == PM_POWER_OFF)) {
+		gpio_direction_output(pdata->gpio_ldo_en, 0);
+		msleep(CHIP_OFF_DELAY);
+	} else {
+		gpio_direction_output(pdata->gpio_ldo_en, 1);
+
+		/* zxt power on sequence */
+		if (ctl == POWER_ON_SEQUENCE) {
+			msleep(CHIP_ON_DELAY);
+			return bt532_power_sequence(info);
+		}
+	}
+
+	return true;
+#endif
+}
+
+#if TOUCH_ONESHOT_UPGRADE
+static bool ts_check_need_upgrade(struct bt532_ts_info *info,
+	u16 cur_version, u16 cur_minor_version, u16 cur_reg_version, u16 cur_hw_id)
+{
+	u16	new_version;
+	u16	new_minor_version;
+	u16	new_reg_version;
+//	u16	new_chip_code;
+#if CHECK_HWID
+	u16	new_hw_id;
+#endif
+	new_version = (u16) (m_firmware_data[52] | (m_firmware_data[53]<<8));
+	new_minor_version = (u16) (m_firmware_data[56] | (m_firmware_data[57]<<8));
+	new_reg_version = (u16) (m_firmware_data[60] | (m_firmware_data[61]<<8));
+//	new_chip_code = (u16) (m_firmware_data[64] | (m_firmware_data[65]<<8));
+
+#if CHECK_HWID
+	new_hw_id = (u16) (m_firmware_data[0x6b12] | (m_firmware_data[0x6b13]<<8));
+	zinitix_printk("cur HW_ID = 0x%x, new HW_ID = 0x%x\n",
+		cur_hw_id, new_hw_id);
+	if (cur_hw_id != new_hw_id)
+		return false;
+#endif
+
+	zinitix_printk("cur version = 0x%x, new version = 0x%x\n",
+		cur_version, new_version);
+	if(cur_version > 0xFF)
+		return true;
+	if (cur_version < new_version)
+		return true;
+	else if (cur_version > new_version)
+		return false;
+
+	zinitix_printk("cur minor version = 0x%x, new minor version = 0x%x\n",
+			cur_minor_version, new_minor_version);
+	if (cur_minor_version < new_minor_version)
+		return true;
+	else if (cur_minor_version > new_minor_version)
+		return false;
+
+	zinitix_printk("cur reg data version = 0x%x, new reg data version = 0x%x\n",
+			cur_reg_version, new_reg_version);
+	if (cur_reg_version < new_reg_version)
+		return true;
+
+	return false;
+}
+#endif
+
+#define TC_SECTOR_SZ		8
+
+static u8 ts_upgrade_firmware(struct bt532_ts_info *info,
+	const u8 *firmware_data, u32 size)
+{
+	struct i2c_client *client = info->client;
+	u16 flash_addr;
+	u8 *verify_data;
+	int retry_cnt = 0;
+	int i;
+	int page_sz = 64;
+	u16 chip_code;
+
+	verify_data = kzalloc(size, GFP_KERNEL);
+	if (verify_data == NULL) {
+		zinitix_printk(KERN_ERR "cannot alloc verify buffer\n");
+		return false;
+	}
+
+retry_upgrade:
+	bt532_power_control(info, POWER_OFF);
+	bt532_power_control(info, POWER_ON);
+	mdelay(10);
+
+	if (write_reg(client, 0xc000, 0x0001) != I2C_SUCCESS){
+		zinitix_printk("power sequence error (vendor cmd enable)\n");
+		goto fail_upgrade;
+	}
+
+	udelay(10);
+
+	if (read_data(client, 0xcc00, (u8 *)&chip_code, 2) < 0) {
+		zinitix_printk("failed to read chip code\n");
+		goto fail_upgrade;
+	}
+
+	zinitix_printk("chip code = 0x%x\n", chip_code);
+	page_sz = 128;
+	udelay(10);
+
+	if (write_cmd(client, 0xc004) != I2C_SUCCESS){
+		zinitix_printk("power sequence error (intn clear)\n");
+		goto fail_upgrade;
+	}
+
+	udelay(10);
+
+	if (write_reg(client, 0xc002, 0x0001) != I2C_SUCCESS){
+		zinitix_printk("power sequence error (nvm init)\n");
+		goto fail_upgrade;
+	}
+
+	mdelay(5); 
+
+	zinitix_printk(KERN_INFO "init flash\n");
+
+	if (write_reg(client, 0xc003, 0x0001) != I2C_SUCCESS){
+		zinitix_printk("failed to write nvm vpp on\n");
+		goto fail_upgrade;
+	}
+
+	if (write_reg(client, 0xc104, 0x0001) != I2C_SUCCESS){
+		zinitix_printk("failed to write nvm wp disable\n");
+		goto fail_upgrade;
+	}
+
+	if (write_cmd(client, BT532_INIT_FLASH) != I2C_SUCCESS) {
+		zinitix_printk(KERN_INFO "failed to init flash\n");
+		goto fail_upgrade;
+	}
+
+	zinitix_printk(KERN_INFO "writing firmware data\n");
+	for (flash_addr = 0; flash_addr < size; ) {
+		for (i = 0; i < page_sz/TC_SECTOR_SZ; i++) {
+			//zinitix_debug_msg("write :addr=%04x, len=%d\n",	flash_addr, TC_SECTOR_SZ);
+			if (write_data(client,
+				BT532_WRITE_FLASH,
+				(u8 *)&firmware_data[flash_addr],TC_SECTOR_SZ) < 0) {
+				zinitix_printk(KERN_INFO"error : write zinitix tc firmare\n");
+				goto fail_upgrade;
+			}
+			flash_addr += TC_SECTOR_SZ;
+			udelay(100);
+		}
+
+		mdelay(30);	/*for fuzing delay*/
+	}
+
+	if (write_reg(client, 0xc003, 0x0000) != I2C_SUCCESS){
+		zinitix_printk("nvm write vpp off\n");
+		goto fail_upgrade;
+	}
+
+	if (write_reg(client, 0xc104, 0x0000) != I2C_SUCCESS){
+		zinitix_printk("nvm wp enable\n");
+		goto fail_upgrade;
+	}
+
+	zinitix_printk(KERN_INFO "init flash\n");
+
+	if (write_cmd(client, BT532_INIT_FLASH) != I2C_SUCCESS) {
+		zinitix_printk(KERN_INFO "failed to init flash\n");
+		goto fail_upgrade;
+	}
+
+	zinitix_printk(KERN_INFO "read firmware data\n");
+
+	for (flash_addr = 0; flash_addr < size; ) {
+		for (i = 0; i < page_sz/TC_SECTOR_SZ; i++) {
+			//zinitix_debug_msg("read :addr=%04x, len=%d\n", flash_addr, TC_SECTOR_SZ);
+			if (read_firmware_data(client,
+				BT532_READ_FLASH,
+				(u8*)&verify_data[flash_addr], TC_SECTOR_SZ) < 0) {
+				dev_err(&client->dev, "Failed to read firmare\n");
+
+				goto fail_upgrade;
+			}
+
+			flash_addr += TC_SECTOR_SZ;
+		}
+	}
+	/* verify */
+	dev_info(&client->dev, "verify firmware data\n");
+	if (memcmp((u8 *)&firmware_data[0], (u8 *)&verify_data[0], size) == 0) {
+		dev_info(&client->dev, "upgrade finished\n");
+		kfree(verify_data);
+		bt532_power_control(info, POWER_OFF);
+		bt532_power_control(info, POWER_ON_SEQUENCE);
+
+		return true;
+	}
+
+fail_upgrade:
+	bt532_power_control(info, POWER_OFF);
+
+	if (retry_cnt++ < INIT_RETRY_CNT) {
+		dev_err(&client->dev, "upgrade failed : so retry... (%d)\n", retry_cnt);
+		goto retry_upgrade;
+	}
+
+	if (verify_data != NULL)
+		kfree(verify_data);
+
+	dev_info(&client->dev, "Failed to upgrade\n");
+
+	return false;
+}
+
+static bool ts_hw_calibration(struct bt532_ts_info *info)
+{
+	struct i2c_client *client = info->client;
+	u16	chip_eeprom_info;
+	int time_out = 0;
+
+	if (write_reg(client,
+		BT532_TOUCH_MODE, 0x07) != I2C_SUCCESS)
+		return false;
+	mdelay(10);
+	write_cmd(client, BT532_CLEAR_INT_STATUS_CMD);
+	mdelay(10);
+	write_cmd(client, BT532_CLEAR_INT_STATUS_CMD);
+	mdelay(50);
+	write_cmd(client, BT532_CLEAR_INT_STATUS_CMD);
+	mdelay(10);
+
+	if (write_cmd(client,
+		BT532_CALIBRATE_CMD) != I2C_SUCCESS)
+		return false;
+
+	if (write_cmd(client,
+		BT532_CLEAR_INT_STATUS_CMD) != I2C_SUCCESS)
+		return false;
+
+	mdelay(10);
+	write_cmd(client, BT532_CLEAR_INT_STATUS_CMD);
+
+	/* wait for h/w calibration*/
+	do {
+		mdelay(500);
+		write_cmd(client,
+				BT532_CLEAR_INT_STATUS_CMD);
+
+		if (read_data(client,
+			BT532_EEPROM_INFO_REG,
+			(u8 *)&chip_eeprom_info, 2) < 0)
+			return false;
+
+		zinitix_debug_msg("touch eeprom info = 0x%04X\r\n",
+			chip_eeprom_info);
+		if (!zinitix_bit_test(chip_eeprom_info, 0))
+			break;
+
+		if(time_out++ == 4){
+			write_cmd(client, BT532_CALIBRATE_CMD);
+			mdelay(10);
+			write_cmd(client, BT532_CLEAR_INT_STATUS_CMD);
+			dev_err(&client->dev, "h/w calibration retry timeout.\n");
+		}
+
+		if(time_out++ > 10){
+			dev_err(&client->dev, "h/w calibration timeout.\n");
+			break;
+		}
+
+	} while (1);
+
+	if (write_reg(client,
+		BT532_TOUCH_MODE, TOUCH_POINT_MODE) != I2C_SUCCESS)
+		return false;
+
+	if (info->cap_info.ic_int_mask != 0) {
+		if (write_reg(client,
+			BT532_INT_ENABLE_FLAG,
+			info->cap_info.ic_int_mask)
+			!= I2C_SUCCESS)
+			return false;
+	}
+
+	write_reg(client, 0xc003, 0x0001);
+	write_reg(client, 0xc104, 0x0001);
+	udelay(100);
+	if (write_cmd(client,
+		BT532_SAVE_CALIBRATION_CMD) != I2C_SUCCESS)
+		return false;
+
+	mdelay(1000);
+	write_reg(client, 0xc003, 0x0000);
+	write_reg(client, 0xc104, 0x0000);
+	return true;
+}
+
+static bool init_touch(struct bt532_ts_info *info)
+{
+	struct bt532_ts_platform_data *pdata = info->pdata;
+	struct i2c_client *client = info->client;
+	struct capa_info *cap = &(info->cap_info);
+	u16 reg_val;
+	int i;
+	u16 chip_eeprom_info;
+#if USE_CHECKSUM
+	u16 chip_check_sum;
+	u8 checksum_err;
+#endif
+	int retry_cnt = 0;
+
+retry_init:
+	for(i = 0; i < INIT_RETRY_CNT; i++) {
+		if (read_data(client, BT532_EEPROM_INFO_REG,
+						(u8 *)&chip_eeprom_info, 2) < 0) {
+			dev_err(&client->dev, "Failed to read eeprom info(%d)\n", i);
+			mdelay(10);
+			continue;
+		} else
+			break;
+	}
+
+	if (i == INIT_RETRY_CNT)
+		goto fail_init;
+
+#if USE_CHECKSUM
+	dev_info(&client->dev,"%s: Check checksum\n", __func__);
+
+	checksum_err = 0;
+
+	for (i = 0; i < INIT_RETRY_CNT; i++) {
+		if (read_data(client, BT532_CHECKSUM_RESULT,
+						(u8 *)&chip_check_sum, 2) < 0) {
+			mdelay(10);
+			continue;
+		}
+
+#if defined(TSP_VERBOSE_DEBUG)
+		dev_info(&client->dev, "0x%04X\n", chip_check_sum);
+#endif
+
+		if(chip_check_sum == 0x55aa)
+			break;
+		else {
+			checksum_err = 1;
+			break;
+		}
+	}
+
+	if (i == INIT_RETRY_CNT || checksum_err) {
+		dev_err(&client->dev, "Failed to check firmware data\n");
+		if(checksum_err == 1 && retry_cnt < INIT_RETRY_CNT)
+			retry_cnt = INIT_RETRY_CNT;
+
+		goto fail_init;
+	}
+#endif
+
+	if (write_cmd(client, BT532_SWRESET_CMD) != I2C_SUCCESS) {
+		dev_err(&client->dev, "Failed to write reset command\n");
+		goto fail_init;
+	}
+
+	cap->button_num = SUPPORTED_BUTTON_NUM;
+
+	reg_val = 0;
+	zinitix_bit_set(reg_val, BIT_PT_CNT_CHANGE);
+	zinitix_bit_set(reg_val, BIT_DOWN);
+	zinitix_bit_set(reg_val, BIT_MOVE);
+	zinitix_bit_set(reg_val, BIT_UP);
+#if (TOUCH_POINT_MODE == 2)
+	zinitix_bit_set(reg_val, BIT_PALM);
+	zinitix_bit_set(reg_val, BIT_PALM_REJECT);
+#endif
+
+	if (cap->button_num > 0)
+		zinitix_bit_set(reg_val, BIT_ICON_EVENT);
+
+	cap->ic_int_mask = reg_val;
+
+	if (write_reg(client, BT532_INT_ENABLE_FLAG, 0x0) != I2C_SUCCESS)
+		goto fail_init;
+
+	dev_info(&client->dev, "%s: Send reset command\n", __func__);
+	if (write_cmd(client, BT532_SWRESET_CMD) != I2C_SUCCESS)
+		goto fail_init;
+
+	/* get chip information */
+	if (read_data(client, BT532_VENDOR_ID,
+					(u8 *)&cap->vendor_id, 2) < 0) {
+		zinitix_printk("failed to read chip revision\n");
+		goto fail_init;
+	}
+
+	if (read_data(client, BT532_CHIP_REVISION,
+					(u8 *)&cap->ic_revision, 2) < 0) {
+		zinitix_printk("failed to read chip revision\n");
+		goto fail_init;
+	}
+
+	cap->ic_fw_size = 32*1024;
+
+	if (read_data(client, BT532_HW_ID, (u8 *)&cap->hw_id, 2) < 0) {
+		dev_err(&client->dev, "Failed to read hw id\n");
+		goto fail_init;
+	}
+	if (read_data(client, BT532_THRESHOLD, (u8 *)&cap->threshold, 2) < 0)
+		goto fail_init;
+
+	if (read_data(client, BT532_THRESHOLD,
+					(u8 *)&cap->threshold, 2) < 0)
+			goto fail_init;
+
+	if (read_data(client, BT532_BUTTON_SENSITIVITY,
+					(u8 *)&cap->key_threshold, 2) < 0)
+		goto fail_init;
+
+	if (read_data(client, BT532_DUMMY_BUTTON_SENSITIVITY,
+					(u8 *)&cap->dummy_threshold, 2) < 0)
+		goto fail_init;
+
+	if (read_data(client, BT532_TOTAL_NUMBER_OF_X,
+					(u8 *)&cap->x_node_num, 2) < 0)
+		goto fail_init;
+
+	if (read_data(client, BT532_TOTAL_NUMBER_OF_Y,
+					(u8 *)&cap->y_node_num, 2) < 0)
+		goto fail_init;
+
+	cap->total_node_num = cap->x_node_num * cap->y_node_num;
+
+	if (read_data(client, BT532_DND_N_COUNT,
+					(u8 *)&cap->N_cnt, 2) < 0)
+		goto fail_init;
+
+	zinitix_debug_msg("N count = %d\n", cap->N_cnt);
+
+	if (read_data(client, BT532_DND_U_COUNT,
+					(u8 *)&cap->u_cnt, 2) < 0)
+		goto fail_init;
+
+	zinitix_debug_msg("u count = %d\n", cap->u_cnt);
+
+	if (read_data(client, BT532_AFE_FREQUENCY,
+					(u8 *)&cap->afe_frequency, 2) < 0)
+		goto fail_init;
+
+	zinitix_debug_msg("afe frequency = %d\n", cap->afe_frequency);
+
+	//--------------------------------------------------------
+
+	/* get chip firmware version */
+	if (read_data(client, BT532_FIRMWARE_VERSION,
+					(u8 *)&cap->fw_version, 2) < 0)
+		goto fail_init;
+
+	if (read_data(client, BT532_MINOR_FW_VERSION,
+					(u8 *)&cap->fw_minor_version, 2) < 0)
+		goto fail_init;
+
+	if (read_data(client, BT532_DATA_VERSION_REG,
+					(u8 *)&cap->reg_data_version, 2) < 0)
+		goto fail_init;
+
+#if TOUCH_ONESHOT_UPGRADE
+	if (ts_check_need_upgrade(info, cap->fw_version,
+								cap->fw_minor_version, cap->reg_data_version,
+								cap->hw_id) == true) {
+		zinitix_printk("start upgrade firmware\n");
+
+		if(ts_upgrade_firmware(info, m_firmware_data,
+			cap->ic_fw_size) == false)
+			goto fail_init;
+
+		if(ts_hw_calibration(info) == false)
+			goto fail_init;
+
+		/* disable chip interrupt */
+		if (write_reg(client, BT532_INT_ENABLE_FLAG, 0) != I2C_SUCCESS)
+			goto fail_init;
+
+		/* get chip firmware version */
+		if (read_data(client, BT532_FIRMWARE_VERSION,
+						(u8 *)&cap->fw_version, 2) < 0)
+			goto fail_init;
+
+		if (read_data(client, BT532_MINOR_FW_VERSION,
+						(u8 *)&cap->fw_minor_version, 2) < 0)
+			goto fail_init;
+
+		if (read_data(client, BT532_DATA_VERSION_REG,
+						(u8 *)&cap->reg_data_version, 2) < 0)
+			goto fail_init;
+	}
+#endif
+
+	if (read_data(client, BT532_EEPROM_INFO_REG,
+					(u8 *)&chip_eeprom_info, 2) < 0)
+		goto fail_init;
+
+	if (zinitix_bit_test(chip_eeprom_info, 0)) { /* hw calibration bit*/
+		if(ts_hw_calibration(info) == false)
+			goto fail_init;
+
+		/* disable chip interrupt */
+		if (write_reg(client, BT532_INT_ENABLE_FLAG, 0) != I2C_SUCCESS)
+			goto fail_init;
+	}
+
+	/* initialize */
+	if (write_reg(client, BT532_X_RESOLUTION,
+					(u16)pdata->x_resolution) != I2C_SUCCESS)
+		goto fail_init;
+
+	if (write_reg(client, BT532_Y_RESOLUTION,
+					(u16)pdata->y_resolution) != I2C_SUCCESS)
+		goto fail_init;
+
+	cap->MinX = (u32)0;
+	cap->MinY = (u32)0;
+	cap->MaxX = (u32)pdata->x_resolution;
+	cap->MaxY = (u32)pdata->y_resolution;
+
+	if (write_reg(client, BT532_BUTTON_SUPPORTED_NUM,
+		(u16)cap->button_num) != I2C_SUCCESS)
+		goto fail_init;
+
+	if (write_reg(client, BT532_SUPPORTED_FINGER_NUM,
+		(u16)MAX_SUPPORTED_FINGER_NUM) != I2C_SUCCESS)
+		goto fail_init;
+
+	cap->multi_fingers = MAX_SUPPORTED_FINGER_NUM;
+
+	zinitix_debug_msg("max supported finger num = %d\r\n",
+		cap->multi_fingers);
+	cap->gesture_support = 0;
+	zinitix_debug_msg("set other configuration\r\n");
+
+	if (write_reg(client, BT532_INITIAL_TOUCH_MODE,
+					TOUCH_POINT_MODE) != I2C_SUCCESS)
+		goto fail_init;
+
+	if (write_reg(client, BT532_TOUCH_MODE, info->touch_mode) != I2C_SUCCESS)
+		goto fail_init;
+
+	/* soft calibration */
+	if (write_cmd(client, BT532_CALIBRATE_CMD) != I2C_SUCCESS)
+		goto fail_init;
+
+	if (write_reg(client, BT532_INT_ENABLE_FLAG,
+		cap->ic_int_mask) != I2C_SUCCESS)
+		goto fail_init;
+
+	/* read garbage data */
+	for (i = 0; i < 10; i++) {
+		write_cmd(client, BT532_CLEAR_INT_STATUS_CMD);
+		udelay(10);
+	}
+
+	if (info->touch_mode != TOUCH_POINT_MODE) { /* Test Mode */
+		if (write_reg(client, BT532_DELAY_RAW_FOR_HOST,
+			RAWDATA_DELAY_FOR_HOST) != I2C_SUCCESS) {
+			dev_err(&client->dev, "%s: Failed to set DELAY_RAW_FOR_HOST\n",
+						__func__);
+
+			goto fail_init;
+		}
+	}
+#if ESD_TIMER_INTERVAL
+	if (write_reg(client, BT532_PERIODICAL_INTERRUPT_INTERVAL,
+			SCAN_RATE_HZ * ESD_TIMER_INTERVAL) != I2C_SUCCESS)
+		goto fail_init;
+
+	read_data(client, BT532_PERIODICAL_INTERRUPT_INTERVAL, (u8 *)&reg_val, 2);
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&client->dev, "Esd timer register = %d\n", reg_val);
+#endif
+#endif
+	zinitix_debug_msg("successfully initialized\r\n");
+	return true;
+
+fail_init:
+	if (++retry_cnt <= INIT_RETRY_CNT) {
+		bt532_power_control(info, POWER_OFF);
+		bt532_power_control(info, POWER_ON_SEQUENCE);
+
+		zinitix_debug_msg("retry to initiallize(retry cnt = %d)\r\n",
+			retry_cnt);
+		goto	retry_init;
+
+	} else if(retry_cnt == INIT_RETRY_CNT+1) {
+		cap->ic_fw_size = 32*1024;
+
+		zinitix_debug_msg("retry to initiallize(retry cnt = %d)\r\n", retry_cnt);
+#if TOUCH_FORCE_UPGRADE
+		if (ts_upgrade_firmware(info, m_firmware_data,
+			cap->ic_fw_size) == false) {
+			zinitix_printk("upgrade failed\n");
+			return false;
+		}
+		mdelay(100);
+
+		// hw calibration and make checksum
+		if(ts_hw_calibration(info) == false) {
+			zinitix_printk("failed to initiallize\r\n");
+			return false;
+		}
+		goto retry_init;
+#endif
+	}
+
+	dev_err(&client->dev, "Failed to initiallize\n");
+
+	return false;
+}
+
+static bool mini_init_touch(struct bt532_ts_info *info)
+{
+	struct bt532_ts_platform_data *pdata = info->pdata;
+	struct i2c_client *client = info->client;
+	int i;
+#if USE_CHECKSUM
+	u16 chip_check_sum;
+
+	dev_info(&client->dev, "check checksum\n");
+
+	if (read_data(client, BT532_CHECKSUM_RESULT,
+					(u8 *)&chip_check_sum, 2) < 0)
+		goto fail_mini_init;
+
+	if( chip_check_sum != 0x55aa ) {
+		dev_err(&client->dev, "Failed to check firmware"
+					" checksum(0x%04x)\n", chip_check_sum);
+
+		goto fail_mini_init;
+	}
+#endif
+
+	if (write_cmd(client, BT532_SWRESET_CMD) != I2C_SUCCESS) {
+		dev_info(&client->dev, "Failed to write reset command\n");
+
+		goto fail_mini_init;
+	}
+
+	/* initialize */
+	if (write_reg(client, BT532_X_RESOLUTION,
+			(u16)(pdata->x_resolution)) != I2C_SUCCESS)
+		goto fail_mini_init;
+
+	if (write_reg(client,BT532_Y_RESOLUTION,
+			(u16)(pdata->y_resolution)) != I2C_SUCCESS)
+		goto fail_mini_init;
+
+	dev_info(&client->dev, "touch max x = %d\r\n", pdata->x_resolution);
+	dev_info(&client->dev, "touch max y = %d\r\n", pdata->y_resolution);
+
+	if (write_reg(client, BT532_BUTTON_SUPPORTED_NUM,
+			(u16)info->cap_info.button_num) != I2C_SUCCESS)
+		goto fail_mini_init;
+
+	if (write_reg(client, BT532_SUPPORTED_FINGER_NUM,
+			(u16)MAX_SUPPORTED_FINGER_NUM) != I2C_SUCCESS)
+		goto fail_mini_init;
+
+	if (write_reg(client, BT532_INITIAL_TOUCH_MODE,
+			TOUCH_POINT_MODE) != I2C_SUCCESS)
+		goto fail_mini_init;
+
+	if (write_reg(client, BT532_TOUCH_MODE,
+			info->touch_mode) != I2C_SUCCESS)
+		goto fail_mini_init;
+
+	/* soft calibration */
+	if (write_cmd(client, BT532_CALIBRATE_CMD) != I2C_SUCCESS)
+		goto fail_mini_init;
+
+	if (write_reg(client, BT532_INT_ENABLE_FLAG,
+			info->cap_info.ic_int_mask) != I2C_SUCCESS)
+		goto fail_mini_init;
+
+	/* read garbage data */
+	for (i = 0; i < 10; i++) {
+		write_cmd(client, BT532_CLEAR_INT_STATUS_CMD);
+		udelay(10);
+	}
+
+	if (info->touch_mode != TOUCH_POINT_MODE) {
+		if (write_reg(client, BT532_DELAY_RAW_FOR_HOST,
+				RAWDATA_DELAY_FOR_HOST) != I2C_SUCCESS){
+			dev_err(&client->dev, "Failed to set BT532_DELAY_RAW_FOR_HOST\n");
+
+			goto fail_mini_init;
+		}
+	}
+
+#if ESD_TIMER_INTERVAL
+	if (write_reg(client, BT532_PERIODICAL_INTERRUPT_INTERVAL,
+			SCAN_RATE_HZ * ESD_TIMER_INTERVAL) != I2C_SUCCESS)
+		goto fail_mini_init;
+
+	esd_timer_start(CHECK_ESD_TIMER, info);
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&client->dev, "Started esd timer\n");
+#endif
+#endif
+
+	dev_info(&client->dev, "Successfully mini initialized\r\n");
+	return true;
+
+fail_mini_init:
+	dev_err(&client->dev, "Failed to initialize mini init\n");
+	bt532_power_control(info, POWER_OFF);
+	bt532_power_control(info, POWER_ON_SEQUENCE);
+
+	if(init_touch(info) == false) {
+		dev_err(&client->dev, "Failed to initialize\n");
+
+		return false;
+	}
+
+#if ESD_TIMER_INTERVAL
+	esd_timer_start(CHECK_ESD_TIMER, info);
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&client->dev, "Started esd timer\n");
+#endif
+#endif
+	return true;
+}
+
+static void clear_report_data(struct bt532_ts_info *info)
+{
+	int i;
+	u8 reported = 0;
+	u8 sub_status;
+
+	for (i = 0; i < info->cap_info.button_num; i++) {
+		if (info->button[i] == ICON_BUTTON_DOWN) {
+			info->button[i] = ICON_BUTTON_UP;
+			input_report_key(info->input_dev, BUTTON_MAPPING_KEY[i], 0);
+			reported = true;
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+			printk(KERN_INFO "Button up = %d\n", i);
+#else
+			printk(KERN_INFO "Button up\n");
+#endif
+		}
+	}
+
+	for (i = 0; i < info->cap_info.multi_fingers; i++) {
+		sub_status = info->reported_touch_info.coord[i].sub_status;
+		if (zinitix_bit_test(sub_status, SUB_BIT_EXIST)) {
+			input_mt_slot(info->input_dev, i);
+			input_mt_report_slot_state(info->input_dev,	MT_TOOL_FINGER, 0);
+			reported = true;
+			if (!m_ts_debug_mode && TSP_NORMAL_EVENT_MSG)
+				printk(KERN_INFO "[TSP] R %02d\r\n", i);
+		}
+		info->reported_touch_info.coord[i].sub_status = 0;
+	}
+
+	if (reported) {
+		input_sync(info->input_dev);
+	}
+}
+
+#define	PALM_REPORT_WIDTH	200
+#define	PALM_REJECT_WIDTH	255
+
+static irqreturn_t bt532_touch_work(int irq, void *data)
+{
+	struct bt532_ts_info* info = (struct bt532_ts_info*)data;
+	struct bt532_ts_platform_data *pdata = info->pdata;
+	struct i2c_client *client = info->client;
+	int i;
+	u8 reported = false;
+	u8 sub_status;
+	u8 prev_sub_status;
+	u32 x, y, maxX, maxY;
+	u32 w;
+	u32 tmp;
+	u8 palm = 0;
+
+	if (gpio_get_value(info->pdata->gpio_int)) {
+		dev_err(&client->dev, "Invalid interrupt\n");
+
+		return IRQ_HANDLED;
+	}
+
+	if (down_trylock(&info->work_lock)) {
+		dev_err(&client->dev, "%s: Failed to occupy work lock\n", __func__);
+		write_cmd(client, BT532_CLEAR_INT_STATUS_CMD);
+
+		return IRQ_HANDLED;
+	}
+#if ESD_TIMER_INTERVAL
+	esd_timer_stop(info);
+#endif
+
+	if (info->work_state != NOTHING) {
+		dev_err(&client->dev, "%s: Other process occupied\n", __func__);
+		udelay(DELAY_FOR_SIGNAL_DELAY);
+
+		if (!gpio_get_value(info->pdata->gpio_int)) {
+			write_cmd(client, BT532_CLEAR_INT_STATUS_CMD);
+			udelay(DELAY_FOR_SIGNAL_DELAY);
+		}
+
+		goto out;
+	}
+
+	info->work_state = NORMAL;
+
+	if (ts_read_coord(info) == false || info->touch_info.status == 0xffff
+		|| info->touch_info.status == 0x1) { /* maybe desirable reset */
+		dev_err(&client->dev, "Failed to read info coord\n");
+		bt532_power_control(info, POWER_OFF);
+		bt532_power_control(info, POWER_ON_SEQUENCE);
+
+		clear_report_data(info);
+		mini_init_touch(info);
+
+		goto out;
+	}
+
+	/* invalid : maybe periodical repeated int. */
+	if (info->touch_info.status == 0x0)
+		goto out;
+
+	reported = false;
+
+	if (zinitix_bit_test(info->touch_info.status, BIT_ICON_EVENT)) {
+		if (read_data(info->client, BT532_ICON_STATUS_REG,
+			(u8 *)(&info->icon_event_reg), 2) < 0) {
+			dev_err(&client->dev, "Failed to read button info\n");
+			write_cmd(client, BT532_CLEAR_INT_STATUS_CMD);
+
+			goto out;
+		}
+
+		for (i = 0; i < info->cap_info.button_num; i++) {
+			if (zinitix_bit_test(info->icon_event_reg,
+									(BIT_O_ICON0_DOWN + i))) {
+				info->button[i] = ICON_BUTTON_DOWN;
+				input_report_key(info->input_dev, BUTTON_MAPPING_KEY[i], 1);
+				reported = true;
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+				dev_info(&client->dev, "Button down = %d\n", i);
+#else
+				dev_info(&client->dev, "Button down\n");
+#endif
+			}
+		}
+
+		for (i = 0; i < info->cap_info.button_num; i++) {
+			if (zinitix_bit_test(info->icon_event_reg,
+									(BIT_O_ICON0_UP + i))) {
+				info->button[i] = ICON_BUTTON_UP;
+				input_report_key(info->input_dev, BUTTON_MAPPING_KEY[i], 0);
+				reported = true;
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+				dev_info(&client->dev, "Button up = %d\n", i);
+#else
+				dev_info(&client->dev, "Button up\n");
+#endif
+			}
+		}
+	}
+
+	/* if button press or up event occured... */
+	if (reported == true ||
+			!zinitix_bit_test(info->touch_info.status, BIT_PT_EXIST)) {
+		for (i = 0; i < info->cap_info.multi_fingers; i++) {
+			prev_sub_status = info->reported_touch_info.coord[i].sub_status;
+			if (zinitix_bit_test(prev_sub_status, SUB_BIT_EXIST)) {
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+				dev_info(&client->dev, "Finger [%02d] up\n", i);
+#else
+				dev_info(&client->dev, "Finger up\n");
+#endif
+				input_mt_slot(info->input_dev, i);
+				input_mt_report_slot_state(info->input_dev,
+											MT_TOOL_FINGER, 0);
+			}
+		}
+		memset(&info->reported_touch_info, 0x0, sizeof(struct point_info));
+		input_sync(info->input_dev);
+
+		if(reported == true) /* for button event */
+			udelay(100);
+
+		goto out;
+	}
+/*
+	if (zinitix_bit_test(info->touch_info.status, BIT_PALM)) {
+		dev_info(&client->dev, "Palm report\n");
+		palm = 1;
+	}
+
+	if (zinitix_bit_test(info->touch_info.status, BIT_PALM_REJECT)){
+		dev_info(&client->dev, "Palm reject\n");
+		palm = 2;
+	}
+*/
+	for (i = 0; i < info->cap_info.multi_fingers; i++) {
+		sub_status = info->touch_info.coord[i].sub_status;
+		prev_sub_status = info->reported_touch_info.coord[i].sub_status;
+
+		if (zinitix_bit_test(sub_status, SUB_BIT_EXIST)) {
+			x = info->touch_info.coord[i].x;
+			y = info->touch_info.coord[i].y;
+			w = info->touch_info.coord[i].width;
+
+			 /* transformation from touch to screen orientation */
+			if (pdata->orientation & TOUCH_V_FLIP)
+				y = info->cap_info.MaxY
+					+ info->cap_info.MinY - y;
+
+			if (pdata->orientation & TOUCH_H_FLIP)
+				x = info->cap_info.MaxX
+					+ info->cap_info.MinX - x;
+
+			maxX = info->cap_info.MaxX;
+			maxY = info->cap_info.MaxY;
+
+			if (pdata->orientation & TOUCH_XY_SWAP) {
+				zinitix_swap_v(x, y, tmp);
+				zinitix_swap_v(maxX, maxY, tmp);
+			}
+
+			if (x > maxX || y > maxY) {
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+				dev_err(&client->dev,
+							"Invalid coord %d : x=%d, y=%d\n", i, x, y);
+#endif
+				continue;
+			}
+
+			info->touch_info.coord[i].x = x;
+			info->touch_info.coord[i].y = y;
+			if (zinitix_bit_test(sub_status, SUB_BIT_DOWN))
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+				dev_info(&client->dev, "Finger [%02d] x = %d, y = %d,"
+						" w = %d\n", i, x, y, w);
+#else
+				dev_info(&client->dev, "Finger down\n");
+#endif
+
+			if (w == 0)
+				w = 1;
+
+			input_mt_slot(info->input_dev, i);
+			input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 1);
+
+#if (TOUCH_POINT_MODE == 2)
+			if (palm == 0) {
+				if(w >= PALM_REPORT_WIDTH)
+					w = PALM_REPORT_WIDTH - 10;
+			} else if (palm == 1) {	//palm report
+				w = PALM_REPORT_WIDTH;
+//				info->touch_info.coord[i].minor_width = PALM_REPORT_WIDTH;
+			} else if (palm == 2){	// palm reject
+//				x = y = 0;
+				w = PALM_REJECT_WIDTH;
+//				info->touch_info.coord[i].minor_width = PALM_REJECT_WIDTH;
+			}
+#endif
+
+			input_report_abs(info->input_dev, ABS_MT_TOUCH_MAJOR, (u32)w);
+			input_report_abs(info->input_dev, ABS_MT_PRESSURE, (u32)w);
+			input_report_abs(info->input_dev, ABS_MT_WIDTH_MAJOR,
+								(u32)((palm == 1)?w-40:w));
+#if (TOUCH_POINT_MODE == 2)
+			input_report_abs(info->input_dev,
+				ABS_MT_TOUCH_MINOR, (u32)info->touch_info.coord[i].minor_width);
+//			input_report_abs(info->input_dev,
+//				ABS_MT_WIDTH_MINOR, (u32)info->touch_info.coord[i].minor_width);
+//			input_report_abs(info->input_dev,
+//				ABS_MT_ANGLE, info->touch_info.coord[i].angle - 90);
+//			zinitix_debug_msg("finger [%02d] angle = %03d\r\n", i, info->touch_info.coord[i].angle);
+//			input_report_abs(info->input_dev, ABS_MT_PALM, (palm==2)?1:0);
+//			input_report_abs(info->input_dev, ABS_MT_PALM, 1);
+#endif
+
+			input_report_abs(info->input_dev, ABS_MT_POSITION_X, x);
+			input_report_abs(info->input_dev, ABS_MT_POSITION_Y, y);
+		} else if (zinitix_bit_test(sub_status, SUB_BIT_UP)||
+			zinitix_bit_test(prev_sub_status, SUB_BIT_EXIST)) {
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+			dev_info(&client->dev, "Finger [%02d] up\n", i);
+#else
+			dev_info(&client->dev, "Finger up\n");
+#endif
+			memset(&info->touch_info.coord[i], 0x0, sizeof(struct coord));
+			input_mt_slot(info->input_dev, i);
+			input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);
+
+		} else {
+			memset(&info->touch_info.coord[i], 0x0, sizeof(struct coord));
+		}
+	}
+	memcpy((char *)&info->reported_touch_info, (char *)&info->touch_info,
+			sizeof(struct point_info));
+	input_sync(info->input_dev);
+
+out:
+	if (info->work_state == NORMAL) {
+#if ESD_TIMER_INTERVAL
+		esd_timer_start(CHECK_ESD_TIMER, info);
+#endif
+		info->work_state = NOTHING;
+	}
+
+	up(&info->work_lock);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bt532_ts_late_resume(struct early_suspend *h)
+{
+	struct bt532_ts_info *info = misc_info;
+	//info = container_of(h, struct bt532_ts_info, early_suspend);
+
+	if (info == NULL)
+		return;
+	zinitix_printk("late resume++\r\n");
+
+	down(&info->work_lock);
+	if (info->work_state != RESUME
+		&& info->work_state != EALRY_SUSPEND) {
+		zinitix_printk("invalid work proceedure (%d)\r\n",
+			info->work_state);
+		up(&info->work_lock);
+		return;
+	}
+#ifdef CONFIG_PM
+	write_cmd(info->client, BT532_WAKEUP_CMD);
+	mdelay(1);
+#else
+	bt532_power_control(info, POWER_ON_SEQUENCE);
+#endif
+	if (mini_init_touch(info) == false)
+		goto fail_late_resume;
+	enable_irq(info->irq);
+	info->work_state = NOTHING;
+	up(&info->work_lock);
+	zinitix_printk("late resume--\n");
+	return;
+fail_late_resume:
+	zinitix_printk("failed to late resume\n");
+	enable_irq(info->irq);
+	info->work_state = NOTHING;
+	up(&info->work_lock);
+	return;
+}
+
+static void bt532_ts_early_suspend(struct early_suspend *h)
+{
+	struct bt532_ts_info *info = misc_info;
+	/*info = container_of(h, struct bt532_ts_info, early_suspend);*/
+
+	if (info == NULL)
+		return;
+
+	zinitix_printk("early suspend++\n");
+
+	disable_irq(info->irq);
+#if ESD_TIMER_INTERVAL
+	flush_work(&info->tmr_work);
+#endif
+
+	down(&info->work_lock);
+	if (info->work_state != NOTHING) {
+		zinitix_printk("invalid work proceedure (%d)\r\n",
+			info->work_state);
+		up(&info->work_lock);
+		enable_irq(info->irq);
+		return;
+	}
+	info->work_state = EALRY_SUSPEND;
+
+	zinitix_debug_msg("clear all reported points\r\n");
+	clear_report_data(info);
+
+#if ESD_TIMER_INTERVAL
+	write_reg(info->client, BT532_PERIODICAL_INTERRUPT_INTERVAL, 0);
+	esd_timer_stop(info);
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&client->dev, "Stopped esd timer\n");
+#endif
+#endif
+
+#ifdef CONIFG_PM
+	write_reg(info->client, BT532_INT_ENABLE_FLAG, 0x0);
+
+	udelay(100);
+	if (write_cmd(info->client, BT532_SLEEP_CMD) != I2C_SUCCESS) {
+		zinitix_printk("failed to enter into sleep mode\n");
+		up(&info->work_lock);
+		return;
+	}
+#else
+	bt532_power_control(info, POWER_OFF);
+#endif
+	zinitix_printk("early suspend--\n");
+	up(&info->work_lock);
+	return;
+}
+#endif	/* CONFIG_HAS_EARLYSUSPEND */
+
+#if defined(CONFIG_PM) || defined(CONFIG_HAS_EARLYSUSPEND)
+static int bt532_ts_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bt532_ts_info *info = i2c_get_clientdata(client);
+
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&client->dev, "resume++\n");
+#endif
+	down(&info->work_lock);
+	if (info->work_state != SUSPEND) {
+		dev_err(&client->dev, "%s: Invalid work proceedure (%d)\n",
+				__func__, info->work_state);
+		up(&info->work_lock);
+
+		return 0;
+	}
+
+	bt532_power_control(info, POWER_ON_SEQUENCE);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	info->work_state = RESUME;
+#else
+	info->work_state = NOTHING;
+	if (mini_init_touch(info) == false)
+		dev_err(&client->dev, "Failed to resume\n");
+	enable_irq(info->irq);
+#endif
+
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&client->dev, "resume--\n");
+#endif
+	up(&info->work_lock);
+
+	return 0;
+}
+
+static int bt532_ts_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bt532_ts_info *info = i2c_get_clientdata(client);
+
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&client->dev, "suspend++\n");
+#endif
+
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	disable_irq(info->irq);
+#endif
+#if ESD_TIMER_INTERVAL
+	flush_work(&info->tmr_work);
+#endif
+
+	down(&info->work_lock);
+	if (info->work_state != NOTHING
+		&& info->work_state != EALRY_SUSPEND) {
+		dev_err(&client->dev,"%s: Invalid work proceedure (%d)\n",
+				__func__, info->work_state);
+		up(&info->work_lock);
+#ifndef CONFIG_HAS_EARLYSUSPEND
+		enable_irq(info->irq);
+#endif
+		return 0;
+	}
+
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	clear_report_data(info);
+
+#if ESD_TIMER_INTERVAL
+	esd_timer_stop(info);
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&client->dev, "Stopped esd timer\n");
+#endif
+#endif
+#endif
+	write_cmd(info->client, BT532_SLEEP_CMD);
+	bt532_power_control(info, PM_POWER_OFF);
+	info->work_state = SUSPEND;
+
+#if defined(TSP_VERBOSE_DEBUG)
+	zinitix_printk("suspend--\n");
+#endif
+	up(&info->work_lock);
+
+	return 0;
+}
+#endif
+
+static bool ts_set_touchmode(u16 value){
+	int i;
+
+	disable_irq(misc_info->irq);
+
+	down(&misc_info->work_lock);
+	if (misc_info->work_state != NOTHING) {
+		printk(KERN_INFO "other process occupied.. (%d)\n",
+			misc_info->work_state);
+		enable_irq(misc_info->irq);
+		up(&misc_info->work_lock);
+		return -1;
+	}
+
+	misc_info->work_state = SET_MODE;
+
+	if(value == TOUCH_DND_MODE) {
+		if (write_reg(misc_info->client, BT532_DND_N_COUNT,
+						SEC_DND_N_COUNT)!=I2C_SUCCESS)
+			printk(KERN_INFO "[zinitix_touch] TEST Mode : "
+					"Fail to set BT532_DND_N_COUNT %d.\n", SEC_DND_N_COUNT);
+		if (write_reg(misc_info->client, BT532_DND_U_COUNT,
+						SEC_DND_U_COUNT)!=I2C_SUCCESS)
+			printk(KERN_INFO "[zinitix_touch] TEST Mode : "
+					"Fail to set BT532_DND_U_COUNT %d.\n", SEC_DND_U_COUNT);
+		if (write_reg(misc_info->client, BT532_AFE_FREQUENCY,
+						SEC_DND_FREQUENCY)!=I2C_SUCCESS)
+			printk(KERN_INFO "[zinitix_touch] TEST Mode : "
+					"Fail to set BT532_AFE_FREQUENCY %d.\n", SEC_DND_FREQUENCY);
+	}
+	if(value == TOUCH_PDND_MODE) {
+		if (write_reg(misc_info->client, BT532_DND_N_COUNT,
+						SEC_PDND_N_COUNT)!=I2C_SUCCESS)
+			printk(KERN_INFO "[zinitix_touch] TEST Mode : "
+					"Fail to set BT532_DND_N_COUNT %d.\n", SEC_PDND_N_COUNT);
+		if (write_reg(misc_info->client, BT532_DND_U_COUNT,
+						SEC_PDND_U_COUNT)!=I2C_SUCCESS)
+			printk(KERN_INFO "[zinitix_touch] TEST Mode : "
+					"Fail to set BT532_DND_U_COUNT %d.\n", SEC_PDND_U_COUNT);
+		if (write_reg(misc_info->client, BT532_AFE_FREQUENCY,
+						SEC_PDND_FREQUENCY)!=I2C_SUCCESS)
+			printk(KERN_INFO "[zinitix_touch] TEST Mode : "
+					"Fail to set BT532_AFE_FREQUENCY %d.\n", SEC_PDND_FREQUENCY);
+	}
+	else if(misc_info->touch_mode == TOUCH_DND_MODE || misc_info->touch_mode == TOUCH_PDND_MODE) {
+		if (write_reg(misc_info->client, BT532_DND_N_COUNT,
+						misc_info->cap_info.N_cnt)!=I2C_SUCCESS)
+			printk(KERN_INFO "[zinitix_touch] TEST Mode : "
+					"Fail to reset BT532_AFE_FREQUENCY %d.\n",
+					misc_info->cap_info.N_cnt);
+		if (write_reg(misc_info->client, BT532_DND_U_COUNT,
+						misc_info->cap_info.u_cnt)!=I2C_SUCCESS)
+			printk(KERN_INFO "[zinitix_touch] TEST Mode : "
+					"Fail to reset BT532_DND_U_COUNT %d.\n",
+					misc_info->cap_info.u_cnt);
+		if (write_reg(misc_info->client, BT532_AFE_FREQUENCY,
+						misc_info->cap_info.afe_frequency)!=I2C_SUCCESS)
+			printk(KERN_INFO "[zinitix_touch] TEST Mode : "
+					"Fail to reset BT532_AFE_FREQUENCY %d.\n",
+					misc_info->cap_info.afe_frequency);
+	}
+
+	if(value == TOUCH_SEC_MODE)
+		misc_info->touch_mode = TOUCH_POINT_MODE;
+	else
+		misc_info->touch_mode = value;
+
+	printk(KERN_INFO "[zinitix_touch] tsp_set_testmode, "
+			"touchkey_testmode = %d\r\n", misc_info->touch_mode);
+
+	if(misc_info->touch_mode != TOUCH_POINT_MODE) {
+		if (write_reg(misc_info->client, BT532_DELAY_RAW_FOR_HOST,
+			RAWDATA_DELAY_FOR_HOST) != I2C_SUCCESS)
+			zinitix_printk("Fail to set BT532_DELAY_RAW_FOR_HOST.\r\n");
+	}
+
+	if (write_reg(misc_info->client, BT532_TOUCH_MODE,
+					misc_info->touch_mode)!=I2C_SUCCESS)
+		printk(KERN_INFO "[zinitix_touch] TEST Mode : "
+				"Fail to set ZINITX_TOUCH_MODE %d.\r\n", misc_info->touch_mode);
+
+	// clear garbage data
+	for(i=0; i < 10; i++) {
+		mdelay(20);
+		write_cmd(misc_info->client, BT532_CLEAR_INT_STATUS_CMD);
+	}
+
+	misc_info->work_state = NOTHING;
+	enable_irq(misc_info->irq);
+	up(&misc_info->work_lock);
+	return 1;
+}
+
+static int ts_upgrade_sequence(const u8 *firmware_data)
+{
+	disable_irq(misc_info->irq);
+	down(&misc_info->work_lock);
+	misc_info->work_state = UPGRADE;
+
+#if ESD_TIMER_INTERVAL
+	esd_timer_stop(misc_info);
+#endif
+	zinitix_debug_msg("clear all reported points\r\n");
+	clear_report_data(misc_info);
+
+	printk(KERN_INFO "start upgrade firmware\n");
+	if (ts_upgrade_firmware(misc_info,
+		firmware_data,
+		misc_info->cap_info.ic_fw_size) == false) {
+		enable_irq(misc_info->irq);
+		misc_info->work_state = NOTHING;
+		up(&misc_info->work_lock);
+		return -1;
+	}
+
+	if (init_touch(misc_info) == false) {
+		enable_irq(misc_info->irq);
+		misc_info->work_state = NOTHING;
+		up(&misc_info->work_lock);
+		return -1;
+	}
+
+#if ESD_TIMER_INTERVAL
+	esd_timer_start(CHECK_ESD_TIMER, misc_info);
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&misc_info->client->dev, "Started esd timer\n");
+#endif
+#endif
+
+	enable_irq(misc_info->irq);
+	misc_info->work_state = NOTHING;
+	up(&misc_info->work_lock);
+	return 0;
+}
+
+#ifdef SEC_FACTORY_TEST
+static inline void set_cmd_result(struct bt532_ts_info *info, char *buff, int len)
+{
+	strncat(info->factory_info->cmd_result, buff, len);
+}
+
+static inline void set_default_result(struct bt532_ts_info *info)
+{
+	char delim = ':';
+	memset(info->factory_info->cmd_result, 0x00, ARRAY_SIZE(info->factory_info->cmd_result));
+	memcpy(info->factory_info->cmd_result, info->factory_info->cmd, strlen(info->factory_info->cmd));
+	strncat(info->factory_info->cmd_result, &delim, 1);
+}
+
+#define MAX_FW_PATH 255
+#define TSP_FW_FILENAME "zinitix_fw.bin"
+
+static void fw_update(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	int ret = 0;
+	const u8 *buff = 0;
+	mm_segment_t old_fs = {0};
+	struct file *fp = NULL;
+	long fsize = 0, nread = 0;
+	char fw_path[MAX_FW_PATH+1];
+	char result[16] = {0};
+
+	set_default_result(info);
+
+	switch (info->factory_info->cmd_param[0]) {
+	case BUILT_IN:
+		ret = ts_upgrade_sequence((u8*)m_firmware_data);
+		if(ret<0) {
+			info->factory_info->cmd_state = 3;
+			return;
+		}
+		break;
+
+	case UMS:
+		old_fs = get_fs();
+		set_fs(get_ds());
+
+		snprintf(fw_path, MAX_FW_PATH, "/sdcard/%s", TSP_FW_FILENAME);
+		fp = filp_open(fw_path, O_RDONLY, 0);
+		if (IS_ERR(fp)) {
+			dev_err(&client->dev,
+				"file %s open error:%d\n", fw_path, (s32)fp);
+			info->factory_info->cmd_state = 3;
+			goto err_open;
+		}
+
+		fsize = fp->f_path.dentry->d_inode->i_size;
+
+		if(fsize != info->cap_info.ic_fw_size) {
+			dev_err(&client->dev, "invalid fw size!!\n");
+			info->factory_info->cmd_state = 3;
+			goto err_open;
+		}
+
+		buff = kzalloc((size_t)fsize, GFP_KERNEL);
+		if (!buff) {
+			dev_err(&client->dev, "failed to alloc buffer for fw\n");
+			info->factory_info->cmd_state = 3;
+			goto err_alloc;
+		}
+
+		nread = vfs_read(fp, (char __user *)buff, fsize, &fp->f_pos);
+		if (nread != fsize) {
+			info->factory_info->cmd_state = 3;
+			goto err_fw_size;
+		}
+
+		filp_close(fp, current->files);
+		set_fs(old_fs);
+		dev_info(&client->dev, "ums fw is loaded!!\n");
+
+		ret = ts_upgrade_sequence((u8*)buff);
+		if(ret<0) {
+			kfree(buff);
+			info->factory_info->cmd_state = 3;
+			return;
+		}
+		break;
+
+	default:
+		dev_err(&client->dev, "invalid fw file type!!\n");
+		goto not_support;
+	}
+
+	info->factory_info->cmd_state = 2;
+	snprintf(result, sizeof(result) , "%s", "OK");
+	set_cmd_result(info, result,
+				strnlen(result, sizeof(result)));
+
+if (fp != NULL) {
+err_fw_size:
+	kfree(buff);
+err_alloc:
+	filp_close(fp, NULL);
+err_open:
+	set_fs(old_fs);
+}
+not_support:
+	snprintf(result, sizeof(result) , "%s", "NG");
+	set_cmd_result(info, result, strnlen(result, sizeof(result)));
+	return;
+}
+
+static void get_fw_ver_bin(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	u16 fw_version, fw_minor_version, reg_version, hw_id, vendor_id;
+	u32 version, length;
+
+	set_default_result(info);
+
+	/* To Do */
+	/* modify m_firmware_data */
+	fw_version = (u16)(m_firmware_data[52] | (m_firmware_data[53] << 8));
+	fw_minor_version = (u16)(m_firmware_data[56] | (m_firmware_data[57] << 8));
+	reg_version = (u16)(m_firmware_data[60] | (m_firmware_data[61] << 8));
+	hw_id = (u16)(m_firmware_data[0x6b12] | (m_firmware_data[0x6b13] << 8));
+	vendor_id = ntohs(*(u16 *)&m_firmware_data[0x6b22]);
+	version = (u32)((u32)(hw_id & 0xff) << 16) | ((fw_version & 0xf ) << 12)
+				| ((fw_minor_version & 0xf) << 8) | (reg_version & 0xff);
+
+	length = sizeof(vendor_id);
+	snprintf(finfo->cmd_buff, length + 1, "%s", (u8 *)&vendor_id);
+	snprintf(finfo->cmd_buff + length, sizeof(finfo->cmd_buff) - length,
+				"%06X", version);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	finfo->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: %s(%d)\n", __func__, finfo->cmd_buff,
+				strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	return;
+}
+
+static void get_fw_ver_ic(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	u16 fw_version, fw_minor_version, reg_version, hw_id, vendor_id;
+	u32 version, length;
+
+	set_default_result(info);
+
+	fw_version = info->cap_info.fw_version;
+	fw_minor_version = info->cap_info.fw_minor_version;
+	reg_version = info->cap_info.reg_data_version;
+	hw_id = info->cap_info.hw_id;
+	vendor_id = ntohs(info->cap_info.vendor_id);
+	version = (u32)((u32)(hw_id & 0xff) << 16) | ((fw_version & 0xf) << 12)
+				| ((fw_minor_version & 0xf) << 8) | (reg_version & 0xff);
+
+	length = sizeof(vendor_id);
+	snprintf(finfo->cmd_buff, length + 1, "%s", (u8 *)&vendor_id);
+	snprintf(finfo->cmd_buff + length, sizeof(finfo->cmd_buff) - length,
+				"%06X", version);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	finfo->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: %s(%d)\n", __func__, finfo->cmd_buff,
+				strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	return;
+}
+
+static void get_threshold(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+
+	set_default_result(info);
+
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff),
+				"%d", info->cap_info.threshold);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	finfo->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: %s(%d)\n", __func__, finfo->cmd_buff,
+				strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	return;
+}
+
+static void module_off_master(void *device_data)
+{
+	return;
+}
+
+static void module_on_master(void *device_data)
+{
+	return;
+}
+
+static void module_off_slave(void *device_data)
+{
+	return;
+}
+
+static void module_on_slave(void *device_data)
+{
+	return;
+}
+
+#define BT532_VENDOR_NAME "ZINITIX"
+
+static void get_chip_vendor(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+
+	set_default_result(info);
+
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff),
+				"%s", BT532_VENDOR_NAME);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	finfo->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: %s(%d)\n", __func__, finfo->cmd_buff,
+				strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	return;
+}
+
+#define BT532_CHIP_NAME "BT532"
+
+static void get_chip_name(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+
+	set_default_result(info);
+
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "%s", BT532_CHIP_NAME);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	finfo->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: %s(%d)\n", __func__, finfo->cmd_buff,
+				strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	return;
+}
+
+static void get_x_num(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+
+	set_default_result(info);
+
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff),
+				"%u", info->cap_info.x_node_num);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	finfo->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: %s(%d)\n", __func__, finfo->cmd_buff,
+				strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	return;
+}
+
+static void get_y_num(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+
+	set_default_result(info);
+
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff),
+				"%u", info->cap_info.y_node_num);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	finfo->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: %s(%d)\n", __func__, finfo->cmd_buff,
+				strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	return;
+}
+
+static void not_support_cmd(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+
+	set_default_result(info);
+
+	sprintf(finfo->cmd_buff, "%s", "NA");
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	info->factory_info->cmd_state = NOT_APPLICABLE;
+
+	dev_info(&client->dev, "%s: \"%s(%d)\"\n", __func__, finfo->cmd_buff,
+				strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	return;
+}
+
+static void run_reference_read(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	struct tsp_raw_data *raw_data = info->raw_data;
+	u32 min, max;
+	s32 i,j;
+
+	set_default_result(info);
+
+	ts_set_touchmode(TOUCH_DND_MODE);
+	get_raw_data(info, (u8 *)raw_data->ref_data, 10);
+	ts_set_touchmode(TOUCH_POINT_MODE);
+
+	min = raw_data->ref_data[0];
+	max = raw_data->ref_data[0];
+
+	for(i = 0; i < info->cap_info.x_node_num; i++)
+	{
+		for(j = 0; j < info->cap_info.y_node_num; j++)
+		{
+			/*pr_info("ref_data : %d ",
+					raw_data->ref_data[i * info->cap_info.y_node_num + j]);*/
+
+			if(raw_data->ref_data[i * info->cap_info.y_node_num + j] < min &&
+				raw_data->ref_data[i * info->cap_info.y_node_num + j] != 0)
+				min = raw_data->ref_data[i * info->cap_info.y_node_num + j];
+
+			if(raw_data->ref_data[i * info->cap_info.y_node_num + j] > max)
+				max = raw_data->ref_data[i * info->cap_info.y_node_num + j];
+
+		}
+		/*pr_info("\n");*/
+	}
+
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "%d,%d\n", min, max);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	finfo->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: \"%s\"(%d)\n", __func__, finfo->cmd_buff,
+				strlen(finfo->cmd_buff));
+
+	return;
+}
+
+static void get_reference(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	struct tsp_raw_data *raw_data = info->raw_data;
+	unsigned int val;
+	int x_node, y_node;
+	int node_num;
+
+	set_default_result(info);
+
+	x_node = finfo->cmd_param[0];
+	y_node = finfo->cmd_param[1];
+
+	if (x_node < 0 || x_node >= info->cap_info.x_node_num ||
+		y_node < 0 || y_node >= info->cap_info.y_node_num) {
+		snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "%s", "abnormal");
+		set_cmd_result(info, finfo->cmd_buff,
+						strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+		info->factory_info->cmd_state = FAIL;
+		return;
+	}
+
+	node_num = x_node * info->cap_info.y_node_num + y_node;
+
+	val = raw_data->ref_data[node_num];
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "%u", val);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	finfo->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: %s(%d)\n", __func__, finfo->cmd_buff,
+				strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	return;
+}
+
+static void run_preference_read(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	struct tsp_raw_data *raw_data = info->raw_data;
+	u16 min, max;
+	s32 i,j;
+
+	set_default_result(info);
+
+	ts_set_touchmode(TOUCH_PDND_MODE);
+	get_raw_data(info, (u8 *)raw_data->pref_data, 10);
+	ts_set_touchmode(TOUCH_POINT_MODE);
+
+	min = 0xFFFF;
+	max = 0x0000;
+
+	for(i = 0; i < info->cap_info.x_node_num; i++)
+	{
+		for(j = 0; j < info->cap_info.y_node_num; j++)
+		{
+			/*pr_info("pref_data : %d ",
+					raw_data->pref_data[i * info->cap_info.y_node_num + j]);*/
+
+			if (raw_data->pref_data[i * info->cap_info.y_node_num + j] < min &&
+				raw_data->pref_data[i * info->cap_info.y_node_num + j] != 0)
+				min = raw_data->pref_data[i * info->cap_info.y_node_num + j];
+
+			if(raw_data->pref_data[i * info->cap_info.y_node_num + j] > max)
+				max = raw_data->pref_data[i * info->cap_info.y_node_num + j];
+
+		}
+		/*pr_info("\n");*/
+	}
+
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "%d,%d\n", min, max);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	finfo->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: \"%s\"(%d)\n", __func__, finfo->cmd_buff,
+				strlen(finfo->cmd_buff));
+
+	return;
+}
+
+static void get_preference(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	struct tsp_raw_data *raw_data = info->raw_data;
+	unsigned int val;
+	int x_node, y_node;
+	int node_num;
+
+	set_default_result(info);
+
+	x_node = finfo->cmd_param[0];
+	y_node = finfo->cmd_param[1];
+
+	if (x_node < 0 || x_node >= info->cap_info.x_node_num ||
+		y_node < 0 || y_node >= info->cap_info.y_node_num) {
+		snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "%s", "abnormal");
+		set_cmd_result(info, finfo->cmd_buff,
+						strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+		info->factory_info->cmd_state = FAIL;
+
+		return;
+	}
+
+	node_num = x_node * info->cap_info.y_node_num + y_node;
+
+	val = raw_data->pref_data[node_num];
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "%u", val);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	finfo->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: %s(%d)\n", __func__, finfo->cmd_buff,
+				strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	return;
+}
+/*
+static void run_scantime_read(void *device_data)
+{
+	return;
+}
+
+static void get_scantime(void *device_data)
+{
+	return;
+}
+*/
+static void run_delta_read(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	struct tsp_raw_data *raw_data = info->raw_data;
+	s16 min, max;
+	s32 i,j;
+
+	set_default_result(info);
+
+	ts_set_touchmode(TOUCH_DELTA_MODE);
+	get_raw_data(info, (u8 *)(u8 *)raw_data->delta_data, 10);
+	ts_set_touchmode(TOUCH_POINT_MODE);
+	finfo->cmd_state = OK;
+
+	min = (s16)0x7FFF;
+	max = (s16)0x8000;
+
+	for(i = 0; i < info->cap_info.x_node_num; i++)
+	{
+		for(j = 0; j < info->cap_info.y_node_num; j++)
+		{
+			/*printk("delta_data : %d \n", raw_data->delta_data[j+i]);*/
+
+			if(raw_data->delta_data[i * info->cap_info.y_node_num + j] < min &&
+				raw_data->delta_data[i * info->cap_info.y_node_num + j] != 0)
+				min = raw_data->delta_data[i * info->cap_info.y_node_num + j];
+
+			if(raw_data->delta_data[i * info->cap_info.y_node_num + j] > max)
+				max = raw_data->delta_data[i * info->cap_info.y_node_num + j];
+
+		}
+		/*printk("\n");*/
+	}
+
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "%d,%d\n", min, max);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	finfo->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: \"%s\"(%d)\n", __func__, finfo->cmd_buff,
+				strlen(finfo->cmd_buff));
+
+	return;
+}
+
+static void get_delta(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	struct tsp_raw_data *raw_data = info->raw_data;
+	unsigned int val;
+	int x_node, y_node;
+	int node_num;
+
+	set_default_result(info);
+
+	x_node = finfo->cmd_param[0];
+	y_node = finfo->cmd_param[1];
+
+	if (x_node < 0 || x_node >= info->cap_info.x_node_num ||
+		y_node < 0 || y_node >= info->cap_info.y_node_num) {
+		snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "%s", "abnormal");
+		set_cmd_result(info, finfo->cmd_buff,
+						strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+		info->factory_info->cmd_state = FAIL;
+
+		return;
+	}
+
+	node_num = x_node * info->cap_info.y_node_num + y_node;
+
+	val = raw_data->delta_data[node_num];
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "%u", val);
+	set_cmd_result(info, finfo->cmd_buff,
+					strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+	info->factory_info->cmd_state = OK;
+
+	dev_info(&client->dev, "%s: %s(%d)\n", __func__, finfo->cmd_buff,
+				strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	return;
+}
+
+/*
+static void run_intensity_read(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+
+	set_default_result(info);
+
+	ts_set_touchmode(TOUCH_DND_MODE);
+	get_raw_data(info, (u8 *)info->dnd_data, 10);
+	ts_set_touchmode(TOUCH_POINT_MODE);
+
+	//////test////////////////////////////////////////////////////
+	int i,j;
+
+	for(i=0; i<30; i++)
+	{
+		for(j=0; j<18; j++)
+			printk("[TSP] info->dnd_data : %d ", info->dnd_data[j+i]);
+
+		printk("\n");
+	}
+	//////test////////////////////////////////////////////////////
+
+	info->factory_info->cmd_state = 2;
+}
+
+static void get_normal(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	char buff[16] = {0};
+	unsigned int val;
+	int x_node, y_node;
+	int node_num;
+
+	set_default_result(info);
+
+	x_node = info->factory_info->cmd_param[0];
+	y_node = info->factory_info->cmd_param[1];
+
+	if (x_node < 0 || x_node > info->cap_info.x_node_num ||
+		y_node < 0 || y_node > info->cap_info.y_node_num) {
+		snprintf(buff, sizeof(buff), "%s", "abnormal");
+		set_cmd_result(info, buff, strnlen(buff, sizeof(buff)));
+		info->factory_info->cmd_state = 3;
+		return;
+	}
+
+	node_num = x_node*info->cap_info.x_node_num + y_node;
+
+	val = info->normal_data[node_num];
+	snprintf(buff, sizeof(buff), "%u", val);
+	set_cmd_result(info, buff, strnlen(buff, sizeof(buff)));
+	info->factory_info->cmd_state = 2;
+
+	dev_info(&info->client->dev, "%s: %s(%d)\n", __func__,
+				buff, strnlen(buff, sizeof(buff)));
+}
+
+static void get_tkey_delta(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	char buff[16] = {0};
+	u16 val;
+	int btn_node;
+	int ret;
+
+	set_default_result(info);
+
+	btn_node = info->factory_info->cmd_param[0];
+
+	if (btn_node < 0 || btn_node > MAX_SUPPORTED_BUTTON_NUM)
+		goto err_out;
+
+	disable_irq(misc_info->irq);
+	down(&misc_info->work_lock);
+	if (misc_info->work_state != NOTHING) {
+		printk(KERN_INFO "other process occupied.. (%d)\n",
+			misc_info->work_state);
+		enable_irq(misc_info->irq);
+		up(&misc_info->work_lock);
+		goto err_out;
+	}
+	misc_info->work_state = SET_MODE;
+
+	ret = read_data(misc_info->client, BT532_BTN_WIDTH + btn_node, (u8*)&val, 2);
+
+	if (ret < 0) {
+		printk(KERN_INFO "read error..\n");
+		enable_irq(misc_info->irq);
+		misc_info->work_state = NOTHING;
+		up(&misc_info->work_lock);
+		goto err_out;
+	}
+	misc_info->work_state = NOTHING;
+	enable_irq(misc_info->irq);
+	up(&misc_info->work_lock);
+
+	snprintf(buff, sizeof(buff), "%u", val);
+	set_cmd_result(info, buff, strnlen(buff, sizeof(buff)));
+	info->factory_info->cmd_state = 2;
+
+	dev_info(&info->client->dev, "%s: %s(%d)\n", __func__,
+				buff, strnlen(buff, sizeof(buff)));
+	return;
+
+err_out:
+	snprintf(buff, sizeof(buff), "%s", "abnormal");
+	set_cmd_result(info, buff, strnlen(buff, sizeof(buff)));
+	info->factory_info->cmd_state = 3;
+}
+
+static void get_intensity(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	char buff[16] = {0};
+	unsigned int val;
+	int x_node, y_node;
+	int node_num;
+
+	set_default_result(info);
+
+	x_node = info->factory_info->cmd_param[0];
+	y_node = info->factory_info->cmd_param[1];
+
+	if (x_node < 0 || x_node > info->cap_info.x_node_num ||
+		y_node < 0 || y_node > info->cap_info.y_node_num) {
+		snprintf(buff, sizeof(buff), "%s", "abnormal");
+		set_cmd_result(info, buff, strnlen(buff, sizeof(buff)));
+		info->factory_info->cmd_state = 3;
+		return;
+	}
+
+	node_num = x_node*info->cap_info.x_node_num + y_node;
+
+	val = info->dnd_data[node_num];
+	snprintf(buff, sizeof(buff), "%u", val);
+	set_cmd_result(info, buff, strnlen(buff, sizeof(buff)));
+	info->factory_info->cmd_state = 2;
+
+	dev_info(&info->client->dev, "%s: %s(%d)\n", __func__,
+				buff, strnlen(buff, sizeof(buff)));
+}
+
+static void run_normal_read(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+
+	set_default_result(info);
+
+	ts_set_touchmode(TOUCH_NORMAL_MODE);
+	get_raw_data(info, (u8 *)info->normal_data, 10);
+	ts_set_touchmode(TOUCH_POINT_MODE);
+
+	info->factory_info->cmd_state = 2;
+}
+
+static void get_key_threshold(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	int ret = 0;
+	u16 threshold;
+	char buff[16] = {0};
+
+	set_default_result(info);
+
+	ret = read_data(misc_info->client, BT532_BUTTON_SENSITIVITY, (u8*)&threshold, 2);
+
+	if (ret < 0) {
+		snprintf(buff, sizeof(buff), "%s", "failed");
+		set_cmd_result(info, buff, strnlen(buff, sizeof(buff)));
+		info->factory_info->cmd_state = 3;
+		return;
+	}
+
+	snprintf(buff, sizeof(buff), "%u", threshold);
+
+	set_cmd_result(info, buff, strnlen(buff, sizeof(buff)));
+	info->factory_info->cmd_state = 2;
+	dev_info(&info->client->dev, "%s: %s(%d)\n", __func__,
+			buff, strnlen(buff, sizeof(buff)));
+}
+*/
+
+static ssize_t store_cmd(struct device *dev, struct device_attribute
+				  *devattr, const char *buf, size_t count)
+{
+	struct bt532_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	char *cur, *start, *end;
+	char buff[TSP_CMD_STR_LEN] = {0};
+	int len, i;
+	struct tsp_cmd *tsp_cmd_ptr = NULL;
+	char delim = ',';
+	bool cmd_found = false;
+	int param_cnt = 0;
+
+	if (finfo->cmd_is_running == true) {
+		dev_err(&client->dev, "%s: other cmd is running\n", __func__);
+		goto err_out;
+	}
+
+	/* check lock  */
+	mutex_lock(&finfo->cmd_lock);
+	finfo->cmd_is_running = true;
+	mutex_unlock(&finfo->cmd_lock);
+
+	finfo->cmd_state = RUNNING;
+
+	for (i = 0; i < ARRAY_SIZE(finfo->cmd_param); i++)
+		finfo->cmd_param[i] = 0;
+
+	len = (int)count;
+	if (*(buf + len - 1) == '\n')
+		len--;
+
+	memset(finfo->cmd, 0x00, ARRAY_SIZE(finfo->cmd));
+	memcpy(finfo->cmd, buf, len);
+
+	cur = strchr(buf, (int)delim);
+	if (cur)
+		memcpy(buff, buf, cur - buf);
+	else
+		memcpy(buff, buf, len);
+
+	/* find command */
+	list_for_each_entry(tsp_cmd_ptr, &finfo->cmd_list_head, list) {
+		if (!strcmp(buff, tsp_cmd_ptr->cmd_name)) {
+			cmd_found = true;
+			break;
+		}
+	}
+
+	/* set not_support_cmd */
+	if (!cmd_found) {
+		list_for_each_entry(tsp_cmd_ptr, &finfo->cmd_list_head, list) {
+			if (!strcmp("not_support_cmd", tsp_cmd_ptr->cmd_name))
+				break;
+		}
+	}
+
+	/* parsing parameters */
+	if (cur && cmd_found) {
+		cur++;
+		start = cur;
+		memset(buff, 0x00, ARRAY_SIZE(buff));
+		do {
+			if (*cur == delim || cur - buf == len) {
+				end = cur;
+				memcpy(buff, start, end - start);
+				*(buff + strlen(buff)) = '\0';
+				finfo->cmd_param[param_cnt] =
+								(int)simple_strtol(buff, NULL, 10);
+				start = cur + 1;
+				memset(buff, 0x00, ARRAY_SIZE(buff));
+				param_cnt++;
+			}
+			cur++;
+		} while (cur - buf <= len);
+	}
+
+	dev_info(&client->dev, "cmd = %s\n", tsp_cmd_ptr->cmd_name);
+/*	for (i = 0; i < param_cnt; i++)
+		dev_info(&client->dev, "cmd param %d= %d\n", i, finfo->cmd_param[i]);*/
+
+	tsp_cmd_ptr->cmd_func(info);
+
+err_out:
+	return count;
+}
+
+static ssize_t show_cmd_status(struct device *dev,
+		struct device_attribute *devattr, char *buf)
+{
+	struct bt532_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+
+	dev_info(&client->dev, "tsp cmd: status:%d\n", finfo->cmd_state);
+
+	if (finfo->cmd_state == WAITING)
+		snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "WAITING");
+
+	else if (finfo->cmd_state == RUNNING)
+		snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "RUNNING");
+
+	else if (finfo->cmd_state == OK)
+		snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "OK");
+
+	else if (finfo->cmd_state == FAIL)
+		snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "FAIL");
+
+	else if (finfo->cmd_state == NOT_APPLICABLE)
+		snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "NOT_APPLICABLE");
+
+	return snprintf(buf, sizeof(finfo->cmd_buff),
+					"%s\n", finfo->cmd_buff);
+}
+
+static ssize_t show_cmd_result(struct device *dev, struct device_attribute
+				    *devattr, char *buf)
+{
+	struct bt532_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+
+	dev_info(&client->dev, "tsp cmd: result: %s\n", finfo->cmd_result);
+
+	mutex_lock(&finfo->cmd_lock);
+	finfo->cmd_is_running = false;
+	mutex_unlock(&finfo->cmd_lock);
+
+	finfo->cmd_state = WAITING;
+
+	return snprintf(buf, sizeof(finfo->cmd_result),
+					"%s\n", finfo->cmd_result);
+}
+
+static ssize_t bt532_orientation_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct bt532_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	struct bt532_ts_platform_data *pdata = client->dev.platform_data;
+	int count;
+
+	count = sprintf(buf, "%d\n", pdata->orientation);
+	pr_info("tsp: orientation value=%d\n", pdata->orientation);
+
+	return count;
+}
+
+ssize_t bt532_orientation_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct bt532_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	struct bt532_ts_platform_data *pdata = client->dev.platform_data;
+	int orientation;
+
+	if (kstrtoint(buf, 0, &orientation))
+		pr_err("tsp: failed storing orientation value\n");
+
+	if (orientation < 0) {
+		orientation = 0;
+	} else if (orientation > 7) {
+		orientation = 7;
+	}
+
+	if (pdata->orientation != orientation) {
+		if (orientation & TOUCH_XY_SWAP) {
+			input_set_abs_params(info->input_dev, ABS_MT_POSITION_Y,
+				info->cap_info.MinX,
+				info->cap_info.MaxX + ABS_PT_OFFSET,
+				0, 0);
+			input_set_abs_params(info->input_dev, ABS_MT_POSITION_X,
+				info->cap_info.MinY,
+				info->cap_info.MaxY + ABS_PT_OFFSET,
+				0, 0);
+		} else {
+			input_set_abs_params(info->input_dev, ABS_MT_POSITION_X,
+				info->cap_info.MinX,
+				info->cap_info.MaxX + ABS_PT_OFFSET,
+				0, 0);
+			input_set_abs_params(info->input_dev, ABS_MT_POSITION_Y,
+				info->cap_info.MinY,
+				info->cap_info.MaxY + ABS_PT_OFFSET,
+				0, 0);
+		}
+		pdata->orientation = orientation;
+		pr_info("tsp: orientation=%d\n", orientation);
+	}
+
+	return size;
+}
+
+static DEVICE_ATTR(cmd, S_IWUSR | S_IWGRP, NULL, store_cmd);
+static DEVICE_ATTR(cmd_status, S_IRUGO, show_cmd_status, NULL);
+static DEVICE_ATTR(cmd_result, S_IRUGO, show_cmd_result, NULL);
+static DEVICE_ATTR(orientation, S_IRUGO | S_IWUSR, bt532_orientation_show, bt532_orientation_store);
+
+static struct attribute *touchscreen_attributes[] = {
+	&dev_attr_cmd.attr,
+	&dev_attr_cmd_status.attr,
+	&dev_attr_cmd_result.attr,
+	&dev_attr_orientation.attr,
+	NULL,
+};
+
+static struct attribute_group touchscreen_attr_group = {
+	.attrs = touchscreen_attributes,
+};
+
+#ifdef SUPPORTED_TOUCH_KEY
+static ssize_t show_touchkey_threshold(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct bt532_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	struct capa_info *cap = &(info->cap_info);
+
+	dev_info(&client->dev, "%s: key threshold = %d %d %d %d\n", __func__,
+			cap->dummy_threshold, cap->key_threshold, cap->key_threshold, cap->dummy_threshold);
+
+	return snprintf(buf, 41, "%d %d %d %d", cap->dummy_threshold,
+					cap->key_threshold,  cap->key_threshold,
+					cap->dummy_threshold);
+}
+#if 0
+static ssize_t enable_dummy_key(struct device *dev,
+								struct device_attribute *attr,
+								char *buf, size_t count)
+{
+	static char enable = '0';
+	struct bt532_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+
+	if (!strcmp(buf, ""))
+		count = sprintf(buf, "%c", enable);
+	else {
+		if ((buf[0] - '0' <= 1) && count == 2)
+			enable = *buf;
+		else {
+			dev_err(&client->dev, "%s: Invalid parameter\n", __func__);
+
+			goto err_out;
+		}
+	}
+
+	dev_info(&client->dev, "%s: Extra button event %c\n", __func__, enable);
+
+	return count;
+
+err_out:
+	return sprintf(buf, "NG");
+
+	return 0;
+}
+#endif
+static ssize_t show_touchkey_sensitivity(struct device *dev,
+										 struct device_attribute *attr,
+										 char *buf)
+{
+	struct bt532_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	u16 val = 0;
+	int ret;
+	int i;
+
+	if (!strcmp(attr->attr.name, "touchkey_dummy_btn1"))
+		i = 0;
+	else if (!strcmp(attr->attr.name, "touchkey_menu"))
+		i = 1;
+	else if (!strcmp(attr->attr.name, "touchkey_back"))
+		i = 2;
+	else if (!strcmp(attr->attr.name, "touchkey_dummy_btn4"))
+		i = 3;
+	else if (!strcmp(attr->attr.name, "touchkey_dummy_btn5"))
+		i = 4;
+	else if (!strcmp(attr->attr.name, "touchkey_dummy_btn6"))
+		i = 5;
+	else {
+		dev_err(&client->dev, "%s: Invalid attribute\n",__func__);
+
+		goto err_out;
+	}
+
+	ret = read_data(client, BT532_BTN_WIDTH + i, (u8*)&val, 2);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: Failed to read %d's key sensitivity\n",
+					 __func__,i);
+
+		goto err_out;
+	}
+
+	dev_info(&client->dev, "%s: %d's key sensitivity = %d\n",
+				__func__, i, val);
+
+	return snprintf(buf, 6, "%d", val);
+
+err_out:
+	return sprintf(buf, "NG");
+}
+
+static ssize_t show_back_key_raw_data(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static ssize_t show_menu_key_raw_data(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+/*
+static ssize_t show_back_key_idac_data(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static ssize_t show_menu_key_idac_data(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+*/
+
+static DEVICE_ATTR(touchkey_threshold, S_IRUGO, show_touchkey_threshold, NULL);
+/*static DEVICE_ATTR(touch_sensitivity, S_IRUGO, back_key_state_show, NULL);*/
+//static DEVICE_ATTR(extra_button_event, S_IWUSR | S_IWGRP | S_IRUGO, NULL, enable_dummy_key );
+static DEVICE_ATTR(touchkey_dummy_btn1, S_IRUGO,
+					show_touchkey_sensitivity, NULL);
+static DEVICE_ATTR(touchkey_menu, S_IRUGO, show_touchkey_sensitivity, NULL);
+static DEVICE_ATTR(touchkey_dummy_btn3, S_IRUGO,
+					show_touchkey_sensitivity, NULL);
+static DEVICE_ATTR(touchkey_dummy_btn4, S_IRUGO,
+					show_touchkey_sensitivity, NULL);
+static DEVICE_ATTR(touchkey_back, S_IRUGO, show_touchkey_sensitivity, NULL);
+static DEVICE_ATTR(touchkey_dummy_btn6, S_IRUGO,
+					show_touchkey_sensitivity, NULL);
+/*static DEVICE_ATTR(autocal_stat, S_IRUGO, show_autocal_status, NULL);*/
+static DEVICE_ATTR(touchkey_raw_back, S_IRUGO, show_back_key_raw_data, NULL);
+static DEVICE_ATTR(touchkey_raw_menu, S_IRUGO, show_menu_key_raw_data, NULL);
+/*static DEVICE_ATTR(touchkey_idac_back, S_IRUGO, show_back_key_idac_data, NULL);
+static DEVICE_ATTR(touchkey_idac_menu, S_IRUGO, show_menu_key_idac_data, NULL);*/
+
+static struct attribute *touchkey_attributes[] = {
+	&dev_attr_touchkey_threshold.attr,
+	/*&dev_attr_touch_sensitivity.attr,*/
+	&dev_attr_touchkey_back.attr,
+	&dev_attr_touchkey_menu.attr,
+	//&dev_attr_autocal_stat.attr,
+	//&dev_attr_extra_button_event.attr,
+	&dev_attr_touchkey_dummy_btn1.attr,
+	&dev_attr_touchkey_raw_menu.attr,
+	&dev_attr_touchkey_dummy_btn3.attr,
+	&dev_attr_touchkey_dummy_btn4.attr,
+	&dev_attr_touchkey_raw_back.attr,
+	&dev_attr_touchkey_dummy_btn6.attr,
+	//&dev_attr_touchkey_idac_back.attr,
+	//&dev_attr_touchkey_idac_menu.attr,
+	NULL,
+};
+static struct attribute_group touchkey_attr_group = {
+	.attrs = touchkey_attributes,
+};
+#endif
+
+static int init_sec_factory(struct bt532_ts_info *info)
+{
+	struct device *factory_ts_dev;
+#ifdef SUPPORTED_TOUCH_KEY
+	struct device *factory_tk_dev;
+#endif
+	struct tsp_factory_info *factory_info;
+	struct tsp_raw_data *raw_data;
+	int ret;
+	int i;
+
+	factory_info = kzalloc(sizeof(struct tsp_factory_info), GFP_KERNEL);
+	if (unlikely(!factory_info)) {
+		dev_err(&info->client->dev, "%s: Failed to allocate memory\n",
+				__func__);
+		ret = -ENOMEM;
+
+		goto err_alloc1;
+	}
+	raw_data = kzalloc(sizeof(struct tsp_raw_data), GFP_KERNEL);
+	if (unlikely(!raw_data)) {
+		dev_err(&info->client->dev, "%s: Failed to allocate memory\n",
+				__func__);
+		ret = -ENOMEM;
+
+		goto err_alloc2;
+	}
+
+	INIT_LIST_HEAD(&factory_info->cmd_list_head);
+	for(i = 0; i < ARRAY_SIZE(tsp_cmds); i++)
+		list_add_tail(&tsp_cmds[i].list, &factory_info->cmd_list_head);
+
+	factory_ts_dev = device_create(sec_class, NULL, 0, info, "tsp");
+	if (unlikely(!factory_ts_dev)) {
+		dev_err(&info->client->dev, "Failed to create factory dev\n");
+		ret = -ENODEV;
+		goto err_create_device;
+	}
+
+#ifdef SUPPORTED_TOUCH_KEY
+	factory_tk_dev = device_create(sec_class, NULL, 0, info, "sec_touchkey");
+	if (IS_ERR(factory_tk_dev)) {
+		dev_err(&info->client->dev, "Failed to create factory dev\n");
+		ret = -ENODEV;
+		goto err_create_device;
+	}
+#endif
+
+	ret = sysfs_create_group(&factory_ts_dev->kobj, &touchscreen_attr_group);
+	if (unlikely(ret)) {
+		dev_err(&info->client->dev, "Failed to create touchscreen sysfs group\n");
+		goto err_create_sysfs;
+	}
+
+#ifdef SUPPORTED_TOUCH_KEY
+	ret = sysfs_create_group(&factory_tk_dev->kobj, &touchkey_attr_group);
+	if (unlikely(ret)) {
+		dev_err(&info->client->dev, "Failed to create touchkey sysfs group\n");
+		goto err_create_sysfs;
+	}
+#endif
+
+	mutex_init(&factory_info->cmd_lock);
+	factory_info->cmd_is_running = false;
+
+	info->factory_info = factory_info;
+	info->raw_data = raw_data;
+
+	return ret;
+
+err_create_sysfs:
+err_create_device:
+	kfree(raw_data);
+err_alloc2:
+	kfree(factory_info);
+err_alloc1:
+
+	return ret;
+}
+#endif
+
+static int ts_misc_fops_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int ts_misc_fops_close(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static long ts_misc_fops_ioctl(struct file *filp,
+	unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct raw_ioctl raw_ioctl;
+	u8 *u8Data;
+	int ret = 0;
+	size_t sz = 0;
+	u16 version;
+	u16 mode;
+
+	struct reg_ioctl reg_ioctl;
+	u16 val;
+	int nval = 0;
+
+	if (misc_info == NULL)
+	{
+		zinitix_debug_msg("misc device NULL?\n");
+		return -1;
+	}
+
+	switch (cmd) {
+
+	case TOUCH_IOCTL_GET_DEBUGMSG_STATE:
+		ret = m_ts_debug_mode;
+		if (copy_to_user(argp, &ret, sizeof(ret)))
+			return -1;
+		break;
+
+	case TOUCH_IOCTL_SET_DEBUGMSG_STATE:
+		if (copy_from_user(&nval, argp, 4)) {
+			pr_info("[zinitix_touch] error : copy_from_user\n");
+			return -1;
+		}
+		if (nval)
+			pr_info("[zinitix_touch] on debug mode (%d)\n",
+				nval);
+		else
+			pr_info("[zinitix_touch] off debug mode (%d)\n",
+				nval);
+		m_ts_debug_mode = nval;
+		break;
+
+	case TOUCH_IOCTL_GET_CHIP_REVISION:
+		ret = misc_info->cap_info.ic_revision;
+		if (copy_to_user(argp, &ret, sizeof(ret)))
+			return -1;
+		break;
+
+	case TOUCH_IOCTL_GET_FW_VERSION:
+		ret = misc_info->cap_info.fw_version;
+		if (copy_to_user(argp, &ret, sizeof(ret)))
+			return -1;
+		break;
+
+	case TOUCH_IOCTL_GET_REG_DATA_VERSION:
+		ret = misc_info->cap_info.reg_data_version;
+		if (copy_to_user(argp, &ret, sizeof(ret)))
+			return -1;
+		break;
+
+	case TOUCH_IOCTL_VARIFY_UPGRADE_SIZE:
+		if (copy_from_user(&sz, argp, sizeof(size_t)))
+			return -1;
+
+		printk(KERN_INFO "[zinitix_touch]: firmware size = %d\r\n", sz);
+		if (misc_info->cap_info.ic_fw_size != sz) {
+			pr_info("[zinitix_touch]: firmware size error\r\n");
+			return -1;
+		}
+		break;
+
+	case TOUCH_IOCTL_VARIFY_UPGRADE_DATA:
+		if (copy_from_user(m_firmware_data,
+			argp, misc_info->cap_info.ic_fw_size))
+			return -1;
+
+		version = (u16) (m_firmware_data[52] | (m_firmware_data[53]<<8));
+
+		pr_info("[zinitix_touch]: firmware version = %x\r\n", version);
+
+		if (copy_to_user(argp, &version, sizeof(version)))
+			return -1;
+		break;
+
+	case TOUCH_IOCTL_START_UPGRADE:
+		return ts_upgrade_sequence((u8*)m_firmware_data);
+
+	case TOUCH_IOCTL_GET_X_RESOLUTION:
+		ret = misc_info->pdata->x_resolution;
+		if (copy_to_user(argp, &ret, sizeof(ret)))
+			return -1;
+		break;
+
+	case TOUCH_IOCTL_GET_Y_RESOLUTION:
+		ret = misc_info->pdata->y_resolution;
+		if (copy_to_user(argp, &ret, sizeof(ret)))
+			return -1;
+		break;
+
+	case TOUCH_IOCTL_GET_X_NODE_NUM:
+		ret = misc_info->cap_info.x_node_num;
+		if (copy_to_user(argp, &ret, sizeof(ret)))
+			return -1;
+		break;
+
+	case TOUCH_IOCTL_GET_Y_NODE_NUM:
+		ret = misc_info->cap_info.y_node_num;
+		if (copy_to_user(argp, &ret, sizeof(ret)))
+			return -1;
+		break;
+
+	case TOUCH_IOCTL_GET_TOTAL_NODE_NUM:
+		ret = misc_info->cap_info.total_node_num;
+		if (copy_to_user(argp, &ret, sizeof(ret)))
+			return -1;
+		break;
+
+	case TOUCH_IOCTL_HW_CALIBRAION:
+		ret = -1;
+		disable_irq(misc_info->irq);
+		down(&misc_info->work_lock);
+		if (misc_info->work_state != NOTHING) {
+			pr_info("[zinitix_touch]: other process occupied.. (%d)\r\n",
+				misc_info->work_state);
+			up(&misc_info->work_lock);
+			return -1;
+		}
+		misc_info->work_state = HW_CALIBRAION;
+		mdelay(100);
+
+		/* h/w calibration */
+		if(ts_hw_calibration(misc_info) == true)
+			ret = 0;
+
+		mode = misc_info->touch_mode;
+		if (write_reg(misc_info->client,
+			BT532_TOUCH_MODE, mode) != I2C_SUCCESS) {
+			pr_err("[zinitix_touch]: failed to set touch mode %d.\n",
+				mode);
+			goto fail_hw_cal;
+		}
+
+		if (write_cmd(misc_info->client,
+			BT532_SWRESET_CMD) != I2C_SUCCESS)
+			goto fail_hw_cal;
+
+		enable_irq(misc_info->irq);
+		misc_info->work_state = NOTHING;
+		up(&misc_info->work_lock);
+		return ret;
+fail_hw_cal:
+		enable_irq(misc_info->irq);
+		misc_info->work_state = NOTHING;
+		up(&misc_info->work_lock);
+		return -1;
+
+	case TOUCH_IOCTL_SET_RAW_DATA_MODE:
+		if (misc_info == NULL) {
+			zinitix_debug_msg("misc device NULL?\n");
+			return -1;
+		}
+		if (copy_from_user(&nval, argp, 4)) {
+			pr_info("[zinitix_touch] error : copy_from_user\r\n");
+			misc_info->work_state = NOTHING;
+			return -1;
+		}
+		ts_set_touchmode((u16)nval);
+
+		return 0;
+
+	case TOUCH_IOCTL_GET_REG:
+		if (misc_info == NULL) {
+			zinitix_debug_msg("misc device NULL?\n");
+			return -1;
+		}
+		down(&misc_info->work_lock);
+		if (misc_info->work_state != NOTHING) {
+			pr_info("[zinitix_touch]:other process occupied.. (%d)\n",
+				misc_info->work_state);
+			up(&misc_info->work_lock);
+			return -1;
+		}
+
+		misc_info->work_state = SET_MODE;
+
+		if (copy_from_user(&reg_ioctl,
+			argp, sizeof(struct reg_ioctl))) {
+			misc_info->work_state = NOTHING;
+			up(&misc_info->work_lock);
+			pr_info("[zinitix_touch] error : copy_from_user\n");
+			return -1;
+		}
+
+		if (read_data(misc_info->client,
+			reg_ioctl.addr, (u8 *)&val, 2) < 0)
+			ret = -1;
+
+		nval = (int)val;
+
+		if (copy_to_user(reg_ioctl.val, (u8 *)&nval, 4)) {
+			misc_info->work_state = NOTHING;
+			up(&misc_info->work_lock);
+			pr_info("[zinitix_touch] error : copy_to_user\n");
+			return -1;
+		}
+
+		zinitix_debug_msg("read : reg addr = 0x%x, val = 0x%x\n",
+			reg_ioctl.addr, nval);
+
+		misc_info->work_state = NOTHING;
+		up(&misc_info->work_lock);
+		return ret;
+
+	case TOUCH_IOCTL_SET_REG:
+
+		down(&misc_info->work_lock);
+		if (misc_info->work_state != NOTHING) {
+			pr_info("[zinitix_touch]: other process occupied.. (%d)\n",
+				misc_info->work_state);
+			up(&misc_info->work_lock);
+			return -1;
+		}
+
+		misc_info->work_state = SET_MODE;
+		if (copy_from_user(&reg_ioctl,
+				argp, sizeof(struct reg_ioctl))) {
+			misc_info->work_state = NOTHING;
+			up(&misc_info->work_lock);
+			pr_info("[zinitix_touch] error : copy_from_user\n");
+			return -1;
+		}
+
+		if (copy_from_user(&val, reg_ioctl.val, 4)) {
+			misc_info->work_state = NOTHING;
+			up(&misc_info->work_lock);
+			pr_info("[zinitix_touch] error : copy_from_user\n");
+			return -1;
+		}
+
+		if (write_reg(misc_info->client,
+			reg_ioctl.addr, val) != I2C_SUCCESS)
+			ret = -1;
+
+		zinitix_debug_msg("write : reg addr = 0x%x, val = 0x%x\r\n",
+			reg_ioctl.addr, val);
+		misc_info->work_state = NOTHING;
+		up(&misc_info->work_lock);
+		return ret;
+
+	case TOUCH_IOCTL_DONOT_TOUCH_EVENT:
+
+		if (misc_info == NULL) {
+			zinitix_debug_msg("misc device NULL?\n");
+			return -1;
+		}
+		down(&misc_info->work_lock);
+		if (misc_info->work_state != NOTHING) {
+			pr_info("[zinitix_touch]: other process occupied.. (%d)\r\n",
+				misc_info->work_state);
+			up(&misc_info->work_lock);
+			return -1;
+		}
+
+		misc_info->work_state = SET_MODE;
+		if (write_reg(misc_info->client,
+			BT532_INT_ENABLE_FLAG, 0) != I2C_SUCCESS)
+			ret = -1;
+		zinitix_debug_msg("write : reg addr = 0x%x, val = 0x0\r\n",
+			BT532_INT_ENABLE_FLAG);
+
+		misc_info->work_state = NOTHING;
+		up(&misc_info->work_lock);
+		return ret;
+
+	case TOUCH_IOCTL_SEND_SAVE_STATUS:
+		if (misc_info == NULL) {
+			zinitix_debug_msg("misc device NULL?\n");
+			return -1;
+		}
+		down(&misc_info->work_lock);
+		if (misc_info->work_state != NOTHING) {
+			pr_info("[zinitix_touch]: other process occupied.." \
+				"(%d)\r\n", misc_info->work_state);
+			up(&misc_info->work_lock);
+			return -1;
+		}
+		misc_info->work_state = SET_MODE;
+		ret = 0;
+		write_reg(misc_info->client, 0xc003, 0x0001);
+		write_reg(misc_info->client, 0xc104, 0x0001);
+		if (write_cmd(misc_info->client,
+			BT532_SAVE_STATUS_CMD) != I2C_SUCCESS)
+			ret =  -1;
+
+		mdelay(1000);	/* for fusing eeprom */
+		write_reg(misc_info->client, 0xc003, 0x0000);
+		write_reg(misc_info->client, 0xc104, 0x0000);
+
+		misc_info->work_state = NOTHING;
+		up(&misc_info->work_lock);
+		return ret;
+
+	case TOUCH_IOCTL_GET_RAW_DATA:
+		if (misc_info == NULL) {
+			zinitix_debug_msg("misc device NULL?\n");
+			return -1;
+		}
+
+		if (misc_info->touch_mode == TOUCH_POINT_MODE)
+			return -1;
+
+		down(&misc_info->raw_data_lock);
+		if (misc_info->update == 0) {
+			up(&misc_info->raw_data_lock);
+			return -2;
+		}
+
+		if (copy_from_user(&raw_ioctl,
+			argp, sizeof(struct raw_ioctl))) {
+			up(&misc_info->raw_data_lock);
+			pr_info("[zinitix_touch] error : copy_from_user\r\n");
+			return -1;
+		}
+
+		misc_info->update = 0;
+
+		u8Data = (u8 *)&misc_info->cur_data[0];
+		if(raw_ioctl.sz > MAX_TRAW_DATA_SZ*2)
+			raw_ioctl.sz = MAX_TRAW_DATA_SZ*2;
+		if (copy_to_user(raw_ioctl.buf, (u8 *)u8Data,
+			raw_ioctl.sz)) {
+			up(&misc_info->raw_data_lock);
+			return -1;
+		}
+
+		up(&misc_info->raw_data_lock);
+		return 0;
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int bt532_ts_probe(struct i2c_client *client,
+		const struct i2c_device_id *i2c_id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct bt532_ts_platform_data *pdata = client->dev.platform_data;
+	struct bt532_ts_info *info;
+	struct input_dev *input_dev;
+	int ret = 0;
+	int i;
+
+	if (!pdata) {
+		dev_err(&client->dev, "Not exist platform data\n");
+		return -EINVAL;
+	}
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "Not compatible i2c function\n");
+		return -EIO;
+	}
+
+	info = kzalloc(sizeof(struct bt532_ts_info), GFP_KERNEL);
+	if (!info) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	i2c_set_clientdata(client, info);
+	info->client = client;
+	info->pdata = pdata;
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		dev_err(&client->dev, "Failed to allocate input device\n");
+		goto err_alloc;
+	}
+
+	info->input_dev = input_dev;
+
+	// power on
+	if (bt532_power_control(info, POWER_ON_SEQUENCE) == false) {
+		goto err_power_sequence;
+	}
+
+/* To Do */
+/* FW version read from tsp */
+
+	memset(&info->reported_touch_info,
+		0x0, sizeof(struct point_info));
+
+	/* init touch mode */
+	info->touch_mode = TOUCH_POINT_MODE;
+	misc_info = info;
+
+	if(init_touch(info) == false) {
+		goto err_input_unregister_device;
+	}
+
+	for (i = 0; i < MAX_SUPPORTED_BUTTON_NUM; i++)
+		info->button[i] = ICON_BUTTON_UNCHANGE;
+
+	snprintf(info->phys, sizeof(info->phys),
+		"%s/input0", dev_name(&client->dev));
+	input_dev->name = "sec_touchscreen";
+	input_dev->id.bustype = BUS_I2C;
+/*	input_dev->id.vendor = 0x0001; */
+	input_dev->phys = info->phys;
+/*	input_dev->id.product = 0x0002; */
+/*	input_dev->id.version = 0x0100; */
+	input_dev->dev.parent = &client->dev;
+
+	set_bit(EV_SYN, info->input_dev->evbit);
+	set_bit(EV_KEY, info->input_dev->evbit);
+	set_bit(EV_ABS, info->input_dev->evbit);
+	set_bit(INPUT_PROP_DIRECT, info->input_dev->propbit);
+
+	for (i = 0; i < MAX_SUPPORTED_BUTTON_NUM; i++)
+		set_bit(BUTTON_MAPPING_KEY[i], info->input_dev->keybit);
+
+	if (pdata->orientation & TOUCH_XY_SWAP) {
+		input_set_abs_params(info->input_dev, ABS_MT_POSITION_Y,
+			info->cap_info.MinX,
+			info->cap_info.MaxX + ABS_PT_OFFSET,
+			0, 0);
+		input_set_abs_params(info->input_dev, ABS_MT_POSITION_X,
+			info->cap_info.MinY,
+			info->cap_info.MaxY + ABS_PT_OFFSET,
+			0, 0);
+	} else {
+		input_set_abs_params(info->input_dev, ABS_MT_POSITION_X,
+			info->cap_info.MinX,
+			info->cap_info.MaxX + ABS_PT_OFFSET,
+			0, 0);
+		input_set_abs_params(info->input_dev, ABS_MT_POSITION_Y,
+			info->cap_info.MinY,
+			info->cap_info.MaxY + ABS_PT_OFFSET,
+			0, 0);
+	}
+
+	input_set_abs_params(info->input_dev, ABS_MT_TOUCH_MAJOR,
+		0, 255, 0, 0);
+	input_set_abs_params(info->input_dev, ABS_MT_WIDTH_MAJOR,
+		0, 255, 0, 0);
+
+#if (TOUCH_POINT_MODE == 2)
+	input_set_abs_params(info->input_dev, ABS_MT_TOUCH_MINOR,
+		0, 255, 0, 0);
+/*	input_set_abs_params(info->input_dev, ABS_MT_WIDTH_MINOR,
+		0, 255, 0, 0); */
+	input_set_abs_params(info->input_dev, ABS_MT_ORIENTATION,
+		-128, 127, 0, 0);
+	input_set_abs_params(info->input_dev, ABS_MT_ANGLE,
+		-90, 90, 0, 0);
+	input_set_abs_params(info->input_dev, ABS_MT_PALM,
+		0, 1, 0, 0);
+#endif
+
+	set_bit(MT_TOOL_FINGER, info->input_dev->keybit);
+	input_mt_init_slots(info->input_dev, info->cap_info.multi_fingers);
+
+	zinitix_debug_msg("register %s input device \r\n",
+		info->input_dev->name);
+	input_set_drvdata(info->input_dev, info);
+	ret = input_register_device(info->input_dev);
+	if (ret) {
+		printk(KERN_ERR "unable to register %s input device\r\n",
+			info->input_dev->name);
+		goto err_input_register_device;
+	}
+
+	/* configure irq */
+	info->irq = gpio_to_irq(pdata->gpio_int);
+	if (info->irq < 0)
+		printk(KERN_INFO "error. gpio_to_irq(..) function is not \
+			supported? you should define GPIO_TOUCH_IRQ.\r\n");
+
+	zinitix_debug_msg("request irq (irq = %d, pin = %d) \r\n",
+		info->irq, pdata->gpio_int);
+
+	info->work_state = NOTHING;
+	sema_init(&info->work_lock, 1);
+
+#if ESD_TIMER_INTERVAL
+	spin_lock_init(&info->lock);
+	INIT_WORK(&info->tmr_work, ts_tmr_work);
+	esd_tmr_workqueue =
+		create_singlethread_workqueue("esd_tmr_workqueue");
+
+	if (!esd_tmr_workqueue) {
+		dev_err(&client->dev, "Failed to create esd tmr work queue\n");
+		ret = -EPERM;
+
+		goto err_esd_input_unregister_device;
+	}
+
+	esd_timer_init(info);
+	esd_timer_start(CHECK_ESD_TIMER, info);
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&client->dev, "Started esd timer\n");
+#endif
+#endif
+	/* ret = request_threaded_irq(info->irq, ts_int_handler, bt532_touch_work,*/
+	ret = request_threaded_irq(info->irq, NULL, bt532_touch_work,
+		IRQF_TRIGGER_FALLING | IRQF_ONESHOT , BT532_TS_DEVICE, info);
+
+	if (ret) {
+		printk(KERN_ERR "unable to register irq.(%s)\r\n",
+			info->input_dev->name);
+		goto err_request_irq;
+	}
+	dev_info(&client->dev, "zinitix touch probe.\r\n");
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	info->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	info->early_suspend.suspend = bt532_ts_early_suspend;
+	info->early_suspend.resume = bt532_ts_late_resume;
+	register_early_suspend(&info->early_suspend);
+#endif
+
+#if defined(CONFIG_PM_RUNTIME)
+	pm_runtime_enable(&client->dev);
+#endif
+
+	sema_init(&info->raw_data_lock, 1);
+
+	ret = misc_register(&touch_misc_device);
+	if (ret) {
+		dev_err(&client->dev, "Failed to register touch misc device\n");
+		goto err_misc_register;
+	}
+
+#ifdef SEC_FACTORY_TEST
+	ret = init_sec_factory(info);
+	if (ret) {
+		dev_err(&client->dev, "Failed to init sec factory device\n");
+
+		goto err_kthread_create_failed;
+	}
+#endif
+
+	return 0;
+
+#ifdef SEC_FACTORY_TEST
+err_kthread_create_failed:
+	kfree(info->factory_info);
+	kfree(info->raw_data);
+#endif
+err_misc_register:
+	free_irq(info->irq, info);
+err_request_irq:
+#if ESD_TIMER_INTERVAL
+err_esd_input_unregister_device:
+#endif
+err_input_unregister_device:
+	input_unregister_device(info->input_dev);
+err_input_register_device:
+err_power_sequence:
+	input_free_device(info->input_dev);
+err_alloc:
+	kfree(info);
+	return ret;
+}
+
+static int bt532_ts_remove(struct i2c_client *client)
+{
+	struct bt532_ts_info *info = i2c_get_clientdata(client);
+	struct bt532_ts_platform_data *pdata = info->pdata;
+
+	disable_irq(info->irq);
+	down(&info->work_lock);
+
+	info->work_state = REMOVE;
+
+	kfree(info->factory_info);
+	kfree(info->raw_data);
+#if ESD_TIMER_INTERVAL
+	flush_work(&info->tmr_work);
+	write_reg(info->client, BT532_PERIODICAL_INTERRUPT_INTERVAL, 0);
+	esd_timer_stop(info);
+#if defined(TSP_VERBOSE_DEBUG)
+	dev_info(&client->dev, "Stopped esd timer\n");
+#endif
+	destroy_workqueue(esd_tmr_workqueue);
+#endif
+
+	if (info->irq)
+		free_irq(info->irq, info);
+
+	misc_deregister(&touch_misc_device);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&info->early_suspend);
+#endif
+
+	if (gpio_is_valid(pdata->gpio_int) != 0)
+		gpio_free(pdata->gpio_int);
+
+	input_unregister_device(info->input_dev);
+	input_free_device(info->input_dev);
+	up(&info->work_lock);
+	kfree(info);
+
+	return 0;
+}
+
+void bt532_ts_shutdown(struct i2c_client *client)
+{
+	struct bt532_ts_info *info = i2c_get_clientdata(client);
+
+	dev_info(&client->dev, "%s++\n",__func__);
+	disable_irq(info->irq);
+	down(&info->work_lock);
+#if ESD_TIMER_INTERVAL
+	flush_work(&info->tmr_work);
+	esd_timer_stop(info);
+#endif
+	up(&info->work_lock);
+	bt532_power_control(info, PM_POWER_OFF);
+	dev_info(&client->dev, "%s--\n",__func__);
+}
+
+static struct i2c_device_id bt532_idtable[] = {
+	{BT532_TS_DEVICE, 0},
+	{ }
+};
+
+#if defined(CONFIG_PM) && !defined(CONFIG_HAS_EARLYSUSPEND)
+static const struct dev_pm_ops bt532_ts_pm_ops = {
+#if defined(CONFIG_PM_RUNTIME)
+	SET_RUNTIME_PM_OPS(bt532_ts_suspend, bt532_ts_resume, NULL)
+#else
+	SET_SYSTEM_SLEEP_PM_OPS(bt532_ts_suspend, bt532_ts_resume)
+#endif
+};
+#endif
+
+static struct i2c_driver bt532_ts_driver = {
+	.probe	= bt532_ts_probe,
+	.remove	= bt532_ts_remove,
+	.shutdown = bt532_ts_shutdown,
+	.id_table	= bt532_idtable,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= BT532_TS_DEVICE,
+#if defined(CONFIG_PM) && !defined(CONFIG_HAS_EARLYSUSPEND)
+		.pm		= &bt532_ts_pm_ops,
+#endif
+	},
+};
+
+#if defined(CONFIG_SPA) || defined(CONFIG_SPA_LPM_MODE)
+extern int spa_lpm_charging_mode_get();
+#else
+extern unsigned int lpcharge;
+#endif
+
+static int __devinit bt532_ts_init(void)
+{
+	pr_info("[TSP]: %s\n", __func__);
+#if defined(CONFIG_SPA) || defined(CONFIG_SPA_LPM_MODE)
+	if (!spa_lpm_charging_mode_get())
+#else
+	if (!lpcharge)
+#endif
+		return i2c_add_driver(&bt532_ts_driver);
+	else
+		return 0;
+}
+
+static void __exit bt532_ts_exit(void)
+{
+	i2c_del_driver(&bt532_ts_driver);
+}
+
+module_init(bt532_ts_init);
+module_exit(bt532_ts_exit);
+
+MODULE_DESCRIPTION("touch-screen device driver using i2c interface");
+MODULE_AUTHOR("<mika.kim@samsung.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/zinitix_touch_bt532_firmware.h b/drivers/input/touchscreen/zinitix_touch_bt532_firmware.h
new file mode 100755
index 00000000..f8f3d625
--- /dev/null
+++ b/drivers/input/touchscreen/zinitix_touch_bt532_firmware.h
@@ -0,0 +1,4127 @@
+/*
+*
+* Zinitix touch driver
+*
+* Copyright (C) 2009 Zinitix, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+* GNU General Public License for more details.
+*
+*/
+/*
+Release Date : 13/12/22, 17:57
+
+Version Info :
+	Chip Code : 0xF400
+	Firmware Version : 0x0002
+	Firmware Minor Version : 0x0004
+	Register Version : 14
+*/
+#ifndef _ZINITIX_ZXT_CODE_H
+#define	_ZINITIX_ZXT_CODE_H
+
+u8 m_firmware_data[] = {
+0x0F, 0x88, 0xF0, 0x07, 0x3F, 0x83, 0xFF, 0xFF,
+0xEF, 0x82, 0xFF, 0xFF, 0xCF, 0x82, 0xFF, 0xFF,
+0xAF, 0x82, 0xFF, 0xFF, 0x0F, 0x98, 0x16, 0x42,
+0x00, 0x1A, 0x00, 0xF4, 0x00, 0x0D, 0x95, 0x01,
+0x0F, 0x88, 0xC7, 0x43, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0x00, 0x00, 0x0F, 0x88, 0x02, 0x00, 0x0F, 0x88,
+0x04, 0x00, 0x0F, 0x88, 0x0E, 0x00, 0x0F, 0x88,
+0x00, 0xF4, 0x0F, 0x88, 0x02, 0x00, 0x00, 0x00,
+0x02, 0x00, 0x0F, 0x88, 0x02, 0x00, 0x0F, 0x88,
+0x02, 0x00, 0x0F, 0x88, 0x02, 0x00, 0x0F, 0x88,
+0x02, 0x00, 0x0F, 0x88, 0x02, 0x00, 0x0F, 0x88,
+0x02, 0x00, 0x0F, 0x88, 0x02, 0x00, 0xFF, 0xFF,
+0xFF, 0xFF, 0xDF, 0x87, 0x0F, 0x88, 0x72, 0x42,
+0x00, 0x03, 0x00, 0xF5, 0x00, 0x51, 0xC1, 0x87,
+0xFF, 0xA0, 0x10, 0x19, 0x00, 0x03, 0x09, 0xF5,
+0x00, 0x51, 0xF0, 0xA0, 0x11, 0x19, 0xFF, 0xA0,
+0x00, 0x03, 0x09, 0xF5, 0x00, 0x51, 0xC1, 0x87,
+0xFF, 0xA0, 0x20, 0x1A, 0x78, 0x00, 0xFF, 0xFF,
+0xFF, 0xFF, 0x21, 0x39, 0xC1, 0x87, 0xFF, 0xA0,
+0x10, 0x03, 0x74, 0x01, 0x10, 0x49, 0x00, 0x87,
+0x00, 0x03, 0x09, 0xF5, 0x00, 0x51, 0xF0, 0xA0,
+0x0F, 0x98, 0x49, 0x40, 0x11, 0x39, 0x81, 0x87,
+0x8F, 0x80, 0x00, 0x0E, 0x75, 0x02, 0x00, 0x03,
+0x09, 0xF5, 0x00, 0xC1, 0x00, 0x0D, 0x09, 0xF5,
+0xFF, 0xA0, 0x00, 0x03, 0x09, 0xF5, 0x00, 0xC9,
+0x00, 0x0D, 0x09, 0xF5, 0xFF, 0xA0, 0x00, 0x03,
+0x93, 0x01, 0x0F, 0x51, 0x30, 0x81, 0x00, 0x03,
+0x07, 0x18, 0x00, 0x49, 0xF0, 0x80, 0x00, 0x03,
+0xDF, 0x01, 0x00, 0x49, 0xB0, 0x80, 0x00, 0x0E,
+0x08, 0xF3, 0xA0, 0x1A, 0x00, 0x40, 0xB0, 0x19,
+0x1A, 0x01, 0xB1, 0x20, 0x01, 0x39, 0xC1, 0x87,
+0x0B, 0x0D, 0xE1, 0x01, 0x01, 0x0E, 0x08, 0xF3,
+0x00, 0x1A, 0x21, 0x00, 0x00, 0x0D, 0x00, 0xF5,
+0xFF, 0xA0, 0x0F, 0x98, 0x38, 0x40, 0x00, 0x0E,
+0x08, 0xF3, 0xA0, 0x1A, 0x00, 0x40, 0x0B, 0x01,
+0xA0, 0x09, 0x91, 0x39, 0xC1, 0x87, 0x01, 0x0E,
+0x08, 0xF3, 0xFF, 0xA0, 0x0F, 0x98, 0x38, 0x40,
+0x00, 0x0E, 0x08, 0xF3, 0xC0, 0x03, 0x55, 0x17,
+0xD0, 0x1A, 0x57, 0x17, 0x80, 0x03, 0xD6, 0x00,
+0xA0, 0x1A, 0x00, 0x40, 0x0B, 0x01, 0xC0, 0x49,
+0x20, 0x80, 0x1D, 0x01, 0x01, 0x38, 0xA0, 0x09,
+0x81, 0x39, 0x41, 0x80, 0xD0, 0x1A, 0x57, 0x17,
+0x80, 0x03, 0xD6, 0x00, 0x91, 0x39, 0x21, 0x87,
+0x90, 0x03, 0x8A, 0x00, 0x00, 0x03, 0xAD, 0x13,
+0x10, 0x03, 0x65, 0x01, 0x01, 0x60, 0x41, 0x80,
+0xA0, 0x0B, 0x01, 0x0E, 0x08, 0xF3, 0xFF, 0xA0,
+0xB0, 0x1A, 0xF5, 0x00, 0x0B, 0x01, 0xA0, 0x09,
+0x0B, 0x01, 0xA0, 0x09, 0x33, 0x19, 0x00, 0x03,
+0x8E, 0x00, 0x02, 0x49, 0x01, 0xB0, 0x34, 0x19,
+0x0B, 0x01, 0xA0, 0x09, 0x31, 0x39, 0xC1, 0x87,
+0x00, 0x03, 0x8E, 0x00, 0x02, 0x49, 0x00, 0xB0,
+0xB1, 0x21, 0x91, 0x39, 0xF1, 0x86, 0x01, 0x0E,
+0x08, 0xF3, 0xFF, 0xA0, 0x00, 0x0E, 0x76, 0x02,
+0x00, 0x03, 0xF0, 0x00, 0x00, 0x0D, 0x77, 0x02,
+0x0F, 0x88, 0x65, 0x40, 0x10, 0x20, 0x30, 0x03,
+0x01, 0x00, 0x31, 0x49, 0x61, 0x82, 0x30, 0x1A,
+0x10, 0xF5, 0x28, 0x19, 0x01, 0x00, 0xFF, 0xFF,
+0x00, 0x62, 0xFF, 0x00, 0x30, 0x09, 0x01, 0x01,
+0x08, 0x79, 0x30, 0x09, 0x21, 0x39, 0x61, 0x87,
+0x00, 0x03, 0x93, 0x01, 0x0F, 0x51, 0xF0, 0xA0,
+0x00, 0x03, 0x07, 0x18, 0x00, 0x49, 0xF0, 0xA0,
+0x00, 0x03, 0xDF, 0x01, 0x00, 0x49, 0xF0, 0xA0,
+0x08, 0x49, 0x0D, 0xB0, 0x08, 0x19, 0xA0, 0x1A,
+0x10, 0xF5, 0x30, 0x19, 0x1A, 0x01, 0x31, 0x20,
+0x01, 0x39, 0xC1, 0x87, 0x03, 0x0D, 0xE1, 0x01,
+0xFF, 0xA0, 0x32, 0x19, 0x31, 0x21, 0x03, 0x00,
+0x10, 0x08, 0xFF, 0xA0, 0x01, 0x0E, 0x09, 0x17,
+0x00, 0x0E, 0x8E, 0x00, 0x00, 0x03, 0xC5, 0x01,
+0x00, 0x0D, 0x75, 0x01, 0x00, 0x03, 0xC6, 0x01,
+0x00, 0x0D, 0x8C, 0x00, 0x00, 0x03, 0xCC, 0x01,
+0x00, 0x0D, 0x92, 0x01, 0x00, 0x03, 0x6F, 0x02,
+0x00, 0x0D, 0x93, 0x01, 0x00, 0x03, 0x70, 0x02,
+0x00, 0x0D, 0x94, 0x01, 0x00, 0x03, 0xC7, 0x01,
+0x00, 0x0D, 0x95, 0x00, 0x00, 0x0D, 0x96, 0x00,
+0x00, 0x0D, 0x97, 0x00, 0x00, 0x0D, 0x98, 0x00,
+0x00, 0x0D, 0x99, 0x00, 0x00, 0x03, 0xCB, 0x01,
+0x00, 0x0D, 0xF0, 0x00, 0x00, 0x0E, 0x72, 0x12,
+0x00, 0x03, 0xD6, 0x01, 0x00, 0x0D, 0x27, 0x01,
+0x00, 0x03, 0xD2, 0x01, 0x00, 0x0D, 0xA5, 0x00,
+0x00, 0x03, 0xD5, 0x01, 0x00, 0x0D, 0xAA, 0x00,
+0x00, 0x0D, 0x33, 0x01, 0x00, 0x03, 0xD7, 0x01,
+0x00, 0x0D, 0xB0, 0x00, 0x00, 0x03, 0xD8, 0x01,
+0x00, 0x0D, 0x26, 0x01, 0x00, 0x03, 0xD9, 0x01,
+0x00, 0x0D, 0x4A, 0x01, 0x00, 0x03, 0xDA, 0x01,
+0x00, 0x0D, 0x4B, 0x01, 0x00, 0x03, 0xDB, 0x01,
+0x00, 0x0D, 0x4C, 0x01, 0x00, 0x03, 0xCD, 0x01,
+0x00, 0x0D, 0x60, 0x01, 0x00, 0x03, 0xCE, 0x01,
+0x00, 0x0D, 0x61, 0x01, 0x00, 0x03, 0xCF, 0x01,
+0x00, 0x0D, 0x62, 0x01, 0x00, 0x03, 0xD0, 0x01,
+0x00, 0x0D, 0x63, 0x01, 0x00, 0x03, 0xD1, 0x01,
+0x00, 0x0D, 0x64, 0x01, 0x00, 0x03, 0x6B, 0x02,
+0x00, 0x0D, 0x3F, 0x01, 0x00, 0x03, 0x6C, 0x02,
+0x00, 0x0D, 0x40, 0x01, 0x00, 0x03, 0x6D, 0x02,
+0x00, 0x0D, 0x41, 0x01, 0x00, 0x03, 0x6E, 0x02,
+0x00, 0x0D, 0x42, 0x01, 0x00, 0x03, 0x65, 0x01,
+0x0B, 0xC1, 0x00, 0x0D, 0x65, 0x01, 0xFF, 0xA0,
+0x01, 0x0E, 0x12, 0x00, 0x02, 0x0E, 0x13, 0x00,
+0x00, 0x0E, 0x14, 0x00, 0xC0, 0x1A, 0x80, 0x00,
+0xB0, 0x1A, 0x75, 0x02, 0xBC, 0x38, 0xB1, 0x79,
+0x0B, 0x0D, 0x2B, 0x17, 0x00, 0x1A, 0x00, 0x75,
+0x00, 0x3A, 0x00, 0x40, 0x00, 0x22, 0x80, 0x00,
+0x01, 0x79, 0x00, 0x0D, 0x2C, 0x17, 0x00, 0x1A,
+0x80, 0x00, 0x00, 0x0D, 0x2D, 0x17, 0x00, 0x03,
+0x2C, 0x17, 0x00, 0x0D, 0x17, 0x00, 0x00, 0x03,
+0x2D, 0x17, 0x00, 0x0D, 0x1F, 0x00, 0x0F, 0x98,
+0x24, 0x07, 0x00, 0x03, 0x2C, 0x17, 0x00, 0x22,
+0x20, 0x00, 0x00, 0x0D, 0x2C, 0x17, 0x00, 0x03,
+0x2D, 0x17, 0x00, 0x22, 0x40, 0x00, 0x00, 0x0D,
+0x2D, 0x17, 0x00, 0x03, 0x2B, 0x17, 0x00, 0x3A,
+0x20, 0x00, 0x00, 0x0D, 0x2B, 0x17, 0x00, 0x49,
+0x2A, 0x86, 0x00, 0x0E, 0x12, 0x00, 0x00, 0x0E,
+0x13, 0x00, 0x00, 0x0E, 0x14, 0x00, 0xFF, 0xA0,
+0x01, 0x0E, 0x12, 0x00, 0x02, 0x0E, 0x13, 0x00,
+0x00, 0x0E, 0x14, 0x00, 0xB0, 0x1A, 0x40, 0x02,
+0xB1, 0x79, 0x0B, 0x0D, 0x2B, 0x17, 0x00, 0x1A,
+0xC0, 0x7D, 0x00, 0x3A, 0x00, 0x40, 0x01, 0x79,
+0x00, 0x0D, 0x2C, 0x17, 0x00, 0x1A, 0x20, 0x10,
+0x00, 0x0D, 0x2D, 0x17, 0x00, 0x03, 0x2C, 0x17,
+0x00, 0x0D, 0x17, 0x00, 0x00, 0x03, 0x2D, 0x17,
+0x00, 0x0D, 0x1F, 0x00, 0x0F, 0x98, 0x24, 0x07,
+0x00, 0x03, 0x2C, 0x17, 0x00, 0x22, 0x20, 0x00,
+0x00, 0x0D, 0x2C, 0x17, 0x00, 0x03, 0x2D, 0x17,
+0x00, 0x22, 0x40, 0x00, 0x00, 0x0D, 0x2D, 0x17,
+0x00, 0x03, 0x2B, 0x17, 0x00, 0x3A, 0x20, 0x00,
+0x00, 0x0D, 0x2B, 0x17, 0x00, 0x49, 0x2A, 0x86,
+0x00, 0x0E, 0x12, 0x00, 0x00, 0x0E, 0x13, 0x00,
+0x00, 0x0E, 0x14, 0x00, 0xFF, 0xA0, 0x00, 0x0E,
+0x13, 0x00, 0x00, 0x0E, 0x14, 0x00, 0xB0, 0x1A,
+0x40, 0x02, 0xB1, 0x79, 0x0B, 0x0D, 0x19, 0x00,
+0x00, 0x1A, 0xC0, 0x7D, 0x00, 0x3A, 0x00, 0x40,
+0x01, 0x79, 0x00, 0x0D, 0x17, 0x00, 0x00, 0x1A,
+0x20, 0x10, 0x00, 0x0D, 0x1F, 0x00, 0x0F, 0x98,
+0x26, 0x07, 0xFF, 0xA0, 0x00, 0x0E, 0x13, 0x00,
+0x00, 0x0E, 0x14, 0x00, 0xC0, 0x1A, 0x80, 0x00,
+0xB0, 0x1A, 0x75, 0x02, 0xBC, 0x38, 0xB1, 0x21,
+0xB1, 0x79, 0x0B, 0x0D, 0x19, 0x00, 0x00, 0x1A,
+0x00, 0x75, 0x00, 0x3A, 0x00, 0x40, 0x00, 0x22,
+0x80, 0x00, 0x01, 0x79, 0x00, 0x0D, 0x17, 0x00,
+0x00, 0x1A, 0x80, 0x00, 0x00, 0x0D, 0x1F, 0x00,
+0x0F, 0x88, 0x26, 0x07, 0x00, 0x0E, 0x13, 0x00,
+0x00, 0x0E, 0x14, 0x00, 0x00, 0x1A, 0x00, 0x20,
+0x00, 0x0D, 0x2E, 0x17, 0x00, 0x0E, 0x2F, 0x17,
+0x00, 0x0E, 0x3A, 0x17, 0x00, 0x1A, 0x40, 0x00,
+0x00, 0x0D, 0x19, 0x00, 0x00, 0x03, 0x2F, 0x17,
+0x00, 0x0D, 0x17, 0x00, 0x00, 0x1A, 0x60, 0x09,
+0x00, 0x0D, 0x1F, 0x00, 0x0F, 0x98, 0x26, 0x07,
+0xA0, 0x1A, 0x80, 0x00, 0xB0, 0x1A, 0x60, 0x09,
+0x20, 0x03, 0x3A, 0x17, 0x0B, 0x00, 0x20, 0x20,
+0xB1, 0x21, 0xA1, 0x39, 0xB1, 0x87, 0x02, 0x0D,
+0x3A, 0x17, 0x00, 0x03, 0x2F, 0x17, 0x00, 0x22,
+0x40, 0x00, 0x00, 0x0D, 0x2F, 0x17, 0x00, 0x03,
+0x2E, 0x17, 0x00, 0x3A, 0x40, 0x00, 0x00, 0x0D,
+0x2E, 0x17, 0x00, 0x49, 0x7A, 0x85, 0x00, 0x0E,
+0xA1, 0x01, 0x20, 0x03, 0x3A, 0x17, 0x20, 0x49,
+0xF1, 0xA0, 0x00, 0x1A, 0xAA, 0x55, 0x00, 0x0D,
+0xA1, 0x01, 0xFF, 0xA0, 0x00, 0x0E, 0x07, 0x18,
+0x32, 0x19, 0x03, 0x00, 0xFF, 0xFF, 0x00, 0x4A,
+0x80, 0x00, 0x5C, 0x81, 0x00, 0x4A, 0x9F, 0x00,
+0x2A, 0x81, 0x01, 0x0E, 0x07, 0x18, 0x00, 0x0E,
+0x05, 0xF5, 0xA0, 0x03, 0x8E, 0x00, 0xA0, 0x49,
+0x00, 0x88, 0x6B, 0x40, 0xA2, 0x49, 0x00, 0x88,
+0x6B, 0x40, 0x10, 0x1A, 0xF5, 0x00, 0x00, 0x3A,
+0x80, 0x00, 0x0F, 0x88, 0xDE, 0x40, 0x00, 0x49,
+0x00, 0x88, 0xD6, 0x40, 0x01, 0x49, 0x00, 0x88,
+0xD6, 0x40, 0x03, 0x49, 0x00, 0x88, 0x65, 0x40,
+0x01, 0x0E, 0xE8, 0x17, 0x00, 0x4A, 0x00, 0x02,
+0xDC, 0x80, 0xA0, 0x18, 0xA0, 0x62, 0xFF, 0x00,
+0xA0, 0x5A, 0x20, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xA0, 0x1E, 0x0A, 0x0D, 0x05, 0xF5,
+0x0F, 0x88, 0x6B, 0x40, 0x04, 0x49, 0x41, 0x80,
+0x01, 0x0E, 0x76, 0x02, 0x0F, 0x88, 0x65, 0x40,
+0x05, 0x49, 0xC1, 0x80, 0x00, 0x0E, 0x00, 0xF5,
+0x00, 0x1A, 0xFF, 0xFF, 0x00, 0x0D, 0x02, 0xF2,
+0x00, 0x0D, 0x0A, 0xF2, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xCF, 0x87, 0x06, 0x49, 0x01, 0x81,
+0x01, 0x0E, 0x7F, 0x02, 0x00, 0x0E, 0x78, 0x02,
+0xA0, 0x03, 0x85, 0x00, 0xA7, 0x49, 0x01, 0x88,
+0x65, 0x40, 0xA0, 0x03, 0x8D, 0x00, 0xA0, 0xC1,
+0x0A, 0x0D, 0x8D, 0x00, 0x0F, 0x88, 0x65, 0x40,
+0x08, 0x49, 0x31, 0x80, 0x0F, 0x98, 0xC4, 0x41,
+0x7F, 0x80, 0x07, 0x49, 0xC1, 0x81, 0xC0, 0x03,
+0x8D, 0x00, 0xC1, 0xC9, 0x0C, 0x0D, 0x8D, 0x00,
+0x00, 0x0E, 0xA3, 0x01, 0x00, 0x0E, 0xA1, 0x01,
+0x0F, 0x98, 0x84, 0x41, 0x0F, 0x98, 0x32, 0x42,
+0x00, 0x03, 0x3A, 0x17, 0x00, 0x31, 0x00, 0x0D,
+0xA3, 0x01, 0x00, 0x0E, 0xA1, 0x01, 0x0F, 0x98,
+0x84, 0x41, 0x0F, 0x98, 0x32, 0x42, 0x00, 0x0E,
+0x08, 0x17, 0x0F, 0x88, 0x65, 0x40, 0x09, 0x49,
+0x61, 0x80, 0x0F, 0x98, 0x0E, 0x41, 0x02, 0x0E,
+0x7F, 0x02, 0x0F, 0x88, 0xD6, 0x40, 0x0F, 0x49,
+0x00, 0x88, 0x65, 0x40, 0x00, 0x03, 0x02, 0x00,
+0x00, 0x4A, 0x00, 0x02, 0xFB, 0xA0, 0x20, 0x03,
+0x85, 0x00, 0x02, 0x0D, 0x0D, 0x16, 0x10, 0x1A,
+0x85, 0x00, 0x00, 0x3A, 0x10, 0x00, 0x0F, 0x98,
+0xDE, 0x40, 0x90, 0x03, 0x01, 0x00, 0x91, 0x49,
+0xFD, 0xA0, 0x00, 0x03, 0x02, 0x00, 0x00, 0x4A,
+0x10, 0x00, 0x41, 0x81, 0x0F, 0x98, 0x65, 0x40,
+0x00, 0x03, 0x85, 0x00, 0x05, 0x49, 0x5D, 0x80,
+0x0A, 0x49, 0x30, 0x80, 0x02, 0x0E, 0x7F, 0x02,
+0xFF, 0xA0, 0x00, 0x03, 0x0D, 0x16, 0x05, 0x49,
+0xFD, 0xA0, 0x0A, 0x49, 0xF0, 0xA0, 0x02, 0x0E,
+0x7F, 0x02, 0xFF, 0xA0, 0x00, 0x4A, 0x60, 0x00,
+0x7C, 0x80, 0x00, 0x4A, 0x7F, 0x00, 0x4A, 0x80,
+0x02, 0x0E, 0x7F, 0x02, 0x0F, 0x88, 0x65, 0x40,
+0x00, 0x4A, 0x00, 0x01, 0xFC, 0xA0, 0x00, 0x4A,
+0x4F, 0x01, 0xFA, 0xA0, 0x02, 0x0E, 0x7F, 0x02,
+0x0F, 0x88, 0x65, 0x40, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xA0, 0x00, 0x03,
+0x92, 0x01, 0x0E, 0x51, 0x00, 0x88, 0xBE, 0x43,
+0x01, 0x0E, 0xE4, 0x17, 0x01, 0x0E, 0xE3, 0x17,
+0x20, 0x03, 0xF3, 0x00, 0x20, 0x49, 0x00, 0x88,
+0xBE, 0x43, 0x00, 0x19, 0x20, 0x50, 0x31, 0x80,
+0x01, 0x21, 0x01, 0x49, 0xBD, 0x87, 0x00, 0x0D,
+0xE4, 0x17, 0x01, 0x19, 0x20, 0x03, 0xF3, 0x00,
+0x20, 0x50, 0x31, 0x80, 0x01, 0x39, 0x00, 0x49,
+0xBB, 0x87, 0x00, 0x0D, 0xE3, 0x17, 0x00, 0x0D,
+0xE2, 0x17, 0xCF, 0x83, 0x00, 0x03, 0x85, 0x00,
+0x03, 0x49, 0xAB, 0x82, 0x10, 0x03, 0xE8, 0x17,
+0x00, 0x0E, 0xE8, 0x17, 0x00, 0x03, 0x0E, 0x16,
+0x01, 0x68, 0x00, 0x49, 0x11, 0x82, 0x10, 0x03,
+0x76, 0x01, 0x10, 0x49, 0xD1, 0x81, 0x20, 0x03,
+0xE4, 0x17, 0x21, 0x49, 0x9B, 0x81, 0x50, 0x03,
+0xE2, 0x17, 0x52, 0x48, 0x60, 0x83, 0x30, 0x03,
+0xE6, 0x17, 0x31, 0x39, 0x30, 0x80, 0x03, 0x0D,
+0xE6, 0x17, 0xFF, 0xA0, 0x00, 0x03, 0xF3, 0x00,
+0x51, 0x39, 0x05, 0x50, 0x31, 0x80, 0x50, 0x49,
+0x00, 0xB0, 0xAF, 0x87, 0x52, 0x48, 0x0B, 0xB0,
+0x52, 0x18, 0x05, 0x0D, 0xE2, 0x17, 0xEF, 0x80,
+0x00, 0x03, 0x49, 0x01, 0x00, 0x0D, 0xE6, 0x17,
+0x50, 0x03, 0xE3, 0x17, 0x10, 0x03, 0xE2, 0x17,
+0x51, 0x48, 0xC0, 0x80, 0x50, 0x03, 0xE3, 0x17,
+0x05, 0x0D, 0xE2, 0x17, 0x00, 0x03, 0x49, 0x01,
+0x00, 0x0D, 0xE6, 0x17, 0x0F, 0x98, 0x44, 0x40,
+0x0F, 0x98, 0x83, 0x48, 0x50, 0x03, 0xE2, 0x17,
+0x50, 0x49, 0x70, 0x80, 0x00, 0x03, 0x66, 0x01,
+0x00, 0x0D, 0xE7, 0x17, 0x00, 0x0E, 0xE5, 0x17,
+0xFF, 0xA0, 0x00, 0x03, 0xB7, 0x01, 0x00, 0x0D,
+0xE7, 0x17, 0x00, 0x03, 0x57, 0x01, 0x00, 0x0D,
+0xE5, 0x17, 0xFF, 0xA0, 0x0F, 0x98, 0x30, 0x46,
+0x0F, 0x98, 0xDB, 0x46, 0x00, 0x03, 0x66, 0x01,
+0x00, 0x0D, 0xE7, 0x17, 0xFF, 0xA0, 0xB0, 0x1A,
+0x0A, 0x18, 0xA0, 0x1A, 0x75, 0x02, 0x00, 0x19,
+0xA0, 0x09, 0xAB, 0x48, 0xDD, 0x87, 0x01, 0x19,
+0x00, 0x0D, 0x86, 0x00, 0x02, 0x19, 0x00, 0x0D,
+0x87, 0x00, 0x04, 0x19, 0x00, 0x0D, 0x96, 0x01,
+0x00, 0x1A, 0x15, 0x00, 0x00, 0x0D, 0x00, 0xFF,
+0x01, 0x0E, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0x0F, 0x98, 0x32, 0x42, 0x00, 0x03, 0x9A, 0x01,
+0x00, 0x4A, 0x15, 0x00, 0x0D, 0xB0, 0x00, 0x1A,
+0x15, 0x00, 0x00, 0x49, 0x0A, 0xB0, 0x00, 0x19,
+0x00, 0x0D, 0x9A, 0x01, 0x00, 0x0D, 0x00, 0xFF,
+0x01, 0x0E, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0x0F, 0x98, 0x06, 0x46, 0x00, 0x03, 0x8E, 0x00,
+0x00, 0x0D, 0x85, 0x00, 0x00, 0x0E, 0x08, 0x17,
+0x00, 0x0E, 0x09, 0x17, 0x00, 0x1A, 0xFF, 0x7F,
+0x00, 0x0D, 0xD9, 0x17, 0x00, 0x0E, 0x72, 0x12,
+0x0F, 0x98, 0x7F, 0x4F, 0x0F, 0x98, 0x83, 0x48,
+0x0F, 0x98, 0x65, 0x40, 0x00, 0x0E, 0x7F, 0x02,
+0x00, 0x03, 0xEF, 0x00, 0x00, 0x0D, 0x78, 0x12,
+0x0F, 0x98, 0x43, 0x43, 0x0F, 0x98, 0x30, 0x46,
+0x0F, 0x98, 0xDB, 0x46, 0x00, 0x03, 0xF0, 0x00,
+0x00, 0x0D, 0x77, 0x02, 0x00, 0x0E, 0x0C, 0x16,
+0x00, 0x0E, 0x76, 0x01, 0x00, 0x0E, 0x78, 0x02,
+0x00, 0x03, 0x7F, 0x01, 0x00, 0x0D, 0xD3, 0x17,
+0x00, 0x03, 0x80, 0x01, 0x00, 0x0D, 0x52, 0x17,
+0x00, 0x0E, 0xD8, 0x17, 0x00, 0x0E, 0xDD, 0x17,
+0x00, 0x0E, 0xE0, 0x17, 0x00, 0x0E, 0xDF, 0x17,
+0x00, 0x03, 0xED, 0x00, 0x00, 0x0D, 0xDE, 0x17,
+0x00, 0x0E, 0xBF, 0x01, 0x00, 0x0E, 0x02, 0x18,
+0x00, 0x03, 0x85, 0x00, 0x02, 0x49, 0xCA, 0x80,
+0x00, 0x03, 0x93, 0x01, 0x01, 0x51, 0x80, 0x80,
+0x00, 0x03, 0x3F, 0x02, 0x00, 0x49, 0x40, 0x80,
+0x00, 0x0D, 0xFD, 0x17, 0x0F, 0x98, 0x5F, 0x49,
+0x0F, 0x98, 0x83, 0x48, 0x0F, 0x98, 0x68, 0x48,
+0x0F, 0x98, 0x83, 0x48, 0x0F, 0x98, 0x68, 0x48,
+0x00, 0x03, 0x8A, 0x00, 0x0A, 0x49, 0x2D, 0x80,
+0x0A, 0x0E, 0x8A, 0x00, 0x00, 0x03, 0x76, 0x02,
+0x01, 0x49, 0x00, 0x98, 0x3E, 0x43, 0x00, 0x03,
+0x7F, 0x02, 0x01, 0x49, 0x00, 0x88, 0x0A, 0x45,
+0x02, 0x49, 0x00, 0x88, 0xFE, 0x43, 0x00, 0x03,
+0x85, 0x00, 0x05, 0x49, 0x6D, 0x80, 0x08, 0x49,
+0xC0, 0x83, 0x0A, 0x49, 0x20, 0x80, 0x0F, 0x88,
+0xE3, 0x44, 0x00, 0x03, 0x85, 0x00, 0x03, 0x49,
+0x4B, 0x83, 0x00, 0x03, 0x65, 0x01, 0x0E, 0x51,
+0x50, 0x80, 0x00, 0x03, 0xAD, 0x13, 0x0E, 0xC1,
+0x00, 0x0D, 0xAD, 0x13, 0x00, 0x03, 0xAD, 0x13,
+0x00, 0x51, 0xC1, 0x81, 0x01, 0x51, 0xA1, 0x81,
+0x03, 0x51, 0x81, 0x81, 0x0F, 0x51, 0x61, 0x81,
+0x00, 0x03, 0x92, 0x01, 0x00, 0x51, 0x20, 0x81,
+0x01, 0x51, 0xC1, 0x80, 0x0F, 0x98, 0x44, 0x45,
+0x00, 0x03, 0x0C, 0x16, 0x01, 0x21, 0x00, 0x0D,
+0x0C, 0x16, 0x10, 0x03, 0xF2, 0x00, 0x01, 0x48,
+0x5B, 0x80, 0xFF, 0x80, 0x0F, 0x98, 0x3D, 0x40,
+0x11, 0x49, 0xB0, 0x80, 0x00, 0x0E, 0x0C, 0x16,
+0x00, 0x03, 0xAD, 0x13, 0x10, 0x03, 0x65, 0x01,
+0x01, 0x60, 0x01, 0x98, 0x6A, 0x45, 0x00, 0x0E,
+0xAD, 0x13, 0x0F, 0x98, 0x2E, 0x4E, 0x00, 0x03,
+0x85, 0x00, 0x03, 0x49, 0x2B, 0x80, 0x0F, 0x98,
+0x27, 0x45, 0x00, 0x03, 0x85, 0x00, 0x03, 0x49,
+0x90, 0x80, 0x0A, 0x49, 0x70, 0x80, 0x04, 0x49,
+0x50, 0x80, 0x05, 0x49, 0x30, 0x80, 0x08, 0x49,
+0x10, 0x80, 0x4F, 0x80, 0x0F, 0x98, 0xA8, 0x45,
+0x0F, 0x98, 0x4D, 0x45, 0x0F, 0x98, 0x07, 0x51,
+0x00, 0x03, 0x92, 0x01, 0x0E, 0x51, 0x00, 0x88,
+0x50, 0x44, 0x0F, 0x98, 0x66, 0x43, 0x00, 0x03,
+0xE5, 0x17, 0x00, 0x49, 0x00, 0x88, 0x50, 0x44,
+0x00, 0x03, 0x05, 0x18, 0x01, 0x21, 0x00, 0x0D,
+0x05, 0x18, 0x00, 0x4E, 0xB8, 0x01, 0x0D, 0x88,
+0x50, 0x44, 0x00, 0x0E, 0x05, 0x18, 0x0F, 0x98,
+0x83, 0x48, 0x00, 0x0E, 0x11, 0xF8, 0x00, 0x0E,
+0x72, 0xF8, 0x0F, 0x98, 0x44, 0x40, 0x0F, 0x98,
+0x56, 0x45, 0x0F, 0x88, 0x50, 0x44, 0x00, 0x03,
+0x85, 0x00, 0x06, 0x49, 0x90, 0x80, 0x0B, 0x49,
+0x70, 0x80, 0x09, 0x49, 0x50, 0x80, 0x07, 0x49,
+0x30, 0x80, 0x00, 0x4A, 0x14, 0x00, 0xA1, 0x81,
+0x0F, 0x98, 0xB8, 0x47, 0xA0, 0x1A, 0xA0, 0x02,
+0x0A, 0x0D, 0x80, 0x02, 0x0F, 0x98, 0xB2, 0x48,
+0x0F, 0x98, 0x68, 0x48, 0xB0, 0x1A, 0xA0, 0x02,
+0x0F, 0x98, 0x1F, 0x4A, 0x00, 0x0E, 0x0A, 0x17,
+0xC0, 0x1A, 0xA0, 0x02, 0x0F, 0x98, 0xB9, 0x47,
+0x0F, 0x98, 0xA8, 0x45, 0x0F, 0x98, 0x4D, 0x45,
+0x0F, 0x88, 0x50, 0x44, 0x00, 0x03, 0x7F, 0x02,
+0x01, 0x49, 0x01, 0x88, 0x50, 0x44, 0x0F, 0x98,
+0x43, 0x43, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x0D,
+0x77, 0x02, 0x00, 0x03, 0x85, 0x00, 0x07, 0x49,
+0xA1, 0x80, 0x00, 0x0E, 0x72, 0x12, 0x0F, 0x98,
+0x36, 0x48, 0x01, 0x0E, 0x72, 0x12, 0x02, 0x0E,
+0x7F, 0x02, 0x0F, 0x88, 0x50, 0x44, 0x00, 0x0E,
+0x7F, 0x02, 0x0F, 0x88, 0x50, 0x44, 0x00, 0x03,
+0x66, 0x01, 0x00, 0x49, 0xF0, 0xA0, 0x00, 0x03,
+0xE7, 0x17, 0x10, 0x03, 0x75, 0x02, 0x11, 0x21,
+0x01, 0x0D, 0x75, 0x02, 0x10, 0x48, 0xFC, 0xA0,
+0x30, 0x1A, 0xF5, 0x00, 0x30, 0x0B, 0x31, 0x21,
+0x00, 0x1A, 0x64, 0x64, 0x30, 0x08, 0x0F, 0x98,
+0x50, 0x40, 0xB0, 0x1A, 0xF5, 0x00, 0x92, 0x19,
+0x0F, 0x98, 0x89, 0x40, 0x0F, 0x88, 0x5D, 0x40,
+0xA0, 0x03, 0xF1, 0x00, 0xA0, 0x49, 0xF0, 0xA0,
+0xFF, 0xFF, 0xFF, 0xFF, 0xA1, 0x39, 0xC1, 0x87,
+0xFF, 0xA0, 0xA0, 0x03, 0xF4, 0x00, 0xA0, 0x49,
+0xF0, 0xA0, 0xFF, 0xFF, 0xFF, 0xFF, 0xA1, 0x39,
+0xC1, 0x87, 0xFF, 0xA0, 0x00, 0x03, 0xE5, 0x17,
+0x00, 0x0E, 0x00, 0xFF, 0x01, 0x0E, 0x01, 0xFF,
+0x01, 0x39, 0xC1, 0x87, 0x00, 0x03, 0x9A, 0x01,
+0x00, 0x0D, 0x00, 0xFF, 0x01, 0x0E, 0x01, 0xFF,
+0x10, 0x03, 0x00, 0xF5, 0x10, 0x51, 0x01, 0x88,
+0x94, 0x43, 0xFF, 0xA0, 0x0F, 0x98, 0x1C, 0x6C,
+0x0F, 0x98, 0x50, 0x40, 0x00, 0x03, 0xD2, 0x12,
+0x00, 0x0D, 0x1F, 0x01, 0xB0, 0x1A, 0x81, 0x02,
+0xC0, 0x1A, 0x8A, 0x01, 0xA8, 0x19, 0x0B, 0x01,
+0xC0, 0x09, 0xA1, 0x39, 0xC1, 0x87, 0x00, 0x03,
+0x85, 0x00, 0x02, 0x49, 0xA0, 0x81, 0x90, 0x03,
+0x8A, 0x00, 0xB0, 0x1A, 0xF5, 0x00, 0x0F, 0x98,
+0x38, 0x40, 0x00, 0x0E, 0x08, 0xF3, 0xA0, 0x1A,
+0x00, 0x40, 0x0B, 0x01, 0xA0, 0x09, 0x0B, 0x01,
+0xA0, 0x09, 0x33, 0x19, 0x0B, 0x01, 0xA0, 0x09,
+0x31, 0x39, 0xC1, 0x87, 0xB1, 0x21, 0x91, 0x39,
+0x81, 0x87, 0x01, 0x0E, 0x08, 0xF3, 0x0F, 0x88,
+0x5D, 0x40, 0x94, 0x19, 0x30, 0x03, 0x8A, 0x00,
+0x93, 0x58, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0x90, 0x1E, 0x92, 0x21, 0xB0, 0x1A, 0xF5, 0x00,
+0x0F, 0x98, 0x89, 0x40, 0x0F, 0x88, 0x5D, 0x40,
+0x00, 0x03, 0xAD, 0x13, 0x10, 0x03, 0x65, 0x01,
+0x01, 0x60, 0x01, 0x98, 0x1C, 0x6C, 0x01, 0x0E,
+0x55, 0x17, 0xB0, 0x1A, 0xA0, 0x02, 0x00, 0x03,
+0x85, 0x00, 0x03, 0x49, 0x1C, 0x83, 0x03, 0x49,
+0xB0, 0x83, 0x05, 0x49, 0xD0, 0x82, 0x00, 0x0E,
+0x55, 0x17, 0xB0, 0x1A, 0x20, 0x07, 0x0A, 0x49,
+0x70, 0x82, 0xB0, 0x1A, 0x60, 0x09, 0x04, 0x49,
+0x30, 0x82, 0xB0, 0x1A, 0x80, 0x00, 0x00, 0x4A,
+0x14, 0x00, 0xE0, 0x81, 0x07, 0x49, 0x71, 0x80,
+0xC0, 0x1A, 0xA0, 0x02, 0x0F, 0x98, 0x97, 0x4D,
+0xB0, 0x1A, 0xA0, 0x02, 0x5F, 0x81, 0xB0, 0x1A,
+0xA0, 0x02, 0x08, 0x49, 0x11, 0x81, 0xC0, 0x03,
+0x8D, 0x00, 0xC0, 0x51, 0x31, 0x80, 0xB0, 0x1A,
+0x20, 0x10, 0xAF, 0x80, 0xB0, 0x1A, 0x20, 0x10,
+0xD0, 0x03, 0x8B, 0x02, 0xB0, 0x0B, 0xB1, 0x21,
+0xD1, 0x39, 0xC1, 0x87, 0xB0, 0x1A, 0x20, 0x10,
+0x0F, 0x98, 0x44, 0x40, 0x00, 0x03, 0xD2, 0x12,
+0x00, 0x0D, 0x1F, 0x01, 0x90, 0x03, 0x8B, 0x02,
+0x0F, 0x98, 0x96, 0x40, 0x0F, 0x88, 0x5D, 0x40,
+0x0F, 0x98, 0xED, 0x53, 0x0F, 0x98, 0x44, 0x40,
+0x00, 0x03, 0xD2, 0x12, 0x00, 0x0D, 0x1F, 0x01,
+0xB0, 0x1A, 0xA0, 0x02, 0x90, 0x03, 0x8B, 0x02,
+0x0F, 0x98, 0x96, 0x40, 0x0F, 0x98, 0x5D, 0x40,
+0x0F, 0x88, 0x46, 0x54, 0xA0, 0x03, 0x95, 0x00,
+0x0A, 0x0D, 0x88, 0x12, 0x0A, 0x0D, 0x8E, 0x12,
+0x00, 0x0E, 0x79, 0x12, 0x00, 0x0E, 0x7A, 0x12,
+0x00, 0x0E, 0xAF, 0x13, 0x00, 0x0E, 0xAE, 0x13,
+0x00, 0x0E, 0x0E, 0x16, 0x00, 0x0E, 0x76, 0x12,
+0x00, 0x0E, 0x74, 0x12, 0x00, 0x0E, 0x75, 0x12,
+0x00, 0x0E, 0x0B, 0x16, 0x00, 0x03, 0x43, 0x02,
+0x00, 0x0D, 0xFD, 0x17, 0x0F, 0x98, 0x65, 0x40,
+0x0F, 0x98, 0x7F, 0x4F, 0xCA, 0x19, 0xD0, 0x1A,
+0xF7, 0x00, 0xD2, 0x21, 0xD0, 0x0B, 0xD4, 0x21,
+0xC1, 0x39, 0xC1, 0x87, 0x0F, 0x88, 0xAE, 0x6C,
+0x00, 0x1A, 0xC3, 0xBA, 0x00, 0x0D, 0x00, 0xF2,
+0x00, 0x1A, 0x08, 0x79, 0x00, 0x0D, 0x01, 0xF2,
+0x00, 0x0E, 0x08, 0xF2, 0x00, 0x0E, 0x09, 0xF2,
+0x00, 0x1A, 0xFF, 0xFF, 0x00, 0x0D, 0x10, 0xF2,
+0x00, 0x0D, 0x11, 0xF2, 0x00, 0x03, 0xB6, 0x01,
+0x00, 0x0D, 0x02, 0xF8, 0x00, 0x0E, 0x03, 0xF8,
+0x00, 0x0E, 0x04, 0xF8, 0x00, 0x03, 0xA2, 0x01,
+0x00, 0x0D, 0x1D, 0xF8, 0x00, 0x03, 0xA4, 0x01,
+0x00, 0x0D, 0x1E, 0xF8, 0x01, 0x0E, 0x09, 0xF8,
+0x00, 0x03, 0xA8, 0x01, 0x00, 0x0D, 0x0A, 0xF8,
+0x00, 0x03, 0xA9, 0x01, 0x00, 0x0D, 0x0B, 0xF8,
+0x00, 0x03, 0xA6, 0x01, 0x00, 0x0D, 0x0C, 0xF8,
+0x00, 0x03, 0xA7, 0x01, 0x00, 0x0D, 0x0D, 0xF8,
+0x00, 0x03, 0xB3, 0x01, 0x00, 0x62, 0xF0, 0xFF,
+0x10, 0x03, 0xA0, 0x01, 0x01, 0x68, 0x00, 0x0D,
+0x0E, 0xF8, 0x00, 0x0E, 0x0F, 0xF8, 0x00, 0x03,
+0xAC, 0x01, 0x00, 0x0D, 0x11, 0xF8, 0x00, 0x03,
+0xB0, 0x01, 0x00, 0x0D, 0x12, 0xF8, 0x00, 0x03,
+0xB1, 0x01, 0x00, 0x0D, 0x13, 0xF8, 0x00, 0x03,
+0x9E, 0x01, 0x00, 0x0D, 0x14, 0xF8, 0x00, 0x03,
+0x9F, 0x01, 0x00, 0x0D, 0x15, 0xF8, 0x00, 0x03,
+0xB4, 0x01, 0x00, 0x0D, 0x1A, 0xF8, 0x00, 0x03,
+0x9D, 0x01, 0x00, 0x0D, 0x1B, 0xF8, 0x00, 0x0E,
+0x10, 0xF8, 0x00, 0x03, 0x9C, 0x01, 0x00, 0x0D,
+0x1F, 0xF8, 0x00, 0x0E, 0x20, 0xF8, 0x00, 0x03,
+0xB2, 0x01, 0x00, 0x0D, 0x21, 0xF8, 0x00, 0x03,
+0xAB, 0x01, 0x00, 0x0D, 0x22, 0xF8, 0x00, 0x1A,
+0x11, 0x01, 0x00, 0x0D, 0x30, 0xF8, 0x00, 0x0E,
+0x47, 0xF8, 0x00, 0x1A, 0x00, 0x10, 0x00, 0x0D,
+0x49, 0xF8, 0x00, 0x03, 0xA5, 0x01, 0x00, 0x0D,
+0x71, 0xF8, 0x00, 0x03, 0xC1, 0x01, 0x00, 0x0D,
+0x72, 0xF8, 0x00, 0x03, 0xC2, 0x01, 0x00, 0x0D,
+0x73, 0xF8, 0x00, 0x03, 0xC3, 0x01, 0x00, 0x0D,
+0x74, 0xF8, 0x00, 0x03, 0xC4, 0x01, 0x00, 0x0D,
+0x75, 0xF8, 0x00, 0x03, 0xAD, 0x01, 0x00, 0x0D,
+0x76, 0xF8, 0x00, 0x03, 0xAE, 0x01, 0x00, 0x0D,
+0x77, 0xF8, 0xFF, 0xA0, 0x00, 0x0E, 0x8A, 0x02,
+0xD0, 0x1A, 0x20, 0x00, 0xD1, 0x79, 0xC0, 0x1A,
+0xD7, 0x00, 0xB0, 0x1A, 0x50, 0xF8, 0x0C, 0x01,
+0xB0, 0x09, 0xD1, 0x39, 0xC1, 0x87, 0xD0, 0x1A,
+0x20, 0x00, 0xD1, 0x79, 0xC0, 0x1A, 0x9B, 0x01,
+0xB0, 0x1A, 0x00, 0xF1, 0x0C, 0x00, 0xB0, 0x09,
+0xD1, 0x39, 0xD1, 0x87, 0xFF, 0xA0, 0xA0, 0x03,
+0xD5, 0x00, 0xA0, 0x5A, 0x12, 0x00, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xA0, 0x1E, 0x0A, 0x0D,
+0x56, 0x17, 0xA0, 0x03, 0xD5, 0x00, 0xC0, 0x03,
+0xD6, 0x00, 0xAC, 0x58, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xA0, 0x1E, 0x0A, 0x0D, 0x8B, 0x02,
+0x0F, 0x98, 0x4D, 0x50, 0xB0, 0x03, 0x0A, 0x16,
+0xA0, 0x03, 0x09, 0x16, 0xBA, 0x38, 0xB1, 0x21,
+0xC0, 0x03, 0x08, 0x16, 0xA0, 0x03, 0x07, 0x16,
+0xCA, 0x38, 0xC1, 0x21, 0xB7, 0x7B, 0xC7, 0x7B,
+0x0B, 0x0D, 0xC6, 0x12, 0x0C, 0x0D, 0xC7, 0x12,
+0x00, 0x03, 0xD5, 0x00, 0x01, 0x39, 0x00, 0x0D,
+0x08, 0xF8, 0x00, 0x03, 0xB6, 0x01, 0x01, 0x51,
+0x40, 0x80, 0x00, 0x1A, 0x1E, 0x00, 0x00, 0x0D,
+0x08, 0xF8, 0x0F, 0x98, 0xC2, 0x46, 0x01, 0x0E,
+0x07, 0xF8, 0x00, 0x03, 0xAA, 0x01, 0x00, 0x0D,
+0x05, 0xF8, 0x10, 0x03, 0x85, 0x00, 0x16, 0x49,
+0x40, 0x80, 0x1B, 0x49, 0x20, 0x80, 0x19, 0x49,
+0x71, 0x80, 0x00, 0x03, 0x97, 0x01, 0x00, 0x0D,
+0x06, 0xF8, 0x00, 0x03, 0x98, 0x01, 0x6F, 0x80,
+0x00, 0x03, 0xED, 0x00, 0x00, 0x0D, 0x06, 0xF8,
+0x00, 0x03, 0xEE, 0x00, 0x00, 0x62, 0x3F, 0x00,
+0x10, 0x18, 0x20, 0x18, 0x26, 0x7B, 0x30, 0x18,
+0x3C, 0x7B, 0x12, 0x68, 0x13, 0x68, 0x01, 0x0D,
+0x16, 0xF8, 0x10, 0x18, 0x14, 0x79, 0x20, 0x18,
+0x22, 0x7B, 0x30, 0x18, 0x38, 0x7B, 0x40, 0x18,
+0x4E, 0x7B, 0x12, 0x68, 0x13, 0x68, 0x14, 0x68,
+0x01, 0x0D, 0x17, 0xF8, 0x10, 0x18, 0x12, 0x79,
+0x20, 0x18, 0x24, 0x7B, 0x30, 0x18, 0x3A, 0x7B,
+0x12, 0x68, 0x13, 0x68, 0x01, 0x0D, 0x18, 0xF8,
+0x00, 0x0D, 0x19, 0xF8, 0x0F, 0x98, 0x9F, 0x48,
+0x00, 0x0D, 0xD4, 0x01, 0x00, 0x0E, 0x10, 0xF8,
+0x00, 0x03, 0x85, 0x00, 0x06, 0x49, 0xF0, 0xA0,
+0x09, 0x49, 0xF0, 0xA0, 0x0B, 0x49, 0xA1, 0x80,
+0x0F, 0x98, 0xA3, 0x49, 0x00, 0x03, 0xD5, 0x00,
+0x01, 0x39, 0x00, 0x0D, 0x08, 0xF8, 0x00, 0x0E,
+0x0E, 0xF8, 0xFF, 0xA0, 0xC0, 0x03, 0x8D, 0x00,
+0xC0, 0x51, 0xD1, 0x80, 0x0F, 0x98, 0xFF, 0x41,
+0x00, 0x1A, 0x00, 0x80, 0x00, 0x0D, 0x0A, 0x17,
+0xC0, 0x1A, 0x20, 0x10, 0x0F, 0x98, 0xB9, 0x47,
+0x01, 0x0E, 0x72, 0x12, 0xFF, 0xA0, 0x00, 0x03,
+0x78, 0x12, 0x01, 0x49, 0xF1, 0xA0, 0x00, 0x0E,
+0x78, 0x12, 0xFF, 0xA0, 0x90, 0x19, 0x30, 0x19,
+0x00, 0x03, 0x76, 0x01, 0x01, 0x49, 0x01, 0xB0,
+0x30, 0x03, 0x99, 0x01, 0x02, 0x49, 0x01, 0xB0,
+0x30, 0x03, 0xE0, 0x01, 0x20, 0x03, 0xED, 0x00,
+0x00, 0x03, 0xE0, 0x17, 0x23, 0x7A, 0x20, 0x20,
+0x00, 0x03, 0xDE, 0x17, 0x02, 0x48, 0x41, 0x80,
+0x00, 0x03, 0xDF, 0x17, 0x03, 0x48, 0xF0, 0xA0,
+0x0F, 0x98, 0x83, 0x48, 0x0F, 0x98, 0xAB, 0x47,
+0x02, 0x0D, 0xDE, 0x17, 0x03, 0x0D, 0xDF, 0x17,
+0x91, 0x19, 0x0F, 0x88, 0x68, 0x48, 0x20, 0x03,
+0xDE, 0x17, 0x30, 0x03, 0xDF, 0x17, 0x00, 0x03,
+0xB3, 0x01, 0x00, 0x62, 0xF0, 0xFF, 0x10, 0x03,
+0xA0, 0x01, 0x13, 0x20, 0x01, 0x68, 0x00, 0x0D,
+0x0E, 0xF8, 0x02, 0x0D, 0x06, 0xF8, 0xFF, 0xA0,
+0xFF, 0xA0, 0x10, 0x03, 0x65, 0x01, 0x1F, 0x51,
+0xF0, 0xA0, 0xB0, 0x1A, 0x60, 0x12, 0xA0, 0x03,
+0xD6, 0x00, 0x00, 0x03, 0x28, 0x01, 0x00, 0x49,
+0x20, 0x80, 0xA0, 0x03, 0xD5, 0x00, 0xB0, 0x0B,
+0xB1, 0x21, 0xA1, 0x39, 0xC1, 0x87, 0x00, 0x0E,
+0x8D, 0x02, 0x00, 0x03, 0x25, 0x01, 0x00, 0x4E,
+0x8D, 0x02, 0x3D, 0x82, 0x60, 0x1A, 0x2B, 0x01,
+0x00, 0x03, 0x8D, 0x02, 0x60, 0x20, 0x06, 0x00,
+0x00, 0x0D, 0x92, 0x02, 0x00, 0x0E, 0x93, 0x02,
+0xB0, 0x1A, 0x60, 0x12, 0x60, 0x03, 0x92, 0x02,
+0xB6, 0x20, 0xB1, 0x0B, 0x00, 0x03, 0x92, 0x02,
+0x01, 0x21, 0x00, 0x0D, 0x92, 0x02, 0x00, 0x03,
+0x93, 0x02, 0x01, 0x21, 0x00, 0x0D, 0x93, 0x02,
+0x00, 0x4E, 0x2A, 0x01, 0xD1, 0x86, 0x00, 0x03,
+0x8D, 0x02, 0x01, 0x21, 0x00, 0x0D, 0x8D, 0x02,
+0x8F, 0x85, 0x00, 0x0E, 0x93, 0x02, 0x00, 0x03,
+0xD6, 0x00, 0x00, 0x0D, 0x8D, 0x02, 0x00, 0x03,
+0x28, 0x01, 0x00, 0x49, 0x40, 0x80, 0x00, 0x03,
+0xD5, 0x00, 0x00, 0x0D, 0x8D, 0x02, 0x00, 0x03,
+0x28, 0x01, 0x00, 0x49, 0xD1, 0x80, 0x20, 0x03,
+0xD6, 0x00, 0x60, 0x03, 0x29, 0x01, 0x62, 0x58,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x60, 0x1E,
+0x50, 0x03, 0x93, 0x02, 0x65, 0x20, 0xCF, 0x80,
+0x20, 0x03, 0xD6, 0x00, 0x60, 0x03, 0x93, 0x02,
+0x62, 0x58, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0x60, 0x1E, 0x50, 0x03, 0x29, 0x01, 0x65, 0x20,
+0xB0, 0x1A, 0x60, 0x12, 0x10, 0x03, 0x93, 0x02,
+0xB1, 0x20, 0x0B, 0x00, 0x01, 0x49, 0x50, 0x80,
+0xAC, 0x18, 0xA6, 0x20, 0x00, 0x03, 0x0A, 0x17,
+0xA0, 0x08, 0x00, 0x03, 0x93, 0x02, 0x01, 0x21,
+0x00, 0x0D, 0x93, 0x02, 0x00, 0x4E, 0x8D, 0x02,
+0xE1, 0x84, 0xFF, 0xA0, 0x01, 0x0E, 0x08, 0x17,
+0x0F, 0x98, 0x83, 0x48, 0x0F, 0x98, 0x68, 0x48,
+0x00, 0x0E, 0xF4, 0x12, 0x0F, 0x98, 0x83, 0x48,
+0x0F, 0x98, 0x68, 0x48, 0x00, 0x03, 0xF4, 0x12,
+0x01, 0x21, 0x00, 0x0D, 0xF4, 0x12, 0x00, 0x4E,
+0xEC, 0x00, 0x4C, 0x87, 0x0F, 0x98, 0x83, 0x48,
+0xB0, 0x1A, 0x20, 0x10, 0x0B, 0x0D, 0x80, 0x02,
+0x0F, 0x98, 0xB2, 0x48, 0xB0, 0x1A, 0x20, 0x10,
+0x0F, 0x98, 0x1F, 0x4A, 0xA0, 0x03, 0x8D, 0x00,
+0xA0, 0xC9, 0xA2, 0xC9, 0x0A, 0x0D, 0x8D, 0x00,
+0x00, 0x03, 0x08, 0x17, 0x00, 0x49, 0xC1, 0x87,
+0x00, 0x1A, 0x00, 0x80, 0x00, 0x0D, 0x0A, 0x17,
+0xC0, 0x1A, 0x20, 0x10, 0x0F, 0x88, 0xB9, 0x47,
+0x00, 0x03, 0xC1, 0x01, 0x00, 0x0D, 0x72, 0xF8,
+0x00, 0x03, 0xAC, 0x01, 0x00, 0x0D, 0x11, 0xF8,
+0x0F, 0x98, 0x83, 0x48, 0x00, 0x1A, 0xFF, 0xFF,
+0x00, 0x0D, 0x10, 0xF2, 0x00, 0x0D, 0x11, 0xF2,
+0x02, 0x0E, 0x0A, 0xF3, 0x02, 0x0E, 0x0B, 0xF3,
+0x02, 0x0E, 0x0C, 0xF3, 0x02, 0x0E, 0x0D, 0xF3,
+0x01, 0x0E, 0x00, 0xF8, 0xFF, 0xA0, 0x00, 0x03,
+0x02, 0xF8, 0x00, 0x51, 0xC1, 0x87, 0x00, 0x0E,
+0x10, 0xF2, 0x00, 0x0E, 0x11, 0xF2, 0xFF, 0xA0,
+0x0F, 0x98, 0x83, 0x48, 0x02, 0x0E, 0x00, 0xF8,
+0xFF, 0xA0, 0x0F, 0x98, 0x83, 0x48, 0x00, 0x03,
+0x75, 0x01, 0x10, 0x03, 0xF9, 0x17, 0x10, 0x4A,
+0xFF, 0xFF, 0x20, 0x80, 0x00, 0x03, 0xDD, 0x01,
+0x00, 0x0D, 0x1C, 0xF8, 0xFF, 0xA0, 0x00, 0x1A,
+0xFF, 0xFF, 0x00, 0x0D, 0xF1, 0x17, 0x00, 0x0D,
+0xF9, 0x17, 0x00, 0x0D, 0xFF, 0x17, 0x00, 0x0E,
+0xF2, 0x17, 0x00, 0x1A, 0x00, 0x80, 0x00, 0x0D,
+0xF3, 0x17, 0x00, 0x1A, 0xFF, 0x7F, 0x00, 0x0D,
+0xF6, 0x17, 0xFF, 0x85, 0x0F, 0x98, 0x83, 0x48,
+0x00, 0x0E, 0x0A, 0xF3, 0x00, 0x0E, 0x0C, 0xF3,
+0x00, 0x03, 0x85, 0x00, 0xB0, 0x1A, 0x00, 0x70,
+0x09, 0x49, 0x20, 0x80, 0xB0, 0x1A, 0x00, 0x90,
+0xD0, 0x03, 0x56, 0x17, 0xC0, 0x03, 0x80, 0x02,
+0x0B, 0x01, 0xC0, 0x09, 0xD1, 0x39, 0xC1, 0x87,
+0xFF, 0xA0, 0x00, 0x0E, 0xD6, 0x17, 0x00, 0x03,
+0x92, 0x01, 0x0A, 0x51, 0x20, 0x80, 0x01, 0x0E,
+0xD6, 0x17, 0x00, 0x03, 0x92, 0x01, 0x05, 0x51,
+0x20, 0x80, 0x02, 0x0E, 0xD6, 0x17, 0x00, 0x03,
+0x85, 0x00, 0x05, 0x49, 0x4D, 0x80, 0x0A, 0x49,
+0x20, 0x80, 0x00, 0x0E, 0xD6, 0x17, 0x0F, 0x98,
+0x83, 0x48, 0x00, 0x0E, 0x0A, 0xF3, 0x00, 0x0E,
+0x0B, 0xF3, 0x00, 0x0E, 0x0C, 0xF3, 0x00, 0x03,
+0xD6, 0x17, 0x00, 0x49, 0x00, 0x82, 0xB0, 0x1A,
+0x00, 0x70, 0xC0, 0x1A, 0xE0, 0x0D, 0xA0, 0x19,
+0xB2, 0x21, 0xDA, 0x19, 0x0B, 0x01, 0x9C, 0x00,
+0xC0, 0x09, 0x90, 0x38, 0x1A, 0x80, 0x90, 0x31,
+0x9A, 0x48, 0x1C, 0x80, 0xA9, 0x18, 0xD1, 0x39,
+0x51, 0x87, 0xB0, 0x4A, 0xF0, 0x70, 0x0C, 0x87,
+0x00, 0x03, 0x77, 0x02, 0x00, 0x49, 0x71, 0x80,
+0x0A, 0x0D, 0x78, 0x01, 0xA0, 0x4E, 0xD3, 0x17,
+0x2C, 0x80, 0x01, 0x0E, 0x7C, 0x12, 0x0F, 0x98,
+0xB2, 0x48, 0x0F, 0x98, 0x93, 0x49, 0x00, 0x03,
+0x7B, 0x01, 0x00, 0x0D, 0x1C, 0xF8, 0x00, 0x1A,
+0x89, 0x17, 0x00, 0x0D, 0x4E, 0x17, 0x0F, 0x98,
+0xDD, 0x49, 0x80, 0x03, 0x4F, 0x17, 0x08, 0x0D,
+0x51, 0x17, 0x08, 0x0D, 0x79, 0x01, 0x00, 0x03,
+0xF1, 0x17, 0x00, 0x0D, 0xF9, 0x17, 0x0F, 0x98,
+0x91, 0x48, 0x00, 0x0D, 0xD4, 0x01, 0x0F, 0x98,
+0xB2, 0x49, 0x00, 0x03, 0x77, 0x02, 0x00, 0x49,
+0x01, 0x88, 0x68, 0x48, 0x00, 0x03, 0x93, 0x01,
+0x01, 0x51, 0x00, 0x88, 0x68, 0x48, 0x00, 0x03,
+0x44, 0x02, 0x00, 0x4E, 0x51, 0x17, 0x8D, 0x80,
+0x00, 0x03, 0x0E, 0x16, 0x00, 0x49, 0xA0, 0x80,
+0x00, 0x03, 0x43, 0x02, 0x00, 0x0D, 0xFD, 0x17,
+0x00, 0x03, 0x42, 0x02, 0x00, 0x0D, 0xFA, 0x17,
+0x0F, 0x88, 0x68, 0x48, 0x00, 0x03, 0xFA, 0x17,
+0x01, 0x39, 0x00, 0x0D, 0xFA, 0x17, 0x00, 0x49,
+0x0A, 0x88, 0x68, 0x48, 0x00, 0x0E, 0xFA, 0x17,
+0x00, 0x03, 0x76, 0x01, 0x00, 0x49, 0x80, 0x81,
+0x00, 0x03, 0x43, 0x02, 0x00, 0x0D, 0xFD, 0x17,
+0x00, 0x03, 0xD4, 0x01, 0x10, 0x03, 0xDD, 0x01,
+0x01, 0x48, 0x00, 0x88, 0x68, 0x48, 0x00, 0x03,
+0xDE, 0x01, 0x00, 0x0D, 0xE0, 0x17, 0x00, 0x0E,
+0xF1, 0x17, 0x00, 0x0E, 0xF9, 0x17, 0x0F, 0x98,
+0x91, 0x48, 0x00, 0x0D, 0xD4, 0x01, 0x9F, 0x81,
+0x00, 0x03, 0xFD, 0x17, 0x00, 0x49, 0x50, 0x80,
+0x01, 0x39, 0x00, 0x0D, 0xFD, 0x17, 0x0F, 0x88,
+0x68, 0x48, 0x00, 0x03, 0xD4, 0x01, 0x00, 0x4E,
+0x75, 0x01, 0x00, 0x88, 0x68, 0x48, 0x0F, 0x98,
+0x9F, 0x48, 0x00, 0x0D, 0xD4, 0x01, 0x00, 0x03,
+0x43, 0x02, 0x00, 0x0D, 0xFD, 0x17, 0x00, 0x0E,
+0xE0, 0x17, 0x01, 0x0E, 0x02, 0x18, 0x00, 0x03,
+0x41, 0x02, 0x00, 0x0D, 0x77, 0x02, 0x01, 0x0E,
+0x7C, 0x12, 0x0F, 0x98, 0x82, 0x47, 0x91, 0x49,
+0xF0, 0xA0, 0x0F, 0x88, 0x68, 0x48, 0x0F, 0x98,
+0x83, 0x48, 0x00, 0x0E, 0x10, 0xF8, 0x00, 0x0E,
+0x08, 0xF8, 0x02, 0x0E, 0x06, 0xF8, 0x00, 0x0E,
+0x1D, 0xF8, 0x00, 0x0E, 0x1E, 0xF8, 0x00, 0x03,
+0xA0, 0x01, 0x00, 0x0D, 0x0E, 0xF8, 0x00, 0x1A,
+0xFF, 0xFF, 0x00, 0x0D, 0x1B, 0xF8, 0x00, 0x0E,
+0x02, 0xF8, 0x00, 0x1A, 0x01, 0x10, 0x00, 0x0D,
+0x73, 0xF8, 0x00, 0x1A, 0x22, 0x02, 0x00, 0x0D,
+0x75, 0xF8, 0xFF, 0xA0, 0x0F, 0x98, 0x83, 0x48,
+0x00, 0x0E, 0x10, 0xF8, 0x00, 0x03, 0xD5, 0x00,
+0x01, 0x39, 0x00, 0x0D, 0x08, 0xF8, 0x00, 0x03,
+0xB6, 0x01, 0x01, 0x51, 0x40, 0x80, 0x00, 0x1A,
+0x1E, 0x00, 0x00, 0x0D, 0x08, 0xF8, 0x00, 0x03,
+0x9D, 0x01, 0x00, 0x0D, 0x1B, 0xF8, 0x00, 0x03,
+0xA2, 0x01, 0x00, 0x0D, 0x1D, 0xF8, 0x00, 0x03,
+0xA4, 0x01, 0x00, 0x0D, 0x1E, 0xF8, 0x00, 0x03,
+0xB6, 0x01, 0x00, 0x0D, 0x02, 0xF8, 0x00, 0x03,
+0xC2, 0x01, 0x00, 0x0D, 0x73, 0xF8, 0x00, 0x03,
+0xC4, 0x01, 0x00, 0x0D, 0x75, 0xF8, 0x0F, 0x88,
+0xA7, 0x47, 0x00, 0x0E, 0x8D, 0x02, 0x00, 0x0E,
+0x4F, 0x17, 0x0F, 0x98, 0x83, 0x48, 0x0F, 0x98,
+0x68, 0x48, 0x0F, 0x98, 0x83, 0x48, 0x0F, 0x98,
+0x68, 0x48, 0x0F, 0x98, 0x83, 0x48, 0x00, 0x0E,
+0x0C, 0xF3, 0xB0, 0x1A, 0x00, 0x90, 0xD0, 0x1A,
+0x12, 0x00, 0x80, 0x03, 0x4F, 0x17, 0xC0, 0x03,
+0x4E, 0x17, 0xAC, 0x18, 0xA0, 0x22, 0x12, 0x00,
+0x90, 0x03, 0x8D, 0x02, 0x0B, 0x01, 0x1C, 0x00,
+0x90, 0x49, 0x01, 0xB0, 0xC0, 0x08, 0x10, 0x38,
+0x1F, 0x51, 0x00, 0xB0, 0x10, 0x31, 0x81, 0x48,
+0x0A, 0xB0, 0x81, 0x18, 0x1A, 0x00, 0x10, 0x38,
+0x1F, 0x51, 0x00, 0xB0, 0x10, 0x31, 0x81, 0x48,
+0x0A, 0xB0, 0x81, 0x18, 0x90, 0x49, 0x00, 0xB0,
+0xA0, 0x08, 0xC1, 0x21, 0xA1, 0x21, 0xD1, 0x39,
+0x51, 0x86, 0x08, 0x0D, 0x4F, 0x17, 0x00, 0x03,
+0x8D, 0x02, 0x01, 0x21, 0x00, 0x0D, 0x8D, 0x02,
+0x02, 0x49, 0x9C, 0x84, 0xFF, 0xA0, 0xCB, 0x18,
+0xD0, 0x03, 0x8B, 0x02, 0x20, 0x1A, 0x12, 0x00,
+0x30, 0x1A, 0x68, 0x01, 0x60, 0x1A, 0x7A, 0x16,
+0x03, 0x00, 0x00, 0x62, 0xFF, 0x00, 0x60, 0x08,
+0x61, 0x21, 0x03, 0x01, 0x08, 0x79, 0x60, 0x09,
+0x21, 0x39, 0x61, 0x87, 0x40, 0x1A, 0x50, 0x14,
+0x20, 0x1A, 0x12, 0x00, 0x7B, 0x01, 0x47, 0x09,
+0x21, 0x39, 0xC1, 0x87, 0x30, 0x1A, 0x7A, 0x16,
+0x60, 0x19, 0x40, 0x1A, 0x50, 0x14, 0x03, 0x01,
+0x04, 0x20, 0xA0, 0x00, 0xCA, 0x08, 0x61, 0x21,
+0x60, 0x4E, 0xD6, 0x00, 0xD1, 0x80, 0x40, 0x1A,
+0x50, 0x14, 0x20, 0x1A, 0x12, 0x00, 0x7B, 0x01,
+0x47, 0x09, 0x21, 0x39, 0xC1, 0x87, 0x30, 0x1A,
+0x7A, 0x16, 0x40, 0x1A, 0x50, 0x14, 0x60, 0x19,
+0xC1, 0x21, 0xD1, 0x39, 0x81, 0x86, 0xFF, 0xA0,
+0x00, 0x03, 0x93, 0x01, 0x02, 0x51, 0xF0, 0xA0,
+0x00, 0x03, 0x77, 0x02, 0x00, 0x49, 0xF1, 0xA0,
+0x00, 0x03, 0x76, 0x01, 0x00, 0x49, 0xA0, 0x83,
+0xB0, 0x1A, 0xA0, 0x02, 0xC0, 0x1A, 0xA0, 0x0B,
+0xA0, 0x1A, 0x20, 0x07, 0xD0, 0x03, 0x8B, 0x02,
+0x9F, 0x19, 0x90, 0x31, 0x70, 0x19, 0x2B, 0x01,
+0x1A, 0x01, 0x21, 0x38, 0x29, 0x48, 0x0A, 0xB0,
+0x71, 0x21, 0xD1, 0x39, 0xD0, 0x49, 0x7A, 0x87,
+0x70, 0x4A, 0x96, 0x00, 0x7B, 0x80, 0x00, 0x0E,
+0x39, 0x16, 0x00, 0x03, 0x76, 0x01, 0x01, 0x49,
+0xEB, 0x80, 0xFF, 0xA0, 0x00, 0x03, 0x39, 0x16,
+0x01, 0x21, 0x00, 0x0D, 0x39, 0x16, 0x01, 0x0E,
+0x38, 0x16, 0x01, 0x0E, 0xED, 0x17, 0x02, 0x0E,
+0x76, 0x01, 0x0F, 0x98, 0x12, 0x4D, 0x00, 0x03,
+0x76, 0x12, 0x01, 0x49, 0xFD, 0xA0, 0xA0, 0x1A,
+0x12, 0x00, 0xC0, 0x1A, 0x26, 0x16, 0xA0, 0x49,
+0xF0, 0xA0, 0xBC, 0x01, 0xA1, 0x39, 0xB1, 0x49,
+0xAD, 0x87, 0x2F, 0x80, 0x00, 0x0E, 0x39, 0x16,
+0x00, 0x03, 0x76, 0x01, 0x00, 0x4E, 0x71, 0x02,
+0xFC, 0xA0, 0xB0, 0x1A, 0xA0, 0x02, 0xC0, 0x1A,
+0xA0, 0x0B, 0xA0, 0x1A, 0x20, 0x07, 0xD0, 0x03,
+0x8B, 0x02, 0x90, 0x03, 0x8E, 0x12, 0x80, 0x03,
+0x72, 0x02, 0x80, 0x49, 0x00, 0xB0, 0x98, 0x18,
+0x70, 0x03, 0x73, 0x02, 0x80, 0x03, 0x74, 0x02,
+0x0B, 0x01, 0x1A, 0x01, 0x20, 0x18, 0x21, 0x38,
+0x29, 0x48, 0xAA, 0x80, 0x30, 0x1A, 0x00, 0x80,
+0x30, 0x38, 0x1C, 0x00, 0x13, 0x38, 0x17, 0x48,
+0xDB, 0x80, 0x37, 0x20, 0xC3, 0x08, 0xAF, 0x80,
+0x30, 0x1A, 0x00, 0x80, 0x30, 0x38, 0x1C, 0x00,
+0x13, 0x38, 0x18, 0x48, 0x3D, 0x80, 0x11, 0x79,
+0x31, 0x20, 0xC3, 0x08, 0xC1, 0x21, 0xD1, 0x39,
+0xD0, 0x49, 0x21, 0x86, 0xFF, 0xA0, 0x00, 0x0E,
+0x47, 0x17, 0xB0, 0x1A, 0xA0, 0x02, 0xC0, 0x1A,
+0xA0, 0x0B, 0xD0, 0x03, 0x8B, 0x02, 0x00, 0x03,
+0x79, 0x02, 0x00, 0x49, 0xC1, 0x80, 0x00, 0x03,
+0x77, 0x02, 0x00, 0x49, 0x81, 0x80, 0x00, 0x03,
+0x7C, 0x12, 0x00, 0x49, 0xF1, 0xA0, 0x70, 0x03,
+0x81, 0x12, 0x70, 0x49, 0xD1, 0x83, 0x80, 0x19,
+0x70, 0x19, 0x20, 0x1A, 0x00, 0x80, 0x30, 0x1A,
+0xFF, 0x7F, 0xA0, 0x1A, 0x20, 0x07, 0x10, 0x19,
+0x00, 0x03, 0x58, 0x01, 0x9C, 0x01, 0x40, 0x1A,
+0x00, 0x80, 0x49, 0x38, 0x5B, 0x00, 0xB4, 0x09,
+0x54, 0x38, 0x5F, 0x51, 0x40, 0x80, 0x50, 0x31,
+0x57, 0x48, 0x0D, 0xB0, 0x75, 0x18, 0x58, 0x48,
+0x1D, 0x80, 0x85, 0x18, 0x50, 0x48, 0x1D, 0x80,
+0x11, 0x21, 0x5A, 0x01, 0x45, 0x38, 0x42, 0x48,
+0x1D, 0x80, 0x24, 0x18, 0x43, 0x48, 0x1B, 0x80,
+0x34, 0x18, 0xD1, 0x39, 0x31, 0x86, 0x07, 0x0D,
+0x47, 0x17, 0x08, 0x0D, 0xD9, 0x17, 0x08, 0x0D,
+0xE7, 0x00, 0x08, 0x0D, 0x94, 0x00, 0x01, 0x0D,
+0xDC, 0x17, 0x01, 0x0D, 0x5E, 0x01, 0x02, 0x0D,
+0xDA, 0x17, 0x02, 0x0D, 0xE8, 0x00, 0x03, 0x0D,
+0xDB, 0x17, 0x03, 0x0D, 0xE9, 0x00, 0xFF, 0xA0,
+0x70, 0x4A, 0x20, 0x00, 0x0B, 0x84, 0x60, 0x1A,
+0x20, 0x00, 0x56, 0x18, 0x67, 0x38, 0x80, 0x19,
+0xA0, 0x1A, 0x20, 0x07, 0x00, 0x0E, 0xDC, 0x17,
+0x00, 0x1A, 0x00, 0x80, 0x00, 0x0D, 0xDA, 0x17,
+0x00, 0x1A, 0xFF, 0x7F, 0x00, 0x0D, 0xDB, 0x17,
+0x0B, 0x00, 0x40, 0x1A, 0x00, 0x80, 0x40, 0x38,
+0x04, 0x0D, 0x10, 0xF9, 0x00, 0x0E, 0x11, 0xF9,
+0x07, 0x0D, 0x12, 0xF9, 0x00, 0x0E, 0x13, 0xF9,
+0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x03, 0x10, 0xF9,
+0x10, 0x03, 0x11, 0xF9, 0x00, 0x0D, 0x00, 0xF9,
+0x01, 0x0D, 0x01, 0xF9, 0x0C, 0x00, 0x00, 0x0D,
+0x10, 0xF9, 0x06, 0x0D, 0x12, 0xF9, 0x00, 0x0E,
+0x13, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x03,
+0x10, 0xF9, 0x10, 0x03, 0x11, 0xF9, 0x00, 0x0D,
+0x02, 0xF9, 0x01, 0x0D, 0x03, 0xF9, 0x00, 0x03,
+0x00, 0xF9, 0x10, 0x03, 0x01, 0xF9, 0x00, 0x0D,
+0x18, 0xF9, 0x01, 0x0D, 0x19, 0xF9, 0x05, 0x0D,
+0x1A, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x03,
+0x18, 0xF9, 0xFF, 0xFF, 0x10, 0x1A, 0x00, 0x80,
+0x10, 0x38, 0x2B, 0x00, 0xB1, 0x08, 0x21, 0x38,
+0x2F, 0x51, 0x60, 0x80, 0x20, 0x31, 0x20, 0x4E,
+0x47, 0x17, 0x0D, 0xB0, 0x02, 0x0D, 0x47, 0x17,
+0x28, 0x48, 0x1D, 0x80, 0x82, 0x18, 0x20, 0x4E,
+0x58, 0x01, 0x5D, 0x80, 0x00, 0x03, 0xDC, 0x17,
+0x01, 0x21, 0x00, 0x0D, 0xDC, 0x17, 0x0A, 0x01,
+0x10, 0x38, 0x10, 0x4E, 0xDA, 0x17, 0x2D, 0x80,
+0x01, 0x0D, 0xDA, 0x17, 0x10, 0x4E, 0xDB, 0x17,
+0x2B, 0x80, 0x01, 0x0D, 0xDB, 0x17, 0xB1, 0x21,
+0xC1, 0x21, 0xD1, 0x39, 0x01, 0x88, 0x40, 0x4B,
+0x08, 0x0D, 0x94, 0x00, 0x08, 0x0D, 0xD9, 0x17,
+0x08, 0x0D, 0xE7, 0x00, 0x00, 0x03, 0xDC, 0x17,
+0x00, 0x0D, 0x5E, 0x01, 0x00, 0x03, 0xDA, 0x17,
+0x00, 0x0D, 0xE8, 0x00, 0x00, 0x03, 0xDB, 0x17,
+0x00, 0x0D, 0xE9, 0x00, 0xFF, 0xA0, 0x40, 0x03,
+0xB0, 0x00, 0x30, 0x03, 0x7B, 0x12, 0x34, 0x20,
+0x00, 0x03, 0x7A, 0x12, 0x40, 0x20, 0xB0, 0x1A,
+0x34, 0x15, 0xAF, 0x19, 0x0B, 0x00, 0x03, 0x48,
+0x1C, 0x80, 0xB4, 0x08, 0xB1, 0x21, 0xA1, 0x39,
+0x91, 0x87, 0x40, 0x03, 0x26, 0x01, 0x30, 0x03,
+0x7B, 0x12, 0x34, 0x20, 0x00, 0x03, 0x7A, 0x12,
+0x40, 0x20, 0xB0, 0x1A, 0xD3, 0x12, 0xA8, 0x19,
+0x0B, 0x00, 0x03, 0x48, 0x1C, 0x80, 0xB4, 0x08,
+0xB1, 0x21, 0xA1, 0x39, 0x91, 0x87, 0xFF, 0xA0,
+0x40, 0x03, 0xB0, 0x00, 0x00, 0x03, 0x7B, 0x12,
+0x40, 0x20, 0xB0, 0x1A, 0x34, 0x15, 0xAF, 0x19,
+0x0B, 0x00, 0x04, 0x48, 0x1B, 0x80, 0x00, 0x19,
+0xB0, 0x09, 0xA1, 0x39, 0x91, 0x87, 0x40, 0x03,
+0x26, 0x01, 0x00, 0x03, 0x7B, 0x12, 0x40, 0x20,
+0xB0, 0x1A, 0xD3, 0x12, 0xA8, 0x19, 0x0B, 0x00,
+0x04, 0x48, 0x1B, 0x80, 0x00, 0x19, 0xB0, 0x09,
+0xA1, 0x39, 0x91, 0x87, 0xFF, 0xA0, 0x90, 0x19,
+0x00, 0x03, 0x77, 0x02, 0x00, 0x49, 0xF1, 0xA0,
+0xD0, 0x1A, 0xA0, 0x0B, 0x0F, 0x98, 0x10, 0x4C,
+0x76, 0x18, 0xD0, 0x1A, 0x20, 0x07, 0x0F, 0x98,
+0x10, 0x4C, 0x90, 0x19, 0x67, 0x38, 0x06, 0x0D,
+0x55, 0x01, 0xFD, 0xA0, 0x00, 0x03, 0x53, 0x01,
+0x60, 0x48, 0xFD, 0xA0, 0x91, 0x19, 0xFF, 0xA0,
+0xB0, 0x03, 0x0A, 0x16, 0xA0, 0x03, 0x09, 0x16,
+0xBA, 0x38, 0xB1, 0x21, 0x00, 0x03, 0xD6, 0x00,
+0x0F, 0x98, 0x59, 0x54, 0x00, 0x1E, 0xD0, 0x20,
+0xAD, 0x18, 0xC0, 0x03, 0x08, 0x16, 0x80, 0x03,
+0x07, 0x16, 0xC8, 0x38, 0xC3, 0x39, 0x0C, 0x0D,
+0x39, 0x13, 0x81, 0x21, 0x60, 0x19, 0xD8, 0x20,
+0x0D, 0x01, 0x1D, 0x01, 0x2D, 0x00, 0x31, 0x18,
+0x30, 0x38, 0x31, 0x20, 0x32, 0x38, 0x30, 0x49,
+0x0B, 0xB0, 0x30, 0x31, 0x36, 0x48, 0x0D, 0xB0,
+0x63, 0x18, 0x01, 0x18, 0x12, 0x18, 0xD1, 0x21,
+0xC1, 0x39, 0x01, 0x87, 0xD0, 0x03, 0xD6, 0x00,
+0xAD, 0x20, 0xDA, 0x18, 0xC0, 0x03, 0x39, 0x13,
+0xB1, 0x39, 0x51, 0x86, 0xFF, 0xA0, 0x90, 0x19,
+0x00, 0x03, 0x79, 0x02, 0x00, 0x49, 0xF1, 0xA0,
+0x00, 0x03, 0x77, 0x02, 0x00, 0x49, 0xF1, 0xA0,
+0x00, 0x03, 0x5A, 0x01, 0x00, 0x49, 0xF0, 0xA0,
+0x00, 0x03, 0xDC, 0x17, 0x10, 0x03, 0x59, 0x01,
+0x01, 0x48, 0xFC, 0xA0, 0x0F, 0x98, 0x9A, 0x4C,
+0xB0, 0x03, 0xD6, 0x00, 0x70, 0x03, 0x5A, 0x01,
+0x40, 0x03, 0x5B, 0x01, 0x64, 0x18, 0x40, 0x62,
+0xFF, 0x00, 0x68, 0x79, 0x50, 0x19, 0xC0, 0x19,
+0xA0, 0x03, 0xD5, 0x00, 0x20, 0x1A, 0x00, 0x80,
+0xD0, 0x1A, 0xA0, 0x0B, 0xDC, 0x20, 0x0D, 0x00,
+0x02, 0x48, 0x0C, 0xB0, 0x20, 0x18, 0xDB, 0x20,
+0xA1, 0x39, 0x91, 0x87, 0x00, 0x03, 0x5C, 0x01,
+0x20, 0x48, 0xEC, 0x81, 0x00, 0x03, 0x5D, 0x01,
+0x20, 0x48, 0x0D, 0xB0, 0x20, 0x18, 0xA0, 0x03,
+0xD5, 0x00, 0xD0, 0x1A, 0xA0, 0x0B, 0xDC, 0x20,
+0x30, 0x19, 0x0D, 0x00, 0x00, 0x49, 0xAB, 0x80,
+0x00, 0x31, 0x10, 0x1A, 0x64, 0x00, 0x0F, 0x98,
+0xA7, 0x54, 0x0F, 0x98, 0xFA, 0x54, 0x07, 0x48,
+0x0D, 0xB0, 0x31, 0x21, 0xDB, 0x20, 0xA1, 0x39,
+0x01, 0x87, 0x34, 0x48, 0x0C, 0xB0, 0x51, 0x21,
+0xC1, 0x21, 0xCB, 0x48, 0xDC, 0x84, 0x56, 0x48,
+0x0C, 0xB0, 0x91, 0x19, 0xB0, 0x1A, 0xA0, 0x0B,
+0xA0, 0x1A, 0x20, 0x07, 0xD0, 0x03, 0x8B, 0x02,
+0x40, 0x1A, 0x00, 0x80, 0x3B, 0x00, 0x5A, 0x01,
+0x43, 0x38, 0x45, 0x38, 0xB4, 0x09, 0xD1, 0x39,
+0x71, 0x87, 0xFF, 0xA0, 0x00, 0x03, 0x79, 0x02,
+0x00, 0x49, 0x01, 0x88, 0x6B, 0x4D, 0x00, 0x03,
+0x92, 0x01, 0x05, 0x51, 0x00, 0x88, 0x6B, 0x4D,
+0x00, 0x03, 0x77, 0x02, 0x00, 0x49, 0x01, 0x88,
+0x6B, 0x4D, 0x00, 0x0E, 0x7C, 0x12, 0x10, 0x03,
+0xAE, 0x00, 0x00, 0x03, 0x51, 0x17, 0x01, 0x48,
+0xFC, 0x80, 0x00, 0x03, 0x78, 0x01, 0x00, 0x4E,
+0xBD, 0x01, 0xAC, 0x80, 0x01, 0x0E, 0x38, 0x16,
+0x02, 0x0E, 0x7C, 0x01, 0x01, 0x0E, 0x7C, 0x12,
+0x01, 0x0E, 0xED, 0x17, 0x0F, 0x88, 0x12, 0x4D,
+0x00, 0x03, 0xED, 0x17, 0x01, 0x49, 0xD1, 0x80,
+0x00, 0x03, 0x51, 0x17, 0x00, 0x4E, 0x52, 0x17,
+0x4C, 0x81, 0x00, 0x03, 0x78, 0x01, 0x00, 0x4E,
+0xD3, 0x17, 0xFC, 0x80, 0x03, 0x0E, 0x7C, 0x01,
+0x1F, 0x83, 0x00, 0x03, 0x76, 0x01, 0x01, 0x49,
+0x8B, 0x80, 0x00, 0x03, 0x78, 0x01, 0x00, 0x4E,
+0xD3, 0x17, 0x3C, 0x80, 0x04, 0x0E, 0x7C, 0x01,
+0x5F, 0x82, 0x00, 0x03, 0x51, 0x17, 0x00, 0x4E,
+0x52, 0x17, 0x3C, 0x80, 0x07, 0x0E, 0x7C, 0x01,
+0xDF, 0x81, 0x00, 0x03, 0xED, 0x17, 0x01, 0x49,
+0xD1, 0x80, 0x00, 0x03, 0x77, 0x01, 0x01, 0x39,
+0x00, 0x49, 0x0B, 0xB0, 0x00, 0x19, 0x00, 0x0D,
+0x77, 0x01, 0x00, 0x49, 0x91, 0x80, 0x00, 0x0E,
+0xED, 0x17, 0xCF, 0x80, 0x00, 0x03, 0x51, 0x17,
+0x00, 0x4E, 0x71, 0x01, 0x0D, 0x88, 0x52, 0x4D,
+0x00, 0x03, 0x7D, 0x01, 0x00, 0x0D, 0x77, 0x01,
+0x0F, 0x88, 0x82, 0x47, 0x00, 0x03, 0x7D, 0x01,
+0x00, 0x0D, 0x77, 0x01, 0x00, 0x03, 0x86, 0x01,
+0x00, 0x0D, 0x81, 0x12, 0x00, 0x03, 0xED, 0x17,
+0x00, 0x49, 0xB0, 0x80, 0x00, 0x03, 0xBD, 0x01,
+0x00, 0x0D, 0xD3, 0x17, 0x00, 0x03, 0x73, 0x01,
+0x00, 0x0D, 0x52, 0x17, 0x02, 0x0E, 0x76, 0x01,
+0xAF, 0x80, 0x01, 0x0E, 0x76, 0x01, 0x00, 0x03,
+0x83, 0x01, 0x00, 0x0D, 0xD3, 0x17, 0x00, 0x03,
+0x81, 0x01, 0x00, 0x0D, 0x52, 0x17, 0x00, 0x03,
+0x87, 0x01, 0x00, 0x0D, 0x3C, 0x17, 0x00, 0x03,
+0x88, 0x01, 0x00, 0x0D, 0x3D, 0x17, 0x00, 0x03,
+0x89, 0x01, 0x00, 0x0D, 0xD5, 0x17, 0x00, 0x03,
+0x84, 0x01, 0x00, 0x0D, 0x79, 0x12, 0x10, 0x03,
+0x85, 0x01, 0x00, 0x03, 0x7A, 0x12, 0x01, 0x48,
+0x00, 0x88, 0x82, 0x47, 0x00, 0x0D, 0x7B, 0x12,
+0x01, 0x0D, 0x7A, 0x12, 0x0F, 0x98, 0xB3, 0x4B,
+0x0F, 0x88, 0x82, 0x47, 0x00, 0x03, 0x77, 0x01,
+0x01, 0x39, 0x00, 0x0D, 0x77, 0x01, 0x00, 0x49,
+0x0A, 0x88, 0x82, 0x47, 0x0F, 0x98, 0x76, 0x4D,
+0x00, 0x03, 0x7A, 0x12, 0x00, 0x49, 0x00, 0x88,
+0x82, 0x47, 0x00, 0x03, 0x7A, 0x12, 0x00, 0x0D,
+0x7B, 0x12, 0x0F, 0x98, 0xD8, 0x4B, 0x00, 0x0E,
+0x7A, 0x12, 0x0F, 0x88, 0x82, 0x47, 0x00, 0x03,
+0x02, 0x18, 0x00, 0x49, 0x01, 0x88, 0x82, 0x47,
+0x0F, 0x98, 0x76, 0x4D, 0x00, 0x0E, 0x7A, 0x12,
+0x0F, 0x88, 0x82, 0x47, 0x00, 0x0E, 0xED, 0x17,
+0x00, 0x03, 0xA5, 0x00, 0x00, 0x0D, 0x81, 0x12,
+0x00, 0x03, 0x7F, 0x01, 0x00, 0x0D, 0xD3, 0x17,
+0x00, 0x03, 0x80, 0x01, 0x00, 0x0D, 0x52, 0x17,
+0x00, 0x0E, 0x76, 0x01, 0x00, 0x0E, 0x79, 0x12,
+0x00, 0x0E, 0x77, 0x01, 0x00, 0x03, 0xA8, 0x00,
+0x00, 0x0D, 0x3C, 0x17, 0x00, 0x03, 0xAC, 0x00,
+0x00, 0x0D, 0x3D, 0x17, 0x00, 0x03, 0xB8, 0x00,
+0x00, 0x0D, 0xD5, 0x17, 0xFF, 0xA0, 0x00, 0x03,
+0x78, 0x12, 0x00, 0x49, 0xF0, 0xA0, 0x00, 0x03,
+0x72, 0x12, 0x00, 0x49, 0xF0, 0xA0, 0xB0, 0x1A,
+0x20, 0x10, 0xC0, 0x1A, 0xA0, 0x0B, 0xD0, 0x03,
+0x8B, 0x02, 0x00, 0x0E, 0x11, 0xF9, 0x0C, 0x00,
+0x10, 0x03, 0xEB, 0x00, 0x00, 0x0D, 0x10, 0xF9,
+0x01, 0x0D, 0x12, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF,
+0x00, 0x03, 0x10, 0xF9, 0x10, 0x03, 0x11, 0xF9,
+0x2B, 0x01, 0x00, 0x0D, 0x18, 0xF9, 0x01, 0x0D,
+0x19, 0xF9, 0x02, 0x0D, 0x1A, 0xF9, 0xFF, 0xFF,
+0xFF, 0xFF, 0x00, 0x03, 0x18, 0xF9, 0xC0, 0x09,
+0xD1, 0x39, 0x51, 0x86, 0xFF, 0xA0, 0x00, 0x03,
+0xD9, 0x17, 0x10, 0x03, 0x4E, 0x01, 0x01, 0x48,
+0xFB, 0xA0, 0x00, 0x03, 0x78, 0x12, 0x01, 0x49,
+0xF0, 0xA0, 0x00, 0x03, 0x8D, 0x00, 0x00, 0x51,
+0xF0, 0xA0, 0x00, 0x03, 0x08, 0x17, 0x00, 0x49,
+0xF1, 0xA0, 0x00, 0x03, 0x72, 0x12, 0x01, 0x49,
+0xB0, 0x80, 0x00, 0x03, 0x0E, 0x16, 0x00, 0x49,
+0xF1, 0xA0, 0x00, 0x03, 0x78, 0x12, 0x02, 0x49,
+0x71, 0x80, 0x01, 0x0E, 0x79, 0x02, 0x4F, 0x80,
+0x00, 0x03, 0x77, 0x02, 0x00, 0x49, 0xF0, 0xA0,
+0xB0, 0x1A, 0x20, 0x10, 0xC0, 0x1A, 0xA0, 0x0B,
+0xA0, 0x03, 0x8B, 0x02, 0x0C, 0x01, 0xB0, 0x09,
+0xA1, 0x39, 0xC1, 0x87, 0x01, 0x0E, 0x72, 0x12,
+0xFF, 0xA0, 0x00, 0x03, 0x77, 0x02, 0x00, 0x49,
+0x21, 0x83, 0x00, 0x03, 0x72, 0x12, 0x00, 0x49,
+0xE0, 0x82, 0x00, 0x03, 0xE7, 0x00, 0x10, 0x03,
+0x4E, 0x01, 0x01, 0x48, 0x8B, 0x82, 0xA0, 0x03,
+0x8B, 0x02, 0xB0, 0x1A, 0x20, 0x10, 0xC0, 0x1A,
+0xA0, 0x0B, 0x90, 0x19, 0x0B, 0x01, 0x1C, 0x01,
+0x01, 0x38, 0x0F, 0x51, 0x10, 0x80, 0x00, 0x31,
+0x09, 0x48, 0x1D, 0x80, 0x90, 0x18, 0xA1, 0x39,
+0x51, 0x87, 0x09, 0x0D, 0xBB, 0x01, 0x90, 0x4E,
+0x56, 0x01, 0x3D, 0x80, 0x01, 0x0E, 0x7B, 0x02,
+0xFF, 0xA0, 0x00, 0x03, 0x7A, 0x02, 0x01, 0x21,
+0x00, 0x0D, 0x7A, 0x02, 0x10, 0x03, 0x4D, 0x01,
+0x01, 0x48, 0xFD, 0xA0, 0x00, 0x0E, 0x7A, 0x02,
+0x01, 0x0E, 0x79, 0x02, 0xFF, 0xA0, 0x00, 0x0E,
+0x7A, 0x02, 0xFF, 0xA0, 0x00, 0x0E, 0xD9, 0x17,
+0x00, 0x0E, 0x7C, 0x12, 0x00, 0x0E, 0x79, 0x02,
+0x00, 0x0E, 0x51, 0x17, 0xB0, 0x1A, 0xA0, 0x0B,
+0x0B, 0x0D, 0x80, 0x02, 0x0F, 0x98, 0xC9, 0x48,
+0x00, 0x03, 0x7C, 0x12, 0x00, 0x49, 0xE0, 0x80,
+0x00, 0x03, 0x77, 0x02, 0x00, 0x49, 0xF1, 0xA0,
+0x01, 0x0E, 0x7C, 0x01, 0x00, 0x03, 0x78, 0x01,
+0x00, 0x4E, 0xAF, 0x00, 0x0A, 0x88, 0xC6, 0x4C,
+0x0F, 0x88, 0xBB, 0x4C, 0x00, 0x03, 0x01, 0x18,
+0x00, 0x0D, 0xBF, 0x01, 0x00, 0x03, 0xFD, 0x17,
+0x00, 0x0D, 0xBE, 0x01, 0xB0, 0x1A, 0xA0, 0x0B,
+0x0F, 0x98, 0x1F, 0x4A, 0x00, 0x1A, 0x00, 0x80,
+0x00, 0x0D, 0x0A, 0x17, 0xC0, 0x1A, 0xA0, 0x0B,
+0x0F, 0x98, 0xB9, 0x47, 0x0F, 0x98, 0xAA, 0x4C,
+0x00, 0x03, 0x7C, 0x12, 0x00, 0x49, 0xF1, 0xA0,
+0x0F, 0x98, 0xC3, 0x4D, 0x00, 0x0E, 0x7B, 0x02,
+0x00, 0x03, 0x8C, 0x00, 0x0F, 0x51, 0x20, 0x80,
+0x0F, 0x98, 0xF5, 0x4D, 0xC0, 0x1A, 0xA0, 0x0B,
+0x0F, 0x98, 0x97, 0x4D, 0x0F, 0x98, 0x58, 0x4A,
+0x00, 0x03, 0x7C, 0x12, 0x00, 0x49, 0xF1, 0xA0,
+0x0F, 0x98, 0xD7, 0x4A, 0x00, 0x03, 0x7B, 0x02,
+0x00, 0x49, 0x10, 0x81, 0x00, 0x03, 0xBB, 0x01,
+0x00, 0x4E, 0xBA, 0x01, 0xCB, 0x80, 0x10, 0x03,
+0xB9, 0x01, 0x0F, 0x98, 0x95, 0x64, 0x00, 0x4E,
+0xE8, 0x00, 0x3D, 0x80, 0x0F, 0x98, 0x2B, 0x4E,
+0x2F, 0x80, 0x0F, 0x98, 0x1D, 0x4E, 0x00, 0x03,
+0x77, 0x02, 0x00, 0x49, 0x81, 0x81, 0x70, 0x03,
+0xE7, 0x00, 0x80, 0x03, 0xE8, 0x00, 0x90, 0x03,
+0xE9, 0x00, 0x70, 0x4E, 0x7A, 0x01, 0x6A, 0x80,
+0x80, 0x4E, 0x72, 0x01, 0x3A, 0x80, 0x90, 0x4E,
+0x7E, 0x01, 0x9A, 0x80, 0x01, 0x0E, 0x7C, 0x12,
+0x00, 0x03, 0x82, 0x01, 0x70, 0x48, 0xFA, 0xA0,
+0x01, 0x0E, 0x79, 0x02, 0xFF, 0xA0, 0x00, 0x03,
+0x92, 0x01, 0x0D, 0x51, 0xE0, 0x80, 0x00, 0x03,
+0x38, 0x16, 0x00, 0x49, 0xA0, 0x80, 0x0F, 0x98,
+0x43, 0x4C, 0x90, 0x49, 0x60, 0x80, 0x03, 0x0E,
+0x7C, 0x01, 0x01, 0x0E, 0x7C, 0x12, 0x0F, 0x88,
+0x12, 0x4D, 0x00, 0x03, 0x76, 0x01, 0x00, 0x49,
+0x30, 0x80, 0x01, 0x0E, 0x49, 0x17, 0xFF, 0xA0,
+0x00, 0x03, 0xED, 0x17, 0x00, 0x49, 0x01, 0x88,
+0x18, 0x4F, 0x00, 0x03, 0x77, 0x02, 0x00, 0x49,
+0x01, 0x88, 0x18, 0x4F, 0x00, 0x03, 0x8C, 0x00,
+0x08, 0x51, 0x00, 0x88, 0x18, 0x4F, 0x70, 0x03,
+0xD9, 0x17, 0x80, 0x03, 0xDA, 0x17, 0x90, 0x03,
+0xDB, 0x17, 0x80, 0x4E, 0x95, 0x00, 0x8C, 0x83,
+0x09, 0x18, 0x00, 0x49, 0x0B, 0xB0, 0x00, 0x31,
+0x10, 0x1A, 0x64, 0x00, 0x0F, 0x98, 0xA7, 0x54,
+0x28, 0x18, 0x0F, 0x98, 0xFA, 0x54, 0x80, 0x03,
+0xDA, 0x17, 0x10, 0x03, 0x4F, 0x01, 0x81, 0x48,
+0x6B, 0x80, 0x10, 0x03, 0x50, 0x01, 0xA0, 0x1A,
+0x7C, 0x02, 0xB1, 0x19, 0x5F, 0x80, 0x10, 0x03,
+0x51, 0x01, 0xA0, 0x1A, 0x7D, 0x02, 0xB2, 0x19,
+0x10, 0x49, 0x90, 0x81, 0x01, 0x48, 0x7C, 0x81,
+0x10, 0x03, 0x4E, 0x01, 0x71, 0x48, 0x3A, 0x81,
+0x0A, 0x00, 0x10, 0x03, 0x4D, 0x01, 0x01, 0x48,
+0x0B, 0xB0, 0x01, 0x21, 0xA0, 0x08, 0x01, 0x48,
+0xBC, 0x80, 0x00, 0x03, 0x92, 0x01, 0x0C, 0x51,
+0x20, 0x80, 0xB2, 0x49, 0x10, 0x81, 0x01, 0x0E,
+0x79, 0x02, 0xA0, 0x0B, 0xFF, 0xA0, 0xA0, 0x0B,
+0x00, 0x03, 0x92, 0x01, 0x0C, 0x51, 0xA0, 0x82,
+0x00, 0x0E, 0x55, 0x01, 0x80, 0x03, 0xDA, 0x17,
+0x10, 0x03, 0x54, 0x01, 0x81, 0x48, 0x0C, 0x82,
+0x10, 0x03, 0x52, 0x01, 0x70, 0x03, 0xD9, 0x17,
+0x71, 0x48, 0xAA, 0x81, 0x00, 0x03, 0x3B, 0x13,
+0x00, 0x49, 0x61, 0x81, 0x0F, 0x98, 0xF7, 0x4B,
+0x90, 0x49, 0x20, 0x81, 0x00, 0x03, 0x7E, 0x02,
+0x01, 0x21, 0x00, 0x0D, 0x7E, 0x02, 0x10, 0x03,
+0x4D, 0x01, 0x01, 0x48, 0xBC, 0x80, 0x01, 0x0E,
+0x79, 0x02, 0x00, 0x0E, 0x7D, 0x02, 0x00, 0x0E,
+0x7C, 0x02, 0x00, 0x0E, 0x7E, 0x02, 0xFF, 0xA0,
+0x00, 0x0E, 0x7E, 0x02, 0x00, 0x03, 0x92, 0x01,
+0x08, 0x51, 0x31, 0x80, 0x01, 0x0E, 0x49, 0x17,
+0xFF, 0xA0, 0x20, 0x03, 0x9E, 0x00, 0x10, 0x03,
+0x81, 0x12, 0x10, 0x49, 0xA0, 0x81, 0x60, 0x1A,
+0x20, 0x00, 0x01, 0x0D, 0x10, 0xF9, 0x00, 0x0E,
+0x11, 0xF9, 0x02, 0x0D, 0x12, 0xF9, 0x00, 0x0E,
+0x13, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x03,
+0x10, 0xF9, 0x10, 0x03, 0x11, 0xF9, 0x00, 0x0D,
+0x18, 0xF9, 0x01, 0x0D, 0x19, 0xF9, 0x06, 0x0D,
+0x1A, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0x20, 0x03,
+0x18, 0xF9, 0x00, 0x03, 0x47, 0x17, 0x02, 0x48,
+0x5C, 0x80, 0x00, 0x03, 0x77, 0x12, 0x00, 0x0D,
+0x49, 0x17, 0xFF, 0xA0, 0x00, 0x03, 0x49, 0x17,
+0x01, 0x39, 0x00, 0x49, 0x0B, 0xB0, 0x00, 0x19,
+0x00, 0x0D, 0x49, 0x17, 0xFF, 0xA0, 0x00, 0x03,
+0x95, 0x00, 0x10, 0x03, 0x79, 0x12, 0x01, 0x20,
+0x00, 0x0D, 0x8E, 0x12, 0x00, 0x03, 0x27, 0x01,
+0x01, 0x20, 0x00, 0x0D, 0x07, 0x17, 0x00, 0x03,
+0xB0, 0x00, 0x10, 0x03, 0x7A, 0x12, 0x01, 0x20,
+0x00, 0x0D, 0x77, 0x12, 0x00, 0x03, 0x26, 0x01,
+0x01, 0x20, 0x00, 0x0D, 0xDB, 0x12, 0x10, 0x03,
+0x79, 0x12, 0x00, 0x03, 0x96, 0x00, 0x01, 0x20,
+0x00, 0x0D, 0x43, 0x17, 0x00, 0x03, 0x97, 0x00,
+0x01, 0x20, 0x00, 0x0D, 0x44, 0x17, 0x00, 0x03,
+0x98, 0x00, 0x01, 0x20, 0x00, 0x0D, 0x45, 0x17,
+0x00, 0x03, 0x99, 0x00, 0x01, 0x20, 0x00, 0x0D,
+0x46, 0x17, 0xFF, 0xA0, 0x10, 0x03, 0xB2, 0x00,
+0x10, 0x49, 0xF0, 0xA0, 0x00, 0x03, 0x43, 0x17,
+0x10, 0x03, 0xB2, 0x00, 0x0F, 0x98, 0x95, 0x64,
+0x00, 0x0D, 0x43, 0x17, 0x00, 0x03, 0x44, 0x17,
+0x10, 0x03, 0xB2, 0x00, 0x0F, 0x98, 0x95, 0x64,
+0x00, 0x0D, 0x44, 0x17, 0x00, 0x03, 0x45, 0x17,
+0x10, 0x03, 0xB2, 0x00, 0x0F, 0x98, 0x95, 0x64,
+0x00, 0x0D, 0x45, 0x17, 0x00, 0x03, 0x46, 0x17,
+0x10, 0x03, 0xB2, 0x00, 0x0F, 0x98, 0x95, 0x64,
+0x00, 0x0D, 0x46, 0x17, 0xFF, 0xA0, 0x00, 0x0E,
+0x07, 0x16, 0x00, 0x0E, 0x09, 0x16, 0x80, 0x03,
+0xD5, 0x00, 0x81, 0x39, 0x08, 0x0D, 0x0A, 0x16,
+0x90, 0x03, 0xD6, 0x00, 0x91, 0x39, 0x09, 0x0D,
+0x08, 0x16, 0xFF, 0xA0, 0xFF, 0x81, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0x0F, 0x88, 0x0A, 0x40, 0x00, 0x03, 0x93, 0x01,
+0x03, 0x51, 0xF0, 0xA0, 0x50, 0x19, 0xA0, 0x1A,
+0xA0, 0x0B, 0xA5, 0x20, 0x75, 0x18, 0x00, 0x19,
+0x90, 0x19, 0xCA, 0x01, 0x0C, 0x20, 0x51, 0x21,
+0x91, 0x21, 0x90, 0x4E, 0xD6, 0x00, 0x91, 0x87,
+0x00, 0x49, 0x2A, 0x80, 0x00, 0x19, 0x4F, 0x80,
+0x20, 0x03, 0xD6, 0x00, 0x0F, 0x98, 0xE7, 0x54,
+0x90, 0x19, 0xA0, 0x1A, 0xE0, 0x04, 0xD0, 0x1A,
+0xA0, 0x0B, 0xA7, 0x20, 0xD7, 0x20, 0xCD, 0x00,
+0xC0, 0x38, 0xC0, 0x49, 0x0B, 0xB0, 0xC0, 0x19,
+0xAC, 0x09, 0xDC, 0x09, 0x91, 0x21, 0x90, 0x4E,
+0xD6, 0x00, 0x51, 0x87, 0xB0, 0x03, 0x8B, 0x02,
+0xB5, 0x48, 0x51, 0x85, 0xFF, 0xA0, 0x0F, 0x98,
+0xD3, 0x4F, 0x10, 0x03, 0x29, 0x01, 0x20, 0x03,
+0x28, 0x01, 0x20, 0x49, 0x91, 0x80, 0x10, 0x49,
+0x31, 0x80, 0x01, 0x0E, 0x09, 0x16, 0xFF, 0xA0,
+0x81, 0x39, 0x08, 0x0D, 0x0A, 0x16, 0xFF, 0xA0,
+0x10, 0x49, 0x31, 0x80, 0x01, 0x0E, 0x07, 0x16,
+0xFF, 0xA0, 0x91, 0x39, 0x09, 0x0D, 0x08, 0x16,
+0xFF, 0xA0, 0x00, 0x03, 0x65, 0x01, 0x0F, 0x51,
+0x21, 0x86, 0x0F, 0x88, 0xD3, 0x4F, 0x60, 0x1A,
+0x57, 0x17, 0xA0, 0x03, 0xD6, 0x00, 0x60, 0x0B,
+0x61, 0x21, 0xA1, 0x39, 0xC1, 0x87, 0xFF, 0xA0,
+0x00, 0x03, 0x8C, 0x00, 0x02, 0x51, 0x30, 0x87,
+0xC0, 0x19, 0x80, 0x03, 0xD5, 0x00, 0x90, 0x03,
+0xD6, 0x00, 0xB0, 0x1A, 0xA0, 0x02, 0x60, 0x1A,
+0x57, 0x17, 0xAC, 0x18, 0x00, 0x19, 0x10, 0x19,
+0x4B, 0x18, 0x4A, 0x20, 0x24, 0x00, 0x20, 0x49,
+0x5B, 0x80, 0x20, 0x31, 0x20, 0x48, 0x5D, 0x80,
+0x02, 0x18, 0x3F, 0x80, 0x21, 0x48, 0x1D, 0x80,
+0x12, 0x18, 0xA9, 0x20, 0xA0, 0x4E, 0x8B, 0x02,
+0xFC, 0x86, 0x70, 0x18, 0x51, 0x18, 0x01, 0x18,
+0x10, 0x03, 0xC6, 0x00, 0x10, 0x49, 0x50, 0x80,
+0x0F, 0x98, 0x95, 0x64, 0x70, 0x48, 0x0D, 0xB0,
+0x70, 0x18, 0x05, 0x18, 0x07, 0x38, 0x10, 0x03,
+0x92, 0x01, 0x1B, 0x51, 0x70, 0x80, 0x10, 0x03,
+0x67, 0x01, 0x10, 0x49, 0x30, 0x80, 0x0F, 0x98,
+0x95, 0x64, 0x70, 0x20, 0x67, 0x09, 0xC1, 0x21,
+0xC9, 0x48, 0xFC, 0x84, 0xFF, 0xA0, 0x80, 0x19,
+0xB0, 0x1A, 0xA0, 0x0B, 0xB3, 0x20, 0xA0, 0x03,
+0xD5, 0x00, 0x90, 0x03, 0xD6, 0x00, 0x50, 0x03,
+0x88, 0x12, 0x0B, 0x00, 0x05, 0x48, 0x0C, 0xB0,
+0x81, 0x19, 0xB9, 0x20, 0xA1, 0x39, 0x91, 0x87,
+0xFF, 0xA0, 0x80, 0x19, 0xA0, 0x03, 0xD6, 0x00,
+0x3A, 0x58, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0x30, 0x1E, 0xB0, 0x1A, 0xA0, 0x0B, 0xB3, 0x20,
+0x50, 0x03, 0x88, 0x12, 0x0B, 0x01, 0x05, 0x48,
+0x0C, 0xB0, 0x81, 0x19, 0xA1, 0x39, 0xA1, 0x87,
+0xFF, 0xA0, 0x30, 0x03, 0x07, 0x16, 0x0F, 0x98,
+0x9B, 0x50, 0x80, 0x49, 0x21, 0x80, 0x00, 0x0E,
+0x4A, 0x17, 0x30, 0x03, 0x08, 0x16, 0x0F, 0x98,
+0x9B, 0x50, 0x80, 0x49, 0x21, 0x80, 0x00, 0x0E,
+0x4C, 0x17, 0x30, 0x03, 0x09, 0x16, 0x0F, 0x98,
+0xAD, 0x50, 0x80, 0x49, 0x21, 0x80, 0x00, 0x0E,
+0x4B, 0x17, 0x30, 0x03, 0x0A, 0x16, 0x0F, 0x98,
+0xAD, 0x50, 0x80, 0x49, 0xF1, 0xA0, 0x00, 0x0E,
+0x4D, 0x17, 0xFF, 0xA0, 0x00, 0x03, 0x92, 0x01,
+0x07, 0x51, 0xF0, 0xA0, 0x10, 0x03, 0x4C, 0x17,
+0x00, 0x03, 0x44, 0x17, 0x01, 0x48, 0x0B, 0xB0,
+0x01, 0x0D, 0x44, 0x17, 0x10, 0x03, 0x4A, 0x17,
+0x00, 0x03, 0x43, 0x17, 0x01, 0x48, 0x0B, 0xB0,
+0x01, 0x0D, 0x43, 0x17, 0x10, 0x03, 0x4D, 0x17,
+0x00, 0x03, 0x46, 0x17, 0x01, 0x48, 0x0B, 0xB0,
+0x01, 0x0D, 0x46, 0x17, 0x10, 0x03, 0x4B, 0x17,
+0x00, 0x03, 0x45, 0x17, 0x01, 0x48, 0x0B, 0xB0,
+0x01, 0x0D, 0x45, 0x17, 0xFF, 0xA0, 0x00, 0x0E,
+0x9B, 0x02, 0x00, 0x0E, 0x3B, 0x13, 0x00, 0x0E,
+0x3C, 0x13, 0x00, 0x0E, 0xAD, 0x13, 0x00, 0x0E,
+0xAE, 0x13, 0x00, 0x0E, 0x08, 0x18, 0x00, 0x03,
+0x77, 0x02, 0x00, 0x49, 0x90, 0x80, 0x00, 0x03,
+0x78, 0x02, 0x00, 0x49, 0x50, 0x80, 0x00, 0x03,
+0x51, 0x17, 0x00, 0x4E, 0x71, 0x01, 0xFB, 0xA0,
+0x00, 0x03, 0x77, 0x02, 0x00, 0x49, 0x21, 0x80,
+0x01, 0x0E, 0x78, 0x02, 0x00, 0x03, 0x79, 0x02,
+0x00, 0x49, 0xE0, 0x80, 0x00, 0x03, 0x8C, 0x00,
+0x00, 0x51, 0xF1, 0xA0, 0x00, 0x03, 0x77, 0x02,
+0x01, 0x39, 0x00, 0x49, 0x0B, 0xB0, 0x00, 0x19,
+0x00, 0x0D, 0x77, 0x02, 0x0F, 0x88, 0xBF, 0x55,
+0x00, 0x03, 0x7C, 0x12, 0x00, 0x49, 0x60, 0x80,
+0x00, 0x03, 0x7D, 0x12, 0x01, 0x21, 0x00, 0x0D,
+0x7D, 0x12, 0xFF, 0xA0, 0x00, 0x0E, 0x7C, 0x01,
+0x00, 0x03, 0x0B, 0x16, 0x00, 0x49, 0x40, 0x80,
+0x01, 0x39, 0x00, 0x0D, 0x0B, 0x16, 0xFF, 0xA0,
+0x00, 0x0E, 0xFD, 0x16, 0x00, 0x0E, 0xFB, 0x16,
+0x0F, 0x98, 0x4D, 0x50, 0x0F, 0x98, 0x80, 0x55,
+0x90, 0x49, 0x00, 0x88, 0x2B, 0x55, 0xA0, 0x03,
+0xD9, 0x17, 0xB0, 0x03, 0x9E, 0x00, 0xAB, 0x48,
+0x2C, 0x80, 0x00, 0x0E, 0x84, 0x12, 0x0F, 0x98,
+0xED, 0x53, 0x0F, 0x98, 0x7F, 0x4F, 0x0F, 0x98,
+0x5C, 0x50, 0xB0, 0x1A, 0xE0, 0x04, 0xC0, 0x1A,
+0xA0, 0x0B, 0xD0, 0x1A, 0x60, 0x09, 0xA0, 0x03,
+0x8B, 0x02, 0x70, 0x1A, 0x57, 0x17, 0x60, 0x1A,
+0x00, 0x80, 0x80, 0x19, 0x90, 0x03, 0xD6, 0x00,
+0x20, 0x19, 0x30, 0x19, 0xD0, 0x0B, 0x0B, 0x01,
+0x17, 0x01, 0x01, 0x38, 0x00, 0x49, 0x0D, 0xB0,
+0x21, 0x21, 0x00, 0x49, 0x0B, 0xB0, 0x31, 0x21,
+0x00, 0x49, 0x0B, 0xB0, 0x00, 0x19, 0x06, 0x48,
+0x0D, 0xB0, 0x60, 0x18, 0xC0, 0x09, 0x81, 0x21,
+0x89, 0x48, 0x31, 0x80, 0x80, 0x19, 0x70, 0x1A,
+0x57, 0x17, 0xD1, 0x21, 0xA1, 0x39, 0x61, 0x86,
+0x06, 0x0D, 0x76, 0x16, 0x02, 0x0D, 0xEB, 0x17,
+0x03, 0x0D, 0xEC, 0x17, 0x0F, 0x98, 0x02, 0x50,
+0x30, 0x19, 0xA0, 0x1A, 0xE2, 0x01, 0xD0, 0x1A,
+0xA0, 0x0B, 0xD0, 0x22, 0x0A, 0x02, 0xD2, 0x21,
+0xC0, 0x1A, 0xE0, 0x04, 0xC0, 0x22, 0x0A, 0x02,
+0xC2, 0x21, 0x0C, 0x00, 0xC2, 0x21, 0x30, 0x48,
+0x0B, 0xB0, 0x30, 0x18, 0x0D, 0x00, 0xD2, 0x21,
+0x00, 0x49, 0x0B, 0xB0, 0x00, 0x19, 0xA0, 0x09,
+0x0C, 0x00, 0xC9, 0x21, 0x30, 0x48, 0x0B, 0xB0,
+0x30, 0x18, 0x0D, 0x00, 0xD9, 0x21, 0x00, 0x49,
+0x0B, 0xB0, 0x00, 0x19, 0xA0, 0x09, 0x0C, 0x00,
+0xC2, 0x21, 0x30, 0x48, 0x0B, 0xB0, 0x30, 0x18,
+0x0D, 0x00, 0xD2, 0x21, 0x00, 0x49, 0x0B, 0xB0,
+0x00, 0x19, 0xA0, 0x09, 0x0C, 0x00, 0x30, 0x48,
+0x0B, 0xB0, 0x30, 0x18, 0x0D, 0x00, 0x00, 0x49,
+0x0B, 0xB0, 0x00, 0x19, 0xA0, 0x08, 0x03, 0x0D,
+0x09, 0x18, 0x00, 0x03, 0x27, 0x01, 0x30, 0x48,
+0x1C, 0x82, 0x00, 0x03, 0x09, 0x18, 0x01, 0x79,
+0x30, 0x18, 0x50, 0x19, 0xC0, 0x1A, 0xE0, 0x04,
+0xC0, 0x22, 0x0A, 0x02, 0xC2, 0x21, 0x0C, 0x00,
+0x30, 0x48, 0x0A, 0xB0, 0x51, 0x21, 0xC2, 0x21,
+0x0C, 0x00, 0x30, 0x48, 0x0A, 0xB0, 0x51, 0x21,
+0xC9, 0x21, 0x0C, 0x00, 0x30, 0x48, 0x0A, 0xB0,
+0x51, 0x21, 0xC2, 0x21, 0x0C, 0x00, 0x30, 0x48,
+0x0A, 0xB0, 0x51, 0x21, 0x52, 0x49, 0x2C, 0x80,
+0x01, 0x0E, 0x08, 0x18, 0x0F, 0x98, 0xC1, 0x50,
+0x0F, 0x98, 0x5A, 0x56, 0x90, 0x49, 0x90, 0x82,
+0x00, 0x03, 0xFE, 0x16, 0x00, 0x49, 0x51, 0x82,
+0x00, 0x0E, 0x1C, 0x16, 0x0F, 0x98, 0x46, 0x54,
+0x00, 0x03, 0x3B, 0x13, 0x00, 0x49, 0xF1, 0xA0,
+0x00, 0x03, 0xFB, 0x16, 0x00, 0x49, 0x60, 0x80,
+0x01, 0x0E, 0x01, 0x17, 0x0F, 0x98, 0x2B, 0x55,
+0x0F, 0x88, 0x80, 0x55, 0x00, 0x03, 0x00, 0x17,
+0x00, 0x49, 0x41, 0x80, 0x0F, 0x98, 0x2B, 0x55,
+0x0F, 0x88, 0xDA, 0x55, 0x00, 0x03, 0xB6, 0x00,
+0x00, 0x0D, 0x0B, 0x16, 0x0F, 0x98, 0x2B, 0x55,
+0x0F, 0x98, 0x80, 0x55, 0x00, 0x0E, 0x00, 0x17,
+0xFF, 0xA0, 0x00, 0x0E, 0x77, 0x16, 0x0F, 0x98,
+0x15, 0x54, 0x00, 0x0E, 0x89, 0x12, 0xD0, 0x03,
+0x77, 0x16, 0xC0, 0x03, 0xC5, 0x12, 0xDC, 0x48,
+0x2D, 0x80, 0x0D, 0x0D, 0xC5, 0x12, 0xA0, 0x03,
+0x0E, 0x16, 0xA0, 0x49, 0x51, 0x80, 0x00, 0x03,
+0x49, 0x17, 0x00, 0x49, 0x50, 0x84, 0xFF, 0x80,
+0x00, 0x03, 0x8E, 0x12, 0x10, 0x03, 0xB2, 0x00,
+0x10, 0x49, 0x31, 0x80, 0x00, 0x0D, 0x88, 0x12,
+0x6F, 0x80, 0x0F, 0x98, 0x95, 0x64, 0x00, 0x0D,
+0x88, 0x12, 0x0F, 0x98, 0xAE, 0x4F, 0x10, 0x03,
+0x88, 0x12, 0x01, 0x0D, 0x8A, 0x12, 0x00, 0x0E,
+0x85, 0x12, 0x00, 0x03, 0x8A, 0x12, 0x00, 0x0D,
+0x8C, 0x12, 0x00, 0x0D, 0x92, 0x00, 0x00, 0x0E,
+0x02, 0x17, 0x00, 0x0E, 0xFC, 0x16, 0x00, 0x0E,
+0x03, 0x17, 0x00, 0x0E, 0x04, 0x17, 0x00, 0x03,
+0x8A, 0x12, 0x10, 0x03, 0x99, 0x02, 0x10, 0x48,
+0x2B, 0x80, 0x00, 0x0E, 0x48, 0x17, 0x00, 0x03,
+0x8A, 0x12, 0x10, 0x03, 0x77, 0x16, 0x10, 0x48,
+0x6B, 0x80, 0x0F, 0x98, 0x9D, 0x64, 0x00, 0x0E,
+0x85, 0x12, 0x0F, 0x88, 0x3D, 0x53, 0x00, 0x03,
+0x8A, 0x12, 0x10, 0x03, 0x48, 0x17, 0x01, 0x48,
+0x2B, 0x80, 0x01, 0x0D, 0x8A, 0x12, 0x0F, 0x98,
+0xFB, 0x5D, 0x0F, 0x98, 0xE2, 0x50, 0x0F, 0x98,
+0x20, 0x59, 0x00, 0x03, 0x85, 0x12, 0x00, 0x49,
+0x00, 0x88, 0xEF, 0x52, 0x00, 0x03, 0x38, 0x16,
+0x00, 0x49, 0x40, 0x80, 0x00, 0x0E, 0xFE, 0x16,
+0x0F, 0x88, 0xD9, 0x52, 0x0F, 0x98, 0xB4, 0x63,
+0x0F, 0x98, 0x1A, 0x64, 0x00, 0x0E, 0x89, 0x12,
+0x00, 0x03, 0x76, 0x16, 0x10, 0x03, 0xD5, 0x17,
+0x10, 0x49, 0x40, 0x80, 0x0F, 0x98, 0x95, 0x64,
+0x00, 0x0D, 0x89, 0x12, 0xA0, 0x03, 0x8C, 0x00,
+0xAE, 0x51, 0x81, 0x80, 0x00, 0x03, 0x89, 0x12,
+0x10, 0x03, 0x8A, 0x12, 0x01, 0x48, 0x2D, 0x80,
+0x00, 0x0D, 0x8A, 0x12, 0x00, 0x03, 0x8C, 0x12,
+0x01, 0x48, 0x2D, 0x80, 0x00, 0x0D, 0x8A, 0x12,
+0x00, 0x03, 0x85, 0x12, 0x00, 0x49, 0xB0, 0x83,
+0x0F, 0x98, 0x75, 0x64, 0x00, 0x03, 0x85, 0x12,
+0x00, 0x49, 0x50, 0x83, 0x00, 0x03, 0xFE, 0x16,
+0x00, 0x49, 0xB0, 0x81, 0xA0, 0x03, 0xD9, 0x17,
+0xB0, 0x03, 0x9D, 0x00, 0xAB, 0x48, 0x3B, 0x81,
+0x00, 0x03, 0x1D, 0x16, 0x01, 0x21, 0x00, 0x0D,
+0x1D, 0x16, 0xB0, 0x03, 0xC3, 0x00, 0xB0, 0x49,
+0xC0, 0x80, 0x0B, 0x48, 0xAC, 0x80, 0x00, 0x0E,
+0x1D, 0x16, 0x0F, 0x98, 0x46, 0x54, 0x0F, 0x98,
+0x2B, 0x55, 0x0F, 0x88, 0xBF, 0x55, 0x00, 0x0E,
+0x1D, 0x16, 0x00, 0x03, 0x85, 0x12, 0x00, 0x49,
+0x01, 0x81, 0x00, 0x03, 0x92, 0x01, 0x09, 0x51,
+0xC0, 0x80, 0x00, 0x03, 0xB7, 0x00, 0x10, 0x03,
+0x77, 0x16, 0x10, 0x48, 0x6B, 0x80, 0x00, 0x03,
+0x77, 0x16, 0x01, 0x7B, 0x00, 0x0D, 0x48, 0x17,
+0x2F, 0x80, 0x00, 0x0E, 0x48, 0x17, 0x00, 0x03,
+0xFB, 0x16, 0x00, 0x49, 0xC1, 0x80, 0x00, 0x03,
+0x01, 0x17, 0x00, 0x49, 0x80, 0x80, 0x00, 0x0E,
+0x01, 0x17, 0x00, 0x03, 0xB6, 0x00, 0x00, 0x0D,
+0x0B, 0x16, 0x0F, 0x88, 0x00, 0x52, 0x00, 0x03,
+0xFE, 0x16, 0x00, 0x51, 0xA0, 0x80, 0x01, 0x61,
+0x00, 0x0D, 0xFE, 0x16, 0x00, 0x03, 0x65, 0x01,
+0x04, 0x51, 0x01, 0x88, 0x87, 0x53, 0x0F, 0x88,
+0x00, 0x52, 0x01, 0x51, 0x80, 0x81, 0x10, 0x03,
+0x65, 0x01, 0x14, 0x51, 0xF0, 0x80, 0x02, 0x51,
+0x50, 0x80, 0x01, 0x19, 0x00, 0x0D, 0xFE, 0x16,
+0x0F, 0x88, 0x87, 0x53, 0x0F, 0x98, 0x46, 0x54,
+0x0F, 0x98, 0x2B, 0x55, 0x01, 0x19, 0x00, 0x0D,
+0xFE, 0x16, 0xFF, 0xA0, 0x03, 0x19, 0x00, 0x0D,
+0xFE, 0x16, 0x0F, 0x88, 0x00, 0x52, 0x02, 0x51,
+0x01, 0x88, 0x87, 0x53, 0x03, 0x51, 0x10, 0x81,
+0x10, 0x03, 0x65, 0x01, 0x14, 0x51, 0x80, 0x80,
+0x0F, 0x98, 0x46, 0x54, 0x0F, 0x98, 0x2B, 0x55,
+0x04, 0x19, 0x00, 0x0D, 0xFE, 0x16, 0xFF, 0xA0,
+0x04, 0x19, 0x00, 0x0D, 0xFE, 0x16, 0x0F, 0x88,
+0x87, 0x53, 0x00, 0x03, 0x76, 0x12, 0x00, 0x49,
+0x50, 0x80, 0x00, 0x03, 0x75, 0x12, 0x00, 0x49,
+0x00, 0x88, 0x87, 0x53, 0x00, 0x03, 0xFE, 0x16,
+0x00, 0x49, 0xD1, 0x83, 0x10, 0x03, 0x65, 0x01,
+0x1F, 0x51, 0x31, 0x80, 0x00, 0x0E, 0x75, 0x12,
+0x6F, 0x83, 0x00, 0x03, 0x07, 0x17, 0x10, 0x03,
+0x8A, 0x12, 0x01, 0x48, 0x1B, 0x80, 0x01, 0x18,
+0x10, 0x03, 0x8C, 0x12, 0x01, 0x48, 0x1B, 0x80,
+0x01, 0x18, 0x10, 0x03, 0x8D, 0x12, 0x01, 0x48,
+0x1B, 0x80, 0x01, 0x18, 0x00, 0x0D, 0x8B, 0x12,
+0x00, 0x03, 0x77, 0x16, 0x10, 0x03, 0x34, 0x01,
+0x10, 0x49, 0x80, 0x80, 0x0F, 0x98, 0x95, 0x64,
+0x10, 0x03, 0x8B, 0x12, 0x01, 0x48, 0x2D, 0x80,
+0x00, 0x0D, 0x8B, 0x12, 0xA0, 0x03, 0x8C, 0x00,
+0xAE, 0x51, 0x40, 0x80, 0x00, 0x03, 0x07, 0x17,
+0x00, 0x0D, 0x8B, 0x12, 0x0F, 0x98, 0x52, 0x5A,
+0x00, 0x03, 0x08, 0x18, 0x00, 0x49, 0x70, 0x80,
+0x00, 0x03, 0x3B, 0x13, 0x00, 0x49, 0x30, 0x80,
+0x01, 0x0E, 0x0E, 0x16, 0xDF, 0x81, 0x00, 0x03,
+0xDC, 0x12, 0x00, 0x49, 0x41, 0x80, 0x00, 0x03,
+0x3B, 0x13, 0x00, 0x49, 0x50, 0x81, 0xD0, 0x03,
+0x3B, 0x13, 0x0F, 0x98, 0x82, 0x59, 0x00, 0x03,
+0x3C, 0x13, 0x00, 0x49, 0xD0, 0x80, 0x00, 0x03,
+0x85, 0x12, 0x00, 0x49, 0x30, 0x80, 0x0F, 0x98,
+0x6D, 0x55, 0x6F, 0x80, 0x00, 0x0E, 0x01, 0x17,
+0x0F, 0x98, 0x46, 0x54, 0x0F, 0x88, 0x3A, 0x55,
+0x00, 0x03, 0x85, 0x12, 0x00, 0x49, 0x01, 0x81,
+0x00, 0x03, 0x08, 0x18, 0x00, 0x49, 0x00, 0x88,
+0x00, 0x52, 0x00, 0x03, 0x3B, 0x13, 0x00, 0x49,
+0x00, 0x88, 0x00, 0x52, 0x01, 0x0E, 0x0E, 0x16,
+0x0F, 0x98, 0x46, 0x54, 0x0F, 0x88, 0x3A, 0x55,
+0x00, 0x0E, 0x01, 0x17, 0x00, 0x0E, 0x84, 0x12,
+0x00, 0x03, 0x85, 0x12, 0x00, 0x0D, 0x86, 0x12,
+0x0F, 0x98, 0x46, 0x54, 0x0F, 0x98, 0xB5, 0x6F,
+0xA0, 0x03, 0x86, 0x12, 0xA0, 0x49, 0x4A, 0x80,
+0x0F, 0x98, 0x1F, 0x55, 0x0F, 0x88, 0xDA, 0x55,
+0x00, 0x03, 0x86, 0x12, 0x00, 0x0D, 0x85, 0x12,
+0x0F, 0x98, 0xAC, 0x65, 0x0F, 0x98, 0xF2, 0x66,
+0xA0, 0x03, 0x85, 0x12, 0xA0, 0x49, 0x4A, 0x80,
+0x0F, 0x98, 0x2B, 0x55, 0x0F, 0x88, 0xDA, 0x55,
+0x0F, 0x98, 0x14, 0x71, 0x00, 0x0E, 0x7D, 0x12,
+0xA0, 0x03, 0xAF, 0x13, 0xA1, 0x21, 0x0A, 0x0D,
+0xAF, 0x13, 0xA0, 0x03, 0x57, 0x13, 0xA0, 0x49,
+0xF1, 0xA0, 0x00, 0x0E, 0xAE, 0x13, 0x0F, 0x88,
+0xDA, 0x55, 0x80, 0x1A, 0x00, 0x80, 0x90, 0x1A,
+0xFF, 0x7F, 0x70, 0x19, 0xC0, 0x19, 0xD0, 0x1A,
+0xA0, 0x02, 0x40, 0x1A, 0x20, 0x07, 0x50, 0x1A,
+0xE0, 0x04, 0xAD, 0x00, 0xB4, 0x01, 0xAB, 0x38,
+0xDA, 0x09, 0x6A, 0x18, 0x60, 0x49, 0x1B, 0x80,
+0x60, 0x19, 0x56, 0x09, 0xA8, 0x48, 0x2D, 0x80,
+0x7C, 0x18, 0x8A, 0x18, 0xA9, 0x48, 0x1B, 0x80,
+0x9A, 0x18, 0xC1, 0x21, 0x00, 0x03, 0x8B, 0x02,
+0xC0, 0x48, 0xB1, 0x86, 0x08, 0x0D, 0x99, 0x02,
+0x07, 0x0D, 0x9A, 0x02, 0x09, 0x0D, 0x9D, 0x02,
+0xFF, 0xA0, 0x50, 0x1A, 0x00, 0x80, 0xA0, 0x03,
+0x09, 0x16, 0x30, 0x03, 0x0A, 0x16, 0xB0, 0x1A,
+0xA0, 0x0B, 0x00, 0x03, 0xD6, 0x00, 0x0F, 0x98,
+0x59, 0x54, 0x00, 0x1E, 0xB0, 0x20, 0x80, 0x03,
+0x07, 0x16, 0x90, 0x03, 0x08, 0x16, 0xB8, 0x20,
+0x0B, 0x00, 0x05, 0x48, 0x5D, 0x80, 0x50, 0x18,
+0x0A, 0x0D, 0xED, 0x13, 0x08, 0x0D, 0xEE, 0x13,
+0xB1, 0x21, 0x81, 0x21, 0x89, 0x48, 0x4D, 0x87,
+0xA1, 0x21, 0xA3, 0x48, 0x4D, 0x86, 0x00, 0x03,
+0xED, 0x13, 0x10, 0x03, 0xEE, 0x13, 0xA0, 0x03,
+0xD6, 0x00, 0x0F, 0x98, 0x59, 0x54, 0x00, 0x1E,
+0x01, 0x20, 0x00, 0x0D, 0x78, 0x16, 0x05, 0x0D,
+0x77, 0x16, 0xFF, 0xA0, 0xC0, 0x03, 0x8B, 0x02,
+0xD0, 0x1A, 0xA0, 0x02, 0x40, 0x1A, 0x20, 0x07,
+0xAD, 0x00, 0xB4, 0x01, 0xAB, 0x20, 0xDA, 0x09,
+0xC1, 0x39, 0xA1, 0x87, 0xFF, 0xA0, 0x12, 0x58,
+0xFF, 0xA0, 0x1A, 0x58, 0xFF, 0xA0, 0x2A, 0x58,
+0xFF, 0xA0, 0x0A, 0x58, 0xFF, 0xA0, 0xA5, 0x59,
+0xFF, 0xA0, 0xA9, 0x59, 0xFF, 0xA0, 0x29, 0x59,
+0xFF, 0xA0, 0x00, 0x0D, 0x31, 0x17, 0x01, 0x0D,
+0x32, 0x17, 0x0F, 0x98, 0xDA, 0x54, 0x90, 0x19,
+0x10, 0x49, 0xFB, 0xA0, 0x91, 0x19, 0xFF, 0xA0,
+0x03, 0x0D, 0x96, 0x02, 0x30, 0x19, 0x0F, 0x51,
+0x10, 0x80, 0x31, 0x39, 0x00, 0x0D, 0x00, 0xF9,
+0x03, 0x0D, 0x01, 0xF9, 0x30, 0x19, 0x1F, 0x51,
+0x10, 0x80, 0x31, 0x39, 0x01, 0x0D, 0x02, 0xF9,
+0x03, 0x0D, 0x03, 0xF9, 0x00, 0x03, 0x00, 0xF9,
+0x10, 0x03, 0x01, 0xF9, 0x30, 0x03, 0x96, 0x02,
+0xFF, 0xA0, 0x03, 0x0D, 0x96, 0x02, 0x00, 0x0D,
+0x00, 0xF9, 0x01, 0x0D, 0x01, 0xF9, 0x30, 0x19,
+0x2F, 0x51, 0x10, 0x80, 0x31, 0x39, 0x02, 0x0D,
+0x02, 0xF9, 0x03, 0x0D, 0x03, 0xF9, 0x00, 0x03,
+0x00, 0xF9, 0x10, 0x03, 0x01, 0xF9, 0x30, 0x03,
+0x96, 0x02, 0xFF, 0xA0, 0x00, 0x0D, 0x00, 0xF9,
+0x01, 0x0D, 0x01, 0xF9, 0x02, 0x0D, 0x02, 0xF9,
+0x03, 0x0D, 0x03, 0xF9, 0x00, 0x03, 0x00, 0xF9,
+0x10, 0x03, 0x01, 0xF9, 0xFF, 0xA0, 0x03, 0x0D,
+0x96, 0x02, 0x00, 0x0D, 0x10, 0xF9, 0x30, 0x19,
+0x0F, 0x51, 0x10, 0x80, 0x31, 0x39, 0x03, 0x0D,
+0x11, 0xF9, 0x01, 0x0D, 0x12, 0xF9, 0xFF, 0xFF,
+0xFF, 0xFF, 0x00, 0x03, 0x10, 0xF9, 0x10, 0x03,
+0x11, 0xF9, 0x30, 0x03, 0x96, 0x02, 0xFF, 0xA0,
+0x03, 0x0D, 0x96, 0x02, 0x00, 0x0D, 0x10, 0xF9,
+0x01, 0x0D, 0x11, 0xF9, 0x02, 0x0D, 0x12, 0xF9,
+0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x03, 0x10, 0xF9,
+0x10, 0x03, 0x11, 0xF9, 0x30, 0x03, 0x96, 0x02,
+0xFF, 0xA0, 0x00, 0x0D, 0x10, 0xF9, 0x01, 0x0D,
+0x11, 0xF9, 0x02, 0x0D, 0x12, 0xF9, 0xFF, 0xFF,
+0xFF, 0xFF, 0x00, 0x03, 0x10, 0xF9, 0x10, 0x03,
+0x11, 0xF9, 0xFF, 0xA0, 0x00, 0x0D, 0x08, 0xF9,
+0x01, 0x0D, 0x09, 0xF9, 0x02, 0x0D, 0x0A, 0xF9,
+0x03, 0x0D, 0x0B, 0xF9, 0x00, 0x03, 0x08, 0xF9,
+0x10, 0x03, 0x09, 0xF9, 0xFF, 0xA0, 0x03, 0x0D,
+0x96, 0x02, 0x00, 0x0D, 0x18, 0xF9, 0x30, 0x19,
+0x0F, 0x51, 0x10, 0x80, 0x31, 0x39, 0x03, 0x0D,
+0x19, 0xF9, 0x02, 0x0D, 0x1A, 0xF9, 0xFF, 0xFF,
+0xFF, 0xFF, 0x00, 0x03, 0x18, 0xF9, 0x30, 0x03,
+0x96, 0x02, 0xFF, 0xA0, 0x00, 0x0D, 0x18, 0xF9,
+0x01, 0x0D, 0x19, 0xF9, 0x02, 0x0D, 0x1A, 0xF9,
+0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x03, 0x18, 0xF9,
+0x10, 0x03, 0x19, 0xF9, 0xFF, 0xA0, 0x30, 0x49,
+0x31, 0x80, 0x2F, 0x51, 0x11, 0x80, 0xEF, 0x86,
+0x04, 0x0D, 0x33, 0x17, 0x41, 0x18, 0x4F, 0x7B,
+0x11, 0x79, 0x01, 0x79, 0x04, 0x68, 0x43, 0x18,
+0x4F, 0x7B, 0x31, 0x79, 0x21, 0x79, 0x24, 0x68,
+0x30, 0x49, 0x41, 0x87, 0x2F, 0x51, 0x21, 0x87,
+0x40, 0x03, 0x33, 0x17, 0xBF, 0x85, 0x10, 0x03,
+0x65, 0x01, 0x1F, 0x51, 0x30, 0x80, 0xD0, 0x19,
+0x0F, 0x98, 0x82, 0x59, 0x00, 0x0E, 0x0E, 0x16,
+0x00, 0x0E, 0x85, 0x12, 0x3F, 0x81, 0x00, 0x0E,
+0x30, 0x17, 0x00, 0x03, 0x88, 0x12, 0x00, 0x0D,
+0x8D, 0x12, 0x10, 0x03, 0x65, 0x01, 0x1F, 0x51,
+0x30, 0x80, 0xD0, 0x19, 0x0F, 0x98, 0x82, 0x59,
+0x00, 0x0E, 0x0E, 0x16, 0x00, 0x0E, 0x85, 0x12,
+0x0F, 0x98, 0xB5, 0x6F, 0x0F, 0x98, 0xAC, 0x65,
+0x0F, 0x98, 0xF2, 0x66, 0x0F, 0x98, 0x14, 0x71,
+0x00, 0x0E, 0xAF, 0x13, 0x00, 0x0E, 0xAE, 0x13,
+0x00, 0x0E, 0x76, 0x12, 0x00, 0x0E, 0x7D, 0x12,
+0x00, 0x0E, 0x3B, 0x16, 0x00, 0x03, 0xFE, 0x16,
+0x00, 0x49, 0x60, 0x80, 0x00, 0x03, 0x99, 0x02,
+0x10, 0x03, 0x8A, 0x12, 0x01, 0x48, 0x4B, 0x80,
+0x00, 0x0E, 0xFE, 0x16, 0x00, 0x0E, 0x1C, 0x16,
+0xA0, 0x03, 0x8E, 0x12, 0x0A, 0x0D, 0x88, 0x12,
+0x0A, 0x0D, 0x92, 0x00, 0x0A, 0x0D, 0xC5, 0x12,
+0xA0, 0x03, 0xAD, 0x13, 0xA3, 0x51, 0x31, 0x80,
+0x0F, 0x98, 0xAE, 0x6C, 0x2F, 0x80, 0x05, 0x0E,
+0xDE, 0x12, 0x00, 0x03, 0x3C, 0x13, 0x00, 0x49,
+0x31, 0x80, 0x00, 0x0E, 0xED, 0x01, 0xFF, 0xA0,
+0x00, 0x0E, 0x73, 0x12, 0x00, 0x03, 0x3C, 0x13,
+0x02, 0x49, 0xF1, 0xA0, 0x00, 0x03, 0xAD, 0x13,
+0x0F, 0xC1, 0x00, 0x0D, 0xAD, 0x13, 0xFF, 0xA0,
+0x00, 0x03, 0x77, 0x02, 0x00, 0x49, 0x40, 0x80,
+0x01, 0x39, 0x00, 0x0D, 0x77, 0x02, 0x7F, 0x83,
+0x00, 0x0E, 0x02, 0x18, 0x91, 0x19, 0x00, 0x03,
+0x8C, 0x00, 0x00, 0x51, 0x01, 0x88, 0xD7, 0x55,
+0xA0, 0x03, 0x0E, 0x16, 0xA0, 0x49, 0xB1, 0x81,
+0xA0, 0x03, 0xD9, 0x17, 0xB0, 0x03, 0x9D, 0x00,
+0xAB, 0x48, 0xDB, 0x83, 0xB0, 0x03, 0x9F, 0x00,
+0x00, 0x03, 0xFB, 0x16, 0x00, 0x49, 0x20, 0x80,
+0xB0, 0x03, 0xC4, 0x00, 0x00, 0x03, 0x00, 0x17,
+0x00, 0x49, 0x40, 0x80, 0xB0, 0x03, 0xC3, 0x00,
+0xB0, 0x49, 0xD0, 0x82, 0xA0, 0x03, 0x73, 0x12,
+0xAB, 0x48, 0x3C, 0x82, 0x0F, 0x81, 0xA0, 0x03,
+0xD9, 0x17, 0xA0, 0x4E, 0x9D, 0x00, 0x3B, 0x82,
+0xA0, 0x03, 0x73, 0x12, 0xA1, 0x21, 0x0A, 0x0D,
+0x73, 0x12, 0xB0, 0x03, 0xA1, 0x00, 0xA0, 0x03,
+0x73, 0x12, 0xAB, 0x48, 0xFC, 0xA0, 0x0F, 0x98,
+0x53, 0x50, 0xC0, 0x03, 0x8B, 0x02, 0x30, 0x1A,
+0xA0, 0x02, 0x40, 0x1A, 0x20, 0x07, 0xA3, 0x01,
+0x4A, 0x09, 0xC1, 0x39, 0xC1, 0x87, 0x00, 0x0E,
+0x73, 0x12, 0x00, 0x0E, 0x48, 0x17, 0x90, 0x19,
+0x8F, 0x80, 0xA0, 0x03, 0x73, 0x12, 0xA1, 0x21,
+0x0A, 0x0D, 0x73, 0x12, 0xFF, 0xA0, 0x00, 0x0E,
+0x73, 0x12, 0xFF, 0xA0, 0xA0, 0x03, 0xD9, 0x17,
+0xA0, 0x4E, 0x9E, 0x00, 0xAB, 0x83, 0x00, 0x03,
+0x8C, 0x00, 0x01, 0x51, 0x61, 0x83, 0xA0, 0x03,
+0x0E, 0x16, 0xA0, 0x49, 0x21, 0x83, 0xA0, 0x03,
+0x00, 0x17, 0xA0, 0x49, 0x40, 0x80, 0xA0, 0x03,
+0xC3, 0x00, 0xA0, 0x49, 0xA0, 0x82, 0xA0, 0x03,
+0x84, 0x12, 0xA0, 0x4E, 0xA0, 0x00, 0xFC, 0x81,
+0xC0, 0x03, 0x8B, 0x02, 0x30, 0x1A, 0xA0, 0x02,
+0x40, 0x1A, 0x20, 0x07, 0xA3, 0x00, 0xB4, 0x00,
+0xAB, 0x48, 0xE0, 0x80, 0x00, 0x03, 0xA2, 0x00,
+0xA0, 0x38, 0xAB, 0x48, 0x7B, 0x80, 0xA0, 0x20,
+0xA0, 0x20, 0xAB, 0x48, 0x5A, 0x80, 0xB0, 0x38,
+0x4B, 0x08, 0x2F, 0x80, 0xB0, 0x20, 0x4B, 0x08,
+0x31, 0x21, 0x41, 0x21, 0xC1, 0x39, 0xA1, 0x86,
+0x00, 0x0E, 0x84, 0x12, 0x8F, 0x80, 0xA0, 0x03,
+0x84, 0x12, 0xA1, 0x21, 0x0A, 0x0D, 0x84, 0x12,
+0xFF, 0xA0, 0x00, 0x0E, 0x84, 0x12, 0xFF, 0xA0,
+0x00, 0x0E, 0x49, 0x13, 0x00, 0x03, 0x9A, 0x02,
+0x20, 0x03, 0xD6, 0x00, 0x0F, 0x98, 0xE7, 0x54,
+0x00, 0x0D, 0x34, 0x13, 0x00, 0x03, 0x1A, 0xF9,
+0x00, 0x0D, 0x36, 0x13, 0x50, 0x19, 0x00, 0x03,
+0x99, 0x02, 0x10, 0x03, 0xBF, 0x00, 0x10, 0x49,
+0xF0, 0xA0, 0x0F, 0x98, 0x95, 0x64, 0x60, 0x18,
+0xC0, 0x19, 0xD0, 0x1A, 0xA0, 0x02, 0xAD, 0x00,
+0xA6, 0x48, 0x8C, 0x81, 0x0C, 0x18, 0x20, 0x03,
+0xD6, 0x00, 0x0F, 0x98, 0xE7, 0x54, 0x10, 0x03,
+0x34, 0x13, 0x20, 0x03, 0x1A, 0xF9, 0x30, 0x03,
+0x36, 0x13, 0x01, 0x38, 0x0F, 0x51, 0x10, 0x80,
+0x00, 0x31, 0x23, 0x38, 0x2F, 0x51, 0x10, 0x80,
+0x20, 0x31, 0x02, 0x20, 0x00, 0x4E, 0xC2, 0x00,
+0x1D, 0x80, 0x51, 0x21, 0xD1, 0x21, 0xC1, 0x21,
+0xC0, 0x4E, 0x8B, 0x02, 0x01, 0x86, 0x05, 0x0D,
+0x49, 0x13, 0xFF, 0xA0, 0x90, 0x19, 0x00, 0x03,
+0x99, 0x02, 0x00, 0x4E, 0xC0, 0x00, 0xFA, 0xA0,
+0x00, 0x03, 0x8C, 0x00, 0x07, 0x51, 0xF0, 0xA0,
+0x0F, 0x98, 0x1C, 0x56, 0x90, 0x19, 0x10, 0x03,
+0x49, 0x13, 0x10, 0x4E, 0xC1, 0x00, 0xFD, 0xA0,
+0x10, 0x03, 0xBE, 0x00, 0x91, 0x19, 0x00, 0x03,
+0x9F, 0x00, 0x01, 0x48, 0xFD, 0xA0, 0x20, 0x03,
+0x73, 0x12, 0x02, 0x38, 0x01, 0x48, 0xFD, 0xA0,
+0x00, 0x03, 0x9F, 0x00, 0x01, 0x38, 0x00, 0x0D,
+0x73, 0x12, 0xFF, 0xA0, 0xD0, 0x20, 0xD4, 0x20,
+0x30, 0x18, 0xB0, 0x18, 0x34, 0x20, 0xB4, 0x38,
+0xBF, 0x51, 0x00, 0xB0, 0xB0, 0x31, 0x3B, 0x38,
+0x73, 0x20, 0x05, 0x48, 0x2D, 0x80, 0x45, 0x48,
+0xFA, 0xA0, 0x3B, 0x38, 0x73, 0x20, 0xFF, 0xA0,
+0x0F, 0x98, 0x55, 0x54, 0x30, 0x1E, 0x62, 0x18,
+0x63, 0x20, 0x6C, 0x20, 0x06, 0x00, 0xFF, 0xA0,
+0x0F, 0x98, 0x57, 0x54, 0x60, 0x1E, 0x6C, 0x20,
+0x61, 0x20, 0x06, 0x00, 0xFF, 0xA0, 0x50, 0x03,
+0x73, 0x16, 0xC0, 0x03, 0x8C, 0x16, 0xA0, 0x03,
+0xD6, 0x00, 0x80, 0x03, 0xFA, 0x12, 0x20, 0x03,
+0x36, 0x13, 0x28, 0x48, 0x30, 0x83, 0x00, 0x03,
+0x07, 0x16, 0x20, 0x48, 0xFD, 0x82, 0x00, 0x0E,
+0x8F, 0x02, 0x00, 0x0E, 0x89, 0x02, 0x10, 0x03,
+0xFC, 0x12, 0x90, 0x03, 0xFD, 0x12, 0x70, 0x19,
+0xD0, 0x19, 0x0F, 0x98, 0x90, 0x56, 0x61, 0x39,
+0x46, 0x00, 0x0F, 0x98, 0x7E, 0x56, 0x11, 0x21,
+0x19, 0x48, 0x7C, 0x87, 0xD0, 0x49, 0xCD, 0x80,
+0x02, 0x0D, 0x8E, 0x16, 0x0D, 0x18, 0x10, 0x03,
+0x42, 0x17, 0x0F, 0x98, 0x95, 0x64, 0x20, 0x03,
+0x8E, 0x16, 0x70, 0x48, 0x1D, 0x80, 0xBF, 0x80,
+0x00, 0x03, 0xFA, 0x12, 0x01, 0x21, 0x20, 0x48,
+0x9D, 0x80, 0x01, 0x0E, 0xF8, 0x12, 0x21, 0x39,
+0x02, 0x0D, 0xFA, 0x12, 0x3F, 0x80, 0x21, 0x39,
+0x28, 0x48, 0x1A, 0x85, 0xFF, 0xA0, 0x50, 0x03,
+0x73, 0x16, 0xC0, 0x03, 0x8C, 0x16, 0x80, 0x03,
+0xFB, 0x12, 0xA0, 0x03, 0xD6, 0x00, 0x00, 0x03,
+0x08, 0x16, 0x20, 0x03, 0x36, 0x13, 0x28, 0x48,
+0x10, 0x83, 0x20, 0x48, 0xFB, 0x82, 0x00, 0x0E,
+0x8F, 0x02, 0x00, 0x0E, 0x89, 0x02, 0x10, 0x03,
+0xFC, 0x12, 0x90, 0x03, 0xFD, 0x12, 0x70, 0x19,
+0xD0, 0x19, 0x0F, 0x98, 0x90, 0x56, 0x61, 0x21,
+0x46, 0x00, 0x0F, 0x98, 0x7E, 0x56, 0x11, 0x21,
+0x19, 0x48, 0x7C, 0x87, 0xD0, 0x49, 0xCD, 0x80,
+0x02, 0x0D, 0x8E, 0x16, 0x0D, 0x18, 0x10, 0x03,
+0x42, 0x17, 0x0F, 0x98, 0x95, 0x64, 0x20, 0x03,
+0x8E, 0x16, 0x70, 0x48, 0x1D, 0x80, 0xBF, 0x80,
+0x00, 0x03, 0xFB, 0x12, 0x01, 0x39, 0x20, 0x48,
+0x9B, 0x80, 0x01, 0x0E, 0xF8, 0x12, 0x21, 0x21,
+0x02, 0x0D, 0xFB, 0x12, 0x3F, 0x80, 0x21, 0x21,
+0x28, 0x48, 0x1C, 0x85, 0xFF, 0xA0, 0x50, 0x03,
+0x73, 0x16, 0xC0, 0x03, 0x8C, 0x16, 0xA0, 0x03,
+0xD6, 0x00, 0x90, 0x03, 0xFC, 0x12, 0x20, 0x03,
+0x34, 0x13, 0x29, 0x48, 0x40, 0x83, 0x00, 0x03,
+0x09, 0x16, 0x20, 0x48, 0x0D, 0x83, 0x00, 0x0E,
+0x8F, 0x02, 0x00, 0x0E, 0x89, 0x02, 0x10, 0x03,
+0xFA, 0x12, 0x80, 0x03, 0xFB, 0x12, 0x70, 0x19,
+0xD0, 0x19, 0x0F, 0x98, 0x98, 0x56, 0x6A, 0x38,
+0x46, 0x00, 0x0F, 0x98, 0x7E, 0x56, 0x11, 0x21,
+0x61, 0x21, 0x18, 0x48, 0x6D, 0x87, 0xD0, 0x49,
+0xCD, 0x80, 0x02, 0x0D, 0x8E, 0x16, 0x0D, 0x18,
+0x10, 0x03, 0x42, 0x17, 0x0F, 0x98, 0x95, 0x64,
+0x20, 0x03, 0x8E, 0x16, 0x70, 0x48, 0x1D, 0x80,
+0xBF, 0x80, 0x00, 0x03, 0xFC, 0x12, 0x01, 0x21,
+0x20, 0x48, 0x9D, 0x80, 0x01, 0x0E, 0xF8, 0x12,
+0x21, 0x39, 0x02, 0x0D, 0xFC, 0x12, 0x3F, 0x80,
+0x21, 0x39, 0x29, 0x48, 0x0B, 0x85, 0xFF, 0xA0,
+0x50, 0x03, 0x73, 0x16, 0xC0, 0x03, 0x8C, 0x16,
+0xA0, 0x03, 0xD6, 0x00, 0x90, 0x03, 0xFD, 0x12,
+0x00, 0x03, 0x0A, 0x16, 0x20, 0x03, 0x34, 0x13,
+0x29, 0x48, 0x20, 0x83, 0x20, 0x48, 0x0B, 0x83,
+0x00, 0x0E, 0x8F, 0x02, 0x00, 0x0E, 0x89, 0x02,
+0x10, 0x03, 0xFA, 0x12, 0x80, 0x03, 0xFB, 0x12,
+0x70, 0x19, 0xD0, 0x19, 0x0F, 0x98, 0x98, 0x56,
+0x6A, 0x20, 0x46, 0x00, 0x0F, 0x98, 0x7E, 0x56,
+0x11, 0x21, 0x61, 0x21, 0x18, 0x48, 0x6D, 0x87,
+0xD0, 0x49, 0xCD, 0x80, 0x02, 0x0D, 0x8E, 0x16,
+0x0D, 0x18, 0x10, 0x03, 0x42, 0x17, 0x0F, 0x98,
+0x95, 0x64, 0x20, 0x03, 0x8E, 0x16, 0x70, 0x48,
+0x1D, 0x80, 0xBF, 0x80, 0x00, 0x03, 0xFD, 0x12,
+0x01, 0x39, 0x20, 0x48, 0x9B, 0x80, 0x01, 0x0E,
+0xF8, 0x12, 0x21, 0x21, 0x02, 0x0D, 0xFD, 0x12,
+0x3F, 0x80, 0x21, 0x21, 0x29, 0x48, 0x0C, 0x85,
+0xFF, 0xA0, 0x00, 0x03, 0xFC, 0x12, 0x00, 0x0D,
+0x0B, 0x13, 0x00, 0x03, 0xFD, 0x12, 0x00, 0x0D,
+0x0C, 0x13, 0x00, 0x03, 0xFA, 0x12, 0x00, 0x0D,
+0x09, 0x13, 0x00, 0x03, 0xFB, 0x12, 0x00, 0x0D,
+0x0A, 0x13, 0xFF, 0xA0, 0x0F, 0x98, 0xA1, 0x57,
+0x0F, 0x98, 0x9F, 0x56, 0x0F, 0x98, 0xDF, 0x56,
+0x0F, 0x98, 0x1F, 0x57, 0x0F, 0x98, 0x60, 0x57,
+0x00, 0x03, 0xFC, 0x12, 0x00, 0x4E, 0x0B, 0x13,
+0x11, 0x87, 0x00, 0x03, 0xFD, 0x12, 0x00, 0x4E,
+0x0C, 0x13, 0xC1, 0x86, 0x00, 0x03, 0xFA, 0x12,
+0x00, 0x4E, 0x09, 0x13, 0x71, 0x86, 0x00, 0x03,
+0xFB, 0x12, 0x00, 0x4E, 0x0A, 0x13, 0x21, 0x86,
+0x0F, 0x85, 0x0F, 0x98, 0x55, 0x54, 0x30, 0x1E,
+0x62, 0x18, 0x63, 0x20, 0x6C, 0x20, 0x06, 0x00,
+0xFF, 0xA0, 0x50, 0x03, 0x72, 0x16, 0xC0, 0x03,
+0x8C, 0x16, 0xA0, 0x03, 0xD6, 0x00, 0x40, 0x03,
+0xFA, 0x12, 0x20, 0x03, 0x36, 0x13, 0x00, 0x03,
+0x07, 0x16, 0x42, 0x48, 0xA0, 0x81, 0x20, 0x48,
+0x2A, 0x80, 0x20, 0x18, 0x6F, 0x81, 0x10, 0x03,
+0xFC, 0x12, 0x90, 0x03, 0xFD, 0x12, 0x70, 0x19,
+0x0F, 0x98, 0xD1, 0x57, 0x05, 0x48, 0x1C, 0x80,
+0x71, 0x19, 0x11, 0x21, 0x19, 0x48, 0x8D, 0x87,
+0x70, 0x49, 0x21, 0x80, 0x21, 0x21, 0x5F, 0x80,
+0x21, 0x39, 0x24, 0x48, 0xCB, 0x86, 0x20, 0x03,
+0xFA, 0x12, 0x20, 0x4E, 0x36, 0x13, 0x0D, 0xB0,
+0x20, 0x03, 0x36, 0x13, 0x02, 0x0D, 0xFA, 0x12,
+0xFF, 0xA0, 0x50, 0x03, 0x72, 0x16, 0xC0, 0x03,
+0x8C, 0x16, 0xA0, 0x03, 0xD6, 0x00, 0x00, 0x03,
+0x08, 0x16, 0x40, 0x03, 0xFB, 0x12, 0x20, 0x03,
+0x36, 0x13, 0x42, 0x48, 0xA0, 0x81, 0x20, 0x48,
+0x2C, 0x80, 0x20, 0x18, 0x6F, 0x81, 0x10, 0x03,
+0xFC, 0x12, 0x90, 0x03, 0xFD, 0x12, 0x70, 0x19,
+0x0F, 0x98, 0xD1, 0x57, 0x05, 0x48, 0x1C, 0x80,
+0x71, 0x19, 0x11, 0x21, 0x19, 0x48, 0x8D, 0x87,
+0x70, 0x49, 0x21, 0x80, 0x21, 0x39, 0x5F, 0x80,
+0x21, 0x21, 0x24, 0x48, 0xCD, 0x86, 0x20, 0x03,
+0xFB, 0x12, 0x20, 0x4E, 0x36, 0x13, 0x0B, 0xB0,
+0x20, 0x03, 0x36, 0x13, 0x02, 0x0D, 0xFB, 0x12,
+0xFF, 0xA0, 0x50, 0x03, 0x72, 0x16, 0xC0, 0x03,
+0x8C, 0x16, 0xA0, 0x03, 0xD6, 0x00, 0x20, 0x03,
+0x34, 0x13, 0x00, 0x03, 0x09, 0x16, 0x20, 0x48,
+0x2A, 0x80, 0x20, 0x18, 0xDF, 0x81, 0x10, 0x03,
+0xFA, 0x12, 0x80, 0x03, 0xFB, 0x12, 0x70, 0x19,
+0x0F, 0x98, 0x57, 0x54, 0x60, 0x1E, 0x6C, 0x20,
+0x61, 0x20, 0x06, 0x00, 0x05, 0x48, 0x1C, 0x80,
+0x71, 0x19, 0x11, 0x21, 0x61, 0x21, 0x18, 0x48,
+0x8D, 0x87, 0x70, 0x49, 0x21, 0x80, 0x21, 0x21,
+0x7F, 0x80, 0x21, 0x39, 0x00, 0x03, 0x09, 0x16,
+0x20, 0x48, 0x5B, 0x86, 0x20, 0x03, 0x09, 0x16,
+0x20, 0x4E, 0x34, 0x13, 0x0D, 0xB0, 0x20, 0x03,
+0x34, 0x13, 0x02, 0x0D, 0xFC, 0x12, 0xFF, 0xA0,
+0x50, 0x03, 0x72, 0x16, 0xC0, 0x03, 0x8C, 0x16,
+0xA0, 0x03, 0xD6, 0x00, 0x90, 0x03, 0x0A, 0x16,
+0x00, 0x03, 0x0A, 0x16, 0x20, 0x03, 0x34, 0x13,
+0x20, 0x48, 0x2C, 0x80, 0x20, 0x18, 0xCF, 0x81,
+0x10, 0x03, 0xFA, 0x12, 0x80, 0x03, 0xFB, 0x12,
+0x70, 0x19, 0x0F, 0x98, 0x57, 0x54, 0x30, 0x1E,
+0x63, 0x18, 0x6C, 0x20, 0x61, 0x20, 0x06, 0x00,
+0x05, 0x48, 0x1C, 0x80, 0x71, 0x19, 0x11, 0x21,
+0x61, 0x21, 0x18, 0x48, 0x8D, 0x87, 0x70, 0x49,
+0x21, 0x80, 0x21, 0x39, 0x5F, 0x80, 0x21, 0x21,
+0x29, 0x48, 0x6C, 0x86, 0x20, 0x03, 0x0A, 0x16,
+0x20, 0x4E, 0x34, 0x13, 0x0B, 0xB0, 0x20, 0x03,
+0x34, 0x13, 0x02, 0x0D, 0xFD, 0x12, 0xFF, 0xA0,
+0x0C, 0x18, 0x20, 0x03, 0xD6, 0x00, 0x0F, 0x98,
+0xE7, 0x54, 0x00, 0x0D, 0x34, 0x13, 0x00, 0x03,
+0x1A, 0xF9, 0x00, 0x0D, 0x36, 0x13, 0xC0, 0x19,
+0x00, 0x03, 0x8A, 0x12, 0x10, 0x03, 0xC5, 0x00,
+0x10, 0x49, 0x60, 0x80, 0x00, 0x03, 0x74, 0x16,
+0x10, 0x03, 0xC5, 0x00, 0x0F, 0x98, 0x95, 0x64,
+0x10, 0x03, 0x8A, 0x12, 0x01, 0x48, 0x1B, 0x80,
+0x01, 0x18, 0x00, 0x0D, 0x72, 0x16, 0x00, 0x03,
+0x74, 0x16, 0x10, 0x03, 0xCE, 0x00, 0x10, 0x49,
+0x31, 0x80, 0x00, 0x0E, 0x73, 0x16, 0x4F, 0x80,
+0x0F, 0x98, 0x95, 0x64, 0x00, 0x0D, 0x73, 0x16,
+0x0F, 0x98, 0xD9, 0x57, 0x0F, 0x98, 0x09, 0x58,
+0x0F, 0x98, 0x39, 0x58, 0x0F, 0x98, 0x6C, 0x58,
+0x0F, 0x98, 0xD9, 0x57, 0x0F, 0x88, 0x09, 0x58,
+0xC0, 0x19, 0x00, 0x03, 0x74, 0x16, 0x10, 0x03,
+0xD4, 0x00, 0x0F, 0x98, 0x95, 0x64, 0x50, 0x18,
+0x50, 0x4A, 0x14, 0x00, 0x2B, 0x80, 0x50, 0x1A,
+0x14, 0x00, 0xA0, 0x03, 0x0B, 0x13, 0xB0, 0x03,
+0x8C, 0x16, 0x00, 0x03, 0xD6, 0x00, 0x0F, 0x98,
+0x59, 0x54, 0x00, 0x1E, 0xB0, 0x20, 0x10, 0x03,
+0x09, 0x13, 0x20, 0x03, 0x0A, 0x13, 0xB1, 0x20,
+0x0B, 0x00, 0x05, 0x48, 0x1C, 0x80, 0xC1, 0x21,
+0xB1, 0x21, 0x11, 0x21, 0x12, 0x48, 0x8D, 0x87,
+0xA1, 0x21, 0x00, 0x03, 0x0C, 0x13, 0xA0, 0x48,
+0x6D, 0x86, 0x0C, 0x0D, 0xFE, 0x12, 0xFF, 0xA0,
+0xA0, 0x03, 0x05, 0x13, 0xB0, 0x03, 0x8C, 0x16,
+0x00, 0x03, 0xD6, 0x00, 0x0F, 0x98, 0x59, 0x54,
+0x00, 0x1E, 0xB0, 0x20, 0x10, 0x03, 0x03, 0x13,
+0x20, 0x03, 0x04, 0x13, 0x30, 0x03, 0x06, 0x13,
+0xB1, 0x20, 0x40, 0x03, 0x91, 0x02, 0xB0, 0x0B,
+0xB1, 0x21, 0x11, 0x21, 0x12, 0x48, 0xBD, 0x87,
+0xA1, 0x21, 0xA3, 0x48, 0x7D, 0x86, 0xFF, 0xA0,
+0x00, 0x03, 0x85, 0x12, 0x00, 0x49, 0xF0, 0xA0,
+0x00, 0x1A, 0x12, 0x00, 0x20, 0x19, 0x10, 0x1A,
+0x26, 0x16, 0x12, 0x09, 0x01, 0x39, 0xDA, 0x87,
+0x70, 0x19, 0xA0, 0x1A, 0x04, 0x14, 0xB0, 0x1A,
+0x26, 0x16, 0xA7, 0x20, 0x1A, 0x00, 0x01, 0x18,
+0x20, 0x03, 0xD6, 0x00, 0x0F, 0x98, 0xE7, 0x54,
+0x00, 0x0D, 0xEC, 0x12, 0x00, 0x03, 0x1A, 0xF9,
+0x00, 0x0D, 0xED, 0x12, 0xB0, 0x20, 0x2B, 0x00,
+0x21, 0x21, 0xB2, 0x08, 0x27, 0x18, 0x0F, 0x98,
+0x5F, 0x54, 0x20, 0x1E, 0x00, 0x1A, 0x62, 0x14,
+0x20, 0x20, 0x25, 0x21, 0x52, 0x00, 0x00, 0x03,
+0xED, 0x12, 0x00, 0x4E, 0x07, 0x16, 0x70, 0x80,
+0x00, 0x4E, 0x08, 0x16, 0x71, 0x80, 0x50, 0x4E,
+0x44, 0x17, 0x4B, 0x80, 0x4F, 0x81, 0x50, 0x4E,
+0x43, 0x17, 0x1C, 0x81, 0x00, 0x03, 0xEC, 0x12,
+0x00, 0x4E, 0x09, 0x16, 0x70, 0x80, 0x00, 0x4E,
+0x0A, 0x16, 0x81, 0x80, 0x50, 0x4E, 0x46, 0x17,
+0x6B, 0x81, 0x5F, 0x80, 0x50, 0x4E, 0x45, 0x17,
+0x2B, 0x81, 0x1F, 0x80, 0x0F, 0x81, 0x07, 0x0D,
+0x8E, 0x16, 0xA7, 0x18, 0x0F, 0x98, 0xA3, 0x62,
+0x70, 0x03, 0x8E, 0x16, 0xD0, 0x03, 0x85, 0x12,
+0xD1, 0x39, 0x0D, 0x0D, 0x85, 0x12, 0x7D, 0x48,
+0xFB, 0xA0, 0x0F, 0x88, 0x2D, 0x59, 0x10, 0x03,
+0x85, 0x12, 0x71, 0x21, 0x71, 0x48, 0xFB, 0xA0,
+0x0F, 0x88, 0x2D, 0x59, 0x00, 0x0E, 0xD2, 0x12,
+0x00, 0x0E, 0x75, 0x12, 0x00, 0x03, 0x25, 0x01,
+0x00, 0x49, 0xF0, 0xA0, 0xD0, 0x49, 0x71, 0x82,
+0x00, 0x19, 0xA0, 0x1A, 0xD3, 0x12, 0x88, 0x19,
+0xA0, 0x09, 0x81, 0x39, 0xD1, 0x87, 0xA0, 0x1A,
+0xE2, 0x01, 0x88, 0x19, 0xA0, 0x09, 0x81, 0x39,
+0xD1, 0x87, 0x70, 0x19, 0x00, 0x03, 0x25, 0x01,
+0x70, 0x48, 0x0B, 0x88, 0x4A, 0x5A, 0x00, 0x03,
+0xDC, 0x12, 0x07, 0x50, 0xE0, 0x80, 0x02, 0x0E,
+0x3C, 0x13, 0x00, 0x03, 0xD2, 0x12, 0x17, 0x18,
+0x18, 0x21, 0x01, 0xC0, 0x00, 0x0D, 0xD2, 0x12,
+0x00, 0x03, 0xDC, 0x12, 0x07, 0xC8, 0x00, 0x0D,
+0xDC, 0x12, 0x71, 0x21, 0x7F, 0x86, 0x00, 0x03,
+0xDC, 0x12, 0x00, 0x0D, 0xDD, 0x12, 0x00, 0x0E,
+0xDC, 0x12, 0x70, 0x19, 0x07, 0x0D, 0x8D, 0x02,
+0x70, 0x03, 0x8D, 0x02, 0x00, 0x03, 0x25, 0x01,
+0x70, 0x48, 0x0B, 0x88, 0x22, 0x5A, 0x10, 0x1A,
+0x0B, 0x17, 0x17, 0x20, 0x01, 0x00, 0x00, 0x4A,
+0xFF, 0xFF, 0x00, 0x88, 0x1B, 0x5A, 0xA0, 0x1A,
+0xD3, 0x12, 0xA7, 0x20, 0x0A, 0x00, 0x01, 0x21,
+0xA0, 0x08, 0x10, 0x03, 0xDB, 0x12, 0x01, 0x48,
+0x5B, 0x80, 0x01, 0x0E, 0x0E, 0x16, 0x01, 0x0E,
+0x3C, 0x13, 0x6F, 0x81, 0x01, 0x0E, 0x0E, 0x16,
+0x01, 0x0E, 0x3C, 0x13, 0xA1, 0x08, 0x00, 0x03,
+0xD2, 0x12, 0x17, 0x18, 0x10, 0x21, 0x01, 0xC0,
+0x00, 0x0D, 0xD2, 0x12, 0x00, 0x03, 0xDC, 0x12,
+0x07, 0xC0, 0x00, 0x0D, 0xDC, 0x12, 0x00, 0x03,
+0x75, 0x12, 0x01, 0x21, 0x00, 0x0D, 0x75, 0x12,
+0x10, 0x1A, 0x0B, 0x17, 0x17, 0x20, 0x61, 0x00,
+0xB0, 0x03, 0xE9, 0x12, 0xB6, 0x20, 0x0B, 0x00,
+0xB0, 0x1A, 0x60, 0x09, 0xB6, 0x20, 0x10, 0x18,
+0x20, 0x03, 0x4A, 0x01, 0x0F, 0x98, 0x53, 0x54,
+0x10, 0x1E, 0xB1, 0x08, 0x10, 0x03, 0x33, 0x01,
+0x10, 0x49, 0x20, 0x80, 0x0F, 0x98, 0x95, 0x64,
+0x10, 0x03, 0x09, 0x17, 0x10, 0x49, 0xF0, 0x80,
+0x47, 0x18, 0x40, 0x22, 0xE2, 0x01, 0x00, 0x0D,
+0xE9, 0x17, 0x80, 0x03, 0xEA, 0x01, 0x08, 0x0D,
+0xEA, 0x17, 0x0F, 0x98, 0x55, 0x73, 0x30, 0x03,
+0xE9, 0x17, 0x43, 0x08, 0x0F, 0x80, 0x70, 0x03,
+0x8D, 0x02, 0x71, 0x21, 0x07, 0x0D, 0x8D, 0x02,
+0x0F, 0x88, 0xBC, 0x59, 0x70, 0x19, 0x00, 0x03,
+0x25, 0x01, 0x70, 0x48, 0x3B, 0x82, 0x00, 0x03,
+0xDC, 0x12, 0x07, 0x50, 0x70, 0x80, 0x00, 0x03,
+0xDD, 0x12, 0x07, 0x50, 0x91, 0x81, 0x02, 0x0E,
+0x3C, 0x13, 0x6F, 0x81, 0x00, 0x03, 0xDD, 0x12,
+0x07, 0x50, 0x20, 0x81, 0x02, 0x0E, 0x3C, 0x13,
+0x00, 0x03, 0xD2, 0x12, 0x17, 0x18, 0x18, 0x21,
+0x01, 0xC0, 0x00, 0x0D, 0xD2, 0x12, 0x00, 0x03,
+0xDC, 0x12, 0x07, 0xC8, 0x00, 0x0D, 0xDC, 0x12,
+0xA0, 0x1A, 0xD3, 0x12, 0xA7, 0x20, 0xA0, 0x0B,
+0x71, 0x21, 0x9F, 0x85, 0xFF, 0xA0, 0x62, 0x58,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x60, 0x1E,
+0x65, 0x20, 0xFF, 0xA0, 0xB0, 0x1A, 0x0B, 0x17,
+0xA8, 0x19, 0x00, 0x1A, 0xFF, 0xFF, 0xB0, 0x09,
+0xA1, 0x39, 0xD1, 0x87, 0x00, 0x1A, 0x00, 0x80,
+0x00, 0x0D, 0x79, 0x16, 0xB0, 0x1A, 0xA0, 0x02,
+0x0B, 0x0D, 0xE9, 0x12, 0x00, 0x0E, 0x8D, 0x02,
+0x00, 0x03, 0x25, 0x01, 0x80, 0x03, 0x8D, 0x02,
+0x80, 0x48, 0xFB, 0xA0, 0x60, 0x1A, 0x2B, 0x01,
+0x00, 0x03, 0x8D, 0x02, 0x60, 0x20, 0x06, 0x00,
+0x00, 0x0D, 0x92, 0x02, 0x90, 0x1A, 0x00, 0x80,
+0x00, 0x0E, 0x93, 0x02, 0x00, 0x03, 0x28, 0x01,
+0x00, 0x49, 0x91, 0x80, 0x20, 0x03, 0xD6, 0x00,
+0x60, 0x03, 0x29, 0x01, 0x50, 0x03, 0x92, 0x02,
+0x0F, 0x98, 0x4B, 0x5A, 0x8F, 0x80, 0x20, 0x03,
+0xD6, 0x00, 0x60, 0x03, 0x92, 0x02, 0x50, 0x03,
+0x29, 0x01, 0x0F, 0x98, 0x4B, 0x5A, 0x06, 0x18,
+0x20, 0x03, 0xD6, 0x00, 0x0F, 0x98, 0xE7, 0x54,
+0x00, 0x03, 0x1A, 0xF9, 0x20, 0x18, 0xB0, 0x1A,
+0x57, 0x17, 0xB0, 0x20, 0x0B, 0x00, 0x10, 0x03,
+0x8B, 0x12, 0x24, 0x49, 0x80, 0x80, 0x2D, 0x49,
+0x60, 0x80, 0x20, 0x03, 0x27, 0x01, 0x12, 0x38,
+0x20, 0x03, 0x3D, 0x01, 0x12, 0x20, 0x10, 0x20,
+0xB0, 0x03, 0xE9, 0x12, 0xB6, 0x20, 0x0B, 0x00,
+0x01, 0x48, 0xBC, 0x80, 0x09, 0x48, 0x9D, 0x80,
+0x90, 0x18, 0xB0, 0x1A, 0x0B, 0x17, 0x00, 0x03,
+0x8D, 0x02, 0xB0, 0x20, 0xB6, 0x08, 0x01, 0x0E,
+0x3B, 0x13, 0x00, 0x03, 0x92, 0x02, 0x01, 0x21,
+0x00, 0x0D, 0x92, 0x02, 0x00, 0x03, 0x93, 0x02,
+0x01, 0x21, 0x00, 0x0D, 0x93, 0x02, 0x00, 0x4E,
+0x2A, 0x01, 0x01, 0x88, 0x76, 0x5A, 0x00, 0x03,
+0x79, 0x16, 0x09, 0x48, 0x2D, 0x80, 0x09, 0x0D,
+0x79, 0x16, 0x00, 0x03, 0x8D, 0x02, 0x01, 0x21,
+0x00, 0x0D, 0x8D, 0x02, 0x0F, 0x88, 0x64, 0x5A,
+0xB0, 0x03, 0xE8, 0x12, 0x60, 0x03, 0x0A, 0x16,
+0x70, 0x03, 0x08, 0x16, 0x30, 0x1A, 0x14, 0x00,
+0x00, 0x0E, 0x03, 0x14, 0x20, 0x03, 0x8A, 0x12,
+0x80, 0x03, 0x09, 0x16, 0x90, 0x03, 0x07, 0x16,
+0xCB, 0x18, 0x1C, 0x00, 0x12, 0x48, 0x0D, 0x88,
+0x70, 0x5B, 0x00, 0x03, 0xD6, 0x00, 0xC0, 0x38,
+0xC1, 0x39, 0x00, 0x03, 0x09, 0x16, 0x80, 0x48,
+0x40, 0x81, 0x00, 0x03, 0x07, 0x16, 0x90, 0x48,
+0x40, 0x80, 0x0C, 0x00, 0x10, 0x48, 0x0D, 0x88,
+0x70, 0x5B, 0xC1, 0x21, 0x0C, 0x00, 0x10, 0x48,
+0x0D, 0x88, 0x70, 0x5B, 0x97, 0x48, 0x50, 0x80,
+0xC1, 0x21, 0x0C, 0x00, 0x10, 0x48, 0x0D, 0x88,
+0x70, 0x5B, 0xCB, 0x18, 0xC1, 0x39, 0x00, 0x03,
+0x07, 0x16, 0x90, 0x48, 0x40, 0x80, 0x0C, 0x00,
+0x10, 0x48, 0x0D, 0x88, 0x70, 0x5B, 0x97, 0x48,
+0x50, 0x80, 0xC2, 0x21, 0x0C, 0x00, 0x10, 0x48,
+0x0C, 0x88, 0x70, 0x5B, 0xCB, 0x18, 0x00, 0x03,
+0xD6, 0x00, 0xC0, 0x20, 0xC1, 0x39, 0x86, 0x48,
+0x40, 0x81, 0x00, 0x03, 0x07, 0x16, 0x90, 0x48,
+0x40, 0x80, 0x0C, 0x00, 0x10, 0x48, 0x0C, 0x88,
+0x70, 0x5B, 0xC1, 0x21, 0x0C, 0x00, 0x10, 0x48,
+0x0C, 0x88, 0x70, 0x5B, 0x97, 0x48, 0x50, 0x80,
+0xC1, 0x21, 0x0C, 0x00, 0x10, 0x48, 0x0C, 0x88,
+0x70, 0x5B, 0xA0, 0x03, 0x03, 0x14, 0xA3, 0x48,
+0xE0, 0x80, 0xD0, 0x1A, 0xEF, 0x13, 0xA0, 0x03,
+0x03, 0x14, 0xDA, 0x20, 0x00, 0x03, 0xE8, 0x12,
+0xCB, 0x18, 0xC0, 0x38, 0xDC, 0x08, 0xA1, 0x21,
+0x0A, 0x0D, 0x03, 0x14, 0x1F, 0x83, 0x00, 0x0E,
+0x3A, 0x13, 0x10, 0x1A, 0xEF, 0x13, 0xA1, 0x00,
+0xC0, 0x03, 0xE8, 0x12, 0xCA, 0x20, 0xDC, 0x00,
+0x01, 0x0E, 0x39, 0x13, 0x10, 0x1A, 0xEF, 0x13,
+0xA0, 0x03, 0x39, 0x13, 0x1A, 0x20, 0xA1, 0x00,
+0xC0, 0x03, 0xE8, 0x12, 0xCA, 0x20, 0xAC, 0x00,
+0xAD, 0x48, 0x5A, 0x80, 0xDA, 0x18, 0xA0, 0x03,
+0x39, 0x13, 0x0A, 0x0D, 0x3A, 0x13, 0xA0, 0x03,
+0x39, 0x13, 0xA1, 0x21, 0x0A, 0x0D, 0x39, 0x13,
+0xA3, 0x48, 0x81, 0x86, 0xAB, 0x00, 0xDA, 0x48,
+0xBA, 0x80, 0x10, 0x1A, 0xEF, 0x13, 0xA0, 0x03,
+0x3A, 0x13, 0x1A, 0x20, 0xC0, 0x03, 0xE8, 0x12,
+0xCB, 0x38, 0xC0, 0x31, 0x1C, 0x08, 0x0F, 0x80,
+0xB1, 0x21, 0x91, 0x21, 0x97, 0x48, 0x2D, 0x80,
+0x90, 0x03, 0x07, 0x16, 0x1D, 0x80, 0x81, 0x21,
+0x86, 0x48, 0x0D, 0x88, 0xE0, 0x5A, 0xFF, 0xA0,
+0x30, 0x03, 0x03, 0x14, 0x31, 0x49, 0xFD, 0xA0,
+0x00, 0x0E, 0x3A, 0x13, 0x20, 0x1A, 0xEF, 0x13,
+0x90, 0x03, 0x3A, 0x13, 0x29, 0x20, 0x82, 0x00,
+0xC0, 0x03, 0xE8, 0x12, 0xC8, 0x20, 0xDC, 0x00,
+0x91, 0x21, 0x10, 0x1A, 0xEF, 0x13, 0x19, 0x20,
+0x71, 0x00, 0xB0, 0x03, 0xE8, 0x12, 0xB7, 0x20,
+0xAB, 0x00, 0xAD, 0x48, 0x4C, 0x80, 0x27, 0x08,
+0x18, 0x08, 0xDA, 0x18, 0x87, 0x18, 0x91, 0x21,
+0x93, 0x48, 0xF1, 0x86, 0xA0, 0x03, 0x3A, 0x13,
+0xA1, 0x21, 0x0A, 0x0D, 0x3A, 0x13, 0xA1, 0x21,
+0xA3, 0x48, 0xCC, 0x85, 0xFF, 0xA0, 0x30, 0x03,
+0x01, 0x13, 0x40, 0x03, 0xFF, 0x12, 0x50, 0x03,
+0x02, 0x13, 0x60, 0x03, 0x00, 0x13, 0x91, 0x19,
+0x70, 0x03, 0x03, 0x14, 0x00, 0x0E, 0x3A, 0x13,
+0xD0, 0x1A, 0xEF, 0x13, 0xAD, 0x00, 0xA0, 0x4A,
+0xFF, 0xFF, 0x40, 0x82, 0x0A, 0x18, 0x20, 0x03,
+0xD6, 0x00, 0x0F, 0x98, 0xE7, 0x54, 0x10, 0x03,
+0x1A, 0xF9, 0x03, 0x48, 0xBC, 0x81, 0x05, 0x48,
+0x9A, 0x81, 0x14, 0x48, 0x7C, 0x81, 0x16, 0x48,
+0x5A, 0x81, 0x00, 0x4E, 0x0B, 0x13, 0x9C, 0x80,
+0x00, 0x4E, 0x0C, 0x13, 0x6A, 0x80, 0x10, 0x4E,
+0x09, 0x13, 0x3C, 0x80, 0x10, 0x4E, 0x0A, 0x13,
+0x9D, 0x80, 0xC0, 0x03, 0xE8, 0x12, 0xCA, 0x20,
+0x0C, 0x00, 0x00, 0x49, 0x30, 0x80, 0x08, 0x48,
+0x1C, 0x80, 0x91, 0x21, 0xD1, 0x21, 0xA0, 0x03,
+0x3A, 0x13, 0xA1, 0x21, 0x0A, 0x0D, 0x3A, 0x13,
+0xA7, 0x48, 0x01, 0x85, 0xFF, 0xA0, 0x30, 0x03,
+0xFC, 0x12, 0x40, 0x03, 0xFA, 0x12, 0x50, 0x03,
+0xFD, 0x12, 0x60, 0x03, 0xFB, 0x12, 0x90, 0x19,
+0x70, 0x03, 0x03, 0x14, 0x00, 0x0E, 0x3A, 0x13,
+0xD0, 0x1A, 0xEF, 0x13, 0xAD, 0x00, 0xA0, 0x4A,
+0xFF, 0xFF, 0x20, 0x82, 0x0A, 0x18, 0x20, 0x03,
+0xD6, 0x00, 0x0F, 0x98, 0xE7, 0x54, 0x10, 0x03,
+0x1A, 0xF9, 0x03, 0x48, 0x9C, 0x81, 0x05, 0x48,
+0x7A, 0x81, 0x14, 0x48, 0x5C, 0x81, 0x16, 0x48,
+0x3A, 0x81, 0xC0, 0x03, 0xE8, 0x12, 0xCA, 0x20,
+0x0C, 0x00, 0x00, 0x49, 0xD0, 0x80, 0x08, 0x48,
+0x4B, 0x80, 0x00, 0x1A, 0xFF, 0xFF, 0xD0, 0x08,
+0x7F, 0x80, 0x00, 0x1A, 0xFF, 0xFF, 0xD0, 0x08,
+0x91, 0x19, 0x0A, 0x0D, 0xEC, 0x13, 0xFF, 0xA0,
+0xD1, 0x21, 0xA0, 0x03, 0x3A, 0x13, 0xA1, 0x21,
+0x0A, 0x0D, 0x3A, 0x13, 0xA7, 0x48, 0x21, 0x85,
+0xFF, 0xA0, 0x05, 0x0D, 0x18, 0xF9, 0x00, 0x0E,
+0x19, 0xF9, 0x0C, 0x0D, 0x1A, 0xF9, 0xFF, 0xA0,
+0x00, 0x03, 0x10, 0x16, 0x20, 0x03, 0x0F, 0x16,
+0x10, 0x03, 0x12, 0x16, 0x30, 0x03, 0x11, 0x16,
+0xFF, 0xA0, 0xD0, 0x03, 0x03, 0x14, 0xD2, 0x49,
+0xFD, 0xA0, 0xC0, 0x03, 0xD6, 0x00, 0x00, 0x0E,
+0x39, 0x13, 0x01, 0x0E, 0x3A, 0x13, 0xB0, 0x1A,
+0xEF, 0x13, 0x00, 0x03, 0x39, 0x13, 0xB0, 0x20,
+0x5B, 0x00, 0x0F, 0x98, 0x25, 0x5C, 0xA0, 0x03,
+0x1A, 0xF9, 0x0A, 0x0D, 0x0F, 0x16, 0xA0, 0x03,
+0x18, 0xF9, 0x0A, 0x0D, 0x12, 0x16, 0xB0, 0x1A,
+0xEF, 0x13, 0x00, 0x03, 0x3A, 0x13, 0xB0, 0x20,
+0x5B, 0x00, 0x0F, 0x98, 0x25, 0x5C, 0xA0, 0x03,
+0x1A, 0xF9, 0x0A, 0x0D, 0x11, 0x16, 0xA0, 0x03,
+0x18, 0xF9, 0x0A, 0x0D, 0x10, 0x16, 0x00, 0x03,
+0x10, 0x16, 0x10, 0x03, 0x12, 0x16, 0x01, 0x38,
+0x0F, 0x51, 0x10, 0x80, 0x00, 0x31, 0x10, 0x03,
+0x0F, 0x16, 0x20, 0x03, 0x11, 0x16, 0x12, 0x38,
+0x1F, 0x51, 0x10, 0x80, 0x10, 0x31, 0xA0, 0x19,
+0x01, 0x48, 0x1A, 0x80, 0xA1, 0x19, 0x01, 0x20,
+0x16, 0x19, 0x01, 0x48, 0x0A, 0x88, 0xD7, 0x5C,
+0x0F, 0x98, 0x2C, 0x5C, 0x01, 0x48, 0x4D, 0x80,
+0x10, 0x03, 0x10, 0x16, 0x00, 0x03, 0x12, 0x16,
+0x23, 0x48, 0x4D, 0x80, 0x30, 0x03, 0x0F, 0x16,
+0x20, 0x03, 0x11, 0x16, 0x90, 0x19, 0x40, 0x03,
+0x03, 0x14, 0x50, 0x19, 0x60, 0x03, 0x39, 0x13,
+0x65, 0x48, 0x90, 0x82, 0x60, 0x03, 0x3A, 0x13,
+0x65, 0x48, 0x50, 0x82, 0x60, 0x1A, 0xEF, 0x13,
+0x65, 0x20, 0x56, 0x00, 0x0F, 0x98, 0x25, 0x5C,
+0x70, 0x03, 0x1A, 0xF9, 0x80, 0x03, 0x18, 0xF9,
+0xA0, 0x49, 0xD1, 0x80, 0x80, 0x48, 0x7D, 0x81,
+0x81, 0x48, 0x5B, 0x81, 0xA3, 0x18, 0xA7, 0x38,
+0xAF, 0x51, 0x10, 0x80, 0xA0, 0x31, 0xA6, 0x49,
+0xED, 0x80, 0x91, 0x19, 0xCF, 0x80, 0x72, 0x48,
+0xAD, 0x80, 0x73, 0x48, 0x8B, 0x80, 0xA1, 0x18,
+0xA8, 0x38, 0xAF, 0x51, 0x10, 0x80, 0xA0, 0x31,
+0xA4, 0x49, 0x1D, 0x80, 0x91, 0x19, 0x51, 0x21,
+0x54, 0x48, 0x0C, 0x85, 0x90, 0x49, 0xB0, 0x81,
+0x0F, 0x98, 0x2C, 0x5C, 0x01, 0x20, 0x01, 0x79,
+0x23, 0x20, 0x21, 0x79, 0x0F, 0x98, 0x16, 0x5D,
+0x0F, 0x98, 0x2C, 0x5C, 0x40, 0x19, 0x01, 0x20,
+0x01, 0x51, 0x20, 0x80, 0x01, 0x21, 0x41, 0x19,
+0x23, 0x20, 0x21, 0x51, 0x20, 0x80, 0x21, 0x21,
+0x41, 0x19, 0x40, 0x49, 0x40, 0x80, 0x01, 0x79,
+0x21, 0x79, 0x0F, 0x98, 0x16, 0x5D, 0x00, 0x03,
+0x3A, 0x13, 0x01, 0x21, 0x00, 0x0D, 0x3A, 0x13,
+0x0D, 0x48, 0x0C, 0x88, 0x3F, 0x5C, 0x00, 0x03,
+0x39, 0x13, 0x01, 0x21, 0x00, 0x0D, 0x39, 0x13,
+0x1D, 0x18, 0x11, 0x39, 0x01, 0x48, 0xFB, 0xA0,
+0x01, 0x21, 0x00, 0x0D, 0x3A, 0x13, 0x0F, 0x88,
+0x3F, 0x5C, 0xFF, 0xA0, 0x4B, 0x00, 0xA4, 0x08,
+0xB9, 0x18, 0x74, 0x48, 0xFB, 0xA0, 0x74, 0x18,
+0xFF, 0xA0, 0x5A, 0x00, 0x67, 0x18, 0x65, 0x38,
+0x06, 0x0D, 0x10, 0xF9, 0x00, 0x0E, 0x11, 0xF9,
+0x00, 0x0E, 0x13, 0xF9, 0x04, 0x0D, 0x12, 0xF9,
+0xFF, 0xFF, 0xFF, 0xFF, 0x40, 0x03, 0x10, 0xF9,
+0x50, 0x03, 0x11, 0xF9, 0x04, 0x0D, 0x18, 0xF9,
+0x05, 0x0D, 0x19, 0xF9, 0x40, 0x1A, 0x64, 0x00,
+0x04, 0x0D, 0x1A, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF,
+0x40, 0x03, 0x18, 0xF9, 0x5B, 0x00, 0x54, 0x20,
+0xB5, 0x08, 0xFF, 0xA0, 0x30, 0x19, 0xC0, 0x03,
+0xD6, 0x00, 0x10, 0x18, 0x1C, 0x58, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x1E, 0x12, 0x20,
+0x40, 0x03, 0x0A, 0x16, 0x50, 0x03, 0x08, 0x16,
+0x60, 0x03, 0x09, 0x16, 0x70, 0x03, 0x07, 0x16,
+0x06, 0x48, 0x11, 0x80, 0x30, 0xC1, 0x04, 0x48,
+0x11, 0x80, 0x31, 0xC1, 0x27, 0x48, 0x11, 0x80,
+0x32, 0xC1, 0x25, 0x48, 0x11, 0x80, 0x33, 0xC1,
+0xA0, 0x1A, 0x13, 0x16, 0x98, 0x19, 0xA0, 0x0B,
+0xA1, 0x21, 0x91, 0x39, 0x90, 0x49, 0xBA, 0x87,
+0x70, 0x1A, 0xFF, 0xFF, 0xA0, 0x1A, 0x13, 0x16,
+0xB0, 0x1A, 0xE0, 0x04, 0x9B, 0x18, 0x91, 0x20,
+0xB9, 0x18, 0x30, 0x51, 0x61, 0x80, 0x32, 0x51,
+0x41, 0x80, 0xBC, 0x38, 0xB1, 0x39, 0x0F, 0x98,
+0xEE, 0x5C, 0xA1, 0x21, 0x30, 0x51, 0x31, 0x80,
+0xBC, 0x38, 0x0F, 0x98, 0xEE, 0x5C, 0xA1, 0x21,
+0x30, 0x51, 0x61, 0x80, 0x33, 0x51, 0x41, 0x80,
+0xBC, 0x38, 0xB1, 0x21, 0x0F, 0x98, 0xEE, 0x5C,
+0xA1, 0x21, 0x32, 0x51, 0x31, 0x80, 0xB1, 0x39,
+0x0F, 0x98, 0xEE, 0x5C, 0xA1, 0x21, 0x4B, 0x00,
+0xA4, 0x08, 0xA1, 0x21, 0x33, 0x51, 0x31, 0x80,
+0xB1, 0x21, 0x0F, 0x98, 0xEE, 0x5C, 0xA1, 0x21,
+0x31, 0x51, 0x61, 0x80, 0x32, 0x51, 0x41, 0x80,
+0xBC, 0x20, 0xB1, 0x39, 0x0F, 0x98, 0xEE, 0x5C,
+0xA1, 0x21, 0x31, 0x51, 0x31, 0x80, 0xBC, 0x20,
+0x0F, 0x98, 0xEE, 0x5C, 0xA1, 0x21, 0x31, 0x51,
+0x61, 0x80, 0x33, 0x51, 0x41, 0x80, 0xBC, 0x20,
+0xB1, 0x21, 0x0F, 0x98, 0xEE, 0x5C, 0x70, 0x49,
+0xFD, 0xA0, 0xA0, 0x1A, 0x13, 0x16, 0xB0, 0x1A,
+0xA0, 0x0B, 0x9B, 0x18, 0x91, 0x20, 0xB9, 0x18,
+0xA4, 0x21, 0x40, 0x03, 0x47, 0x01, 0x0F, 0x98,
+0xF5, 0x5C, 0xA0, 0x1A, 0x13, 0x16, 0x30, 0x51,
+0xC1, 0x80, 0x32, 0x51, 0xA1, 0x80, 0xBC, 0x38,
+0xB1, 0x39, 0x40, 0x03, 0x47, 0x01, 0x50, 0x1A,
+0x14, 0x00, 0x45, 0x38, 0x0F, 0x98, 0xF5, 0x5C,
+0xB9, 0x18, 0xA1, 0x21, 0x30, 0x51, 0x81, 0x80,
+0xBC, 0x38, 0x40, 0x03, 0x47, 0x01, 0x5A, 0x19,
+0x45, 0x38, 0x0F, 0x98, 0xF5, 0x5C, 0xB9, 0x18,
+0xA1, 0x21, 0x30, 0x51, 0xC1, 0x80, 0x33, 0x51,
+0xA1, 0x80, 0xBC, 0x38, 0xB1, 0x21, 0x40, 0x03,
+0x47, 0x01, 0x50, 0x1A, 0x14, 0x00, 0x45, 0x38,
+0x0F, 0x98, 0xF5, 0x5C, 0xB9, 0x18, 0xA1, 0x21,
+0x32, 0x51, 0x81, 0x80, 0xB1, 0x39, 0x40, 0x03,
+0x47, 0x01, 0x5A, 0x19, 0x45, 0x38, 0x0F, 0x98,
+0xF5, 0x5C, 0xB9, 0x18, 0xA2, 0x21, 0x33, 0x51,
+0x81, 0x80, 0xB1, 0x21, 0x40, 0x03, 0x47, 0x01,
+0x5A, 0x19, 0x45, 0x38, 0x0F, 0x98, 0xF5, 0x5C,
+0xB9, 0x18, 0xA1, 0x21, 0x31, 0x51, 0xC1, 0x80,
+0x32, 0x51, 0xA1, 0x80, 0xBC, 0x20, 0xB1, 0x39,
+0x40, 0x03, 0x47, 0x01, 0x50, 0x1A, 0x14, 0x00,
+0x45, 0x38, 0x0F, 0x98, 0xF5, 0x5C, 0xB9, 0x18,
+0xA1, 0x21, 0x31, 0x51, 0x81, 0x80, 0xBC, 0x20,
+0x40, 0x03, 0x47, 0x01, 0x5A, 0x19, 0x45, 0x38,
+0x0F, 0x98, 0xF5, 0x5C, 0xB9, 0x18, 0xA1, 0x21,
+0x31, 0x51, 0xC1, 0x80, 0x33, 0x51, 0xA1, 0x80,
+0xBC, 0x20, 0xB1, 0x21, 0x40, 0x03, 0x47, 0x01,
+0x50, 0x1A, 0x14, 0x00, 0x45, 0x38, 0x0F, 0x98,
+0xF5, 0x5C, 0xB9, 0x18, 0xFF, 0xA0, 0x00, 0x0E,
+0x13, 0x14, 0x00, 0x03, 0x3D, 0x16, 0x01, 0x39,
+0x00, 0x0D, 0x3D, 0x16, 0x00, 0x49, 0x8A, 0x80,
+0x00, 0x0E, 0x3D, 0x16, 0x00, 0x03, 0x38, 0x01,
+0x00, 0x0D, 0x3A, 0x16, 0x00, 0x0E, 0x3C, 0x16,
+0x00, 0x03, 0xCB, 0x00, 0x10, 0x03, 0x30, 0x17,
+0x10, 0x49, 0xA0, 0x80, 0x00, 0x03, 0x3A, 0x01,
+0x10, 0x1A, 0x14, 0x00, 0x01, 0x0D, 0x3D, 0x16,
+0x04, 0x0E, 0x3A, 0x16, 0x02, 0x0E, 0x3C, 0x16,
+0x00, 0x0D, 0x42, 0x17, 0x00, 0x0E, 0x30, 0x17,
+0x00, 0x0E, 0x85, 0x12, 0x00, 0x0E, 0x91, 0x02,
+0x10, 0x03, 0x77, 0x16, 0x00, 0x03, 0x8A, 0x12,
+0x10, 0x48, 0xFC, 0xA0, 0xC0, 0x1A, 0xA0, 0x0B,
+0x0C, 0x0D, 0xE8, 0x12, 0x0F, 0x98, 0xD0, 0x5A,
+0x00, 0x03, 0x03, 0x14, 0x00, 0x49, 0xF0, 0xA0,
+0x00, 0x03, 0x93, 0x01, 0x00, 0x51, 0xA1, 0x80,
+0xB0, 0x1A, 0xE0, 0x04, 0xC0, 0x1A, 0xA0, 0x0B,
+0xA0, 0x03, 0x8B, 0x02, 0x0B, 0x01, 0xC0, 0x09,
+0xA1, 0x39, 0xC1, 0x87, 0x00, 0x03, 0x92, 0x01,
+0x0F, 0x51, 0x20, 0x80, 0x0F, 0x98, 0x35, 0x5C,
+0x0F, 0x98, 0x7C, 0x5B, 0x00, 0x0E, 0xF8, 0x12,
+0x00, 0x03, 0x09, 0x16, 0x00, 0x0D, 0xFC, 0x12,
+0x00, 0x03, 0x07, 0x16, 0x00, 0x0D, 0xFA, 0x12,
+0x00, 0x03, 0x0A, 0x16, 0x00, 0x0D, 0xFD, 0x12,
+0x00, 0x03, 0x08, 0x16, 0x00, 0x0D, 0xFB, 0x12,
+0xC0, 0x1A, 0xA0, 0x0B, 0x0C, 0x0D, 0xE8, 0x12,
+0x00, 0x03, 0xD6, 0x00, 0x00, 0x0D, 0x07, 0x13,
+0x80, 0x03, 0x8A, 0x12, 0x0F, 0x98, 0xE7, 0x5B,
+0x90, 0x49, 0x00, 0x88, 0xDC, 0x5F, 0xC0, 0x03,
+0xE8, 0x12, 0xA0, 0x03, 0xEC, 0x13, 0xCA, 0x20,
+0x0C, 0x00, 0x00, 0x0D, 0x74, 0x16, 0x10, 0x03,
+0xCD, 0x00, 0x0F, 0x98, 0x95, 0x64, 0x10, 0x03,
+0x8A, 0x12, 0x01, 0x48, 0x1B, 0x80, 0x01, 0x18,
+0x00, 0x0D, 0x75, 0x16, 0xB0, 0x1A, 0xA0, 0x0B,
+0x0B, 0x0D, 0x8C, 0x16, 0xC0, 0x03, 0xEC, 0x13,
+0x0F, 0x98, 0xA0, 0x58, 0xA0, 0x03, 0xFC, 0x12,
+0x0A, 0x0D, 0x01, 0x13, 0x0A, 0x0D, 0x0B, 0x13,
+0xA0, 0x03, 0xFD, 0x12, 0x0A, 0x0D, 0x02, 0x13,
+0x0A, 0x0D, 0x0C, 0x13, 0xA0, 0x03, 0xFA, 0x12,
+0x0A, 0x0D, 0xFF, 0x12, 0x0A, 0x0D, 0x09, 0x13,
+0xA0, 0x03, 0xFB, 0x12, 0x0A, 0x0D, 0x00, 0x13,
+0x0A, 0x0D, 0x0A, 0x13, 0x0F, 0x98, 0xD8, 0x58,
+0xA0, 0x03, 0xFC, 0x12, 0xB0, 0x03, 0xFD, 0x12,
+0xBA, 0x38, 0xB1, 0x21, 0xA0, 0x03, 0xFA, 0x12,
+0xC0, 0x03, 0xFB, 0x12, 0xCA, 0x38, 0xC1, 0x21,
+0xAB, 0x18, 0xAC, 0x58, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xA0, 0x1E, 0x00, 0x03, 0x13, 0x14,
+0x10, 0x1A, 0x14, 0x14, 0x10, 0x20, 0x20, 0x03,
+0x74, 0x16, 0x12, 0x08, 0x10, 0x1A, 0x28, 0x14,
+0x10, 0x20, 0x1A, 0x08, 0x10, 0x1A, 0x3C, 0x14,
+0x10, 0x20, 0x1B, 0x08, 0xBC, 0x48, 0x0A, 0xB0,
+0x1C, 0x08, 0x01, 0x21, 0x00, 0x0D, 0x13, 0x14,
+0xA1, 0x79, 0x00, 0x03, 0xFE, 0x12, 0x0A, 0x48,
+0x9D, 0x81, 0xB0, 0x4E, 0xC7, 0x00, 0x0B, 0x88,
+0x9F, 0x5F, 0xC0, 0x4E, 0xC8, 0x00, 0x0B, 0x88,
+0x9F, 0x5F, 0xB0, 0x03, 0xFE, 0x12, 0xB0, 0x4E,
+0xC9, 0x00, 0x0B, 0x88, 0x9F, 0x5F, 0xB0, 0x4E,
+0xCC, 0x00, 0x0D, 0x88, 0x9F, 0x5F, 0x00, 0x03,
+0xCA, 0x00, 0x10, 0x03, 0x74, 0x16, 0x10, 0x48,
+0x0D, 0x88, 0x9F, 0x5F, 0xB0, 0x1A, 0xA0, 0x0B,
+0x0B, 0x0D, 0x8C, 0x16, 0x0F, 0x98, 0xB2, 0x57,
+0x80, 0x03, 0x75, 0x16, 0x0F, 0x98, 0xA7, 0x5B,
+0x91, 0x49, 0x0D, 0x88, 0x9F, 0x5F, 0x00, 0x0E,
+0x0E, 0x13, 0x00, 0x0E, 0x0D, 0x13, 0x0F, 0x98,
+0xD8, 0x58, 0x10, 0x03, 0x0E, 0x13, 0xC0, 0x1A,
+0x0F, 0x13, 0xC1, 0x20, 0x00, 0x03, 0xFE, 0x12,
+0xC0, 0x08, 0xC0, 0x1A, 0x14, 0x13, 0xC1, 0x20,
+0x00, 0x03, 0x09, 0x13, 0xC0, 0x08, 0xC0, 0x1A,
+0x19, 0x13, 0xC1, 0x20, 0x00, 0x03, 0x0A, 0x13,
+0xC0, 0x08, 0xC0, 0x1A, 0x1E, 0x13, 0xC1, 0x20,
+0x00, 0x03, 0x0B, 0x13, 0xC0, 0x08, 0xC0, 0x1A,
+0x23, 0x13, 0xC1, 0x20, 0x00, 0x03, 0x0C, 0x13,
+0xC0, 0x08, 0x11, 0x21, 0x01, 0x0D, 0x0E, 0x13,
+0x15, 0x49, 0x8B, 0x83, 0xA0, 0x03, 0x01, 0x13,
+0x0A, 0x0D, 0xFC, 0x12, 0xA0, 0x03, 0x02, 0x13,
+0x0A, 0x0D, 0xFD, 0x12, 0xA0, 0x03, 0xFF, 0x12,
+0x0A, 0x0D, 0xFA, 0x12, 0xA0, 0x03, 0x00, 0x13,
+0x0A, 0x0D, 0xFB, 0x12, 0xC0, 0x1A, 0xA0, 0x0B,
+0x0C, 0x0D, 0xE8, 0x12, 0x00, 0x03, 0xD6, 0x00,
+0x00, 0x0D, 0x07, 0x13, 0x80, 0x03, 0x75, 0x16,
+0x0F, 0x98, 0xE7, 0x5B, 0x90, 0x49, 0xA0, 0x81,
+0xC0, 0x1A, 0xA0, 0x0B, 0xA0, 0x03, 0xEC, 0x13,
+0xCA, 0x20, 0x0C, 0x00, 0x00, 0x0D, 0x74, 0x16,
+0xB0, 0x1A, 0xA0, 0x0B, 0x0B, 0x0D, 0x8C, 0x16,
+0xC0, 0x03, 0xEC, 0x13, 0x0F, 0x98, 0xA0, 0x58,
+0xB0, 0x1A, 0xA0, 0x0B, 0x0B, 0x0D, 0x8C, 0x16,
+0x0F, 0x98, 0xB2, 0x57, 0x0F, 0x98, 0xD8, 0x58,
+0x0F, 0x88, 0xF9, 0x5E, 0x10, 0x03, 0x0D, 0x13,
+0xC0, 0x1A, 0x0F, 0x13, 0xC1, 0x20, 0x0C, 0x00,
+0x00, 0x0D, 0xFE, 0x12, 0x20, 0x03, 0x0E, 0x13,
+0x21, 0x49, 0xDD, 0x83, 0xC0, 0x1A, 0x14, 0x13,
+0xC1, 0x20, 0x0C, 0x00, 0x00, 0x0D, 0x09, 0x13,
+0xC0, 0x1A, 0x19, 0x13, 0xC1, 0x20, 0x0C, 0x00,
+0x00, 0x0D, 0x0A, 0x13, 0xC0, 0x1A, 0x1E, 0x13,
+0xC1, 0x20, 0x0C, 0x00, 0x00, 0x0D, 0x0B, 0x13,
+0xC0, 0x1A, 0x23, 0x13, 0xC1, 0x20, 0x0C, 0x00,
+0x00, 0x0D, 0x0C, 0x13, 0x0F, 0x98, 0x13, 0x60,
+0x0F, 0x98, 0x93, 0x60, 0xB0, 0x1A, 0xA0, 0x0B,
+0x0B, 0x0D, 0x8C, 0x16, 0x00, 0x03, 0x06, 0x18,
+0x00, 0x49, 0xE1, 0x80, 0xD0, 0x1A, 0x04, 0x14,
+0xA0, 0x03, 0x91, 0x02, 0xDA, 0x20, 0xC0, 0x03,
+0x90, 0x02, 0xDC, 0x08, 0xA1, 0x21, 0x0A, 0x0D,
+0x91, 0x02, 0xAF, 0x49, 0x0B, 0x88, 0xDC, 0x5F,
+0x10, 0x03, 0x0E, 0x13, 0x00, 0x03, 0x0D, 0x13,
+0x01, 0x21, 0x00, 0x0D, 0x0D, 0x13, 0x01, 0x48,
+0x0C, 0x88, 0x56, 0x5F, 0x9F, 0x82, 0x00, 0x0E,
+0xF8, 0x12, 0x00, 0x03, 0x01, 0x13, 0x00, 0x0D,
+0x0B, 0x13, 0x00, 0x03, 0x02, 0x13, 0x00, 0x0D,
+0x0C, 0x13, 0x00, 0x03, 0xFF, 0x12, 0x00, 0x0D,
+0x09, 0x13, 0x00, 0x03, 0x00, 0x13, 0x00, 0x0D,
+0x0A, 0x13, 0x0F, 0x98, 0x93, 0x60, 0x00, 0x03,
+0x06, 0x18, 0x00, 0x49, 0x11, 0x81, 0xB0, 0x1A,
+0xA0, 0x0B, 0x0B, 0x0D, 0x8C, 0x16, 0xD0, 0x1A,
+0x04, 0x14, 0xA0, 0x03, 0x91, 0x02, 0xDA, 0x20,
+0xC0, 0x03, 0x90, 0x02, 0xDC, 0x08, 0xA1, 0x21,
+0x0A, 0x0D, 0x91, 0x02, 0xAF, 0x49, 0x4B, 0x81,
+0xA0, 0x03, 0x01, 0x13, 0x0A, 0x0D, 0x05, 0x13,
+0xA0, 0x03, 0x02, 0x13, 0x0A, 0x0D, 0x06, 0x13,
+0xA0, 0x03, 0xFF, 0x12, 0x0A, 0x0D, 0x03, 0x13,
+0xA0, 0x03, 0x00, 0x13, 0x0A, 0x0D, 0x04, 0x13,
+0x0F, 0x98, 0x04, 0x59, 0x0F, 0x88, 0x4C, 0x5E,
+0xA0, 0x03, 0x91, 0x02, 0x0A, 0x0D, 0x85, 0x12,
+0xFF, 0xA0, 0x60, 0x03, 0x0E, 0x13, 0x70, 0x03,
+0x0D, 0x13, 0x71, 0x21, 0x76, 0x48, 0xFB, 0xA0,
+0x00, 0x1A, 0x14, 0x13, 0x07, 0x20, 0x30, 0x00,
+0x00, 0x1A, 0x19, 0x13, 0x07, 0x20, 0x40, 0x00,
+0x00, 0x1A, 0x1E, 0x13, 0x07, 0x20, 0x10, 0x00,
+0x00, 0x1A, 0x23, 0x13, 0x07, 0x20, 0x20, 0x00,
+0xA1, 0x48, 0x5C, 0x81, 0xA2, 0x48, 0x3A, 0x81,
+0x83, 0x48, 0x1C, 0x81, 0x84, 0x48, 0xFA, 0x80,
+0x00, 0x03, 0xD6, 0x00, 0x0F, 0x98, 0x59, 0x54,
+0x00, 0x1E, 0x08, 0x20, 0x10, 0x1A, 0xA0, 0x0B,
+0x10, 0x20, 0x10, 0x0B, 0x10, 0x1A, 0xE0, 0x04,
+0x10, 0x20, 0x10, 0x0B, 0xFF, 0xA0, 0x71, 0x21,
+0x76, 0x48, 0x6C, 0x85, 0xFF, 0xA0, 0xA0, 0x03,
+0x0B, 0x13, 0x80, 0x03, 0x09, 0x13, 0x90, 0x03,
+0x0A, 0x13, 0xB0, 0x03, 0x0C, 0x13, 0x0F, 0x98,
+0xE1, 0x5F, 0x81, 0x21, 0x89, 0x48, 0xBD, 0x87,
+0xA1, 0x21, 0xAB, 0x48, 0x2D, 0x87, 0xFF, 0xA0,
+0x5C, 0x18, 0x4A, 0x18, 0x00, 0x19, 0x10, 0x19,
+0x2C, 0x01, 0x3C, 0x01, 0x0F, 0x98, 0x61, 0x54,
+0x00, 0x03, 0x31, 0x17, 0x10, 0x03, 0x32, 0x17,
+0x90, 0x49, 0x20, 0x80, 0x02, 0x18, 0x13, 0x18,
+0xA1, 0x39, 0x21, 0x87, 0xB0, 0x08, 0xB1, 0x21,
+0xB1, 0x08, 0xC5, 0x18, 0xA4, 0x18, 0x4D, 0x18,
+0x00, 0x0E, 0x21, 0x17, 0x00, 0x0E, 0x22, 0x17,
+0x0C, 0x01, 0x1C, 0x01, 0x24, 0x18, 0x0F, 0x98,
+0xBC, 0x54, 0x20, 0x03, 0x21, 0x17, 0x30, 0x03,
+0x22, 0x17, 0x0F, 0x98, 0x9A, 0x54, 0x00, 0x0D,
+0x21, 0x17, 0x01, 0x0D, 0x22, 0x17, 0x41, 0x21,
+0xA1, 0x39, 0xE1, 0x86, 0x00, 0x03, 0x21, 0x17,
+0x10, 0x03, 0x22, 0x17, 0x20, 0x1A, 0x64, 0x00,
+0x30, 0x19, 0x0F, 0x98, 0xCD, 0x54, 0x20, 0x03,
+0xD0, 0x12, 0x30, 0x03, 0xD1, 0x12, 0x0F, 0x98,
+0x07, 0x55, 0x00, 0x0D, 0x21, 0x17, 0x01, 0x0D,
+0x22, 0x17, 0x20, 0x1A, 0x32, 0x00, 0x30, 0x19,
+0x0F, 0x98, 0x9A, 0x54, 0x20, 0x1A, 0x64, 0x00,
+0x0F, 0x98, 0xFA, 0x54, 0x01, 0x39, 0x70, 0x18,
+0x00, 0x03, 0x21, 0x17, 0x10, 0x03, 0x22, 0x17,
+0x20, 0x1A, 0x80, 0x00, 0x30, 0x19, 0x0F, 0x98,
+0xCD, 0x54, 0x20, 0x1A, 0x64, 0x00, 0x0F, 0x98,
+0xFA, 0x54, 0x00, 0x3A, 0x40, 0x00, 0x27, 0x18,
+0xFF, 0xA0, 0xC0, 0x1A, 0x97, 0x16, 0xA0, 0x1A,
+0x20, 0x00, 0x00, 0x19, 0xC0, 0x09, 0xC0, 0x09,
+0xA1, 0x39, 0xC1, 0x87, 0xC0, 0x1A, 0xD7, 0x16,
+0xA0, 0x1A, 0x12, 0x00, 0xC0, 0x09, 0xC0, 0x09,
+0xA1, 0x39, 0xC1, 0x87, 0xFF, 0xA0, 0x00, 0x0E,
+0x06, 0x18, 0x0F, 0x98, 0x81, 0x60, 0x00, 0x1A,
+0xE0, 0x04, 0x00, 0x0D, 0x8C, 0x16, 0x70, 0x1A,
+0xFF, 0x7F, 0x50, 0x1A, 0x97, 0x16, 0xA0, 0x03,
+0x0B, 0x13, 0xB0, 0x03, 0x8C, 0x16, 0x00, 0x03,
+0xD6, 0x00, 0x0F, 0x98, 0x59, 0x54, 0x00, 0x1E,
+0xB0, 0x20, 0x80, 0x03, 0x09, 0x13, 0x90, 0x03,
+0x0A, 0x13, 0x30, 0x03, 0x0C, 0x13, 0xB8, 0x20,
+0x40, 0x1A, 0xD7, 0x16, 0x48, 0x20, 0x48, 0x20,
+0x10, 0x19, 0x20, 0x19, 0x0B, 0x00, 0x00, 0x49,
+0x8D, 0x80, 0x10, 0x20, 0x20, 0x29, 0xC4, 0x01,
+0xD4, 0x02, 0xC0, 0x20, 0xD0, 0x29, 0x4C, 0x09,
+0x4D, 0x0A, 0x07, 0x48, 0x1B, 0x80, 0x70, 0x18,
+0x42, 0x21, 0xB1, 0x21, 0x81, 0x21, 0x89, 0x48,
+0xDD, 0x86, 0x50, 0x1A, 0x97, 0x16, 0x5A, 0x20,
+0x5A, 0x20, 0x51, 0x09, 0x52, 0x08, 0xA1, 0x21,
+0xA3, 0x48, 0xFD, 0x84, 0x00, 0x03, 0x74, 0x16,
+0x00, 0x0D, 0x29, 0x13, 0x07, 0x0D, 0x28, 0x13,
+0xC0, 0x1A, 0x97, 0x16, 0xA0, 0x1A, 0x20, 0x00,
+0x00, 0x19, 0x10, 0x19, 0x2C, 0x01, 0x3C, 0x01,
+0x0F, 0x98, 0x9A, 0x54, 0xA1, 0x39, 0xA1, 0x87,
+0x00, 0x0D, 0xD0, 0x12, 0x01, 0x0D, 0xD1, 0x12,
+0x01, 0x68, 0x00, 0x49, 0x31, 0x80, 0x01, 0x0E,
+0x06, 0x18, 0xFF, 0xA0, 0xC0, 0x1A, 0x97, 0x16,
+0x00, 0x03, 0x0B, 0x13, 0xC0, 0x20, 0xC0, 0x20,
+0x01, 0x21, 0xD0, 0x18, 0x00, 0x03, 0x0B, 0x13,
+0x10, 0x03, 0x0C, 0x13, 0x10, 0x38, 0x11, 0x21,
+0xA1, 0x18, 0xB0, 0x1A, 0x16, 0x17, 0x0F, 0x98,
+0x24, 0x60, 0x02, 0x0D, 0x32, 0x13, 0x00, 0x0D,
+0xCA, 0x12, 0xC0, 0x1A, 0xD7, 0x16, 0x00, 0x03,
+0x09, 0x13, 0xC0, 0x20, 0xC0, 0x20, 0x01, 0x21,
+0xD0, 0x18, 0x00, 0x03, 0x09, 0x13, 0x10, 0x03,
+0x0A, 0x13, 0x10, 0x38, 0x11, 0x21, 0xA1, 0x18,
+0xB0, 0x1A, 0x18, 0x17, 0x0F, 0x98, 0x24, 0x60,
+0x02, 0x0D, 0x33, 0x13, 0x00, 0x0D, 0xCB, 0x12,
+0x20, 0x03, 0x32, 0x13, 0x00, 0x03, 0x33, 0x13,
+0x10, 0x03, 0xD6, 0x00, 0x0F, 0x98, 0x53, 0x54,
+0x20, 0x1E, 0x02, 0x20, 0x00, 0x0D, 0x90, 0x02,
+0x00, 0x49, 0x3C, 0x80, 0x00, 0x4E, 0x8B, 0x02,
+0x3C, 0x80, 0x01, 0x0E, 0x06, 0x18, 0xFF, 0xA0,
+0x00, 0x0E, 0x98, 0x12, 0x00, 0x0E, 0x99, 0x12,
+0x90, 0x03, 0x90, 0x02, 0x0F, 0x98, 0xBD, 0x68,
+0x10, 0x03, 0x0B, 0x13, 0x00, 0x03, 0x0C, 0x13,
+0x01, 0x38, 0x01, 0x21, 0x20, 0x03, 0x09, 0x13,
+0x10, 0x03, 0x0A, 0x13, 0x12, 0x38, 0x11, 0x21,
+0x0F, 0x98, 0xA7, 0x54, 0x00, 0x03, 0xD0, 0x12,
+0x10, 0x03, 0xD1, 0x12, 0x20, 0x03, 0xD3, 0x00,
+0x0F, 0x98, 0xFA, 0x54, 0x00, 0x49, 0x0A, 0xB0,
+0x01, 0x19, 0x00, 0x0D, 0xCD, 0x12, 0x00, 0x0D,
+0xCE, 0x12, 0x00, 0x03, 0x8C, 0x00, 0x09, 0x51,
+0x51, 0x81, 0x00, 0x03, 0xF8, 0x12, 0x00, 0x49,
+0x10, 0x81, 0x00, 0x03, 0x8C, 0x00, 0x0A, 0x51,
+0xB0, 0x81, 0x00, 0x03, 0x98, 0x12, 0x01, 0x49,
+0x70, 0x81, 0x00, 0x03, 0xCA, 0x12, 0x10, 0x03,
+0xC8, 0x12, 0x01, 0x20, 0x01, 0x79, 0x00, 0x0D,
+0xC8, 0x12, 0x2F, 0x81, 0x00, 0x03, 0x98, 0x12,
+0x01, 0x49, 0xA0, 0x80, 0x00, 0x03, 0x0B, 0x13,
+0x10, 0x03, 0x0C, 0x13, 0x10, 0x38, 0x11, 0x21,
+0x00, 0x03, 0xD1, 0x00, 0x10, 0x48, 0x4D, 0x80,
+0x00, 0x03, 0xCA, 0x12, 0x00, 0x0D, 0xC8, 0x12,
+0x00, 0x03, 0x8C, 0x00, 0x09, 0x51, 0x51, 0x81,
+0x00, 0x03, 0xF8, 0x12, 0x00, 0x49, 0x10, 0x81,
+0x00, 0x03, 0x8C, 0x00, 0x0A, 0x51, 0xB0, 0x81,
+0x00, 0x03, 0x99, 0x12, 0x01, 0x49, 0x70, 0x81,
+0x00, 0x03, 0xCB, 0x12, 0x10, 0x03, 0xC9, 0x12,
+0x01, 0x20, 0x01, 0x79, 0x00, 0x0D, 0xC9, 0x12,
+0x2F, 0x81, 0x00, 0x03, 0x99, 0x12, 0x01, 0x49,
+0xA0, 0x80, 0x00, 0x03, 0x09, 0x13, 0x10, 0x03,
+0x0A, 0x13, 0x10, 0x38, 0x11, 0x21, 0x00, 0x03,
+0xD2, 0x00, 0x10, 0x48, 0x4D, 0x80, 0x00, 0x03,
+0xCB, 0x12, 0x00, 0x0D, 0xC9, 0x12, 0x0F, 0x98,
+0x43, 0x62, 0x0F, 0x88, 0x41, 0x69, 0x00, 0x03,
+0x85, 0x00, 0x02, 0x49, 0xF1, 0xA0, 0x00, 0x03,
+0x16, 0x17, 0x10, 0x03, 0x17, 0x17, 0x20, 0x03,
+0x18, 0x17, 0x30, 0x03, 0x19, 0x17, 0x0F, 0x98,
+0x61, 0x54, 0x90, 0x49, 0x00, 0x81, 0x00, 0x03,
+0x16, 0x17, 0x10, 0x03, 0x17, 0x17, 0x20, 0x03,
+0xCD, 0x12, 0x30, 0x19, 0x0F, 0x98, 0xCD, 0x54,
+0x20, 0x03, 0x18, 0x17, 0x30, 0x03, 0x19, 0x17,
+0x0F, 0x98, 0x07, 0x55, 0xFF, 0x80, 0x00, 0x03,
+0x18, 0x17, 0x10, 0x03, 0x19, 0x17, 0x20, 0x03,
+0xCD, 0x12, 0x30, 0x19, 0x0F, 0x98, 0xCD, 0x54,
+0x20, 0x03, 0x16, 0x17, 0x30, 0x03, 0x17, 0x17,
+0x0F, 0x98, 0x07, 0x55, 0x10, 0x03, 0xCD, 0x12,
+0x11, 0x79, 0x10, 0x49, 0x2A, 0x80, 0x10, 0x03,
+0xCD, 0x12, 0x00, 0x49, 0x1A, 0x80, 0x01, 0x18,
+0x10, 0x03, 0xCD, 0x12, 0x01, 0x48, 0x1D, 0x80,
+0x01, 0x18, 0x00, 0x0D, 0xCF, 0x12, 0xFF, 0xA0,
+0xC0, 0x1A, 0x8F, 0x12, 0x00, 0x03, 0x08, 0x13,
+0x03, 0x59, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0x00, 0x1E, 0xC0, 0x20, 0x80, 0x19, 0x93, 0x19,
+0x00, 0x19, 0x10, 0x19, 0x2C, 0x01, 0x20, 0x49,
+0x2D, 0x80, 0x0F, 0x98, 0x85, 0x54, 0x81, 0x21,
+0x89, 0x48, 0x8C, 0x87, 0x00, 0x0D, 0x14, 0x17,
+0x01, 0x0D, 0x15, 0x17, 0xC0, 0x1A, 0x8F, 0x12,
+0x00, 0x03, 0x08, 0x13, 0x03, 0x59, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x1E, 0xC0, 0x20,
+0x80, 0x19, 0x93, 0x19, 0x41, 0x19, 0x00, 0x0E,
+0x21, 0x17, 0x00, 0x0E, 0x22, 0x17, 0x0C, 0x01,
+0x00, 0x49, 0xED, 0x80, 0x10, 0x19, 0x24, 0x18,
+0x0F, 0x98, 0xBC, 0x54, 0x20, 0x03, 0x21, 0x17,
+0x30, 0x03, 0x22, 0x17, 0x0F, 0x98, 0x9A, 0x54,
+0x00, 0x0D, 0x21, 0x17, 0x01, 0x0D, 0x22, 0x17,
+0x41, 0x21, 0x81, 0x21, 0x89, 0x48, 0xBC, 0x86,
+0x00, 0x03, 0x21, 0x17, 0x10, 0x03, 0x22, 0x17,
+0x20, 0x1A, 0xE8, 0x03, 0x30, 0x19, 0x0F, 0x98,
+0xCD, 0x54, 0x23, 0x19, 0x0F, 0x98, 0xFA, 0x54,
+0x20, 0x03, 0x14, 0x17, 0x30, 0x03, 0x15, 0x17,
+0x0F, 0x98, 0x07, 0x55, 0xFF, 0xA0, 0x00, 0x03,
+0x85, 0x00, 0x02, 0x49, 0xF1, 0xA0, 0x00, 0x0E,
+0xCC, 0x12, 0x00, 0x03, 0x0C, 0x13, 0x10, 0x03,
+0x0B, 0x13, 0x01, 0x48, 0xF0, 0xA0, 0x00, 0x1A,
+0x5A, 0x00, 0x00, 0x0D, 0xCC, 0x12, 0x00, 0x03,
+0x0A, 0x13, 0x10, 0x03, 0x09, 0x13, 0x01, 0x48,
+0xF0, 0xA0, 0x00, 0x19, 0x00, 0x0D, 0x08, 0x13,
+0x0F, 0x98, 0xF0, 0x61, 0x00, 0x0D, 0x1D, 0x17,
+0x01, 0x0D, 0x1E, 0x17, 0x02, 0x19, 0x00, 0x0D,
+0x08, 0x13, 0x0F, 0x98, 0xF0, 0x61, 0x00, 0x0D,
+0x1F, 0x17, 0x01, 0x0D, 0x20, 0x17, 0x00, 0x03,
+0x1D, 0x17, 0x10, 0x03, 0x1E, 0x17, 0x20, 0x1A,
+0x5A, 0x00, 0x0F, 0x98, 0xBC, 0x54, 0x20, 0x03,
+0x1F, 0x17, 0x30, 0x03, 0x20, 0x17, 0x0F, 0x98,
+0x07, 0x55, 0x10, 0x03, 0x92, 0x01, 0x16, 0x51,
+0x40, 0x80, 0x10, 0x1A, 0xB4, 0x00, 0x10, 0x38,
+0x01, 0x18, 0x00, 0x0D, 0xCC, 0x12, 0x00, 0x03,
+0x16, 0x17, 0x10, 0x03, 0x17, 0x17, 0x20, 0x03,
+0x18, 0x17, 0x30, 0x03, 0x19, 0x17, 0x0F, 0x98,
+0x61, 0x54, 0x90, 0x49, 0xF1, 0xA0, 0x00, 0x03,
+0xCC, 0x12, 0x00, 0x4A, 0x5A, 0x00, 0x6B, 0x80,
+0x10, 0x1A, 0x5A, 0x00, 0x10, 0x38, 0x01, 0x0D,
+0xCC, 0x12, 0xFF, 0xA0, 0x10, 0x1A, 0x87, 0x00,
+0x10, 0x38, 0x10, 0x22, 0x87, 0x00, 0x01, 0x18,
+0x00, 0x0D, 0xCC, 0x12, 0xFF, 0xA0, 0x10, 0x03,
+0x85, 0x12, 0x11, 0x49, 0xF0, 0xA0, 0x2A, 0x18,
+0x3A, 0x18, 0x31, 0x21, 0x31, 0x48, 0xFB, 0xA0,
+0x40, 0x1A, 0x04, 0x14, 0x42, 0x20, 0x50, 0x1A,
+0x04, 0x14, 0x53, 0x20, 0x05, 0x00, 0x40, 0x08,
+0x42, 0x18, 0x42, 0x7B, 0x40, 0x22, 0xB0, 0x13,
+0x53, 0x18, 0x52, 0x7B, 0x50, 0x22, 0xB0, 0x13,
+0xB4, 0x19, 0x05, 0x01, 0x40, 0x09, 0xB1, 0x39,
+0xC1, 0x87, 0x0F, 0x98, 0x5F, 0x54, 0x60, 0x1E,
+0x60, 0x22, 0x62, 0x14, 0x39, 0x59, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0x70, 0x1E, 0x70, 0x22,
+0x62, 0x14, 0xB9, 0x19, 0x07, 0x01, 0x60, 0x09,
+0xB1, 0x39, 0xC1, 0x87, 0x21, 0x21, 0x31, 0x21,
+0x5F, 0x85, 0x00, 0x03, 0x8C, 0x00, 0x04, 0x51,
+0x41, 0x80, 0x00, 0x03, 0x8C, 0x00, 0x05, 0x51,
+0xF0, 0xA0, 0x00, 0x03, 0x77, 0x02, 0x00, 0x49,
+0xF1, 0xA0, 0x00, 0x03, 0x77, 0x16, 0x00, 0x4E,
+0x95, 0x00, 0xFD, 0xA0, 0x7F, 0x19, 0x00, 0x4E,
+0xB7, 0x00, 0x0B, 0xB0, 0x75, 0x19, 0x1F, 0x19,
+0x0F, 0x98, 0x95, 0x64, 0x0F, 0x49, 0x0B, 0xB0,
+0x0F, 0x19, 0x50, 0x18, 0xC0, 0x03, 0x8B, 0x02,
+0xA0, 0x1A, 0x60, 0x09, 0x80, 0x19, 0xA0, 0x0B,
+0x4B, 0x00, 0x45, 0x48, 0x2D, 0x80, 0xA1, 0x0B,
+0x81, 0x21, 0xB1, 0x21, 0xA1, 0x21, 0xC1, 0x39,
+0xC0, 0x49, 0x5A, 0x87, 0x87, 0x48, 0xFD, 0xA0,
+0x00, 0x03, 0xD6, 0x00, 0x02, 0x39, 0x10, 0x03,
+0xD5, 0x00, 0x12, 0x39, 0x0F, 0x98, 0xA7, 0x54,
+0xC0, 0x18, 0xA0, 0x1A, 0x60, 0x09, 0x60, 0x03,
+0xD6, 0x00, 0x76, 0x18, 0x86, 0x18, 0x82, 0x39,
+0x61, 0x21, 0xA6, 0x20, 0x60, 0x19, 0x00, 0x19,
+0x9A, 0x18, 0x19, 0x00, 0x10, 0x49, 0xA0, 0x82,
+0x01, 0x21, 0x91, 0x21, 0x19, 0x00, 0x10, 0x49,
+0x00, 0xB0, 0x01, 0x21, 0x92, 0x39, 0x19, 0x00,
+0x10, 0x49, 0x00, 0xB0, 0x01, 0x21, 0x97, 0x38,
+0x19, 0x00, 0x10, 0x49, 0x00, 0xB0, 0x01, 0x21,
+0x91, 0x21, 0x19, 0x00, 0x10, 0x49, 0x00, 0xB0,
+0x01, 0x21, 0x91, 0x21, 0x19, 0x00, 0x10, 0x49,
+0x00, 0xB0, 0x01, 0x21, 0x97, 0x20, 0x97, 0x20,
+0x19, 0x00, 0x10, 0x49, 0x00, 0xB0, 0x01, 0x21,
+0x91, 0x39, 0x19, 0x00, 0x10, 0x49, 0x00, 0xB0,
+0x01, 0x21, 0x91, 0x39, 0x19, 0x00, 0x10, 0x49,
+0x00, 0xB0, 0x01, 0x21, 0xA0, 0x08, 0x00, 0x19,
+0xA1, 0x21, 0x61, 0x21, 0x68, 0x48, 0x2C, 0x80,
+0x60, 0x19, 0xA2, 0x21, 0xC1, 0x39, 0xC0, 0x49,
+0x7A, 0x84, 0xC0, 0x03, 0x8B, 0x02, 0xA0, 0x1A,
+0x60, 0x09, 0x60, 0x19, 0x70, 0x1A, 0x52, 0x16,
+0x80, 0x19, 0x00, 0x19, 0x10, 0x19, 0x4A, 0x00,
+0x43, 0x49, 0x0C, 0xB0, 0x81, 0x21, 0x04, 0x20,
+0x14, 0x20, 0x50, 0x1A, 0x3E, 0x16, 0x56, 0x20,
+0x25, 0x00, 0x24, 0x20, 0x52, 0x08, 0xA1, 0x21,
+0x61, 0x21, 0x60, 0x4E, 0xD6, 0x00, 0x4C, 0x80,
+0x60, 0x19, 0x71, 0x08, 0x71, 0x21, 0x10, 0x19,
+0xC1, 0x39, 0xC0, 0x49, 0x8A, 0x86, 0x40, 0x1A,
+0x3E, 0x16, 0x50, 0x03, 0xD6, 0x00, 0x60, 0x19,
+0x34, 0x00, 0x63, 0x48, 0x0B, 0xB0, 0x63, 0x18,
+0x41, 0x21, 0x51, 0x39, 0x50, 0x49, 0x8A, 0x87,
+0x40, 0x1A, 0x52, 0x16, 0x50, 0x03, 0xD5, 0x00,
+0x70, 0x19, 0x34, 0x00, 0x73, 0x48, 0x0B, 0xB0,
+0x73, 0x18, 0x41, 0x21, 0x51, 0x39, 0x50, 0x49,
+0x8A, 0x87, 0x10, 0x03, 0x8C, 0x00, 0x14, 0x51,
+0x90, 0x81, 0x50, 0x03, 0x77, 0x16, 0x50, 0x4E,
+0xB7, 0x00, 0x4B, 0x81, 0x60, 0x4A, 0x1E, 0x00,
+0x9B, 0x80, 0x70, 0x4A, 0x1E, 0x00, 0x6B, 0x80,
+0x80, 0x4E, 0xA3, 0x00, 0x3B, 0x80, 0x00, 0x4E,
+0xA4, 0x00, 0x8C, 0x80, 0x00, 0x03, 0xB6, 0x00,
+0x00, 0x0D, 0x0B, 0x16, 0x01, 0x0E, 0xFB, 0x16,
+0x0F, 0x88, 0x00, 0x52, 0x10, 0x03, 0x8C, 0x00,
+0x15, 0x51, 0xF0, 0xA0, 0x00, 0x4E, 0x3E, 0x01,
+0x0C, 0xB0, 0x03, 0x0E, 0xFE, 0x16, 0xFF, 0xA0,
+0x00, 0x0E, 0x1E, 0x16, 0x00, 0x0E, 0x1F, 0x16,
+0x00, 0x0E, 0x20, 0x16, 0x00, 0x0E, 0x21, 0x16,
+0x00, 0x03, 0x13, 0x14, 0x00, 0x49, 0xF0, 0xA0,
+0xA0, 0x19, 0xB0, 0x19, 0xC0, 0x19, 0x80, 0x19,
+0x90, 0x19, 0x70, 0x19, 0x60, 0x19, 0x10, 0x1A,
+0x14, 0x14, 0x1A, 0x20, 0x31, 0x00, 0x30, 0x4E,
+0xB7, 0x00, 0xDA, 0x81, 0x00, 0x03, 0x8C, 0x00,
+0x04, 0x51, 0x60, 0x83, 0x20, 0x1A, 0x3C, 0x14,
+0x2A, 0x20, 0x02, 0x00, 0x00, 0x4E, 0xCF, 0x00,
+0x7A, 0x80, 0x20, 0x1A, 0x28, 0x14, 0x2A, 0x20,
+0x02, 0x00, 0x00, 0x4E, 0xB1, 0x00, 0x8C, 0x82,
+0xB1, 0x21, 0x20, 0x1A, 0x28, 0x14, 0x2A, 0x20,
+0x02, 0x00, 0x70, 0x48, 0x0B, 0xB0, 0x70, 0x18,
+0x83, 0x48, 0x0B, 0xB0, 0x83, 0x18, 0x00, 0x03,
+0x8C, 0x00, 0x05, 0x51, 0x90, 0x81, 0x20, 0x1A,
+0x3C, 0x14, 0x2A, 0x20, 0x02, 0x00, 0x00, 0x4E,
+0xEA, 0x00, 0x7A, 0x80, 0x20, 0x1A, 0x28, 0x14,
+0x2A, 0x20, 0x02, 0x00, 0x00, 0x4E, 0xB5, 0x00,
+0xBC, 0x80, 0xC1, 0x21, 0x20, 0x1A, 0x28, 0x14,
+0x2A, 0x20, 0x02, 0x00, 0x60, 0x48, 0x0B, 0xB0,
+0x60, 0x18, 0x93, 0x48, 0x0B, 0xB0, 0x93, 0x18,
+0xA1, 0x21, 0xA0, 0x4E, 0x13, 0x14, 0x0C, 0x88,
+0xC7, 0x63, 0x0B, 0x0D, 0x1F, 0x16, 0x0C, 0x0D,
+0x1E, 0x16, 0x08, 0x0D, 0x21, 0x16, 0x09, 0x0D,
+0x20, 0x16, 0x07, 0x0D, 0x23, 0x16, 0x06, 0x0D,
+0x22, 0x16, 0xFF, 0xA0, 0x00, 0x0E, 0xFD, 0x16,
+0x00, 0x0E, 0xFB, 0x16, 0x00, 0x03, 0x77, 0x16,
+0x00, 0x4E, 0xB7, 0x00, 0x3A, 0x81, 0x00, 0x03,
+0x1F, 0x16, 0x00, 0x49, 0xF0, 0xA0, 0x01, 0x0E,
+0xFB, 0x16, 0x00, 0x0E, 0x85, 0x12, 0x00, 0x03,
+0x21, 0x16, 0x10, 0x03, 0xBA, 0x00, 0x10, 0x49,
+0xF0, 0xA0, 0x0F, 0x98, 0x95, 0x64, 0x00, 0x0D,
+0x8C, 0x12, 0xFF, 0xA0, 0x20, 0x19, 0x00, 0x03,
+0x1F, 0x16, 0x00, 0x49, 0xB0, 0x80, 0x21, 0x19,
+0x00, 0x03, 0x21, 0x16, 0x10, 0x03, 0xBA, 0x00,
+0x10, 0x49, 0x40, 0x80, 0x0F, 0x98, 0x95, 0x64,
+0x00, 0x0D, 0x8C, 0x12, 0x00, 0x03, 0x1E, 0x16,
+0x20, 0x68, 0x20, 0x49, 0xF0, 0xA0, 0x00, 0x03,
+0x22, 0x16, 0x00, 0x4E, 0xB4, 0x00, 0x9A, 0x81,
+0x20, 0x03, 0x1E, 0x16, 0x30, 0x03, 0x1F, 0x16,
+0x21, 0x49, 0x5C, 0x80, 0x23, 0x49, 0x1B, 0x81,
+0x32, 0x20, 0x33, 0x49, 0xEA, 0x80, 0x00, 0x03,
+0x65, 0x01, 0x04, 0x51, 0xF0, 0xA0, 0x21, 0x49,
+0xFC, 0xA0, 0x32, 0x49, 0xFC, 0xA0, 0x00, 0x03,
+0xFE, 0x16, 0x03, 0xC1, 0x00, 0x0D, 0xFE, 0x16,
+0xFF, 0xA0, 0x01, 0x0E, 0xFD, 0x16, 0x00, 0x0E,
+0xFB, 0x16, 0x01, 0x0E, 0x00, 0x17, 0x00, 0x03,
+0xFE, 0x16, 0x01, 0xC1, 0x00, 0x0D, 0xFE, 0x16,
+0xFF, 0xA0, 0xA0, 0x19, 0x2A, 0x18, 0x0F, 0x98,
+0x5F, 0x54, 0x20, 0x1E, 0x20, 0x22, 0x62, 0x14,
+0x25, 0x21, 0x62, 0x00, 0x00, 0x03, 0x8A, 0x12,
+0x60, 0x48, 0xDB, 0x80, 0x0F, 0x98, 0xA3, 0x62,
+0xA1, 0x39, 0xD0, 0x03, 0x85, 0x12, 0xD1, 0x39,
+0x0D, 0x0D, 0x85, 0x12, 0xD0, 0x49, 0x3A, 0x80,
+0x00, 0x0E, 0x85, 0x12, 0xFF, 0xA0, 0xA1, 0x21,
+0xB0, 0x03, 0x85, 0x12, 0xAB, 0x48, 0x2C, 0x86,
+0xFF, 0xA0, 0x10, 0x49, 0xF0, 0xA0, 0x0F, 0x98,
+0xA7, 0x54, 0x20, 0x1A, 0x64, 0x00, 0x0F, 0x88,
+0xFA, 0x54, 0x00, 0x03, 0x8C, 0x00, 0x0D, 0x51,
+0xF0, 0xA0, 0xC0, 0x03, 0x9B, 0x00, 0x00, 0x03,
+0x77, 0x16, 0x0C, 0x48, 0xFC, 0xA0, 0x00, 0x03,
+0x09, 0x16, 0x00, 0x0D, 0xFC, 0x12, 0x00, 0x03,
+0x07, 0x16, 0x00, 0x0D, 0xFA, 0x12, 0x00, 0x03,
+0x0A, 0x16, 0x00, 0x0D, 0xFD, 0x12, 0x00, 0x03,
+0x08, 0x16, 0x00, 0x0D, 0xFB, 0x12, 0xC0, 0x1A,
+0xA0, 0x02, 0xA0, 0x03, 0x78, 0x16, 0xCA, 0x20,
+0x0C, 0x00, 0x00, 0x0D, 0xFC, 0x16, 0x00, 0x0D,
+0x74, 0x16, 0xB0, 0x1A, 0xA0, 0x02, 0x0B, 0x0D,
+0x8C, 0x16, 0xC0, 0x03, 0x78, 0x16, 0x0F, 0x98,
+0xA0, 0x58, 0xA0, 0x03, 0xFC, 0x12, 0xB0, 0x03,
+0xFD, 0x12, 0xBA, 0x38, 0xB1, 0x21, 0x00, 0x03,
+0xA6, 0x00, 0xB0, 0x48, 0x4B, 0x81, 0xA0, 0x03,
+0xFA, 0x12, 0xC0, 0x03, 0xFB, 0x12, 0xCA, 0x38,
+0xC1, 0x21, 0x00, 0x03, 0xA7, 0x00, 0xC0, 0x48,
+0xAB, 0x80, 0xBC, 0x58, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xB0, 0x1E, 0x00, 0x03, 0xAB, 0x00,
+0xB0, 0x48, 0x1B, 0x80, 0xFF, 0xA0, 0x01, 0x0E,
+0xFB, 0x16, 0x00, 0x03, 0xFC, 0x16, 0x10, 0x03,
+0xBC, 0x00, 0x10, 0x49, 0xF0, 0xA0, 0x0F, 0x98,
+0x95, 0x64, 0x10, 0x03, 0x8C, 0x12, 0x10, 0x48,
+0xFB, 0xA0, 0x00, 0x0D, 0x8C, 0x12, 0xFF, 0xA0,
+0xB0, 0x03, 0x51, 0x13, 0xD0, 0x19, 0x30, 0x03,
+0x8A, 0x00, 0xBD, 0x50, 0xF0, 0xA0, 0xD1, 0x21,
+0xD3, 0x48, 0xB1, 0x87, 0xFF, 0xA0, 0x4C, 0x00,
+0x40, 0x62, 0xFF, 0x00, 0x08, 0x18, 0x60, 0x03,
+0xA9, 0x00, 0x60, 0x49, 0x60, 0x80, 0x08, 0x18,
+0x10, 0x19, 0x24, 0x18, 0x30, 0x19, 0x0F, 0x98,
+0xD1, 0x6C, 0xA0, 0x18, 0xA0, 0x62, 0xFF, 0x00,
+0xDC, 0x00, 0xDD, 0x51, 0x10, 0x80, 0xAD, 0xC1,
+0xA8, 0xC1, 0xAA, 0xC1, 0x0A, 0x0D, 0xF3, 0x12,
+0xFF, 0xA0, 0x40, 0x03, 0x85, 0x00, 0x42, 0x49,
+0x20, 0x80, 0xA8, 0x18, 0xFF, 0xA0, 0x49, 0x00,
+0xFF, 0xFF, 0x40, 0x62, 0xFF, 0x00, 0x78, 0x18,
+0x70, 0x62, 0xFF, 0x00, 0x07, 0x18, 0x60, 0x03,
+0xA9, 0x00, 0x60, 0x49, 0x60, 0x80, 0x07, 0x18,
+0x10, 0x19, 0x24, 0x18, 0x30, 0x19, 0x0F, 0x98,
+0xD1, 0x6C, 0x50, 0x18, 0x49, 0x00, 0x48, 0x79,
+0x40, 0x62, 0xFF, 0x00, 0x78, 0x18, 0x78, 0x79,
+0x70, 0x62, 0xFF, 0x00, 0x40, 0x4A, 0x87, 0x00,
+0x6D, 0x80, 0x70, 0x4A, 0x2D, 0x00, 0xBB, 0x80,
+0x70, 0x22, 0xB4, 0x00, 0x8F, 0x80, 0x40, 0x4A,
+0x2D, 0x00, 0x5B, 0x80, 0x70, 0x4A, 0x87, 0x00,
+0x2D, 0x80, 0x40, 0x22, 0xB4, 0x00, 0x07, 0x18,
+0x00, 0x4A, 0xB4, 0x00, 0x2C, 0x80, 0x00, 0x3A,
+0xB4, 0x00, 0x60, 0x03, 0xAD, 0x00, 0x60, 0x49,
+0xF0, 0x82, 0x07, 0x0D, 0x10, 0xF9, 0x00, 0x0E,
+0x11, 0xF9, 0x00, 0x1A, 0x32, 0x00, 0x00, 0x0D,
+0x12, 0xF9, 0x00, 0x0E, 0x13, 0xF9, 0xFF, 0xFF,
+0xFF, 0xFF, 0x00, 0x03, 0x10, 0xF9, 0x10, 0x03,
+0x11, 0xF9, 0xB0, 0x03, 0x06, 0x16, 0xB4, 0x21,
+0x2B, 0x00, 0xFF, 0xFF, 0x40, 0x4A, 0xB4, 0x00,
+0x2C, 0x80, 0x20, 0x22, 0x28, 0x23, 0x30, 0x19,
+0x0F, 0x98, 0xD1, 0x6C, 0x00, 0x4A, 0x28, 0x23,
+0x2C, 0x80, 0x00, 0x3A, 0x28, 0x23, 0xB0, 0x08,
+0x00, 0x0D, 0x18, 0xF9, 0x01, 0x0D, 0x19, 0xF9,
+0x00, 0x1A, 0x32, 0x00, 0x00, 0x0D, 0x1A, 0xF9,
+0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x03, 0x18, 0xF9,
+0xA0, 0x18, 0xA8, 0x7B, 0xA5, 0x68, 0xFF, 0xA0,
+0x10, 0x03, 0x56, 0x13, 0x90, 0x1A, 0x34, 0x15,
+0x80, 0x1A, 0x43, 0x15, 0x70, 0x1A, 0x52, 0x15,
+0x91, 0x20, 0x81, 0x20, 0x71, 0x20, 0x90, 0x0B,
+0x80, 0x0B, 0x70, 0x0B, 0xFF, 0xA0, 0x00, 0x0E,
+0x11, 0xF9, 0x00, 0x1A, 0x64, 0x00, 0x00, 0x0D,
+0x12, 0xF9, 0x00, 0x0E, 0x13, 0xF9, 0xFF, 0xFF,
+0xFF, 0xFF, 0x00, 0x03, 0x10, 0xF9, 0x10, 0x03,
+0x11, 0xF9, 0xB0, 0x09, 0xB1, 0x09, 0xFF, 0xA0,
+0x90, 0x1A, 0x85, 0x13, 0x92, 0x21, 0xC0, 0x19,
+0xB0, 0x19, 0x3A, 0x19, 0xA9, 0x00, 0xA8, 0x51,
+0x20, 0x80, 0xBC, 0xC0, 0x3F, 0x80, 0xA0, 0x62,
+0xFF, 0x00, 0x9A, 0x08, 0x94, 0x21, 0xC1, 0x21,
+0xC3, 0x48, 0x41, 0x87, 0x0B, 0x0D, 0x51, 0x13,
+0xD0, 0x1A, 0xE9, 0x14, 0xD2, 0x21, 0x0D, 0x0D,
+0x58, 0x13, 0x00, 0x0E, 0x4F, 0x13, 0x00, 0x0E,
+0x56, 0x13, 0x00, 0x0E, 0x57, 0x13, 0xD0, 0x03,
+0x58, 0x13, 0x0D, 0x00, 0x0E, 0x51, 0x00, 0x88,
+0x3B, 0x66, 0x80, 0x1A, 0x43, 0x15, 0xA0, 0x03,
+0x56, 0x13, 0x8A, 0x20, 0x08, 0x00, 0x10, 0x18,
+0x11, 0x39, 0x01, 0x0D, 0x59, 0x13, 0x00, 0x49,
+0x00, 0x88, 0x3B, 0x66, 0x30, 0x03, 0x8A, 0x00,
+0x03, 0x48, 0x0A, 0x88, 0x34, 0x66, 0x00, 0x03,
+0x56, 0x13, 0x10, 0x03, 0x4F, 0x13, 0x10, 0xC0,
+0x01, 0x0D, 0x4F, 0x13, 0xD0, 0x03, 0x58, 0x13,
+0xD2, 0x39, 0x10, 0x03, 0x59, 0x13, 0x61, 0x18,
+0x7D, 0x01, 0x07, 0x0D, 0xEC, 0x12, 0x8D, 0x00,
+0x08, 0x0D, 0xED, 0x12, 0x90, 0x1A, 0x85, 0x13,
+0x01, 0x18, 0x02, 0x7B, 0x90, 0x20, 0x00, 0x1A,
+0x61, 0x15, 0x1B, 0x59, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0x10, 0x1E, 0x01, 0x20, 0x00, 0x0D,
+0x06, 0x16, 0x09, 0x0D, 0x5A, 0x13, 0x09, 0x01,
+0x00, 0x0D, 0xF6, 0x12, 0x09, 0x00, 0x00, 0x0D,
+0xF7, 0x12, 0x0F, 0x98, 0x01, 0x6E, 0x0A, 0x0D,
+0x3D, 0x13, 0x90, 0x03, 0x5A, 0x13, 0x49, 0x01,
+0x59, 0x00, 0x0F, 0x98, 0x4C, 0x6D, 0x90, 0x03,
+0x5A, 0x13, 0x97, 0x09, 0x98, 0x09, 0xD0, 0x03,
+0x58, 0x13, 0xAD, 0x01, 0x9A, 0x09, 0x8D, 0x00,
+0xFF, 0xFF, 0x0F, 0x98, 0x1D, 0x65, 0x9A, 0x08,
+0x00, 0x03, 0x57, 0x13, 0x01, 0x21, 0x00, 0x0D,
+0x57, 0x13, 0xD0, 0x03, 0x58, 0x13, 0x0D, 0x00,
+0x08, 0x51, 0x30, 0x80, 0x01, 0x0E, 0x0E, 0x16,
+0xAF, 0x80, 0x0F, 0x98, 0x8C, 0x65, 0x7F, 0x80,
+0x00, 0x03, 0x56, 0x13, 0x10, 0x03, 0x4F, 0x13,
+0x10, 0xC0, 0x01, 0x0D, 0x4F, 0x13, 0xD0, 0x03,
+0x58, 0x13, 0x0D, 0x00, 0x08, 0x51, 0x21, 0x80,
+0x0F, 0x98, 0x8C, 0x65, 0xD0, 0x03, 0x58, 0x13,
+0xD5, 0x21, 0x0D, 0x0D, 0x58, 0x13, 0xA0, 0x03,
+0x56, 0x13, 0xA1, 0x21, 0x0A, 0x0D, 0x56, 0x13,
+0xAF, 0x49, 0x01, 0x88, 0xCB, 0x65, 0x00, 0x03,
+0x57, 0x13, 0x10, 0x03, 0x8A, 0x00, 0x01, 0x48,
+0x5C, 0x81, 0xD0, 0x1A, 0xE9, 0x14, 0xD2, 0x21,
+0xA0, 0x19, 0x0D, 0x00, 0x0E, 0x51, 0x90, 0x80,
+0x80, 0x1A, 0x43, 0x15, 0x8A, 0x20, 0x08, 0x00,
+0x00, 0x49, 0x31, 0x80, 0x00, 0x1A, 0xFF, 0x00,
+0x80, 0x08, 0xD5, 0x21, 0xA1, 0x21, 0xAF, 0x49,
+0x01, 0x87, 0xFF, 0xA0, 0xD0, 0x1A, 0xE9, 0x14,
+0xD2, 0x21, 0x0D, 0x0D, 0x58, 0x13, 0x00, 0x0E,
+0x56, 0x13, 0xD0, 0x03, 0x58, 0x13, 0x0D, 0x00,
+0x0E, 0x51, 0x00, 0x88, 0xE4, 0x66, 0x00, 0x03,
+0x56, 0x13, 0x10, 0x03, 0x4F, 0x13, 0x10, 0x50,
+0x01, 0x88, 0xE4, 0x66, 0x0F, 0x98, 0xF8, 0x64,
+0x30, 0x03, 0x8A, 0x00, 0xD3, 0x48, 0x10, 0x85,
+0x0D, 0x0D, 0x59, 0x13, 0xA0, 0x03, 0x51, 0x13,
+0xAD, 0xC0, 0x0A, 0x0D, 0x51, 0x13, 0x80, 0x1A,
+0x43, 0x15, 0xA0, 0x03, 0x56, 0x13, 0x8A, 0x20,
+0xD1, 0x21, 0x8D, 0x08, 0x00, 0x03, 0x56, 0x13,
+0x10, 0x03, 0x4F, 0x13, 0x10, 0xC0, 0x01, 0x0D,
+0x4F, 0x13, 0xD0, 0x03, 0x58, 0x13, 0xD2, 0x39,
+0x7D, 0x01, 0x8D, 0x00, 0x10, 0x03, 0x59, 0x13,
+0x90, 0x1A, 0x85, 0x13, 0x01, 0x18, 0x02, 0x7B,
+0x90, 0x20, 0xB0, 0x1A, 0x61, 0x15, 0x1B, 0x59,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x1E,
+0xB1, 0x20, 0x0B, 0x0D, 0x06, 0x16, 0x97, 0x09,
+0x07, 0x0D, 0x10, 0xF9, 0x0F, 0x98, 0x9B, 0x65,
+0x98, 0x09, 0x08, 0x0D, 0x10, 0xF9, 0x0F, 0x98,
+0x9B, 0x65, 0xD0, 0x03, 0x58, 0x13, 0x0D, 0x01,
+0x90, 0x09, 0x2D, 0x00, 0x92, 0x08, 0x12, 0x18,
+0x18, 0x79, 0x01, 0x0D, 0x10, 0xF9, 0x00, 0x0E,
+0x11, 0xF9, 0x00, 0x1A, 0x32, 0x00, 0x00, 0x0D,
+0x12, 0xF9, 0x00, 0x0E, 0x13, 0xF9, 0xFF, 0xFF,
+0xFF, 0xFF, 0x00, 0x03, 0x10, 0xF9, 0xB0, 0x09,
+0xB0, 0x0B, 0xB1, 0x21, 0xB7, 0x09, 0xB8, 0x09,
+0xB0, 0x0B, 0xB1, 0x21, 0xB7, 0x09, 0xB8, 0x08,
+0x00, 0x03, 0x57, 0x13, 0x01, 0x21, 0x00, 0x0D,
+0x57, 0x13, 0x01, 0x0E, 0x0E, 0x16, 0x10, 0x03,
+0x8A, 0x00, 0x01, 0x48, 0x00, 0x88, 0x55, 0x66,
+0xD0, 0x03, 0x58, 0x13, 0xD5, 0x21, 0x0D, 0x0D,
+0x58, 0x13, 0xA0, 0x03, 0x56, 0x13, 0xA1, 0x21,
+0x0A, 0x0D, 0x56, 0x13, 0xAF, 0x49, 0x01, 0x88,
+0x71, 0x66, 0xFF, 0xA0, 0x00, 0x0E, 0x39, 0x13,
+0xB0, 0x1A, 0x85, 0x13, 0xA0, 0x03, 0x39, 0x13,
+0xA2, 0x7B, 0xBA, 0x20, 0xC0, 0x1A, 0x5D, 0x13,
+0xCA, 0x20, 0xDC, 0x18, 0xD2, 0x21, 0x0D, 0x00,
+0x08, 0x51, 0x00, 0x88, 0x85, 0x67, 0xDB, 0x18,
+0xD2, 0x21, 0x0D, 0x00, 0x08, 0x51, 0x00, 0x88,
+0x71, 0x67, 0x0B, 0x51, 0x01, 0x88, 0x71, 0x67,
+0xAB, 0x01, 0x0A, 0x0D, 0xF6, 0x12, 0xAC, 0x01,
+0x0A, 0x0D, 0xEC, 0x12, 0xAB, 0x02, 0x0A, 0x0D,
+0xF7, 0x12, 0xAC, 0x02, 0x0A, 0x0D, 0xED, 0x12,
+0x0F, 0x98, 0x01, 0x6E, 0x0A, 0x0D, 0x3D, 0x13,
+0xA0, 0x03, 0x30, 0x17, 0xA0, 0x49, 0x61, 0x80,
+0xA0, 0x03, 0x39, 0x13, 0xD0, 0x03, 0x3B, 0x16,
+0xDA, 0x50, 0x61, 0x80, 0xA0, 0x03, 0x3A, 0x16,
+0xD0, 0x03, 0x3D, 0x13, 0xDA, 0x48, 0x7D, 0x83,
+0xA0, 0x03, 0x39, 0x13, 0xD0, 0x03, 0x3B, 0x16,
+0xDA, 0xC0, 0x0D, 0x0D, 0x3B, 0x16, 0x0B, 0x01,
+0xC0, 0x09, 0x0B, 0x01, 0xC0, 0x09, 0x8B, 0x00,
+0x80, 0x62, 0xFF, 0x00, 0x0F, 0x98, 0x03, 0x65,
+0xA0, 0x03, 0xF3, 0x12, 0xA0, 0x62, 0xFF, 0x00,
+0x9C, 0x00, 0x90, 0x62, 0xFF, 0x00, 0xA9, 0x38,
+0xAF, 0x51, 0x10, 0x80, 0xA0, 0x31, 0x90, 0x03,
+0x39, 0x01, 0xA9, 0x48, 0xFB, 0x80, 0xA0, 0x03,
+0xF3, 0x12, 0xA0, 0x62, 0x00, 0xFF, 0x9C, 0x00,
+0x90, 0x62, 0xFF, 0x00, 0xA9, 0x68, 0xCA, 0x08,
+0xB1, 0x21, 0xC1, 0x21, 0xAB, 0x00, 0xCA, 0x08,
+0x0F, 0x88, 0x9C, 0x67, 0xA0, 0x03, 0xF3, 0x12,
+0xAF, 0xC1, 0xCA, 0x08, 0xB1, 0x21, 0xC1, 0x21,
+0xAB, 0x00, 0xCA, 0x08, 0x9F, 0x83, 0xB2, 0x21,
+0xC2, 0x21, 0x8B, 0x00, 0x80, 0x62, 0xFF, 0x00,
+0x0F, 0x98, 0x03, 0x65, 0xA0, 0x03, 0xF3, 0x12,
+0xAA, 0xC9, 0xA8, 0xC1, 0x0A, 0x0D, 0xF3, 0x12,
+0xBF, 0x84, 0xB2, 0x21, 0xC2, 0x21, 0xA0, 0x03,
+0x39, 0x13, 0xD0, 0x03, 0x3B, 0x16, 0xDA, 0xC8,
+0x0D, 0x0D, 0x3B, 0x16, 0x0C, 0x00, 0x0D, 0x51,
+0x20, 0x80, 0xC0, 0x0B, 0xDF, 0x81, 0xA0, 0x19,
+0xAB, 0xC1, 0xCA, 0x08, 0xC1, 0x21, 0xC0, 0x0B,
+0x7F, 0x81, 0xDB, 0x18, 0xD2, 0x21, 0x0D, 0x00,
+0x08, 0x51, 0x51, 0x80, 0xC2, 0x21, 0xC0, 0x0B,
+0xC1, 0x21, 0xC0, 0x0B, 0xDF, 0x80, 0x0B, 0x01,
+0xC0, 0x09, 0x0B, 0x01, 0xC0, 0x09, 0x0B, 0x01,
+0x00, 0x62, 0xFF, 0x00, 0x0F, 0xC1, 0x08, 0xC1,
+0x09, 0xC1, 0xC0, 0x09, 0xAB, 0x00, 0xCA, 0x08,
+0x00, 0x03, 0x39, 0x13, 0x01, 0x21, 0x00, 0x0D,
+0x39, 0x13, 0x10, 0x03, 0x8A, 0x00, 0x01, 0x48,
+0x01, 0x88, 0xF4, 0x66, 0xFF, 0xA0, 0x20, 0x03,
+0xB9, 0x00, 0x20, 0x49, 0xF0, 0xA0, 0xA0, 0x19,
+0xB0, 0x19, 0xC0, 0x1A, 0x5D, 0x13, 0xC2, 0x21,
+0x30, 0x03, 0x8A, 0x00, 0x0C, 0x00, 0x08, 0x51,
+0x50, 0x80, 0x00, 0x62, 0xFF, 0x00, 0x0B, 0x48,
+0x1C, 0x80, 0xB0, 0x18, 0xC4, 0x21, 0xA1, 0x21,
+0xA3, 0x48, 0x41, 0x87, 0x0B, 0x0D, 0x9B, 0x02,
+0xA0, 0x19, 0x00, 0x03, 0x9B, 0x02, 0x10, 0x03,
+0xB9, 0x00, 0x0F, 0x98, 0x95, 0x64, 0x00, 0x0D,
+0x9B, 0x02, 0x40, 0x03, 0x9B, 0x02, 0xC0, 0x1A,
+0x5D, 0x13, 0xC2, 0x21, 0xD0, 0x1A, 0xF7, 0x00,
+0xD2, 0x21, 0x30, 0x03, 0x8A, 0x00, 0x0C, 0x00,
+0x10, 0x18, 0x18, 0x51, 0x41, 0x80, 0x1D, 0xC9,
+0x1A, 0xC9, 0xC1, 0x08, 0x4F, 0x81, 0x00, 0x62,
+0xFF, 0x00, 0x04, 0x48, 0x7B, 0x80, 0x0D, 0x00,
+0x08, 0x51, 0x61, 0x80, 0x1D, 0xC1, 0x1A, 0xC9,
+0xC1, 0x08, 0x9F, 0x80, 0x1D, 0x51, 0x31, 0x80,
+0x1D, 0xC9, 0xC1, 0x08, 0x4F, 0x80, 0x1D, 0xC9,
+0x1A, 0xC9, 0x19, 0xC1, 0xC1, 0x08, 0x40, 0x03,
+0x9B, 0x02, 0xC4, 0x21, 0xD4, 0x21, 0xA1, 0x21,
+0xA3, 0x48, 0xD1, 0x85, 0xFF, 0xA0, 0x80, 0x19,
+0x00, 0x03, 0x29, 0x13, 0x10, 0x03, 0x9C, 0x00,
+0x10, 0x49, 0x30, 0x80, 0x0F, 0x98, 0x95, 0x64,
+0x80, 0x18, 0x00, 0x03, 0x32, 0x13, 0x10, 0x03,
+0x33, 0x13, 0x40, 0x03, 0x0A, 0x16, 0x50, 0x03,
+0x08, 0x16, 0x20, 0x03, 0x09, 0x16, 0x30, 0x03,
+0x07, 0x16, 0x02, 0x48, 0xD0, 0x81, 0x04, 0x48,
+0x00, 0x88, 0x5C, 0x68, 0x13, 0x48, 0x91, 0x80,
+0x01, 0x0E, 0xE2, 0x12, 0x70, 0x03, 0x4A, 0x17,
+0x78, 0x48, 0x0B, 0xB0, 0x08, 0x0D, 0x4A, 0x17,
+0xFF, 0xA0, 0x15, 0x48, 0x20, 0x80, 0x00, 0x0E,
+0xDF, 0x12, 0x15, 0x48, 0x81, 0x80, 0x01, 0x0E,
+0xE0, 0x12, 0x70, 0x03, 0x4C, 0x17, 0x78, 0x48,
+0x0B, 0xB0, 0x08, 0x0D, 0x4C, 0x17, 0xFF, 0xA0,
+0x13, 0x48, 0x11, 0x81, 0x01, 0x0E, 0xE2, 0x12,
+0x01, 0x0E, 0xE3, 0x12, 0x70, 0x03, 0x4A, 0x17,
+0x78, 0x48, 0x0B, 0xB0, 0x08, 0x0D, 0x4A, 0x17,
+0x70, 0x03, 0x4B, 0x17, 0x78, 0x48, 0x0B, 0xB0,
+0x08, 0x0D, 0x4B, 0x17, 0xFF, 0xA0, 0x15, 0x48,
+0x80, 0x80, 0x01, 0x0E, 0xE3, 0x12, 0x70, 0x03,
+0x4B, 0x17, 0x78, 0x48, 0x0B, 0xB0, 0x08, 0x0D,
+0x4B, 0x17, 0x15, 0x48, 0x01, 0x81, 0x01, 0x0E,
+0xE3, 0x12, 0x01, 0x0E, 0xE0, 0x12, 0x70, 0x03,
+0x4C, 0x17, 0x78, 0x48, 0x0B, 0xB0, 0x08, 0x0D,
+0x4C, 0x17, 0x70, 0x03, 0x4B, 0x17, 0x78, 0x48,
+0x0B, 0xB0, 0x08, 0x0D, 0x4B, 0x17, 0xFF, 0xA0,
+0x13, 0x48, 0x11, 0x81, 0x01, 0x0E, 0xE2, 0x12,
+0x01, 0x0E, 0xE1, 0x12, 0x70, 0x03, 0x4A, 0x17,
+0x78, 0x48, 0x0B, 0xB0, 0x08, 0x0D, 0x4A, 0x17,
+0x70, 0x03, 0x4D, 0x17, 0x78, 0x48, 0x0B, 0xB0,
+0x08, 0x0D, 0x4D, 0x17, 0xFF, 0xA0, 0x15, 0x48,
+0x80, 0x80, 0x01, 0x0E, 0xE1, 0x12, 0x70, 0x03,
+0x4D, 0x17, 0x78, 0x48, 0x0B, 0xB0, 0x08, 0x0D,
+0x4D, 0x17, 0x15, 0x48, 0x01, 0x81, 0x01, 0x0E,
+0xE0, 0x12, 0x01, 0x0E, 0xE1, 0x12, 0x70, 0x03,
+0x4C, 0x17, 0x78, 0x48, 0x0B, 0xB0, 0x08, 0x0D,
+0x4C, 0x17, 0x70, 0x03, 0x4D, 0x17, 0x78, 0x48,
+0x0B, 0xB0, 0x08, 0x0D, 0x4D, 0x17, 0xFF, 0xA0,
+0x09, 0x18, 0x0A, 0x38, 0x18, 0x18, 0x0F, 0x98,
+0xA7, 0x54, 0x29, 0x18, 0x2D, 0x38, 0x0F, 0x98,
+0xFA, 0x54, 0x39, 0x18, 0x30, 0x38, 0xFF, 0xA0,
+0xAB, 0x38, 0x0A, 0x18, 0x18, 0x18, 0x0F, 0x98,
+0xA7, 0x54, 0x29, 0x18, 0x2D, 0x38, 0x0F, 0x98,
+0xFA, 0x54, 0x0B, 0x20, 0xFF, 0xA0, 0x00, 0x0E,
+0xE0, 0x12, 0x00, 0x0E, 0xE1, 0x12, 0x00, 0x0E,
+0xE2, 0x12, 0x00, 0x0E, 0xE3, 0x12, 0x00, 0x0E,
+0xE4, 0x12, 0x00, 0x0E, 0xE5, 0x12, 0x00, 0x0E,
+0xE6, 0x12, 0x00, 0x0E, 0xE7, 0x12, 0xFF, 0xA0,
+0x01, 0x0E, 0xE0, 0x12, 0x01, 0x0E, 0xE1, 0x12,
+0x01, 0x0E, 0xE2, 0x12, 0x01, 0x0E, 0xE3, 0x12,
+0xFF, 0xA0, 0xA0, 0x03, 0x33, 0x13, 0x0A, 0x0D,
+0x31, 0x13, 0xA0, 0x03, 0x32, 0x13, 0x0A, 0x0D,
+0x30, 0x13, 0x0F, 0x98, 0xA3, 0x68, 0x0F, 0x98,
+0xF7, 0x67, 0x00, 0x03, 0x8C, 0x00, 0x03, 0x51,
+0x20, 0x80, 0x0F, 0x98, 0xB4, 0x68, 0x00, 0x03,
+0xF8, 0x12, 0x00, 0x49, 0x00, 0x88, 0x22, 0x69,
+0x00, 0x03, 0x8C, 0x00, 0x06, 0x51, 0x20, 0x80,
+0x0F, 0x98, 0xB4, 0x68, 0x01, 0x0E, 0x30, 0x17,
+0x00, 0x03, 0x30, 0x13, 0x00, 0x49, 0xC0, 0x80,
+0x01, 0x39, 0x10, 0x03, 0x0B, 0x13, 0x01, 0x48,
+0x2B, 0x80, 0x01, 0x0E, 0xE4, 0x12, 0x01, 0x39,
+0x01, 0x48, 0x2B, 0x80, 0x01, 0x0E, 0xE0, 0x12,
+0x00, 0x03, 0x30, 0x13, 0x10, 0x03, 0xD5, 0x00,
+0x11, 0x39, 0x01, 0x48, 0xC0, 0x80, 0x01, 0x21,
+0x10, 0x03, 0x0C, 0x13, 0x01, 0x48, 0x2D, 0x80,
+0x01, 0x0E, 0xE6, 0x12, 0x01, 0x21, 0x01, 0x48,
+0x2D, 0x80, 0x01, 0x0E, 0xE2, 0x12, 0x00, 0x03,
+0x31, 0x13, 0x00, 0x49, 0xC0, 0x80, 0x01, 0x39,
+0x10, 0x03, 0x09, 0x13, 0x01, 0x48, 0x2B, 0x80,
+0x01, 0x0E, 0xE5, 0x12, 0x01, 0x39, 0x01, 0x48,
+0x2B, 0x80, 0x01, 0x0E, 0xE1, 0x12, 0x00, 0x03,
+0x31, 0x13, 0x10, 0x03, 0xD6, 0x00, 0x11, 0x39,
+0x01, 0x48, 0xC0, 0x80, 0x01, 0x21, 0x10, 0x03,
+0x0A, 0x13, 0x01, 0x48, 0x2D, 0x80, 0x01, 0x0E,
+0xE7, 0x12, 0x01, 0x21, 0x01, 0x48, 0x2D, 0x80,
+0x01, 0x0E, 0xE3, 0x12, 0x50, 0x1A, 0xA3, 0x12,
+0x60, 0x1A, 0xE0, 0x04, 0x0F, 0x98, 0x58, 0x6B,
+0x0F, 0x98, 0xE3, 0x6B, 0x0F, 0x98, 0x27, 0x73,
+0xD0, 0x03, 0x32, 0x13, 0xD7, 0x7B, 0xC0, 0x03,
+0xC8, 0x12, 0xDC, 0x20, 0xD0, 0x22, 0x40, 0x00,
+0x0D, 0x0D, 0xC8, 0x12, 0xD0, 0x03, 0x33, 0x13,
+0xD7, 0x7B, 0xC0, 0x03, 0xC9, 0x12, 0xDC, 0x20,
+0xD0, 0x22, 0x40, 0x00, 0x0D, 0x0D, 0xC9, 0x12,
+0xFF, 0xA0, 0xC0, 0x03, 0xC8, 0x12, 0xC0, 0x49,
+0x3B, 0x80, 0x00, 0x0E, 0xC8, 0x12, 0x6F, 0x80,
+0xB0, 0x03, 0xC6, 0x12, 0xCB, 0x48, 0x2C, 0x80,
+0x0B, 0x0D, 0xC8, 0x12, 0xC0, 0x03, 0xC9, 0x12,
+0xC0, 0x49, 0x3B, 0x80, 0x00, 0x0E, 0xC9, 0x12,
+0x6F, 0x80, 0xB0, 0x03, 0xC7, 0x12, 0xCB, 0x48,
+0x2C, 0x80, 0x0B, 0x0D, 0xC9, 0x12, 0xA0, 0x03,
+0xCD, 0x12, 0x90, 0x03, 0xAA, 0x00, 0x0A, 0x0D,
+0x18, 0xF9, 0x00, 0x0E, 0x19, 0xF9, 0x09, 0x0D,
+0x1A, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xA0, 0x03,
+0x18, 0xF9, 0xA0, 0x4A, 0xFF, 0x00, 0x2C, 0x80,
+0xA0, 0x1A, 0xFF, 0x00, 0xA1, 0x49, 0x1B, 0x80,
+0xA1, 0x19, 0x0A, 0x0D, 0xCD, 0x12, 0xC0, 0x03,
+0xC8, 0x12, 0x00, 0x03, 0x09, 0x16, 0x00, 0x49,
+0x20, 0x80, 0xC0, 0x3A, 0x80, 0x00, 0xC0, 0x49,
+0x1B, 0x80, 0xC0, 0x19, 0x0C, 0x0D, 0xC8, 0x12,
+0xD0, 0x03, 0xC9, 0x12, 0x00, 0x03, 0x07, 0x16,
+0x00, 0x49, 0x20, 0x80, 0xD0, 0x3A, 0x80, 0x00,
+0xD0, 0x49, 0x1B, 0x80, 0xD0, 0x19, 0x0D, 0x0D,
+0xC9, 0x12, 0xA0, 0x03, 0xC8, 0x12, 0xB0, 0x03,
+0x61, 0x01, 0xAB, 0x48, 0x2B, 0x80, 0x0B, 0x0D,
+0xC8, 0x12, 0xA0, 0x03, 0xC8, 0x12, 0x00, 0x03,
+0x62, 0x01, 0xB0, 0x03, 0xC6, 0x12, 0xB0, 0x38,
+0xAB, 0x48, 0x2D, 0x80, 0x0B, 0x0D, 0xC8, 0x12,
+0xA0, 0x03, 0xC9, 0x12, 0xB0, 0x03, 0x63, 0x01,
+0xAB, 0x48, 0x2B, 0x80, 0x0B, 0x0D, 0xC9, 0x12,
+0xA0, 0x03, 0xC9, 0x12, 0x00, 0x03, 0x64, 0x01,
+0xB0, 0x03, 0xC7, 0x12, 0xB0, 0x38, 0xAB, 0x48,
+0x2D, 0x80, 0x0B, 0x0D, 0xC9, 0x12, 0x00, 0x03,
+0x92, 0x01, 0x04, 0x51, 0x61, 0x83, 0x90, 0x1A,
+0x80, 0x00, 0x89, 0x18, 0x00, 0x03, 0x60, 0x01,
+0x80, 0x38, 0xA0, 0x03, 0xC8, 0x12, 0xA9, 0x48,
+0x6B, 0x80, 0xD0, 0x03, 0x61, 0x01, 0x0F, 0x98,
+0x8C, 0x68, 0x03, 0x0D, 0xC8, 0x12, 0xA0, 0x03,
+0xC8, 0x12, 0x09, 0x18, 0xB0, 0x03, 0xC6, 0x12,
+0xB0, 0x38, 0xAB, 0x48, 0x6D, 0x80, 0xD0, 0x03,
+0x62, 0x01, 0x0F, 0x98, 0x98, 0x68, 0x00, 0x0D,
+0xC8, 0x12, 0xA0, 0x03, 0xC9, 0x12, 0xA9, 0x48,
+0x6B, 0x80, 0xD0, 0x03, 0x63, 0x01, 0x0F, 0x98,
+0x8C, 0x68, 0x03, 0x0D, 0xC9, 0x12, 0xA0, 0x03,
+0xC9, 0x12, 0x09, 0x18, 0xB0, 0x03, 0xC7, 0x12,
+0xB0, 0x38, 0xAB, 0x48, 0x6D, 0x80, 0xD0, 0x03,
+0x64, 0x01, 0x0F, 0x98, 0x98, 0x68, 0x00, 0x0D,
+0xC9, 0x12, 0xA0, 0x03, 0xC8, 0x12, 0xB0, 0x03,
+0x3F, 0x01, 0xAB, 0x48, 0x2B, 0x80, 0x0B, 0x0D,
+0xC8, 0x12, 0xA0, 0x03, 0xC8, 0x12, 0x00, 0x03,
+0x40, 0x01, 0xB0, 0x03, 0xC6, 0x12, 0xB0, 0x38,
+0xAB, 0x48, 0x2D, 0x80, 0x0B, 0x0D, 0xC8, 0x12,
+0xA0, 0x03, 0xC9, 0x12, 0xB0, 0x03, 0x41, 0x01,
+0xAB, 0x48, 0x2B, 0x80, 0x0B, 0x0D, 0xC9, 0x12,
+0xA0, 0x03, 0xC9, 0x12, 0x00, 0x03, 0x42, 0x01,
+0xB0, 0x03, 0xC7, 0x12, 0xB0, 0x38, 0xAB, 0x48,
+0x2D, 0x80, 0x0B, 0x0D, 0xC9, 0x12, 0xA0, 0x03,
+0xC8, 0x12, 0xB0, 0x03, 0x3F, 0x01, 0xAB, 0x38,
+0x0A, 0x0D, 0xC8, 0x12, 0xA0, 0x03, 0xC9, 0x12,
+0xB0, 0x03, 0x41, 0x01, 0xAB, 0x38, 0x0A, 0x0D,
+0xC9, 0x12, 0x80, 0x03, 0x35, 0x01, 0x90, 0x03,
+0x36, 0x01, 0x00, 0x03, 0x37, 0x01, 0x02, 0x51,
+0x40, 0x80, 0x90, 0x03, 0x35, 0x01, 0x80, 0x03,
+0x36, 0x01, 0xC0, 0x03, 0xC9, 0x12, 0xD0, 0x03,
+0xC7, 0x12, 0x00, 0x03, 0x41, 0x01, 0xD0, 0x38,
+0x00, 0x03, 0x42, 0x01, 0x18, 0x18, 0x0F, 0x98,
+0x19, 0x6B, 0xA0, 0x03, 0x18, 0xF9, 0x0A, 0x0D,
+0xC9, 0x12, 0xC0, 0x03, 0xC8, 0x12, 0xD0, 0x03,
+0xC6, 0x12, 0x00, 0x03, 0x3F, 0x01, 0xD0, 0x38,
+0x00, 0x03, 0x40, 0x01, 0x19, 0x18, 0x0F, 0x98,
+0x19, 0x6B, 0xA0, 0x03, 0x18, 0xF9, 0x0A, 0x0D,
+0xC8, 0x12, 0x00, 0x03, 0x37, 0x01, 0x02, 0x51,
+0x80, 0x80, 0x00, 0x03, 0xC9, 0x12, 0x10, 0x03,
+0xC8, 0x12, 0x00, 0x0D, 0xC8, 0x12, 0x01, 0x0D,
+0xC9, 0x12, 0x00, 0x03, 0x37, 0x01, 0x01, 0x51,
+0xA0, 0x80, 0xB0, 0x03, 0x36, 0x01, 0xA0, 0x03,
+0xC8, 0x12, 0xBA, 0x38, 0xB0, 0x49, 0x1B, 0x80,
+0xB0, 0x19, 0x0B, 0x0D, 0xC8, 0x12, 0x00, 0x03,
+0x37, 0x01, 0x00, 0x51, 0xA0, 0x80, 0xB0, 0x03,
+0x35, 0x01, 0xA0, 0x03, 0xC9, 0x12, 0xBA, 0x38,
+0xB0, 0x49, 0x1B, 0x80, 0xB0, 0x19, 0x0B, 0x0D,
+0xC9, 0x12, 0xD0, 0x03, 0x35, 0x01, 0xA0, 0x03,
+0xC9, 0x12, 0xAD, 0x48, 0x2D, 0x80, 0x0D, 0x0D,
+0xC9, 0x12, 0xA0, 0x49, 0x2B, 0x80, 0x00, 0x0E,
+0xC9, 0x12, 0xD0, 0x03, 0x36, 0x01, 0xA0, 0x03,
+0xC8, 0x12, 0xAD, 0x48, 0x2D, 0x80, 0x0D, 0x0D,
+0xC8, 0x12, 0xA0, 0x49, 0x2B, 0x80, 0x00, 0x0E,
+0xC8, 0x12, 0x00, 0x03, 0x09, 0x17, 0x00, 0x49,
+0xB0, 0x82, 0x60, 0x03, 0xEE, 0x01, 0x70, 0x1A,
+0xEF, 0x01, 0x50, 0x03, 0xC9, 0x12, 0x40, 0x03,
+0xC8, 0x12, 0x04, 0x0D, 0xEC, 0x12, 0x05, 0x0D,
+0xED, 0x12, 0xB0, 0x03, 0xC9, 0x01, 0x97, 0x01,
+0x09, 0x0D, 0xF7, 0x12, 0x87, 0x01, 0x08, 0x0D,
+0xF6, 0x12, 0x70, 0x4A, 0x35, 0x02, 0x01, 0xB0,
+0x70, 0x1A, 0x49, 0x02, 0x0F, 0x98, 0x01, 0x6E,
+0xAB, 0x48, 0xCA, 0x80, 0xC0, 0x03, 0xCD, 0x12,
+0xD0, 0x03, 0xD3, 0x01, 0xCD, 0x48, 0x0D, 0x98,
+0x35, 0x6B, 0x05, 0x0D, 0xC9, 0x12, 0x04, 0x0D,
+0xC8, 0x12, 0x2F, 0x80, 0x61, 0x39, 0x31, 0x86,
+0xA0, 0x03, 0x91, 0x02, 0xA2, 0x7B, 0xB0, 0x1A,
+0xB0, 0x13, 0xBA, 0x20, 0xA0, 0x03, 0xC9, 0x12,
+0xBA, 0x09, 0xA0, 0x03, 0xC8, 0x12, 0xBA, 0x09,
+0xA0, 0x03, 0xCD, 0x12, 0xBA, 0x09, 0x00, 0x03,
+0x9B, 0x02, 0xA0, 0x48, 0x2D, 0x80, 0x0A, 0x0D,
+0x9B, 0x02, 0x0B, 0x0D, 0x90, 0x16, 0xA0, 0x03,
+0x29, 0x13, 0x10, 0x03, 0x85, 0x00, 0x12, 0x49,
+0x11, 0x81, 0x0F, 0x98, 0xAF, 0x61, 0xB0, 0x03,
+0x90, 0x16, 0xA0, 0x03, 0xCF, 0x12, 0x00, 0x03,
+0xCD, 0x12, 0xA0, 0x48, 0x3D, 0x80, 0xA0, 0x18,
+0xA0, 0x62, 0xFF, 0x00, 0x00, 0x03, 0xCC, 0x12,
+0x08, 0x7B, 0xA0, 0x68, 0xBA, 0x08, 0xA0, 0x03,
+0x91, 0x02, 0x0F, 0x98, 0x5D, 0x54, 0xA0, 0x1E,
+0xB0, 0x1A, 0x62, 0x14, 0xBA, 0x20, 0x00, 0x03,
+0x0B, 0x13, 0xB0, 0x09, 0x00, 0x03, 0x0C, 0x13,
+0xB0, 0x09, 0x00, 0x03, 0x09, 0x13, 0xB0, 0x09,
+0x00, 0x03, 0x0A, 0x13, 0xB0, 0x09, 0x00, 0x03,
+0xCE, 0x12, 0xB0, 0x09, 0x00, 0x03, 0x29, 0x13,
+0xB0, 0x09, 0x00, 0x03, 0x28, 0x13, 0xB0, 0x09,
+0xA0, 0x1A, 0x60, 0x09, 0x10, 0x03, 0x90, 0x02,
+0xA1, 0x20, 0x0A, 0x00, 0xB0, 0x09, 0x10, 0x03,
+0x9C, 0x02, 0x01, 0x48, 0x2D, 0x80, 0x00, 0x0D,
+0x9C, 0x02, 0x00, 0x03, 0xFE, 0x12, 0xB0, 0x08,
+0xFF, 0xA0, 0xD0, 0x38, 0xC0, 0x49, 0x1B, 0x80,
+0xC0, 0x19, 0xCD, 0x48, 0x1D, 0x80, 0xCD, 0x18,
+0x01, 0x0D, 0x10, 0xF9, 0x00, 0x0E, 0x11, 0xF9,
+0x0C, 0x0D, 0x12, 0xF9, 0x00, 0x0E, 0x13, 0xF9,
+0xFF, 0xFF, 0xFF, 0xFF, 0xB0, 0x03, 0x10, 0xF9,
+0xC0, 0x03, 0x11, 0xF9, 0x0B, 0x0D, 0x18, 0xF9,
+0x0C, 0x0D, 0x19, 0xF9, 0x0D, 0x0D, 0x1A, 0xF9,
+0xFF, 0xA0, 0xA0, 0x03, 0xCA, 0x01, 0x84, 0x38,
+0xC8, 0x18, 0xCF, 0x51, 0x10, 0x80, 0xC0, 0x31,
+0xC2, 0x49, 0x9D, 0x80, 0x08, 0x18, 0x1A, 0x18,
+0x0F, 0x98, 0xA7, 0x54, 0x20, 0x1A, 0x64, 0x00,
+0x0F, 0x98, 0xE7, 0x54, 0x40, 0x20, 0x95, 0x38,
+0xD9, 0x18, 0xDF, 0x51, 0x10, 0x80, 0xD0, 0x31,
+0xD2, 0x49, 0x9D, 0x80, 0x09, 0x18, 0x1A, 0x18,
+0x0F, 0x98, 0xA7, 0x54, 0x20, 0x1A, 0x64, 0x00,
+0x0F, 0x98, 0xE7, 0x54, 0x50, 0x20, 0xFF, 0xA0,
+0xC5, 0x18, 0xB0, 0x1A, 0x19, 0x00, 0xC0, 0x0B,
+0xC1, 0x21, 0xB1, 0x39, 0xC1, 0x87, 0x10, 0x03,
+0x09, 0x16, 0x00, 0x03, 0x30, 0x13, 0x00, 0x0D,
+0xEE, 0x12, 0x0C, 0x0E, 0xF0, 0x12, 0x01, 0x39,
+0x01, 0x48, 0x4C, 0x80, 0x00, 0x0D, 0xEE, 0x12,
+0x07, 0x0E, 0xF0, 0x12, 0x01, 0x39, 0x01, 0x48,
+0x4C, 0x80, 0x00, 0x0D, 0xEE, 0x12, 0x02, 0x0E,
+0xF0, 0x12, 0x10, 0x03, 0x0A, 0x16, 0x00, 0x03,
+0x30, 0x13, 0x00, 0x0D, 0xF1, 0x12, 0x01, 0x21,
+0x01, 0x48, 0x2A, 0x80, 0x00, 0x0D, 0xF1, 0x12,
+0x01, 0x21, 0x01, 0x48, 0x2A, 0x80, 0x00, 0x0D,
+0xF1, 0x12, 0x10, 0x03, 0x07, 0x16, 0x00, 0x03,
+0x31, 0x13, 0x00, 0x0D, 0xEF, 0x12, 0x74, 0x19,
+0x01, 0x39, 0x01, 0x48, 0x8C, 0x80, 0x00, 0x0D,
+0xEF, 0x12, 0x20, 0x03, 0xF0, 0x12, 0x21, 0x39,
+0x02, 0x0D, 0xF0, 0x12, 0x71, 0x39, 0x01, 0x39,
+0x01, 0x48, 0x8C, 0x80, 0x00, 0x0D, 0xEF, 0x12,
+0x20, 0x03, 0xF0, 0x12, 0x21, 0x39, 0x02, 0x0D,
+0xF0, 0x12, 0x71, 0x39, 0x10, 0x03, 0x08, 0x16,
+0x00, 0x03, 0x31, 0x13, 0x00, 0x0D, 0xF2, 0x12,
+0x01, 0x21, 0x01, 0x48, 0x3A, 0x80, 0x00, 0x0D,
+0xF2, 0x12, 0x71, 0x39, 0x01, 0x21, 0x01, 0x48,
+0x3A, 0x80, 0x00, 0x0D, 0xF2, 0x12, 0x71, 0x39,
+0x20, 0x03, 0xF0, 0x12, 0x52, 0x20, 0xA0, 0x03,
+0xEE, 0x12, 0xB6, 0x18, 0x00, 0x03, 0xD6, 0x00,
+0x0F, 0x98, 0x59, 0x54, 0x00, 0x1E, 0xB0, 0x20,
+0x80, 0x03, 0xEF, 0x12, 0x90, 0x03, 0xF2, 0x12,
+0x30, 0x03, 0xF1, 0x12, 0xB8, 0x20, 0x0B, 0x01,
+0x50, 0x09, 0x81, 0x21, 0x89, 0x48, 0xBD, 0x87,
+0x57, 0x20, 0xA1, 0x21, 0xA3, 0x48, 0x9D, 0x86,
+0xFF, 0xA0, 0xC0, 0x1A, 0xA3, 0x12, 0xC5, 0x20,
+0xB5, 0x19, 0xC0, 0x0B, 0xC5, 0x21, 0xB1, 0x39,
+0xC1, 0x87, 0xFF, 0xA0, 0xC0, 0x1A, 0xA3, 0x12,
+0xC5, 0x20, 0xB5, 0x19, 0x00, 0x19, 0xC0, 0x09,
+0xB1, 0x39, 0xD1, 0x87, 0xFF, 0xA0, 0x00, 0x03,
+0xE0, 0x12, 0x00, 0x49, 0x30, 0x80, 0x50, 0x19,
+0x0F, 0x98, 0xD1, 0x6B, 0x00, 0x03, 0xE1, 0x12,
+0x00, 0x49, 0x30, 0x80, 0x50, 0x19, 0x0F, 0x98,
+0xDA, 0x6B, 0x00, 0x03, 0xE2, 0x12, 0x00, 0x49,
+0x30, 0x80, 0x54, 0x19, 0x0F, 0x98, 0xD1, 0x6B,
+0x00, 0x03, 0xE3, 0x12, 0x00, 0x49, 0x40, 0x80,
+0x50, 0x1A, 0x14, 0x00, 0x0F, 0x98, 0xDA, 0x6B,
+0x00, 0x03, 0xE4, 0x12, 0x00, 0x49, 0x30, 0x80,
+0x51, 0x19, 0x0F, 0x98, 0xD1, 0x6B, 0x00, 0x03,
+0xE5, 0x12, 0x00, 0x49, 0x30, 0x80, 0x55, 0x19,
+0x0F, 0x98, 0xDA, 0x6B, 0x00, 0x03, 0xE6, 0x12,
+0x00, 0x49, 0x30, 0x80, 0x53, 0x19, 0x0F, 0x98,
+0xD1, 0x6B, 0x00, 0x03, 0xE7, 0x12, 0x00, 0x49,
+0xF0, 0xA0, 0x5F, 0x19, 0x0F, 0x88, 0xDA, 0x6B,
+0xB0, 0x1A, 0xF7, 0x00, 0xC0, 0x1A, 0x5D, 0x13,
+0x70, 0x1A, 0x35, 0x02, 0x00, 0x03, 0x8E, 0x00,
+0x00, 0x49, 0x00, 0x88, 0x69, 0x6C, 0x02, 0x49,
+0x00, 0x88, 0x69, 0x6C, 0x00, 0x0E, 0x39, 0x13,
+0x00, 0x0E, 0x3A, 0x13, 0xD0, 0x19, 0x9C, 0x18,
+0x8B, 0x18, 0xA9, 0x01, 0x8A, 0x09, 0xA9, 0x01,
+0x8A, 0x09, 0x59, 0x00, 0x48, 0x00, 0x80, 0x0B,
+0xA9, 0x00, 0xA8, 0x51, 0xF0, 0x80, 0xAD, 0x51,
+0x71, 0x80, 0x85, 0x08, 0x00, 0x03, 0x3A, 0x13,
+0x01, 0x21, 0x00, 0x0D, 0x3A, 0x13, 0x9F, 0x80,
+0x48, 0x51, 0xC0, 0x80, 0x50, 0x19, 0x5B, 0xC1,
+0x85, 0x08, 0x3F, 0x80, 0xAB, 0x51, 0x60, 0x80,
+0x85, 0x08, 0xA0, 0x03, 0x39, 0x13, 0xAD, 0xC0,
+0x0A, 0x0D, 0x39, 0x13, 0x91, 0x21, 0x09, 0x00,
+0x70, 0x09, 0xB4, 0x21, 0xC4, 0x21, 0xD1, 0x21,
+0xA0, 0x03, 0x8A, 0x00, 0xDA, 0x48, 0x31, 0x85,
+0xA0, 0x03, 0x39, 0x13, 0x0A, 0x0D, 0xF6, 0x00,
+0xB0, 0x03, 0xAD, 0x13, 0x0B, 0x0D, 0xF5, 0x00,
+0xA0, 0x03, 0x3A, 0x13, 0x0A, 0x0D, 0x74, 0x12,
+0xFF, 0xA0, 0xD0, 0x03, 0x8A, 0x00, 0x00, 0x0E,
+0x39, 0x13, 0x9C, 0x18, 0x92, 0x21, 0x89, 0x00,
+0x9C, 0x18, 0xA9, 0x01, 0xBA, 0x09, 0xA9, 0x01,
+0xBA, 0x09, 0x4B, 0x00, 0x8D, 0x51, 0x80, 0x80,
+0xB0, 0x0B, 0x48, 0x51, 0x30, 0x80, 0x40, 0x19,
+0x4B, 0xC1, 0xB4, 0x08, 0xB1, 0x21, 0x9F, 0x80,
+0x88, 0x51, 0x50, 0x80, 0x00, 0x03, 0x39, 0x13,
+0x01, 0x21, 0x00, 0x0D, 0x39, 0x13, 0xA9, 0x00,
+0xBA, 0x09, 0x91, 0x21, 0xA9, 0x00, 0x09, 0x00,
+0x00, 0x0D, 0xE9, 0x17, 0x80, 0x03, 0x09, 0x17,
+0x80, 0x49, 0x60, 0x80, 0x80, 0x03, 0xEB, 0x01,
+0x08, 0x0D, 0xEA, 0x17, 0x0F, 0x98, 0x55, 0x73,
+0xA0, 0x03, 0xE9, 0x17, 0xBA, 0x09, 0x7A, 0x09,
+0xC4, 0x21, 0xD1, 0x39, 0xE1, 0x84, 0xB0, 0x03,
+0xAD, 0x13, 0x0B, 0x0D, 0xF5, 0x00, 0xA0, 0x03,
+0x39, 0x13, 0x0A, 0x0D, 0x74, 0x12, 0xB0, 0x03,
+0xAF, 0x13, 0xB8, 0x7B, 0xAB, 0x68, 0x0A, 0x0D,
+0xF6, 0x00, 0xFF, 0xA0, 0xD0, 0x1A, 0x5D, 0x13,
+0xD2, 0x21, 0xB0, 0x1A, 0x85, 0x13, 0xB2, 0x21,
+0xCA, 0x19, 0x10, 0x19, 0xD0, 0x0B, 0xB0, 0x0B,
+0xD4, 0x21, 0xB4, 0x21, 0xC1, 0x39, 0xA1, 0x87,
+0x90, 0x1A, 0xE9, 0x14, 0x92, 0x21, 0xA0, 0x1A,
+0x34, 0x15, 0x80, 0x1A, 0x43, 0x15, 0x70, 0x1A,
+0x52, 0x15, 0xCF, 0x19, 0x10, 0x19, 0x90, 0x0B,
+0xA1, 0x09, 0x81, 0x09, 0x71, 0x09, 0x95, 0x21,
+0xC1, 0x39, 0x91, 0x87, 0x00, 0x0E, 0x76, 0x12,
+0xFF, 0xA0, 0x00, 0x0D, 0x00, 0xF9, 0x01, 0x0D,
+0x01, 0xF9, 0x02, 0x0D, 0x10, 0xF9, 0x03, 0x0D,
+0x11, 0xF9, 0x06, 0x18, 0x01, 0x39, 0x00, 0x0D,
+0x12, 0xF9, 0x00, 0x0E, 0x13, 0xF9, 0xFF, 0xFF,
+0xFF, 0xFF, 0x00, 0x03, 0x10, 0xF9, 0x10, 0x03,
+0x11, 0xF9, 0x00, 0x0D, 0x02, 0xF9, 0x01, 0x0D,
+0x03, 0xF9, 0x00, 0x03, 0x00, 0xF9, 0x10, 0x03,
+0x01, 0xF9, 0x00, 0x0D, 0x18, 0xF9, 0x01, 0x0D,
+0x19, 0xF9, 0x06, 0x0D, 0x1A, 0xF9, 0xFF, 0xFF,
+0xFF, 0xFF, 0x00, 0x03, 0x18, 0xF9, 0x10, 0x03,
+0x19, 0xF9, 0xFF, 0xA0, 0x60, 0x03, 0x3C, 0x17,
+0x68, 0x79, 0x60, 0x49, 0x21, 0x80, 0x61, 0x19,
+0xFF, 0xA0, 0x20, 0x03, 0x3D, 0x17, 0x20, 0x62,
+0xFF, 0x00, 0x02, 0x48, 0x7D, 0x80, 0x20, 0x03,
+0x3D, 0x17, 0x28, 0x79, 0x02, 0x48, 0xFD, 0xA0,
+0x61, 0x19, 0xFF, 0xA0, 0x30, 0x18, 0x00, 0x03,
+0x3D, 0x17, 0x08, 0x79, 0x20, 0x03, 0x3C, 0x17,
+0x20, 0x62, 0xFF, 0x00, 0x0F, 0x98, 0xE7, 0x54,
+0x20, 0x18, 0x03, 0x18, 0x0F, 0x98, 0xE7, 0x54,
+0x60, 0x03, 0x3C, 0x17, 0x60, 0x62, 0xFF, 0x00,
+0x60, 0x38, 0x00, 0x03, 0x3C, 0x17, 0x08, 0x79,
+0x60, 0x48, 0xFB, 0xA0, 0x60, 0x18, 0xFF, 0xA0,
+0x00, 0x0E, 0x11, 0xF9, 0x00, 0x1A, 0x64, 0x00,
+0x00, 0x0D, 0x12, 0xF9, 0x00, 0x0E, 0x13, 0xF9,
+0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x03, 0x10, 0xF9,
+0x10, 0x03, 0x11, 0xF9, 0xB0, 0x03, 0x06, 0x16,
+0xB4, 0x20, 0x2B, 0x01, 0x3B, 0x00, 0x0F, 0x98,
+0xD1, 0x6C, 0xB1, 0x0A, 0xB0, 0x08, 0x00, 0x0D,
+0x18, 0xF9, 0x01, 0x0D, 0x19, 0xF9, 0x00, 0x1A,
+0x64, 0x00, 0x00, 0x0D, 0x1A, 0xF9, 0xFF, 0xFF,
+0xFF, 0xFF, 0x00, 0x03, 0x18, 0xF9, 0xFF, 0xA0,
+0x00, 0x0E, 0x3E, 0x17, 0x00, 0x0E, 0x3F, 0x17,
+0x06, 0x0D, 0x90, 0x16, 0xB0, 0x03, 0x06, 0x16,
+0xB6, 0x21, 0x0B, 0x01, 0x1B, 0x01, 0x0B, 0x00,
+0x04, 0x18, 0x07, 0x38, 0x0F, 0x51, 0x10, 0x80,
+0x00, 0x31, 0x10, 0x03, 0x43, 0x01, 0x01, 0x48,
+0x2A, 0x80, 0x01, 0x0E, 0x3E, 0x17, 0x15, 0x18,
+0x18, 0x38, 0x1F, 0x51, 0x10, 0x80, 0x10, 0x31,
+0x20, 0x03, 0x43, 0x01, 0x12, 0x48, 0x3A, 0x80,
+0x01, 0x0E, 0x3F, 0x17, 0xCF, 0x80, 0x00, 0x03,
+0x3E, 0x17, 0x01, 0x49, 0x80, 0x80, 0x00, 0x03,
+0x44, 0x01, 0x00, 0x0D, 0x8F, 0x16, 0xB0, 0x0A,
+0xB8, 0x0A, 0xB7, 0x08, 0x8F, 0x80, 0x0B, 0x00,
+0x01, 0x39, 0x00, 0x49, 0x0B, 0xB0, 0x00, 0x19,
+0xB0, 0x08, 0x00, 0x0D, 0x8F, 0x16, 0xB0, 0x03,
+0x06, 0x16, 0xB9, 0x21, 0x4B, 0x00, 0xB7, 0x09,
+0x5B, 0x00, 0xB8, 0x08, 0x07, 0x0D, 0x91, 0x16,
+0x08, 0x0D, 0x92, 0x16, 0x04, 0x18, 0x07, 0x38,
+0x0F, 0x51, 0x10, 0x80, 0x00, 0x31, 0x00, 0x0D,
+0x35, 0x13, 0x15, 0x18, 0x18, 0x38, 0x1F, 0x51,
+0x10, 0x80, 0x10, 0x31, 0x01, 0x0D, 0x37, 0x13,
+0x0F, 0x98, 0x1A, 0x6E, 0x0A, 0x0D, 0x38, 0x13,
+0xB0, 0x03, 0x06, 0x16, 0xB5, 0x21, 0x0B, 0x00,
+0xBA, 0x08, 0x0A, 0x48, 0xAD, 0x80, 0x07, 0x59,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x1E,
+0x0A, 0x20, 0x06, 0x21, 0x03, 0x79, 0xB0, 0x08,
+0x9F, 0x80, 0x03, 0x59, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0x00, 0x1E, 0x0A, 0x20, 0x03, 0x21,
+0x02, 0x79, 0xB0, 0x08, 0x10, 0x03, 0x8C, 0x00,
+0x1C, 0x51, 0x21, 0x80, 0x01, 0x0E, 0x8F, 0x16,
+0x10, 0x03, 0x8F, 0x16, 0x10, 0x49, 0xA0, 0x80,
+0x0F, 0x98, 0xFA, 0x6C, 0x00, 0x03, 0x3C, 0x16,
+0x60, 0x20, 0x06, 0x0D, 0x93, 0x16, 0x06, 0x0D,
+0x94, 0x16, 0x2F, 0x81, 0x00, 0x03, 0x35, 0x13,
+0x0F, 0x98, 0xFA, 0x6C, 0x00, 0x03, 0x3C, 0x16,
+0x60, 0x20, 0x06, 0x0D, 0x93, 0x16, 0x00, 0x03,
+0x37, 0x13, 0x0F, 0x98, 0xFA, 0x6C, 0x00, 0x03,
+0x3C, 0x16, 0x60, 0x20, 0x06, 0x0D, 0x94, 0x16,
+0x60, 0x03, 0x93, 0x16, 0x06, 0x0D, 0x95, 0x16,
+0x07, 0x18, 0x60, 0x49, 0x50, 0x80, 0x07, 0x0D,
+0x10, 0xF9, 0x40, 0x19, 0x0F, 0x98, 0x28, 0x6D,
+0x00, 0x0D, 0x91, 0x16, 0x60, 0x03, 0x94, 0x16,
+0x06, 0x0D, 0x96, 0x16, 0x08, 0x18, 0x60, 0x49,
+0x50, 0x80, 0x08, 0x0D, 0x10, 0xF9, 0x42, 0x19,
+0x0F, 0x98, 0x28, 0x6D, 0x00, 0x0D, 0x92, 0x16,
+0x70, 0x03, 0x91, 0x16, 0x80, 0x03, 0x92, 0x16,
+0xFF, 0xA0, 0xA0, 0x03, 0xF6, 0x12, 0xD0, 0x03,
+0xEC, 0x12, 0xAD, 0x38, 0xAF, 0x51, 0x10, 0x80,
+0xA0, 0x31, 0x0A, 0x0D, 0x35, 0x13, 0xA0, 0x03,
+0xF7, 0x12, 0xD0, 0x03, 0xED, 0x12, 0xAD, 0x38,
+0xAF, 0x51, 0x10, 0x80, 0xA0, 0x31, 0x0A, 0x0D,
+0x37, 0x13, 0x0F, 0x98, 0x1A, 0x6E, 0x0A, 0x0D,
+0x38, 0x13, 0xFF, 0xA0, 0xA0, 0x03, 0x35, 0x13,
+0xD0, 0x03, 0x37, 0x13, 0xA0, 0x49, 0x21, 0x80,
+0xAD, 0x18, 0xFF, 0xA0, 0xD0, 0x49, 0xF0, 0xA0,
+0xAD, 0x48, 0x1B, 0x80, 0xAD, 0x18, 0x00, 0x03,
+0x35, 0x13, 0x10, 0x18, 0x0F, 0x98, 0xA7, 0x54,
+0x00, 0x0D, 0x00, 0xF9, 0x01, 0x0D, 0x01, 0xF9,
+0x00, 0x03, 0x37, 0x13, 0x10, 0x18, 0x0F, 0x98,
+0xA7, 0x54, 0x00, 0x0D, 0x02, 0xF9, 0x01, 0x0D,
+0x03, 0xF9, 0x00, 0x03, 0x00, 0xF9, 0x10, 0x03,
+0x01, 0xF9, 0x00, 0x0D, 0x18, 0xF9, 0x01, 0x0D,
+0x19, 0xF9, 0xD0, 0x19, 0x26, 0x19, 0x0A, 0x0D,
+0x1A, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x03,
+0x18, 0xF9, 0x10, 0x03, 0x19, 0xF9, 0x00, 0x0D,
+0x00, 0xF9, 0x01, 0x0D, 0x01, 0xF9, 0x0A, 0x0D,
+0x02, 0xF9, 0x0D, 0x0D, 0x03, 0xF9, 0xA0, 0x03,
+0x00, 0xF9, 0xD0, 0x03, 0x01, 0xF9, 0xA1, 0x79,
+0xD0, 0x51, 0xAF, 0xC5, 0xD1, 0x79, 0x21, 0x39,
+0x61, 0x86, 0xFF, 0xA0, 0xB0, 0x03, 0x51, 0x13,
+0xD0, 0x19, 0xBD, 0x50, 0xF0, 0xA0, 0xD1, 0x21,
+0xDF, 0x49, 0xB1, 0x87, 0xFF, 0xA0, 0x0F, 0x98,
+0x5E, 0x6E, 0xDF, 0x49, 0xF0, 0xA0, 0xA0, 0x03,
+0x86, 0x12, 0xA1, 0x21, 0x0A, 0x0D, 0x86, 0x12,
+0xA0, 0x03, 0x51, 0x13, 0xAD, 0xC0, 0x0A, 0x0D,
+0x51, 0x13, 0xA0, 0x03, 0x50, 0x13, 0xAD, 0xC0,
+0x0A, 0x0D, 0x50, 0x13, 0x90, 0x1A, 0xE9, 0x14,
+0xAD, 0x18, 0x0F, 0x98, 0x5B, 0x54, 0xA0, 0x1E,
+0x9A, 0x20, 0xC0, 0x1A, 0xB0, 0x13, 0xA0, 0x03,
+0x52, 0x13, 0xA2, 0x7B, 0xCA, 0x20, 0x0C, 0x01,
+0x90, 0x09, 0x0C, 0x01, 0x90, 0x09, 0xA0, 0x03,
+0xF3, 0x12, 0xA0, 0x62, 0xFF, 0x00, 0x50, 0x1A,
+0x43, 0x15, 0x5D, 0x20, 0x50, 0x0B, 0x50, 0x1A,
+0x34, 0x15, 0x5D, 0x20, 0x10, 0x03, 0x77, 0x12,
+0x51, 0x08, 0xAE, 0xC1, 0xA8, 0xC1, 0xAA, 0xC1,
+0xA9, 0xC1, 0x9A, 0x08, 0xC1, 0x21, 0x91, 0x21,
+0x0C, 0x00, 0x90, 0x08, 0xA0, 0x03, 0x52, 0x13,
+0x0F, 0x98, 0x5D, 0x54, 0xA0, 0x1E, 0xC0, 0x1A,
+0x62, 0x14, 0xCA, 0x20, 0xC5, 0x21, 0x0C, 0x00,
+0x10, 0x03, 0x9A, 0x00, 0x10, 0x49, 0x40, 0x80,
+0x0F, 0x98, 0x95, 0x64, 0x91, 0x21, 0x90, 0x08,
+0x80, 0x1A, 0x52, 0x15, 0x8D, 0x20, 0x80, 0x0B,
+0xFF, 0xA0, 0x10, 0x19, 0x00, 0x03, 0xED, 0x17,
+0x00, 0x49, 0xF1, 0xA0, 0x10, 0x03, 0x9A, 0x00,
+0x10, 0x49, 0xF0, 0xA0, 0x20, 0x03, 0x52, 0x13,
+0x0F, 0x98, 0x5F, 0x54, 0x10, 0x1E, 0x20, 0x1A,
+0x62, 0x14, 0x21, 0x20, 0x25, 0x21, 0x02, 0x00,
+0x92, 0x21, 0x59, 0x00, 0x10, 0x03, 0x41, 0x17,
+0x20, 0x03, 0x48, 0x01, 0x12, 0x48, 0xDC, 0x80,
+0x05, 0x48, 0xBB, 0x80, 0x92, 0x39, 0xA8, 0xC9,
+0xAB, 0xC1, 0x9A, 0x08, 0x00, 0x03, 0x86, 0x12,
+0x01, 0x39, 0x00, 0x0D, 0x86, 0x12, 0x11, 0x19,
+0xFF, 0xA0, 0x10, 0x03, 0x9A, 0x00, 0x0F, 0x98,
+0x95, 0x64, 0x05, 0x48, 0x0B, 0xB0, 0x05, 0x18,
+0x90, 0x08, 0x92, 0x39, 0x10, 0x19, 0xFF, 0xA0,
+0xC0, 0x1A, 0xB0, 0x13, 0xA0, 0x03, 0x52, 0x13,
+0xA2, 0x7B, 0xCA, 0x20, 0x90, 0x1A, 0xE9, 0x14,
+0xA0, 0x03, 0x53, 0x13, 0x0F, 0x98, 0x5B, 0x54,
+0xA0, 0x1E, 0x9A, 0x20, 0x7C, 0x01, 0x97, 0x09,
+0x8C, 0x01, 0x98, 0x09, 0xAC, 0x00, 0xA0, 0x62,
+0xFF, 0x00, 0x20, 0x03, 0x77, 0x12, 0x70, 0x1A,
+0x34, 0x15, 0x00, 0x03, 0x53, 0x13, 0x70, 0x20,
+0x07, 0x00, 0x02, 0x48, 0x9B, 0x80, 0x80, 0x1A,
+0x43, 0x15, 0x00, 0x03, 0x53, 0x13, 0x80, 0x20,
+0x80, 0x0B, 0xAE, 0xC9, 0x10, 0x19, 0xFF, 0xA0,
+0x72, 0x08, 0xAE, 0xC1, 0x0F, 0x88, 0xB9, 0x6E,
+0x7A, 0x20, 0xA7, 0x00, 0x0A, 0x18, 0xAB, 0x48,
+0x2B, 0x80, 0x7B, 0x08, 0xAB, 0x18, 0x0A, 0x0D,
+0x41, 0x17, 0xFF, 0xA0, 0xB0, 0x1A, 0xE9, 0x14,
+0xA0, 0x03, 0x53, 0x13, 0x0F, 0x98, 0x5B, 0x54,
+0xA0, 0x1E, 0xBA, 0x20, 0xAB, 0x00, 0x0A, 0x0D,
+0xEC, 0x12, 0xB1, 0x21, 0xAB, 0x00, 0x0A, 0x0D,
+0xED, 0x12, 0x00, 0x0E, 0x3A, 0x13, 0xA0, 0x1A,
+0x10, 0x27, 0x0A, 0x0D, 0x3D, 0x13, 0x0A, 0x0D,
+0x52, 0x13, 0x90, 0x03, 0x3A, 0x13, 0x90, 0x4E,
+0x85, 0x12, 0x5B, 0x82, 0xA0, 0x03, 0x4F, 0x13,
+0xA9, 0x50, 0xB1, 0x81, 0xB0, 0x1A, 0xB0, 0x13,
+0xA0, 0x03, 0x3A, 0x13, 0xA2, 0x7B, 0xBA, 0x20,
+0xAB, 0x00, 0x0A, 0x0D, 0xF6, 0x12, 0xB1, 0x21,
+0xAB, 0x00, 0x0A, 0x0D, 0xF7, 0x12, 0x0F, 0x98,
+0x01, 0x6E, 0xB0, 0x03, 0x3D, 0x13, 0xAB, 0x48,
+0x8B, 0x80, 0xA0, 0x03, 0x38, 0x13, 0x0A, 0x0D,
+0x3D, 0x13, 0xA0, 0x03, 0x3A, 0x13, 0x0A, 0x0D,
+0x52, 0x13, 0x90, 0x03, 0x3A, 0x13, 0x91, 0x21,
+0x09, 0x0D, 0x3A, 0x13, 0x6F, 0x85, 0xFF, 0xA0,
+0xB0, 0x1A, 0xB0, 0x13, 0xA0, 0x03, 0x52, 0x13,
+0xA2, 0x7B, 0xBA, 0x20, 0xAB, 0x00, 0x0A, 0x0D,
+0xEC, 0x12, 0xB1, 0x21, 0xAB, 0x00, 0x0A, 0x0D,
+0xED, 0x12, 0x00, 0x0E, 0x3A, 0x13, 0xA0, 0x1A,
+0x10, 0x27, 0x0A, 0x0D, 0x3D, 0x13, 0x0A, 0x0D,
+0x53, 0x13, 0xA0, 0x03, 0x3A, 0x13, 0xAF, 0x49,
+0xAB, 0x82, 0x90, 0x03, 0x50, 0x13, 0x9A, 0x50,
+0x01, 0x82, 0xB0, 0x03, 0x51, 0x13, 0xBA, 0x50,
+0xC0, 0x81, 0xB0, 0x1A, 0xE9, 0x14, 0xA0, 0x03,
+0x3A, 0x13, 0x0F, 0x98, 0x5B, 0x54, 0xA0, 0x1E,
+0xBA, 0x20, 0xAB, 0x01, 0x0A, 0x0D, 0xF6, 0x12,
+0xAB, 0x00, 0x0A, 0x0D, 0xF7, 0x12, 0x0F, 0x98,
+0x01, 0x6E, 0xB0, 0x03, 0x3D, 0x13, 0xAB, 0x48,
+0x8B, 0x80, 0xA0, 0x03, 0x38, 0x13, 0x0A, 0x0D,
+0x3D, 0x13, 0xA0, 0x03, 0x3A, 0x13, 0x0A, 0x0D,
+0x53, 0x13, 0x90, 0x03, 0x3A, 0x13, 0x91, 0x21,
+0x09, 0x0D, 0x3A, 0x13, 0x2F, 0x85, 0xFF, 0xA0,
+0xD0, 0x19, 0xC0, 0x03, 0x51, 0x13, 0xB0, 0x03,
+0x50, 0x13, 0xBD, 0x50, 0x21, 0x80, 0xCD, 0x50,
+0xF1, 0xA0, 0xD1, 0x21, 0xDF, 0x49, 0x91, 0x87,
+0xFF, 0xA0, 0xB0, 0x03, 0x85, 0x12, 0xB0, 0x49,
+0x3B, 0x80, 0x00, 0x0E, 0x86, 0x12, 0xFF, 0xA0,
+0x90, 0x1A, 0xE9, 0x14, 0x92, 0x21, 0xC0, 0x19,
+0xB0, 0x19, 0xD0, 0x19, 0xA9, 0x00, 0xA8, 0x51,
+0x30, 0x80, 0xBC, 0xC0, 0xD1, 0x21, 0x3F, 0x80,
+0xA0, 0x62, 0xFF, 0x00, 0x9A, 0x08, 0x95, 0x21,
+0xC1, 0x21, 0xCF, 0x49, 0x31, 0x87, 0x0D, 0x0D,
+0x76, 0x12, 0x0B, 0x0D, 0x51, 0x13, 0xA0, 0x03,
+0x76, 0x12, 0xB0, 0x03, 0x85, 0x12, 0xBA, 0x68,
+0xB0, 0x49, 0x00, 0x88, 0xAE, 0x6C, 0x00, 0x0E,
+0x39, 0x13, 0x00, 0x0E, 0x50, 0x13, 0x00, 0x0E,
+0x4F, 0x13, 0x00, 0x0E, 0xF4, 0x12, 0x00, 0x0E,
+0xAD, 0x13, 0xA0, 0x03, 0x76, 0x12, 0xA0, 0x49,
+0x00, 0x88, 0x59, 0x70, 0x0F, 0x98, 0xA8, 0x6F,
+0xDF, 0x49, 0x00, 0x88, 0x59, 0x70, 0x0D, 0x0D,
+0x53, 0x13, 0x0D, 0x0D, 0x54, 0x13, 0x0F, 0x98,
+0x22, 0x6F, 0xA0, 0x03, 0x52, 0x13, 0xA0, 0x4A,
+0x10, 0x27, 0x00, 0x88, 0x59, 0x70, 0x0F, 0x98,
+0x64, 0x6F, 0xA0, 0x03, 0x53, 0x13, 0xA0, 0x4A,
+0x10, 0x27, 0x00, 0x88, 0x59, 0x70, 0x10, 0x03,
+0x54, 0x13, 0x00, 0x03, 0x53, 0x13, 0x10, 0x48,
+0x30, 0x80, 0x00, 0x0D, 0x54, 0x13, 0x7F, 0x86,
+0xA0, 0x03, 0x4F, 0x13, 0x90, 0x03, 0x52, 0x13,
+0xA9, 0xC0, 0x0A, 0x0D, 0x4F, 0x13, 0xA0, 0x03,
+0x50, 0x13, 0x90, 0x03, 0x53, 0x13, 0xA9, 0xC0,
+0x0A, 0x0D, 0x50, 0x13, 0x00, 0x0E, 0x41, 0x17,
+0x00, 0x03, 0x77, 0x12, 0x90, 0x1A, 0x34, 0x15,
+0xA0, 0x03, 0x53, 0x13, 0x9A, 0x20, 0x19, 0x00,
+0x10, 0x48, 0xEB, 0x80, 0xA9, 0x00, 0xA1, 0x21,
+0x9A, 0x08, 0x0F, 0x98, 0x2C, 0x70, 0x8F, 0x81,
+0xB0, 0x03, 0x3D, 0x13, 0x70, 0x1A, 0x52, 0x15,
+0xA0, 0x03, 0x53, 0x13, 0x0F, 0x88, 0x18, 0x6F,
+0x0F, 0x98, 0x2C, 0x70, 0x00, 0x4E, 0x3C, 0x01,
+0xBB, 0x80, 0x00, 0x03, 0x7D, 0x12, 0x00, 0x4E,
+0xC0, 0x01, 0x6B, 0x80, 0xB0, 0x03, 0x3D, 0x13,
+0xA0, 0x03, 0x3B, 0x01, 0xBA, 0x48, 0xBB, 0x80,
+0x0F, 0x98, 0xEC, 0x6E, 0x10, 0x49, 0xF1, 0x80,
+0xA8, 0xC1, 0xA9, 0xC1, 0x9A, 0x09, 0xC1, 0x21,
+0x8C, 0x00, 0x98, 0x08, 0x8F, 0x80, 0x80, 0x03,
+0x55, 0x13, 0x90, 0x03, 0x39, 0x13, 0x70, 0x1A,
+0xFF, 0x00, 0x0F, 0x98, 0x67, 0x6E, 0x0F, 0x88,
+0xEA, 0x6F, 0xA0, 0x03, 0x76, 0x12, 0xB0, 0x03,
+0x85, 0x12, 0xAB, 0x48, 0xF0, 0xA0, 0xBA, 0x48,
+0xBA, 0x82, 0xD0, 0x03, 0x50, 0x13, 0xC0, 0x19,
+0xB0, 0x03, 0x51, 0x13, 0xBC, 0x50, 0x00, 0x82,
+0xDC, 0x50, 0xE1, 0x81, 0x90, 0x1A, 0xE9, 0x14,
+0xAC, 0x18, 0x0F, 0x98, 0x5B, 0x54, 0xA0, 0x1E,
+0x9A, 0x20, 0x92, 0x21, 0xA9, 0x00, 0xA0, 0x62,
+0xFF, 0x00, 0x70, 0x1A, 0x34, 0x15, 0x7C, 0x20,
+0x87, 0x00, 0x70, 0x0B, 0x20, 0x03, 0x77, 0x12,
+0x82, 0x48, 0x2B, 0x80, 0xAE, 0xC9, 0x1F, 0x80,
+0xAE, 0xC1, 0xAB, 0xC1, 0x9A, 0x08, 0xB0, 0x03,
+0x51, 0x13, 0xBC, 0xC8, 0x0B, 0x0D, 0x51, 0x13,
+0xC1, 0x21, 0xCF, 0x49, 0x91, 0x85, 0xFF, 0xA0,
+0x00, 0x0E, 0x39, 0x13, 0xA0, 0x03, 0x39, 0x13,
+0xA0, 0x4E, 0x85, 0x12, 0xFB, 0xA0, 0x90, 0x03,
+0x39, 0x13, 0xA0, 0x03, 0x4F, 0x13, 0xA9, 0x50,
+0x01, 0x88, 0x0D, 0x71, 0x00, 0x0E, 0x3A, 0x13,
+0xA0, 0x1A, 0xFF, 0xFF, 0x0A, 0x0D, 0x3D, 0x13,
+0xA0, 0x03, 0x39, 0x13, 0x0F, 0x98, 0x5D, 0x54,
+0xA0, 0x1E, 0xC0, 0x1A, 0x62, 0x14, 0xCA, 0x20,
+0xC5, 0x21, 0x0C, 0x00, 0x10, 0x03, 0x8E, 0x12,
+0x01, 0x48, 0xBB, 0x80, 0x00, 0x03, 0x86, 0x12,
+0x01, 0x39, 0x00, 0x0D, 0x86, 0x12, 0x00, 0x49,
+0x0A, 0x88, 0x0D, 0x71, 0x00, 0x0E, 0x86, 0x12,
+0xFF, 0xA0, 0x0F, 0x98, 0x5E, 0x6E, 0xDF, 0x49,
+0xF0, 0xA0, 0xA0, 0x03, 0x51, 0x13, 0xAD, 0xC0,
+0x0A, 0x0D, 0x51, 0x13, 0x90, 0x03, 0x39, 0x13,
+0xA0, 0x03, 0x4F, 0x13, 0xA9, 0xC0, 0x0A, 0x0D,
+0x4F, 0x13, 0xC0, 0x1A, 0xB0, 0x13, 0xA0, 0x03,
+0x39, 0x13, 0xA2, 0x7B, 0xCA, 0x20, 0x90, 0x1A,
+0xE9, 0x14, 0xAD, 0x18, 0x0F, 0x98, 0x5B, 0x54,
+0xA0, 0x1E, 0x9A, 0x20, 0xAC, 0x01, 0x9A, 0x09,
+0xAC, 0x01, 0x9A, 0x09, 0x70, 0x1A, 0x34, 0x15,
+0x7D, 0x20, 0x87, 0x00, 0x81, 0x21, 0x78, 0x08,
+0xAC, 0x00, 0xA0, 0x62, 0xFF, 0x00, 0x20, 0x03,
+0x77, 0x12, 0x82, 0x48, 0x7B, 0x80, 0x80, 0x1A,
+0x43, 0x15, 0x0D, 0x18, 0x80, 0x20, 0x80, 0x0B,
+0xAE, 0xC9, 0x2F, 0x80, 0x72, 0x08, 0xAE, 0xC1,
+0xA8, 0xC1, 0xA9, 0xC1, 0x9A, 0x08, 0xC1, 0x21,
+0x91, 0x21, 0x8C, 0x00, 0x98, 0x08, 0xA0, 0x03,
+0x39, 0x13, 0x0F, 0x98, 0x5D, 0x54, 0xA0, 0x1E,
+0xC0, 0x1A, 0x62, 0x14, 0xCA, 0x20, 0xC5, 0x21,
+0x0C, 0x00, 0x10, 0x03, 0x9A, 0x00, 0x10, 0x49,
+0x40, 0x80, 0x0F, 0x98, 0x95, 0x64, 0x91, 0x21,
+0x90, 0x08, 0x70, 0x1A, 0x52, 0x15, 0x7D, 0x20,
+0x70, 0x0B, 0xA0, 0x03, 0x39, 0x13, 0xA1, 0x21,
+0x0A, 0x0D, 0x39, 0x13, 0x0F, 0x88, 0x8E, 0x70,
+0x00, 0x0E, 0xAE, 0x13, 0xD0, 0x03, 0x8A, 0x00,
+0xB0, 0x1A, 0xF7, 0x00, 0xC0, 0x1A, 0x5D, 0x13,
+0x50, 0x19, 0x9C, 0x18, 0x92, 0x21, 0x89, 0x00,
+0x88, 0x51, 0x60, 0x81, 0x8D, 0x51, 0x41, 0x81,
+0xA0, 0x03, 0xAE, 0x13, 0xA1, 0x21, 0x0A, 0x0D,
+0xAE, 0x13, 0x8F, 0x51, 0x50, 0x80, 0xA0, 0x03,
+0xAD, 0x13, 0xA8, 0xC1, 0x0A, 0x0D, 0xAD, 0x13,
+0x8A, 0x51, 0xF0, 0x80, 0xA0, 0x03, 0xAD, 0x13,
+0xA2, 0xC1, 0x0A, 0x0D, 0xAD, 0x13, 0x9F, 0x80,
+0x8B, 0x51, 0x10, 0x80, 0x51, 0x19, 0x9B, 0x18,
+0x92, 0x21, 0x89, 0x00, 0x88, 0x51, 0x10, 0x80,
+0x51, 0x19, 0xB4, 0x21, 0xC4, 0x21, 0xD1, 0x39,
+0x81, 0x85, 0xB0, 0x03, 0x74, 0x12, 0xA0, 0x03,
+0xAE, 0x13, 0xBA, 0x48, 0xF0, 0x80, 0xBA, 0x48,
+0x7C, 0x80, 0xA0, 0x03, 0xAD, 0x13, 0xA3, 0xC1,
+0xA0, 0xC1, 0x0A, 0x0D, 0xAD, 0x13, 0x6F, 0x80,
+0xA0, 0x03, 0xAD, 0x13, 0xAB, 0xC1, 0xA1, 0xC1,
+0x0A, 0x0D, 0xAD, 0x13, 0xA0, 0x03, 0xAD, 0x13,
+0xAB, 0xC9, 0xB0, 0x03, 0xAE, 0x13, 0xB0, 0x49,
+0x10, 0x80, 0xAB, 0xC1, 0x50, 0x49, 0x20, 0x80,
+0xA3, 0xC1, 0xA0, 0xC1, 0x0A, 0x0D, 0xAD, 0x13,
+0x0A, 0x18, 0x00, 0x62, 0x0F, 0x08, 0x00, 0x49,
+0xF0, 0xA0, 0x00, 0x03, 0x65, 0x01, 0x04, 0x51,
+0xB0, 0x80, 0x00, 0x03, 0xFE, 0x16, 0x01, 0x51,
+0x10, 0x80, 0xA5, 0xC1, 0x00, 0x03, 0xFE, 0x16,
+0x03, 0x51, 0x20, 0x80, 0xA4, 0xC1, 0x0F, 0x80,
+0x00, 0x03, 0x65, 0x01, 0x05, 0x51, 0x50, 0x80,
+0x00, 0x03, 0xFE, 0x16, 0x01, 0x51, 0x10, 0x80,
+0xA5, 0xC1, 0x0A, 0x0D, 0xAD, 0x13, 0xFF, 0xA0,
+0x00, 0x0E, 0x11, 0xF9, 0x00, 0x0D, 0x10, 0xF9,
+0x0F, 0x51, 0xF0, 0xA0, 0x20, 0x1A, 0xFF, 0xFF,
+0x02, 0x0D, 0x11, 0xF9, 0xFF, 0xA0, 0x00, 0x0E,
+0x13, 0xF9, 0x00, 0x0D, 0x12, 0xF9, 0x0F, 0x51,
+0xF0, 0xA0, 0x20, 0x1A, 0xFF, 0xFF, 0x02, 0x0D,
+0x13, 0xF9, 0xFF, 0xA0, 0x0D, 0x00, 0x0F, 0x98,
+0x88, 0x71, 0x00, 0x03, 0x1A, 0x17, 0x0F, 0x98,
+0x93, 0x71, 0x00, 0x03, 0x10, 0xF9, 0x00, 0x0D,
+0x23, 0x17, 0x00, 0x03, 0x11, 0xF9, 0x00, 0x0D,
+0x24, 0x17, 0xDB, 0x38, 0x3D, 0x02, 0x1D, 0x00,
+0xDB, 0x20, 0x4D, 0x00, 0xDB, 0x20, 0x0D, 0x01,
+0x10, 0x20, 0x0D, 0x01, 0x30, 0x20, 0x0D, 0x00,
+0x10, 0x20, 0xDB, 0x38, 0x0D, 0x00, 0x40, 0x20,
+0xDB, 0x38, 0x0D, 0x00, 0x10, 0x20, 0x03, 0x18,
+0x0F, 0x98, 0x88, 0x71, 0x00, 0x03, 0x1B, 0x17,
+0x0F, 0x98, 0x93, 0x71, 0x00, 0x03, 0x10, 0xF9,
+0x00, 0x0D, 0x25, 0x17, 0x00, 0x03, 0x11, 0xF9,
+0x00, 0x0D, 0x26, 0x17, 0x04, 0x18, 0x0F, 0x98,
+0x88, 0x71, 0x00, 0x03, 0x1B, 0x17, 0x0F, 0x98,
+0x93, 0x71, 0x00, 0x03, 0x10, 0xF9, 0x00, 0x0D,
+0x27, 0x17, 0x00, 0x03, 0x11, 0xF9, 0x00, 0x0D,
+0x28, 0x17, 0x01, 0x18, 0x0F, 0x98, 0x88, 0x71,
+0x00, 0x03, 0x1C, 0x17, 0x0F, 0x98, 0x93, 0x71,
+0x00, 0x03, 0x10, 0xF9, 0x10, 0x03, 0x11, 0xF9,
+0x20, 0x03, 0x23, 0x17, 0x30, 0x03, 0x24, 0x17,
+0x00, 0x0D, 0x00, 0xF9, 0x01, 0x0D, 0x01, 0xF9,
+0x02, 0x0D, 0x02, 0xF9, 0x03, 0x0D, 0x03, 0xF9,
+0x00, 0x03, 0x00, 0xF9, 0x10, 0x03, 0x01, 0xF9,
+0x20, 0x03, 0x25, 0x17, 0x30, 0x03, 0x26, 0x17,
+0x00, 0x0D, 0x00, 0xF9, 0x01, 0x0D, 0x01, 0xF9,
+0x02, 0x0D, 0x02, 0xF9, 0x03, 0x0D, 0x03, 0xF9,
+0x00, 0x03, 0x00, 0xF9, 0x10, 0x03, 0x01, 0xF9,
+0x20, 0x03, 0x27, 0x17, 0x30, 0x03, 0x28, 0x17,
+0x00, 0x0D, 0x00, 0xF9, 0x01, 0x0D, 0x01, 0xF9,
+0x02, 0x0D, 0x02, 0xF9, 0x03, 0x0D, 0x03, 0xF9,
+0x00, 0x03, 0x00, 0xF9, 0x10, 0x03, 0x01, 0xF9,
+0x1F, 0x51, 0xF0, 0xA0, 0x00, 0x19, 0xFF, 0xA0,
+0xA5, 0x19, 0xB5, 0x19, 0xC5, 0x19, 0x00, 0x0E,
+0xF4, 0x12, 0x06, 0x0E, 0x39, 0x13, 0xD0, 0x03,
+0x9F, 0x02, 0x00, 0x03, 0x39, 0x13, 0xD0, 0x20,
+0x0F, 0x98, 0x9E, 0x71, 0x40, 0x1A, 0xBC, 0x12,
+0x10, 0x03, 0xF4, 0x12, 0x41, 0x20, 0x40, 0x08,
+0x00, 0x03, 0xF4, 0x12, 0x01, 0x21, 0x00, 0x0D,
+0xF4, 0x12, 0x00, 0x03, 0x39, 0x13, 0x01, 0x21,
+0x00, 0x0D, 0x39, 0x13, 0xD0, 0x03, 0x9F, 0x02,
+0x00, 0x03, 0x39, 0x13, 0xD0, 0x20, 0x0F, 0x98,
+0x9E, 0x71, 0x40, 0x1A, 0xBC, 0x12, 0x10, 0x03,
+0xF4, 0x12, 0x41, 0x20, 0x40, 0x08, 0x00, 0x03,
+0xF4, 0x12, 0x01, 0x21, 0x00, 0x0D, 0xF4, 0x12,
+0x00, 0x03, 0x39, 0x13, 0x01, 0x21, 0x00, 0x0D,
+0x39, 0x13, 0xD0, 0x03, 0x9F, 0x02, 0x00, 0x03,
+0x39, 0x13, 0xD0, 0x20, 0x0F, 0x98, 0x9E, 0x71,
+0x40, 0x1A, 0xBC, 0x12, 0x10, 0x03, 0xF4, 0x12,
+0x41, 0x20, 0x40, 0x08, 0x00, 0x03, 0x39, 0x13,
+0x03, 0x21, 0x00, 0x0D, 0x39, 0x13, 0x00, 0x03,
+0xF4, 0x12, 0x01, 0x21, 0x00, 0x0D, 0xF4, 0x12,
+0x09, 0x49, 0x01, 0x88, 0x23, 0x72, 0xFF, 0xA0,
+0xB0, 0x1A, 0x3E, 0x13, 0xA0, 0x1A, 0x9A, 0x12,
+0x93, 0x19, 0x0A, 0x01, 0x1A, 0x01, 0x0F, 0x98,
+0x6C, 0x54, 0x2A, 0x01, 0x0F, 0x98, 0x85, 0x54,
+0xB0, 0x09, 0xB1, 0x09, 0x91, 0x39, 0x51, 0x87,
+0xFF, 0xA0, 0x00, 0x03, 0x4A, 0x01, 0x00, 0x0D,
+0x1A, 0x17, 0x00, 0x03, 0x4B, 0x01, 0x00, 0x0D,
+0x1B, 0x17, 0x00, 0x03, 0x4C, 0x01, 0x00, 0x0D,
+0x1C, 0x17, 0xFF, 0xA0, 0x0F, 0x98, 0x6C, 0x72,
+0xB0, 0x1A, 0x3E, 0x13, 0x4B, 0x01, 0x5B, 0x01,
+0x6B, 0x01, 0x7B, 0x01, 0x8B, 0x01, 0x9B, 0x01,
+0x06, 0x18, 0x17, 0x18, 0x26, 0x18, 0x37, 0x18,
+0x0F, 0x98, 0x9A, 0x54, 0x24, 0x18, 0x35, 0x18,
+0x0F, 0x98, 0xDA, 0x54, 0x28, 0x18, 0x39, 0x18,
+0x0F, 0x98, 0xDA, 0x54, 0x00, 0x0D, 0x44, 0x13,
+0x01, 0x0D, 0x45, 0x13, 0x08, 0x18, 0x19, 0x18,
+0x24, 0x18, 0x35, 0x18, 0x0F, 0x98, 0xDA, 0x54,
+0x20, 0x03, 0x45, 0x01, 0x0F, 0x98, 0xBC, 0x54,
+0x20, 0x03, 0x44, 0x13, 0x30, 0x03, 0x45, 0x13,
+0x0F, 0x98, 0xFA, 0x54, 0x20, 0x03, 0x45, 0x01,
+0x02, 0x48, 0x3D, 0x80, 0x02, 0x18, 0x01, 0x0E,
+0x98, 0x12, 0x20, 0x31, 0x02, 0x48, 0x3B, 0x80,
+0x02, 0x18, 0x01, 0x0E, 0x98, 0x12, 0x00, 0x4A,
+0x40, 0x00, 0x2D, 0x80, 0x00, 0x1A, 0x40, 0x00,
+0x00, 0x0D, 0xC8, 0x12, 0x0F, 0x98, 0x0E, 0x73,
+0x0F, 0x98, 0x6C, 0x72, 0xB0, 0x1A, 0x3E, 0x13,
+0x4B, 0x01, 0x5B, 0x01, 0x6B, 0x01, 0x7B, 0x01,
+0x8B, 0x01, 0x9B, 0x00, 0x06, 0x18, 0x17, 0x18,
+0x26, 0x18, 0x37, 0x18, 0x0F, 0x98, 0x9A, 0x54,
+0x24, 0x18, 0x35, 0x18, 0x0F, 0x98, 0xDA, 0x54,
+0x28, 0x18, 0x39, 0x18, 0x0F, 0x98, 0xDA, 0x54,
+0x00, 0x0D, 0x46, 0x13, 0x01, 0x0D, 0x47, 0x13,
+0x08, 0x18, 0x19, 0x18, 0x24, 0x18, 0x35, 0x18,
+0x0F, 0x98, 0xDA, 0x54, 0x20, 0x03, 0x46, 0x01,
+0x0F, 0x98, 0xBC, 0x54, 0x20, 0x03, 0x46, 0x13,
+0x30, 0x03, 0x47, 0x13, 0x0F, 0x98, 0xFA, 0x54,
+0x20, 0x03, 0x45, 0x01, 0x02, 0x48, 0x3D, 0x80,
+0x02, 0x18, 0x01, 0x0E, 0x99, 0x12, 0x20, 0x31,
+0x02, 0x48, 0x3B, 0x80, 0x02, 0x18, 0x01, 0x0E,
+0x99, 0x12, 0x00, 0x4A, 0x40, 0x00, 0x2D, 0x80,
+0x00, 0x1A, 0x40, 0x00, 0x00, 0x0D, 0xC9, 0x12,
+0x91, 0x19, 0xFF, 0xA0, 0x00, 0x03, 0x9B, 0x12,
+0x10, 0x03, 0x9D, 0x12, 0x00, 0x0D, 0x9D, 0x12,
+0x01, 0x0D, 0x9B, 0x12, 0x00, 0x03, 0x9C, 0x12,
+0x10, 0x03, 0xA0, 0x12, 0x00, 0x0D, 0xA0, 0x12,
+0x01, 0x0D, 0x9C, 0x12, 0x00, 0x03, 0x9F, 0x12,
+0x10, 0x03, 0xA1, 0x12, 0x00, 0x0D, 0xA1, 0x12,
+0x01, 0x0D, 0x9F, 0x12, 0xFF, 0xA0, 0x50, 0x1A,
+0x8F, 0x12, 0x60, 0x1A, 0xA3, 0x12, 0x66, 0x21,
+0xB0, 0x19, 0xA0, 0x19, 0x06, 0x01, 0x50, 0x09,
+0xA1, 0x21, 0xA3, 0x49, 0xB1, 0x87, 0xD2, 0x21,
+0x62, 0x21, 0xB1, 0x21, 0xB3, 0x49, 0x51, 0x87,
+0x00, 0x1A, 0xA3, 0x12, 0x00, 0x0D, 0x9F, 0x02,
+0x0F, 0x98, 0x7D, 0x72, 0x0F, 0x98, 0x1C, 0x72,
+0xC0, 0x1A, 0x60, 0x09, 0x90, 0x03, 0x90, 0x02,
+0xC9, 0x20, 0xA0, 0x1A, 0xBC, 0x12, 0xA4, 0x21,
+0x0A, 0x00, 0xC0, 0x08, 0xA9, 0x19, 0xB0, 0x1A,
+0xBC, 0x12, 0xC0, 0x1A, 0x9A, 0x12, 0x0B, 0x01,
+0xC0, 0x09, 0xA1, 0x39, 0xC1, 0x87, 0x0F, 0x88,
+0x8A, 0x72, 0x80, 0x03, 0x09, 0x17, 0x80, 0x49,
+0xF0, 0xA0, 0x80, 0x03, 0xEB, 0x01, 0x80, 0x49,
+0xF0, 0xA0, 0x00, 0x03, 0xEA, 0x17, 0x00, 0x49,
+0xF0, 0xA0, 0x80, 0x03, 0xEC, 0x01, 0x18, 0x18,
+0x18, 0x79, 0xA1, 0x18, 0x80, 0x62, 0xFF, 0x00,
+0x0F, 0x98, 0xA7, 0x54, 0x20, 0x18, 0x31, 0x18,
+0x00, 0x03, 0xE9, 0x17, 0x18, 0x18, 0x0F, 0x98,
+0xA7, 0x54, 0x0F, 0x98, 0x85, 0x54, 0x8A, 0x20,
+0x28, 0x18, 0x0F, 0x98, 0xFA, 0x54, 0x00, 0x0D,
+0xED, 0x01, 0x00, 0x0D, 0xE9, 0x17, 0xFF, 0xA0,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xAA, 0xAA,
+0x55, 0x55, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00,
+0x0E, 0x00, 0x00, 0x00, 0x05, 0x00, 0x12, 0x00,
+0xB4, 0xA5, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x20, 0x01, 0x49, 0x5A, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x50, 0x00, 0x23, 0x00, 0x23, 0x00,
+0x23, 0x00, 0x23, 0x00, 0x00, 0x00, 0x19, 0x00,
+0x05, 0x00, 0x14, 0x00, 0x0F, 0x00, 0x1E, 0x00,
+0x01, 0x00, 0x10, 0x27, 0x02, 0x00, 0x03, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00,
+0x04, 0x02, 0x02, 0x00, 0x28, 0x00, 0x14, 0x00,
+0x20, 0x40, 0x10, 0x00, 0xC2, 0x01, 0x96, 0x00,
+0x02, 0x00, 0x0A, 0x00, 0x4B, 0x00, 0x03, 0x00,
+0x32, 0x00, 0x19, 0x00, 0x05, 0x00, 0x5A, 0x00,
+0x0F, 0x00, 0x1E, 0x00, 0x96, 0x00, 0x96, 0x00,
+0x19, 0x00, 0x0F, 0x00, 0x3C, 0x00, 0x3C, 0x00,
+0x3C, 0x00, 0x01, 0x00, 0x03, 0x00, 0xC8, 0x00,
+0x78, 0x00, 0x14, 0x00, 0x32, 0x00, 0x0A, 0x00,
+0x0A, 0x00, 0x3C, 0x00, 0xC8, 0x00, 0x50, 0x00,
+0x02, 0x00, 0x14, 0x00, 0x0A, 0x00, 0x03, 0x00,
+0x01, 0x00, 0x04, 0x00, 0x04, 0x00, 0x01, 0x00,
+0x0A, 0x00, 0x1E, 0x00, 0x12, 0x00, 0x0B, 0x07,
+0x03, 0x1F, 0x1F, 0x0F, 0x13, 0x17, 0x1B, 0x0D,
+0x11, 0x15, 0x19, 0x1D, 0x09, 0x05, 0x02, 0x06,
+0x0A, 0x0E, 0x12, 0x16, 0x1A, 0x1C, 0x18, 0x14,
+0x00, 0x04, 0x08, 0x0C, 0x10, 0x01, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xAC, 0x0D,
+0x0A, 0x00, 0x0E, 0x00, 0x3F, 0x00, 0x00, 0x00,
+0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
+0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x82, 0x00, 0xD0, 0x07, 0x3C, 0x00,
+0x01, 0x00, 0x04, 0x00, 0x03, 0x00, 0xB4, 0x00,
+0x00, 0x00, 0x1D, 0x00, 0x01, 0x00, 0x02, 0x00,
+0x04, 0x00, 0x0D, 0x00, 0x0F, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x57, 0x02, 0xFF, 0x03, 0x00, 0x00,
+0x00, 0x00, 0x04, 0x00, 0x5F, 0x00, 0x96, 0x00,
+0x3C, 0x00, 0xB4, 0x00, 0x0C, 0x00, 0x0A, 0x00,
+0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x20, 0x00,
+0x3C, 0x00, 0x42, 0x00, 0x42, 0x00, 0x32, 0x00,
+0x05, 0x00, 0x20, 0x03, 0x05, 0x00, 0x03, 0x00,
+0x03, 0x00, 0x03, 0x00, 0x28, 0x00, 0xC8, 0x00,
+0x78, 0x00, 0x46, 0x00, 0x14, 0x00, 0x32, 0x00,
+0xC8, 0x00, 0x00, 0x00, 0x14, 0x00, 0xE8, 0x03,
+0x96, 0x00, 0x05, 0x00, 0x32, 0x00, 0x02, 0x05,
+0x32, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x50, 0x00,
+0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00,
+0x40, 0x00, 0x0F, 0x80, 0x64, 0x00, 0x00, 0x00,
+0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+0x10, 0x11, 0x1E, 0x00, 0xDC, 0x05, 0x5E, 0x01,
+0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x4B, 0x00,
+0x50, 0x00, 0x02, 0x00, 0xDC, 0x05, 0x4D, 0x00,
+0x00, 0x00, 0x96, 0x00, 0x24, 0xFA, 0x64, 0x00,
+0xB4, 0x00, 0x96, 0x00, 0x00, 0x00, 0x50, 0x00,
+0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x02,
+0x30, 0x55, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00,
+0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00,
+0x06, 0x00, 0x07, 0x00, 0xE3, 0xF7, 0x0C, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x14, 0x00,
+0x3F, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
+0xFF, 0x01, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
+0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC1, 0x71,
+0xFF, 0xFF, 0x00, 0x00, 0x0F, 0x00, 0x05, 0x00,
+0x00, 0x00, 0x0F, 0x00, 0x02, 0x00, 0x00, 0x00,
+0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x50, 0x00, 0x15, 0x04, 0x00, 0x00,
+0x01, 0x01, 0x00, 0x00, 0x02, 0x00, 0x32, 0x00,
+0x01, 0x00, 0x11, 0x01, 0xDC, 0x05, 0x01, 0x00,
+0x05, 0x05, 0x64, 0x00, 0x00, 0x00, 0xFF, 0x0F,
+0x02, 0x00, 0x11, 0x11, 0xFF, 0xFF, 0xFF, 0xFF,
+0x10, 0x00, 0x64, 0x00, 0x0C, 0x00, 0x3C, 0x00,
+0x3C, 0x00, 0x1E, 0x00, 0x46, 0x00, 0x0A, 0x00,
+0x03, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x1E, 0x00,
+0x1E, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xE8, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x02, 0x00,
+0x02, 0x00, 0x06, 0x00, 0x03, 0x00, 0x03, 0x00,
+0x03, 0x00, 0xAA, 0x00, 0xBE, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x2C, 0x01,
+0x0E, 0x00, 0x4A, 0x02, 0x0E, 0x00, 0x0E, 0x00,
+0x32, 0x00, 0x4A, 0x02, 0x56, 0x00, 0x0E, 0x00,
+0x79, 0x00, 0x4A, 0x02, 0x9D, 0x00, 0x0E, 0x00,
+0xC0, 0x00, 0x4A, 0x02, 0xE4, 0x00, 0x0E, 0x00,
+0x07, 0x01, 0x4A, 0x02, 0x2B, 0x01, 0x0E, 0x00,
+0x4E, 0x01, 0x4A, 0x02, 0x72, 0x01, 0x0E, 0x00,
+0x95, 0x01, 0x4A, 0x02, 0xB9, 0x01, 0x0E, 0x00,
+0xDC, 0x01, 0x2C, 0x01, 0x00, 0x02, 0x4A, 0x02,
+0x00, 0x02, 0x0E, 0x00, 0x24, 0x02, 0x4A, 0x02,
+0x47, 0x02, 0x0E, 0x00, 0x6B, 0x02, 0x4A, 0x02,
+0x8E, 0x02, 0x0E, 0x00, 0xB2, 0x02, 0x4A, 0x02,
+0xD5, 0x02, 0x0E, 0x00, 0xF9, 0x02, 0x4A, 0x02,
+0x1C, 0x03, 0x0E, 0x00, 0x40, 0x03, 0x4A, 0x02,
+0x63, 0x03, 0x0E, 0x00, 0x87, 0x03, 0x4A, 0x02,
+0xAA, 0x03, 0x0E, 0x00, 0xCE, 0x03, 0x51, 0x00,
+0xCE, 0x03, 0x94, 0x00, 0xCE, 0x03, 0xD8, 0x00,
+0xCE, 0x03, 0x1B, 0x01, 0xCE, 0x03, 0x5F, 0x01,
+0xCE, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x04,
+0x19, 0x00, 0x03, 0x00, 0x05, 0x00, 0x78, 0x00,
+0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0xA2, 0x01, 0xCE, 0x03, 0xE5, 0x01,
+0xCE, 0x03, 0x29, 0x02, 0xCE, 0x03, 0x2F, 0x00,
+0xF2, 0x03, 0x73, 0x00, 0xF2, 0x03, 0xB6, 0x00,
+0xF2, 0x03, 0xF9, 0x00, 0xF2, 0x03, 0x3D, 0x01,
+0xF2, 0x03, 0x80, 0x01, 0xF2, 0x03, 0xC4, 0x01,
+0xF2, 0x03, 0x07, 0x02, 0xF2, 0x03, 0x4A, 0x02,
+0xF2, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
+0x00, 0x00, 0x02, 0x00, 0x3C, 0x00, 0xC4, 0xFF,
+0xC8, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+#endif
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index ff4b8cfd..a57f8726 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -319,6 +319,25 @@ config LEDS_ADP5520
 	  To compile this driver as a module, choose M here: the module will
 	  be called leds-adp5520.
 
+config LEDS_RT8547
+	bool "LED Support for RT8547"
+	default n
+	help
+	  This option enabled support for RT8547 LED drivers
+
+config FLED_RT5033
+	bool "LED Support for RT5033"
+	default n
+	help
+	  This option enabled support for RT5033 LED drivers
+
+config LEDS_RT8547_DBG
+	bool "LED RT8547 Debug"
+	depends on LEDS_RT8547
+	default n
+	help
+	  This option enabled RT8547 LED drivers debug option
+
 config LEDS_DELL_NETBOOKS
 	tristate "External LED on Dell Business Netbooks"
 	depends on LEDS_CLASS
@@ -468,6 +487,12 @@ config LEDS_TRIGGER_DEFAULT_ON
 	  This allows LEDs to be initialised in the ON state.
 	  If unsure, say Y.
 
+config LEDS_TRIGGER_SLEEP
+	tristate "LED Sleep Mode Trigger"
+	depends on LEDS_TRIGGERS && HAS_EARLYSUSPEND
+	help
+	  This turns LEDs on when the screen is off but the cpu still running.
+
 comment "iptables trigger is under Netfilter config (LED target)"
 	depends on LEDS_TRIGGERS
 
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 890481cb..a5cf75bf 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -45,6 +45,8 @@ obj-$(CONFIG_LEDS_NETXBIG)		+= leds-netxbig.o
 obj-$(CONFIG_LEDS_ASIC3)		+= leds-asic3.o
 obj-$(CONFIG_LEDS_RENESAS_TPU)		+= leds-renesas-tpu.o
 obj-$(CONFIG_LEDS_MAX8997)		+= leds-max8997.o
+obj-$(CONFIG_LEDS_RT8547)		+= leds-rt8547.o
+obj-$(CONFIG_FLED_RT5033)		+= rt5033_fled.o rtfled.o flashlight.o
 
 # LED SPI Drivers
 obj-$(CONFIG_LEDS_DAC124S085)		+= leds-dac124s085.o
@@ -56,3 +58,4 @@ obj-$(CONFIG_LEDS_TRIGGER_HEARTBEAT)	+= ledtrig-heartbeat.o
 obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT)	+= ledtrig-backlight.o
 obj-$(CONFIG_LEDS_TRIGGER_GPIO)		+= ledtrig-gpio.o
 obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+= ledtrig-default-on.o
+obj-$(CONFIG_LEDS_TRIGGER_SLEEP)	+= ledtrig-sleep.o
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index ce1e7ba9..a57f8726 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -1,1224 +1,499 @@
-#
-# Generic video config states
-#
-
-config VIDEO_V4L2
-	tristate
-	depends on VIDEO_DEV && VIDEO_V4L2_COMMON
-	default VIDEO_DEV && VIDEO_V4L2_COMMON
-
-config VIDEOBUF_GEN
-	tristate
-
-config VIDEOBUF_DMA_SG
-	depends on HAS_DMA
-	select VIDEOBUF_GEN
-	tristate
-
-config VIDEOBUF_VMALLOC
-	select VIDEOBUF_GEN
-	tristate
-
-config VIDEOBUF_DMA_CONTIG
-	depends on HAS_DMA
-	select VIDEOBUF_GEN
-	tristate
-
-config VIDEOBUF_DVB
-	tristate
-	select VIDEOBUF_GEN
-
-config VIDEO_BTCX
-	depends on PCI
-	tristate
-
-config VIDEO_TVEEPROM
-	tristate
-	depends on I2C
-
-config VIDEO_TUNER
-	tristate
-	depends on MEDIA_TUNER
-
-config V4L2_MEM2MEM_DEV
-	tristate
-	depends on VIDEOBUF2_CORE
-
-config VIDEOBUF2_CORE
-	tristate
-
-config VIDEOBUF2_MEMOPS
-	tristate
-
-config VIDEOBUF2_DMA_CONTIG
-	select VIDEOBUF2_CORE
-	select VIDEOBUF2_MEMOPS
-	tristate
-
-config VIDEOBUF2_VMALLOC
-	select VIDEOBUF2_CORE
-	select VIDEOBUF2_MEMOPS
-	tristate
-
-
-config VIDEOBUF2_DMA_SG
-	#depends on HAS_DMA
-	select VIDEOBUF2_CORE
-	select VIDEOBUF2_MEMOPS
-	tristate
-#
-# Multimedia Video device configuration
-#
-
-menuconfig VIDEO_CAPTURE_DRIVERS
-	bool "Video capture adapters"
-	depends on VIDEO_V4L2
-	default y
-	---help---
-	  Say Y here to enable selecting the video adapters for
-	  webcams, analog TV, and hybrid analog/digital TV.
-	  Some of those devices also supports FM radio.
-
-if VIDEO_CAPTURE_DRIVERS && VIDEO_V4L2
-
-config VIDEO_ADV_DEBUG
-	bool "Enable advanced debug functionality"
-	default n
-	---help---
-	  Say Y here to enable advanced debugging functionality on some
-	  V4L devices.
-	  In doubt, say N.
-
-config VIDEO_FIXED_MINOR_RANGES
-	bool "Enable old-style fixed minor ranges for video devices"
-	default n
-	---help---
-	  Say Y here to enable the old-style fixed-range minor assignments.
-	  Only useful if you rely on the old behavior and use mknod instead of udev.
-
-	  When in doubt, say N.
-
-config VIDEO_HELPER_CHIPS_AUTO
-	bool "Autoselect pertinent encoders/decoders and other helper chips"
-	default y if !EXPERT
-	---help---
-	  Most video cards may require additional modules to encode or
-	  decode audio/video standards. This option will autoselect
-	  all pertinent modules to each selected video module.
-
-	  Unselect this only if you know exactly what you are doing, since
-	  it may break support on some boards.
-
-	  In doubt, say Y.
-
-config VIDEO_IR_I2C
-	tristate "I2C module for IR" if !VIDEO_HELPER_CHIPS_AUTO
-	depends on I2C && RC_CORE
-	default y
-	---help---
-	  Most boards have an IR chip directly connected via GPIO. However,
-	  some video boards have the IR connected via I2C bus.
-
-	  If your board doesn't have an I2C IR chip, you may disable this
-	  option.
-
-	  In doubt, say Y.
-
-#
-# Encoder / Decoder module configuration
-#
-
-menu "Encoders, decoders, sensors and other helper chips"
-	visible if !VIDEO_HELPER_CHIPS_AUTO
-
-comment "Audio decoders, processors and mixers"
+config LEDS_GPIO_REGISTER
+	bool
+	help
+	  This option provides the function gpio_led_register_device.
+	  As this function is used by arch code it must not be compiled as a
+	  module.
 
-config VIDEO_TVAUDIO
-	tristate "Simple audio decoder chips"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for several audio decoder chips found on some bt8xx boards:
-	  Philips: tda9840, tda9873h, tda9874h/a, tda9850, tda985x, tea6300,
-		   tea6320, tea6420, tda8425, ta8874z.
-	  Microchip: pic16c54 based design on ProVideo PV951 board.
+menuconfig NEW_LEDS
+	bool "LED Support"
+	help
+	  Say Y to enable Linux LED support.  This allows control of supported
+	  LEDs from both userspace and optionally, by kernel events (triggers).
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called tvaudio.
+	  This is not related to standard keyboard LEDs which are controlled
+	  via the input system.
 
-config VIDEO_TDA7432
-	tristate "Philips TDA7432 audio processor"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for tda7432 audio decoder chip found on some bt8xx boards.
+if NEW_LEDS
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called tda7432.
-
-config VIDEO_TDA9840
-	tristate "Philips TDA9840 audio processor"
-	depends on I2C
-	---help---
-	  Support for tda9840 audio decoder chip found on some Zoran boards.
+config LEDS_CLASS
+	tristate "LED Class Support"
+	help
+	  This option enables the led sysfs class in /sys/class/leds.  You'll
+	  need this to do anything useful with LEDs.  If unsure, say N.
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called tda9840.
+comment "LED drivers"
 
-config VIDEO_TEA6415C
-	tristate "Philips TEA6415C audio processor"
-	depends on I2C
-	---help---
-	  Support for tea6415c audio decoder chip found on some bt8xx boards.
+config LEDS_88PM860X
+	tristate "LED Support for Marvell 88PM860x PMIC"
+	depends on LEDS_CLASS
+	depends on MFD_88PM860X
+	help
+	  This option enables support for on-chip LED drivers found on Marvell
+	  Semiconductor 88PM8606 PMIC.
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called tea6415c.
+config LEDS_ATMEL_PWM
+	tristate "LED Support using Atmel PWM outputs"
+	depends on LEDS_CLASS
+	depends on ATMEL_PWM
+	help
+	  This option enables support for LEDs driven using outputs
+	  of the dedicated PWM controller found on newer Atmel SOCs.
 
-config VIDEO_TEA6420
-	tristate "Philips TEA6420 audio processor"
+config LEDS_LM3530
+	tristate "LCD Backlight driver for LM3530"
+	depends on LEDS_CLASS
 	depends on I2C
-	---help---
-	  Support for tea6420 audio decoder chip found on some bt8xx boards.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called tea6420.
-
-config VIDEO_MSP3400
-	tristate "Micronas MSP34xx audio decoders"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Micronas MSP34xx series of audio decoders.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called msp3400.
-
-config VIDEO_CS5345
-	tristate "Cirrus Logic CS5345 audio ADC"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Cirrus Logic CS5345 24-bit, 192 kHz
-	  stereo A/D converter.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called cs5345.
-
-config VIDEO_CS53L32A
-	tristate "Cirrus Logic CS53L32A audio ADC"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Cirrus Logic CS53L32A low voltage
-	  stereo A/D converter.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called cs53l32a.
-
-config VIDEO_TLV320AIC23B
-	tristate "Texas Instruments TLV320AIC23B audio codec"
-	depends on VIDEO_V4L2 && I2C && EXPERIMENTAL
-	---help---
-	  Support for the Texas Instruments TLV320AIC23B audio codec.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called tlv320aic23b.
-
-config VIDEO_WM8775
-	tristate "Wolfson Microelectronics WM8775 audio ADC with input mixer"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Wolfson Microelectronics WM8775 high
-	  performance stereo A/D Converter with a 4 channel input mixer.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called wm8775.
-
-config VIDEO_WM8739
-	tristate "Wolfson Microelectronics WM8739 stereo audio ADC"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Wolfson Microelectronics WM8739
-	  stereo A/D Converter.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called wm8739.
-
-config VIDEO_VP27SMPX
-	tristate "Panasonic VP27s internal MPX"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the internal MPX of the Panasonic VP27s tuner.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called vp27smpx.
-
-comment "RDS decoders"
-
-config VIDEO_SAA6588
-	tristate "SAA6588 Radio Chip RDS decoder support"
-	depends on VIDEO_V4L2 && I2C
-
 	help
-	  Support for this Radio Data System (RDS) decoder. This allows
-	  seeing radio station identification transmitted using this
-	  standard.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called saa6588.
-
-comment "Video decoders"
-
-config VIDEO_ADV7180
-	tristate "Analog Devices ADV7180 decoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Analog Devices ADV7180 video decoder.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called adv7180.
-
-config VIDEO_ADV7183
-	tristate "Analog Devices ADV7183 decoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  V4l2 subdevice driver for the Analog Devices
-	  ADV7183 video decoder.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called adv7183.
-
-config VIDEO_BT819
-	tristate "BT819A VideoStream decoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for BT819A video decoder.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called bt819.
-
-config VIDEO_BT856
-	tristate "BT856 VideoStream decoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for BT856 video decoder.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called bt856.
-
-config VIDEO_BT866
-	tristate "BT866 VideoStream decoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for BT866 video decoder.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called bt866.
-
-config VIDEO_KS0127
-	tristate "KS0127 video decoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for KS0127 video decoder.
-
-	  This chip is used on AverMedia AVS6EYES Zoran-based MJPEG
-	  cards.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called ks0127.
-
-config VIDEO_SAA7110
-	tristate "Philips SAA7110 video decoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Philips SAA7110 video decoders.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called saa7110.
-
-config VIDEO_SAA711X
-	tristate "Philips SAA7111/3/4/5 video decoders"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Philips SAA7111/3/4/5 video decoders.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called saa7115.
-
-config VIDEO_SAA7191
-	tristate "Philips SAA7191 video decoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Philips SAA7191 video decoder.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called saa7191.
-
-config VIDEO_TVP514X
-	tristate "Texas Instruments TVP514x video decoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  This is a Video4Linux2 sensor-level driver for the TI TVP5146/47
-	  decoder. It is currently working with the TI OMAP3 camera
-	  controller.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called tvp514x.
-
-config VIDEO_TVP5150
-	tristate "Texas Instruments TVP5150 video decoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Texas Instruments TVP5150 video decoder.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called tvp5150.
-
-config VIDEO_TVP7002
-	tristate "Texas Instruments TVP7002 video decoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Texas Instruments TVP7002 video decoder.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called tvp7002.
-
-config VIDEO_VPX3220
-	tristate "vpx3220a, vpx3216b & vpx3214c video decoders"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for VPX322x video decoders.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called vpx3220.
-
-comment "Video and audio decoders"
-
-config VIDEO_SAA717X
-	tristate "Philips SAA7171/3/4 audio/video decoders"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Philips SAA7171/3/4 audio/video decoders.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called saa717x.
-
-source "drivers/media/video/cx25840/Kconfig"
-
-comment "MPEG video encoders"
-
-config VIDEO_CX2341X
-	tristate "Conexant CX2341x MPEG encoders"
-	depends on VIDEO_V4L2 && VIDEO_V4L2_COMMON
-	---help---
-	  Support for the Conexant CX23416 MPEG encoders
-	  and CX23415 MPEG encoder/decoders.
+	  This option enables support for the LCD backlight using
+	  LM3530 ambient light sensor chip. This ALS chip can be
+	  controlled manually or using PWM input or using ambient
+	  light automatically.
+
+config LEDS_LOCOMO
+	tristate "LED Support for Locomo device"
+	depends on LEDS_CLASS
+	depends on SHARP_LOCOMO
+	help
+	  This option enables support for the LEDs on Sharp Locomo.
+	  Zaurus models SL-5500 and SL-5600.
 
-	  This module currently supports the encoding functions only.
+config LEDS_MIKROTIK_RB532
+	tristate "LED Support for Mikrotik Routerboard 532"
+	depends on LEDS_CLASS
+	depends on MIKROTIK_RB532
+	help
+	  This option enables support for the so called "User LED" of
+	  Mikrotik's Routerboard 532.
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called cx2341x.
+config LEDS_S3C24XX
+	tristate "LED Support for Samsung S3C24XX GPIO LEDs"
+	depends on LEDS_CLASS
+	depends on ARCH_S3C24XX
+	help
+	  This option enables support for LEDs connected to GPIO lines
+	  on Samsung S3C24XX series CPUs, such as the S3C2410 and S3C2440.
 
-comment "Video encoders"
+config LEDS_NET48XX
+	tristate "LED Support for Soekris net48xx series Error LED"
+	depends on LEDS_CLASS
+	depends on SCx200_GPIO
+	help
+	  This option enables support for the Soekris net4801 and net4826 error
+	  LED.
 
-config VIDEO_SAA7127
-	tristate "Philips SAA7127/9 digital video encoders"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Philips SAA7127/9 digital video encoders.
+config LEDS_FSG
+	tristate "LED Support for the Freecom FSG-3"
+	depends on LEDS_CLASS
+	depends on MACH_FSG
+	help
+	  This option enables support for the LEDs on the Freecom FSG-3.
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called saa7127.
+config LEDS_WRAP
+	tristate "LED Support for the WRAP series LEDs"
+	depends on LEDS_CLASS
+	depends on SCx200_GPIO
+	help
+	  This option enables support for the PCEngines WRAP programmable LEDs.
 
-config VIDEO_SAA7185
-	tristate "Philips SAA7185 video encoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Philips SAA7185 video encoder.
+config LEDS_COBALT_QUBE
+	tristate "LED Support for the Cobalt Qube series front LED"
+	depends on LEDS_CLASS
+	depends on MIPS_COBALT
+	help
+	  This option enables support for the front LED on Cobalt Qube series
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called saa7185.
+config LEDS_COBALT_RAQ
+	bool "LED Support for the Cobalt Raq series"
+	depends on LEDS_CLASS=y && MIPS_COBALT
+	select LEDS_TRIGGERS
+	help
+	  This option enables support for the Cobalt Raq series LEDs.
 
-config VIDEO_ADV7170
-	tristate "Analog Devices ADV7170 video encoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Analog Devices ADV7170 video encoder driver
+config LEDS_SUNFIRE
+	tristate "LED support for SunFire servers."
+	depends on LEDS_CLASS
+	depends on SPARC64
+	select LEDS_TRIGGERS
+	help
+	  This option enables support for the Left, Middle, and Right
+	  LEDs on the I/O and CPU boards of SunFire UltraSPARC servers.
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called adv7170.
+config LEDS_HP6XX
+	tristate "LED Support for the HP Jornada 6xx"
+	depends on LEDS_CLASS
+	depends on SH_HP6XX
+	help
+	  This option enables LED support for the handheld
+	  HP Jornada 620/660/680/690.
 
-config VIDEO_ADV7175
-	tristate "Analog Devices ADV7175 video encoder"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the Analog Devices ADV7175 video encoder driver
+config LEDS_PCA9532
+	tristate "LED driver for PCA9532 dimmer"
+	depends on LEDS_CLASS
+	depends on I2C && INPUT && EXPERIMENTAL
+	help
+	  This option enables support for NXP pca9532
+	  LED controller. It is generally only useful
+	  as a platform driver
+
+config LEDS_PCA9532_GPIO
+	bool "Enable GPIO support for PCA9532"
+	depends on LEDS_PCA9532
+	depends on GPIOLIB
+	help
+	  Allow unused pins on PCA9532 to be used as gpio.
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called adv7175.
+	  To use a pin as gpio pca9532_type in pca9532_platform data needs to
+	  set to PCA9532_TYPE_GPIO.
 
-config VIDEO_ADV7343
-	tristate "ADV7343 video encoder"
+config LEDS_GPIO
+	tristate "LED Support for GPIO connected LEDs"
+	depends on LEDS_CLASS
+	depends on GENERIC_GPIO
+	help
+	  This option enables support for the LEDs connected to GPIO
+	  outputs. To be useful the particular board must have LEDs
+	  and they must be connected to the GPIO lines.  The LEDs must be
+	  defined as platform devices and/or OpenFirmware platform devices.
+	  The code to use these bindings can be selected below.
+
+config LEDS_LP3944
+	tristate "LED Support for N.S. LP3944 (Fun Light) I2C chip"
+	depends on LEDS_CLASS
 	depends on I2C
 	help
-	  Support for Analog Devices I2C bus based ADV7343 encoder.
+	  This option enables support for LEDs connected to the National
+	  Semiconductor LP3944 Lighting Management Unit (LMU) also known as
+	  Fun Light Chip.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called adv7343.
+	  module will be called leds-lp3944.
 
-config VIDEO_AK881X
-	tristate "AK8813/AK8814 video encoders"
-	depends on I2C
+config LEDS_LP5521
+	tristate "LED Support for N.S. LP5521 LED driver chip"
+	depends on LEDS_CLASS && I2C
 	help
-	  Video output driver for AKM AK8813 and AK8814 TV encoders
-
-comment "Camera sensor devices"
+	  If you say yes here you get support for the National Semiconductor
+	  LP5521 LED driver. It is 3 channel chip with programmable engines.
+	  Driver provides direct control via LED class and interface for
+	  programming the engines.
+
+config LEDS_LP5523
+	tristate "LED Support for N.S. LP5523 LED driver chip"
+	depends on LEDS_CLASS && I2C
+	help
+	  If you say yes here you get support for the National Semiconductor
+	  LP5523 LED driver. It is 9 channel chip with programmable engines.
+	  Driver provides direct control via LED class and interface for
+	  programming the engines.
+
+config LEDS_CLEVO_MAIL
+	tristate "Mail LED on Clevo notebook"
+	depends on LEDS_CLASS
+	depends on X86 && SERIO_I8042 && DMI
+	help
+	  This driver makes the mail LED accessible from userspace
+	  programs through the leds subsystem. This LED have three
+	  known mode: off, blink at 0.5Hz and blink at 1Hz.
 
-config VIDEO_APTINA_PLL
-	tristate
+	  The driver supports two kinds of interface: using ledtrig-timer
+	  or through /sys/class/leds/clevo::mail/brightness. As this LED
+	  cannot change it's brightness it blinks instead. The brightness
+	  value 0 means off, 1..127 means blink at 0.5Hz and 128..255 means
+	  blink at 1Hz.
 
-config VIDEO_OV7670
-	tristate "OmniVision OV7670 sensor support"
-	depends on I2C && VIDEO_V4L2
-	---help---
-	  This is a Video4Linux2 sensor-level driver for the OmniVision
-	  OV7670 VGA camera.  It currently only works with the M88ALP01
-	  controller.
+	  This module can drive the mail LED for the following notebooks:
 
-config VIDEO_VS6624
-	tristate "ST VS6624 sensor support"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  This is a Video4Linux2 sensor-level driver for the ST VS6624
-	  camera.
+	  	Clevo D400P
+	  	Clevo D410J
+	  	Clevo D410V
+	  	Clevo D400V/D470V (not tested, but might work)
+	  	Clevo M540N
+	  	Clevo M5x0N (not tested, but might work)
+	  	Positivo Mobile (Clevo M5x0V)
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called vs6624.
-
-config VIDEO_MT9M032
-	tristate "MT9M032 camera sensor support"
-	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
-	select VIDEO_APTINA_PLL
-	---help---
-	  This driver supports MT9M032 camera sensors from Aptina, monochrome
-	  models only.
-
-config VIDEO_MT9P031
-	tristate "Aptina MT9P031 support"
-	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
-	select VIDEO_APTINA_PLL
-	---help---
-	  This is a Video4Linux2 sensor-level driver for the Aptina
-	  (Micron) mt9p031 5 Mpixel camera.
-
-config VIDEO_MT9T001
-	tristate "Aptina MT9T001 support"
-	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
-	---help---
-	  This is a Video4Linux2 sensor-level driver for the Aptina
-	  (Micron) mt0t001 3 Mpixel camera.
-
-config VIDEO_MT9V011
-	tristate "Micron mt9v011 sensor support"
-	depends on I2C && VIDEO_V4L2
-	---help---
-	  This is a Video4Linux2 sensor-level driver for the Micron
-	  mt0v011 1.3 Mpixel camera.  It currently only works with the
-	  em28xx driver.
-
-config VIDEO_MT9V032
-	tristate "Micron MT9V032 sensor support"
-	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
-	---help---
-	  This is a Video4Linux2 sensor-level driver for the Micron
-	  MT9V032 752x480 CMOS sensor.
-
-config VIDEO_TCM825X
-	tristate "TCM825x camera sensor support"
-	depends on I2C && VIDEO_V4L2
-	---help---
-	  This is a driver for the Toshiba TCM825x VGA camera sensor.
-	  It is used for example in Nokia N800.
-
-config VIDEO_SR030PC30
-	tristate "Siliconfile SR030PC30 sensor support"
-	depends on I2C && VIDEO_V4L2
-	---help---
-	  This driver supports SR030PC30 VGA camera from Siliconfile
-
-config VIDEO_NOON010PC30
-	tristate "Siliconfile NOON010PC30 sensor support"
-	depends on I2C && VIDEO_V4L2 && EXPERIMENTAL && VIDEO_V4L2_SUBDEV_API
-	---help---
-	  This driver supports NOON010PC30 CIF camera from Siliconfile
-
-source "drivers/media/video/m5mols/Kconfig"
-
-config VIDEO_S5K6AA
-	tristate "Samsung S5K6AAFX sensor support"
-	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
-	---help---
-	  This is a V4L2 sensor-level driver for Samsung S5K6AA(FX) 1.3M
-	  camera sensor with an embedded SoC image signal processor.
-
-comment "Flash devices"
-
-config VIDEO_ADP1653
-	tristate "ADP1653 flash support"
-	depends on I2C && VIDEO_V4L2 && MEDIA_CONTROLLER
-	---help---
-	  This is a driver for the ADP1653 flash controller. It is used for
-	  example in Nokia N900.
-
-config VIDEO_AS3645A
-	tristate "AS3645A flash driver support"
-	depends on I2C && VIDEO_V4L2 && MEDIA_CONTROLLER
-	---help---
-	  This is a driver for the AS3645A and LM3555 flash controllers. It has
-	  build in control for flash, torch and indicator LEDs.
-
-comment "Video improvement chips"
-
-config VIDEO_UPD64031A
-	tristate "NEC Electronics uPD64031A Ghost Reduction"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the NEC Electronics uPD64031A Ghost Reduction
-	  video chip. It is most often found in NTSC TV cards made for
-	  Japan and is used to reduce the 'ghosting' effect that can
-	  be present in analog TV broadcasts.
+	  If your model is not listed here you can try the "nodetect"
+	  module parameter.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called upd64031a.
+	  module will be called leds-clevo-mail.
 
-config VIDEO_UPD64083
-	tristate "NEC Electronics uPD64083 3-Dimensional Y/C separation"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	  Support for the NEC Electronics uPD64083 3-Dimensional Y/C
-	  separation video chip. It is used to improve the quality of
-	  the colors of a composite signal.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called upd64083.
-
-comment "Miscelaneous helper chips"
-
-config VIDEO_THS7303
-	tristate "THS7303 Video Amplifier"
+config LEDS_PCA955X
+	tristate "LED Support for PCA955x I2C chips"
+	depends on LEDS_CLASS
 	depends on I2C
 	help
-	  Support for TI THS7303 video amplifier
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called ths7303.
-
-config VIDEO_M52790
-	tristate "Mitsubishi M52790 A/V switch"
-	depends on VIDEO_V4L2 && I2C
-	---help---
-	 Support for the Mitsubishi M52790 A/V switch.
-
-	 To compile this driver as a module, choose M here: the
-	 module will be called m52790.
-
-endmenu # encoder / decoder chips
-
-config VIDEO_VIVI
-	tristate "Virtual Video Driver"
-	depends on VIDEO_DEV && VIDEO_V4L2 && !SPARC32 && !SPARC64
-	depends on FRAMEBUFFER_CONSOLE || STI_CONSOLE
-	select FONT_8x16
-	select VIDEOBUF2_VMALLOC
-	default n
-	---help---
-	  Enables a virtual video driver. This device shows a color bar
-	  and a timestamp, as a real device would generate by using V4L2
-	  api.
-	  Say Y here if you want to test video apps or debug V4L devices.
-	  In doubt, say N.
-
-#
-# USB Multimedia device configuration
-#
-
-menuconfig V4L_USB_DRIVERS
-	bool "V4L USB devices"
-	depends on USB
-	default y
-
-if V4L_USB_DRIVERS
-
-source "drivers/media/video/uvc/Kconfig"
-
-source "drivers/media/video/gspca/Kconfig"
-
-source "drivers/media/video/pvrusb2/Kconfig"
-
-source "drivers/media/video/hdpvr/Kconfig"
+	  This option enables support for LEDs connected to PCA955x
+	  LED driver chips accessed via the I2C bus.  Supported
+	  devices include PCA9550, PCA9551, PCA9552, and PCA9553.
 
-source "drivers/media/video/em28xx/Kconfig"
-
-source "drivers/media/video/tlg2300/Kconfig"
-
-source "drivers/media/video/cx231xx/Kconfig"
-
-source "drivers/media/video/tm6000/Kconfig"
-
-source "drivers/media/video/usbvision/Kconfig"
-
-source "drivers/media/video/et61x251/Kconfig"
-
-source "drivers/media/video/sn9c102/Kconfig"
-
-source "drivers/media/video/pwc/Kconfig"
-
-source "drivers/media/video/cpia2/Kconfig"
-
-config USB_ZR364XX
-	tristate "USB ZR364XX Camera support"
-	depends on VIDEO_V4L2
-	select VIDEOBUF_GEN
-	select VIDEOBUF_VMALLOC
-	---help---
-	  Say Y here if you want to connect this type of camera to your
-	  computer's USB port.
-	  See <file:Documentation/video4linux/zr364xx.txt> for more info
-	  and list of supported cameras.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called zr364xx.
-
-config USB_STKWEBCAM
-	tristate "USB Syntek DC1125 Camera support"
-	depends on VIDEO_V4L2 && EXPERIMENTAL
-	---help---
-	  Say Y here if you want to use this type of camera.
-	  Supported devices are typically found in some Asus laptops,
-	  with USB id 174f:a311 and 05e1:0501. Other Syntek cameras
-	  may be supported by the stk11xx driver, from which this is
-	  derived, see <http://sourceforge.net/projects/syntekdriver/>
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called stkwebcam.
-
-config USB_S2255
-	tristate "USB Sensoray 2255 video capture device"
-	depends on VIDEO_V4L2
-	select VIDEOBUF_VMALLOC
-	default n
+config LEDS_PCA9633
+	tristate "LED support for PCA9633 I2C chip"
+	depends on LEDS_CLASS
+	depends on I2C
 	help
-	  Say Y here if you want support for the Sensoray 2255 USB device.
-	  This driver can be compiled as a module, called s2255drv.
-
-endif # V4L_USB_DRIVERS
-
-#
-# PCI drivers configuration
-#
-
-menuconfig V4L_PCI_DRIVERS
-	bool "V4L PCI(e) devices"
-	depends on PCI
-	default y
-	---help---
-	  Say Y here to enable support for these PCI(e) drivers.
-
-if V4L_PCI_DRIVERS
-
-source "drivers/media/video/au0828/Kconfig"
-
-source "drivers/media/video/bt8xx/Kconfig"
-
-source "drivers/media/video/cx18/Kconfig"
-
-source "drivers/media/video/cx23885/Kconfig"
-
-source "drivers/media/video/cx25821/Kconfig"
-
-source "drivers/media/video/cx88/Kconfig"
-
-config VIDEO_HEXIUM_GEMINI
-	tristate "Hexium Gemini frame grabber"
-	depends on PCI && VIDEO_V4L2 && I2C
-	select VIDEO_SAA7146_VV
-	---help---
-	  This is a video4linux driver for the Hexium Gemini frame
-	  grabber card by Hexium. Please note that the Gemini Dual
-	  card is *not* fully supported.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called hexium_gemini.
-
-config VIDEO_HEXIUM_ORION
-	tristate "Hexium HV-PCI6 and Orion frame grabber"
-	depends on PCI && VIDEO_V4L2 && I2C
-	select VIDEO_SAA7146_VV
-	---help---
-	  This is a video4linux driver for the Hexium HV-PCI6 and
-	  Orion frame grabber cards by Hexium.
+	  This option enables support for LEDs connected to the PCA9633
+	  LED driver chip accessed via the I2C bus.
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called hexium_orion.
-
-source "drivers/media/video/ivtv/Kconfig"
-
-config VIDEO_MEYE
-	tristate "Sony Vaio Picturebook Motion Eye Video For Linux"
-	depends on PCI && SONY_LAPTOP && VIDEO_V4L2
-	---help---
-	  This is the video4linux driver for the Motion Eye camera found
-	  in the Vaio Picturebook laptops. Please read the material in
-	  <file:Documentation/video4linux/meye.txt> for more information.
-
-	  If you say Y or M here, you need to say Y or M to "Sony Laptop
-	  Extras" in the misc device section.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called meye.
-
-config VIDEO_MXB
-	tristate "Siemens-Nixdorf 'Multimedia eXtension Board'"
-	depends on PCI && VIDEO_V4L2 && I2C
-	select VIDEO_SAA7146_VV
-	select VIDEO_TUNER
-	select VIDEO_SAA711X if VIDEO_HELPER_CHIPS_AUTO
-	select VIDEO_TDA9840 if VIDEO_HELPER_CHIPS_AUTO
-	select VIDEO_TEA6415C if VIDEO_HELPER_CHIPS_AUTO
-	select VIDEO_TEA6420 if VIDEO_HELPER_CHIPS_AUTO
-	---help---
-	  This is a video4linux driver for the 'Multimedia eXtension Board'
-	  TV card by Siemens-Nixdorf.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called mxb.
-
-source "drivers/media/video/saa7134/Kconfig"
-
-source "drivers/media/video/saa7164/Kconfig"
-
-source "drivers/media/video/zoran/Kconfig"
+config LEDS_WM831X_STATUS
+	tristate "LED support for status LEDs on WM831x PMICs"
+	depends on LEDS_CLASS
+	depends on MFD_WM831X
+	help
+	  This option enables support for the status LEDs of the WM831x
+          series of PMICs.
 
-endif # V4L_PCI_DRIVERS
+config LEDS_WM8350
+	tristate "LED Support for WM8350 AudioPlus PMIC"
+	depends on LEDS_CLASS
+	depends on MFD_WM8350
+	help
+	  This option enables support for LEDs driven by the Wolfson
+	  Microelectronics WM8350 AudioPlus PMIC.
 
-#
-# ISA & parallel port drivers configuration
-#
+config LEDS_DA903X
+	tristate "LED Support for DA9030/DA9034 PMIC"
+	depends on LEDS_CLASS
+	depends on PMIC_DA903X
+	help
+	  This option enables support for on-chip LED drivers found
+	  on Dialog Semiconductor DA9030/DA9034 PMICs.
 
-menuconfig V4L_ISA_PARPORT_DRIVERS
-	bool "V4L ISA and parallel port devices"
-	depends on ISA || PARPORT
-	default n
-	---help---
-	  Say Y here to enable support for these ISA and parallel port drivers.
+config LEDS_DAC124S085
+	tristate "LED Support for DAC124S085 SPI DAC"
+	depends on LEDS_CLASS
+	depends on SPI
+	help
+	  This option enables support for DAC124S085 SPI DAC from NatSemi,
+	  which can be used to control up to four LEDs.
 
-if V4L_ISA_PARPORT_DRIVERS
+config LEDS_PWM
+	tristate "PWM driven LED Support"
+	depends on LEDS_CLASS
+	depends on HAVE_PWM
+	help
+	  This option enables support for pwm driven LEDs
 
-config VIDEO_BWQCAM
-	tristate "Quickcam BW Video For Linux"
-	depends on PARPORT && VIDEO_V4L2
+config LEDS_REGULATOR
+	tristate "REGULATOR driven LED support"
+	depends on LEDS_CLASS
+	depends on REGULATOR
 	help
-	  Say Y have if you the black and white version of the QuickCam
-	  camera. See the next option for the color version.
+	  This option enables support for regulator driven LEDs.
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called bw-qcam.
+config LEDS_BD2802
+	tristate "LED driver for BD2802 RGB LED"
+	depends on LEDS_CLASS
+	depends on I2C
+	help
+	  This option enables support for BD2802GU RGB LED driver chips
+	  accessed via the I2C bus.
 
-config VIDEO_CQCAM
-	tristate "QuickCam Colour Video For Linux"
-	depends on PARPORT && VIDEO_V4L2
+config LEDS_INTEL_SS4200
+	tristate "LED driver for Intel NAS SS4200 series"
+	depends on LEDS_CLASS
+	depends on PCI && DMI
 	help
-	  This is the video4linux driver for the colour version of the
-	  Connectix QuickCam.  If you have one of these cameras, say Y here,
-	  otherwise say N.  This driver does not work with the original
-	  monochrome QuickCam, QuickCam VC or QuickClip.  It is also available
-	  as a module (c-qcam).
-	  Read <file:Documentation/video4linux/CQcam.txt> for more information.
-
-config VIDEO_PMS
-	tristate "Mediavision Pro Movie Studio Video For Linux"
-	depends on ISA && VIDEO_V4L2
+	  This option enables support for the Intel SS4200 series of
+	  Network Attached Storage servers.  You may control the hard
+	  drive or power LEDs on the front panel.  Using this driver
+	  can stop the front LED from blinking after startup.
+
+config LEDS_LT3593
+	tristate "LED driver for LT3593 controllers"
+	depends on LEDS_CLASS
+	depends on GENERIC_GPIO
 	help
-	  Say Y if you have the ISA Mediavision Pro Movie Studio
-	  capture card.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called pms.
-
-config VIDEO_W9966
-	tristate "W9966CF Webcam (FlyCam Supra and others) Video For Linux"
-	depends on PARPORT_1284 && PARPORT && VIDEO_V4L2
+	  This option enables support for LEDs driven by a Linear Technology
+	  LT3593 controller. This controller uses a special one-wire pulse
+	  coding protocol to set the brightness.
+
+config LEDS_ADP5520
+	tristate "LED Support for ADP5520/ADP5501 PMIC"
+	depends on LEDS_CLASS
+	depends on PMIC_ADP5520
 	help
-	  Video4linux driver for Winbond's w9966 based Webcams.
-	  Currently tested with the LifeView FlyCam Supra.
-	  If you have one of these cameras, say Y here
-	  otherwise say N.
-	  This driver is also available as a module (w9966).
-
-	  Check out <file:Documentation/video4linux/w9966.txt> for more
-	  information.
+	  This option enables support for on-chip LED drivers found
+	  on Analog Devices ADP5520/ADP5501 PMICs.
 
-endif # V4L_ISA_PARPORT_DRIVERS
+	  To compile this driver as a module, choose M here: the module will
+	  be called leds-adp5520.
 
-menuconfig V4L_PLATFORM_DRIVERS
-	bool "V4L platform devices"
+config LEDS_RT8547
+	bool "LED Support for RT8547"
 	default n
-	---help---
-	  Say Y here to enable support for platform-specific V4L drivers.
-
-if V4L_PLATFORM_DRIVERS
-
-source "drivers/media/video/marvell-ccic/Kconfig"
-
-config VIDEO_VIA_CAMERA
-	tristate "VIAFB camera controller support"
-	depends on FB_VIA
-	select VIDEOBUF_DMA_SG
-	select VIDEO_OV7670
 	help
-	   Driver support for the integrated camera controller in VIA
-	   Chrome9 chipsets.  Currently only tested on OLPC xo-1.5 systems
-	   with ov7670 sensors.
-
-#
-# Platform multimedia device configuration
-#
-
-source "drivers/media/video/davinci/Kconfig"
-
-source "drivers/media/video/omap/Kconfig"
-
-source "drivers/media/video/blackfin/Kconfig"
+	  This option enabled support for RT8547 LED drivers
 
-config VIDEO_SH_VOU
-	tristate "SuperH VOU video output driver"
-	depends on VIDEO_DEV && ARCH_SHMOBILE
-	select VIDEOBUF_DMA_CONTIG
+config FLED_RT5033
+	bool "LED Support for RT5033"
+	default n
 	help
-	  Support for the Video Output Unit (VOU) on SuperH SoCs.
+	  This option enabled support for RT5033 LED drivers
 
-config VIDEO_VIU
-	tristate "Freescale VIU Video Driver"
-	depends on VIDEO_V4L2 && PPC_MPC512x
-	select VIDEOBUF_DMA_CONTIG
-	default y
-	---help---
-	  Support for Freescale VIU video driver. This device captures
-	  video data, or overlays video on DIU frame buffer.
-
-	  Say Y here if you want to enable VIU device on MPC5121e Rev2+.
-	  In doubt, say N.
-
-config VIDEO_TIMBERDALE
-	tristate "Support for timberdale Video In/LogiWIN"
-	depends on VIDEO_V4L2 && I2C && DMADEVICES
-	select DMA_ENGINE
-	select TIMB_DMA
-	select VIDEO_ADV7180
-	select VIDEOBUF_DMA_CONTIG
-	---help---
-	  Add support for the Video In peripherial of the timberdale FPGA.
-
-config VIDEO_VINO
-	tristate "SGI Vino Video For Linux"
-	depends on I2C && SGI_IP22 && VIDEO_V4L2
-	select VIDEO_SAA7191 if VIDEO_HELPER_CHIPS_AUTO
+config LEDS_RT8547_DBG
+	bool "LED RT8547 Debug"
+	depends on LEDS_RT8547
+	default n
 	help
-	  Say Y here to build in support for the Vino video input system found
-	  on SGI Indy machines.
-
-config VIDEO_M32R_AR
-	tristate "AR devices"
-	depends on M32R && VIDEO_V4L2
-	---help---
-	  This is a video4linux driver for the Renesas AR (Artificial Retina)
-	  camera module.
-
-config VIDEO_M32R_AR_M64278
-	tristate "AR device with color module M64278(VGA)"
-	depends on PLAT_M32700UT
-	select VIDEO_M32R_AR
-	---help---
-	  This is a video4linux driver for the Renesas AR (Artificial
-	  Retina) with M64278E-800 camera module.
-	  This module supports VGA(640x480 pixels) resolutions.
+	  This option enabled RT8547 LED drivers debug option
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called arv.
-
-config VIDEO_OMAP3
-	tristate "OMAP 3 Camera support (EXPERIMENTAL)"
-	depends on OMAP_IOVMM && VIDEO_V4L2 && I2C && VIDEO_V4L2_SUBDEV_API && ARCH_OMAP3 && EXPERIMENTAL
-	---help---
-	  Driver for an OMAP 3 camera controller.
-
-config VIDEO_OMAP3_DEBUG
-	bool "OMAP 3 Camera debug messages"
-	depends on VIDEO_OMAP3
-	---help---
-	  Enable debug messages on OMAP 3 camera controller driver.
-
-config SOC_CAMERA
-	tristate "SoC camera support"
-	depends on VIDEO_V4L2 && HAS_DMA && I2C
-	select VIDEOBUF_GEN
-	select VIDEOBUF2_CORE
+config LEDS_DELL_NETBOOKS
+	tristate "External LED on Dell Business Netbooks"
+	depends on LEDS_CLASS
+	depends on X86 && ACPI_WMI
 	help
-	  SoC Camera is a common API to several cameras, not connecting
-	  over a bus like PCI or USB. For example some i2c camera connected
-	  directly to the data bus of an SoC.
+	  This adds support for the Latitude 2100 and similar
+	  notebooks that have an external LED.
 
-config SOC_CAMERA_IMX074
-	tristate "imx074 support"
-	depends on SOC_CAMERA && I2C
+config LEDS_MC13783
+	tristate "LED Support for MC13783 PMIC"
+	depends on LEDS_CLASS
+	depends on MFD_MC13783
 	help
-	  This driver supports IMX074 cameras from Sony
-
-config SOC_CAMERA_MT9M001
-	tristate "mt9m001 support"
-	depends on SOC_CAMERA && I2C
-	select GPIO_PCA953X if MT9M001_PCA9536_SWITCH
+	  This option enable support for on-chip LED drivers found
+	  on Freescale Semiconductor MC13783 PMIC.
+
+config LEDS_NS2
+	tristate "LED support for Network Space v2 GPIO LEDs"
+	depends on LEDS_CLASS
+	depends on MACH_NETSPACE_V2 || MACH_INETSPACE_V2 || \
+		   MACH_NETSPACE_MAX_V2 || MACH_D2NET_V2
+	default y
 	help
-	  This driver supports MT9M001 cameras from Micron, monochrome
-	  and colour models.
-
-config SOC_CAMERA_MT9M111
-	tristate "mt9m111, mt9m112 and mt9m131 support"
-	depends on SOC_CAMERA && I2C
+	  This option enable support for the dual-GPIO LED found on the
+	  Network Space v2 board (and parents). This include Internet Space v2,
+	  Network Space (Max) v2 and d2 Network v2 boards.
+
+config LEDS_NETXBIG
+	tristate "LED support for Big Network series LEDs"
+	depends on MACH_NET2BIG_V2 || MACH_NET5BIG_V2
+	depends on LEDS_CLASS
+	default y
 	help
-	  This driver supports MT9M111, MT9M112 and MT9M131 cameras from
-	  Micron/Aptina
-
-config SOC_CAMERA_MT9T031
-	tristate "mt9t031 support"
-	depends on SOC_CAMERA && I2C
+	  This option enable support for LEDs found on the LaCie 2Big
+	  and 5Big Network v2 boards. The LEDs are wired to a CPLD and are
+	  controlled through a GPIO extension bus.
+
+config LEDS_ASIC3
+	bool "LED support for the HTC ASIC3"
+	depends on LEDS_CLASS
+	depends on MFD_ASIC3
+	default y
 	help
-	  This driver supports MT9T031 cameras from Micron.
-
-config SOC_CAMERA_MT9T112
-	tristate "mt9t112 support"
-	depends on SOC_CAMERA && I2C
+	  This option enables support for the LEDs on the HTC ASIC3. The HTC
+	  ASIC3 LED GPIOs are inputs, not outputs, thus the leds-gpio driver
+	  cannot be used. This driver supports hardware blinking with an on+off
+	  period from 62ms to 125s. Say Y to enable LEDs on the HP iPAQ hx4700.
+
+config LEDS_RENESAS_TPU
+	bool "LED support for Renesas TPU"
+	depends on LEDS_CLASS && HAVE_CLK && GENERIC_GPIO
 	help
-	  This driver supports MT9T112 cameras from Aptina.
-
-config SOC_CAMERA_MT9V022
-	tristate "mt9v022 support"
-	depends on SOC_CAMERA && I2C
-	select GPIO_PCA953X if MT9V022_PCA9536_SWITCH
+	  This option enables build of the LED TPU platform driver,
+	  suitable to drive any TPU channel on newer Renesas SoCs.
+	  The driver controls the GPIO pin connected to the LED via
+	  the GPIO framework and expects the LED to be connected to
+	  a pin that can be driven in both GPIO mode and using TPU
+	  pin function. The latter to support brightness control.
+	  Brightness control is supported but hardware blinking is not.
+
+config LEDS_TCA6507
+	tristate "LED Support for TCA6507 I2C chip"
+	depends on LEDS_CLASS && I2C
 	help
-	  This driver supports MT9V022 cameras from Micron
+	  This option enables support for LEDs connected to TC6507
+	  LED driver chips accessed via the I2C bus.
+	  Driver support brightness control and hardware-assisted blinking.
 
-config SOC_CAMERA_RJ54N1
-	tristate "rj54n1cb0c support"
-	depends on SOC_CAMERA && I2C
+config LEDS_MAX8997
+	tristate "LED support for MAX8997 PMIC"
+	depends on LEDS_CLASS && MFD_MAX8997
 	help
-	  This is a rj54n1cb0c video driver
+	  This option enables support for on-chip LED drivers on
+	  MAXIM MAX8997 PMIC.
 
-config SOC_CAMERA_TW9910
-	tristate "tw9910 support"
-	depends on SOC_CAMERA && I2C
+config LEDS_OT200
+	tristate "LED support for the Bachmann OT200"
+	depends on LEDS_CLASS && HAS_IOMEM
 	help
-	  This is a tw9910 video driver
+	  This option enables support for the LEDs on the Bachmann OT200.
+	  Say Y to enable LEDs on the Bachmann OT200.
 
-config SOC_CAMERA_PLATFORM
-	tristate "platform camera support"
-	depends on SOC_CAMERA
+config LEDS_TRIGGERS
+	bool "LED Trigger support"
+	depends on LEDS_CLASS
 	help
-	  This is a generic SoC camera platform driver, useful for testing
+	  This option enables trigger support for the leds class.
+	  These triggers allow kernel events to drive the LEDs and can
+	  be configured via sysfs. If unsure, say Y.
 
-config SOC_CAMERA_OV2640
-	tristate "ov2640 camera support"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a ov2640 camera driver
+comment "LED Triggers"
 
-config SOC_CAMERA_OV5642
-	tristate "ov5642 camera support"
-	depends on SOC_CAMERA && I2C
+config LEDS_TRIGGER_TIMER
+	tristate "LED Timer Trigger"
+	depends on LEDS_TRIGGERS
 	help
-	  This is a V4L2 camera driver for the OmniVision OV5642 sensor
+	  This allows LEDs to be controlled by a programmable timer
+	  via sysfs. Some LED hardware can be programmed to start
+	  blinking the LED without any further software interaction.
+	  For more details read Documentation/leds/leds-class.txt.
 
-config SOC_CAMERA_OV6650
-	tristate "ov6650 sensor support"
-	depends on SOC_CAMERA && I2C
-	---help---
-	  This is a V4L2 SoC camera driver for the OmniVision OV6650 sensor
+	  If unsure, say Y.
 
-config SOC_CAMERA_OV772X
-	tristate "ov772x camera support"
-	depends on SOC_CAMERA && I2C
+config LEDS_TRIGGER_IDE_DISK
+	bool "LED IDE Disk Trigger"
+	depends on IDE_GD_ATA
+	depends on LEDS_TRIGGERS
 	help
-	  This is a ov772x camera driver
+	  This allows LEDs to be controlled by IDE disk activity.
+	  If unsure, say Y.
 
-config SOC_CAMERA_OV9640
-	tristate "ov9640 camera support"
-	depends on SOC_CAMERA && I2C
+config LEDS_TRIGGER_HEARTBEAT
+	tristate "LED Heartbeat Trigger"
+	depends on LEDS_TRIGGERS
 	help
-	  This is a ov9640 camera driver
-
-config SOC_CAMERA_OV9740
-	tristate "ov9740 camera support"
-	depends on SOC_CAMERA && I2C
+	  This allows LEDs to be controlled by a CPU load average.
+	  The flash frequency is a hyperbolic function of the 1-minute
+	  load average.
+	  If unsure, say Y.
+
+config LEDS_TRIGGER_BACKLIGHT
+	tristate "LED backlight Trigger"
+	depends on LEDS_TRIGGERS
 	help
-	  This is a ov9740 camera driver
-
-config MX1_VIDEO
-	bool
+	  This allows LEDs to be controlled as a backlight device: they
+	  turn off and on when the display is blanked and unblanked.
 
-config VIDEO_MX1
-	tristate "i.MX1/i.MXL CMOS Sensor Interface driver"
-	depends on VIDEO_DEV && ARCH_MX1 && SOC_CAMERA
-	select FIQ
-	select VIDEOBUF_DMA_CONTIG
-	select MX1_VIDEO
-	---help---
-	  This is a v4l2 driver for the i.MX1/i.MXL CMOS Sensor Interface
+	  If unsure, say N.
 
-config MX3_VIDEO
-	bool
-
-config VIDEO_MX3
-	tristate "i.MX3x Camera Sensor Interface driver"
-	depends on VIDEO_DEV && MX3_IPU && SOC_CAMERA
-	select VIDEOBUF2_DMA_CONTIG
-	select MX3_VIDEO
-	---help---
-	  This is a v4l2 driver for the i.MX3x Camera Sensor Interface
-
-config VIDEO_PXA27x
-	tristate "PXA27x Quick Capture Interface driver"
-	depends on VIDEO_DEV && PXA27x && SOC_CAMERA
-	select VIDEOBUF_DMA_SG
-	---help---
-	  This is a v4l2 driver for the PXA27x Quick Capture Interface
-
-config VIDEO_SH_MOBILE_CSI2
-	tristate "SuperH Mobile MIPI CSI-2 Interface driver"
-	depends on VIDEO_DEV && SOC_CAMERA && HAVE_CLK
-	---help---
-	  This is a v4l2 driver for the SuperH MIPI CSI-2 Interface
-
-config VIDEO_SH_MOBILE_CEU
-	tristate "SuperH Mobile CEU Interface driver"
-	depends on VIDEO_DEV && SOC_CAMERA && HAS_DMA && HAVE_CLK
-	select VIDEOBUF2_DMA_CONTIG
-	---help---
-	  This is a v4l2 driver for the SuperH Mobile CEU Interface
-
-config VIDEO_OMAP1
-	tristate "OMAP1 Camera Interface driver"
-	depends on VIDEO_DEV && ARCH_OMAP1 && SOC_CAMERA
-	select VIDEOBUF_DMA_CONTIG
-	select VIDEOBUF_DMA_SG
-	---help---
-	  This is a v4l2 driver for the TI OMAP1 camera interface
-
-config VIDEO_OMAP2
-	tristate "OMAP2 Camera Capture Interface driver"
-	depends on VIDEO_DEV && ARCH_OMAP2
-	select VIDEOBUF_DMA_SG
-	---help---
-	  This is a v4l2 driver for the TI OMAP2 camera capture interface
-
-config VIDEO_MX2_HOSTSUPPORT
-	bool
-
-config VIDEO_MX2
-	tristate "i.MX27/i.MX25 Camera Sensor Interface driver"
-	depends on VIDEO_DEV && SOC_CAMERA && (MACH_MX27 || ARCH_MX25)
-	select VIDEOBUF2_DMA_CONTIG
-	select VIDEO_MX2_HOSTSUPPORT
-	---help---
-	  This is a v4l2 driver for the i.MX27 and the i.MX25 Camera Sensor
-	  Interface
-
-config  VIDEO_SAMSUNG_S5P_FIMC
-	tristate "Samsung S5P and EXYNOS4 camera interface driver (EXPERIMENTAL)"
-	depends on VIDEO_V4L2 && I2C && PLAT_S5P && PM_RUNTIME && \
-		VIDEO_V4L2_SUBDEV_API && EXPERIMENTAL
-	select VIDEOBUF2_DMA_CONTIG
-	select V4L2_MEM2MEM_DEV
-	---help---
-	  This is a v4l2 driver for Samsung S5P and EXYNOS4 camera
-	  host interface and video postprocessor.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called s5p-fimc.
-
-config VIDEO_ATMEL_ISI
-	tristate "ATMEL Image Sensor Interface (ISI) support"
-	depends on VIDEO_DEV && SOC_CAMERA && ARCH_AT91
-	select VIDEOBUF2_DMA_CONTIG
-	---help---
-	  This module makes the ATMEL Image Sensor Interface available
-	  as a v4l2 device.
-
-config VIDEO_S5P_MIPI_CSIS
-	tristate "Samsung S5P and EXYNOS4 MIPI CSI receiver driver"
-	depends on VIDEO_V4L2 && PM_RUNTIME && PLAT_S5P
-	depends on VIDEO_V4L2_SUBDEV_API && REGULATOR
-	---help---
-	  This is a v4l2 driver for Samsung S5P/EXYNOS4 MIPI-CSI receiver.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called s5p-csis.
-
-source "drivers/media/video/s5p-tv/Kconfig"
+config LEDS_TRIGGER_GPIO
+	tristate "LED GPIO Trigger"
+	depends on LEDS_TRIGGERS
+	depends on GPIOLIB
+	help
+	  This allows LEDs to be controlled by gpio events. It's good
+	  when using gpios as switches and triggering the needed LEDs
+	  from there. One use case is n810's keypad LEDs that could
+	  be triggered by this trigger when user slides up to show
+	  keypad.
 
-endif # V4L_PLATFORM_DRIVERS
-endif # VIDEO_CAPTURE_DRIVERS
+	  If unsure, say N.
 
-menuconfig V4L_MEM2MEM_DRIVERS
-	bool "Memory-to-memory multimedia devices"
-	depends on VIDEO_V4L2
-	default n
-	---help---
-	  Say Y here to enable selecting drivers for V4L devices that
-	  use system memory for both source and destination buffers, as opposed
-	  to capture and output drivers, which use memory buffers for just
-	  one of those.
-
-if V4L_MEM2MEM_DRIVERS
-
-config VIDEO_MEM2MEM_TESTDEV
-	tristate "Virtual test device for mem2mem framework"
-	depends on VIDEO_DEV && VIDEO_V4L2
-	select VIDEOBUF2_VMALLOC
-	select V4L2_MEM2MEM_DEV
-	default n
-	---help---
-	  This is a virtual test device for the memory-to-memory driver
-	  framework.
-
-config VIDEO_SAMSUNG_S5P_G2D
-	tristate "Samsung S5P and EXYNOS4 G2D 2d graphics accelerator driver"
-	depends on VIDEO_DEV && VIDEO_V4L2 && PLAT_S5P
-	select VIDEOBUF2_DMA_CONTIG
-	select V4L2_MEM2MEM_DEV
-	default n
-	---help---
-	  This is a v4l2 driver for Samsung S5P and EXYNOS4 G2D
-	  2d graphics accelerator.
-
-config VIDEO_SAMSUNG_S5P_JPEG
-	tristate "Samsung S5P/Exynos4 JPEG codec driver (EXPERIMENTAL)"
-	depends on VIDEO_DEV && VIDEO_V4L2 && PLAT_S5P && EXPERIMENTAL
-	select VIDEOBUF2_DMA_CONTIG
-	select V4L2_MEM2MEM_DEV
-	---help---
-	  This is a v4l2 driver for Samsung S5P and EXYNOS4 JPEG codec
-
-config VIDEO_SAMSUNG_S5P_MFC
-	tristate "Samsung S5P MFC 5.1 Video Codec"
-	depends on VIDEO_DEV && VIDEO_V4L2 && PLAT_S5P
-	select VIDEOBUF2_DMA_CONTIG
-	default n
+config LEDS_TRIGGER_DEFAULT_ON
+	tristate "LED Default ON Trigger"
+	depends on LEDS_TRIGGERS
 	help
-	    MFC 5.1 driver for V4L2.
+	  This allows LEDs to be initialised in the ON state.
+	  If unsure, say Y.
 
-config VIDEO_MX2_EMMAPRP
-	tristate "MX2 eMMa-PrP support"
-	depends on VIDEO_DEV && VIDEO_V4L2 && SOC_IMX27
-	select VIDEOBUF2_DMA_CONTIG
-	select V4L2_MEM2MEM_DEV
+config LEDS_TRIGGER_SLEEP
+	tristate "LED Sleep Mode Trigger"
+	depends on LEDS_TRIGGERS && HAS_EARLYSUSPEND
 	help
-	    MX2X chips have a PrP that can be used to process buffers from
-	    memory to memory. Operations include resizing and format
-	    conversion.
+	  This turns LEDs on when the screen is off but the cpu still running.
+
+comment "iptables trigger is under Netfilter config (LED target)"
+	depends on LEDS_TRIGGERS
 
-endif # V4L_MEM2MEM_DRIVERS
+endif # NEW_LEDS
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index a6282a3a..5f7e9040 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -89,13 +89,30 @@ obj-$(CONFIG_SOC_CAMERA_MT9T031)	+= mt9t031.o
 obj-$(CONFIG_SOC_CAMERA_MT9T112)	+= mt9t112.o
 obj-$(CONFIG_SOC_CAMERA_MT9V022)	+= mt9v022.o
 obj-$(CONFIG_SOC_CAMERA_OV2640)		+= ov2640.o
-obj-$(CONFIG_SOC_CAMERA_OV5642)		+= ov5642.o
+obj-$(CONFIG_SOC_CAMERA_OV2659)		+= ov2659.o
+obj-$(CONFIG_SOC_CAMERA_OV5642)		+= ov5642.o ov5642_cfg.o
+obj-$(CONFIG_SOC_CAMERA_OV5640)		+= ov5640.o
 obj-$(CONFIG_SOC_CAMERA_OV6650)		+= ov6650.o
 obj-$(CONFIG_SOC_CAMERA_OV772X)		+= ov772x.o
 obj-$(CONFIG_SOC_CAMERA_OV9640)		+= ov9640.o
 obj-$(CONFIG_SOC_CAMERA_OV9740)		+= ov9740.o
 obj-$(CONFIG_SOC_CAMERA_RJ54N1)		+= rj54n1cb0c.o
 obj-$(CONFIG_SOC_CAMERA_TW9910)		+= tw9910.o
+obj-$(CONFIG_VIDEO_MVISP_OV882X) 	+= ov882x.o
+obj-$(CONFIG_VIDEO_MVISP_SENSOR) 	+= mvisp_sensor.o
+obj-$(CONFIG_VIDEO_VCM_DW9714L) 	+= dw9714l.o
+obj-$(CONFIG_VIDEO_VCM_AD5823)         += ad5823.o
+obj-$(CONFIG_VIDEO_VCM_AK7343)		+= ak7343.o
+ifeq ($(CONFIG_CAMERA_J_CAMERA),y)
+obj-$(CONFIG_SOC_CAMERA_S5K4ECGX) 		+= s5k4ecgx_jcam.o
+else
+obj-$(CONFIG_SOC_CAMERA_S5K4ECGX) 	+= s5k4ecgx.o
+endif
+obj-$(CONFIG_SOC_CAMERA_SUBSENSOR) 	+= subsensor.o
+obj-$(CONFIG_SOC_CAMERA_SR352)		+= sr352.o
+obj-$(CONFIG_SOC_CAMERA_SR030PC50)	+= sr030pc50.o
+obj-$(CONFIG_SOC_CAMERA_SR130PC10) 	+= sr130pc10.o
+obj-$(CONFIG_SOC_CAMERA_SR200PC20M) 	+= sr200pc20m.o
 
 # And now the v4l2 drivers:
 
@@ -171,6 +188,8 @@ obj-$(CONFIG_VIDEO_CX23885) += cx23885/
 obj-$(CONFIG_VIDEO_AK881X)		+= ak881x.o
 
 obj-$(CONFIG_VIDEO_OMAP2)		+= omap2cam.o
+#obj-$(CONFIG_ECS_DRIVER)		+= ecs/
+obj-$(CONFIG_MAP_CAMERA)		+= map_hw.o map_camera.o map_vnode.o
 obj-$(CONFIG_SOC_CAMERA)		+= soc_camera.o soc_mediabus.o
 obj-$(CONFIG_SOC_CAMERA_PLATFORM)	+= soc_camera_platform.o
 # soc-camera host drivers have to be linked after camera drivers
@@ -178,11 +197,20 @@ obj-$(CONFIG_VIDEO_MX1)			+= mx1_camera.o
 obj-$(CONFIG_VIDEO_MX2)			+= mx2_camera.o
 obj-$(CONFIG_VIDEO_MX3)			+= mx3_camera.o
 obj-$(CONFIG_VIDEO_PXA27x)		+= pxa_camera.o
+ifndef CONFIG_MACH_LT02
+obj-$(CONFIG_VIDEO_MMP) 		+= mmp_camera.o
+else
+obj-$(CONFIG_VIDEO_MMP) 		+= mmp_camera_lt02.o
+endif
+obj-$(CONFIG_VIDEO_MRVL_CAM_DEBUG)	+= mc_debug.o
 obj-$(CONFIG_VIDEO_SH_MOBILE_CSI2)	+= sh_mobile_csi2.o
 obj-$(CONFIG_VIDEO_SH_MOBILE_CEU)	+= sh_mobile_ceu_camera.o
 obj-$(CONFIG_VIDEO_OMAP1)		+= omap1_camera.o
 obj-$(CONFIG_VIDEO_ATMEL_ISI)		+= atmel-isi.o
 
+#obj-$(CONFIG_VIDEO_MVISP)			+= mvisp/
+
+
 obj-$(CONFIG_VIDEO_MX2_EMMAPRP)		+= mx2_emmaprp.o
 
 obj-$(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) 	+= s5p-fimc/
@@ -207,7 +235,10 @@ obj-$(CONFIG_VIDEO_IR_I2C)  += ir-kbd-i2c.o
 
 obj-y	+= davinci/
 
+# obj-$(CONFIG_CMMB)			+= cmmb/
+
 obj-$(CONFIG_ARCH_OMAP)	+= omap/
+obj-$(CONFIG_MMP_V4L2_OVERLAY)  += mmp_vout.o
 
 ccflags-y += -I$(srctree)/drivers/media/dvb/dvb-core
 ccflags-y += -I$(srctree)/drivers/media/dvb/frontends
diff --git a/drivers/media/video/mmp_camera.h b/drivers/media/video/mmp_camera.h
new file mode 100644
index 00000000..2c768367
--- /dev/null
+++ b/drivers/media/video/mmp_camera.h
@@ -0,0 +1,291 @@
+/*
+ * Register definitions for the m88alp01 camera interface.
+ * Offsets in bytes as given in the spec.
+ *
+ * Copyright 2006 One Laptop Per Child Association, Inc.
+ * Written by Jonathan Corbet <corbet@lwn.net>
+ *
+ * Copyright (C) 2011-2012, Marvell International Ltd.
+ * Modified by Kassey Lee <ygli@marvell.com>
+ *	       Albert Wang <twang13@marvell.com>
+ *
+ * This file may be distributed under the terms of the GNU General
+ * Public License, version 2.
+ */
+#ifndef __MMP_CAMERA_H
+#define __MMP_CAMERA_H
+
+/* All the Micro are for samsung debug, by Vincent Wan. */
+//#define __DEBUG_DMA_DONE 						/* Set frames finished interrupt indicating, defined for 'DMA done', undefined for 'EOF detect', prefer 'dma done'.*/
+#define __DEBUG_ENABLE_OVERFLOWIRQ			/* Enable overflow irq */
+#undef __DEBUG_DUMP_REGISTER					/* Dump All CCIC registers */
+#undef __DEBUG_ENABLE_RAWSTATUS				/* Read the raw status registers */
+#define SSG_SKIP_FRAMES 0						/* Skip the frames, 0: no skip, 1: skip one frame,2:skip two frames */
+#undef __ENABLE_DDR_MIN_312MHZ					/* Enable limit min ddr clock to 312MHZ */
+#undef __DEBUG_STREAM_ON_OFF_LOG				/* Enable stream on/off kernel log */
+#undef __DEBUG_ENABLE_COUNTS_CHECK
+#undef __DEBUG_ENABLE_SKIP_EOF_CHECK
+/*
+ * Y.U.V. reg define
+ */
+#define REG_Y0BAR	0x00
+#define REG_Y1BAR	0x04
+#define REG_Y2BAR	0x08
+#define REG_U0BAR	0x0c
+#define REG_U1BAR	0x10
+#define REG_U2BAR	0x14
+#define REG_V0BAR	0x18
+#define REG_V1BAR	0x1C
+#define REG_V2BAR	0x20
+
+/*
+ * MIPI enable
+ */
+#define REG_CSI2_CTRL0	0x100
+#define REG_CSI2_DPHY3  0x12c
+#define REG_CSI2_DPHY5  0x134
+#define REG_CSI2_DPHY6  0x138
+
+#define REG_IMGPITCH	0x24	/* Image pitch register */
+#define   IMGP_YP_SHFT	  2		/* Y pitch params */
+#define   IMGP_YP_MASK	  0x00003ffc	/* Y pitch field */
+#define   IMGP_UVP_SHFT   18		/* UV pitch (planar) */
+#define   IMGP_UVP_MASK   0x3ffc0000
+
+#define REG_IRQSTATRAW	0x28	/* RAW IRQ Status */
+
+#define REG_IRQMASK	0x2c	/* IRQ mask - same bits as IRQSTAT */
+
+#define REG_IRQSTAT	0x30	/* IRQ status / clear */
+#define   IRQ_DMA_DONE0	  0x01 << 18	/* Dma done of frame 0 */
+#define   IRQ_DMA_DONE1	  0x01 << 19	/* Dma done of frame 1 */
+#define   IRQ_DMA_DONE2	  0x01 << 20	/* Dma done of frame 2 */
+
+#define   IRQ_EOF0	  0x00000001	/* End of frame 0 */
+#define   IRQ_EOF1	  0x00000002	/* End of frame 1 */
+#define   IRQ_EOF2	  0x00000004	/* End of frame 2 */
+#define   IRQ_SOF0	  0x00000008	/* Start of frame 0 */
+#define   IRQ_SOF1	  0x00000010	/* Start of frame 1 */
+#define   IRQ_SOF2	  0x00000020	/* Start of frame 2 */
+#define   IRQ_OVERFLOW	  0x00000040	/* FIFO overflow */
+#define   FRAMEIRQS_EOF   (IRQ_EOF0 | IRQ_EOF1 | IRQ_EOF2)
+#define   FRAMEIRQS_DMA_DONE   (IRQ_DMA_DONE0 | IRQ_DMA_DONE1 | IRQ_DMA_DONE2)
+#define   FRAMEIRQS_SOF   (IRQ_SOF0 | IRQ_SOF1 | IRQ_SOF2)
+#define   FRAMEIRQS	  (FRAMEIRQS_EOF | FRAMEIRQS_SOF)
+#define   FRAMEIRQS_DMA	  (FRAMEIRQS_DMA_DONE | FRAMEIRQS_SOF)
+#define   ALLIRQS	  (FRAMEIRQS | IRQ_OVERFLOW)
+#define   ALLIRQS_DMA	  (FRAMEIRQS_DMA | IRQ_OVERFLOW)
+
+#define REG_IMGSIZE	0x34	/* Image size */
+#define  IMGSZ_V_MASK	  0x1fff0000
+#define  IMGSZ_V_SHIFT	  16
+#define  IMGSZ_H_MASK	  0x00003fff
+
+#define REG_IMGOFFSET	0x38	/* IMage offset */
+
+#define REG_CTRL0	0x3c	/* Control 0 */
+#define   C0_ENABLE	  0x00000001	/* Makes the whole thing go */
+/* Mask for all the format bits */
+#define   C0_DF_MASK	  0x00fffffc    /* Bits 2-23 */
+/* RGB ordering */
+#define   C0_RGB4_RGBX	  0x00000000
+#define   C0_RGB4_XRGB	  0x00000004
+#define   C0_RGB4_BGRX	  0x00000008
+#define   C0_RGB4_XBGR	  0x0000000c
+#define   C0_RGB5_RGGB	  0x00000000
+#define   C0_RGB5_GRBG	  0x00000004
+#define   C0_RGB5_GBRG	  0x00000008
+#define   C0_RGB5_BGGR	  0x0000000c
+/* Spec has two fields for DIN and DOUT, but they must match, so
+   combine them here. */
+#define   C0_DF_YUV	  0x00000000    /* Data is YUV */
+#define   C0_DF_RGB	  0x000000a0	/* Data is RGB */
+#define   C0_DF_BAYER	  0x00000140	/* Data is Bayer */
+/* 8-8-8 must be missing from the below - ask */
+#define   C0_RGBF_565	  0x00000000
+#define   C0_RGBF_444	  0x00000800
+#define   C0_RGB_BGR	  0x00001000	/* Blue comes first */
+#define   C0_YUV_PLANAR   0x00000000	/* YUV 422 planar format */
+#define   C0_YUV_PACKED   0x00008000	/* YUV 422 packed format */
+#define   C0_YUV_420PL	  0x0000a000	/* YUV 420 planar format */
+/* Think that 420 packed must be 111 - ask */
+#define   C0_YUVE_YUYV	  0x00000000	/* Y1CbY0Cr */
+#define   C0_YUVE_YVYU	  0x00010000	/* Y1CrY0Cb */
+#define   C0_YUVE_VYUY	  0x00020000	/* CrY1CbY0 */
+#define   C0_YUVE_UYVY	  0x00030000	/* CbY1CrY0 */
+#define   C0_YUVE_XYUV	  0x00000000    /* 420: .YUV */
+#define   C0_YUVE_XYVU	  0x00010000	/* 420: .YVU */
+#define   C0_YUVE_XUVY	  0x00020000	/* 420: .UVY */
+#define   C0_YUVE_XVUY	  0x00030000	/* 420: .VUY */
+/* Bayer bits 18,19 if needed */
+#define   C0_HPOL_LOW	  0x01000000	/* HSYNC polarity active low */
+#define   C0_VPOL_LOW	  0x02000000	/* VSYNC polarity active low */
+#define   C0_VCLK_LOW	  0x04000000	/* VCLK on falling edge */
+#define   C0_DOWNSCALE	  0x08000000	/* Enable downscaler */
+#define   C0_SIFM_MASK	  0xc0000000	/* SIF mode bits */
+#define   C0_SIF_HVSYNC   0x00000000	/* Use H/VSYNC */
+#define   C0_SOF_NOSYNC   0x40000000	/* Use inband active signaling */
+#define   C0_EOF_VSYNC	  0x00400000	/* Generate EOF by VSYNC */
+#define   C0_VEDGE_CTRL   0x00800000	/* Detecting falling edge of VSYNC */
+
+#define REG_CTRL1	0x40	/* Control 1 */
+#define   C1_RESERVED	  0x0000003c	/* Reserved and shouldn't be changed */
+#define   C1_444ALPHA	  0x00f00000	/* Alpha field in RGB444 */
+#define   C1_ALPHA_SHFT   20
+#define   C1_DMAB64	  0x00000000	/* 64-byte DMA burst */
+#define   C1_DMAB128	  0x02000000	/* 128-byte DMA burst */
+#define   C1_DMAB256	  0x04000000	/* 256-byte DMA burst */
+#define   C1_DMAB_MASK	  0x06000000
+#define   C1_TWOBUFS	  0x08000000	/* Use only two DMA buffers */
+#define   C1_PWRDWN	  0x10000000	/* Power down */
+#define   C1_DMAPOSTED	  0x40000000	/* DMA Posted Select */
+
+#define REG_CTRL2	0x44	/* Control 2 */
+#define ISIM_FIX	0x80000000	/* ISIM FIX */
+#define REG_CTRL3	0x1ec	/* CCIC parallel mode */
+
+#define REG_LNNUM	0x60	/* Lines num DMA filled */
+
+#define REG_CLKCTRL	0x88	/* Clock control */
+
+#define REG_FRAME_CNT 0x23c	/* Frame byte count */
+
+#define   CLK_DIV_MASK	  0x0000ffff	/* Upper bits RW "reserved" */
+
+/*
+ * Indicate flags for CCIC frame buffer state
+ * 0	- No available buffer, will enter signle buffer mode
+ * 1:3	- Normal mode, indicate which frame buffer is used in CCIC
+ */
+#define CF_SINGLE_BUF	0
+#define CF_FRAME_SOF0	1
+
+/*
+ * CCIC can support at most 3 frame buffers
+ * 2	- Use Two Buffers mode
+ * 3	- Use Three Buffers mode
+ */
+#define MAX_DMA_BUFS	2
+#define CF_FRMAE_OVERFLOW	(CF_FRAME_SOF0 + MAX_DMA_BUFS)
+/*
+ * Basic frame states
+ */
+struct mmp_frame_state {
+	int frames;
+	int singles;
+	int delivered;
+#if MAX_DMA_BUFS == 3
+	int tribufs;	/* Only tribufs == 2 can enter single buffer mode */
+#endif
+};
+
+struct yuv_pointer_t {
+	dma_addr_t y;
+	dma_addr_t u;
+	dma_addr_t v;
+};
+
+/*
+ * buffer for one video frame
+ */
+struct mmp_buffer {
+	/*
+	 * common v4l buffer stuff -- must be first
+	 */
+	struct vb2_buffer vb_buf;
+	struct yuv_pointer_t yuv_p;
+	struct list_head queue;
+	struct page *page;
+	size_t bsize;
+	int list_init_flag;
+};
+
+enum mmp_camera_state {
+	S_IDLE,		/* Just hanging around */
+	S_STREAMING,	/* Streaming data */
+	S_BUFWAIT	/* streaming requested but no buffers yet */
+};
+
+struct mmp_camera_dev {
+	struct soc_camera_host soc_host;
+	struct soc_camera_device *icd;
+	unsigned int irq;
+	void __iomem *base;
+	struct platform_device *pdev;
+	struct resource *res;
+	struct list_head buffers;	/* Available frames */
+	spinlock_t list_lock;
+	struct mutex s_mutex;		/* Access to this structure */
+	struct v4l2_pix_format pix_format;
+	unsigned long flags;		/* Indicate frame buffer state */
+	struct mmp_frame_state frame_state;	/* Frame state counter */
+	enum mmp_camera_state state;
+	struct mmp_buffer *vb_bufs[MAX_DMA_BUFS];
+	unsigned int nbufs;		/* How many bufs are used for ccic */
+	struct vb2_alloc_ctx *vb_alloc_ctx;
+	int frame_rate;
+	struct pm_qos_request qos_ddr;
+#ifdef CONFIG_VIDEO_MRVL_CAM_DEBUG
+	struct ccic_mcd		mcd_root;
+	struct mcd_dphy		mcd_dphy;
+	/* in current design, DPHY and CCIC is coupled, so have to put
+	 * mcd_dphy_hw here, should move to a proper place in future */
+	struct mcd_dphy_hw	mcd_dphy_hw;
+	struct mcd_dma		mcd_ccic;
+	struct mcd_vdev		mcd_vdev;
+	struct mcd_sensor	mcd_sensor;
+#endif
+	struct pm_qos_request qos_idle;
+};
+
+#ifdef CONFIG_VIDEO_MRVL_CAM_DEBUG
+/* Get the counter value */
+#define GET(mcd, ent_id, val_id) \
+	mcd_value_read(&(mcd.pentity[ent_id]->value[val_id]))
+/* Set the counter value */
+#define SET(mcd, ent_id, val_id, val) \
+	mcd_value_set(&(mcd.pentity[ent_id]->value[val_id]), val)
+/* increase or decrease the counter value */
+#define PEG(mcd, ent_id, val_id, cnt) \
+	mcd_value_peg(&(mcd.pentity[ent_id]->value[val_id]), (cnt))
+/* Set the counter value 0 */
+#define CLEAR(mcd, ent_id, val_id) \
+	mcd_value_set(&(mcd.pentity[ent_id]->value[val_id]), 0)
+#endif
+
+/*
+ * Device register I/O
+ */
+static inline u32 ccic_reg_read(struct mmp_camera_dev *pcdev, unsigned int reg)
+{
+	return ioread32(pcdev->base + reg);
+}
+
+static inline void ccic_reg_write(struct mmp_camera_dev *pcdev,
+			unsigned int reg, u32 val)
+{
+	iowrite32(val, pcdev->base + reg);
+}
+
+static inline void ccic_reg_write_mask(struct mmp_camera_dev *pcdev,
+			unsigned int reg, u32 val, u32 mask)
+{
+	u32 v = ccic_reg_read(pcdev, reg);
+
+	v = (v & ~mask) | (val & mask);
+	ccic_reg_write(pcdev, reg, v);
+}
+
+static inline void ccic_reg_set_bit(struct mmp_camera_dev *pcdev,
+			unsigned int reg, u32 val)
+{
+	ccic_reg_write_mask(pcdev, reg, val, val);
+}
+
+static inline void ccic_reg_clear_bit(struct mmp_camera_dev *pcdev,
+			unsigned int reg, u32 val)
+{
+	ccic_reg_write_mask(pcdev, reg, 0, val);
+}
+
+#endif
diff --git a/drivers/mfd/88pm822.c b/drivers/mfd/88pm822.c
new file mode 100755
index 00000000..a451706a
--- /dev/null
+++ b/drivers/mfd/88pm822.c
@@ -0,0 +1,1253 @@
+/*
+ * Base driver for Marvell 88PM822
+ *
+ * Copyright (C) 2012 Marvell International Ltd.
+ * Haojian Zhuang <haojian.zhuang@marvell.com>
+ * Joseph(Yossi) Hanin <yhanin@marvell.com>
+ * Qiao Zhou <zhouqiao@marvell.com>
+ * Yipeng Yao <ypyao@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/88pm822.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/irq.h>
+#include <linux/proc_fs.h>
+#include "../staging/android/switch/switch.h"
+
+#define PM822_PROC_FILE			"driver/pm822_reg"
+
+struct i2c_client *pm822_client;
+
+/* Interrupt Number in 88PM822 */
+enum {
+	PM822_IRQ_ONKEY,	/* EN1b0 *//*0 */
+	PM822_IRQ_RSVD1,	/* EN1b1 */
+	PM822_IRQ_CHG,		/* EN1b2 */
+	PM822_IRQ_BAT,		/* EN1b3 */
+	PM822_IRQ_RTC,		/* EN1b4 */
+	PM822_IRQ_CLASSD,	/* EN1b5 *//*5 */
+	PM822_IRQ_VBAT,		/* EN2b0 */
+	PM822_IRQ_VSYS,		/* EN2b1 */
+	PM822_IRQ_RSVD2,	/* EN2b2 */
+	PM822_IRQ_TINT,		/* EN2b3 */
+	PM822_IRQ_LDO_PGOOD,		/* EN2b4*/
+	PM822_IRQ_BUCK_PGOOD,		/* EN2b5*/
+	PM822_IRQ_GPADC0,	/* EN3b0 *//*10 */
+	PM822_IRQ_GPADC1,	/* EN3b1 */
+	PM822_IRQ_GPADC2,	/* EN3b2 */
+	PM822_IRQ_GPADC3,	/* EN3b3 */
+	PM822_IRQ_MIC_DET,	/* EN3b4 */
+	PM822_IRQ_HS_DET,	/* EN3b5 */
+	PM822_MAX_IRQ,
+};
+
+static const struct i2c_device_id pm822_id_table[] = {
+	{"88PM822", 0},
+	{} /* NULL terminated */
+};
+MODULE_DEVICE_TABLE(i2c, pm822_id_table);
+
+static int reg_pm822 = 0xffff;
+static int pg_index;
+static struct pm822_chip *g_pm822_chip;
+
+
+static struct resource rtc_resources[] = {
+	{
+	 .name = "88pm822-rtc",
+	 .start = PM822_IRQ_RTC,
+	 .end = PM822_IRQ_RTC,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct mfd_cell rtc_devs[] = {
+	{
+	 .name = "88pm822-rtc",
+	 .num_resources = ARRAY_SIZE(rtc_resources),
+	 .resources = &rtc_resources[0],
+	 .id = -1,
+	 },
+};
+static struct resource onkey_resources[] = {
+	{
+	 .name = "88pm822-onkey",
+	 .start = PM822_IRQ_ONKEY,
+	 .end = PM822_IRQ_ONKEY,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct resource headset_resources_822[] = {
+	{
+		.name = "88pm822-headset",
+		.start = PM822_IRQ_HS_DET,
+		.end = PM822_IRQ_HS_DET,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.name = "88pm822-hook",
+		.start = PM822_IRQ_MIC_DET,
+		.end = PM822_IRQ_MIC_DET,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct gpio_switch_platform_data headset_switch_device_data[] = {
+	{
+	 /* headset switch */
+	 .name = "h2w",
+	 .gpio = 0,
+	 .name_on = NULL,
+	 .name_off = NULL,
+	 .state_on = NULL,
+	 .state_off = NULL,
+	 }, {
+	 /* hook switch */
+	 .name = "h3w",
+	 .gpio = 0,
+	 .name_on = NULL,
+	 .name_off = NULL,
+	 .state_on = NULL,
+	 .state_off = NULL,
+	 },
+};
+
+static struct mfd_cell headset_devs_822[] = {
+	{
+	 .name = "88pm822-headset",
+	 .num_resources = ARRAY_SIZE(headset_resources_822),
+	 .resources = &headset_resources_822[0],
+	 .id = -1,
+	 .platform_data = headset_switch_device_data,
+	 .pdata_size = sizeof(headset_switch_device_data),
+	 },
+};
+
+static struct mfd_cell onkey_devs[] = {
+	{
+	 .name = "88pm822-onkey",
+	 .num_resources = 1,
+	 .resources = &onkey_resources[0],
+	 .id = -1,
+	 },
+};
+
+static struct resource usb_resources[] = {
+	{
+	.name = "88pm822-usb",
+	.start = PM822_IRQ_CHG,
+	.end = PM822_IRQ_CHG,
+	.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct mfd_cell usb_devs[] = {
+	{
+	.name = "88pm822-usb",
+	.num_resources = 1,
+	.resources = &usb_resources[0],
+	.id = -1,
+	},
+};
+
+static struct mfd_cell vibrator_devs[] = {
+	{
+	 .name = "88pm822-vibrator",
+	 .id = -1,
+	},
+};
+
+static __attribute((unused)) struct mfd_cell dvc_devs[] = {
+	{
+	 .name = "dvc",
+	 .id = -1,
+	},
+};
+
+#if defined(CONFIG_FUELGAUGE_88PM822)
+static struct resource bat_resources[] = {
+	{
+#ifdef CONFIG_BATTERY_SAMSUNG
+	 .name = "sec-fuelgauge",
+#else
+	 .name = "88pm80x-bat",
+#endif
+	 .start = PM822_IRQ_VBAT,
+	 .end = PM822_IRQ_VBAT,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct mfd_cell bat_devs[] = {
+	{
+#ifdef CONFIG_BATTERY_SAMSUNG
+	 .name = "sec-fuelgauge",
+#else
+	 .name = "88pm80x-bat",
+#endif
+	.num_resources = 1,
+	.resources = &bat_resources[0],
+	.id = -1,
+},
+};
+#endif
+
+static struct resource regulator_resources[] = {
+	{PM822_ID_BUCK1, PM822_ID_BUCK1, "buck-1", IORESOURCE_IO,},
+	{PM822_ID_BUCK2, PM822_ID_BUCK2, "buck-2", IORESOURCE_IO,},
+	{PM822_ID_BUCK3, PM822_ID_BUCK3, "buck-3", IORESOURCE_IO,},
+	{PM822_ID_BUCK4, PM822_ID_BUCK4, "buck-4", IORESOURCE_IO,},
+	{PM822_ID_BUCK5, PM822_ID_BUCK5, "buck-5", IORESOURCE_IO,},
+	{PM822_ID_LDO1, PM822_ID_LDO1, "ldo-01", IORESOURCE_IO,},
+	{PM822_ID_LDO2, PM822_ID_LDO2, "ldo-02", IORESOURCE_IO,},
+	{PM822_ID_LDO3, PM822_ID_LDO3, "ldo-03", IORESOURCE_IO,},
+	{PM822_ID_LDO4, PM822_ID_LDO4, "ldo-04", IORESOURCE_IO,},
+	{PM822_ID_LDO5, PM822_ID_LDO5, "ldo-05", IORESOURCE_IO,},
+	{PM822_ID_LDO6, PM822_ID_LDO6, "ldo-06", IORESOURCE_IO,},
+	{PM822_ID_LDO7, PM822_ID_LDO7, "ldo-07", IORESOURCE_IO,},
+	{PM822_ID_LDO8, PM822_ID_LDO8, "ldo-08", IORESOURCE_IO,},
+	{PM822_ID_LDO9, PM822_ID_LDO9, "ldo-09", IORESOURCE_IO,},
+	{PM822_ID_LDO10, PM822_ID_LDO10, "ldo-10", IORESOURCE_IO,},
+	{PM822_ID_LDO11, PM822_ID_LDO11, "ldo-11", IORESOURCE_IO,},
+	{PM822_ID_LDO12, PM822_ID_LDO12, "ldo-12", IORESOURCE_IO,},
+	{PM822_ID_LDO13, PM822_ID_LDO13, "ldo-13", IORESOURCE_IO,},
+	{PM822_ID_LDO14, PM822_ID_LDO14, "ldo-14", IORESOURCE_IO,},
+	{PM822_ID_VOUTSW, PM822_ID_VOUTSW, "voutsw", IORESOURCE_IO,},
+
+#if defined(CONFIG_CPU_PXA1L88) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	/* Below 4 resources are fake, only used in new DVC */
+	{PM822_ID_BUCK1_AP_ACTIVE, PM822_ID_BUCK1_AP_ACTIVE,
+				"buck-1-ap-active", IORESOURCE_IO,},
+	{PM822_ID_BUCK1_AP_LPM, PM822_ID_BUCK1_AP_LPM,
+				"buck-1-ap-lpm", IORESOURCE_IO,},
+	{PM822_ID_BUCK1_APSUB_IDLE, PM822_ID_BUCK1_APSUB_IDLE,
+				"buck-1-apsub-idle", IORESOURCE_IO,},
+	{PM822_ID_BUCK1_APSUB_SLEEP, PM822_ID_BUCK1_APSUB_SLEEP,
+				"buck-1-apsub-sleep", IORESOURCE_IO,},
+#endif
+};
+
+static struct mfd_cell regulator_devs[] = {
+	{"88pm822-regulator", 0,},
+	{"88pm822-regulator", 1,},
+	{"88pm822-regulator", 2,},
+	{"88pm822-regulator", 3,},
+	{"88pm822-regulator", 4,},
+	{"88pm822-regulator", 5,},
+	{"88pm822-regulator", 6,},
+	{"88pm822-regulator", 7,},
+	{"88pm822-regulator", 8,},
+	{"88pm822-regulator", 9,},
+	{"88pm822-regulator", 10,},
+	{"88pm822-regulator", 11,},
+	{"88pm822-regulator", 12,},
+	{"88pm822-regulator", 13,},
+	{"88pm822-regulator", 14,},
+	{"88pm822-regulator", 15,},
+	{"88pm822-regulator", 16,},
+	{"88pm822-regulator", 17,},
+	{"88pm822-regulator", 18,},
+	{"88pm822-regulator", 19,},
+
+#if defined(CONFIG_CPU_PXA1L88) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	/* below 4 regulators are fake, only used in new dvc */
+	{"88pm822-regulator", 20,},
+	{"88pm822-regulator", 21,},
+	{"88pm822-regulator", 22,},
+	{"88pm822-regulator", 23,},
+#endif
+
+};
+
+static struct regulator_init_data regulator_pdata[ARRAY_SIZE(regulator_devs)];
+
+static const struct regmap_irq pm822_irqs[] = {
+	/* INT0 */
+	[PM822_IRQ_ONKEY] = {
+		.mask = PM822_IRQ_ONKEY_EN,
+	},
+	[PM822_IRQ_RSVD1] = {
+		.mask = 0,
+	},
+	[PM822_IRQ_CHG] = {
+		.mask = PM822_IRQ_CHG_EN,
+	},
+	[PM822_IRQ_BAT] = {
+		.mask = PM822_IRQ_BAT_EN,
+	},
+	[PM822_IRQ_RTC] = {
+		.mask = PM822_IRQ_RTC_EN,
+	},
+	[PM822_IRQ_CLASSD] = {
+		.mask = PM822_IRQ_CLASSD_EN,
+	},
+	/* INT1 */
+	[PM822_IRQ_VBAT] = {
+		.reg_offset = 1,
+		.mask = PM822_IRQ_VBAT_EN,
+	},
+	[PM822_IRQ_VSYS] = {
+		.reg_offset = 1,
+		.mask = PM822_IRQ_VSYS_EN,
+	},
+	[PM822_IRQ_LDO_PGOOD] = {
+		.reg_offset = 1,
+		.mask = PM822_IRQ_LDO_PGOOD_EN,
+	},
+	[PM822_IRQ_BUCK_PGOOD] = {
+		.reg_offset = 1,
+		.mask = PM822_IRQ_BUCK_PGOOD_EN,
+	},
+	[PM822_IRQ_RSVD2] = {
+		.reg_offset = 1,
+		.mask = 0,
+	},
+	[PM822_IRQ_TINT] = {
+		.reg_offset = 1,
+		.mask = PM822_IRQ_TINT_EN,
+	},
+	/* INT2 */
+	[PM822_IRQ_GPADC0] = {
+		.reg_offset = 2,
+		.mask = PM822_IRQ_GPADC0_EN,
+	},
+	[PM822_IRQ_GPADC1] = {
+		.reg_offset = 2,
+		.mask = PM822_IRQ_GPADC1_EN,
+	},
+	[PM822_IRQ_GPADC2] = {
+		.reg_offset = 2,
+		.mask = PM822_IRQ_GPADC2_EN,
+	},
+	[PM822_IRQ_GPADC3] = {
+		.reg_offset = 2,
+		.mask = PM822_IRQ_GPADC3_EN,
+	},
+	[PM822_IRQ_MIC_DET] = {
+		.reg_offset = 2,
+		.mask = PM822_IRQ_MIC_DET_EN,
+	},
+	[PM822_IRQ_HS_DET] = {
+		.reg_offset = 2,
+		.mask = PM822_IRQ_HS_DET_EN,
+	},
+};
+
+#if defined(CONFIG_SEC_DEBUG)
+static u8 power_on_reason = 0;
+unsigned char pm822_get_power_on_reason(void)
+{
+	return power_on_reason;
+}
+#endif
+
+static ssize_t pm822_proc_read(char *buf, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	unsigned int reg_val = 0;
+	int len = 0;
+	struct pm822_chip *chip = data;
+	int i;
+
+	if (reg_pm822 == 0xffff) {
+		pr_info("pm822: base page:\n");
+		for (i = 0; i < PM822_BASE_REG_NUM; i++) {
+			regmap_read(chip->regmap, i, &reg_val);
+			pr_info("[0x%02x]=0x%02x\n", i, reg_val);
+		}
+		pr_info("pm822: power page:\n");
+		for (i = 0; i < PM822_POWER_REG_NUM; i++) {
+			regmap_read(chip->subchip->regmap_power, i, &reg_val);
+			pr_info("[0x%02x]=0x%02x\n", i, reg_val);
+		}
+		pr_info("pm822: gpadc page:\n");
+		for (i = 0; i < PM822_GPADC_REG_NUM; i++) {
+			regmap_read(chip->subchip->regmap_gpadc, i, &reg_val);
+			pr_info("[0x%02x]=0x%02x\n", i, reg_val);
+		}
+
+		len = 0;
+	} else {
+
+		switch (pg_index) {
+		case 0:
+			regmap_read(chip->regmap, reg_pm822, &reg_val);
+			break;
+		case 1:
+			regmap_read(chip->subchip->regmap_power, reg_pm822, &reg_val);
+			break;
+		case 2:
+			regmap_read(chip->subchip->regmap_gpadc, reg_pm822, &reg_val);
+			break;
+		default:
+			pr_err("pg_index error!\n");
+			return 0;
+		}
+
+		len = sprintf(buf, "reg_pm822=0x%x, pg_index=0x%x, val=0x%x\n",
+			      reg_pm822, pg_index, reg_val);
+	}
+	return len;
+}
+
+static ssize_t pm822_proc_write(struct file *filp,
+				       const char *buff, size_t len,
+				       void *data)
+{
+	u8 reg_val;
+	struct pm822_chip *chip = data;
+
+	char messages[20], index[20];
+	memset(messages, '\0', 20);
+	memset(index, '\0', 20);
+
+	if (copy_from_user(messages, buff, len))
+		return -EFAULT;
+
+	if ('-' == messages[0]) {
+		if ((strlen(messages) != 10) &&
+		    (strlen(messages) != 9)) {
+			pr_err("Right format: -0x[page_addr] 0x[reg_addr]\n");
+			return len;
+		}
+		/* set the register index */
+		memcpy(index, messages + 1, 3);
+
+		if (kstrtoint(index, 16, &pg_index) < 0)
+			return -EINVAL;
+
+		pr_info("pg_index = 0x%x\n", pg_index);
+
+		memcpy(index, messages + 5, 4);
+		if (kstrtoint(index, 16, &reg_pm822) < 0)
+			return -EINVAL;
+		pr_info("reg_pm822 = 0x%x\n", reg_pm822);
+	} else if ('+' == messages[0]) {
+		/* enable to get all the reg value */
+		reg_pm822 = 0xffff;
+		pr_info("read all reg enabled!\n");
+	} else {
+		if ((reg_pm822 == 0xffff) ||
+		    ('0' != messages[0])) {
+			pr_err("Right format: -0x[page_addr] 0x[reg_addr]\n");
+			return len;
+		}
+		/* set the register value */
+		if (kstrtou8(messages, 16, &reg_val) < 0)
+			return -EINVAL;
+
+		switch (pg_index) {
+		case 0:
+			regmap_write(chip->regmap, reg_pm822, reg_val & 0xff);
+			break;
+		case 1:
+			regmap_write(chip->subchip->regmap_power, reg_pm822, reg_val & 0xff);
+			break;
+		case 2:
+			regmap_write(chip->subchip->regmap_gpadc, reg_pm822, reg_val & 0xff);
+			break;
+		default:
+			pr_err("pg_index error!\n");
+			break;
+
+		}
+	}
+
+	return len;
+}
+
+extern int get_dynamicbiasgpadc(int *tbat, int gpadc_bias, unsigned int channel)
+{
+	int ret = -1, adc_data, data;
+	unsigned char buf[2];
+	unsigned int bias_reg;
+
+	struct pm822_chip *chip = g_pm822_chip;
+
+	switch (channel) {
+	case PM822_GPADC0_MEAS1:
+		bias_reg = PM822_GPADC_BIAS1;
+		break;
+	case PM822_GPADC1_MEAS1:
+		bias_reg = PM822_GPADC_BIAS2;
+		break;
+	case PM822_GPADC2_MEAS1:
+		bias_reg = PM822_GPADC_BIAS3;
+		break;
+	case PM822_GPADC3_MEAS1:
+		bias_reg = PM822_GPADC_BIAS4;
+		break;
+	default:
+		dev_err(chip->dev, "not supported GPADC!\n");
+		return -EINVAL;
+	}
+
+	regmap_read(chip->subchip->regmap_gpadc,
+			bias_reg, &data);
+	data &= 0xF0;
+	data |= gpadc_bias;
+	regmap_write(chip->subchip->regmap_gpadc,
+			bias_reg, data);
+
+	/*
+	 * There is no way to measure the temperature of battery,
+	 * report the pmic temperature value
+	 */
+	ret = regmap_bulk_read(chip->subchip->regmap_gpadc,
+			       channel, buf, 2);
+	if (ret < 0) {
+		dev_err(chip->dev, "Attention: failed to get battery tbat!\n");
+		return -EINVAL;
+	}
+
+	adc_data = ((buf[0] & 0xff) << 4) | (buf[1] & 0x0f);
+	/* tbat = value * 1.4 *1000/(2^12) */
+	adc_data = ((adc_data & 0xfff) * 7 * 100) >> 11;
+	dev_info(chip->dev, "%s: adc_channel = 0x%x, adc_data value = 0x%x\n", __func__, channel, adc_data);
+	*tbat = adc_data;
+
+	return ret;
+}
+
+extern int pm822_read_gpadc(int *tbat, unsigned int channel)
+{
+	unsigned char buf[2];
+	int sum = 0, ret = -1;
+	struct pm822_chip *chip = g_pm822_chip;
+	*tbat = 0;
+	if (!chip) {
+		pr_err("%s: chip is NULL\n", __func__);
+		return -EINVAL;
+	}
+	ret = regmap_bulk_read(chip->subchip->regmap_gpadc, channel, buf, 2);
+	if (ret >= 0) {
+		sum = ((buf[0] & 0xFF) << 4) | (buf[1] & 0x0F);
+		sum = ((sum & 0xFFF) * 1400) >> 12;
+		*tbat = sum;
+	}
+	return ret;
+}
+
+/* return 1 if chip version is a0 */
+extern int is_pm822_a0(void)
+{
+	int ret = 0;
+	struct pm822_chip *chip = g_pm822_chip;
+	if (!chip) {
+		pr_err("%s: chip is NULL\n", __func__);
+		return -EINVAL;
+	}
+	if (chip->version==0x81) ret = 1;
+	return ret;
+}
+
+static int __devinit device_gpadc_init(struct pm822_chip *chip,
+				       struct pm822_platform_data *pdata)
+{
+	struct pm822_subchip *subchip = chip->subchip;
+	struct regmap *map = subchip->regmap_gpadc;
+	int data = 0, ret = 0;
+	unsigned char batt_gp_en, batt_gp_bias;
+	unsigned char batt_gp_bias_out, batt_gp_bias_en;
+
+	/* for GPADC used to measure the battery thermal sensor */
+	chip->batt_gp_nr = pdata->batt_gp_nr;
+
+	if (!map) {
+		dev_warn(chip->dev,
+			 "Warning: gpadc regmap is not available!\n");
+		return -EINVAL;
+	}
+	/*
+	 * set GPADC to be NON_STOP mode
+	 */
+	ret = regmap_read(chip->subchip->regmap_gpadc,
+			PM822_GPADC_MISC_CONFIG2, &data);
+	if (ret < 0)
+		return ret;
+
+	data |= PM822_GPADC_NON_STOP;
+
+	ret = regmap_write(chip->subchip->regmap_gpadc,
+				PM822_GPADC_MISC_CONFIG2, data);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * enable all GPADC base source
+	 * to support all platforms
+	 * 88pm820 A0 need this change
+	 */
+	ret = regmap_read(chip->regmap, 0x0, &data);
+
+	if (data == 0x81) {
+
+		data = 0xff;
+
+		ret = regmap_write(chip->subchip->regmap_gpadc,
+				PM822_GPADC_BIAS_EN1, data);
+		if (ret < 0)
+			return ret;
+
+	}
+
+	/*
+	 * enable GPADC to measure battery thermal sensor,
+	 * default bias current = 31uA
+	 */
+	switch (chip->batt_gp_nr) {
+	case PM822_GPADC0:
+		batt_gp_en = PM822_GPADC0_MEANS_EN;
+		batt_gp_bias = PM822_GPADC_BIAS1;
+		batt_gp_bias_en = PM822_GPADC_GP_BIAS_EN0;
+		batt_gp_bias_out = PM822_GPADC_GP_BIAS_OUT0;
+		break;
+	case PM822_GPADC1:
+		batt_gp_en = PM822_GPADC1_MEANS_EN;
+		batt_gp_bias = PM822_GPADC_BIAS2;
+		batt_gp_bias_en = PM822_GPADC_GP_BIAS_EN1;
+		batt_gp_bias_out = PM822_GPADC_GP_BIAS_OUT1;
+		break;
+	case PM822_GPADC2:
+		batt_gp_en = PM822_GPADC2_MEANS_EN;
+		batt_gp_bias = PM822_GPADC_BIAS3;
+		batt_gp_bias_en = PM822_GPADC_GP_BIAS_EN2;
+		batt_gp_bias_out = PM822_GPADC_GP_BIAS_OUT2;
+		break;
+	case PM822_GPADC3:
+		batt_gp_en = PM822_GPADC3_MEANS_EN;
+		batt_gp_bias = PM822_GPADC_BIAS4;
+		batt_gp_bias_en = PM822_GPADC_GP_BIAS_EN3;
+		batt_gp_bias_out = PM822_GPADC_GP_BIAS_OUT3;
+		break;
+	default:
+		dev_err(chip->dev, "GPADC init failed!\n");
+		return -EINVAL;
+	}
+
+	regmap_read(chip->subchip->regmap_gpadc,
+		    PM822_GPADC_MEAS_EN2, &data);
+	data |= batt_gp_en;
+	regmap_write(chip->subchip->regmap_gpadc,
+		     PM822_GPADC_MEAS_EN2, data);
+
+	regmap_read(chip->subchip->regmap_gpadc, batt_gp_bias, &data);
+	data |= 0x06; /* 31uA */
+	regmap_write(chip->subchip->regmap_gpadc, batt_gp_bias, data);
+
+	regmap_read(chip->subchip->regmap_gpadc,
+		    PM822_GPADC_BIAS_EN1, &data);
+	data |= (batt_gp_bias_en | batt_gp_bias_out);
+	regmap_write(chip->subchip->regmap_gpadc,
+		     PM822_GPADC_BIAS_EN1, data);
+
+	return 0;
+}
+
+static int __devinit device_regulator_init(struct pm822_chip *chip,
+				struct pm822_platform_data *pdata)
+{
+	struct regulator_init_data *initdata;
+	int ret = 0;
+	int i, seq;
+
+	if (!pdata || !pdata->regulator) {
+		dev_warn(chip->dev, "Regulator pdata is unavailable!\n");
+		return 0;
+	}
+
+	if (pdata->num_regulators > ARRAY_SIZE(regulator_devs))
+		pdata->num_regulators = ARRAY_SIZE(regulator_devs);
+
+	for (i = 0; i < pdata->num_regulators; i++) {
+		initdata = &pdata->regulator[i];
+		seq = *(unsigned int *)initdata->driver_data;
+		if ((seq < 0) || (seq > PM822_ID_RG_MAX)) {
+			dev_err(chip->dev, "Wrong ID(%d) on regulator(%s)\n",
+				seq, initdata->constraints.name);
+			ret = -EINVAL;
+			goto out_err;
+		}
+		memcpy(&regulator_pdata[i], &pdata->regulator[i],
+		       sizeof(struct regulator_init_data));
+		regulator_devs[i].platform_data = &regulator_pdata[i];
+		regulator_devs[i].pdata_size =
+		    sizeof(struct regulator_init_data);
+		regulator_devs[i].num_resources = 1;
+		regulator_devs[i].resources = &regulator_resources[seq];
+
+		ret = mfd_add_devices(chip->dev, 0, &regulator_devs[i], 1,
+				      &regulator_resources[seq], 0);
+		if (ret < 0) {
+			dev_err(chip->dev, "Failed to add regulator subdev\n");
+			goto out_err;
+		}
+	}
+	dev_info(chip->dev, "[%s]:Added mfd regulator_devs\n", __func__);
+	return 0;
+
+out_err:
+	return ret;
+}
+
+static int __devinit device_pm822_irq_init(struct pm822_chip *chip,
+					   struct pm822_platform_data *pdata)
+{
+	struct regmap *map = chip->regmap;
+	unsigned long flags = pdata->irq_flags;
+	struct irq_desc *desc;
+	int data, mask, ret = -EINVAL;
+
+	if (!map || !chip->irq) {
+		dev_err(chip->dev, "incorrect parameters\n");
+		return -EINVAL;
+	}
+
+	/* irq pin: low active
+	 * irq clear on write
+	 * irq status bit: not set when it is masked
+	 */
+	mask = PM822_INV_INT | PM822_INT_CLEAR_MODE | PM822_INT_MASK_MODE;
+	data = PM822_INT_CLEAR_MODE;
+	ret = regmap_update_bits(map, PM822_WAKEUP2, mask, data);
+	if (ret < 0)
+		goto out;
+
+	ret = regmap_add_irq_chip(chip->regmap, chip->irq, flags, -1,
+				chip->regmap_irq_chip, &chip->irq_data);
+
+	chip->irq_base = regmap_irq_chip_get_base(chip->irq_data);
+
+	desc = irq_to_desc(chip->irq);
+	irq_get_chip(chip->irq_base)->irq_set_wake =
+		desc->irq_data.chip->irq_set_wake;
+out:
+	return ret;
+}
+
+static void device_pm822_irq_exit(struct pm822_chip *chip)
+{
+	regmap_del_irq_chip(chip->irq, chip->irq_data);
+}
+
+static struct regmap_irq_chip pm822_irq_chip = {
+	.name = "88pm822",
+	.irqs = pm822_irqs,
+	.num_irqs = ARRAY_SIZE(pm822_irqs),
+
+	.num_regs = 3,
+	.status_base = PM822_INT_STATUS1,
+	.mask_base = PM822_INT_EN1,
+	.ack_base = PM822_INT_STATUS1,
+	.mask_invert = 1,
+};
+
+const struct regmap_config pm822_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+static int pm822_pages_init(struct pm822_chip *chip)
+{
+	struct pm822_subchip *subchip = chip->subchip;
+	struct i2c_client *client = chip->i2c;
+
+	if (subchip->power_page_addr) {
+		subchip->power_page =
+		    i2c_new_dummy(client->adapter, subchip->power_page_addr);
+		subchip->regmap_power =
+		    devm_regmap_init_i2c(subchip->power_page,
+					 &pm822_regmap_config);
+		i2c_set_clientdata(subchip->power_page, chip);
+	} else
+		dev_info(chip->dev,
+			 "PM822: No power_page_addr\n");
+
+	if (subchip->gpadc_page_addr) {
+		subchip->gpadc_page = i2c_new_dummy(client->adapter,
+						    subchip->gpadc_page_addr);
+		subchip->regmap_gpadc =
+		    devm_regmap_init_i2c(subchip->gpadc_page,
+					 &pm822_regmap_config);
+		i2c_set_clientdata(subchip->gpadc_page, chip);
+	} else
+		dev_info(chip->dev,
+			 "PM822: No gpadc_page_addr\n");
+
+	return 0;
+}
+
+static void pm822_pages_exit(struct pm822_chip *chip)
+{
+	struct pm822_subchip *subchip = chip->subchip;
+
+	if (subchip->power_page) {
+		regmap_exit(subchip->regmap_power);
+		i2c_unregister_device(subchip->power_page);
+	}
+	if (subchip->gpadc_page) {
+		regmap_exit(subchip->regmap_gpadc);
+		i2c_unregister_device(subchip->gpadc_page);
+	}
+	i2c_unregister_device(chip->i2c);
+}
+
+static int __devinit device_pm822_init(struct pm822_chip *chip,
+				     struct pm822_platform_data *pdata)
+{
+	int ret;
+	unsigned int val;
+
+	ret = regmap_read(chip->regmap, PM822_CHIP_ID, &val);
+	if (ret < 0) {
+		dev_err(chip->dev, "PM822: Failed to read CHIP ID: %d\n", ret);
+		goto out;
+	}
+	chip->version = val & 0xFF;
+	dev_info(chip->dev, "88PM822:Marvell 88PM822 (ID:0x%X) detected\n", val);
+
+#if defined(CONFIG_SEC_DEBUG)
+	/* read power on reason from PMIC general use register */
+	ret = regmap_read(chip->regmap, PMIC_GENERAL_USE_REGISTER, &val);
+	if (ret < 0) {
+		dev_err(chip->dev, "Failed to read PMIC_GENERAL_USE_REGISTER : %d\n", ret);
+		goto out;
+	}
+	printk("%s read register PMIC_GENERAL_USE_REGISTER [%d]\n", __func__, val);
+
+	/* read power on reason from PMIC general use register */
+	if (val != PMIC_GENERAL_USE_BOOT_BY_FULL_RESET)
+		regmap_write(chip->regmap, PMIC_GENERAL_USE_REGISTER, PMIC_GENERAL_USE_BOOT_BY_HW_RESET);
+
+	power_on_reason = (u8)val;
+#endif
+
+	/*
+	 * alarm wake up bit will be clear in device_irq_init(),
+	 * read before that
+	 */
+	ret = regmap_read(chip->regmap, PM822_RTC_CTRL, &val);
+	if (ret < 0) {
+		dev_err(chip->dev, "Failed to read RTC register: %d\n", ret);
+		goto out;
+	}
+	if (val & PM822_ALARM_WAKEUP) {
+		if (pdata && pdata->rtc)
+			pdata->rtc->rtc_wakeup = 1;
+	}
+
+	ret = device_gpadc_init(chip, pdata);
+	if (ret < 0) {
+		dev_err(chip->dev, "[%s]Failed to init gpadc\n", __func__);
+		goto out;
+	}
+
+	chip->regmap_irq_chip = &pm822_irq_chip;
+
+	ret = device_pm822_irq_init(chip, pdata);
+	if (ret < 0) {
+		dev_err(chip->dev, "[%s]Failed to init pm822 irq\n", __func__);
+		goto out;
+	}
+
+	if (device_regulator_init(chip, pdata)) {
+		dev_err(chip->dev, "Failed to init regulators\n");
+		goto out_dev;
+	}
+
+	ret =
+	    mfd_add_devices(chip->dev, 0, &onkey_devs[0],
+			    ARRAY_SIZE(onkey_devs), &onkey_resources[0], 0);
+	if (ret < 0) {
+		dev_err(chip->dev, "Failed to add onkey subdev\n");
+		goto out_dev;
+	} else
+		dev_info(chip->dev, "[%s]:Added mfd onkey_devs\n", __func__);
+
+#if defined(CONFIG_FUELGAUGE_88PM822)
+#if defined(CONFIG_BATTERY_SAMSUNG)
+	if (pdata && pdata->fuelgauge_data) {
+		bat_devs[0].platform_data = pdata->fuelgauge_data;
+		bat_devs[0].pdata_size = sizeof(struct sec_battery_platform_data);
+#else
+	if (pdata && pdata->bat) {
+		bat_devs[0].platform_data = pdata->bat;
+		bat_devs[0].pdata_size = sizeof(struct pm80x_bat_pdata);
+#endif
+		ret = mfd_add_devices(chip->dev, 0, &bat_devs[0],
+				      ARRAY_SIZE(bat_devs), NULL, 0);
+		if (ret < 0) {
+			dev_err(chip->dev, "Failed to add bat subdev\n");
+			goto out_dev;
+		} else
+			dev_info(chip->dev,
+				"[%s]:Added mfd bat_devs\n", __func__);
+	}
+#endif
+
+	/* FIXME battery */
+	if (pdata && pdata->vibrator) {
+		vibrator_devs[0].platform_data = pdata->vibrator;
+		vibrator_devs[0].pdata_size =
+					sizeof(struct pm822_vibrator_pdata);
+		ret = mfd_add_devices(chip->dev, 0, &vibrator_devs[0],
+			ARRAY_SIZE(vibrator_devs), NULL, 0);
+		if (ret < 0) {
+			dev_err(chip->dev, "Failed to add vibrator subdev\n");
+			goto out_dev;
+		} else
+			dev_info(chip->dev,
+				"[%s]:Added mfd vibrator_devs\n", __func__);
+	}
+
+	if (pdata && pdata->rtc) {
+		rtc_devs[0].platform_data = pdata->rtc;
+		rtc_devs[0].pdata_size = sizeof(struct pm822_rtc_pdata);
+		ret = mfd_add_devices(chip->dev, 0, &rtc_devs[0],
+				      ARRAY_SIZE(rtc_devs), NULL, 0);
+		if (ret < 0) {
+			dev_err(chip->dev, "Failed to add rtc subdev\n");
+			goto out_dev;
+		} else
+			dev_info(chip->dev,
+				 "[%s]:Added mfd rtc_devs\n", __func__);
+	}
+
+#if defined(CONFIG_CPU_PXA1L88) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	if (pdata && pdata->dvc) {
+		dvc_devs[0].platform_data = pdata->dvc;
+		dvc_devs[0].pdata_size = sizeof(struct pm822_dvc_pdata);
+		ret = mfd_add_devices(chip->dev, 0, &dvc_devs[0],
+					ARRAY_SIZE(dvc_devs), NULL, 0);
+		if (ret < 0) {
+			dev_err(chip->dev, "Failed to add dvc subdev\n");
+			goto out_dev;
+		} else
+			dev_info(chip->dev,
+				"[%s]:Added mfd dvc_devs\n", __func__);
+	}
+#endif
+
+	ret = mfd_add_devices(chip->dev, 0, &headset_devs_822[0],
+			ARRAY_SIZE(headset_devs_822),
+			&headset_resources_822[0], 0);
+	if (ret < 0) {
+		dev_err(chip->dev, "Failed to add headset subdev\n");
+		goto out_dev;
+	} else
+		dev_info(chip->dev, "[%s]:Added mfd headset_devs\n", __func__);
+
+	/* FIXME usb */
+	if (pdata && pdata->usb) {
+		usb_devs[0].platform_data = pdata->usb;
+		usb_devs[0].pdata_size = sizeof(struct pm822_usb_pdata);
+		ret = mfd_add_devices(chip->dev, 0, &usb_devs[0],
+				      ARRAY_SIZE(usb_devs), NULL, 0);
+		if (ret < 0) {
+			dev_err(chip->dev, "Failed to add usb subdev\n");
+			goto out_dev;
+		} else
+			dev_info(chip->dev,
+				 "[%s]:Added mfd usb_devs\n", __func__);
+	}
+
+	if (chip->proc_file == NULL) {
+		chip->proc_file =
+			create_proc_entry(PM822_PROC_FILE, 0644, NULL);
+		if (chip->proc_file) {
+			chip->proc_file->read_proc = pm822_proc_read;
+			chip->proc_file->write_proc = (write_proc_t  *)pm822_proc_write;
+			chip->proc_file->data = chip;
+		} else
+			pr_info("pm822 proc file create failed!\n");
+	}
+
+	return 0;
+out_dev:
+	mfd_remove_devices(chip->dev);
+	device_pm822_irq_exit(chip);
+out:
+	return ret;
+}
+
+static int __devinit pm822_probe(struct i2c_client *client,
+				 const struct i2c_device_id *id)
+{
+	int ret = 0;
+	struct pm822_chip *chip;
+	struct regmap *map;
+	struct pm822_subchip *subchip;
+	struct pm822_platform_data *pdata = client->dev.platform_data;
+	if (!pdata) {
+		ret = -EINVAL;
+		goto out_init;
+	}
+
+	chip = devm_kzalloc(&client->dev, sizeof(struct pm822_chip), GFP_KERNEL);
+	if (!chip) {
+		ret = -ENOMEM;
+		goto out_init;
+	}
+
+	map = devm_regmap_init_i2c(client, &pm822_regmap_config);
+	if (IS_ERR(map)) {
+		ret = PTR_ERR(map);
+		dev_err(&client->dev, "Failed to allocate register map: %d\n", ret);
+		goto err_free_chip;
+	}
+
+	chip->i2c = client;
+	chip->regmap = map;
+	chip->irq = client->irq;
+	chip->dev = &client->dev;
+	dev_set_drvdata(chip->dev, chip);
+	i2c_set_clientdata(chip->i2c, chip);
+	/* export a interface for pm805 to operate the classD */
+	pm822_client = client;
+
+	device_init_wakeup(&client->dev, 1);
+
+	subchip = devm_kzalloc(&client->dev, sizeof(struct pm822_subchip), GFP_KERNEL);
+	if (!subchip) {
+		ret = -ENOMEM;
+		goto err_free_chip;
+	}
+
+	subchip->power_page_addr = pdata->power_page_addr;
+	subchip->gpadc_page_addr = pdata->gpadc_page_addr;
+	chip->subchip = subchip;
+
+	ret = pm822_pages_init(chip);
+	if (ret) {
+		dev_err(&client->dev, "pm822_pages_init failed!\n");
+		goto err_free_subchip;
+	}
+
+	ret = device_pm822_init(chip, pdata);
+	if (ret) {
+		dev_err(chip->dev, "%s failed!\n", __func__);
+		goto err_exit_page;
+	}
+
+	if (pdata->plat_config)
+		pdata->plat_config(chip, pdata);
+
+	if (!g_pm822_chip)
+		g_pm822_chip = chip;
+
+	return 0;
+
+err_exit_page:
+	pm822_pages_exit(chip);
+err_free_subchip:
+	devm_kfree(&client->dev, subchip);
+err_free_chip:
+	devm_kfree(&client->dev, chip);
+out_init:
+	return ret;
+}
+
+static int __devexit pm822_remove(struct i2c_client *client)
+{
+	struct pm822_chip *chip = i2c_get_clientdata(client);
+
+	g_pm822_chip = NULL;
+	mfd_remove_devices(chip->dev);
+	device_pm822_irq_exit(chip);
+
+	pm822_pages_exit(chip);
+	remove_proc_entry(PM822_PROC_FILE, NULL);
+	devm_kfree(&client->dev, chip->subchip);
+	devm_kfree(&client->dev, chip);
+
+	return 0;
+}
+
+int pm822_extern_read(int page, int reg)
+{
+	int ret;
+	unsigned int val;
+	struct pm822_chip *chip = g_pm822_chip;
+	if (!chip) {
+		pr_err("%s: chip is NULL\n", __func__);
+		return -EINVAL;
+	}
+	switch (page) {
+	case PM822_BASE_PAGE:
+		ret = regmap_read(chip->regmap, reg, &val);
+		break;
+	case PM822_POWER_PAGE:
+		ret = regmap_read(chip->subchip->regmap_power,
+				  reg, &val);
+		break;
+	case PM822_GPADC_PAGE:
+		ret = regmap_read(chip->subchip->regmap_gpadc,
+				  reg, &val);
+		break;
+	default:
+		ret = -1;
+		break;
+	}
+
+	if (ret < 0) {
+		pr_err("fail to read page: %d, reg: 0x%x - %d\n", page, reg, ret);
+		return ret;
+	}
+
+	return val;
+}
+EXPORT_SYMBOL(pm822_extern_read);
+
+int pm822_extern_write(int page, int reg, unsigned char val)
+{
+	int ret;
+	struct pm822_chip *chip = g_pm822_chip;
+	if (!chip) {
+		pr_err("%s: chip is NULL\n", __func__);
+		return -EINVAL;
+	}
+	switch (page) {
+	case PM822_BASE_PAGE:
+		ret = regmap_write(chip->regmap, reg, val);
+		break;
+	case PM822_POWER_PAGE:
+		ret = regmap_write(chip->subchip->regmap_power,
+				  reg, val);
+		break;
+	case PM822_GPADC_PAGE:
+		ret = regmap_write(chip->subchip->regmap_gpadc,
+				  reg, val);
+		break;
+	default:
+		ret = -1;
+		break;
+	}
+
+	if (ret < 0) {
+		pr_err("fail to write page: %d, reg: 0x%x - %d\n", page, reg, ret);
+		return ret;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(pm822_extern_write);
+
+int pm822_extern_setbits(int page, int reg,
+			 unsigned char mask, unsigned char val)
+{
+	int ret;
+	struct pm822_chip *chip = g_pm822_chip;
+	if (!chip) {
+		pr_err("%s: chip is NULL\n", __func__);
+		return -EINVAL;
+	}
+	switch (page) {
+	case PM822_BASE_PAGE:
+		ret = regmap_update_bits(chip->regmap, reg, mask, val);
+		break;
+	case PM822_POWER_PAGE:
+		ret = regmap_update_bits(chip->subchip->regmap_power,
+					 reg, mask, val);
+		break;
+	case PM822_GPADC_PAGE:
+		ret = regmap_update_bits(chip->subchip->regmap_gpadc,
+					 reg, mask, val);
+		break;
+	default:
+		ret = -1;
+		break;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(pm822_extern_setbits);
+
+#ifdef CONFIG_PM
+static int pm822_suspend(struct device *dev)
+{
+	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+	struct pm822_chip *chip = i2c_get_clientdata(client);
+	int i, tmp = chip->wu_flag;
+
+	if (chip && tmp &&
+	    device_may_wakeup(chip->dev)) {
+		enable_irq_wake(chip->irq);
+
+		for (i = 0; i < 32; i++) {
+			if (tmp & (1 << i))
+				enable_irq_wake(chip->irq_base + i);
+		}
+	}
+
+	return 0;
+}
+
+static int pm822_resume(struct device *dev)
+{
+	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+	struct pm822_chip *chip = i2c_get_clientdata(client);
+	int i, tmp = chip->wu_flag;
+
+	if (chip && tmp &&
+	    device_may_wakeup(chip->dev)) {
+		disable_irq_wake(chip->irq);
+
+		for (i = 0; i < 32; i++) {
+			if (tmp & (1 << i))
+				disable_irq_wake(chip->irq_base + i);
+		}
+	}
+
+	return 0;
+}
+
+SIMPLE_DEV_PM_OPS(pm822_pm_ops, pm822_suspend, pm822_resume);
+
+#endif
+
+static struct i2c_driver pm822_driver = {
+	.driver = {
+		.name = "88PM822",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm = &pm822_pm_ops,
+#endif
+		},
+	.probe = pm822_probe,
+	.remove = __devexit_p(pm822_remove),
+	.id_table = pm822_id_table,
+};
+
+static int __init pm822_i2c_init(void)
+{
+	return i2c_add_driver(&pm822_driver);
+}
+subsys_initcall(pm822_i2c_init);
+
+static void __exit pm822_i2c_exit(void)
+{
+	i2c_del_driver(&pm822_driver);
+}
+module_exit(pm822_i2c_exit);
+
+MODULE_DESCRIPTION("PMIC Driver for Marvell 88PM822");
+MODULE_AUTHOR("Yipeng Yao <ypyao@marvell.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 11e44386..6fce01bd 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -9,6 +9,30 @@ config MFD_CORE
 	tristate
 	default n
 
+config MFD_D2199
+	tristate "Dialog D2199 Multifunction DEvice"
+	select I2C
+	select MFD_CORE
+	select RTC_CLASS
+	select REGULATOR
+	select MISC_DEVICES
+	select INPUT_MISC
+	select INPUT_D2199_ONKEY
+	select REGULATOR_D2199
+	select RTC_DRV_D2199
+	select MFD_D2199_BRINGUP_RECHECK
+	select D2199_DVC
+	help
+	  This supports the Dialog D2199 Multifunction Device
+
+config MFD_D2199_BRINGUP_RECHECK
+	tristate "BringUp recheck"
+	depends on MFD_D2199
+
+config D2199_DVC
+	tristate "D2199 DVC"
+	depends on MFD_D2199
+	
 config MFD_88PM860X
 	bool "Support Marvell 88PM8606/88PM8607"
 	depends on I2C=y && GENERIC_HARDIRQS
@@ -20,6 +44,54 @@ config MFD_88PM860X
 	  select individual components like voltage regulators, RTC and
 	  battery-charger under the corresponding menus.
 
+config MFD_88PM830
+	tristate "Support Marvell 88PM830"
+	depends on I2C=y && GENERIC_HARDIRQS
+	select REGMAP_I2C
+	select REGMAP_IRQ
+	select MFD_CORE
+	help
+	  This supports for Marvell 88PM830 Power Management IC.
+	  This includes the I2C driver and the core APIs _only_,
+	  you have to select individual components like  battery-charger
+	  under the corresponding menus.
+
+config MFD_88PM800
+	tristate "Support Marvell 88PM800"
+	depends on I2C=y && GENERIC_HARDIRQS
+	select REGMAP_I2C
+	select REGMAP_IRQ
+	select MFD_CORE
+	help
+	  This supports for Marvell 88PM800 Power Management IC.
+	  This includes the I2C driver and the core APIs _only_, you have to
+	  select individual components like voltage regulators, RTC and
+	  battery-charger under the corresponding menus.
+
+config MFD_88PM805
+	tristate "Support Marvell 88PM805"
+	depends on I2C=y && GENERIC_HARDIRQS
+	select REGMAP_I2C
+	select REGMAP_IRQ
+	select MFD_CORE
+	help
+	  This supports for Marvell 88PM805 Power Management IC. This includes
+	  the I2C driver and the core APIs _only_, you have to select individual
+	  components like codec device, headset/Mic device under the
+	  corresponding menus.
+
+config MFD_88PM822
+	tristate "Support Marvell 88PM822"
+	depends on I2C=y && GENERIC_HARDIRQS
+	select REGMAP_I2C
+	select REGMAP_IRQ
+	select MFD_CORE
+	help
+	  This supports for Marvell 88PM822 Power Management IC.
+	  This includes the I2C driver and the core APIs _only_, you have to
+	  select individual components like voltage regulators, RTC and
+	  battery-charger under the corresponding menus.
+
 config MFD_SM501
 	tristate "Support for Silicon Motion SM501"
 	 ---help---
@@ -95,6 +167,15 @@ config HTC_I2CPLD
 	  This device provides input and output GPIOs through an I2C
 	  interface to one or more sub-chips.
 
+config PXA_DS1WM
+	tristate "PXA_DS1WM chip support"
+	select MFD_CORE
+	help
+	  This supports for w1 master controller of Marvell PXA9XX processor
+	  IC. The core driver provides register access for PXA_DS1WM, Actual
+	  functionality is handled by the ds1wm drivers, so if activate w1
+	  master ,it also enable ds1wm simutaneously.
+
 config UCB1400_CORE
 	tristate "Philips UCB1400 Core driver"
 	depends on AC97_BUS
@@ -303,6 +384,19 @@ config MFD_STMPE
 		Keypad: stmpe-keypad
 		Touchscreen: stmpe-ts
 
+config MFD_RT8973
+	tristate "Richtek RT8973 MUIC"
+	depends on I2C
+	default n
+	help
+	  Support RT8973 MUIC
+
+config RTMUSC_INT_GPIO_NUMBER
+	int "Used GPIO number"
+	default "93"
+	---help---
+	Decimal number (See schematic of mainboard and SoC datasheet)
+
 menu "STMPE Interface Drivers"
 depends on MFD_STMPE
 
@@ -891,6 +985,25 @@ config MFD_ANATOP
 endmenu
 endif
 
+config MFD_STBC
+        tristate "Support for STMirco I/F PMIC"
+	depends on I2C
+	select MFD_CORE
+	default n
+	help
+	  If you say yes to this option, support will be included for the
+	  STM I/F PMIC chip.
+
+
+config MFD_RT5033
+        tristate "Support for Richtek RT5033 I/F PMIC"
+	depends on I2C
+	select MFD_CORE
+	default n
+	help
+	  If you say yes to this option, support will be included for the
+	  RT5033 I/F PMIC chip.
+
 menu "Multimedia Capabilities Port drivers"
 	depends on ARCH_SA1100
 
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 05fa538c..461271c7 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -4,6 +4,13 @@
 
 88pm860x-objs			:= 88pm860x-core.o 88pm860x-i2c.o
 obj-$(CONFIG_MFD_88PM860X)	+= 88pm860x.o
+obj-$(CONFIG_MFD_88PM830)	+= 88pm830.o
+obj-$(CONFIG_MFD_88PM800)	+= 88pm800.o 88pm80x.o
+obj-$(CONFIG_MFD_88PM805)	+= 88pm805.o 88pm80x.o
+obj-$(CONFIG_MFD_88PM822)	+= 88pm822.o
+ifeq ($(CONFIG_SEC_PM_DEBUG),y)
+obj-$(CONFIG_MFD_88PM822)	+= 88pm822-dbg.o
+endif
 obj-$(CONFIG_MFD_SM501)		+= sm501.o
 obj-$(CONFIG_MFD_ASIC3)		+= asic3.o tmio_core.o
 
@@ -11,10 +18,17 @@ obj-$(CONFIG_HTC_EGPIO)		+= htc-egpio.o
 obj-$(CONFIG_HTC_PASIC3)	+= htc-pasic3.o
 obj-$(CONFIG_HTC_I2CPLD)	+= htc-i2cpld.o
 
+obj-$(CONFIG_PXA_DS1WM)		+= pxa-w1.o
+
 obj-$(CONFIG_MFD_DAVINCI_VOICECODEC)	+= davinci_voicecodec.o
 obj-$(CONFIG_MFD_DM355EVM_MSP)	+= dm355evm_msp.o
 obj-$(CONFIG_MFD_TI_SSP)	+= ti-ssp.o
 
+obj-$(CONFIG_MFD_D2199)		+= d2199-core.o d2199-i2c.o d2199-irq.o
+ifeq ($(CONFIG_SEC_PM_DEBUG),y)
+obj-$(CONFIG_MFD_D2199)		+= d2199-dbg.o
+endif
+
 obj-$(CONFIG_MFD_STMPE)		+= stmpe.o
 obj-$(CONFIG_STMPE_I2C)		+= stmpe-i2c.o
 obj-$(CONFIG_STMPE_SPI)		+= stmpe-spi.o
@@ -116,3 +130,6 @@ obj-$(CONFIG_MFD_INTEL_MSIC)	+= intel_msic.o
 obj-$(CONFIG_MFD_RC5T583)	+= rc5t583.o rc5t583-irq.o
 obj-$(CONFIG_MFD_S5M_CORE)	+= s5m-core.o s5m-irq.o
 obj-$(CONFIG_MFD_ANATOP)	+= anatop-mfd.o
+obj-$(CONFIG_MFD_RT8973)	+= rt8973.o
+obj-$(CONFIG_MFD_RT5033) += rt5033_core.o rt5033_irq.o
+obj-$(CONFIG_MFD_STBC) += sec_stbc.o
\ No newline at end of file
diff --git a/drivers/mfd/rt8973.c b/drivers/mfd/rt8973.c
new file mode 100644
index 00000000..ffcecae7
--- /dev/null
+++ b/drivers/mfd/rt8973.c
@@ -0,0 +1,1365 @@
+/* drivers/mfd/rt8973.c
+ * Richtek RT8973 Multifunction Device / MUIC Driver
+ *
+ * Copyright (C) 2013
+ * Author: Patrick Chang <patrick_chang@richtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/rtdefs.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/wakelock.h>
+#include <linux/pm_wakeup.h>
+#include <plat/pm.h>
+#include <linux/delay.h>
+#include <linux/mfd/rt8973.h>
+#ifdef SAMSUNG_MVRL_MUIC_RT8973
+#include <linux/gpio-pxa.h>
+#include <linux/platform_data/mv_usb.h>
+#include <mach/gpio-edge.h>
+#endif
+
+#define RT8973_DEVICE_NAME "rt8973"
+#define ALIAS_NAME RT8973_DEVICE_NAME
+#define RT8973_DRV_VER "2.0.7_SEC_M"
+#define RT8973_IRQF_MODE IRQF_TRIGGER_FALLING
+
+#define RT8973_REG_CHIP_ID          0x01
+#define RT8973_REG_CONTROL          0x02
+#define RT8973_REG_INT_FLAG1        0x03
+#define RT8973_REG_INT_FLAG2        0x04
+#define RT8973_REG_INTERRUPT_MASK1  0x05
+#define RT8973_REG_INTERRUPT_MASK2  0x06
+#define RT8973_REG_ADC              0x07
+#define RT8973_REG_DEVICE1          0x0A
+#define RT8973_REG_DEVICE2          0x0B
+#define RT8973_REG_MANUAL_SW1       0x13
+#define RT8973_REG_MANUAL_SW2       0x14
+#define RT8973_REG_RESET            0x1B
+
+#define DCD_T_RETRY 2
+
+#define RT8973_DEVICE1_OTG  0x01
+#define RT8973_DEVICE1_SDP  0x04
+#define RT8973_DEVICE1_UART 0x08
+#define RT8973_DEVICE1_CDPORT   0x20
+#define RT8973_DEVICE1_DCPORT   0x40
+
+#ifdef SAMSUNG_MVRL_MUIC_RT8973
+static struct gpio_edge_desc muic_int_gpio;
+static struct wakeup_source jig_suspend_wake;
+static int jig_wakelock_acq;
+#endif
+
+static irqreturn_t rt8973_irq_handler(int irq, void *data);
+
+struct device_desc {
+	char *name;
+	uint32_t reg_val;
+	int cable_type;
+};
+
+static const struct device_desc device_to_cable_type_mapping[] = {
+	{
+	 .name = "OTG",
+	 .reg_val = RT8973_DEVICE1_OTG,
+	 .cable_type = MUIC_RT8973_CABLE_TYPE_OTG,
+	 },
+	{
+	 .name = "USB SDP",
+	 .reg_val = RT8973_DEVICE1_SDP,
+	 .cable_type = MUIC_RT8973_CABLE_TYPE_USB,
+	 },
+	{
+	 .name = "UART",
+	 .reg_val = RT8973_DEVICE1_UART,
+	 .cable_type = MUIC_RT8973_CABLE_TYPE_UART,
+	 },
+	{
+	 .name = "USB CDP",
+	 .reg_val = RT8973_DEVICE1_CDPORT,
+	 .cable_type = MUIC_RT8973_CABLE_TYPE_CDP,
+	 },
+	{
+	 .name = "USB DCP",
+	 .reg_val = RT8973_DEVICE1_DCPORT,
+	 .cable_type = MUIC_RT8973_CABLE_TYPE_REGULAR_TA,
+	 },
+};
+
+struct id_desc {
+	char *name;
+	int cable_type_with_vbus;
+	int cable_type_without_vbus;
+};
+
+static const struct id_desc id_to_cable_type_mapping[] = {
+	{
+	 /* 00000, 0 */
+	 .name = "OTG",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_OTG,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_OTG,
+	 },
+	{			/* 00001, 1 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 00010, 2 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 00011, 3 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 00100, 4 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 00101, 5 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 00110, 6 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 00111, 7 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 01000, 8 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 01001, 9 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 01010, 10 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 01011, 11 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 01100, 12 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 01101, 13 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 01110, 14 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 01111, 15 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 10000, 16 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 10001, 17 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 10010, 18 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 10011, 19 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 10100, 20 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 10101, 21 */
+	 .name = "ADC0x15 Charger/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_0x15,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 10110, 22 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 10111, 23 */
+	 .name = "Type 1 Charger/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_TYPE1_CHARGER,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 11000, 24 */
+	 .name = "FM BOOT OFF USB/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_JIG_USB_OFF,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 11001, 25 */
+	 .name = "FM BOOT ON USB/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_JIG_USB_ON,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 11010, 26 */
+	 .name = "DESK DOCK VBUS/DESK DOCK",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_0x1A_VBUS,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_0x1A,
+	 },
+	{			/* 11011, 27 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 11100, 28 */
+	 .name = "JIG UART BOOT OFF",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF_WITH_VBUS,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF,
+	 },
+	{			/* 11101, 29 */
+	 .name = "JIG UART BOOT ON",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_JIG_UART_ON_WITH_VBUS,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_JIG_UART_ON,
+	 },
+	{			/* 11110, 30 */
+	 .name = "AT&T TA/Unknown",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	 },
+	{			/* 11111, 31 */
+	 .name = "AT&T TA/No cable",
+	 .cable_type_with_vbus = MUIC_RT8973_CABLE_TYPE_ATT_TA,
+	 .cable_type_without_vbus = MUIC_RT8973_CABLE_TYPE_NONE,
+	 },
+};
+
+enum {
+	VBUS_SHIFT = 0,
+	ACCESSORY_SHIFT,
+	OCP_SHIFT,
+	OVP_SHIFT,
+	OTP_SHIFT,
+	ADC_CHG_SHIFT,
+	CABLE_CHG_SHIFT,
+	OTG_SHIFT,
+	DCDT_SHIFT,
+	USB_SHIFT,
+	UART_SHIFT,
+	JIG_SHIFT,
+	L_USB_SHIFT,
+};
+
+struct rt8973_status {
+	int cable_type;
+	int id_adc;
+	uint8_t irq_flags[2];
+	uint8_t device_reg[2];
+	/* Processed useful status
+	 * Compare previous and current regs
+	 * to get this information */
+	union {
+		struct {
+			uint32_t vbus_status:1;
+			uint32_t accessory_status:1;
+			uint32_t ocp_status:1;
+			uint32_t ovp_status:1;
+			uint32_t otp_status:1;
+			uint32_t adc_chg_status:1;
+			uint32_t cable_chg_status:1;
+			uint32_t otg_status:1;
+			uint32_t dcdt_status:1;
+			uint32_t usb_connect:1;
+			uint32_t uart_connect:1;
+			uint32_t jig_connect:1;
+			uint32_t l_usb_connect:1;
+		};
+		uint32_t status;
+	};
+};
+
+typedef struct rt8973_chip {
+	struct i2c_client *iic;
+	struct mutex io_lock;
+	struct rt8973_platform_data *pdata;
+	struct device *dev;
+#ifdef SAMSUNG_MVRL_MUIC_RT8973
+	struct device *switch_dev;
+#endif
+	struct workqueue_struct *wq;
+	struct delayed_work irq_work;
+	struct wake_lock muic_wake_lock;
+	struct rt8973_status prev_status;
+	struct rt8973_status curr_status;
+	int dcdt_retry_count;
+	int irq;
+	struct pm_qos_request qos_idle;
+} rt8973_chip_t;
+
+#ifdef SAMSUNG_MVRL_MUIC_RT8973
+static struct rt8973_status *current_status;
+static struct pm_qos_request *qos_idle;
+#endif
+
+static int32_t rt8973_read(struct rt8973_chip *chip, uint8_t reg,
+			   uint8_t nbytes, uint8_t *buff)
+{
+	int ret;
+	mutex_lock(&chip->io_lock);
+	ret = i2c_smbus_read_i2c_block_data(chip->iic, reg, nbytes, buff);
+	mutex_unlock(&chip->io_lock);
+	return ret;
+}
+
+static int32_t rt8973_reg_read(struct rt8973_chip *chip, int reg)
+{
+	int ret;
+	mutex_lock(&chip->io_lock);
+	ret = i2c_smbus_read_byte_data(chip->iic, reg);
+	mutex_unlock(&chip->io_lock);
+	return ret;
+}
+
+int32_t rt8973_reg_write(struct rt8973_chip *chip, int reg, unsigned char data)
+{
+	int ret;
+	mutex_lock(&chip->io_lock);
+	ret = i2c_smbus_write_byte_data(chip->iic, reg, data);
+	mutex_unlock(&chip->io_lock);
+	return ret;
+}
+
+static int32_t rt8973_assign_bits(struct rt8973_chip *chip, int reg,
+				  unsigned char mask, unsigned char data)
+{
+	struct i2c_client *iic;
+	int ret;
+	iic = chip->iic;
+	mutex_lock(&chip->io_lock);
+	ret = i2c_smbus_read_byte_data(iic, reg);
+	if (ret < 0)
+		goto out;
+	ret &= ~mask;
+	ret |= data;
+	ret = i2c_smbus_write_byte_data(iic, reg, ret);
+out:
+	mutex_unlock(&chip->io_lock);
+	return ret;
+}
+
+int32_t rt8973_set_bits(struct rt8973_chip *chip, int reg, unsigned char mask)
+{
+	return rt8973_assign_bits(chip, reg, mask, mask);
+}
+
+int32_t rt8973_clr_bits(struct rt8973_chip *chip, int reg, unsigned char mask)
+{
+	return rt8973_assign_bits(chip, reg, mask, 0);
+}
+
+static inline int rt8973_update_regs(rt8973_chip_t *chip)
+{
+	int ret;
+	ret = rt8973_read(chip, RT8973_REG_INT_FLAG1,
+			  2, chip->curr_status.irq_flags);
+	if (ret < 0)
+		return ret;
+	ret = rt8973_read(chip, RT8973_REG_DEVICE1,
+			  2, chip->curr_status.device_reg);
+	if (ret < 0)
+		return ret;
+	ret = rt8973_reg_read(chip, RT8973_REG_ADC);
+	if (ret < 0)
+		return ret;
+	chip->curr_status.id_adc = ret;
+	/* invalid id value */
+	if (ret >= ARRAY_SIZE(id_to_cable_type_mapping))
+		return -EINVAL;
+	return 0;
+}
+
+static int rt8973_get_cable_type_by_device_reg(rt8973_chip_t *chip)
+{
+	uint32_t device_reg = chip->curr_status.device_reg[1];
+	int i;
+	RTINFO("Device = 0x%x, 0x%x\n",
+	       (int)chip->curr_status.device_reg[0],
+	       (int)chip->curr_status.device_reg[1]);
+	device_reg <<= 8;
+	device_reg |= chip->curr_status.device_reg[0];
+	for (i = 0; i < ARRAY_SIZE(device_to_cable_type_mapping); i++) {
+		if (device_to_cable_type_mapping[i].reg_val == device_reg)
+			return device_to_cable_type_mapping[i].cable_type;
+	}
+	/* not found */
+	return -EINVAL;
+}
+
+static int rt8973_get_cable_type_by_id(rt8973_chip_t *chip)
+{
+	int id_val = chip->curr_status.id_adc;
+	int cable_type;
+	RTINFO("ID value = 0x%x\n", id_val);
+	if (chip->curr_status.vbus_status)
+		cable_type = id_to_cable_type_mapping[id_val].
+			cable_type_with_vbus;
+	else
+		cable_type = id_to_cable_type_mapping[id_val].
+			cable_type_without_vbus;
+	/* Special case for L ID219K USB cable */
+	if (cable_type == MUIC_RT8973_CABLE_TYPE_TYPE1_CHARGER) {
+		/* ID = 200KOhm, VBUS = 1, DCD_T = 0 and CHGDET = 0 ==> L SDP*/
+		if ((chip->curr_status.irq_flags[0]&0x0C) == 0)
+			cable_type = MUIC_RT8973_CABLE_TYPE_L_SPEC_USB;
+	}
+	return cable_type;
+}
+
+static int rt8973_get_cable_type(rt8973_chip_t *chip)
+{
+	int ret;
+	ret = rt8973_get_cable_type_by_device_reg(chip);
+	if (ret >= 0)
+		return ret;
+	else
+		return rt8973_get_cable_type_by_id(chip);
+}
+
+static void rt8973_preprocess_status(rt8973_chip_t *chip)
+{
+	chip->curr_status.vbus_status =
+	    (chip->curr_status.irq_flags[1] & 0x02) ? 0 : 1;
+	chip->curr_status.cable_type = rt8973_get_cable_type(chip);
+	chip->curr_status.ocp_status =
+	    (chip->curr_status.irq_flags[1] & 0x20) ? 1 : 0;
+	chip->curr_status.ovp_status =
+	    (chip->curr_status.irq_flags[1] & 0x10) ? 1 : 0;
+	chip->curr_status.otp_status =
+	    (chip->curr_status.irq_flags[1] & 0x08) ? 1 : 0;
+	chip->curr_status.adc_chg_status =
+	    (chip->prev_status.id_adc != chip->curr_status.id_adc) ? 1 : 0;
+	chip->curr_status.otg_status =
+	    (chip->curr_status.cable_type ==
+	     MUIC_RT8973_CABLE_TYPE_OTG) ? 1 : 0;
+	chip->curr_status.accessory_status =
+	    ((chip->curr_status.cable_type !=
+	      MUIC_RT8973_CABLE_TYPE_NONE) &&
+	     (chip->curr_status.cable_type !=
+	      MUIC_RT8973_CABLE_TYPE_UNKNOWN)) ? 1 : 0;
+	chip->curr_status.cable_chg_status =
+	    (chip->curr_status.cable_type !=
+	     chip->prev_status.cable_type) ? 1 : 0;
+	chip->curr_status.dcdt_status =
+	    (chip->curr_status.irq_flags[0] & 0x08) ? 1 : 0;
+	chip->curr_status.usb_connect =
+	    ((chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_USB) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_CDP) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_JIG_USB_OFF) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_L_SPEC_USB) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_JIG_USB_ON)) ? 1 : 0;
+	chip->curr_status.uart_connect =
+	    ((chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_UART) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_JIG_UART_ON) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF_WITH_VBUS) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_JIG_UART_ON_WITH_VBUS)) ? 1 : 0;
+	chip->curr_status.jig_connect =
+	    ((chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_JIG_USB_OFF) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_JIG_USB_ON) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_JIG_UART_ON) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF_WITH_VBUS) ||
+	     (chip->curr_status.cable_type ==
+	      MUIC_RT8973_CABLE_TYPE_JIG_UART_ON_WITH_VBUS)) ? 1 : 0;
+	chip->curr_status.l_usb_connect = (chip->curr_status.cable_type ==
+	    MUIC_RT8973_CABLE_TYPE_L_SPEC_USB) ? 1 : 0;
+}
+
+#define FLAG_HIGH           (0x01)
+#define FLAG_LOW            (0x02)
+#define FLAG_LOW_TO_HIGH    (0x04)
+#define FLAG_HIGH_TO_LOW    (0x08)
+#define FLAG_RISING         FLAG_LOW_TO_HIGH
+#define FLAG_FALLING        FLAG_HIGH_TO_LOW
+#define FLAG_CHANGED        (FLAG_LOW_TO_HIGH | FLAG_HIGH_TO_LOW)
+
+static inline uint32_t state_check(unsigned int old_state,
+				   unsigned int new_state,
+				   unsigned int bit_mask)
+{
+	unsigned int ret = 0;
+	old_state &= bit_mask;
+	new_state &= bit_mask;
+	if (new_state)
+		ret |= FLAG_HIGH;
+	else
+		ret |= FLAG_LOW;
+	if (old_state != new_state) {
+		if (new_state)
+			ret |= FLAG_LOW_TO_HIGH;
+		else
+			ret |= FLAG_HIGH_TO_LOW;
+	}
+	return ret;
+}
+
+struct rt8973_event_handler {
+	char *name;
+	uint32_t bit_mask;
+	uint32_t type;
+	void (*handler) (struct rt8973_chip *chip,
+			 const struct rt8973_event_handler *handler,
+			 unsigned int old_status, unsigned int new_status);
+
+};
+
+static void rt8973_ocp_handler(struct rt8973_chip *chip,
+			       const struct rt8973_event_handler *handler,
+			       unsigned int old_status, unsigned int new_status)
+{
+	RTERR("OCP event triggered\n");
+	if (chip->pdata->ocp_callback)
+		chip->pdata->ocp_callback();
+}
+
+static void rt8973_ovp_handler(struct rt8973_chip *chip,
+			       const struct rt8973_event_handler *handler,
+			       unsigned int old_status, unsigned int new_status)
+{
+	RTERR("OVP event triggered\n");
+	if (chip->pdata->ovp_callback)
+		chip->pdata->ovp_callback();
+}
+
+static void rt8973_otp_handler(struct rt8973_chip *chip,
+			       const struct rt8973_event_handler *handler,
+			       unsigned int old_status, unsigned int new_status)
+{
+	RTERR("OTP event triggered\n");
+	if (chip->pdata->otp_callback)
+		chip->pdata->otp_callback();
+}
+
+struct rt8973_event_handler urgent_event_handlers[] = {
+	{
+	 .name = "OCP",
+	 .bit_mask = (1 << OCP_SHIFT),
+	 .type = FLAG_RISING,
+	 .handler = rt8973_ocp_handler,
+	 },
+	{
+	 .name = "OVP",
+	 .bit_mask = (1 << OVP_SHIFT),
+	 .type = FLAG_RISING,
+	 .handler = rt8973_ovp_handler,
+	 },
+	{
+	 .name = "OTP",
+	 .bit_mask = (1 << OTP_SHIFT),
+	 .type = FLAG_RISING,
+	 .handler = rt8973_otp_handler,
+	 },
+};
+
+#if RTDBGINFO_LEVEL <= RTDBGLEVEL
+static char *rt8973_cable_names[] = {
+
+	"MUIC_RT8973_CABLE_TYPE_NONE",
+	"MUIC_RT8973_CABLE_TYPE_UART",
+	"MUIC_RT8973_CABLE_TYPE_USB",
+	"MUIC_RT8973_CABLE_TYPE_OTG",
+	/* TA Group */
+	"MUIC_RT8973_CABLE_TYPE_REGULAR_TA",
+	"MUIC_RT8973_CABLE_TYPE_ATT_TA",
+	"MUIC_RT8973_CABLE_TYPE_0x15",
+	"MUIC_RT8973_CABLE_TYPE_TYPE1_CHARGER",
+	"MUIC_RT8973_CABLE_TYPE_0x1A",
+	"MUIC_RT8973_CABLE_TYPE_0x1A_VBUS",
+	/* JIG Group */
+	"MUIC_RT8973_CABLE_TYPE_JIG_USB_OFF",
+	"MUIC_RT8973_CABLE_TYPE_JIG_USB_ON",
+	"MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF",
+	"MUIC_RT8973_CABLE_TYPE_JIG_UART_ON",
+	/* JIG type with VBUS */
+	"MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF_WITH_VBUS",
+	"MUIC_RT8973_CABLE_TYPE_JIG_UART_ON_WITH_VBUS",
+
+	"MUIC_RT8973_CABLE_TYPE_CDP",
+	"MUIC_RT8973_CABLE_TYPE_L_SPEC_USB",
+	"MUIC_RT8973_CABLE_TYPE_UNKNOWN",
+	"MUIC_RT8973_CABLE_TYPE_INVALID",
+};
+#endif /*RTDBGINFO_LEVEL<=RTDBGLEVEL */
+
+static void rt8973_cable_change_handler(struct rt8973_chip *chip,
+					const struct rt8973_event_handler
+					*handler, unsigned int old_status,
+					unsigned int new_status)
+{
+	RTINFO("Cable change to %s\n",
+	       rt8973_cable_names[chip->curr_status.cable_type]);
+	cable_change_callback(chip->curr_status.cable_type);
+	if (chip->pdata->cable_chg_callback)
+		chip->pdata->cable_chg_callback(chip->curr_status.cable_type);
+
+}
+
+static void rt8973_otg_attach_handler(struct rt8973_chip *chip,
+				      const struct rt8973_event_handler
+				      *handler, unsigned int old_status,
+				      unsigned int new_status)
+{
+	RTINFO("OTG attached\n");
+	rt8973_reg_write(chip, RT8973_REG_MANUAL_SW1, 0x24);
+	/* Disable USBCHDEN and AutoConfig*/
+	rt8973_clr_bits(chip, RT8973_REG_CONTROL, (1 << 2) | (1 << 6));
+	if (chip->pdata->otg_callback)
+		chip->pdata->otg_callback(1);
+}
+
+static void rt8973_otg_detach_handler(struct rt8973_chip *chip,
+				      const struct rt8973_event_handler
+				      *handler, unsigned int old_status,
+				      unsigned int new_status)
+{
+	RTINFO("OTG detached\n");
+	rt8973_reg_write(chip, RT8973_REG_MANUAL_SW1, 0x00);
+	/* Enable USBCHDEN and AutoConfig*/
+	rt8973_set_bits(chip, RT8973_REG_CONTROL, (1 << 2) | (1 << 6));
+	if (chip->pdata->otg_callback)
+		chip->pdata->otg_callback(0);
+}
+
+static void rt8973_usb_attach_handler(struct rt8973_chip *chip,
+				      const struct rt8973_event_handler
+				      *handler, unsigned int old_status,
+				      unsigned int new_status)
+{
+	RTINFO("USB attached\n");
+	if (chip->pdata->usb_callback)
+		chip->pdata->usb_callback(1);
+}
+
+static void rt8973_usb_detach_handler(struct rt8973_chip *chip,
+				      const struct rt8973_event_handler
+				      *handler, unsigned int old_status,
+				      unsigned int new_status)
+{
+	RTINFO("USB detached\n");
+	if (chip->pdata->usb_callback)
+		chip->pdata->usb_callback(0);
+}
+
+static void rt8973_uart_attach_handler(struct rt8973_chip *chip,
+				       const struct rt8973_event_handler
+				       *handler, unsigned int old_status,
+				       unsigned int new_status)
+{
+	RTINFO("UART attached\n");
+	if (chip->pdata->uart_callback)
+		chip->pdata->uart_callback(1);
+}
+
+static void rt8973_uart_detach_handler(struct rt8973_chip *chip,
+				       const struct rt8973_event_handler
+				       *handler, unsigned int old_status,
+				       unsigned int new_status)
+{
+	RTINFO("UART detached\n");
+	if (chip->pdata->uart_callback)
+		chip->pdata->uart_callback(0);
+}
+
+static inline jig_type_t get_jig_type(int cable_type)
+{
+	jig_type_t type = JIG_USB_BOOT_ON;
+	switch (cable_type) {
+	case MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF_WITH_VBUS:
+	case MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF:
+		type = JIG_UART_BOOT_OFF;
+		break;
+	case MUIC_RT8973_CABLE_TYPE_JIG_UART_ON_WITH_VBUS:
+	case MUIC_RT8973_CABLE_TYPE_JIG_UART_ON:
+		type = JIG_UART_BOOT_ON;
+		break;
+	case MUIC_RT8973_CABLE_TYPE_JIG_USB_OFF:
+		type = JIG_USB_BOOT_OFF;
+		break;
+	case MUIC_RT8973_CABLE_TYPE_JIG_USB_ON:
+		type = JIG_USB_BOOT_ON;
+		break;
+	}
+	return type;
+}
+
+static inline int rt8973_get_jig_uart_without_vbus(int cable_type)
+{
+	int ret = false;
+	switch (cable_type) {
+	case MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF:
+	case MUIC_RT8973_CABLE_TYPE_JIG_UART_ON:
+		ret = true;
+		break;
+	}
+	return ret;
+}
+
+static void rt8973_jig_attach_handler(struct rt8973_chip *chip,
+				      const struct rt8973_event_handler
+				      *handler, unsigned int old_status,
+				      unsigned int new_status)
+{
+	jig_type_t type;
+	type = get_jig_type(chip->curr_status.cable_type);
+	RTINFO("JIG attached (type = %d)\n", (int)type);
+
+	if ((!jig_wakelock_acq) &&
+		rt8973_get_jig_uart_without_vbus
+		(chip->curr_status.cable_type)) {
+		__pm_stay_awake(&jig_suspend_wake);
+		pm_qos_update_request(qos_idle,
+				PM_QOS_CPUIDLE_BLOCK_AXI_VALUE);
+		jig_wakelock_acq = 1;
+		RTINFO("AP wakelock for factorytest\n");
+	}
+
+	if (chip->pdata->jig_callback)
+		chip->pdata->jig_callback(type, 1);
+}
+
+static void rt8973_jig_detach_handler(struct rt8973_chip *chip,
+				      const struct rt8973_event_handler
+				      *handler, unsigned int old_status,
+				      unsigned int new_status)
+{
+	jig_type_t type;
+	type = get_jig_type(chip->prev_status.cable_type);
+	RTINFO("JIG detached (type = %d)\n", (int)type);
+	if (jig_wakelock_acq) {
+		__pm_relax(&jig_suspend_wake);
+		pm_qos_update_request(qos_idle,
+				PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+		jig_wakelock_acq = 0;
+		RTINFO("AP wakelock release\n");
+	}
+	if (chip->pdata->jig_callback)
+		chip->pdata->jig_callback(type, 0);
+}
+
+static void rt8973_l_usb_attach_handler(struct rt8973_chip *chip,
+				      const struct rt8973_event_handler
+				      *handler, unsigned int old_status,
+				      unsigned int new_status)
+{
+	RTINFO("L USB cable attached\n");
+	/* Make switch connect to USB path */
+	rt8973_reg_write(chip, RT8973_REG_MANUAL_SW1, 0x24);
+	/* Change to manual-config */
+	rt8973_clr_bits(chip, RT8973_REG_CONTROL, 1 << 2);
+}
+
+static void rt8973_l_usb_detach_handler(struct rt8973_chip *chip,
+				      const struct rt8973_event_handler
+				      *handler, unsigned int old_status,
+				      unsigned int new_status)
+{
+	RTINFO("L USB cable detached\n");
+	/* Make switch opened */
+	rt8973_reg_write(chip, RT8973_REG_MANUAL_SW1, 0x00);
+	/* Change to auto-config */
+	rt8973_set_bits(chip, RT8973_REG_CONTROL, 1 << 2);
+}
+
+
+struct rt8973_event_handler normal_event_handlers[] = {
+	{
+	 .name = "L USB attached",
+	 .bit_mask = (1 << L_USB_SHIFT),
+	 .type = FLAG_RISING,
+	 .handler = rt8973_l_usb_attach_handler,
+	},
+	{
+	 .name = "L special USB detached",
+	 .bit_mask = (1 << L_USB_SHIFT),
+	 .type = FLAG_FALLING,
+	 .handler = rt8973_l_usb_detach_handler,
+	},
+	{
+	 .name = "Cable changed",
+	 .bit_mask = (1 << CABLE_CHG_SHIFT),
+	 .type = FLAG_HIGH,
+	 .handler = rt8973_cable_change_handler,
+	 },
+	{
+	 .name = "OTG attached",
+	 .bit_mask = (1 << OTG_SHIFT),
+	 .type = FLAG_RISING,
+	 .handler = rt8973_otg_attach_handler,
+	 },
+	{
+	 .name = "OTG detached",
+	 .bit_mask = (1 << OTG_SHIFT),
+	 .type = FLAG_FALLING,
+	 .handler = rt8973_otg_detach_handler,
+	 },
+	{
+	 .name = "USB attached",
+	 .bit_mask = (1 << USB_SHIFT),
+	 .type = FLAG_RISING,
+	 .handler = rt8973_usb_attach_handler,
+	 },
+	{
+	 .name = "USB detached",
+	 .bit_mask = (1 << USB_SHIFT),
+	 .type = FLAG_FALLING,
+	 .handler = rt8973_usb_detach_handler,
+	 },
+	{
+	 .name = "UART attached",
+	 .bit_mask = (1 << UART_SHIFT),
+	 .type = FLAG_RISING,
+	 .handler = rt8973_uart_attach_handler,
+	 },
+	{
+	 .name = "UART detached",
+	 .bit_mask = (1 << UART_SHIFT),
+	 .type = FLAG_FALLING,
+	 .handler = rt8973_uart_detach_handler,
+	 },
+	{
+	 .name = "JIG attached",
+	 .bit_mask = (1 << JIG_SHIFT),
+	 .type = FLAG_RISING,
+	 .handler = rt8973_jig_attach_handler,
+	 },
+	{
+	 .name = "JIG detached",
+	 .bit_mask = (1 << JIG_SHIFT),
+	 .type = FLAG_FALLING,
+	 .handler = rt8973_jig_detach_handler,
+	 },
+};
+
+static void rt8973_process_urgent_evt(rt8973_chip_t *chip)
+{
+	unsigned int i;
+	unsigned int type, sta_chk;
+	uint32_t prev_status, curr_status;
+	prev_status = chip->prev_status.status;
+	curr_status = chip->curr_status.status;
+	for (i = 0; i < ARRAY_SIZE(urgent_event_handlers); i++) {
+		sta_chk = state_check(prev_status,
+				      curr_status,
+				      urgent_event_handlers[i].bit_mask);
+		type = urgent_event_handlers[i].type;
+		if (type & sta_chk) {
+
+			if (urgent_event_handlers[i].handler)
+				urgent_event_handlers[i].handler(chip,
+						urgent_event_handlers + i,
+						prev_status,
+						curr_status);
+		}
+	}
+}
+
+static void rt8973_process_normal_evt(rt8973_chip_t *chip)
+{
+	unsigned int i;
+	unsigned int type, sta_chk;
+	uint32_t prev_status, curr_status;
+	prev_status = chip->prev_status.status;
+	curr_status = chip->curr_status.status;
+	for (i = 0; i < ARRAY_SIZE(normal_event_handlers); i++) {
+		sta_chk = state_check(prev_status,
+				      curr_status,
+				      normal_event_handlers[i].bit_mask);
+		type = normal_event_handlers[i].type;
+		if (type & sta_chk) {
+			if (normal_event_handlers[i].handler)
+				normal_event_handlers[i].handler(chip,
+						normal_event_handlers + i,
+						prev_status,
+						curr_status);
+		}
+	}
+}
+
+static void rt8973_irq_work(struct work_struct *work)
+{
+	int ret;
+	rt8973_chip_t *chip = container_of(to_delayed_work(work),
+					   rt8973_chip_t, irq_work);
+	chip->prev_status = chip->curr_status;
+	ret = rt8973_update_regs(chip);
+	if (ret < 0) {
+		RTERR("Error : can't update(read) register status:%d\n", ret);
+		/* roll back status */
+		chip->curr_status = chip->prev_status;
+		return;
+	}
+	RTINFO("I1 I2 D1 D2 0x%x, 0x%x, 0x%x, 0x%x\n",
+			(int)chip->curr_status.irq_flags[0],
+			(int)chip->curr_status.irq_flags[1],
+			(int)chip->curr_status.device_reg[0],
+			(int)chip->curr_status.device_reg[1]);
+	RTINFO("ADC = 0x%x\n", (int)chip->curr_status.id_adc);
+	rt8973_preprocess_status(chip);
+	RTINFO("Status : cable type = %d,\n"
+	       "vbus = %d, accessory = %d\n"
+	       "ocp = %d, ovp = %d, otp = %d,\n"
+	       "adc_chg = %d, cable_chg = %d\n"
+	       "otg = %d, dcdt = %d, usb = %d,\n"
+	       "uart = %d, jig = %d\n"
+	       "L usb cable = %d\n",
+	       chip->curr_status.cable_type,
+	       chip->curr_status.vbus_status,
+	       chip->curr_status.accessory_status,
+	       chip->curr_status.ocp_status,
+	       chip->curr_status.ovp_status,
+	       chip->curr_status.otp_status,
+	       chip->curr_status.adc_chg_status,
+	       chip->curr_status.cable_chg_status,
+	       chip->curr_status.otg_status,
+	       chip->curr_status.dcdt_status,
+	       chip->curr_status.usb_connect,
+	       chip->curr_status.uart_connect,
+	       chip->curr_status.jig_connect,
+	       chip->curr_status.l_usb_connect);
+	rt8973_process_urgent_evt(chip);
+	if (chip->curr_status.dcdt_status) {
+		if (chip->dcdt_retry_count >= DCD_T_RETRY) {
+			chip->dcdt_retry_count = 0;	/* reset counter */
+			RTINFO("Exceeded maxima retry times\n");
+			/* continue to process event */
+		} else {
+			chip->dcdt_retry_count++;
+			/* DCD_T -> roll back previous status */
+			chip->curr_status = chip->prev_status;
+			RTINFO("DCD_T event triggered, do re-detect\n");
+			rt8973_clr_bits(chip, RT8973_REG_CONTROL, 0x60);
+			msleep_interruptible(1);
+			rt8973_set_bits(chip, RT8973_REG_CONTROL, 0x60);
+			return;
+		}
+	}
+	rt8973_process_normal_evt(chip);
+}
+
+static irqreturn_t rt8973_irq_handler(int irq, void *data)
+{
+	struct rt8973_chip *chip = data;
+	wake_lock_timeout(&(chip->muic_wake_lock), msecs_to_jiffies(500));
+	RTINFO("RT8973 interrupt triggered!\n");
+	queue_delayed_work(chip->wq, &chip->irq_work, msecs_to_jiffies(250));
+	return IRQ_HANDLED;
+}
+
+static const struct i2c_device_id rt8973_id_table[] = {
+	{"rt8973", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, rt8973_id_table);
+
+static bool rt8973_reset_check(struct i2c_client *iic)
+{
+	int ret;
+	ret = i2c_smbus_read_byte_data(iic, RT8973_REG_CHIP_ID);
+	if (ret < 0) {
+		RTERR("Error : can't read device ID from IC(%d)\n", ret);
+		return false;
+	}
+	if ((ret&0x07) != 0x02) {
+		RTERR("Error : vendor ID mismatch (0x%d)!\n", ret);
+		return false;
+	}
+
+    /* write default value instead of sending reset command*/
+    /* REG[0x02] = 0xE5, REG[0x14] = 0x01*/
+	i2c_smbus_write_byte_data(iic, RT8973_REG_CONTROL, 0xE5);
+	i2c_smbus_write_byte_data(iic, RT8973_REG_MANUAL_SW2, 0x01);
+	return true;
+}
+
+static void rt8973_init_regs(rt8973_chip_t *chip)
+{
+	int chip_id = rt8973_reg_read(chip, RT8973_REG_CHIP_ID);
+	/* initialize with MUIC_RT8973_CABLE_TYPE_INVALID
+	 * to make 1st detection work always report cable type */
+	chip->curr_status.cable_type = MUIC_RT8973_CABLE_TYPE_INVALID;
+	chip->curr_status.id_adc = 0x1f;
+	/* for rev 0, turn off i2c reset function */
+	if (((chip_id & 0xf8) >> 3) == 0)
+		rt8973_set_bits(chip, RT8973_REG_CONTROL, 0x08);
+	/* Only mask Connect */
+	rt8973_reg_write(chip, RT8973_REG_INTERRUPT_MASK1, 0x20);
+	/* Only mask OCP_LATCH and POR */
+	rt8973_reg_write(chip, RT8973_REG_INTERRUPT_MASK2, 0x24);
+	/* Dummy read */
+	rt8973_reg_read(chip, RT8973_REG_INT_FLAG1);
+	/* enable interrupt */
+	rt8973_clr_bits(chip, RT8973_REG_CONTROL, 0x01);
+	/* Execute 1st dectection and report cable type*/
+	queue_delayed_work(chip->wq, &chip->irq_work, 0);
+}
+
+#ifdef SAMSUNG_MVRL_MUIC_RT8973
+static ssize_t adc_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	u8 adc_value[] = "1C";
+	u8 adc_fail = 0;
+
+	if (current_status->cable_type == MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF) {
+		RTINFO("adc_show JIG UART BOOT OFF\n");
+		return sprintf(buf, "%s\n", adc_value);
+	} else {
+		RTINFO("adc_show no detect\n");
+		return sprintf(buf, "%d\n", adc_fail);
+	}
+}
+
+static ssize_t usb_state_show_attrs(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	if (current_status->usb_connect)
+		return sprintf(buf, "USB_STATE_CONFIGURED\n");
+	else
+		return sprintf(buf, "USB_STATE_NOTCONFIGURED\n");
+}
+
+static ssize_t usb_sel_show_attrs(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "PDA");
+}
+
+static ssize_t rt8973_set_syssleep(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct pm_qos_request *syssleep_qos_idle = qos_idle;
+
+	if (!strncmp(buf, "1", 1)) {
+		pm_qos_update_request(syssleep_qos_idle,
+				PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+		__pm_relax(&jig_suspend_wake);
+	}
+	return count;
+}
+static DEVICE_ATTR(syssleep, S_IWUSR, NULL, rt8973_set_syssleep);
+static DEVICE_ATTR(adc, S_IRUGO | S_IWUSR | S_IWGRP | S_IXOTH /*0665 */ ,
+		   adc_show, NULL);
+static DEVICE_ATTR(usb_state, S_IRUGO, usb_state_show_attrs, NULL);
+static DEVICE_ATTR(usb_sel, S_IRUGO, usb_sel_show_attrs, NULL);
+
+static int sec_get_usb_vbus(unsigned int *level)
+{
+	if (current_status->vbus_status) {
+		RTINFO("set VBUS_HIGH\n");
+		*level = VBUS_HIGH;
+	} else {
+		RTINFO("set VBUS_LOW\n");
+		*level = VBUS_LOW;
+	}
+	return 0;
+}
+
+
+int rt8973_check_usb_status()
+{
+	int ret = 0;
+	if (current_status == NULL)
+		RTINFO("current_status is NULL\n");
+	else {
+		if (current_status->usb_connect)
+			ret = 1;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(rt8973_check_usb_status);
+
+int rt8973_check_jig_uart_status()
+{
+	int ret = 0;
+	if (current_status == NULL)
+		RTINFO("current_status is NULL\n");
+	else {
+		if ((current_status->cable_type ==
+		    MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF)
+		    || (current_status->cable_type ==
+		    MUIC_RT8973_CABLE_TYPE_JIG_UART_ON)
+		    || (current_status->cable_type ==
+		    MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF_WITH_VBUS)
+		    || (current_status->cable_type ==
+		    MUIC_RT8973_CABLE_TYPE_JIG_UART_ON_WITH_VBUS))
+			ret = 1;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(rt8973_check_jig_uart_status);
+#endif
+
+static int rt8973_parse_dt(struct device *dev,
+		struct rt8973_platform_data *pdata)
+{
+	struct device_node *np = dev->of_node;
+	enum of_gpio_flags irq_gpio_flags;
+	pdata->irq_gpio = of_get_named_gpio_flags(np, "rt8973,irq-gpio",
+			0, &irq_gpio_flags);
+	return 0;
+}
+
+static int __devinit rt8973_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+	struct rt8973_platform_data *pdata;
+	struct rt8973_chip *chip;
+#ifdef SAMSUNG_MVRL_MUIC_RT8973
+	struct device *switch_dev;
+#endif
+	int ret;
+	RTINFO("Richtek RT8973 driver probing...\n");
+	if (client->dev.of_node) {
+		pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_nomem;
+		}
+		ret = rt8973_parse_dt(&client->dev, pdata);
+		if (ret < 0)
+			goto err_parse_dt;
+	} else
+		pdata = client->dev.platform_data;
+
+#ifdef SAMSUNG_MVRL_MUIC_RT8973
+	wakeup_source_init(&jig_suspend_wake, "rt8973_jig_uart_wakelock");
+#ifdef PXA_IRQ_TO_GPIO
+	pdata->irq_gpio = pxa_irq_to_gpio(client->irq);
+#else
+	client->irq = gpio_to_irq(CONFIG_RTMUSC_INT_GPIO_NUMBER);
+	pdata->irq_gpio = pxa_irq_to_gpio(client->irq);
+#endif
+	RTINFO("GPIO MUIC INT No. = %d\n", pdata->irq_gpio);
+#endif
+	ret = i2c_check_functionality(client->adapter,
+				      I2C_FUNC_SMBUS_BYTE_DATA |
+				      I2C_FUNC_SMBUS_I2C_BLOCK);
+	if (ret < 0) {
+		RTERR("Error : i2c functionality check failed\n");
+		goto err_i2c_func;
+	}
+	if (!rt8973_reset_check(client)) {
+		ret = -ENODEV;
+		goto err_reset_rt8973_fail;
+	}
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL) {
+		ret = -ENOMEM;
+		goto err_nomem;
+	}
+#ifdef SAMSUNG_MVRL_MUIC_RT8973
+	current_status = &chip->curr_status;
+	chip->qos_idle.name = "Jig driver";
+	pm_qos_add_request(&chip->qos_idle, PM_QOS_CPUIDLE_BLOCK,
+			   PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+	qos_idle = &chip->qos_idle;
+#endif
+	wake_lock_init(&chip->muic_wake_lock, WAKE_LOCK_SUSPEND,
+		       "rt8973_wakelock");
+	ret = gpio_request(pdata->irq_gpio, "RT8973_EINT");
+	RTWARN_IF(ret < 0,
+		  "Warning : failed to request GPIO%d (retval = %d)\n",
+		  pdata->irq_gpio, ret);
+	ret = gpio_direction_input(pdata->irq_gpio);
+	RTWARN_IF(ret < 0,
+		  "Warning : failed to set GPIO%d as input pin(retval = %d)\n",
+		  pdata->irq_gpio, ret);
+	chip->iic = client;
+	chip->dev = &client->dev;
+	chip->pdata = pdata;
+	i2c_set_clientdata(client, chip);
+	chip->wq = create_workqueue("rt8973_workqueue");
+	INIT_DELAYED_WORK(&chip->irq_work, rt8973_irq_work);
+#ifdef SAMSUNG_MVRL_MUIC_RT8973
+#ifndef CONFIG_MFD_88PM822
+	pxa_usb_set_extern_call(PXA_USB_DEV_OTG, vbus, get_vbus,
+				sec_get_usb_vbus);
+#endif
+#endif
+	mutex_init(&chip->io_lock);
+	chip->irq = gpio_to_irq(pdata->irq_gpio);
+	client->irq = chip->irq;
+	RTINFO("Request IRQ %d(GPIO %d)...\n",
+	       chip->irq, pdata->irq_gpio);
+	ret = request_irq(chip->irq, rt8973_irq_handler,
+		RT8973_IRQF_MODE | IRQF_NO_SUSPEND, RT8973_DEVICE_NAME, chip);
+	if (ret < 0) {
+		RTERR
+		    ("Error : failed to request irq %d (gpio=%d, retval=%d)\n",
+		     chip->irq, pdata->irq_gpio, ret);
+		goto err_request_irq_fail;
+	}
+	rt8973_init_regs(chip);
+#ifdef SAMSUNG_MVRL_MUIC_RT8973
+	switch_dev = device_create(sec_class, NULL, 0, NULL, "switch");
+	chip->switch_dev = switch_dev;
+	if (device_create_file(switch_dev, &dev_attr_adc) < 0)
+		pr_err("Failed to create device file(%s)!\n",
+		       dev_attr_adc.attr.name);
+	if (device_create_file(switch_dev, &dev_attr_usb_state) < 0)
+		pr_err("Failed to create device file(%s)!\n",
+		       dev_attr_usb_state.attr.name);
+	if (device_create_file(switch_dev, &dev_attr_usb_sel) < 0)
+		pr_err("Failed to create device file(%s)!\n",
+		       dev_attr_usb_sel.attr.name);
+	if (device_create_file(switch_dev, &dev_attr_syssleep) < 0)
+		pr_err("Failed to create device file(%s)!\n",
+		       dev_attr_syssleep.attr.name);
+
+	muic_int_gpio.mfp = pdata->irq_gpio;
+	mmp_gpio_edge_add(&muic_int_gpio);
+#endif
+	RTINFO("Richtek RT8973 MUIC driver" " initialize successfully\n");
+	return 0;
+err_request_irq_fail:
+	mutex_destroy(&chip->io_lock);
+	destroy_workqueue(chip->wq);
+	gpio_free(pdata->irq_gpio);
+	wake_lock_destroy(&chip->muic_wake_lock);
+	kfree(chip);
+err_nomem:
+err_reset_rt8973_fail:
+err_i2c_func:
+err_parse_dt:
+	return ret;
+}
+
+static int __devexit rt8973_remove(struct i2c_client *client)
+{
+	struct rt8973_chip *chip;
+	RTINFO("Richtek RT8973 driver removing...\n");
+#ifdef SAMSUNG_MVRL_MUIC_RT8973
+	mmp_gpio_edge_del(&muic_int_gpio);
+#endif
+	chip = i2c_get_clientdata(client);
+	if (chip) {
+		pm_qos_remove_request(&chip->qos_idle);
+		free_irq(chip->irq, chip);
+		gpio_free(chip->pdata->irq_gpio);
+		mutex_destroy(&chip->io_lock);
+		if (chip->wq)
+			destroy_workqueue(chip->wq);
+		wake_lock_destroy(&chip->muic_wake_lock);
+		kfree(chip);
+	}
+	return 0;
+
+}
+
+static void rt8973_shutdown(struct i2c_client *iic)
+{
+	struct rt8973_chip *chip;
+	chip = i2c_get_clientdata(iic);
+	disable_irq(iic->irq);
+	cancel_delayed_work_sync(&chip->irq_work);
+	RTINFO("Shutdown : reset rt8973...\n");
+	i2c_smbus_write_byte_data(iic, RT8973_REG_RESET, 0x01);
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id rt8973_match_table[] = {
+	{ .compatible = "richtek,rt8973",},
+	{},
+};
+#else
+#define rt8973_match_table NULL
+#endif
+
+
+static struct i2c_driver rt8973_driver = {
+	.driver = {
+		   .name = RT8973_DEVICE_NAME,
+		   .owner = THIS_MODULE,
+		   .of_match_table = rt8973_match_table,
+		   },
+	.probe = rt8973_probe,
+	.remove = __devexit_p(rt8973_remove),
+	.shutdown = rt8973_shutdown,
+	.id_table = rt8973_id_table,
+};
+
+static int __init rt8973_i2c_init(void)
+{
+	int ret;
+	ret = i2c_add_driver(&rt8973_driver);
+	if (ret != 0)
+		pr_err("Failed to register RT8973 I2C driver: %d\n", ret);
+	return ret;
+}
+
+module_init(rt8973_i2c_init);
+
+static void __exit rt8973_i2c_exit(void)
+{
+	i2c_del_driver(&rt8973_driver);
+}
+
+module_exit(rt8973_i2c_exit);
+
+MODULE_DESCRIPTION("Richtek RT8973 MUIC Driver");
+MODULE_AUTHOR("Patrick Chang <patrick_chang@richtek.com>");
+MODULE_VERSION(RT8973_DRV_VER);
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index c7795096..0f24cc3f 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -382,6 +382,14 @@ config HMC6352
 	  This driver provides support for the Honeywell HMC6352 compass,
 	  providing configuration and heading data via sysfs.
 
+config SENSORS_AK8975
+	tristate "AK8975 compass support"
+	default n
+	depends on I2C
+	help
+	  If you say yes here you get support for Asahi Kasei's
+	  orientation sensor AK8975.
+
 config EP93XX_PWM
 	tristate "EP93xx PWM support"
 	depends on ARCH_EP93XX
@@ -425,6 +433,10 @@ config TI_DAC7512
 	  This driver can also be built as a module. If so, the module
 	  will be called ti_dac7512.
 
+config UID_STAT
+	bool "UID based statistics tracking exported to /proc/uid_stat"
+	default n
+
 config VMWARE_BALLOON
 	tristate "VMware Balloon Driver"
 	depends on X86
@@ -498,6 +510,44 @@ config MAX8997_MUIC
 	  Maxim MAX8997 PMIC.
 	  The MAX8997 MUIC is a USB port accessory detector and switch.
 
+config SM5502_MUIC
+	tristate "SM5502 microUSB Switch"
+	depends on I2C
+	help
+	  The SM5502 is a USB port accessory detector and switch.
+	  The SM5502 is fully controlled using I2C and enables USB data,
+	  stereo and mono audio, video, microphone and UART data to use
+	  a common connector port.
+
+config WL127X_RFKILL
+	tristate "Bluetooth power control driver for TI wl127x"
+	depends on RFKILL
+	default n
+	---help---
+	 Creates an rfkill entry in sysfs for power control of Bluetooth
+	 TI wl127x chips.
+
+config SD8XXX_RFKILL
+        tristate "Rfkill power control for Marvell sd8xxx wlan/bt/fm"
+        depends on MMC_SDHCI_PXAV2 || MMC_SDHCI_PXAV3
+        select RFKILL
+        select WIRELESS_EXT
+        select WEXT_PRIV
+        select WEXT_SPY
+        default n
+        ---help---
+         Creates an rfkill entry in sysfs for power control of Marvell
+         sd8xxx wlan/bt/fm chips.
+
+config TC35876X
+	boolean "TC35876X chip"
+	depends on I2C && I2C_PXA
+	default n
+	help
+	  If you say yes here, you support for it.
+
+	  This driver can NOT be built as a module.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
@@ -506,4 +556,8 @@ source "drivers/misc/ti-st/Kconfig"
 source "drivers/misc/lis3lv02d/Kconfig"
 source "drivers/misc/carma/Kconfig"
 source "drivers/misc/altera-stapl/Kconfig"
+# source "drivers/misc/inv_mpu/Kconfig"
+# source "drivers/misc/projector/Kconfig"
+# source "drivers/misc/quicklogic/Kconfig"
+
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 3e1d8010..a5485454 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -33,6 +33,7 @@ obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550.o
 obj-$(CONFIG_EP93XX_PWM)	+= ep93xx_pwm.o
 obj-$(CONFIG_DS1682)		+= ds1682.o
 obj-$(CONFIG_TI_DAC7512)	+= ti_dac7512.o
+obj-$(CONFIG_UID_STAT)		+= uid_stat.o
 obj-$(CONFIG_C2PORT)		+= c2port/
 obj-$(CONFIG_IWMC3200TOP)      += iwmc3200top/
 obj-$(CONFIG_HMC6352)		+= hmc6352.o
@@ -49,3 +50,12 @@ obj-y				+= carma/
 obj-$(CONFIG_USB_SWITCH_FSA9480) += fsa9480.o
 obj-$(CONFIG_ALTERA_STAPL)	+=altera-stapl/
 obj-$(CONFIG_MAX8997_MUIC)	+= max8997-muic.o
+obj-$(CONFIG_SM5502_MUIC)	+= sm5502-muic.o
+obj-$(CONFIG_WL127X_RFKILL)	+= wl127x-rfkill.o
+obj-$(CONFIG_SD8XXX_RFKILL)    += sd8x_rfkill.o
+obj-$(CONFIG_SENSORS_AK8975)	+= akm8975.o
+obj-$(CONFIG_TC35876X)		+= tc35876x.o
+#obj-$(CONFIG_MPU_SENSORS_MPU6050B1)     += inv_mpu/
+#obj-$(CONFIG_SEC_MODEM)		+= modem_if/
+#obj-$(CONFIG_USE_DPP2601)	+= projector/
+#obj-$(CONFIG_QUICKLOGIC_BRIDGE)	+= quicklogic/
diff --git a/drivers/misc/uid_stat.c b/drivers/misc/uid_stat.c
new file mode 100644
index 00000000..2141124a
--- /dev/null
+++ b/drivers/misc/uid_stat.c
@@ -0,0 +1,156 @@
+/* drivers/misc/uid_stat.c
+ *
+ * Copyright (C) 2008 - 2009 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/atomic.h>
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/stat.h>
+#include <linux/uid_stat.h>
+#include <net/activity_stats.h>
+
+static DEFINE_SPINLOCK(uid_lock);
+static LIST_HEAD(uid_list);
+static struct proc_dir_entry *parent;
+
+struct uid_stat {
+	struct list_head link;
+	uid_t uid;
+	atomic_t tcp_rcv;
+	atomic_t tcp_snd;
+};
+
+static struct uid_stat *find_uid_stat(uid_t uid) {
+	unsigned long flags;
+	struct uid_stat *entry;
+
+	spin_lock_irqsave(&uid_lock, flags);
+	list_for_each_entry(entry, &uid_list, link) {
+		if (entry->uid == uid) {
+			spin_unlock_irqrestore(&uid_lock, flags);
+			return entry;
+		}
+	}
+	spin_unlock_irqrestore(&uid_lock, flags);
+	return NULL;
+}
+
+static int tcp_snd_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	int len;
+	unsigned int bytes;
+	char *p = page;
+	struct uid_stat *uid_entry = (struct uid_stat *) data;
+	if (!data)
+		return 0;
+
+	bytes = (unsigned int) (atomic_read(&uid_entry->tcp_snd) + INT_MIN);
+	p += sprintf(p, "%u\n", bytes);
+	len = (p - page) - off;
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+	return len;
+}
+
+static int tcp_rcv_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	int len;
+	unsigned int bytes;
+	char *p = page;
+	struct uid_stat *uid_entry = (struct uid_stat *) data;
+	if (!data)
+		return 0;
+
+	bytes = (unsigned int) (atomic_read(&uid_entry->tcp_rcv) + INT_MIN);
+	p += sprintf(p, "%u\n", bytes);
+	len = (p - page) - off;
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+	return len;
+}
+
+/* Create a new entry for tracking the specified uid. */
+static struct uid_stat *create_stat(uid_t uid) {
+	unsigned long flags;
+	char uid_s[32];
+	struct uid_stat *new_uid;
+	struct proc_dir_entry *entry;
+
+	/* Create the uid stat struct and append it to the list. */
+	if ((new_uid = kmalloc(sizeof(struct uid_stat), GFP_KERNEL)) == NULL)
+		return NULL;
+
+	new_uid->uid = uid;
+	/* Counters start at INT_MIN, so we can track 4GB of network traffic. */
+	atomic_set(&new_uid->tcp_rcv, INT_MIN);
+	atomic_set(&new_uid->tcp_snd, INT_MIN);
+
+	spin_lock_irqsave(&uid_lock, flags);
+	list_add_tail(&new_uid->link, &uid_list);
+	spin_unlock_irqrestore(&uid_lock, flags);
+
+	sprintf(uid_s, "%d", uid);
+	entry = proc_mkdir(uid_s, parent);
+
+	/* Keep reference to uid_stat so we know what uid to read stats from. */
+	create_proc_read_entry("tcp_snd", S_IRUGO, entry , tcp_snd_read_proc,
+		(void *) new_uid);
+
+	create_proc_read_entry("tcp_rcv", S_IRUGO, entry, tcp_rcv_read_proc,
+		(void *) new_uid);
+
+	return new_uid;
+}
+
+int uid_stat_tcp_snd(uid_t uid, int size) {
+	struct uid_stat *entry;
+	activity_stats_update();
+	if ((entry = find_uid_stat(uid)) == NULL &&
+		((entry = create_stat(uid)) == NULL)) {
+			return -1;
+	}
+	atomic_add(size, &entry->tcp_snd);
+	return 0;
+}
+
+int uid_stat_tcp_rcv(uid_t uid, int size) {
+	struct uid_stat *entry;
+	activity_stats_update();
+	if ((entry = find_uid_stat(uid)) == NULL &&
+		((entry = create_stat(uid)) == NULL)) {
+			return -1;
+	}
+	atomic_add(size, &entry->tcp_rcv);
+	return 0;
+}
+
+static int __init uid_stat_init(void)
+{
+	parent = proc_mkdir("uid_stat", NULL);
+	if (!parent) {
+		pr_err("uid_stat: failed to create proc entry\n");
+		return -1;
+	}
+	return 0;
+}
+
+__initcall(uid_stat_init);
diff --git a/drivers/nfc/Kconfig b/drivers/nfc/Kconfig
index 5af95927..5c5a03b8 100644
--- a/drivers/nfc/Kconfig
+++ b/drivers/nfc/Kconfig
@@ -5,37 +5,22 @@
 menu "Near Field Communication (NFC) devices"
 	depends on NFC
 
-config PN544_NFC
-	tristate "PN544 NFC driver"
-	depends on I2C
-	select CRC_CCITT
+config NFC_PN544
+        bool "NXP PN544 NFC Controller Driver"
 	default n
-	---help---
-	  Say yes if you want PN544 Near Field Communication driver.
-	  This is for i2c connected version. If unsure, say N here.
-
-	  To compile this driver as a module, choose m here. The module will
-	  be called pn544.
-
-config NFC_PN533
-	tristate "NXP PN533 USB driver"
-	depends on USB
-	help
-	  NXP PN533 USB driver.
-	  This driver provides support for NFC NXP PN533 devices.
-
-	  Say Y here to compile support for PN533 devices into the
-	  kernel or say M to compile it as module (pn533).
-
-config NFC_WILINK
-	tristate "Texas Instruments NFC WiLink driver"
-	depends on TI_ST && NFC_NCI
-	help
-	  This enables the NFC driver for Texas Instrument's BT/FM/GPS/NFC
-	  combo devices. This makes use of shared transport line discipline
-	  core driver to communicate with the NFC core of the combo chip.
-
-	  Say Y here to compile support for Texas Instrument's NFC WiLink driver
-	  into the kernel or say M to compile it as module.
+        help
+          NXP PN544 Near Field Communication controller support.
+          This option enables device driver support for the NFC.
+          It is used by many services. NFC is fully controlled using I2C
+          to communicate the AP chip.
+
+config NFC_PN547
+        bool "NXP PN547 NFC Controller Driver"
+	default n
+        help
+          NXP PN547 Near Field Communication controller support.
+          This option enables device driver support for the NFC.
+          It is used by many services. NFC is fully controlled using I2C
+          to communicate the AP chip.
 
 endmenu
diff --git a/drivers/nfc/Makefile b/drivers/nfc/Makefile
index ab99e857..d3661217 100644
--- a/drivers/nfc/Makefile
+++ b/drivers/nfc/Makefile
@@ -2,7 +2,9 @@
 # Makefile for nfc devices
 #
 
-obj-$(CONFIG_PN544_NFC)		+= pn544.o
+obj-$(CONFIG_NFC_PN544)		+= pn544.o
+obj-$(CONFIG_NFC_PN547)		+= pn547.o
+obj-$(CONFIG_ST21NFCA)		+= st21nfca.o
 obj-$(CONFIG_NFC_PN533)		+= pn533.o
 obj-$(CONFIG_NFC_WILINK)	+= nfcwilink.o
 
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index 99dc29f2..8b282eef 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -8,6 +8,15 @@ menuconfig POWER_SUPPLY
 
 if POWER_SUPPLY
 
+config BATTERY_SAMSUNG
+    tristate "samsung battery driver"
+	help
+	  Say Y to include support for samsung battery driver
+	  This battery driver integrated all battery-related functions
+	  To see battery-related functions,
+	  refer to sec_charging_common.h
+
+
 config POWER_SUPPLY_DEBUG
 	bool "Power supply debug"
 	help
@@ -62,6 +71,91 @@ config TEST_POWER
 	help
 	  This driver is used for testing. It's safe to say M here.
 
+config BATTERY_88PM80X
+	tristate "Marvell 88PM80x battery driver"
+	depends on MFD_88PM800
+	help
+	  Say Y here to enable battery monitor for Marvell 88PM80x chip.
+	  This driver uses the ADC function of 88PM80x. The capacity of the
+	  battery is calculated via the voltage. So it may not be very
+	  accurate.
+
+config SPA
+        tristate "Samsung Power&Accessory"
+        help
+         Samsung Power&Accessory
+config SPA_LPM_MODE
+	tristate "power off charging mode"
+	depends on SPA
+	help
+	  power off charging mode
+config SPA_FUEL_GAUGE_TEST
+	tristate "fuel gauge test binary"
+	depends on SPA
+	help
+	 fuel gauge test binary
+config SPA_POWER_OFF_BY_LOW_VOLTAGE
+	tristate "power off by low voltage"
+	depends on SPA
+	help
+	 power off by low voltage 
+
+config BATTERY_D2199
+	tristate "D2199 Fuel Gauge"
+	depends on MFD_D2199
+	depends on I2C
+	help
+	  This feature is depend on Power Supply class support
+	  	 
+config STC3105_FUELGAUGE
+        tristate "STC3105_FUELGAUGE"
+        help
+         STC3105_FUELGAUGE
+config MAX17043_FUELGAUGE
+        tristate "MAX17043_FUELGAUGE"
+        help
+         MAX17043_FUELGAUGE
+config BQ27425_FUELGAUGE
+        tristate "BQ27425_FUELGAUGE"
+        help
+         BQ27425_FUELGAUGE
+config BQ27425_READ_VF
+        tristate "BQ27425_READ_VF"
+	depends on BQ27425_FUELGAUGE
+        help
+         BQ27425_READ_VF
+config BQ27425_SOC_COMPENSATION_FOR_DISCHARGING
+        tristate "BQ27425_SOC_COMPENSATION_FOR_DISCHARGING"
+	depends on BQ27425_FUELGAUGE
+        help
+         BQ27425_SOC_COMPENSATION_FOR_DISCHARGING
+config SS6000_CHARGER
+	tristate "SS6000_CHARGER"
+	help
+	 SS6000_CHARGER
+config SS6000_CHARGER_OVP_FEATURE
+	tristate "SS6000_CHARGER_OVP_FEATURE"
+	depends on SS6000_CHARGER
+	help
+	 SS6000_CHARGER_OVP_FEATURE
+config STC3115_FUELGAUGE
+        tristate "STC3115_FUELGAUGE"
+        help
+         STC3115_FUELGAUGE
+config BQ24157_CHARGER
+	tristate "BQ24157_CHARGER"
+	help
+	 BQ24157_CHARGER
+config FSA9480_MICROUSB
+        tristate "FSA9480_MICROUSB"
+	help
+	 FSA9480_MICROUSB
+
+config FSA9480_MUIC_PXA_USB_NOTIFY
+	tristate "FSA9480_MUIC_PXA_USB_NOTIFY"
+	help
+	  Say Y here to enable PXA986/988/1088/1920 USB notify without Marvell PMIC 
+	
 config BATTERY_DS2760
 	tristate "DS2760 battery driver (HP iPAQ & others)"
 	depends on W1 && W1_SLAVE_DS2760
@@ -190,6 +284,16 @@ config BATTERY_MAX17042
 	  multi-function devices that include fuel gauages that are compatible
 	  with MAX17042.
 
+config BATTERY_ANDROID
+	tristate "Battery driver for Android"
+	help
+	  Say Y to enable generic support for battery charging according
+	  to common Android policies.
+	  This driver adds periodic battery level and health monitoring,
+	  kernel log reporting and other debugging features, common board
+	  battery file glue logic for battery/case temperature sensors,
+	  etc.
+
 config BATTERY_Z2
 	tristate "Z2 battery driver"
 	depends on I2C && MACH_ZIPIT2
@@ -242,6 +346,12 @@ config CHARGER_MAX8903
 	  pins based on the status of charger connections with interrupt
 	  handlers.
 
+config CHARGER_T7
+	tristate "T7 Tablet Battery Charger"
+	depends on GPIOLIB
+	help
+	  Say Y to enable support for T7 Tablet battery charger interface.
+
 config CHARGER_TWL4030
 	tristate "OMAP TWL4030 BCI charger driver"
 	depends on TWL4030_CORE
@@ -307,4 +417,32 @@ config AB8500_BATTERY_THERM_ON_BATCTRL
 	help
 	  Say Y to enable battery temperature measurements using
 	  thermistor connected on BATCTRL ADC.
+
+config CHARGER_ISL9226
+	tristate "ISL9226 batter charger support"
+	depends on I2C
+	help
+	  Say Y to include support for ISL9226 charger driver.
+
+config CHARGER_SMB358
+        tristate "Summit Microelectronics SMB358 Battery Charger"
+        depends on I2C
+        help
+          Say Y to include support for Summit Microelectronics SMB358
+          Battery Charger.
+
+config I2C_RT9455
+	tristate "RT9455 Switch Mode Charger driver"
+	depends on I2C
+	default n
+	help
+	  Say Y here to enable support for RT955 (I2C) chips.
+
+config I2C_RT9455_DBG
+	tristate "RT9455 Switch Mode Charger driver debug flag"
+	depends on I2C_RT9455
+	default n
+	help
+	  Say Y here to enable debug support for RT955 (I2C) chips.
+
 endif # POWER_SUPPLY
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index b6b24341..acdf2024 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -5,7 +5,6 @@ power_supply-$(CONFIG_SYSFS)		+= power_supply_sysfs.o
 power_supply-$(CONFIG_LEDS_TRIGGERS)	+= power_supply_leds.o
 
 obj-$(CONFIG_POWER_SUPPLY)	+= power_supply.o
-
 obj-$(CONFIG_PDA_POWER)		+= pda_power.o
 obj-$(CONFIG_APM_POWER)		+= apm_power.o
 obj-$(CONFIG_MAX8925_POWER)	+= max8925_power.o
@@ -37,6 +36,7 @@ obj-$(CONFIG_BATTERY_INTEL_MID)	+= intel_mid_battery.o
 obj-$(CONFIG_AB8500_BM)		+= ab8500_charger.o ab8500_btemp.o ab8500_fg.o abx500_chargalg.o
 obj-$(CONFIG_CHARGER_ISP1704)	+= isp1704_charger.o
 obj-$(CONFIG_CHARGER_MAX8903)	+= max8903_charger.o
+obj-$(CONFIG_CHARGER_T7)	+= t7_charger.o
 obj-$(CONFIG_CHARGER_TWL4030)	+= twl4030_charger.o
 obj-$(CONFIG_CHARGER_LP8727)	+= lp8727_charger.o
 obj-$(CONFIG_CHARGER_GPIO)	+= gpio-charger.o
@@ -44,3 +44,22 @@ obj-$(CONFIG_CHARGER_MANAGER)	+= charger-manager.o
 obj-$(CONFIG_CHARGER_MAX8997)	+= max8997_charger.o
 obj-$(CONFIG_CHARGER_MAX8998)	+= max8998_charger.o
 obj-$(CONFIG_CHARGER_SMB347)	+= smb347-charger.o
+obj-$(CONFIG_BATTERY_ANDROID)	+= android_battery.o
+obj-$(CONFIG_CHARGER_ISL9226)   += isl9226_charger.o
+ifndef CONFIG_SPA
+obj-$(CONFIG_BATTERY_88PM80X)	+= 88pm80x_battery.o
+else
+obj-$(CONFIG_BATTERY_88PM80X)	+= 88pm80x_fuelgauge.o
+endif
+obj-$(CONFIG_SPA) += spa.o
+obj-$(CONFIG_BQ24157_CHARGER)	+= bq24157_charger.o
+obj-$(CONFIG_STC3115_FUELGAUGE) += stc3115_fuelgauge.o  stc3115_configsecure.o
+obj-$(CONFIG_FUELGAUGE_STC3115) += stc3115_configsecure_lt02.o
+ifndef CONFIG_MACH_LT02
+obj-$(CONFIG_FSA9480_MICROUSB) += fsa9480.o
+else
+obj-$(CONFIG_FSA9480_MICROUSB) += fsa9480_lt02.o
+endif
+obj-$(CONFIG_CHARGER_SMB358) += smb358_charger.o
+obj-$(CONFIG_BATTERY_D2199)	+= d2199_battery.o
+obj-$(CONFIG_I2C_RT9455)	+= rt9455.o
diff --git a/drivers/power/power_supply_core.c b/drivers/power/power_supply_core.c
index 6ad61272..773fca15 100644
--- a/drivers/power/power_supply_core.c
+++ b/drivers/power/power_supply_core.c
@@ -41,23 +41,40 @@ static int __power_supply_changed_work(struct device *dev, void *data)
 
 static void power_supply_changed_work(struct work_struct *work)
 {
+	unsigned long flags;
 	struct power_supply *psy = container_of(work, struct power_supply,
 						changed_work);
 
 	dev_dbg(psy->dev, "%s\n", __func__);
 
-	class_for_each_device(power_supply_class, NULL, psy,
-			      __power_supply_changed_work);
+	spin_lock_irqsave(&psy->changed_lock, flags);
+	if (psy->changed) {
+		psy->changed = false;
+		spin_unlock_irqrestore(&psy->changed_lock, flags);
 
-	power_supply_update_leds(psy);
+		class_for_each_device(power_supply_class, NULL, psy,
+				      __power_supply_changed_work);
 
-	kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
+		power_supply_update_leds(psy);
+
+		kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
+		spin_lock_irqsave(&psy->changed_lock, flags);
+	}
+	if (!psy->changed)
+		pm_relax(psy->dev);
+	spin_unlock_irqrestore(&psy->changed_lock, flags);
 }
 
 void power_supply_changed(struct power_supply *psy)
 {
+	unsigned long flags;
+
 	dev_dbg(psy->dev, "%s\n", __func__);
 
+	spin_lock_irqsave(&psy->changed_lock, flags);
+	psy->changed = true;
+	pm_stay_awake(psy->dev);
+	spin_unlock_irqrestore(&psy->changed_lock, flags);
 	schedule_work(&psy->changed_work);
 }
 EXPORT_SYMBOL_GPL(power_supply_changed);
@@ -197,6 +214,11 @@ int power_supply_register(struct device *parent, struct power_supply *psy)
 	if (rc)
 		goto device_add_failed;
 
+	spin_lock_init(&psy->changed_lock);
+	rc = device_init_wakeup(dev, true);
+	if (rc)
+		goto wakeup_init_failed;
+
 	rc = power_supply_create_triggers(psy);
 	if (rc)
 		goto create_triggers_failed;
@@ -206,6 +228,7 @@ int power_supply_register(struct device *parent, struct power_supply *psy)
 	goto success;
 
 create_triggers_failed:
+wakeup_init_failed:
 	device_del(dev);
 kobject_set_name_failed:
 device_add_failed:
diff --git a/drivers/power/power_supply_sysfs.c b/drivers/power/power_supply_sysfs.c
index 4368e7d6..429e590f 100644
--- a/drivers/power/power_supply_sysfs.c
+++ b/drivers/power/power_supply_sysfs.c
@@ -45,17 +45,18 @@ static ssize_t power_supply_show_property(struct device *dev,
 					  char *buf) {
 	static char *type_text[] = {
 		"Unknown", "Battery", "UPS", "Mains", "USB",
-		"USB_DCP", "USB_CDP", "USB_ACA"
+		"USB_DCP", "USB_CDP", "USB_ACA",
+		"MISC", "CARDOCK", "WIRELESS", "UARTOFF", "OTG"
 	};
 	static char *status_text[] = {
 		"Unknown", "Charging", "Discharging", "Not charging", "Full"
 	};
 	static char *charge_type[] = {
-		"Unknown", "N/A", "Trickle", "Fast"
+		"Unknown", "N/A", "Trickle", "Fast", "slow"
 	};
 	static char *health_text[] = {
 		"Unknown", "Good", "Overheat", "Dead", "Over voltage",
-		"Unspecified failure", "Cold",
+		"Unspecified failure", "Cold", "under voltage"
 	};
 	static char *technology_text[] = {
 		"Unknown", "NiMH", "Li-ion", "Li-poly", "LiFe", "NiCd",
@@ -167,13 +168,32 @@ static struct device_attribute power_supply_attrs[] = {
 	POWER_SUPPLY_ATTR(capacity),
 	POWER_SUPPLY_ATTR(capacity_level),
 	POWER_SUPPLY_ATTR(temp),
+#if defined(CONFIG_SPA)//book
+	POWER_SUPPLY_ATTR(temp_adc),
+#endif
 	POWER_SUPPLY_ATTR(temp_ambient),
 	POWER_SUPPLY_ATTR(time_to_empty_now),
 	POWER_SUPPLY_ATTR(time_to_empty_avg),
 	POWER_SUPPLY_ATTR(time_to_full_now),
 	POWER_SUPPLY_ATTR(time_to_full_avg),
 	POWER_SUPPLY_ATTR(type),
+#if defined(CONFIG_SPA)//book
+	POWER_SUPPLY_ATTR(batt_vol),
+	POWER_SUPPLY_ATTR(batt_vol_aver),
+	POWER_SUPPLY_ATTR(batt_temp),
+	POWER_SUPPLY_ATTR(batt_temp_adc),
+	POWER_SUPPLY_ATTR(batt_temp_aver),
+	POWER_SUPPLY_ATTR(batt_temp_adc_aver),
+	POWER_SUPPLY_ATTR(batt_charging_source),
+	/* DFT */
+	POWER_SUPPLY_ATTR(batt_read_raw_soc),
+	/* DFT */
+#endif
 	POWER_SUPPLY_ATTR(scope),
+	/* Local extensions */
+	POWER_SUPPLY_ATTR(usb_hc),
+	POWER_SUPPLY_ATTR(usb_otg),
+	POWER_SUPPLY_ATTR(charge_enabled),
 	/* Properties of type `const char *' */
 	POWER_SUPPLY_ATTR(model_name),
 	POWER_SUPPLY_ATTR(manufacturer),
diff --git a/drivers/regulator/88pm822.c b/drivers/regulator/88pm822.c
new file mode 100755
index 00000000..5d62faad
--- /dev/null
+++ b/drivers/regulator/88pm822.c
@@ -0,0 +1,550 @@
+/*
+ * Regulators driver for Marvell 88PM822
+ *
+ * Copyright (C) 2013 Marvell International Ltd.
+ * Yipeng Yao <ypyao@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/regmap.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/88pm822.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+#if defined(CONFIG_CPU_PXA1L88) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+/* below 4 addresses are fake, only used in new dvc */
+#define PM822_BUCK1_AP_ACTIVE	(0x3C)
+#define PM822_BUCK1_AP_LPM	(0x3C)
+#define PM822_BUCK1_APSUB_IDLE	(0x3C)
+#define PM822_BUCK1_APSUB_SLEEP	(0x3C)
+
+#endif
+
+struct pm822_regulator_info {
+	struct regulator_desc desc;
+	struct pm822_chip *chip;
+	struct regmap *map;
+	struct regulator_dev *regulator;
+
+	int vol_reg;
+	int vol_shift;
+	int vol_nbits;
+	int enable_reg;
+	int enable_bit;
+	int dvc_en;
+	int dvc_val;
+	int max_uA;
+	unsigned int *vol_table;
+	void __iomem *dummy_dvc_reg;
+	unsigned int (*dvc_init_map)[4];
+
+#if defined(CONFIG_CPU_PXA1L88) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	struct pm822_dvc_pdata *dvc;
+#endif
+};
+
+/* Copy from drivers/regulator/core.c */
+struct regulator {
+	struct device *dev;
+	struct list_head list;
+	int uA_load;
+	int min_uV;
+	int max_uV;
+	char *supply_name;
+	struct device_attribute dev_attr;
+	struct regulator_dev *rdev;
+	struct dentry *debugfs;
+};
+
+/* FIXME use 0b'10 as default dvc value. The thinking is that we do not
+ * want user to see the dvc feature in PM822. If you want to change the
+ * voltage setting according to different dvc settings, you may use the dedicated
+ * driver API to do this.
+ */
+#define PM822_DEF_DVC_VAL		0x2
+
+static const unsigned int BUCK1_table[] = {
+	/* 0x00-0x4F: from 0.6 to 1.5875V with step 0.0125V */
+	600000, 612500, 625000, 637500, 650000, 662500, 675000, 687500,
+	700000, 712500, 725000, 737500, 750000, 762500, 775000, 787500,
+	800000, 812500, 825000, 837500, 850000, 862500, 875000, 887500,
+	900000, 912500, 925000, 937500, 950000, 962500, 975000, 987500,
+	1000000, 1012500, 1025000, 1037500, 1050000, 1062500, 1075000, 1087500,
+	1100000, 1112500, 1125000, 1137500, 1150000, 1162500, 1175000, 1187500,
+	1200000, 1212500, 1225000, 1237500, 1250000, 1262500, 1275000, 1287500,
+	1300000, 1312500, 1325000, 1337500, 1350000, 1362500, 1375000, 1387500,
+	1400000, 1412500, 1425000, 1437500, 1450000, 1462500, 1475000, 1487500,
+	1500000, 1512500, 1525000, 1537500, 1550000, 1562500, 1575000, 1587500,
+	/* 0x50-0x7F: from 1.6 to 3.95V with step 0.05V */
+	1600000, 1650000, 1700000, 1750000, 1800000,
+};
+
+static const unsigned int BUCK2_table[] = {
+	/* 0x00-0x4F: from 0.6 to 1.5875V with step 0.0125V */
+	600000, 612500, 625000, 637500, 650000, 662500, 675000, 687500,
+	700000, 712500, 725000, 737500, 750000, 762500, 775000, 787500,
+	800000, 812500, 825000, 837500, 850000, 862500, 875000, 887500,
+	900000, 912500, 925000, 937500, 950000, 962500, 975000, 987500,
+	1000000, 1012500, 1025000, 1037500, 1050000, 1062500, 1075000, 1087500,
+	1100000, 1112500, 1125000, 1137500, 1150000, 1162500, 1175000, 1187500,
+	1200000, 1212500, 1225000, 1237500, 1250000, 1262500, 1275000, 1287500,
+	1300000, 1312500, 1325000, 1337500, 1350000, 1362500, 1375000, 1387500,
+	1400000, 1412500, 1425000, 1437500, 1450000, 1462500, 1475000, 1487500,
+	1500000, 1512500, 1525000, 1537500, 1550000, 1562500, 1575000, 1587500,
+	/* 0x50-0x7F: from 1.6 to 3.95V with step 0.05V */
+	1600000, 1650000, 1700000, 1750000, 1800000, 1850000, 1900000, 1950000,
+	2000000, 2050000, 2100000, 2150000, 2200000, 2250000, 2300000, 2350000,
+	2400000, 2450000, 2500000, 2550000, 2600000, 2650000, 2700000, 2750000,
+	2800000, 2850000, 2900000, 2950000, 3000000, 3050000, 3100000, 3150000,
+	3200000, 3250000, 3300000,
+};
+
+static const unsigned int BUCK3_table[] = {
+	/* 0x00-0x4F: from 0.6 to 1.5875V with step 0.0125V */
+	600000, 612500, 625000, 637500, 650000, 662500, 675000, 687500,
+	700000, 712500, 725000, 737500, 750000, 762500, 775000, 787500,
+	800000, 812500, 825000, 837500, 850000, 862500, 875000, 887500,
+	900000, 912500, 925000, 937500, 950000, 962500, 975000, 987500,
+	1000000, 1012500, 1025000, 1037500, 1050000, 1062500, 1075000, 1087500,
+	1100000, 1112500, 1125000, 1137500, 1150000, 1162500, 1175000, 1187500,
+	1200000, 1212500, 1225000, 1237500, 1250000, 1262500, 1275000, 1287500,
+	1300000, 1312500, 1325000, 1337500, 1350000, 1362500, 1375000, 1387500,
+	1400000, 1412500, 1425000, 1437500, 1450000, 1462500, 1475000, 1487500,
+	1500000, 1512500, 1525000, 1537500, 1550000, 1562500, 1575000, 1587500,
+	/* 0x50-0x7F: from 1.6 to 3.95V with step 0.05V */
+	1600000, 1650000, 1700000, 1750000, 1800000, 1850000, 1900000, 1950000,
+	2000000, 2050000, 2100000, 2150000, 2200000, 2250000, 2300000, 2350000,
+	2400000, 2450000, 2500000, 2550000, 2600000, 2650000, 2700000, 2750000,
+	2800000, 2850000, 2900000, 2950000, 3000000, 3050000, 3100000, 3150000,
+	3200000, 3250000, 3300000,
+};
+
+static const unsigned int BUCK4_table[] = {
+	/* 0x00-0x4F: from 0.6 to 1.5875V with step 0.0125V */
+	600000, 612500, 625000, 637500, 650000, 662500, 675000, 687500,
+	700000, 712500, 725000, 737500, 750000, 762500, 775000, 787500,
+	800000, 812500, 825000, 837500, 850000, 862500, 875000, 887500,
+	900000, 912500, 925000, 937500, 950000, 962500, 975000, 987500,
+	1000000, 1012500, 1025000, 1037500, 1050000, 1062500, 1075000, 1087500,
+	1100000, 1112500, 1125000, 1137500, 1150000, 1162500, 1175000, 1187500,
+	1200000, 1212500, 1225000, 1237500, 1250000, 1262500, 1275000, 1287500,
+	1300000, 1312500, 1325000, 1337500, 1350000, 1362500, 1375000, 1387500,
+	1400000, 1412500, 1425000, 1437500, 1450000, 1462500, 1475000, 1487500,
+	1500000, 1512500, 1525000, 1537500, 1550000, 1562500, 1575000, 1587500,
+	/* 0x50-0x7F: from 1.6 to 3.95V with step 0.05V */
+	1600000, 1650000, 1700000, 1750000, 1800000, 1850000, 1900000, 1950000,
+	2000000, 2050000, 2100000, 2150000, 2200000, 2250000, 2300000, 2350000,
+	2400000, 2450000, 2500000, 2550000, 2600000, 2650000, 2700000, 2750000,
+	2800000, 2850000, 2900000, 2950000, 3000000, 3050000, 3100000, 3150000,
+	3200000, 3250000, 3300000,
+};
+
+static const unsigned int BUCK5_table[] = {
+	/* 0x00-0x4F: from 0.6 to 1.5875V with step 0.0125V */
+	600000, 612500, 625000, 637500, 650000, 662500, 675000, 687500,
+	700000, 712500, 725000, 737500, 750000, 762500, 775000, 787500,
+	800000, 812500, 825000, 837500, 850000, 862500, 875000, 887500,
+	900000, 912500, 925000, 937500, 950000, 962500, 975000, 987500,
+	1000000, 1012500, 1025000, 1037500, 1050000, 1062500, 1075000, 1087500,
+	1100000, 1112500, 1125000, 1137500, 1150000, 1162500, 1175000, 1187500,
+	1200000, 1212500, 1225000, 1237500, 1250000, 1262500, 1275000, 1287500,
+	1300000, 1312500, 1325000, 1337500, 1350000, 1362500, 1375000, 1387500,
+	1400000, 1412500, 1425000, 1437500, 1450000, 1462500, 1475000, 1487500,
+	1500000, 1512500, 1525000, 1537500, 1550000, 1562500, 1575000, 1587500,
+	/* 0x50-0x7F: from 1.6 to 3.95V with step 0.05V */
+	1600000, 1650000, 1700000, 1750000, 1800000, 1850000, 1900000, 1950000,
+	2000000, 2050000, 2100000, 2150000, 2200000, 2250000, 2300000, 2350000,
+	2400000, 2450000, 2500000, 2550000, 2600000, 2650000, 2700000, 2750000,
+	2800000, 2850000, 2900000, 2950000, 3000000, 3050000, 3100000, 3150000,
+	3200000, 3250000, 3300000, 3350000, 3400000, 3450000, 3500000, 3550000,
+	3600000, 3650000, 3700000, 3750000, 3800000, 3850000, 3900000, 3950000,
+};
+
+static const unsigned int LDO1_table[] = {
+	1700000, 1800000, 1900000, 2500000, 2800000, 2900000, 3100000, 3300000,
+};
+
+static const unsigned int LDO2_table[] = {
+	1700000, 1800000, 1900000, 2500000, 2800000, 2900000, 3100000, 3300000,
+};
+
+static const unsigned int LDO3_table[] = {
+	1200000, 1250000, 1700000, 1800000, 1850000, 1900000, 2500000, 2600000,
+	2700000, 2750000, 2800000, 2850000, 2900000, 3000000, 3100000, 3300000,
+};
+
+static const unsigned int LDO4_table[] = {
+	1200000, 1250000, 1700000, 1800000, 1850000, 1900000, 2500000, 2600000,
+	2700000, 2750000, 2800000, 2850000, 2900000, 3000000, 3100000, 3300000,
+};
+
+static const unsigned int LDO5_table[] = {
+	1200000, 1250000, 1700000, 1800000, 1850000, 1900000, 2500000, 2600000,
+	2700000, 2750000, 2800000, 2850000, 2900000, 3000000, 3100000, 3300000,
+};
+
+static const unsigned int LDO6_table[] = {
+	1200000, 1250000, 1700000, 1800000, 1850000, 1900000, 2500000, 2600000,
+	2700000, 2750000, 2800000, 2850000, 2900000, 3000000, 3100000, 3300000,
+};
+
+static const unsigned int LDO7_table[] = {
+	1200000, 1250000, 1700000, 1800000, 1850000, 1900000, 2500000, 2600000,
+	2700000, 2750000, 2800000, 2850000, 2900000, 3000000, 3100000, 3300000,
+};
+
+static const unsigned int LDO8_table[] = {
+	1200000, 1250000, 1700000, 1800000, 1850000, 1900000, 2500000, 2600000,
+	2700000, 2750000, 2800000, 2850000, 2900000, 3000000, 3100000, 3300000,
+};
+
+static const unsigned int LDO9_table[] = {
+	1200000, 1250000, 1700000, 1800000, 1850000, 1900000, 2500000, 2600000,
+	2700000, 2750000, 2800000, 2850000, 2900000, 3000000, 3100000, 3300000,
+};
+
+static const unsigned int LDO10_table[] = {
+	1200000, 1250000, 1700000, 1800000, 1850000, 1900000, 2500000, 2600000,
+	2700000, 2750000, 2800000, 2850000, 2900000, 3000000, 3100000, 3300000,
+};
+
+static const unsigned int LDO11_table[] = {
+	1200000, 1250000, 1700000, 1800000, 1850000, 1900000, 2500000, 2600000,
+	2700000, 2750000, 2800000, 2850000, 2900000, 3000000, 3100000, 3300000,
+};
+
+static const unsigned int LDO12_table[] = {
+	600000,  650000,  700000,  750000,  800000,  850000,  900000,  950000,
+	1000000, 1050000, 1100000, 1150000, 1200000, 1300000, 1400000, 1500000,
+};
+
+static const unsigned int LDO13_table[] = {
+	1700000, 1800000, 1900000, 2500000, 2800000, 2900000, 3100000, 3300000,
+};
+
+static const unsigned int LDO14_table[] = {
+	1700000, 1800000, 1900000, 2000000, 2100000, 2500000, 2700000, 2800000,
+};
+
+static const unsigned int VOUTSW_table[] = {
+};
+
+#if defined(CONFIG_CPU_PXA1L88) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+/* below 4 tables are fake table, only used in new dvc
+ * the voltage is logical value, not real value. and the
+ * smallest logical value is LEVEL0(int value is 1), and
+ * as the unit is uv, so smallest uV is 1000, others are x1000
+ */
+static const unsigned int BUCK1_AP_ACTIVE_table[] = {
+	1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000,
+};
+
+static const unsigned int BUCK1_AP_LPM_table[] = {
+	1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000,
+};
+
+static const unsigned int BUCK1_APSUB_IDLE_table[] = {
+	1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000,
+};
+
+static const unsigned int BUCK1_APSUB_SLEEP_table[] = {
+	1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000,
+};
+#endif
+
+static int pm822_list_voltage(struct regulator_dev *rdev, unsigned index)
+{
+	struct pm822_regulator_info *info = rdev_get_drvdata(rdev);
+	int ret = -EINVAL;
+
+	if (info->vol_table && (index < info->desc.n_voltages))
+		ret = info->vol_table[index];
+
+	return ret;
+}
+
+static int choose_voltage(struct pm822_regulator_info *info,
+			  int min_uV, int max_uV)
+{
+	int i, ret = -ENOENT;
+
+	if (info->vol_table) {
+		for (i = 0; i < info->desc.n_voltages; i++) {
+			if (!info->vol_table[i])
+				break;
+			if ((min_uV <= info->vol_table[i])
+			    && (max_uV >= info->vol_table[i])) {
+				ret = i;
+				break;
+			}
+		}
+	}
+	if (ret < 0)
+		dev_err(info->chip->dev,
+			"invalid voltage range (%d %d) uV\n", min_uV, max_uV);
+
+	return ret;
+}
+
+static int pm822_set_voltage(struct regulator_dev *rdev,
+			     int min_uV, int max_uV, unsigned *selector)
+{
+	struct pm822_regulator_info *info = rdev_get_drvdata(rdev);
+	uint8_t mask;
+	int ret;
+	unsigned int value;
+
+	if (info->desc.id == PM822_ID_VOUTSW)
+		return 0;
+
+	if (min_uV > max_uV) {
+		dev_err(info->chip->dev,
+			"invalid voltage range (%d, %d) uV\n", min_uV, max_uV);
+		return -EINVAL;
+	}
+
+#if defined(CONFIG_CPU_PXA1L88) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	if ((info->dvc != NULL) && (info->dvc->reg_dvc)
+	    && (info->desc.id >= PM822_ID_BUCK1_AP_ACTIVE)
+	    && (info->desc.id <= PM822_ID_BUCK1_APSUB_SLEEP)) {
+		info->dvc->set_dvc(info->desc.id, min_uV / 1000);
+		return 0;
+	}
+
+	ret = choose_voltage(info, min_uV, max_uV);
+	if (ret < 0)
+		return -EINVAL;
+	*selector = ret;
+	value = (ret << info->vol_shift);
+	mask = ((1 << info->vol_nbits) - 1) << info->vol_shift;
+	if ((info->dvc != NULL) && (info->dvc->reg_dvc)) {
+		/* BUCK3 and BUCK5 */
+		if (info->desc.id == PM822_ID_BUCK3) {
+			regmap_update_bits(info->map, info->vol_reg + 1, mask,
+					   value);
+			regmap_update_bits(info->map, info->vol_reg + 2, mask,
+					   value);
+			regmap_update_bits(info->map, info->vol_reg + 3, mask,
+					   value);
+		}
+
+		if (info->desc.id == PM822_ID_BUCK5) {
+			regmap_update_bits(info->map, info->vol_reg + 1, mask,
+					   value);
+			regmap_update_bits(info->map, info->vol_reg + 2, mask,
+					   value);
+			regmap_update_bits(info->map, info->vol_reg + 3, mask,
+					   value);
+		}
+	}
+
+	return regmap_update_bits(info->map, info->vol_reg, mask, value);
+#endif
+}
+
+static int pm822_get_voltage(struct regulator_dev *rdev)
+{
+	struct pm822_regulator_info *info = rdev_get_drvdata(rdev);
+	uint8_t val, mask;
+	int ret;
+	unsigned int value;
+
+	if (info->desc.id == PM822_ID_VOUTSW)
+		return 0;
+
+#if defined(CONFIG_CPU_PXA1L88) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	ret = regmap_read(info->map, info->vol_reg, &value);
+#endif
+	if (ret < 0)
+		return ret;
+
+	mask = ((1 << info->vol_nbits) - 1) << info->vol_shift;
+	val = (value & mask) >> info->vol_shift;
+
+	return pm822_list_voltage(rdev, val);
+}
+
+static int pm822_enable(struct regulator_dev *rdev)
+{
+	struct pm822_regulator_info *info = rdev_get_drvdata(rdev);
+
+	return regmap_update_bits(info->map, info->enable_reg,
+			1 << info->enable_bit, 1 << info->enable_bit);
+}
+
+static int pm822_disable(struct regulator_dev *rdev)
+{
+	struct pm822_regulator_info *info = rdev_get_drvdata(rdev);
+
+	return regmap_update_bits(info->map, info->enable_reg,
+				  1 << info->enable_bit, 0);
+}
+
+static int pm822_is_enabled(struct regulator_dev *rdev)
+{
+	struct pm822_regulator_info *info = rdev_get_drvdata(rdev);
+	int ret;
+	unsigned int val;
+
+	ret = regmap_read(info->map, info->enable_reg, &val);
+	if (ret < 0)
+		return ret;
+
+	return !!(val & (1 << info->enable_bit));
+}
+
+static int pm822_get_current_limit(struct regulator_dev *rdev)
+{
+	struct pm822_regulator_info *info = rdev_get_drvdata(rdev);
+	return info->max_uA;
+}
+
+static struct regulator_ops pm822_regulator_ops = {
+	.set_voltage = pm822_set_voltage,
+	.get_voltage = pm822_get_voltage,
+	.list_voltage = pm822_list_voltage,
+	.enable = pm822_enable,
+	.disable = pm822_disable,
+	.is_enabled = pm822_is_enabled,
+	.get_current_limit = pm822_get_current_limit,
+};
+
+#define PM822_REGULATOR(_id, shift, nbits, ereg, ebit, _dvc, amax)	\
+{									\
+	.desc	= {							\
+		.name	= #_id,						\
+		.ops	= &pm822_regulator_ops,				\
+		.type	= REGULATOR_VOLTAGE,				\
+		.id	= PM822_ID_##_id,				\
+		.owner	= THIS_MODULE,					\
+		.n_voltages = ARRAY_SIZE(_id##_table),			\
+	},								\
+	.vol_reg	= PM822_##_id,					\
+	.vol_shift	= (shift),					\
+	.vol_nbits	= (nbits),					\
+	.enable_reg	= PM822_##ereg,					\
+	.enable_bit	= (ebit),					\
+	.dvc_en		= _dvc,						\
+	.dvc_val	= PM822_DEF_DVC_VAL,				\
+	.max_uA		= (amax),					\
+	.vol_table	= (unsigned int *)&_id##_table,			\
+}
+
+static struct pm822_regulator_info pm822_regulator_info[] = {
+
+	PM822_REGULATOR(BUCK1,	0,	7,	BUCK_EN1,	0,	1,	3500000),
+	PM822_REGULATOR(BUCK2,	0,	7,	BUCK_EN1,	1,	0,	750000),
+	PM822_REGULATOR(BUCK3,	0,	7,	BUCK_EN1,	2,	1,	1500000),
+	PM822_REGULATOR(BUCK4,	0,	7,	BUCK_EN1,	3,	0,	750000),
+	PM822_REGULATOR(BUCK5,	0,	7,	BUCK_EN1,	4,	1,	1500000),
+
+	PM822_REGULATOR(LDO1,	0,	4,	LDO1_8_EN1,	0,	0,	100000),
+	PM822_REGULATOR(LDO2,	0,	4,	LDO1_8_EN1,	1,	0,	100000),
+	PM822_REGULATOR(LDO3,	0,	4,	LDO1_8_EN1,	2,	0,	400000),
+	PM822_REGULATOR(LDO4,	0,	4,	LDO1_8_EN1,	3,	0,	400000),
+	PM822_REGULATOR(LDO5,	0,	4,	LDO1_8_EN1,	4,	0,	200000),
+	PM822_REGULATOR(LDO6,	0,	4,	LDO1_8_EN1,	5,	0,	200000),
+	PM822_REGULATOR(LDO7,	0,	4,	LDO1_8_EN1,	6,	0,	100000),
+	PM822_REGULATOR(LDO8,	0,	4,	LDO1_8_EN1,	7,	0,	100000),
+	PM822_REGULATOR(LDO9,	0,	4,	LDO9_14_EN1,	0,	0,	200000),
+	PM822_REGULATOR(LDO10,	0,	4,	LDO9_14_EN1,	1,	0,	400000),
+	PM822_REGULATOR(LDO11,	0,	4,	LDO9_14_EN1,	2,	0,	200000),
+	PM822_REGULATOR(LDO12,	0,	4,	LDO9_14_EN1,	3,	0,	400000),
+	PM822_REGULATOR(LDO13,	0,	4,	LDO9_14_EN1,	4,	0,	100000),
+	PM822_REGULATOR(LDO14,	0,	3,	LDO9_14_EN1,	5,	0,	8000),
+	PM822_REGULATOR(VOUTSW,	0,	0,	MISC_EN1,	4,	0,	0),
+
+#if defined(CONFIG_CPU_PXA1L88) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	/* below 4 dvcs are fake, only used in new dvc */
+	PM822_REGULATOR(BUCK1_AP_ACTIVE, 0, 7, BUCK_EN1, 0, 0, 300000),
+	PM822_REGULATOR(BUCK1_AP_LPM, 0, 7, BUCK_EN1, 0, 0, 300000),
+	PM822_REGULATOR(BUCK1_APSUB_IDLE, 0, 7, BUCK_EN1, 0, 0, 300000),
+	PM822_REGULATOR(BUCK1_APSUB_SLEEP, 0, 7, BUCK_EN1, 0, 0, 300000),
+#endif
+};
+
+static int __devinit pm822_regulator_probe(struct platform_device *pdev)
+{
+	struct pm822_chip *chip = dev_get_drvdata(pdev->dev.parent);
+	struct pm822_regulator_info *info = NULL;
+	struct regulator_init_data *pdata = pdev->dev.platform_data;
+	struct pm822_platform_data *ppdata = (pdev->dev.parent)->platform_data;
+	struct resource *res;
+	int i;
+
+	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "No I/O resource!\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(pm822_regulator_info); i++) {
+		info = &pm822_regulator_info[i];
+		if (info->desc.id == res->start)
+			break;
+	}
+	if ((i < 0) || (i > PM822_ID_RG_MAX)) {
+		dev_err(&pdev->dev, "Failed to find regulator %d\n",
+			res->start);
+		return -EINVAL;
+	}
+#if defined(CONFIG_CPU_PXA1L88) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	info->dvc = ppdata->dvc;
+#endif
+
+	info->map = chip->subchip->regmap_power;
+	info->chip = chip;
+	info->regulator = regulator_register(&info->desc, &pdev->dev,
+					     pdata, info, NULL);
+	if (IS_ERR(info->regulator)) {
+		dev_err(&pdev->dev, "failed to register regulator %s\n",
+			info->desc.name);
+		return PTR_ERR(info->regulator);
+	}
+
+	platform_set_drvdata(pdev, info);
+	return 0;
+}
+
+static int __devexit pm822_regulator_remove(struct platform_device *pdev)
+{
+	struct pm822_regulator_info *info = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+	regulator_unregister(info->regulator);
+	return 0;
+}
+
+static struct platform_driver pm822_regulator_driver = {
+	.driver		= {
+		.name	= "88pm822-regulator",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= pm822_regulator_probe,
+	.remove		= __devexit_p(pm822_regulator_remove),
+};
+
+static int __init pm822_regulator_init(void)
+{
+	return platform_driver_register(&pm822_regulator_driver);
+}
+subsys_initcall(pm822_regulator_init);
+
+static void __exit pm822_regulator_exit(void)
+{
+	platform_driver_unregister(&pm822_regulator_driver);
+}
+module_exit(pm822_regulator_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Yipeng Yao <ypyao@marvell.com>");
+MODULE_DESCRIPTION("Regulator Driver for Marvell 88PM822 PMIC");
+MODULE_ALIAS("platform:88pm822-regulator");
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 36db5a44..b98ccd9e 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -137,10 +137,16 @@ config REGULATOR_ISL6271A
 
 config REGULATOR_88PM8607
 	bool "Marvell 88PM8607 Power regulators"
-	depends on MFD_88PM860X=y
+	depends on MFD_88PM860X
 	help
 	  This driver supports 88PM8607 voltage regulator chips.
 
+config REGULATOR_88PM800
+	bool "Marvell 88PM800 Power regulators"
+	depends on MFD_88PM800
+	help
+	  This driver supports 88PM800 voltage regulator chips.
+
 config REGULATOR_MAX1586
 	tristate "Maxim 1586/1587 voltage regulator"
 	depends on I2C
@@ -345,6 +351,13 @@ config REGULATOR_WM831X
 	  Support the voltage and current regulators of the WM831x series
 	  of PMIC devices.
 
+config REGULATOR_D2199
+	tristate "Dialog Semiconductor D2199 PMIC regulators"
+	depends on MFD_D2199
+	help
+	  Support the voltage and current regulators of the Dialog D2199
+	  multifunction device.
+
 config REGULATOR_WM8350
 	tristate "Wolfson Microelectronics WM8350 AudioPlus PMIC"
 	depends on MFD_WM8350
@@ -366,5 +379,34 @@ config REGULATOR_WM8994
 	  This driver provides support for the voltage regulators on the
 	  WM8994 CODEC.
 
+config REGULATOR_FAN53555
+	tristate "Fairchild FAN5355 Regulator"
+	depends on I2C
+	help
+	  This driver supports Fairchild FAN5355 Digitally Programmable
+	  TinyBuck Regulator. The FAN53555 is a step-down switching voltage
+	  regulator that delivers a digitally programmable output from an
+	  input voltage supply of 2.5V to 5.5V. The output voltage is
+	  programmed through an I2C interface.
+
+config REGULATOR_88PG870
+	tristate "Marvell 88PG870 DC to DC Regulator"
+	depends on I2C
+	select REGMAP_I2C
+	help
+	  This driver controls a 88PG870 voltage output regulator via I2C bus.
+
+config REGULATOR_88PM822
+	bool "Marvell 88PM822 Power regulators"
+	depends on MFD_88PM822
+	help
+	  This driver supports 88PM822 voltage regulator chips.
+
+config REGULATOR_RT5033
+	depends on MFD_RT5033
+	tristate "RT5033 LDO and Buck"
+	help
+	  Say y here to support the regulators found on the Richtek RT5033 I/F PMIC.
+
 endif
 
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 94b52745..dd28a449 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_REGULATOR_USERSPACE_CONSUMER) += userspace-consumer.o
 
 obj-$(CONFIG_REGULATOR_GPIO) += gpio-regulator.o
 obj-$(CONFIG_REGULATOR_88PM8607) += 88pm8607.o
+obj-$(CONFIG_REGULATOR_88PM800) += 88pm800.o
 obj-$(CONFIG_REGULATOR_AAT2870) += aat2870-regulator.o
 obj-$(CONFIG_REGULATOR_AB3100) += ab3100.o
 obj-$(CONFIG_REGULATOR_AB8500)	+= ab8500.o
@@ -30,6 +31,7 @@ obj-$(CONFIG_REGULATOR_MAX8925) += max8925-regulator.o
 obj-$(CONFIG_REGULATOR_MAX8952) += max8952.o
 obj-$(CONFIG_REGULATOR_MAX8997) += max8997.o
 obj-$(CONFIG_REGULATOR_MAX8998) += max8998.o
+obj-$(CONFIG_REGULATOR_D2199)	+= d2199-regulator.o
 obj-$(CONFIG_REGULATOR_MC13783) += mc13783-regulator.o
 obj-$(CONFIG_REGULATOR_MC13892) += mc13892-regulator.o
 obj-$(CONFIG_REGULATOR_MC13XXX_CORE) +=  mc13xxx-regulator-core.o
@@ -52,6 +54,9 @@ obj-$(CONFIG_REGULATOR_WM831X) += wm831x-ldo.o
 obj-$(CONFIG_REGULATOR_WM8350) += wm8350-regulator.o
 obj-$(CONFIG_REGULATOR_WM8400) += wm8400-regulator.o
 obj-$(CONFIG_REGULATOR_WM8994) += wm8994-regulator.o
-
+obj-$(CONFIG_REGULATOR_FAN53555) += fan53555.o
+obj-$(CONFIG_REGULATOR_88PG870) += 88pg870.o
+obj-$(CONFIG_REGULATOR_88PM822) += 88pm822.o
+obj-$(CONFIG_REGULATOR_RT5033) += rt5033_regulator.o
 
 ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 8c8377d5..024a2f5e 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -135,6 +135,33 @@ config RTC_DRV_88PM860X
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-88pm860x.
 
+config RTC_DRV_D2199
+	tristate "Dialog Semiconductor D2199"
+	depends on MFD_D2199
+	help
+	  If you say yes here you get support for RTC function of the
+	  Dialog Semiconductor D2199 multifunction device.
+
+config RTC_DRV_88PM80X
+	tristate "Marvell 88PM80x"
+	depends on RTC_CLASS && I2C && MFD_88PM800
+	help
+	  If you say yes here you get support for RTC function in Marvell
+	  88PM80x chips.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-88pm80x.
+
+config RTC_DRV_88PM822
+	tristate "Marvell 88PM822"
+	depends on RTC_CLASS && I2C && MFD_88PM822
+	help
+	  If you say yes here you get support for RTC function in Marvell
+	  88PM822 chips.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-88pm822.
+
 config RTC_DRV_DS1307
 	tristate "Dallas/Maxim DS1307/37/38/39/40, ST M41T00, EPSON RX-8025"
 	help
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 727ae778..84f6b101 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -15,7 +15,10 @@ rtc-core-$(CONFIG_RTC_INTF_SYSFS) += rtc-sysfs.o
 
 # Keep the list ordered.
 
+obj-$(CONFIG_RTC_DRV_SA1100)	+= rtc-sa1100.o
 obj-$(CONFIG_RTC_DRV_88PM860X)  += rtc-88pm860x.o
+obj-$(CONFIG_RTC_DRV_88PM80X)	+= rtc-88pm80x.o
+obj-$(CONFIG_RTC_DRV_88PM822)	+= rtc-88pm822.o
 obj-$(CONFIG_RTC_DRV_AB3100)	+= rtc-ab3100.o
 obj-$(CONFIG_RTC_DRV_AB8500)	+= rtc-ab8500.o
 obj-$(CONFIG_RTC_DRV_AT32AP700X)+= rtc-at32ap700x.o
@@ -31,6 +34,7 @@ obj-$(CONFIG_RTC_DRV_DA9052)	+= rtc-da9052.o
 obj-$(CONFIG_RTC_DRV_DAVINCI)	+= rtc-davinci.o
 obj-$(CONFIG_RTC_DRV_DM355EVM)	+= rtc-dm355evm.o
 obj-$(CONFIG_RTC_DRV_VRTC)	+= rtc-mrst.o
+obj-$(CONFIG_RTC_DRV_D2199)	+= rtc-d2199.o
 obj-$(CONFIG_RTC_DRV_DS1216)	+= rtc-ds1216.o
 obj-$(CONFIG_RTC_DRV_DS1286)	+= rtc-ds1286.o
 obj-$(CONFIG_RTC_DRV_DS1302)	+= rtc-ds1302.o
@@ -93,7 +97,6 @@ obj-$(CONFIG_RTC_DRV_RX8025)	+= rtc-rx8025.o
 obj-$(CONFIG_RTC_DRV_RX8581)	+= rtc-rx8581.o
 obj-$(CONFIG_RTC_DRV_S35390A)	+= rtc-s35390a.o
 obj-$(CONFIG_RTC_DRV_S3C)	+= rtc-s3c.o
-obj-$(CONFIG_RTC_DRV_SA1100)	+= rtc-sa1100.o
 obj-$(CONFIG_RTC_DRV_SH)	+= rtc-sh.o
 obj-$(CONFIG_RTC_DRV_SPEAR)	+= rtc-spear.o
 obj-$(CONFIG_RTC_DRV_STARFIRE)	+= rtc-starfire.o
diff --git a/drivers/rtc/rtc-88pm822.c b/drivers/rtc/rtc-88pm822.c
new file mode 100755
index 00000000..396b9273
--- /dev/null
+++ b/drivers/rtc/rtc-88pm822.c
@@ -0,0 +1,400 @@
+/*
+ * Real Time Clock driver for Marvell 88pm822 PMIC
+ *
+ * Copyright (c) 2012 Marvell International Ltd.
+ *  Wenzeng Chen<wzch@marvell.com>
+ *  Qiao Zhou <zhouqiao@marvell.com>
+ *  Hongyan Song<hysong@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/regmap.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/88pm822.h>
+#include <linux/rtc.h>
+
+#if defined(CONFIG_RTC_CHN_ALARM_BOOT)
+#include <linux/reboot.h>
+#include <linux/workqueue.h>
+#endif
+
+struct pm822_rtc_info {
+	struct pm822_chip *chip;
+	struct regmap *map;
+	struct rtc_device *rtc_dev;
+	struct device *dev;
+	struct delayed_work calib_work;
+
+	int irq;
+	int vrtc;
+	int (*sync) (unsigned int ticks);
+};
+
+#if defined(CONFIG_RTC_CHN_ALARM_BOOT)
+#if defined(CONFIG_BATTERY_SAMSUNG)
+extern unsigned int lpcharge;
+#else
+extern int spa_lpm_charging_mode_get(void);
+#endif
+struct work_struct reboot_work;
+static void pm80x_rtc_reboot_work(struct work_struct *work)
+{
+	kernel_restart("alarm");
+}
+#endif
+
+static irqreturn_t rtc_update_handler(int irq, void *data)
+{
+	struct pm822_rtc_info *info = (struct pm822_rtc_info *)data;
+	int mask;
+
+	mask = PM822_ALARM | PM822_ALARM_WAKEUP;
+	regmap_update_bits(info->map, PM822_RTC_CTRL, mask | PM822_ALARM1_EN,
+			   mask);
+	rtc_update_irq(info->rtc_dev, 1, RTC_AF);
+	
+#if defined(CONFIG_RTC_CHN_ALARM_BOOT)
+#if defined(CONFIG_BATTERY_SAMSUNG)
+	if (lpcharge)
+#else
+	if(spa_lpm_charging_mode_get())
+#endif
+		schedule_work(&reboot_work);
+#endif
+
+	return IRQ_HANDLED;
+}
+
+static int pm822_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)
+{
+	struct pm822_rtc_info *info = dev_get_drvdata(dev);
+
+	if (enabled)
+		regmap_update_bits(info->map, PM822_RTC_CTRL,
+				   PM822_ALARM1_EN, PM822_ALARM1_EN);
+	else
+		regmap_update_bits(info->map, PM822_RTC_CTRL,
+				   PM822_ALARM1_EN, 0);
+	return 0;
+}
+
+static int pm822_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct pm822_rtc_info *info = dev_get_drvdata(dev);
+	unsigned char buf[4];
+	unsigned long ticks, data;
+	long base;
+
+	regmap_raw_read(info->map, PM822_USER_DATA1, buf, 4);
+	base = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
+	dev_dbg(info->dev, "%x-%x-%x-%x\n", buf[0], buf[1], buf[2], buf[3]);
+
+	/* load 32-bit read-only counter */
+	regmap_raw_read(info->map, PM822_RTC_COUNTER1, buf, 4);
+	data = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
+	ticks = base + data;
+	dev_dbg(info->dev, "get base:0x%lx, RO count:0x%lx, ticks:0x%lx\n",
+		base, data, ticks);
+	rtc_time_to_tm(ticks, tm);
+	return 0;
+}
+
+static int pm822_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct pm822_rtc_info *info = dev_get_drvdata(dev);
+	unsigned char buf[4];
+	unsigned long ticks, data;
+	long base;
+
+	if ((tm->tm_year < 70) || (tm->tm_year > 138)) {
+		dev_dbg(info->dev,
+			"Set time %d out of range. Please set time between 1970 to 2038.\n",
+			1900 + tm->tm_year);
+		return -EINVAL;
+	}
+	rtc_tm_to_time(tm, &ticks);
+
+	/* load 32-bit read-only counter */
+	regmap_raw_read(info->map, PM822_RTC_COUNTER1, buf, 4);
+	data = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
+	base = ticks - data;
+	dev_dbg(info->dev, "set base:0x%lx, RO count:0x%lx, ticks:0x%lx\n",
+		base, data, ticks);
+	buf[0] = base & 0xFF;
+	buf[1] = (base >> 8) & 0xFF;
+	buf[2] = (base >> 16) & 0xFF;
+	buf[3] = (base >> 24) & 0xFF;
+	regmap_raw_write(info->map, PM822_USER_DATA1, buf, 4);
+
+	if (info->sync)
+		info->sync(ticks);
+
+	return 0;
+}
+
+static int pm822_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct pm822_rtc_info *info = dev_get_drvdata(dev);
+	unsigned char buf[4];
+	unsigned long ticks, base, data;
+	int ret;
+	unsigned int val;
+
+	regmap_raw_read(info->map, PM822_USER_DATA1, buf, 4);
+	base = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
+	dev_dbg(info->dev, "%x-%x-%x-%x\n", buf[0], buf[1], buf[2], buf[3]);
+
+	regmap_raw_read(info->map, PM822_RTC_EXPIRE1_1, buf, 4);
+	data = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
+	ticks = base + data;
+	dev_dbg(info->dev, "get base:0x%lx, RO count:0x%lx, ticks:0x%lx\n",
+		base, data, ticks);
+
+	rtc_time_to_tm(ticks, &alrm->time);
+	ret = regmap_read(info->map, PM822_RTC_CTRL, &val);
+	if (ret < 0) {
+		dev_err(info->dev, "Failed to rtc ctrl: %d\n", ret);
+		return ret;
+	}
+
+	alrm->enabled = (val & PM822_ALARM1_EN) ? 1 : 0;
+	alrm->pending = (val & (PM822_ALARM | PM822_ALARM_WAKEUP)) ? 1 : 0;
+	return 0;
+}
+
+static int pm822_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct pm822_rtc_info *info = dev_get_drvdata(dev);
+	unsigned long ticks, base, data;
+	unsigned char buf[4];
+	int mask;
+
+	regmap_update_bits(info->map, PM822_RTC_CTRL, PM822_ALARM1_EN, 0);
+
+	regmap_raw_read(info->map, PM822_USER_DATA1, buf, 4);
+	base = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
+	dev_dbg(info->dev, "%x-%x-%x-%x\n", buf[0], buf[1], buf[2], buf[3]);
+
+	/* get new ticks for alarm */
+	rtc_tm_to_time(&alrm->time, &ticks);
+	dev_dbg(info->dev, "%s, alarm time: %lu\n", __func__, ticks);
+	data = ticks - base;
+
+	buf[0] = data & 0xff;
+	buf[1] = (data >> 8) & 0xff;
+	buf[2] = (data >> 16) & 0xff;
+	buf[3] = (data >> 24) & 0xff;
+	regmap_raw_write(info->map, PM822_RTC_EXPIRE1_1, buf, 4);
+	if (alrm->enabled) {
+		mask = PM822_ALARM | PM822_ALARM_WAKEUP | PM822_ALARM1_EN;
+		regmap_update_bits(info->map, PM822_RTC_CTRL, mask, mask);
+	} else {
+		mask = PM822_ALARM | PM822_ALARM_WAKEUP | PM822_ALARM1_EN;
+		regmap_update_bits(info->map, PM822_RTC_CTRL, mask,
+				   PM822_ALARM | PM822_ALARM_WAKEUP);
+	}
+	return 0;
+}
+
+static const struct rtc_class_ops pm822_rtc_ops = {
+	.read_time = pm822_rtc_read_time,
+	.set_time = pm822_rtc_set_time,
+	.read_alarm = pm822_rtc_read_alarm,
+	.set_alarm = pm822_rtc_set_alarm,
+	.alarm_irq_enable = pm822_rtc_alarm_irq_enable,
+};
+
+#ifdef CONFIG_PM
+static int pm822_rtc_suspend(struct device *dev)
+{
+	return pm822_dev_suspend(dev);
+}
+
+static int pm822_rtc_resume(struct device *dev)
+{
+	return pm822_dev_resume(dev);
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(pm822_rtc_pm_ops, pm822_rtc_suspend, pm822_rtc_resume);
+
+static int __devinit pm822_rtc_probe(struct platform_device *pdev)
+{
+	struct pm822_chip *chip = dev_get_drvdata(pdev->dev.parent);
+	struct pm822_platform_data *pm822_pdata;
+	struct pm822_rtc_pdata *pdata = NULL;
+	struct pm822_rtc_info *info;
+	struct rtc_time tm;
+	unsigned long ticks = 0;
+	int irq, ret;
+	unsigned long now_ticks = 0, default_ticks = 0;
+	struct rtc_time default_time; 
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL)
+		dev_warn(&pdev->dev, "No platform data!\n");
+
+	info =
+	    devm_kzalloc(&pdev->dev, sizeof(struct pm822_rtc_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "No IRQ resource!\n");
+		ret = -EINVAL;
+		goto out;
+	}
+	info->irq = irq + chip->irq_base;
+
+	info->chip = chip;
+	info->map = chip->regmap;
+	if (!info->map) {
+		dev_err(&pdev->dev, "no regmap!\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	info->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, info);
+
+	ret = pm822_rtc_read_time(&pdev->dev, &tm);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to read initial time.\n");
+		goto out;
+	}
+
+#if 1
+	rtc_tm_to_time(&tm, &now_ticks);
+	default_time.tm_year = 100;
+	default_time.tm_mon = 11;
+	default_time.tm_mday = 31;
+	default_time.tm_hour = 0;
+	default_time.tm_min = 0;
+	default_time.tm_sec = 0;
+	rtc_tm_to_time(&default_time, &default_ticks);
+	
+	if((tm.tm_year < 70) || (tm.tm_year > 138) || (now_ticks <= default_ticks)) {
+		printk("%s now : %ld default : %ld\n", __func__, now_ticks, default_ticks);
+		tm.tm_year = 114;
+		tm.tm_mon = 0;
+		tm.tm_mday = 1;
+		tm.tm_hour = 0;
+		tm.tm_min = 0;
+		tm.tm_sec = 0;
+		ret = pm822_rtc_set_time(&pdev->dev,&tm);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Failed to set initial time.\n");
+			goto out;
+		}
+	}
+#else	
+	if ((tm.tm_year < 70) || (tm.tm_year > 138)) {
+		tm.tm_year = 70;
+		tm.tm_mon = 0;
+		tm.tm_mday = 1;
+		tm.tm_hour = 0;
+		tm.tm_min = 0;
+		tm.tm_sec = 0;
+		ret = pm822_rtc_set_time(&pdev->dev, &tm);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Failed to set initial time.\n");
+			goto out;
+		}
+	}
+#endif
+
+	rtc_tm_to_time(&tm, &ticks);
+	if (pdata && pdata->sync) {
+		pdata->sync(ticks);
+		info->sync = pdata->sync;
+	}
+
+	info->rtc_dev = rtc_device_register("88pm822-rtc", &pdev->dev,
+					    &pm822_rtc_ops, THIS_MODULE);
+	ret = PTR_ERR(info->rtc_dev);
+	if (IS_ERR(info->rtc_dev)) {
+		dev_err(&pdev->dev, "Failed to register RTC device: %d\n", ret);
+		goto out;
+	}
+	/*
+	 * enable internal XO instead of internal 3.25MHz clock since it can
+	 * free running in PMIC power-down state.
+	 */
+	regmap_update_bits(info->map, PM822_RTC_CTRL, PM822_RTC1_USE_XO,
+			   PM822_RTC1_USE_XO);
+
+	if (pdev->dev.parent->platform_data) {
+		pm822_pdata = pdev->dev.parent->platform_data;
+		pdata = pm822_pdata->rtc;
+		if (pdata)
+			info->rtc_dev->dev.platform_data = &pdata->rtc_wakeup;
+	}
+
+#if defined(CONFIG_RTC_CHN_ALARM_BOOT)
+#if defined(CONFIG_BATTERY_SAMSUNG)
+	if (lpcharge)
+#else
+	if(spa_lpm_charging_mode_get())
+#endif
+	{
+		INIT_WORK(&reboot_work, pm80x_rtc_reboot_work);
+	}
+#endif
+
+	ret = pm822_request_irq(chip, info->irq, rtc_update_handler,
+				IRQF_ONESHOT, "88pm822-rtc", info);
+	if (ret < 0) {
+		dev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",
+			info->irq, ret);
+		goto out_rtc;
+	}
+
+	device_init_wakeup(&pdev->dev, 1);
+
+	return 0;
+out_rtc:
+	pm822_free_irq(chip, info->irq, info);
+out:
+	return ret;
+}
+
+static int __devexit pm822_rtc_remove(struct platform_device *pdev)
+{
+	struct pm822_rtc_info *info = platform_get_drvdata(pdev);
+	platform_set_drvdata(pdev, NULL);
+	rtc_device_unregister(info->rtc_dev);
+	pm822_free_irq(info->chip, info->irq, info);
+	return 0;
+}
+
+static struct platform_driver pm822_rtc_driver = {
+	.driver = {
+		   .name = "88pm822-rtc",
+		   .owner = THIS_MODULE,
+		   .pm = &pm822_rtc_pm_ops,
+		   },
+	.probe = pm822_rtc_probe,
+	.remove = __devexit_p(pm822_rtc_remove),
+};
+
+module_platform_driver(pm822_rtc_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Marvell 88PM822 RTC driver");
+MODULE_AUTHOR("Hongyan Song <hysong@marvell.com>");
+MODULE_ALIAS("platform:88pm822-rtc");
diff --git a/drivers/rtc/rtc-sa1100.c b/drivers/rtc/rtc-sa1100.c
index 50a5c4ad..ead9beb0 100644
--- a/drivers/rtc/rtc-sa1100.c
+++ b/drivers/rtc/rtc-sa1100.c
@@ -34,6 +34,7 @@
 #include <linux/pm.h>
 #include <linux/bitops.h>
 #include <linux/io.h>
+#include <linux/delay.h>
 
 #include <mach/hardware.h>
 #include <mach/irqs.h>
@@ -42,6 +43,15 @@
 #include <mach/regs-rtc.h>
 #endif
 
+#ifdef CONFIG_FAKE_SYSTEMOFF
+#include <linux/power/fake-sysoff.h>
+#endif
+
+#if defined(CONFIG_SPA)
+#include <mach/spa.h>
+static void (*spa_external_event)(int, int) = NULL;
+#endif
+
 #define RTC_DEF_DIVIDER		(32768 - 1)
 #define RTC_DEF_TRIM		0
 #define RTC_FREQ		1024
@@ -61,6 +71,12 @@ static irqreturn_t sa1100_rtc_interrupt(int irq, void *dev_id)
 	unsigned int rtsr;
 	unsigned long events = 0;
 
+#if defined(CONFIG_SPA)
+	printk("sa1100_rtc_interrupt\n");
+
+	if(spa_external_event)
+		spa_external_event(SPA_CATEGORY_BATTERY, SPA_BATTERY_EVENT_SLEEP_MONITOR);
+#endif
 	spin_lock(&info->lock);
 
 	rtsr = RTSR;
@@ -102,51 +118,6 @@ static irqreturn_t sa1100_rtc_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int sa1100_rtc_open(struct device *dev)
-{
-	struct sa1100_rtc *info = dev_get_drvdata(dev);
-	struct rtc_device *rtc = info->rtc;
-	int ret;
-
-	ret = clk_prepare_enable(info->clk);
-	if (ret)
-		goto fail_clk;
-	ret = request_irq(info->irq_1hz, sa1100_rtc_interrupt, 0, "rtc 1Hz", dev);
-	if (ret) {
-		dev_err(dev, "IRQ %d already in use.\n", info->irq_1hz);
-		goto fail_ui;
-	}
-	ret = request_irq(info->irq_alarm, sa1100_rtc_interrupt, 0, "rtc Alrm", dev);
-	if (ret) {
-		dev_err(dev, "IRQ %d already in use.\n", info->irq_alarm);
-		goto fail_ai;
-	}
-	rtc->max_user_freq = RTC_FREQ;
-	rtc_irq_set_freq(rtc, NULL, RTC_FREQ);
-
-	return 0;
-
- fail_ai:
-	free_irq(info->irq_1hz, dev);
- fail_ui:
-	clk_disable_unprepare(info->clk);
- fail_clk:
-	return ret;
-}
-
-static void sa1100_rtc_release(struct device *dev)
-{
-	struct sa1100_rtc *info = dev_get_drvdata(dev);
-
-	spin_lock_irq(&info->lock);
-	RTSR = 0;
-	spin_unlock_irq(&info->lock);
-
-	free_irq(info->irq_alarm, dev);
-	free_irq(info->irq_1hz, dev);
-	clk_disable_unprepare(info->clk);
-}
-
 static int sa1100_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)
 {
 	struct sa1100_rtc *info = dev_get_drvdata(dev);
@@ -171,9 +142,14 @@ static int sa1100_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	unsigned long time;
 	int ret;
 
+	if (tm->tm_year > 138)
+		return -EINVAL;
+
 	ret = rtc_tm_to_time(tm, &time);
 	if (ret == 0)
 		RCNR = time;
+
+	udelay(200);
 	return ret;
 }
 
@@ -218,8 +194,6 @@ static int sa1100_rtc_proc(struct device *dev, struct seq_file *seq)
 }
 
 static const struct rtc_class_ops sa1100_rtc_ops = {
-	.open = sa1100_rtc_open,
-	.release = sa1100_rtc_release,
 	.read_time = sa1100_rtc_read_time,
 	.set_time = sa1100_rtc_set_time,
 	.read_alarm = sa1100_rtc_read_alarm,
@@ -303,7 +277,35 @@ static int sa1100_rtc_probe(struct platform_device *pdev)
 	 * the corresponding bits in RTSR. */
 	RTSR = RTSR_AL | RTSR_HZ;
 
+	ret = clk_prepare_enable(info->clk);
+	if (ret)
+		goto err_nortc;
+	ret = request_irq(info->irq_1hz, sa1100_rtc_interrupt, 0, "rtc 1Hz", &pdev->dev);
+	if (ret) {
+		dev_err(&pdev->dev, "IRQ %d already in use.\n", info->irq_1hz);
+		goto err_ui;
+	}
+	ret = request_irq(info->irq_alarm, sa1100_rtc_interrupt, 0, "rtc Alrm", &pdev->dev);
+	if (ret) {
+		dev_err(&pdev->dev, "IRQ %d already in use.\n", info->irq_alarm);
+		goto err_ai;
+	}
+	rtc->max_user_freq = RTC_FREQ;
+	rtc_irq_set_freq(rtc, NULL, RTC_FREQ);
+
+#if defined(CONFIG_SPA)
+	printk("sa1100_rtc_probe get ext event\n");
+	spa_external_event = spa_get_external_event_handler();
+#endif
+
 	return 0;
+
+err_ai:
+	free_irq(info->irq_1hz, &pdev->dev);
+err_ui:
+	clk_disable_unprepare(info->clk);
+err_nortc:
+	rtc_device_unregister(info->rtc);
 err_dev:
 	platform_set_drvdata(pdev, NULL);
 	clk_put(info->clk);
@@ -317,6 +319,14 @@ static int sa1100_rtc_remove(struct platform_device *pdev)
 	struct sa1100_rtc *info = platform_get_drvdata(pdev);
 
 	if (info) {
+		spin_lock_irq(&info->lock);
+		RTSR = 0;
+		spin_unlock_irq(&info->lock);
+
+		free_irq(info->irq_alarm, &pdev->dev);
+		free_irq(info->irq_1hz, &pdev->dev);
+		clk_disable_unprepare(info->clk);
+
 		rtc_device_unregister(info->rtc);
 		clk_put(info->clk);
 		platform_set_drvdata(pdev, NULL);
@@ -327,9 +337,18 @@ static int sa1100_rtc_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
+#ifdef CONFIG_FAKE_SYSTEMOFF
+static bool dev_wakeup;
+#endif
 static int sa1100_rtc_suspend(struct device *dev)
 {
 	struct sa1100_rtc *info = dev_get_drvdata(dev);
+#ifdef CONFIG_FAKE_SYSTEMOFF
+	if (fake_sysoff_status_query()) {
+		dev_wakeup = device_can_wakeup(dev);
+		device_set_wakeup_capable(dev, false);
+	}
+#endif
 	if (device_may_wakeup(dev))
 		enable_irq_wake(info->irq_alarm);
 	return 0;
@@ -340,6 +359,10 @@ static int sa1100_rtc_resume(struct device *dev)
 	struct sa1100_rtc *info = dev_get_drvdata(dev);
 	if (device_may_wakeup(dev))
 		disable_irq_wake(info->irq_alarm);
+#ifdef CONFIG_FAKE_SYSTEMOFF
+	if (fake_sysoff_status_query())
+		device_set_wakeup_capable(dev, dev_wakeup);
+#endif
 	return 0;
 }
 
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 00c02403..ac8b9eec 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -275,8 +275,8 @@ config SPI_PPC4xx
 
 config SPI_PXA2XX
 	tristate "PXA2xx SSP SPI master"
-	depends on (ARCH_PXA || (X86_32 && PCI)) && EXPERIMENTAL
-	select PXA_SSP if ARCH_PXA
+	depends on (ARCH_PXA || ARCH_MMP || (X86_32 && PCI)) && EXPERIMENTAL
+	select PXA_SSP if ARCH_PXA || ARCH_MMP
 	help
 	  This enables using a PXA2xx or Sodaville SSP port as a SPI master
 	  controller. The driver can be configured to use any SSP port and
diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c
index dc25bee8..b000cd61 100644
--- a/drivers/spi/spi-pxa2xx.c
+++ b/drivers/spi/spi-pxa2xx.c
@@ -34,7 +34,7 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/delay.h>
-
+#include <plat/pm.h>
 
 MODULE_AUTHOR("Stephen Street");
 MODULE_DESCRIPTION("PXA2xx SSP SPI Controller");
@@ -47,9 +47,9 @@ MODULE_ALIAS("platform:pxa2xx-spi");
 
 #define DMA_INT_MASK		(DCSR_ENDINTR | DCSR_STARTINTR | DCSR_BUSERR)
 #define RESET_DMA_CHANNEL	(DCSR_NODESC | DMA_INT_MASK)
-#define IS_DMA_ALIGNED(x)	((((u32)(x)) & 0x07) == 0)
+#define IS_DMA_ALIGNED(x)	((((u32)(x)) & 0x3F) == 0)
 #define MAX_DMA_LEN		8191
-#define DMA_ALIGNMENT		8
+#define DMA_ALIGNMENT		64
 
 /*
  * for testing SSCR1 changes that require SSP restart, basically
@@ -105,6 +105,7 @@ struct driver_data {
 	/* DMA setup stuff */
 	int rx_channel;
 	int tx_channel;
+	u32 *alloc_dma_buf;
 	u32 *null_dma_buf;
 
 	/* SSP register addresses */
@@ -148,6 +149,8 @@ struct driver_data {
 	int (*read)(struct driver_data *drv_data);
 	irqreturn_t (*transfer_handler)(struct driver_data *drv_data);
 	void (*cs_control)(u32 command);
+	struct pm_qos_request qos_idle;
+	int constraint_is_set;
 };
 
 struct chip_data {
@@ -173,6 +176,37 @@ struct chip_data {
 	void (*cs_control)(u32 command);
 };
 
+static void set_dvfm_constraint(struct driver_data *drv_data)
+{
+	if (drv_data->constraint_is_set == 0) {
+		drv_data->constraint_is_set = 1;
+		pm_qos_update_request(&drv_data->qos_idle,
+				PM_QOS_CPUIDLE_BLOCK_DDR_VALUE);
+	}
+}
+
+static void unset_dvfm_constraint(struct driver_data *drv_data)
+{
+	if (drv_data->constraint_is_set) {
+		drv_data->constraint_is_set = 0;
+		pm_qos_update_request(&drv_data->qos_idle,
+				PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+	}
+}
+
+static void init_dvfm_constraint(struct driver_data *drv_data)
+{
+	drv_data->constraint_is_set = 0;
+	drv_data->qos_idle.name = drv_data->pdev->name;
+	pm_qos_add_request(&drv_data->qos_idle, PM_QOS_CPUIDLE_BLOCK,
+			PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+}
+
+static void deinit_dvfm_constraint(struct driver_data *drv_data)
+{
+	pm_qos_remove_request(&drv_data->qos_idle);
+}
+
 static void pump_messages(struct work_struct *work);
 
 static void cs_assert(struct driver_data *drv_data)
@@ -228,6 +262,14 @@ static int pxa25x_ssp_comp(struct driver_data *drv_data)
 	return 0;
 }
 
+static int is_pxa988_ssp(struct driver_data *drv_data)
+{
+	if (drv_data->ssp_type == PXA988_SSP)
+		return 1;
+	return 0;
+}
+
+
 static int flush(struct driver_data *drv_data)
 {
 	unsigned long limit = loops_per_jiffy << 1;
@@ -503,6 +545,7 @@ static void giveback(struct driver_data *drv_data)
 		msg->complete(msg->context);
 
 	drv_data->cur_chip = NULL;
+	unset_dvfm_constraint(drv_data);
 }
 
 static int wait_ssp_rx_stall(void const __iomem *ioaddr)
@@ -810,7 +853,7 @@ static irqreturn_t ssp_int(int irq, void *dev_id)
 			write_SSTO(0, reg);
 		write_SSSR_CS(drv_data, drv_data->clear_sr);
 
-		dev_err(&drv_data->pdev->dev, "bad message state "
+		dev_err(&drv_data->pdev->dev, "bad message state "\
 			"in interrupt handler\n");
 
 		/* Never fail */
@@ -1119,19 +1162,26 @@ static void pump_transfers(unsigned long data)
 		DCSR(drv_data->tx_channel) = RESET_DMA_CHANNEL;
 		DSADR(drv_data->tx_channel) = drv_data->tx_dma;
 		DTADR(drv_data->tx_channel) = drv_data->ssdr_physical;
-		if (drv_data->tx == drv_data->null_dma_buf)
-			/* No source address increment */
-			DCMD(drv_data->tx_channel) = DCMD_FLOWTRG
+		if (!is_pxa988_ssp(drv_data)) {
+			if (drv_data->tx == drv_data->null_dma_buf)
+				/* No source address increment */
+				DCMD(drv_data->tx_channel) = DCMD_FLOWTRG
 							| drv_data->dma_width
 							| dma_burst
 							| drv_data->len;
-		else
+			else
+				DCMD(drv_data->tx_channel) = DCMD_INCSRCADDR
+							| DCMD_FLOWTRG
+							| drv_data->dma_width
+							| dma_burst
+							| drv_data->len;
+		} else {
 			DCMD(drv_data->tx_channel) = DCMD_INCSRCADDR
 							| DCMD_FLOWTRG
 							| drv_data->dma_width
 							| dma_burst
 							| drv_data->len;
-
+		}
 		/* Enable dma end irqs on SSP to detect end of transfer */
 		if (drv_data->ssp_type == PXA25x_SSP)
 			DCMD(drv_data->tx_channel) |= DCMD_ENDIRQEN;
@@ -1169,6 +1219,7 @@ static void pump_transfers(unsigned long data)
 			write_SSTO(chip->timeout, reg);
 	}
 
+	set_dvfm_constraint(drv_data);	/*disable system to idle while DMA */
 	cs_assert(drv_data);
 
 	/* after chip select, release the data by enabling service
@@ -1319,7 +1370,7 @@ static int setup(struct spi_device *spi)
 
 		if (drv_data->ssp_type == CE4100_SSP) {
 			if (spi->chip_select > 4) {
-				dev_err(&spi->dev, "failed setup: "
+				dev_err(&spi->dev, "failed setup: "\
 				"cs number must not be > 4.\n");
 				kfree(chip);
 				return -EINVAL;
@@ -1349,6 +1400,8 @@ static int setup(struct spi_device *spi)
 			rx_thres = chip_info->rx_threshold;
 		chip->enable_dma = drv_data->master_info->enable_dma;
 		chip->dma_threshold = 0;
+		if (chip_info->using_gpio_cs == 0 && chip_info->gpio_cs == 0)
+			chip_info->gpio_cs = -1;
 		if (chip_info->enable_loopback)
 			chip->cr1 = SSCR1_LBM;
 	}
@@ -1364,7 +1417,7 @@ static int setup(struct spi_device *spi)
 		if (set_dma_burst_and_threshold(chip, spi, spi->bits_per_word,
 						&chip->dma_burst_size,
 						&chip->dma_threshold)) {
-			dev_warn(&spi->dev, "in setup: DMA burst size reduced "
+			dev_warn(&spi->dev, "in setup: DMA burst size reduced "\
 					"to match bits_per_word\n");
 		}
 	}
@@ -1543,18 +1596,36 @@ static int __devinit pxa2xx_spi_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	/* Allocate master with space for drv_data and null dma buffer */
-	master = spi_alloc_master(dev, sizeof(struct driver_data) + 16);
+	/* Allocate master with space for drv_data*/
+	master = spi_alloc_master(dev, sizeof(struct driver_data));
 	if (!master) {
 		dev_err(&pdev->dev, "cannot alloc spi_master\n");
 		pxa_ssp_free(ssp);
 		return -ENOMEM;
 	}
+
 	drv_data = spi_master_get_devdata(master);
+	/* the null DMA buf should malloc form DMA_ZONE
+	 * and align of DMA_ALIGNMENT
+	 */
+	if (!is_pxa988_ssp(drv_data)) {
+		drv_data->alloc_dma_buf =
+			kzalloc(DMA_ALIGNMENT+4, GFP_KERNEL | GFP_DMA);
+	} else {
+		drv_data->alloc_dma_buf =
+			kzalloc(DMA_ALIGNMENT+MAX_DMA_LEN,
+					GFP_KERNEL | GFP_DMA);
+	}
+
+	if (!drv_data->alloc_dma_buf) {
+		status = -ENOMEM;
+		goto out_error_dma_buf;
+	}
 	drv_data->master = master;
 	drv_data->master_info = platform_info;
 	drv_data->pdev = pdev;
 	drv_data->ssp = ssp;
+	init_dvfm_constraint(drv_data);
 
 	master->dev.parent = &pdev->dev;
 	master->dev.of_node = pdev->dev.of_node;
@@ -1569,8 +1640,8 @@ static int __devinit pxa2xx_spi_probe(struct platform_device *pdev)
 	master->transfer = transfer;
 
 	drv_data->ssp_type = ssp->type;
-	drv_data->null_dma_buf = (u32 *)ALIGN((u32)(drv_data +
-						sizeof(struct driver_data)), 8);
+	drv_data->null_dma_buf =
+		(u32 *)ALIGN((u32)drv_data->alloc_dma_buf, DMA_ALIGNMENT);
 
 	drv_data->ioaddr = ssp->mmio_base;
 	drv_data->ssdr_physical = ssp->phys_base + SSDR;
@@ -1678,6 +1749,9 @@ out_error_irq_alloc:
 	free_irq(ssp->irq, drv_data);
 
 out_error_master_alloc:
+	deinit_dvfm_constraint(drv_data);
+	kfree(drv_data->alloc_dma_buf);
+out_error_dma_buf:
 	spi_master_put(master);
 	pxa_ssp_free(ssp);
 	return status;
@@ -1704,7 +1778,7 @@ static int pxa2xx_spi_remove(struct platform_device *pdev)
 		 * message memory in drv_data->queue, but we can release the
 		 * resources below.  I think the kernel should honor -EBUSY
 		 * returns but... */
-		dev_err(&pdev->dev, "pxa2xx_spi_remove: workqueue will not "
+		dev_err(&pdev->dev, "pxa2xx_spi_remove: workqueue will not "\
 			"complete, message memory not freed\n");
 
 	/* Disable the SSP at the peripheral and SOC level */
@@ -1724,7 +1798,8 @@ static int pxa2xx_spi_remove(struct platform_device *pdev)
 
 	/* Release SSP */
 	pxa_ssp_free(ssp);
-
+	kfree(drv_data->alloc_dma_buf);
+	deinit_dvfm_constraint(drv_data);
 	/* Disconnect from the SPI framework */
 	spi_unregister_master(drv_data->master);
 
diff --git a/drivers/staging/iio/Kconfig b/drivers/staging/iio/Kconfig
index fe158671..dfa2c14c 100644
--- a/drivers/staging/iio/Kconfig
+++ b/drivers/staging/iio/Kconfig
@@ -77,6 +77,8 @@ source "drivers/staging/iio/magnetometer/Kconfig"
 source "drivers/staging/iio/meter/Kconfig"
 source "drivers/staging/iio/resolver/Kconfig"
 source "drivers/staging/iio/trigger/Kconfig"
+source "drivers/staging/iio/inv_test/Kconfig"
+
 
 config IIO_DUMMY_EVGEN
        tristate
diff --git a/drivers/staging/iio/imu/Kconfig b/drivers/staging/iio/imu/Kconfig
index 2c2f47de..ca5295a4 100644
--- a/drivers/staging/iio/imu/Kconfig
+++ b/drivers/staging/iio/imu/Kconfig
@@ -14,4 +14,5 @@ config ADIS16400
 	  adis16365, adis16400 and adis16405 triaxial inertial sensors
 	  (adis16400 series also have magnetometers).
 
+source "drivers/staging/iio/imu//mpu/Kconfig"
 endmenu
diff --git a/drivers/staging/iio/imu/Makefile b/drivers/staging/iio/imu/Makefile
index 3400a13d..b496a091 100644
--- a/drivers/staging/iio/imu/Makefile
+++ b/drivers/staging/iio/imu/Makefile
@@ -5,3 +5,4 @@
 adis16400-y             := adis16400_core.o
 adis16400-$(CONFIG_IIO_BUFFER) += adis16400_ring.o adis16400_trigger.o
 obj-$(CONFIG_ADIS16400) += adis16400.o
+obj-y += mpu/
diff --git a/drivers/staging/iio/imu/mpu/Kconfig b/drivers/staging/iio/imu/mpu/Kconfig
new file mode 100644
index 00000000..21cc237c
--- /dev/null
+++ b/drivers/staging/iio/imu/mpu/Kconfig
@@ -0,0 +1,24 @@
+#
+# inv-mpu-iio driver for Invensense MPU devices and combos
+#
+
+config INV_MPU_IIO
+	tristate "Invensense MPU devices"
+	depends on I2C && SYSFS && IIO && IIO_KFIFO_BUF && IIO_TRIGGER && !INV_MPU
+	default n
+	help
+	  This driver supports the Invensense MPU devices.
+	  This includes MPU6050/MPU3050/MPU9150/ITG3500/MPU6500/MPU9250.
+	  This driver can be built as a module. The module will be called
+	  inv-mpu-iio.
+
+config INV_IIO_MPU3050_ACCEL_SLAVE_BMA250
+	bool  "Invensense MPU3050 slave accelerometer device for bma250"
+	depends on INV_MPU_IIO
+	default n
+	help
+	  This is slave device enable MPU3050 accelerometer slave device.
+	  Right now, it is only bma250. For other acceleromter device,
+	  it can be added to this menu if the proper interface is filled.
+	  There are some interface function to be defined.
+
diff --git a/drivers/staging/iio/imu/mpu/Makefile b/drivers/staging/iio/imu/mpu/Makefile
new file mode 100644
index 00000000..1268a7bf
--- /dev/null
+++ b/drivers/staging/iio/imu/mpu/Makefile
@@ -0,0 +1,28 @@
+#
+# Makefile for Invensense inv-mpu-iio device.
+#
+
+obj-$(CONFIG_INV_MPU_IIO) += inv-mpu-iio.o
+
+inv-mpu-iio-objs := inv_mpu_core.o
+inv-mpu-iio-objs += inv_mpu_ring.o
+inv-mpu-iio-objs += inv_mpu_trigger.o
+inv-mpu-iio-objs += inv_mpu_misc.o
+inv-mpu-iio-objs += inv_mpu3050_iio.o
+inv-mpu-iio-objs += dmpDefaultMPU6050.o
+
+CFLAGS_inv_mpu_core.o      += -Idrivers/staging/iio
+CFLAGS_inv_mpu_ring.o      += -Idrivers/staging/iio
+CFLAGS_inv_mpu_trigger.o   += -Idrivers/staging/iio
+CFLAGS_inv_mpu_misc.o      += -Idrivers/staging/iio
+CFLAGS_inv_mpu3050_iio.o   += -Idrivers/staging/iio
+CFLAGS_dmpDefaultMPU6050.o += -Idrivers/staging/iio
+
+# the Bosch BMA250 driver is added to the inv-mpu device driver because it
+# must be connected to an MPU3050 device on the secondary slave bus.
+ifeq ($(CONFIG_INV_IIO_MPU3050_ACCEL_SLAVE_BMA250), y)
+inv-mpu-iio-objs += inv_slave_bma250.o
+#CFLAGS_dmpDefaultMPU6050.o += -Idrivers/staging/iio
+CFLAGS_inv_slave_bma250.o   += -Idrivers/staging/iio
+endif
+
diff --git a/drivers/staging/iio/industrialio-buffer.c b/drivers/staging/iio/industrialio-buffer.c
index 386ba760..a0d124fb 100644
--- a/drivers/staging/iio/industrialio-buffer.c
+++ b/drivers/staging/iio/industrialio-buffer.c
@@ -14,12 +14,12 @@
  * - Alternative access techniques?
  */
 #include <linux/kernel.h>
-#include <linux/export.h>
 #include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/cdev.h>
 #include <linux/slab.h>
 #include <linux/poll.h>
+#include <linux/module.h>
 
 #include "iio.h"
 #include "iio_core.h"
@@ -56,6 +56,8 @@ unsigned int iio_buffer_poll(struct file *filp,
 {
 	struct iio_dev *indio_dev = filp->private_data;
 	struct iio_buffer *rb = indio_dev->buffer;
+	if (rb->stufftoread)
+		return POLLIN | POLLRDNORM;
 
 	poll_wait(filp, &rb->pollq, wait);
 	if (rb->stufftoread)
diff --git a/drivers/staging/iio/industrialio-core.c b/drivers/staging/iio/industrialio-core.c
index d303bfbf..ae457a0f 100644
--- a/drivers/staging/iio/industrialio-core.c
+++ b/drivers/staging/iio/industrialio-core.c
@@ -68,6 +68,7 @@ static const char * const iio_chan_type_name_spec[] = {
 	[IIO_ANGL] = "angl",
 	[IIO_TIMESTAMP] = "timestamp",
 	[IIO_CAPACITANCE] = "capacitance",
+	[IIO_QUATERNION] = "quaternion",
 };
 
 static const char * const iio_modifier_names[] = {
@@ -76,6 +77,7 @@ static const char * const iio_modifier_names[] = {
 	[IIO_MOD_Z] = "z",
 	[IIO_MOD_LIGHT_BOTH] = "both",
 	[IIO_MOD_LIGHT_IR] = "ir",
+	[IIO_MOD_R]  = "r",
 };
 
 /* relies on pairs of these shared then separate */
@@ -792,7 +794,16 @@ EXPORT_SYMBOL(iio_allocate_device);
 
 void iio_free_device(struct iio_dev *dev)
 {
+	struct device *device;
+	struct kobject *kobject;
+
 	if (dev) {
+		device = &dev->dev;
+		kobject = &device->kobj;
+
+		kfree(device->p);
+		kfree(kobject->name);
+
 		ida_simple_remove(&iio_ida, dev->id);
 		kfree(dev);
 	}
diff --git a/drivers/staging/iio/industrialio-event.c b/drivers/staging/iio/industrialio-event.c
index 5fdf739e..68ef8264 100644
--- a/drivers/staging/iio/industrialio-event.c
+++ b/drivers/staging/iio/industrialio-event.c
@@ -35,6 +35,7 @@
  */
 struct iio_event_interface {
 	wait_queue_head_t	wait;
+	struct mutex		read_lock;
 	DECLARE_KFIFO(det_events, struct iio_event_data, 16);
 
 	struct list_head	dev_attr_list;
@@ -96,14 +97,16 @@ static ssize_t iio_event_chrdev_read(struct file *filep,
 	if (count < sizeof(struct iio_event_data))
 		return -EINVAL;
 
-	spin_lock(&ev_int->wait.lock);
+	if (mutex_lock_interruptible(&ev_int->read_lock))
+		return -ERESTARTSYS;
+
 	if (kfifo_is_empty(&ev_int->det_events)) {
 		if (filep->f_flags & O_NONBLOCK) {
 			ret = -EAGAIN;
 			goto error_unlock;
 		}
 		/* Blocking on device; waiting for something to be there */
-		ret = wait_event_interruptible_locked(ev_int->wait,
+		ret = wait_event_interruptible(ev_int->wait,
 					!kfifo_is_empty(&ev_int->det_events));
 		if (ret)
 			goto error_unlock;
@@ -113,7 +116,7 @@ static ssize_t iio_event_chrdev_read(struct file *filep,
 	ret = kfifo_to_user(&ev_int->det_events, buf, count, &copied);
 
 error_unlock:
-	spin_unlock(&ev_int->wait.lock);
+	mutex_unlock(&ev_int->read_lock);
 
 	return ret ? ret : copied;
 }
@@ -376,6 +379,7 @@ static void iio_setup_ev_int(struct iio_event_interface *ev_int)
 {
 	INIT_KFIFO(ev_int->det_events);
 	init_waitqueue_head(&ev_int->wait);
+	mutex_init(&ev_int->read_lock);
 }
 
 static const char *iio_event_group_name = "events";
@@ -437,6 +441,7 @@ int iio_device_register_eventset(struct iio_dev *indio_dev)
 
 error_free_setup_event_lines:
 	__iio_remove_event_config_attrs(indio_dev);
+	mutex_destroy(&indio_dev->event_interface->read_lock);
 	kfree(indio_dev->event_interface);
 error_ret:
 
@@ -449,5 +454,6 @@ void iio_device_unregister_eventset(struct iio_dev *indio_dev)
 		return;
 	__iio_remove_event_config_attrs(indio_dev);
 	kfree(indio_dev->event_interface->group.attrs);
+	mutex_destroy(&indio_dev->event_interface->read_lock);
 	kfree(indio_dev->event_interface);
 }
diff --git a/drivers/staging/iio/inkern.c b/drivers/staging/iio/inkern.c
index ef07a02b..832fbb65 100644
--- a/drivers/staging/iio/inkern.c
+++ b/drivers/staging/iio/inkern.c
@@ -7,9 +7,9 @@
  * the Free Software Foundation.
  */
 #include <linux/err.h>
-#include <linux/export.h>
 #include <linux/slab.h>
 #include <linux/mutex.h>
+#include <linux/module.h>
 
 #include "iio.h"
 #include "iio_core.h"
diff --git a/drivers/staging/iio/inv_test/Kconfig b/drivers/staging/iio/inv_test/Kconfig
new file mode 100644
index 00000000..f6b6e159
--- /dev/null
+++ b/drivers/staging/iio/inv_test/Kconfig
@@ -0,0 +1,11 @@
+#
+# Kconfig for Invensense IIO testing hooks
+#
+
+config INV_TESTING
+	boolean "Invensense IIO testing hooks"
+	depends on INV_MPU_IIO || INV_AMI306_IIO || INV_YAS530
+	default n
+	help
+	  This flag enables display of additional testing information from the
+	  Invensense IIO drivers
diff --git a/drivers/staging/iio/inv_test/Makefile b/drivers/staging/iio/inv_test/Makefile
new file mode 100644
index 00000000..4f0edd3d
--- /dev/null
+++ b/drivers/staging/iio/inv_test/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for Invensense IIO testing hooks.
+#
+
+obj-$(CONFIG_INV_TESTING) += inv_counters.o
+
diff --git a/drivers/staging/iio/inv_test/inv_counters.h b/drivers/staging/iio/inv_test/inv_counters.h
new file mode 100644
index 00000000..d671d011
--- /dev/null
+++ b/drivers/staging/iio/inv_test/inv_counters.h
@@ -0,0 +1,75 @@
+/*
+ * @file  inv_counters.h
+ * @brief Debug file to keep track of various counters for the InvenSense
+ *        sensor drivers.
+ *
+ * @version 0.1
+ */
+
+#ifndef _INV_COUNTERS_H_
+#define _INV_COUNTERS_H_
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/sysfs.h>
+#include <linux/string.h>
+#include <linux/jiffies.h>
+#include <linux/spinlock.h>
+
+enum irqtype {
+	MPU,
+	ACCEL,
+	COMPASS
+};
+
+#ifdef CONFIG_INV_TESTING
+
+#define INV_I2C_INC_MPUREAD(x)		inv_counters_mpuread(x)
+#define INV_I2C_INC_MPUWRITE(x)		inv_counters_mpuwrite(x)
+#define INV_I2C_INC_ACCELREAD(x)	inv_counters_accelread(x)
+#define INV_I2C_INC_ACCELWRITE(x)	inv_counters_accelwrite(x)
+#define INV_I2C_INC_COMPASSREAD(x)	inv_counters_compassread(x)
+#define INV_I2C_INC_COMPASSWRITE(x)	inv_counters_compasswrite(x)
+
+#define INV_INC_TEMPREAD(x)		inv_counters_tempread(x)
+
+#define INV_I2C_SETIRQ(type, irq)	inv_counters_set_i2cirq(type, irq)
+#define INV_I2C_INC_COMPASSIRQ()	inv_counters_compassirq()
+#define INV_I2C_INC_ACCELIRQ()		inv_counters_accelirq()
+
+void inv_counters_mpuread(int count);
+void inv_counters_mpuwrite(int count);
+void inv_counters_accelread(int count);
+void inv_counters_accelwrite(int count);
+void inv_counters_compassread(int count);
+void inv_counters_compasswrite(int count);
+
+void inv_counters_tempread(int count);
+
+void inv_counters_set_i2cirq(enum irqtype type, int irq);
+void inv_counters_compassirq(void);
+void inv_counters_accelirq(void);
+
+#else
+
+#define INV_I2C_INC_MPUREAD(x)
+#define INV_I2C_INC_MPUWRITE(x)
+#define INV_I2C_INC_ACCELREAD(x)
+#define INV_I2C_INC_ACCELWRITE(x)
+#define INV_I2C_INC_COMPASSREAD(x)
+#define INV_I2C_INC_COMPASSWRITE(x)
+
+#define INV_INC_TEMPREAD(x)
+
+#define INV_I2C_INC_COMPASSIRQ()
+#define INV_I2C_INC_ACCELIRQ()
+
+#define INV_I2C_SETIRQ(type, irq)
+#define INV_I2C_INC_COMPASSIRQ()
+#define INV_I2C_INC_ACCELIRQ()
+
+#endif /* CONFIG_INV_TESTING */
+
+#endif /* _INV_COUNTERS_H_ */
+
diff --git a/drivers/staging/iio/kfifo_buf.c b/drivers/staging/iio/kfifo_buf.c
index 9f3bd59c..5a702449 100644
--- a/drivers/staging/iio/kfifo_buf.c
+++ b/drivers/staging/iio/kfifo_buf.c
@@ -4,6 +4,7 @@
 #include <linux/device.h>
 #include <linux/workqueue.h>
 #include <linux/kfifo.h>
+#include <linux/sched.h>
 #include <linux/mutex.h>
 
 #include "kfifo_buf.h"
@@ -36,6 +37,7 @@ static int iio_request_update_kfifo(struct iio_buffer *r)
 	kfifo_free(&buf->kf);
 	ret = __iio_allocate_kfifo(buf, buf->buffer.bytes_per_datum,
 				   buf->buffer.length);
+	r->stufftoread = false;
 error_ret:
 	return ret;
 }
@@ -95,9 +97,16 @@ static int iio_store_to_kfifo(struct iio_buffer *r,
 {
 	int ret;
 	struct iio_kfifo *kf = iio_to_kfifo(r);
-	ret = kfifo_in(&kf->kf, data, r->bytes_per_datum);
-	if (ret != r->bytes_per_datum)
-		return -EBUSY;
+	if (kfifo_avail(&kf->kf) >= r->bytes_per_datum) {
+		ret = kfifo_in(&kf->kf, data, r->bytes_per_datum);
+		if (ret != r->bytes_per_datum)
+			return -EBUSY;
+	} else {
+		return -ENOMEM;
+	}
+	r->stufftoread = true;
+	wake_up_interruptible(&r->pollq);
+
 	return 0;
 }
 
@@ -107,12 +116,18 @@ static int iio_read_first_n_kfifo(struct iio_buffer *r,
 	int ret, copied;
 	struct iio_kfifo *kf = iio_to_kfifo(r);
 
-	if (n < r->bytes_per_datum)
+	if (n < r->bytes_per_datum || r->length == 0)
 		return -EINVAL;
 
 	n = rounddown(n, r->bytes_per_datum);
 	ret = kfifo_to_user(&kf->kf, buf, n, &copied);
 
+	if (kfifo_is_empty(&kf->kf))
+		r->stufftoread = false;
+	/* verify it is still empty to avoid race */
+	if (!kfifo_is_empty(&kf->kf))
+		r->stufftoread = true;
+
 	return copied;
 }
 
diff --git a/drivers/staging/iio/magnetometer/Kconfig b/drivers/staging/iio/magnetometer/Kconfig
index 722c4e13..a8f8ddf5 100644
--- a/drivers/staging/iio/magnetometer/Kconfig
+++ b/drivers/staging/iio/magnetometer/Kconfig
@@ -24,4 +24,14 @@ config SENSORS_HMC5843
 	  To compile this driver as a module, choose M here: the module
 	  will be called hmc5843
 
+config INV_MMC328X_IIO
+    tristate "Invensense IIO driver for Memsic MMC328x compass"
+    depends on I2C && SYSFS && IIO && IIO_KFIFO_BUF
+    default n
+    help
+      This driver supports the Memsic MMC328x compass. It is the Invensense
+      IIO implementation for the MMC328x compass device.
+      This driver can be built as a module. The module will be called
+      inv-mmc328x-iio.
+
 endmenu
diff --git a/drivers/staging/iio/magnetometer/Makefile b/drivers/staging/iio/magnetometer/Makefile
index f2a753f8..d3e8a02a 100644
--- a/drivers/staging/iio/magnetometer/Makefile
+++ b/drivers/staging/iio/magnetometer/Makefile
@@ -4,3 +4,12 @@
 
 obj-$(CONFIG_SENSORS_AK8975)	+= ak8975.o
 obj-$(CONFIG_SENSORS_HMC5843)	+= hmc5843.o
+obj-$(CONFIG_INV_MMC328X_IIO) += inv-mmc328x-iio.o
+
+inv-mmc328x-iio-objs := inv_mmc328x_core.o
+inv-mmc328x-iio-objs += inv_mmc328x_ring.o
+inv-mmc328x-iio-objs += inv_mmc328x_trigger.o
+
+CFLAGS_inv_mmc328x_core.o    += -Idrivers/staging/iio
+CFLAGS_inv_mmc328x_ring.o    += -Idrivers/staging/iio
+CFLAGS_inv_mmc328x_trigger.o += -Idrivers/staging/iio
diff --git a/drivers/staging/iio/magnetometer/inv_mmc328x_core.c b/drivers/staging/iio/magnetometer/inv_mmc328x_core.c
new file mode 100644
index 00000000..3083b912
--- /dev/null
+++ b/drivers/staging/iio/magnetometer/inv_mmc328x_core.c
@@ -0,0 +1,412 @@
+/*
+* Copyright (C) 2012 Invensense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+*/
+
+/**
+ *  @addtogroup  DRIVERS
+ *  @brief       Hardware drivers.
+ *
+ *  @{
+ *      @file    inv_mmc328x_core.c
+ *      @brief   Invensense implementation for MMC328x
+ *      @details This driver currently works for the MMC328x
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+
+#include "inv_mmc328x_iio.h"
+#include "sysfs.h"
+#include "inv_test/inv_counters.h"
+
+#define MMC328X_RESET_INTV		100
+#define MMC328X_WAIT_TM		10	/* ms */
+#define MMC328X_DELAY_RRM		1	/* ms */
+#define MMC328X_DELAY_TM		50	/* ms */
+#define MMC328X_DELAY_RM		100	/* ms */
+
+
+static u32 read_idx;
+
+s32 i2c_write(const struct i2c_client *client,
+		u8 command, u8 length, const u8 values)
+{
+	INV_I2C_INC_COMPASSWRITE(3);
+	return i2c_smbus_write_i2c_block_data(client, command, length, &values);
+}
+
+s32 i2c_read(const struct i2c_client *client,
+		u8 command, u8 length, u8 *values)
+{
+	INV_I2C_INC_COMPASSWRITE(3);
+	INV_I2C_INC_COMPASSREAD(length);
+	return i2c_smbus_read_i2c_block_data(client, command, length, values);
+}
+
+void set_mmc328x_enable(struct iio_dev *indio_dev, bool enable)
+{
+	struct inv_mmc328x_state_s *st = iio_priv(indio_dev);
+	int pre_enable = st->enable;
+
+	if (enable) {
+		if (pre_enable == 0) {
+			schedule_delayed_work(&st->work,
+				msecs_to_jiffies(st->delay));
+			st->enable = 1;
+		}
+
+	} else {
+		if (pre_enable == 1) {
+			cancel_delayed_work_sync(&st->work);
+			st->enable = 0;
+		}
+	}
+}
+
+int mmc328x_read_raw_data(struct inv_mmc328x_state_s *st, short dat[3])
+{
+	unsigned char buf[6];
+
+	if (!(read_idx % MMC328X_RESET_INTV)) {
+		/* Reset sensor Periodly */
+		/* RRM */
+		i2c_write(st->i2c, MMC328X_REG_CTRL, 1, MMC328X_CTRL_RRM);
+		/* wait external capacitor charging done for next RRM */
+		msleep(MMC328X_DELAY_RRM);
+		/* TM */
+		i2c_write(st->i2c, MMC328X_REG_CTRL, 1, MMC328X_CTRL_TM);
+		msleep(MMC328X_DELAY_TM);
+		/* RM */
+		i2c_write(st->i2c, MMC328X_REG_CTRL, 1, MMC328X_CTRL_RM);
+		/* wait external capacitor charging done for next RM */
+		msleep(MMC328X_DELAY_RM);
+	}
+	/* Take meaurement */
+	i2c_write(st->i2c, MMC328X_REG_CTRL, 1, MMC328X_CTRL_TM);
+	msleep(MMC328X_WAIT_TM);
+	i2c_read(st->i2c, MMC328X_REG_DATA, sizeof(buf), buf);
+	dat[0] = buf[1] << 8 | buf[0];
+	dat[1] = buf[3] << 8 | buf[2];
+	dat[2] = buf[5] << 8 | buf[4];
+
+	read_idx++;
+
+	return 0;
+}
+
+/**
+ *  mmc328x_read_raw() - read raw method.
+ */
+static int mmc328x_read_raw(struct iio_dev *indio_dev,
+			      struct iio_chan_spec const *chan,
+			      int *val,
+			      int *val2,
+			      long mask)
+{
+	struct inv_mmc328x_state_s  *st = iio_priv(indio_dev);
+	switch (mask) {
+	case 0:
+		if (chan->type == IIO_MAGN) {
+			*val = st->compass_data[chan->channel2 - IIO_MOD_X];
+			return IIO_VAL_INT;
+		}
+
+		return -EINVAL;
+	case IIO_CHAN_INFO_SCALE:
+		if (chan->type == IIO_MAGN) {
+			*val = MEMSIC_SCALE;
+			return IIO_VAL_INT;
+		}
+		return -EINVAL;
+	default:
+		return -EINVAL;
+	}
+}
+
+/**
+ *  mmc328x_write_raw() - write raw method.
+ */
+static int mmc328x_write_raw(struct iio_dev *indio_dev,
+			       struct iio_chan_spec const *chan,
+			       int val,
+			       int val2,
+			       long mask)
+{
+	int result;
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		result = -EINVAL;
+		return result;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/**
+ * inv_compass_matrix_show() - show orientation matrix
+ */
+static ssize_t inv_compass_matrix_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	signed char *m;
+	struct inv_mmc328x_state_s *st = iio_priv(indio_dev);
+	m = st->plat_data.orientation;
+	return sprintf(buf,
+	"%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+		m[0],  m[1],  m[2],  m[3], m[4], m[5], m[6], m[7], m[8]);
+}
+
+static ssize_t mmc328x_rate_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mmc328x_state_s *st = iio_priv(indio_dev);
+
+	error = kstrtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (0 == data)
+		return -EINVAL;
+	/* transform rate to delay in ms */
+	data = 1000 / data;
+	if (data > MMC328X_MAX_DELAY)
+		data = MMC328X_MAX_DELAY;
+	if (data < MMC328X_MIN_DELAY)
+		data = MMC328X_MIN_DELAY;
+	st->delay = data;
+	return count;
+}
+
+static ssize_t mmc328x_rate_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mmc328x_state_s *st = iio_priv(indio_dev);
+	/* transform delay in ms to rate */
+	return sprintf(buf, "%d\n", 1000 / st->delay);
+}
+
+static void mmc328x_work_func(struct work_struct *work)
+{
+	struct inv_mmc328x_state_s *st =
+		container_of((struct delayed_work *)work,
+			struct inv_mmc328x_state_s, work);
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+	unsigned long delay = msecs_to_jiffies(st->delay);
+
+	inv_read_mmc328x_fifo(indio_dev);
+	schedule_delayed_work(&st->work, delay);
+	INV_I2C_INC_COMPASSIRQ();
+
+}
+
+static const struct iio_chan_spec compass_channels[] = {
+	{
+		.type = IIO_MAGN,
+		.modified = 1,
+		.channel2 = IIO_MOD_X,
+		.info_mask = IIO_CHAN_INFO_SCALE_SHARED_BIT,
+		.scan_index = INV_MMC328X_SCAN_MAGN_X,
+		.scan_type = IIO_ST('s', 16, 16, 0)
+	}, {
+		.type = IIO_MAGN,
+		.modified = 1,
+		.channel2 = IIO_MOD_Y,
+		.info_mask = IIO_CHAN_INFO_SCALE_SHARED_BIT,
+		.scan_index = INV_MMC328X_SCAN_MAGN_Y,
+		.scan_type = IIO_ST('s', 16, 16, 0)
+	}, {
+		.type = IIO_MAGN,
+		.modified = 1,
+		.channel2 = IIO_MOD_Z,
+		.info_mask = IIO_CHAN_INFO_SCALE_SHARED_BIT,
+		.scan_index = INV_MMC328X_SCAN_MAGN_Z,
+		.scan_type = IIO_ST('s', 16, 16, 0)
+	},
+	IIO_CHAN_SOFT_TIMESTAMP(INV_MMC328X_SCAN_TIMESTAMP)
+};
+
+static DEVICE_ATTR(compass_matrix, S_IRUGO, inv_compass_matrix_show, NULL);
+static DEVICE_ATTR(sampling_frequency, S_IRUGO | S_IWUSR, mmc328x_rate_show,
+		mmc328x_rate_store);
+
+static struct attribute *inv_mmc328x_attributes[] = {
+	&dev_attr_compass_matrix.attr,
+	&dev_attr_sampling_frequency.attr,
+	NULL,
+};
+static const struct attribute_group inv_attribute_group = {
+	.name = "mmc328x",
+	.attrs = inv_mmc328x_attributes,
+};
+
+static const struct iio_info mmc328x_info = {
+	.driver_module = THIS_MODULE,
+	.read_raw = &mmc328x_read_raw,
+	.write_raw = &mmc328x_write_raw,
+	.attrs = &inv_attribute_group,
+};
+
+/*constant IIO attribute */
+/**
+ *  inv_mmc328x_probe() - probe function.
+ */
+static int inv_mmc328x_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct inv_mmc328x_state_s *st;
+	struct iio_dev *indio_dev;
+	int result;
+	char data;
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+	indio_dev = iio_allocate_device(sizeof(*st));
+	if (indio_dev == NULL) {
+		result =  -ENOMEM;
+		goto out_no_free;
+	}
+
+	st = iio_priv(indio_dev);
+	st->i2c = client;
+	st->sl_handle = client->adapter;
+	st->plat_data =
+		*(struct mpu_platform_data *)dev_get_platdata(&client->dev);
+	st->delay = 10;
+
+	i2c_set_clientdata(client, indio_dev);
+
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->name = id->name;
+	indio_dev->channels = compass_channels;
+	indio_dev->num_channels = ARRAY_SIZE(compass_channels);
+	indio_dev->info = &mmc328x_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->currentmode = INDIO_DIRECT_MODE;
+	/* check whether mmc328x chip exist*/
+	result = i2c_read(st->i2c, 0x10, 1, &data);
+
+	if (result < 1) {
+		pr_err("----mmc328x chip chip failed return-----\n");
+		goto out_free;
+	}
+	result = inv_mmc328x_configure_ring(indio_dev);
+	if (result)
+		goto out_free;
+	result = iio_buffer_register(indio_dev, indio_dev->channels,
+				indio_dev->num_channels);
+	if (result)
+		goto out_unreg_ring;
+	result = inv_mmc328x_probe_trigger(indio_dev);
+	if (result)
+		goto out_remove_ring;
+
+	result = iio_device_register(indio_dev);
+	if (result)
+		goto out_remove_trigger;
+	INIT_DELAYED_WORK(&st->work, mmc328x_work_func);
+	pr_info("%s: Probe name %s\n", __func__, id->name);
+	return 0;
+
+out_remove_trigger:
+	if (indio_dev->modes & INDIO_BUFFER_TRIGGERED)
+		inv_mmc328x_remove_trigger(indio_dev);
+out_remove_ring:
+	iio_buffer_unregister(indio_dev);
+out_unreg_ring:
+	inv_mmc328x_unconfigure_ring(indio_dev);
+out_free:
+	iio_free_device(indio_dev);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return -EIO;
+
+}
+/**
+ *  inv_mmc328x_remove() - remove function.
+ */
+static int inv_mmc328x_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct inv_mmc328x_state_s *st = iio_priv(indio_dev);
+	cancel_delayed_work_sync(&st->work);
+	iio_device_unregister(indio_dev);
+	inv_mmc328x_remove_trigger(indio_dev);
+	iio_buffer_unregister(indio_dev);
+	inv_mmc328x_unconfigure_ring(indio_dev);
+	iio_free_device(indio_dev);
+
+	dev_info(&client->adapter->dev, "inv-mmc328x-iio module removed.\n");
+	return 0;
+}
+static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
+/* device id table is used to identify what device can be
+ * supported by this driver
+ */
+static const struct i2c_device_id inv_mmc328x_id[] = {
+	{"mmc328x", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, inv_mmc328x_id);
+
+static struct i2c_driver inv_mmc328x_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe		=	inv_mmc328x_probe,
+	.remove		=	inv_mmc328x_remove,
+	.id_table	=	inv_mmc328x_id,
+	.driver = {
+		.owner	=	THIS_MODULE,
+		.name	=	"inv-mmc328x-iio",
+	},
+	.address_list = normal_i2c,
+};
+static int __init inv_mmc328x_init(void)
+{
+	int result = i2c_add_driver(&inv_mmc328x_driver);
+	if (result) {
+		pr_err("%s failed\n", __func__);
+		return result;
+	}
+	return 0;
+}
+
+static void __exit inv_mmc328x_exit(void)
+{
+	i2c_del_driver(&inv_mmc328x_driver);
+}
+module_init(inv_mmc328x_init);
+module_exit(inv_mmc328x_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("inv_mmc328x_iio");
diff --git a/drivers/staging/iio/magnetometer/inv_mmc328x_iio.h b/drivers/staging/iio/magnetometer/inv_mmc328x_iio.h
new file mode 100644
index 00000000..91a1e856
--- /dev/null
+++ b/drivers/staging/iio/magnetometer/inv_mmc328x_iio.h
@@ -0,0 +1,84 @@
+/*
+* Copyright (C) 2012 Invensense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+*/
+
+/**
+ *  @addtogroup DRIVERS
+ *  @brief      Hardware drivers.
+ *
+ *  @{
+ *      @file  inv_mmc328x_iio.h
+ *      @brief Struct definitions for the Invensense implementation
+ *              of mmc328x driver.
+ */
+
+#ifndef _INV_GYRO_H_
+#define _INV_GYRO_H_
+#endif
+#include <linux/i2c.h>
+#include <linux/kfifo.h>
+#include <linux/miscdevice.h>
+#include <linux/input.h>
+#include <linux/spinlock.h>
+#include <linux/mpu.h>
+
+#include "iio.h"
+#include "buffer.h"
+#include "trigger.h"
+
+/**
+ *  struct inv_mmc328x_state_s - Driver state variables.
+ *  @i2c:		i2c client handle.
+ *  @sl_handle:         Handle to I2C port.
+ */
+struct inv_mmc328x_state_s {
+	struct mpu_platform_data plat_data;
+	struct i2c_client *i2c;
+	struct iio_trigger *trig;
+	struct delayed_work work;
+	short compass_data[3];
+	int delay;
+	s8 enable;
+	void *sl_handle;
+};
+
+/* scan element definition */
+enum inv_mpu_scan {
+	INV_MMC328X_SCAN_MAGN_X,
+	INV_MMC328X_SCAN_MAGN_Y,
+	INV_MMC328X_SCAN_MAGN_Z,
+	INV_MMC328X_SCAN_TIMESTAMP,
+};
+
+#define MMC328X_MAX_DELAY                   1000
+#define MMC328X_MIN_DELAY                   10
+#define MEMSIC_SCALE                       (5461 * (1<<15))
+
+/* MMC328X register address */
+#define MMC328X_REG_CTRL		0x07
+#define MMC328X_REG_DATA		0x00
+#define MMC328X_REG_DS			0x06
+
+/* MMC328X control bit */
+#define MMC328X_CTRL_TM		0x01
+#define MMC328X_CTRL_RM		0x20
+#define MMC328X_CTRL_RRM	0x40
+
+int inv_mmc328x_configure_ring(struct iio_dev *indio_dev);
+void inv_mmc328x_unconfigure_ring(struct iio_dev *indio_dev);
+int inv_mmc328x_probe_trigger(struct iio_dev *indio_dev);
+void inv_mmc328x_remove_trigger(struct iio_dev *indio_dev);
+void set_mmc328x_enable(struct iio_dev *indio_dev, bool enable);
+int mmc328x_read_raw_data(struct inv_mmc328x_state_s *st,
+				short dat[3]);
+void inv_read_mmc328x_fifo(struct iio_dev *indio_dev);
diff --git a/drivers/staging/iio/magnetometer/inv_mmc328x_ring.c b/drivers/staging/iio/magnetometer/inv_mmc328x_ring.c
new file mode 100644
index 00000000..72dc1575
--- /dev/null
+++ b/drivers/staging/iio/magnetometer/inv_mmc328x_ring.c
@@ -0,0 +1,136 @@
+/*
+* Copyright (C) 2012 Invensense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+*/
+
+/**
+ *  @addtogroup  DRIVERS
+ *  @brief       Hardware drivers.
+ *
+ *  @{
+ *      @file    inv_mmc328x_ring.c
+ *      @brief   Invensense implementation for MMC328X
+ *      @details This driver currently works for the MMC328X
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+
+#include "iio.h"
+#include "kfifo_buf.h"
+#include "trigger_consumer.h"
+#include "sysfs.h"
+
+#include "inv_mmc328x_iio.h"
+static s64 get_time_ns(void)
+{
+	struct timespec ts;
+	ktime_get_ts(&ts);
+	return timespec_to_ns(&ts);
+}
+
+static int put_scan_to_buf(struct iio_dev *indio_dev, unsigned char *d,
+			short *s, int scan_index)
+{
+	struct iio_buffer *ring = indio_dev->buffer;
+	int st;
+	int i, d_ind;
+	d_ind = 0;
+	for (i = 0; i < 3; i++) {
+		st = iio_scan_mask_query(indio_dev, ring, scan_index + i);
+		if (st) {
+			memcpy(&d[d_ind], &s[i], sizeof(s[i]));
+			d_ind += sizeof(s[i]);
+		}
+	}
+	return d_ind;
+}
+
+/**
+ *  inv_read_fifo() - Transfer data from FIFO to ring buffer.
+ */
+void inv_read_mmc328x_fifo(struct iio_dev *indio_dev)
+{
+	struct inv_mmc328x_state_s *st = iio_priv(indio_dev);
+	struct iio_buffer *ring = indio_dev->buffer;
+	int d_ind;
+	s8 *tmp;
+	s64 tmp_buf[2];
+	if (!mmc328x_read_raw_data(st, st->compass_data))
+		;
+	tmp = (u8 *) tmp_buf;
+	d_ind = put_scan_to_buf(indio_dev, tmp, st->compass_data,
+			INV_MMC328X_SCAN_MAGN_X);
+	if (ring->scan_timestamp)
+		tmp_buf[(d_ind + 7) / 8] = get_time_ns();
+
+	ring->access->store_to(indio_dev->buffer, tmp, 0);
+}
+
+void inv_mmc328x_unconfigure_ring(struct iio_dev *indio_dev)
+{
+	iio_kfifo_free(indio_dev->buffer);
+};
+
+static int inv_mmc328x_postenable(struct iio_dev *indio_dev)
+{
+	struct inv_mmc328x_state_s *st = iio_priv(indio_dev);
+	set_mmc328x_enable(indio_dev, true);
+	schedule_delayed_work(&st->work, msecs_to_jiffies(st->delay));
+	return 0;
+}
+
+static int inv_mmc328x_predisable(struct iio_dev *indio_dev)
+{
+	struct inv_mmc328x_state_s *st = iio_priv(indio_dev);
+	cancel_delayed_work_sync(&st->work);
+	return 0;
+}
+
+static const struct iio_buffer_setup_ops inv_mmc328x_ring_setup_ops = {
+	.preenable = &iio_sw_buffer_preenable,
+	.postenable = &inv_mmc328x_postenable,
+	.predisable = &inv_mmc328x_predisable,
+};
+
+int inv_mmc328x_configure_ring(struct iio_dev *indio_dev)
+{
+	int ret = 0;
+	struct iio_buffer *ring;
+	ring = iio_kfifo_allocate(indio_dev);
+	if (!ring) {
+		ret = -ENOMEM;
+		return ret;
+	}
+	indio_dev->buffer = ring;
+
+	/* setup ring buffer */
+	ring->scan_timestamp = true;
+	indio_dev->setup_ops = &inv_mmc328x_ring_setup_ops;
+	indio_dev->modes |= INDIO_BUFFER_TRIGGERED;
+	return 0;
+}
+
+
+/**
+ *  @}
+ */
diff --git a/drivers/staging/iio/magnetometer/inv_mmc328x_trigger.c b/drivers/staging/iio/magnetometer/inv_mmc328x_trigger.c
new file mode 100644
index 00000000..2a3c89e3
--- /dev/null
+++ b/drivers/staging/iio/magnetometer/inv_mmc328x_trigger.c
@@ -0,0 +1,84 @@
+/*
+* Copyright (C) 2012 Invensense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+*/
+
+/**
+ *  @addtogroup  DRIVERS
+ *  @brief       Hardware drivers.
+ *
+ *  @{
+ *      @file    inv_mmc328x_trigger.c
+ *      @brief   Invensense implementation for MMC328X
+ *      @details This driver currently works for the MMC328X
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+
+#include "iio.h"
+#include "sysfs.h"
+#include "trigger.h"
+#include "inv_mmc328x_iio.h"
+static const struct iio_trigger_ops inv_mmc328x_trigger_ops = {
+	.owner = THIS_MODULE,
+};
+
+int inv_mmc328x_probe_trigger(struct iio_dev *indio_dev)
+{
+	int ret;
+	struct inv_mmc328x_state_s *st = iio_priv(indio_dev);
+	st->trig =
+		iio_allocate_trigger("%s-dev%d", indio_dev->name,
+				indio_dev->id);
+	if (st->trig == NULL) {
+		ret = -ENOMEM;
+		goto error_ret;
+	}
+
+	/* select default trigger */
+	st->trig->dev.parent = &st->i2c->dev;
+	st->trig->private_data = indio_dev;
+	st->trig->ops = &inv_mmc328x_trigger_ops;
+	ret = iio_trigger_register(st->trig);
+
+	/* select default trigger */
+	indio_dev->trig = st->trig;
+	if (ret)
+		goto error_free_trig;
+	return 0;
+error_free_trig: iio_free_trigger(st->trig);
+error_ret: return ret;
+}
+
+void inv_mmc328x_remove_trigger(struct iio_dev *indio_dev)
+{
+	struct inv_mmc328x_state_s *st = iio_priv(indio_dev);
+	iio_trigger_unregister(st->trig);
+	iio_free_trigger(st->trig);
+}
+
+/**
+ *  @}
+ */
diff --git a/drivers/staging/iio/types.h b/drivers/staging/iio/types.h
index 0c321366..291c7832 100644
--- a/drivers/staging/iio/types.h
+++ b/drivers/staging/iio/types.h
@@ -27,6 +27,7 @@ enum iio_chan_type {
 	IIO_ANGL,
 	IIO_TIMESTAMP,
 	IIO_CAPACITANCE,
+	IIO_QUATERNION,
 };
 
 enum iio_modifier {
@@ -44,6 +45,7 @@ enum iio_modifier {
 	IIO_MOD_X_OR_Y_OR_Z,
 	IIO_MOD_LIGHT_BOTH,
 	IIO_MOD_LIGHT_IR,
+	IIO_MOD_R,
 };
 
 #define IIO_VAL_INT 1
diff --git a/drivers/staging/zsmalloc/Kconfig b/drivers/staging/zsmalloc/Kconfig
index a5ab7200..90845656 100644
--- a/drivers/staging/zsmalloc/Kconfig
+++ b/drivers/staging/zsmalloc/Kconfig
@@ -1,9 +1,5 @@
 config ZSMALLOC
 	tristate "Memory allocator for compressed pages"
-	# X86 dependency is because of the use of __flush_tlb_one and set_pte
-	# in zsmalloc-main.c.
-	# TODO: convert these to portable functions
-	depends on X86
 	default n
 	help
 	  zsmalloc is a slab-based memory allocator designed to store
diff --git a/drivers/staging/zsmalloc/zsmalloc-main.c b/drivers/staging/zsmalloc/zsmalloc-main.c
index 917461c6..8b0bcb62 100644
--- a/drivers/staging/zsmalloc/zsmalloc-main.c
+++ b/drivers/staging/zsmalloc/zsmalloc-main.c
@@ -10,6 +10,54 @@
  * Released under the terms of GNU General Public License Version 2.0
  */
 
+
+/*
+ * This allocator is designed for use with zcache and zram. Thus, the
+ * allocator is supposed to work well under low memory conditions. In
+ * particular, it never attempts higher order page allocation which is
+ * very likely to fail under memory pressure. On the other hand, if we
+ * just use single (0-order) pages, it would suffer from very high
+ * fragmentation -- any object of size PAGE_SIZE/2 or larger would occupy
+ * an entire page. This was one of the major issues with its predecessor
+ * (xvmalloc).
+ *
+ * To overcome these issues, zsmalloc allocates a bunch of 0-order pages
+ * and links them together using various 'struct page' fields. These linked
+ * pages act as a single higher-order page i.e. an object can span 0-order
+ * page boundaries. The code refers to these linked pages as a single entity
+ * called zspage.
+ *
+ * Following is how we use various fields and flags of underlying
+ * struct page(s) to form a zspage.
+ *
+ * Usage of struct page fields:
+ *	page->first_page: points to the first component (0-order) page
+ *	page->index (union with page->freelist): offset of the first object
+ *		starting in this page. For the first page, this is
+ *		always 0, so we use this field (aka freelist) to point
+ *		to the first free object in zspage.
+ *	page->lru: links together all component pages (except the first page)
+ *		of a zspage
+ *
+ *	For _first_ page only:
+ *
+ *	page->private (union with page->first_page): refers to the
+ *		component page after the first page
+ *	page->freelist: points to the first free object in zspage.
+ *		Free objects are linked together using in-place
+ *		metadata.
+ *	page->objects: maximum number of objects we can store in this
+ *		zspage (class->zspage_order * PAGE_SIZE / class->size)
+ *	page->lru: links together first pages of various zspages.
+ *		Basically forming list of zspages in a fullness group.
+ *	page->mapping: class index and fullness group of the zspage
+ *
+ * Usage of struct page flags:
+ *	PG_private: identifies the first component page
+ *	PG_private2: identifies the last component page
+ *
+ */
+
 #ifdef CONFIG_ZSMALLOC_DEBUG
 #define DEBUG
 #endif
@@ -45,12 +93,12 @@ static DEFINE_PER_CPU(struct mapping_area, zs_map_area);
 
 static int is_first_page(struct page *page)
 {
-	return test_bit(PG_private, &page->flags);
+	return PagePrivate(page);
 }
 
 static int is_last_page(struct page *page)
 {
-	return test_bit(PG_private_2, &page->flags);
+	return PagePrivate2(page);
 }
 
 static void get_zspage_mapping(struct page *page, unsigned int *class_idx,
@@ -180,7 +228,7 @@ out:
  * link together 3 PAGE_SIZE sized pages to form a zspage
  * since then we can perfectly fit in 8 such objects.
  */
-static int get_zspage_order(int class_size)
+static int get_pages_per_zspage(int class_size)
 {
 	int i, max_usedpc = 0;
 	/* zspage order which gives maximum used size per KB */
@@ -247,13 +295,11 @@ static void *obj_location_to_handle(struct page *page, unsigned long obj_idx)
 }
 
 /* Decode <page, obj_idx> pair from the given object handle */
-static void obj_handle_to_location(void *handle, struct page **page,
+static void obj_handle_to_location(unsigned long handle, struct page **page,
 				unsigned long *obj_idx)
 {
-	unsigned long hval = (unsigned long)handle;
-
-	*page = pfn_to_page(hval >> OBJ_INDEX_BITS);
-	*obj_idx = hval & OBJ_INDEX_MASK;
+	*page = pfn_to_page(handle >> OBJ_INDEX_BITS);
+	*obj_idx = handle & OBJ_INDEX_MASK;
 }
 
 static unsigned long obj_idx_to_offset(struct page *page,
@@ -354,7 +400,7 @@ static void init_zspage(struct page *first_page, struct size_class *class)
 static struct page *alloc_zspage(struct size_class *class, gfp_t flags)
 {
 	int i, error;
-	struct page *first_page = NULL;
+	struct page *first_page = NULL, *uninitialized_var(prev_page);
 
 	/*
 	 * Allocate individual pages and link them together as:
@@ -368,8 +414,8 @@ static struct page *alloc_zspage(struct size_class *class, gfp_t flags)
 	 * identify the last page.
 	 */
 	error = -ENOMEM;
-	for (i = 0; i < class->zspage_order; i++) {
-		struct page *page, *prev_page;
+	for (i = 0; i < class->pages_per_zspage; i++) {
+		struct page *page;
 
 		page = alloc_page(flags);
 		if (!page)
@@ -377,7 +423,7 @@ static struct page *alloc_zspage(struct size_class *class, gfp_t flags)
 
 		INIT_LIST_HEAD(&page->lru);
 		if (i == 0) {	/* first page */
-			set_bit(PG_private, &page->flags);
+			SetPagePrivate(page);
 			set_page_private(page, 0);
 			first_page = page;
 			first_page->inuse = 0;
@@ -388,9 +434,8 @@ static struct page *alloc_zspage(struct size_class *class, gfp_t flags)
 			page->first_page = first_page;
 		if (i >= 2)
 			list_add(&page->lru, &prev_page->lru);
-		if (i == class->zspage_order - 1)	/* last page */
-			set_bit(PG_private_2, &page->flags);
-
+		if (i == class->pages_per_zspage - 1)	/* last page */
+			SetPagePrivate2(page);
 		prev_page = page;
 	}
 
@@ -398,7 +443,7 @@ static struct page *alloc_zspage(struct size_class *class, gfp_t flags)
 
 	first_page->freelist = obj_location_to_handle(first_page, 0);
 	/* Maximum number of objects we can store in this zspage */
-	first_page->objects = class->zspage_order * PAGE_SIZE / class->size;
+	first_page->objects = class->pages_per_zspage * PAGE_SIZE / class->size;
 
 	error = 0; /* Success */
 
@@ -425,12 +470,51 @@ static struct page *find_get_zspage(struct size_class *class)
 	return page;
 }
 
+static void zs_copy_map_object(char *buf, struct page *firstpage,
+				int off, int size)
+{
+	struct page *pages[2];
+	int sizes[2];
+	void *addr;
+
+	pages[0] = firstpage;
+	pages[1] = get_next_page(firstpage);
+	BUG_ON(!pages[1]);
+
+	sizes[0] = PAGE_SIZE - off;
+	sizes[1] = size - sizes[0];
+
+	/* copy object to per-cpu buffer */
+	addr = kmap_atomic(pages[0]);
+	memcpy(buf, addr + off, sizes[0]);
+	kunmap_atomic(addr);
+	addr = kmap_atomic(pages[1]);
+	memcpy(buf + sizes[0], addr, sizes[1]);
+	kunmap_atomic(addr);
+}
 
-/*
- * If this becomes a separate module, register zs_init() with
- * module_init(), zs_exit with module_exit(), and remove zs_initialized
-*/
-static int zs_initialized;
+static void zs_copy_unmap_object(char *buf, struct page *firstpage,
+				int off, int size)
+{
+	struct page *pages[2];
+	int sizes[2];
+	void *addr;
+
+	pages[0] = firstpage;
+	pages[1] = get_next_page(firstpage);
+	BUG_ON(!pages[1]);
+
+	sizes[0] = PAGE_SIZE - off;
+	sizes[1] = size - sizes[0];
+
+	/* copy per-cpu buffer to object */
+	addr = kmap_atomic(pages[0]);
+	memcpy(addr + off, buf, sizes[0]);
+	kunmap_atomic(addr);
+	addr = kmap_atomic(pages[1]);
+	memcpy(addr, buf + sizes[0], sizes[1]);
+	kunmap_atomic(addr);
+}
 
 static int zs_cpu_notifier(struct notifier_block *nb, unsigned long action,
 				void *pcpu)
@@ -441,18 +525,23 @@ static int zs_cpu_notifier(struct notifier_block *nb, unsigned long action,
 	switch (action) {
 	case CPU_UP_PREPARE:
 		area = &per_cpu(zs_map_area, cpu);
-		if (area->vm)
-			break;
-		area->vm = alloc_vm_area(2 * PAGE_SIZE, area->vm_ptes);
-		if (!area->vm)
-			return notifier_from_errno(-ENOMEM);
+		/*
+		 * Make sure we don't leak memory if a cpu UP notification
+		 * and zs_init() race and both call zs_cpu_up() on the same cpu
+		 */
+		if (area->vm_buf)
+			return 0;
+		area->vm_buf = (char *)__get_free_page(GFP_KERNEL);
+		if (!area->vm_buf)
+			return -ENOMEM;
+		return 0;
 		break;
 	case CPU_DEAD:
 	case CPU_UP_CANCELED:
 		area = &per_cpu(zs_map_area, cpu);
-		if (area->vm)
-			free_vm_area(area->vm);
-		area->vm = NULL;
+		if (area->vm_buf)
+			free_page((unsigned long)area->vm_buf);
+		area->vm_buf = NULL;
 		break;
 	}
 
@@ -490,7 +579,7 @@ fail:
 
 struct zs_pool *zs_create_pool(const char *name, gfp_t flags)
 {
-	int i, error, ovhd_size;
+	int i, ovhd_size;
 	struct zs_pool *pool;
 
 	if (!name)
@@ -513,32 +602,13 @@ struct zs_pool *zs_create_pool(const char *name, gfp_t flags)
 		class->size = size;
 		class->index = i;
 		spin_lock_init(&class->lock);
-		class->zspage_order = get_zspage_order(size);
+		class->pages_per_zspage = get_pages_per_zspage(size);
 
 	}
 
-	/*
-	 * If this becomes a separate module, register zs_init with
-	 * module_init, and remove this block
-	*/
-	if (!zs_initialized) {
-		error = zs_init();
-		if (error)
-			goto cleanup;
-		zs_initialized = 1;
-	}
-
 	pool->flags = flags;
 	pool->name = name;
 
-	error = 0; /* Success */
-
-cleanup:
-	if (error) {
-		zs_destroy_pool(pool);
-		pool = NULL;
-	}
-
 	return pool;
 }
 EXPORT_SYMBOL_GPL(zs_create_pool);
@@ -567,18 +637,14 @@ EXPORT_SYMBOL_GPL(zs_destroy_pool);
  * zs_malloc - Allocate block of given size from pool.
  * @pool: pool to allocate from
  * @size: size of block to allocate
- * @page: page no. that holds the object
- * @offset: location of object within page
- *
- * On success, <page, offset> identifies block allocated
- * and 0 is returned. On failure, <page, offset> is set to
- * 0 and -ENOMEM is returned.
  *
+ * On success, handle to the allocated object is returned,
+ * otherwise 0.
  * Allocation requests with size > ZS_MAX_ALLOC_SIZE will fail.
  */
-void *zs_malloc(struct zs_pool *pool, size_t size)
+unsigned long zs_malloc(struct zs_pool *pool, size_t size)
 {
-	void *obj;
+	unsigned long obj;
 	struct link_free *link;
 	int class_idx;
 	struct size_class *class;
@@ -587,7 +653,7 @@ void *zs_malloc(struct zs_pool *pool, size_t size)
 	unsigned long m_objidx, m_offset;
 
 	if (unlikely(!size || size > ZS_MAX_ALLOC_SIZE))
-		return NULL;
+		return 0;
 
 	class_idx = get_size_class_index(size);
 	class = &pool->size_class[class_idx];
@@ -600,14 +666,14 @@ void *zs_malloc(struct zs_pool *pool, size_t size)
 		spin_unlock(&class->lock);
 		first_page = alloc_zspage(class, pool->flags);
 		if (unlikely(!first_page))
-			return NULL;
+			return 0;
 
 		set_zspage_mapping(first_page, class->index, ZS_EMPTY);
 		spin_lock(&class->lock);
-		class->pages_allocated += class->zspage_order;
+		class->pages_allocated += class->pages_per_zspage;
 	}
 
-	obj = first_page->freelist;
+	obj = (unsigned long)first_page->freelist;
 	obj_handle_to_location(obj, &m_page, &m_objidx);
 	m_offset = obj_idx_to_offset(m_page, m_objidx, class->size);
 
@@ -626,7 +692,7 @@ void *zs_malloc(struct zs_pool *pool, size_t size)
 }
 EXPORT_SYMBOL_GPL(zs_malloc);
 
-void zs_free(struct zs_pool *pool, void *obj)
+void zs_free(struct zs_pool *pool, unsigned long obj)
 {
 	struct link_free *link;
 	struct page *first_page, *f_page;
@@ -653,13 +719,13 @@ void zs_free(struct zs_pool *pool, void *obj)
 							+ f_offset);
 	link->next = first_page->freelist;
 	kunmap_atomic(link);
-	first_page->freelist = obj;
+	first_page->freelist = (void *)obj;
 
 	first_page->inuse--;
 	fullness = fix_fullness_group(pool, first_page);
 
 	if (fullness == ZS_EMPTY)
-		class->pages_allocated -= class->zspage_order;
+		class->pages_allocated -= class->pages_per_zspage;
 
 	spin_unlock(&class->lock);
 
@@ -668,7 +734,22 @@ void zs_free(struct zs_pool *pool, void *obj)
 }
 EXPORT_SYMBOL_GPL(zs_free);
 
-void *zs_map_object(struct zs_pool *pool, void *handle)
+/**
+ * zs_map_object - get address of allocated object from handle.
+ * @pool: pool from which the object was allocated
+ * @handle: handle returned from zs_malloc
+ *
+ * Before using an object allocated from zs_malloc, it must be mapped using
+ * this function. When done with the object, it must be unmapped using
+ * zs_unmap_object.
+ *
+ * Only one object can be mapped per cpu at a time. There is no protection
+ * against nested mappings.
+ *
+ * This function returns with preemption and page faults disabled.
+*/
+void *zs_map_object(struct zs_pool *pool, unsigned long handle,
+			enum zs_mapmode mm)
 {
 	struct page *page;
 	unsigned long obj_idx, off;
@@ -689,26 +770,20 @@ void *zs_map_object(struct zs_pool *pool, void *handle)
 	if (off + class->size <= PAGE_SIZE) {
 		/* this object is contained entirely within a page */
 		area->vm_addr = kmap_atomic(page);
-	} else {
-		/* this object spans two pages */
-		struct page *nextp;
-
-		nextp = get_next_page(page);
-		BUG_ON(!nextp);
-
-
-		set_pte(area->vm_ptes[0], mk_pte(page, PAGE_KERNEL));
-		set_pte(area->vm_ptes[1], mk_pte(nextp, PAGE_KERNEL));
-
-		/* We pre-allocated VM area so mapping can never fail */
-		area->vm_addr = area->vm->addr;
+		return area->vm_addr + off;
 	}
 
-	return area->vm_addr + off;
+	/* disable page faults to match kmap_atomic() return conditions */
+	pagefault_disable();
+
+	if (mm != ZS_MM_WO)
+		zs_copy_map_object(area->vm_buf, page, off, class->size);
+	area->vm_addr = NULL;
+	return area->vm_buf;
 }
 EXPORT_SYMBOL_GPL(zs_map_object);
 
-void zs_unmap_object(struct zs_pool *pool, void *handle)
+void zs_unmap_object(struct zs_pool *pool, unsigned long handle)
 {
 	struct page *page;
 	unsigned long obj_idx, off;
@@ -718,6 +793,17 @@ void zs_unmap_object(struct zs_pool *pool, void *handle)
 	struct size_class *class;
 	struct mapping_area *area;
 
+	area = &__get_cpu_var(zs_map_area);
+	/* single-page object fastpath */
+	if (area->vm_addr) {
+		kunmap_atomic(area->vm_addr);
+		goto out;
+	}
+
+	/* no write fastpath */
+	if (area->vm_mm == ZS_MM_RO)
+		goto pfenable;
+
 	BUG_ON(!handle);
 
 	obj_handle_to_location(handle, &page, &obj_idx);
@@ -725,15 +811,12 @@ void zs_unmap_object(struct zs_pool *pool, void *handle)
 	class = &pool->size_class[class_idx];
 	off = obj_idx_to_offset(page, obj_idx, class->size);
 
-	area = &__get_cpu_var(zs_map_area);
-	if (off + class->size <= PAGE_SIZE) {
-		kunmap_atomic(area->vm_addr);
-	} else {
-		set_pte(area->vm_ptes[0], __pte(0));
-		set_pte(area->vm_ptes[1], __pte(0));
-		__flush_tlb_one((unsigned long)area->vm_addr);
-		__flush_tlb_one((unsigned long)area->vm_addr + PAGE_SIZE);
-	}
+	zs_copy_unmap_object(area->vm_buf, page, off, class->size);
+
+pfenable:
+	/* enable page faults to match kunmap_atomic() return conditions */
+	pagefault_enable();
+out:
 	put_cpu_var(zs_map_area);
 }
 EXPORT_SYMBOL_GPL(zs_unmap_object);
@@ -749,3 +832,9 @@ u64 zs_get_total_size_bytes(struct zs_pool *pool)
 	return npages << PAGE_SHIFT;
 }
 EXPORT_SYMBOL_GPL(zs_get_total_size_bytes);
+
+module_init(zs_init);
+module_exit(zs_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Nitin Gupta <ngupta@vflare.org>");
diff --git a/drivers/staging/zsmalloc/zsmalloc.h b/drivers/staging/zsmalloc/zsmalloc.h
index 949384ee..de2e8bfb 100644
--- a/drivers/staging/zsmalloc/zsmalloc.h
+++ b/drivers/staging/zsmalloc/zsmalloc.h
@@ -15,16 +15,28 @@
 
 #include <linux/types.h>
 
+/*
+ * zsmalloc mapping modes
+ *
+ * NOTE: These only make a difference when a mapped object spans pages
+*/
+enum zs_mapmode {
+	ZS_MM_RW, /* normal read-write mapping */
+	ZS_MM_RO, /* read-only (no copy-out at unmap time) */
+	ZS_MM_WO /* write-only (no copy-in at map time) */
+};
+
 struct zs_pool;
 
 struct zs_pool *zs_create_pool(const char *name, gfp_t flags);
 void zs_destroy_pool(struct zs_pool *pool);
 
-void *zs_malloc(struct zs_pool *pool, size_t size);
-void zs_free(struct zs_pool *pool, void *obj);
+unsigned long zs_malloc(struct zs_pool *pool, size_t size);
+void zs_free(struct zs_pool *pool, unsigned long obj);
 
-void *zs_map_object(struct zs_pool *pool, void *handle);
-void zs_unmap_object(struct zs_pool *pool, void *handle);
+void *zs_map_object(struct zs_pool *pool, unsigned long handle,
+			enum zs_mapmode mm);
+void zs_unmap_object(struct zs_pool *pool, unsigned long handle);
 
 u64 zs_get_total_size_bytes(struct zs_pool *pool);
 
diff --git a/drivers/staging/zsmalloc/zsmalloc_int.h b/drivers/staging/zsmalloc/zsmalloc_int.h
index 92eefc66..52805176 100644
--- a/drivers/staging/zsmalloc/zsmalloc_int.h
+++ b/drivers/staging/zsmalloc/zsmalloc_int.h
@@ -110,9 +110,9 @@ enum fullness_group {
 static const int fullness_threshold_frac = 4;
 
 struct mapping_area {
-	struct vm_struct *vm;
-	pte_t *vm_ptes[2];
-	char *vm_addr;
+	char *vm_buf; /* copy buffer for objects that span pages */
+	char *vm_addr; /* address of kmap_atomic()'ed pages */
+	enum zs_mapmode vm_mm; /* mapping mode */
 };
 
 struct size_class {
@@ -124,7 +124,7 @@ struct size_class {
 	unsigned int index;
 
 	/* Number of PAGE_SIZE sized pages to combine to form a 'zspage' */
-	int zspage_order;
+	int pages_per_zspage;
 
 	spinlock_t lock;
 
diff --git a/drivers/tty/serial/pxa.c b/drivers/tty/serial/pxa.c
index 5847a4b8..d9455a7d 100644
--- a/drivers/tty/serial/pxa.c
+++ b/drivers/tty/serial/pxa.c
@@ -44,19 +44,104 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/wakelock.h>
+#include <plat/pm.h>
+#include <mach/dma.h>
+
+#define	DMA_BLOCK	UART_XMIT_SIZE
+
+#define PXA_UART_TX	0
+#define PXA_UART_RX	1
 
 #define PXA_NAME_LEN		8
 
 struct uart_pxa_port {
 	struct uart_port        port;
-	unsigned char           ier;
+	unsigned int            ier;
 	unsigned char           lcr;
-	unsigned char           mcr;
+	unsigned int            mcr;
 	unsigned int            lsr_break_flag;
 	struct clk		*clk;
 	char			name[PXA_NAME_LEN];
+	struct timer_list	pxa_timer;
+
+#define TX_DMA_RUNNING		(1 << 0)
+#define RX_DMA_RUNNING		(1 << 1)
+	unsigned int		dma_status;
+	struct work_struct	uart_tx_lpm_work;
+	struct pm_qos_request	qos_idle[2];
+	int			txdma;
+	int			rxdma;
+	void			*txdma_addr;
+	void			*rxdma_addr;
+	dma_addr_t		txdma_addr_phys;
+	dma_addr_t		rxdma_addr_phys;
+	int			dma_enable;
+	int			tx_stop;
+	int			rx_stop;
+	int			data_len;
+	volatile unsigned int	*txdrcmr;
+	volatile unsigned int	*rxdrcmr;
+	struct	tasklet_struct	tklet;
+#ifdef	CONFIG_PM
+	/* We needn't save rx dma register because we
+	 * just restart the dma totallly after resume
+	 */
+	void			*buf_save;
+	unsigned long		dcsr_tx;
+	unsigned long		dsadr_tx;
+	unsigned long		dtadr_tx;
+	unsigned long		dcmd_tx;
+#endif
 };
 
+static int uart_dma;
+
+static int __init uart_dma_setup(char *__unused)
+{
+	uart_dma = 1;
+	return 1;
+}
+__setup("uart_dma", uart_dma_setup);
+
+static inline void stop_dma(struct uart_pxa_port *up, int read)
+{
+	unsigned long flags;
+	unsigned int channel, dcsr;
+	int timeout = 10000;
+
+	channel = read ? up->rxdma : up->txdma;
+	dcsr = DCSR(channel);
+	if (!(dcsr & DCSR_RUN))
+		return;
+
+	DCSR(channel) = dcsr & ~DCSR_RUN;
+
+	/* if have DMA reqeust, wait. */
+	while (!(DCSR(channel) & DCSR_STOPSTATE) && (timeout-- > 0))
+		rmb();
+
+	BUG_ON(timeout <= 0);
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (read)
+		up->dma_status &= ~RX_DMA_RUNNING;
+	else
+		up->dma_status &= ~TX_DMA_RUNNING;
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void pxa_uart_transmit_dma(int channel, void *data);
+static void pxa_uart_receive_dma(int channel, void *data);
+static void pxa_uart_transmit_dma_start(struct uart_pxa_port *up, int count);
+static void pxa_uart_receive_dma_start(struct uart_pxa_port *up);
+static inline void wait_for_xmitr(struct uart_pxa_port *up);
+static inline void serial_out(struct uart_pxa_port *up, int offset, int value);
+
+static unsigned int serial_pxa_tx_empty(struct uart_port *port);
+
+#define PXA_TIMER_TIMEOUT (3*HZ)
+
 static inline unsigned int serial_in(struct uart_pxa_port *up, int offset)
 {
 	offset <<= 2;
@@ -73,6 +158,9 @@ static void serial_pxa_enable_ms(struct uart_port *port)
 {
 	struct uart_pxa_port *up = (struct uart_pxa_port *)port;
 
+	if (up->dma_enable)
+		return;
+
 	up->ier |= UART_IER_MSI;
 	serial_out(up, UART_IER, up->ier);
 }
@@ -80,10 +168,32 @@ static void serial_pxa_enable_ms(struct uart_port *port)
 static void serial_pxa_stop_tx(struct uart_port *port)
 {
 	struct uart_pxa_port *up = (struct uart_pxa_port *)port;
+	unsigned int timeout = 0x100000;
 
-	if (up->ier & UART_IER_THRI) {
-		up->ier &= ~UART_IER_THRI;
-		serial_out(up, UART_IER, up->ier);
+	if (up->dma_enable) {
+		up->tx_stop = 1;
+
+		if (up->ier & UART_IER_DMAE) {
+			/*
+			 * Here we still need DCSR as the judgment of
+			 * whether dma has been transfer completed
+			 * As there when this function is being caled,
+			 * it would hold a spinlock and possible with irqsave,
+			 * If this function is being called over core0,
+			 * we may cannot get status change from the flag,
+			 * As irq handler is being blocked to be called yet.
+			 */
+			while (!(DCSR(up->txdma) & DCSR_STOPSTATE)
+					&& (timeout-- > 0))
+				rmb();
+
+			BUG_ON(timeout == 0);
+		}
+	} else {
+		if (up->ier & UART_IER_THRI) {
+			up->ier &= ~UART_IER_THRI;
+			serial_out(up, UART_IER, up->ier);
+		}
 	}
 }
 
@@ -91,9 +201,18 @@ static void serial_pxa_stop_rx(struct uart_port *port)
 {
 	struct uart_pxa_port *up = (struct uart_pxa_port *)port;
 
-	up->ier &= ~UART_IER_RLSI;
-	up->port.read_status_mask &= ~UART_LSR_DR;
-	serial_out(up, UART_IER, up->ier);
+	if (up->dma_enable) {
+		if (up->ier & UART_IER_DMAE) {
+			spin_unlock(&up->port.lock);
+			stop_dma(up, 1);
+			spin_lock(&up->port.lock);
+		}
+		up->rx_stop = 1;
+	} else {
+		up->ier &= ~UART_IER_RLSI;
+		up->port.read_status_mask &= ~UART_LSR_DR;
+		serial_out(up, UART_IER, up->ier);
+	}
 }
 
 static inline void receive_chars(struct uart_pxa_port *up, int *status)
@@ -110,8 +229,10 @@ static inline void receive_chars(struct uart_pxa_port *up, int *status)
 		 * Step 2
 		 * Disable the Reciever Time Out Interrupt via IER[RTOEI]
 		 */
+		spin_lock(&up->port.lock);
 		up->ier &= ~UART_IER_RTOIE;
 		serial_out(up, UART_IER, up->ier);
+		spin_unlock(&up->port.lock);
 
 		ch = serial_in(up, UART_RX);
 		flag = TTY_NORMAL;
@@ -177,8 +298,10 @@ static inline void receive_chars(struct uart_pxa_port *up, int *status)
 	 * Step 6:
 	 * No more data in FIFO: Re-enable RTO interrupt via IER[RTOIE]
 	 */
+	spin_lock(&up->port.lock);
 	up->ier |= UART_IER_RTOIE;
 	serial_out(up, UART_IER, up->ier);
+	spin_unlock(&up->port.lock);
 }
 
 static void transmit_chars(struct uart_pxa_port *up)
@@ -193,7 +316,9 @@ static void transmit_chars(struct uart_pxa_port *up)
 		return;
 	}
 	if (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {
+		spin_lock(&up->port.lock);
 		serial_pxa_stop_tx(&up->port);
+		spin_unlock(&up->port.lock);
 		return;
 	}
 
@@ -210,17 +335,118 @@ static void transmit_chars(struct uart_pxa_port *up)
 		uart_write_wakeup(&up->port);
 
 
-	if (uart_circ_empty(xmit))
+	if (uart_circ_empty(xmit)) {
+		spin_lock(&up->port.lock);
 		serial_pxa_stop_tx(&up->port);
+		spin_unlock(&up->port.lock);
+	}
+}
+
+static inline void
+dma_receive_chars(struct uart_pxa_port *up, int *status)
+{
+	struct tty_struct *tty = up->port.state->port.tty;
+	unsigned char ch;
+	int max_count = 256;
+	int count = 0;
+	unsigned char *tmp;
+	unsigned int flag = TTY_NORMAL;
+
+	stop_dma(up, 1);
+	/*
+	 * deal with the bytes received by DMA
+	 */
+	count = DTADR(up->rxdma) - up->rxdma_addr_phys;
+	tmp = up->rxdma_addr;
+	if (up->port.sysrq) {
+		while (count > 0) {
+			if (!uart_handle_sysrq_char(&up->port, *tmp)) {
+				uart_insert_char(&up->port, *status,
+						 0, *tmp, flag);
+				up->port.icount.rx++;
+			}
+			tmp++;
+			count--;
+		}
+	} else {
+		tty_insert_flip_string(tty, tmp, count);
+		up->port.icount.rx += count;
+	}
+
+	/* deal with the bytes in rx FIFO */
+	do {
+		ch = serial_in(up, UART_RX);
+		flag = TTY_NORMAL;
+		up->port.icount.rx++;
+
+		if (unlikely(*status & (UART_LSR_BI | UART_LSR_PE |
+					UART_LSR_FE | UART_LSR_OE))) {
+			/*
+			 * For statistics only
+			 */
+			if (*status & UART_LSR_BI) {
+				*status &= ~(UART_LSR_FE | UART_LSR_PE);
+				up->port.icount.brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+				if (uart_handle_break(&up->port))
+					goto ignore_char2;
+			} else if (*status & UART_LSR_PE)
+				up->port.icount.parity++;
+			else if (*status & UART_LSR_FE)
+				up->port.icount.frame++;
+			if (*status & UART_LSR_OE)
+				up->port.icount.overrun++;
+
+			/*
+			 * Mask off conditions which should be ignored.
+			 */
+			*status &= up->port.read_status_mask;
+
+#ifdef CONFIG_SERIAL_PXA_CONSOLE
+			if (up->port.line == up->port.cons->index) {
+				/* Recover the break flag from console xmit */
+				*status |= up->lsr_break_flag;
+				up->lsr_break_flag = 0;
+			}
+#endif
+			if (*status & UART_LSR_BI)
+				flag = TTY_BREAK;
+			else if (*status & UART_LSR_PE)
+				flag = TTY_PARITY;
+			else if (*status & UART_LSR_FE)
+				flag = TTY_FRAME;
+		}
+		if (!uart_handle_sysrq_char(&up->port, ch))
+			uart_insert_char(&up->port, *status, UART_LSR_OE,
+					 ch, flag);
+ignore_char2:
+		*status = serial_in(up, UART_LSR);
+	} while ((*status & UART_LSR_DR) && (max_count-- > 0));
+
+	tty_schedule_flip(tty);
+
+	if (up->rx_stop)
+		return;
+	pxa_uart_receive_dma_start(up);
 }
 
 static void serial_pxa_start_tx(struct uart_port *port)
 {
 	struct uart_pxa_port *up = (struct uart_pxa_port *)port;
 
-	if (!(up->ier & UART_IER_THRI)) {
-		up->ier |= UART_IER_THRI;
-		serial_out(up, UART_IER, up->ier);
+	if (up->dma_enable) {
+		up->tx_stop = 0;
+		tasklet_schedule(&up->tklet);
+	} else {
+		if (!(up->ier & UART_IER_THRI)) {
+			up->ier |= UART_IER_THRI;
+			serial_out(up, UART_IER, up->ier);
+		}
 	}
 }
 
@@ -253,15 +479,41 @@ static inline irqreturn_t serial_pxa_irq(int irq, void *dev_id)
 	struct uart_pxa_port *up = dev_id;
 	unsigned int iir, lsr;
 
+	/*
+	 * If FCR[4] is set, we may receive EOC interrupt when:
+	 * 1) current descritor of DMA finishes successfully;
+	 * 2) there are still trailing bytes in UART FIFO.
+	 * This interrupt alway comes along with UART_IIR_NO_INT.
+	 * So this interrupt is just ignored by us.
+	 */
 	iir = serial_in(up, UART_IIR);
 	if (iir & UART_IIR_NO_INT)
 		return IRQ_NONE;
+
+	/* timer is not active */
+	if (!mod_timer(&up->pxa_timer, jiffies + PXA_TIMER_TIMEOUT))
+		pm_qos_update_request(&up->qos_idle[PXA_UART_RX],
+				PM_QOS_CPUIDLE_BLOCK_AXI_VALUE);
+
 	lsr = serial_in(up, UART_LSR);
-	if (lsr & UART_LSR_DR)
-		receive_chars(up, &lsr);
-	check_modem_status(up);
-	if (lsr & UART_LSR_THRE)
-		transmit_chars(up);
+	if (up->dma_enable) {
+		/* we only need to deal with FIFOE here */
+		if (lsr & UART_LSR_FIFOE)
+			dma_receive_chars(up, &lsr);
+	} else {
+		if (lsr & UART_LSR_DR)
+			receive_chars(up, &lsr);
+
+		check_modem_status(up);
+		if (lsr & UART_LSR_THRE) {
+			transmit_chars(up);
+			/* wait Tx empty */
+			while (!serial_pxa_tx_empty(	\
+						(struct uart_port *)dev_id))
+				;
+		}
+	}
+
 	return IRQ_HANDLED;
 }
 
@@ -272,6 +524,16 @@ static unsigned int serial_pxa_tx_empty(struct uart_port *port)
 	unsigned int ret;
 
 	spin_lock_irqsave(&up->port.lock, flags);
+
+	if (up->dma_enable) {
+		if (up->ier & UART_IER_DMAE) {
+			if (up->dma_status & TX_DMA_RUNNING) {
+				spin_unlock_irqrestore(&up->port.lock, flags);
+				return 0;
+			}
+		}
+	}
+
 	ret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;
 	spin_unlock_irqrestore(&up->port.lock, flags);
 
@@ -301,7 +563,7 @@ static unsigned int serial_pxa_get_mctrl(struct uart_port *port)
 static void serial_pxa_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
 	struct uart_pxa_port *up = (struct uart_pxa_port *)port;
-	unsigned char mcr = 0;
+	unsigned int mcr = 0;
 
 	if (mctrl & TIOCM_RTS)
 		mcr |= UART_MCR_RTS;
@@ -333,31 +595,273 @@ static void serial_pxa_break_ctl(struct uart_port *port, int break_state)
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
-#if 0
-static void serial_pxa_dma_init(struct pxa_uart *up)
+static void pxa_uart_transmit_dma_start(struct uart_pxa_port *up, int count)
+{
+	DCSR(up->txdma)  = DCSR_NODESC;
+	DSADR(up->txdma) = up->txdma_addr_phys;
+	DTADR(up->txdma) = up->port.mapbase;
+	DCMD(up->txdma) = DCMD_INCSRCADDR | DCMD_FLOWTRG | DCMD_ENDIRQEN |
+		DCMD_WIDTH1 | DCMD_BURST16 | count;
+
+	pm_qos_update_request(&up->qos_idle[PXA_UART_TX],
+			PM_QOS_CPUIDLE_BLOCK_AXI_VALUE);
+
+	DCSR(up->txdma) |= DCSR_RUN;
+}
+
+static void pxa_uart_receive_dma_start(struct uart_pxa_port *up)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (up->dma_status & RX_DMA_RUNNING) {
+		spin_unlock_irqrestore(&up->port.lock, flags);
+		return;
+	}
+	up->dma_status |= RX_DMA_RUNNING;
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	DCSR(up->rxdma)  = DCSR_NODESC | DCSR_EORIRQEN | DCSR_EORSTOPEN;
+	DSADR(up->rxdma) = up->port.mapbase;
+	DTADR(up->rxdma) = up->rxdma_addr_phys;
+	DCMD(up->rxdma) = DCMD_INCTRGADDR | DCMD_FLOWSRC | DCMD_ENDIRQEN |
+		DCMD_WIDTH1 | DCMD_BURST16 | DMA_BLOCK;
+	DCSR(up->rxdma) |= DCSR_RUN;
+}
+
+static void pxa_uart_receive_dma(int channel, void *data)
+{
+	volatile unsigned long dcsr;
+	unsigned long flags;
+	struct uart_pxa_port *up = (struct uart_pxa_port *)data;
+	struct tty_struct *tty = up->port.state->port.tty;
+	unsigned int count;
+	unsigned char *tmp = up->rxdma_addr;
+
+	if (!mod_timer(&up->pxa_timer, jiffies + PXA_TIMER_TIMEOUT))
+		pm_qos_update_request(&up->qos_idle[PXA_UART_RX],
+				PM_QOS_CPUIDLE_BLOCK_AXI_VALUE);
+	dcsr = DCSR(channel);
+
+	if (dcsr & DCSR_ENDINTR)
+		DCSR(channel) |= DCSR_ENDINTR;
+	if (dcsr & DCSR_EORINTR)
+		DCSR(channel) |= DCSR_EORINTR;
+	if (dcsr & DCSR_BUSERR) {
+		DCSR(channel) |= DCSR_BUSERR;
+		printk(KERN_ALERT "%s(): DMA channel bus error\n", __func__);
+	}
+
+	count = DTADR(channel) - up->rxdma_addr_phys;
+	if (up->port.sysrq) {
+		while (count > 0) {
+			if (!uart_handle_sysrq_char(&up->port, *tmp)) {
+				tty_insert_flip_char(tty, *tmp, TTY_NORMAL);
+				up->port.icount.rx++;
+			}
+			tmp++;
+			count--;
+		}
+	} else {
+		tty_insert_flip_string(tty, tmp, count);
+		up->port.icount.rx += count;
+	}
+	tty_flip_buffer_push(tty);
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	/*
+	 * DMA_RUNNING flag should be clear only after
+	 * all dma interface operation completed
+	 */
+	up->dma_status &= ~RX_DMA_RUNNING;
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	if (up->rx_stop)
+		return;
+	pxa_uart_receive_dma_start(up);
+	return;
+}
+
+static void pxa_uart_transmit_dma(int channel, void *data)
+{
+	struct uart_pxa_port *up = (struct uart_pxa_port *)data;
+	struct circ_buf *xmit = &up->port.state->xmit;
+	volatile unsigned long dcsr;
+
+	dcsr = DCSR(channel);
+
+	if (dcsr & DCSR_BUSERR) {
+		DCSR(channel) |= DCSR_BUSERR;
+		printk(KERN_ALERT "%s(): DMA channel bus error\n", __func__);
+	}
+
+	if (dcsr & DCSR_STOPSTATE)
+		schedule_work(&up->uart_tx_lpm_work);
+
+	if (dcsr & DCSR_ENDINTR)
+		DCSR(channel) |= DCSR_ENDINTR;
+
+	spin_lock(&up->port.lock);
+	/*
+	 * DMA_RUNNING flag should be clear only after
+	 * all dma interface operation completed
+	 */
+	up->dma_status &= ~TX_DMA_RUNNING;
+	spin_unlock(&up->port.lock);
+
+	/* if tx stop, stop transmit DMA and return */
+	if (up->tx_stop)
+		return;
+
+	if (up->port.x_char) {
+		serial_out(up, UART_TX, up->port.x_char);
+		up->port.icount.tx++;
+		up->port.x_char = 0;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+
+	if (!uart_circ_empty(xmit))
+		tasklet_schedule(&up->tklet);
+	return;
+}
+
+static void uart_pxa_dma_init(struct uart_pxa_port *up)
 {
-	up->rxdma =
-		pxa_request_dma(up->name, DMA_PRIO_LOW, pxa_receive_dma, up);
-	if (up->rxdma < 0)
-		goto out;
-	up->txdma =
-		pxa_request_dma(up->name, DMA_PRIO_LOW, pxa_transmit_dma, up);
-	if (up->txdma < 0)
-		goto err_txdma;
-	up->dmadesc = kmalloc(4 * sizeof(pxa_dma_desc), GFP_KERNEL);
-	if (!up->dmadesc)
-		goto err_alloc;
 
-	/* ... */
-err_alloc:
+	if (0 == up->rxdma) {
+		up->rxdma = pxa_request_dma(up->name, DMA_PRIO_LOW,
+				pxa_uart_receive_dma, up);
+		if (up->rxdma < 0)
+			goto out;
+	}
+
+	if (0 == up->txdma) {
+		up->txdma = pxa_request_dma(up->name, DMA_PRIO_LOW,
+				pxa_uart_transmit_dma, up);
+		if (up->txdma < 0)
+			goto err_txdma;
+	}
+
+	if (NULL == up->txdma_addr) {
+		up->txdma_addr = dma_alloc_coherent(NULL, DMA_BLOCK,
+				&up->txdma_addr_phys, GFP_KERNEL);
+		if (!up->txdma_addr)
+			goto txdma_err_alloc;
+	}
+
+	if (NULL == up->rxdma_addr) {
+		up->rxdma_addr = dma_alloc_coherent(NULL, DMA_BLOCK,
+				&up->rxdma_addr_phys, GFP_KERNEL);
+		if (!up->rxdma_addr)
+			goto rxdma_err_alloc;
+	}
+
+#ifdef CONFIG_PM
+	up->buf_save = kmalloc(DMA_BLOCK, GFP_KERNEL);
+	if (!up->buf_save)
+		goto buf_err_alloc;
+#endif
+
+	up->dma_status = 0;
+	writel(up->rxdma | DRCMR_MAPVLD, up->rxdrcmr);
+	writel(up->txdma | DRCMR_MAPVLD, up->txdrcmr);
+	DALGN |= (0x1 << up->rxdma);
+
+	return;
+
+#ifdef CONFIG_PM
+buf_err_alloc:
+	dma_free_coherent(NULL, DMA_BLOCK, up->rxdma_addr,
+			up->rxdma_addr_phys);
+	up->rxdma_addr = NULL;
+#endif
+rxdma_err_alloc:
+	dma_free_coherent(NULL, DMA_BLOCK, up->txdma_addr,
+			up->txdma_addr_phys);
+	up->txdma_addr = NULL;
+txdma_err_alloc:
 	pxa_free_dma(up->txdma);
-err_rxdma:
+	up->txdma = 0;
+err_txdma:
 	pxa_free_dma(up->rxdma);
+	up->rxdma = 0;
 out:
 	return;
 }
+
+static void uart_pxa_dma_uninit(struct uart_pxa_port *up)
+{
+#ifdef CONFIG_PM
+	kfree(up->buf_save);
 #endif
 
+	stop_dma(up, 0);
+	stop_dma(up, 1);
+	if (up->txdma_addr != NULL) {
+		dma_free_coherent(NULL, DMA_BLOCK, up->txdma_addr,
+				up->txdma_addr_phys);
+		up->txdma_addr = NULL;
+	}
+	if (up->txdma != 0) {
+		pxa_free_dma(up->txdma);
+		writel(0, up->txdrcmr);
+		up->txdma = 0;
+	}
+
+	if (up->rxdma_addr != NULL) {
+		dma_free_coherent(NULL, DMA_BLOCK, up->rxdma_addr,
+				up->rxdma_addr_phys);
+		up->rxdma_addr = NULL;
+	}
+
+	if (up->rxdma != 0) {
+		pxa_free_dma(up->rxdma);
+		DALGN &= ~(0x1 << up->rxdma);
+		writel(0, up->rxdrcmr);
+		up->rxdma = 0;
+	}
+
+	return;
+}
+
+static void uart_task_action(unsigned long data)
+{
+	struct uart_pxa_port *up = (struct uart_pxa_port *)data;
+	struct circ_buf *xmit = &up->port.state->xmit;
+	unsigned char *tmp = up->txdma_addr;
+	unsigned long flags;
+	int count = 0, c;
+
+	/* if the tx is stop, just return.*/
+	if (up->tx_stop)
+		return;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (up->dma_status & TX_DMA_RUNNING) {
+		spin_unlock_irqrestore(&up->port.lock, flags);
+		return;
+	}
+
+	up->dma_status |= TX_DMA_RUNNING;
+	while (1) {
+		c = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);
+		if (c <= 0)
+			break;
+
+		memcpy(tmp, xmit->buf + xmit->tail, c);
+		xmit->tail = (xmit->tail + c) & (UART_XMIT_SIZE - 1);
+		tmp += c;
+		count += c;
+		up->port.icount.tx += c;
+	}
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	pr_debug("count =%d", count);
+	pxa_uart_transmit_dma_start(up, count);
+}
+
 static int serial_pxa_startup(struct uart_port *port)
 {
 	struct uart_pxa_port *up = (struct uart_pxa_port *)port;
@@ -410,8 +914,22 @@ static int serial_pxa_startup(struct uart_port *port)
 	 * are set via set_termios(), which will be occurring imminently
 	 * anyway, so we don't enable them here.
 	 */
-	up->ier = UART_IER_RLSI | UART_IER_RDI | UART_IER_RTOIE | UART_IER_UUE;
+	if (up->dma_enable) {
+		uart_pxa_dma_init(up);
+		up->rx_stop = 0;
+		pxa_uart_receive_dma_start(up);
+		tasklet_init(&up->tklet, uart_task_action, (unsigned long)up);
+	}
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (up->dma_enable) {
+		up->ier = UART_IER_DMAE | UART_IER_UUE;
+	} else {
+		up->ier = UART_IER_RLSI | UART_IER_RDI |
+			UART_IER_RTOIE | UART_IER_UUE;
+	}
 	serial_out(up, UART_IER, up->ier);
+	spin_unlock_irqrestore(&up->port.lock, flags);
 
 	/*
 	 * And clear the interrupt registers again for luck.
@@ -429,15 +947,22 @@ static void serial_pxa_shutdown(struct uart_port *port)
 	struct uart_pxa_port *up = (struct uart_pxa_port *)port;
 	unsigned long flags;
 
+	flush_work(&up->uart_tx_lpm_work);
+
 	free_irq(up->port.irq, up);
 
+	if (up->dma_enable) {
+		tasklet_kill(&up->tklet);
+		uart_pxa_dma_uninit(up);
+	}
+
 	/*
 	 * Disable interrupts from this port
 	 */
+	spin_lock_irqsave(&up->port.lock, flags);
 	up->ier = 0;
 	serial_out(up, UART_IER, 0);
 
-	spin_lock_irqsave(&up->port.lock, flags);
 	up->port.mctrl &= ~TIOCM_OUT2;
 	serial_pxa_set_mctrl(&up->port, up->port.mctrl);
 	spin_unlock_irqrestore(&up->port.lock, flags);
@@ -459,7 +984,7 @@ serial_pxa_set_termios(struct uart_port *port, struct ktermios *termios,
 	struct uart_pxa_port *up = (struct uart_pxa_port *)port;
 	unsigned char cval, fcr = 0;
 	unsigned long flags;
-	unsigned int baud, quot;
+	unsigned int baud, quot = 0;
 	unsigned int dll;
 
 	switch (termios->c_cflag & CSIZE) {
@@ -488,21 +1013,41 @@ serial_pxa_set_termios(struct uart_port *port, struct ktermios *termios,
 	/*
 	 * Ask the core to calculate the divisor for us.
 	 */
-	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
-	quot = uart_get_divisor(port, baud);
+	baud = uart_get_baud_rate(port, termios, old, 0, 921600*16*4/16);
+	if (baud > 921600) {
+		port->uartclk = 921600*16*4; /* 58.9823MHz as the clk src */
+		if (B1500000 == (termios->c_cflag & B1500000))
+			quot = 2;
+		if (B3500000 == (termios->c_cflag & B3500000))
+			quot = 1;
+		if (quot == 0)
+			quot = uart_get_divisor(port, baud);
+	} else {
+		quot = uart_get_divisor(port, baud);
+	}
 
-	if ((up->port.uartclk / quot) < (2400 * 16))
-		fcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR1;
-	else if ((up->port.uartclk / quot) < (230400 * 16))
-		fcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR8;
-	else
-		fcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR32;
+	if (up->dma_enable) {
+		fcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR32 |
+					     UART_FCR_PXA_TRAIL;
+		fcr &= ~UART_FCR_PXA_BUS32;
+	} else {
+		if ((up->port.uartclk / quot) < (2400 * 16))
+			fcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR1;
+		else if ((up->port.uartclk / quot) < (230400 * 16))
+			fcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR8;
+		else
+			fcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR32;
+	}
 
 	/*
 	 * Ok, we're now changing the port state.  Do it with
 	 * interrupts disabled.
 	 */
 	spin_lock_irqsave(&up->port.lock, flags);
+	if (baud > 921600)
+		up->ier |= UART_IER_HSE;
+	else
+		up->ier &= ~UART_IER_HSE;
 
 	/*
 	 * Ensure the port will be enabled.
@@ -546,9 +1091,15 @@ serial_pxa_set_termios(struct uart_port *port, struct ktermios *termios,
 	/*
 	 * CTS flow control flag and modem status interrupts
 	 */
-	up->ier &= ~UART_IER_MSI;
-	if (UART_ENABLE_MS(&up->port, termios->c_cflag))
-		up->ier |= UART_IER_MSI;
+	if (!up->dma_enable) {
+		/* Don't enable modem status interrupt if DMA is enabled.
+		 * Inherited from the old code.
+		 * Please also refer to serial_pxa_enable_ms().
+		 */
+		up->ier &= ~UART_IER_MSI;
+		if (UART_ENABLE_MS(&up->port, termios->c_cflag))
+			up->ier |= UART_IER_MSI;
+	}
 
 	serial_out(up, UART_IER, up->ier);
 
@@ -670,8 +1221,18 @@ serial_pxa_console_write(struct console *co, const char *s, unsigned int count)
 {
 	struct uart_pxa_port *up = serial_pxa_ports[co->index];
 	unsigned int ier;
+	unsigned long flags;
+	int locked = 1;
 
-	clk_prepare_enable(up->clk);
+	local_irq_save(flags);
+	if (up->port.sysrq)
+		locked = 0;
+	else if (oops_in_progress)
+		locked = spin_trylock(&up->port.lock);
+	else
+		spin_lock(&up->port.lock);
+
+	clk_enable(up->clk);
 
 	/*
 	 *	First save the IER then disable the interrupts
@@ -688,7 +1249,11 @@ serial_pxa_console_write(struct console *co, const char *s, unsigned int count)
 	wait_for_xmitr(up);
 	serial_out(up, UART_IER, ier);
 
-	clk_disable_unprepare(up->clk);
+	clk_disable(up->clk);
+
+	if (locked)
+		spin_unlock(&up->port.lock);
+	local_irq_restore(flags);
 }
 
 static int __init
@@ -761,9 +1326,38 @@ static struct uart_driver serial_pxa_reg = {
 static int serial_pxa_suspend(struct device *dev)
 {
         struct uart_pxa_port *sport = dev_get_drvdata(dev);
+	if (sport && (sport->ier & UART_IER_DMAE)) {
+		int length = 0, sent = 0;
+		unsigned long flags;
 
-        if (sport)
-                uart_suspend_port(&serial_pxa_reg, &sport->port);
+		local_irq_save(flags);
+		/*
+		 * tx stop and suspend and when resume,
+		 * tx startup would be called and set it to 0
+		*/
+		sport->tx_stop = 1;
+		sport->rx_stop = 1;
+		sport->data_len = 0;
+		if (DCSR(sport->txdma) & DCSR_RUN) {
+			stop_dma(sport, 0);
+			length = DCMD(sport->txdma) & 0x1FFF;
+			sent = DSADR(sport->txdma) -
+				sport->txdma_addr_phys;
+			memcpy(sport->buf_save, sport->txdma_addr
+				 + sent, length);
+			sport->data_len = length;
+
+		}
+
+		if (DCSR(sport->rxdma) & DCSR_RUN)
+			stop_dma(sport, 1);
+		pxa_uart_receive_dma(sport->rxdma, sport);
+
+		local_irq_restore(flags);
+	}
+
+	if (sport)
+		uart_suspend_port(&serial_pxa_reg, &sport->port);
 
         return 0;
 }
@@ -775,6 +1369,18 @@ static int serial_pxa_resume(struct device *dev)
         if (sport)
                 uart_resume_port(&serial_pxa_reg, &sport->port);
 
+	if (sport && (sport->ier & UART_IER_DMAE)) {
+		if (sport->data_len > 0) {
+			memcpy(sport->txdma_addr, sport->buf_save,
+					sport->data_len);
+			pxa_uart_transmit_dma_start(sport,
+					sport->data_len);
+		} else
+			tasklet_schedule(&sport->tklet);
+
+		pxa_uart_receive_dma_start(sport);
+	}
+
         return 0;
 }
 
@@ -784,6 +1390,25 @@ static const struct dev_pm_ops serial_pxa_pm_ops = {
 };
 #endif
 
+static void pxa_timer_handler(unsigned long data)
+{
+	struct uart_pxa_port *up = (struct uart_pxa_port *)data;
+	pm_qos_update_request(&up->qos_idle[PXA_UART_RX],
+			PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+}
+
+static void uart_tx_lpm_handler(struct work_struct *work)
+{
+	struct uart_pxa_port *up =
+		container_of(work, struct uart_pxa_port, uart_tx_lpm_work);
+
+	/* Polling until TX FIFO is empty */
+	while(!(serial_in(up, UART_LSR) & UART_LSR_TEMT))
+		msleep(1);
+	pm_qos_update_request(&up->qos_idle[PXA_UART_TX],
+			PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+}
+
 static struct of_device_id serial_pxa_dt_ids[] = {
 	{ .compatible = "mrvl,pxa-uart", },
 	{ .compatible = "mrvl,mmp-uart", },
@@ -812,7 +1437,7 @@ static int serial_pxa_probe_dt(struct platform_device *pdev,
 static int serial_pxa_probe(struct platform_device *dev)
 {
 	struct uart_pxa_port *sport;
-	struct resource *mmres, *irqres;
+	struct resource *mmres, *irqres, *dmares;
 	int ret;
 
 	mmres = platform_get_resource(dev, IORESOURCE_MEM, 0);
@@ -829,6 +1454,11 @@ static int serial_pxa_probe(struct platform_device *dev)
 		ret = PTR_ERR(sport->clk);
 		goto err_free;
 	}
+	ret = clk_prepare(sport->clk);
+	if (ret) {
+		clk_put(sport->clk);
+		goto err_free;
+	}
 
 	sport->port.type = PORT_PXA;
 	sport->port.iotype = UPIO_MEM;
@@ -847,12 +1477,60 @@ static int serial_pxa_probe(struct platform_device *dev)
 		goto err_clk;
 	snprintf(sport->name, PXA_NAME_LEN - 1, "UART%d", sport->port.line + 1);
 
+	sport->rxdrcmr = NULL;
+	sport->txdrcmr = NULL;
+	sport->txdma = 0;
+	sport->rxdma = 0;
+	sport->txdma_addr = NULL;
+	sport->rxdma_addr = NULL;
+	sport->dma_enable = 0;
+
+	if (uart_dma) {
+		/* Get Rx DMA mapping register */
+		dmares = platform_get_resource(dev, IORESOURCE_DMA, 0);
+		if (dmares)
+			sport->rxdrcmr = &DRCMR(dmares->start);
+
+		/* Get Tx DMA mapping register */
+		dmares = platform_get_resource(dev, IORESOURCE_DMA, 1);
+		if (dmares)
+			sport->txdrcmr = &DRCMR(dmares->start);
+
+		if (sport->rxdrcmr && sport->txdrcmr)
+			sport->dma_enable = 1;
+	}
+
+	sport->qos_idle[PXA_UART_TX].name = kasprintf(GFP_KERNEL,
+					    "%s%s", "tx", sport->name);
+	if (!sport->qos_idle[PXA_UART_TX].name) {
+		ret = -ENOMEM;
+		goto err_clk;
+	}
+
+	sport->qos_idle[PXA_UART_RX].name = kasprintf(GFP_KERNEL,
+					    "%s%s", "rx", sport->name);
+	if (!sport->qos_idle[PXA_UART_RX].name) {
+		ret = -ENOMEM;
+		kfree(sport->qos_idle[PXA_UART_TX].name);
+		goto err_clk;
+	}
+
+	pm_qos_add_request(&sport->qos_idle[PXA_UART_TX], PM_QOS_CPUIDLE_BLOCK,
+			   PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+	pm_qos_add_request(&sport->qos_idle[PXA_UART_RX], PM_QOS_CPUIDLE_BLOCK,
+			   PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+
 	sport->port.membase = ioremap(mmres->start, resource_size(mmres));
 	if (!sport->port.membase) {
 		ret = -ENOMEM;
-		goto err_clk;
+		goto err_map;
 	}
 
+	INIT_WORK(&sport->uart_tx_lpm_work, uart_tx_lpm_handler);
+
+	init_timer(&sport->pxa_timer);
+	sport->pxa_timer.function = pxa_timer_handler;
+	sport->pxa_timer.data = (long)sport;
 	serial_pxa_ports[sport->port.line] = sport;
 
 	uart_add_one_port(&serial_pxa_reg, &sport->port);
@@ -860,7 +1538,13 @@ static int serial_pxa_probe(struct platform_device *dev)
 
 	return 0;
 
+ err_map:
+	kfree(sport->qos_idle[PXA_UART_TX].name);
+	kfree(sport->qos_idle[PXA_UART_RX].name);
+	pm_qos_remove_request(&sport->qos_idle[PXA_UART_RX]);
+	pm_qos_remove_request(&sport->qos_idle[PXA_UART_TX]);
  err_clk:
+	clk_unprepare(sport->clk);
 	clk_put(sport->clk);
  err_free:
 	kfree(sport);
@@ -871,11 +1555,19 @@ static int serial_pxa_remove(struct platform_device *dev)
 {
 	struct uart_pxa_port *sport = platform_get_drvdata(dev);
 
+	kfree(sport->qos_idle[PXA_UART_TX].name);
+	kfree(sport->qos_idle[PXA_UART_RX].name);
+	pm_qos_remove_request(&sport->qos_idle[PXA_UART_RX]);
+	pm_qos_remove_request(&sport->qos_idle[PXA_UART_TX]);
+
 	platform_set_drvdata(dev, NULL);
 
 	uart_remove_one_port(&serial_pxa_reg, &sport->port);
+
+	clk_unprepare(sport->clk);
 	clk_put(sport->clk);
 	kfree(sport);
+	serial_pxa_ports[dev->id] = NULL;
 
 	return 0;
 }
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 246b823c..6926fec5 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -94,6 +94,9 @@ static void __uart_start(struct tty_struct *tty)
 	struct uart_state *state = tty->driver_data;
 	struct uart_port *port = state->uart_port;
 
+	if (port->ops->wake_peer)
+		port->ops->wake_peer(port);
+
 	if (!uart_circ_empty(&state->xmit) && state->xmit.buf &&
 	    !tty->stopped && !tty->hw_stopped)
 		port->ops->start_tx(port);
@@ -160,7 +163,6 @@ static int uart_port_startup(struct tty_struct *tty, struct uart_state *state,
 	if (retval == 0) {
 		if (uart_console(uport) && uport->cons->cflag) {
 			tty->termios->c_cflag = uport->cons->cflag;
-			uport->cons->cflag = 0;
 		}
 		/*
 		 * Initialise the hardware port settings.
@@ -1952,16 +1954,17 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
 	 */
 	if (uart_console(uport)) {
 		/*
-		 * First try to use the console cflag setting.
-		 */
-		memset(&termios, 0, sizeof(struct ktermios));
-		termios.c_cflag = uport->cons->cflag;
-
-		/*
-		 * If that's unset, use the tty termios setting.
+		 * First try to use the tty termios setting.
 		 */
-		if (port->tty && port->tty->termios && termios.c_cflag == 0)
+		if (port->tty && port->tty->termios)
 			termios = *(port->tty->termios);
+		else {
+			/*
+			 * If unavailable, use the console cflag setting.
+			 */
+			memset(&termios, 0, sizeof(struct ktermios));
+			termios.c_cflag = uport->cons->cflag;
+		}
 
 		if (console_suspend_enabled)
 			uart_change_pm(state, 0);
diff --git a/drivers/tty/vt/vt_ioctl.c b/drivers/tty/vt/vt_ioctl.c
index ede2ef18..1d02e328 100644
--- a/drivers/tty/vt/vt_ioctl.c
+++ b/drivers/tty/vt/vt_ioctl.c
@@ -110,16 +110,7 @@ void vt_event_post(unsigned int event, unsigned int old, unsigned int new)
 		wake_up_interruptible(&vt_event_waitqueue);
 }
 
-/**
- *	vt_event_wait		-	wait for an event
- *	@vw: our event
- *
- *	Waits for an event to occur which completes our vt_event_wait
- *	structure. On return the structure has wv->done set to 1 for success
- *	or 0 if some event such as a signal ended the wait.
- */
-
-static void vt_event_wait(struct vt_event_wait *vw)
+static void __vt_event_queue(struct vt_event_wait *vw)
 {
 	unsigned long flags;
 	/* Prepare the event */
@@ -129,14 +120,40 @@ static void vt_event_wait(struct vt_event_wait *vw)
 	spin_lock_irqsave(&vt_event_lock, flags);
 	list_add(&vw->list, &vt_events);
 	spin_unlock_irqrestore(&vt_event_lock, flags);
+}
+
+static void __vt_event_wait(struct vt_event_wait *vw)
+{
 	/* Wait for it to pass */
 	wait_event_interruptible(vt_event_waitqueue, vw->done);
+}
+
+static void __vt_event_dequeue(struct vt_event_wait *vw)
+{
+	unsigned long flags;
+
 	/* Dequeue it */
 	spin_lock_irqsave(&vt_event_lock, flags);
 	list_del(&vw->list);
 	spin_unlock_irqrestore(&vt_event_lock, flags);
 }
 
+/**
+ *	vt_event_wait		-	wait for an event
+ *	@vw: our event
+ *
+ *	Waits for an event to occur which completes our vt_event_wait
+ *	structure. On return the structure has wv->done set to 1 for success
+ *	or 0 if some event such as a signal ended the wait.
+ */
+
+static void vt_event_wait(struct vt_event_wait *vw)
+{
+	__vt_event_queue(vw);
+	__vt_event_wait(vw);
+	__vt_event_dequeue(vw);
+}
+
 /**
  *	vt_event_wait_ioctl	-	event ioctl handler
  *	@arg: argument to ioctl
@@ -177,10 +194,14 @@ int vt_waitactive(int n)
 {
 	struct vt_event_wait vw;
 	do {
-		if (n == fg_console + 1)
-			break;
 		vw.event.event = VT_EVENT_SWITCH;
-		vt_event_wait(&vw);
+		__vt_event_queue(&vw);
+		if (n == fg_console + 1) {
+			__vt_event_dequeue(&vw);
+			break;
+		}
+		__vt_event_wait(&vw);
+		__vt_event_dequeue(&vw);
 		if (vw.done == 0)
 			return -EINTR;
 	} while (vw.event.newev != n);
diff --git a/drivers/uio/Kconfig b/drivers/uio/Kconfig
index 6f3ea9bb..23982117 100644
--- a/drivers/uio/Kconfig
+++ b/drivers/uio/Kconfig
@@ -111,4 +111,39 @@ config UIO_PRUSS
 	  To compile this driver as a module, choose M here: the module
 	  will be called uio_pruss.
 
+config UIO_HDMI
+	tristate "Userspace HDMI driver"
+	depends on UIO && CPU_MMP3
+	default y
+	help
+	  Userspace IO interface to the Marvell hdmi controller.
+
+config UIO_CODA7542
+	tristate "CODA7542 UIO device driver"
+	depends on UIO
+	default n
+	help
+	  Userspace IO interface to the Chip&Media multi-format video
+	  decoder engine.
+
+	  If you compile this as a module, it will be called uio_coda7542.
+
+config UIO_HANTRO
+	tristate "Hantro UIO device driver"
+	depends on UIO && CPU_EDEN
+	default n
+	help
+	  Userspace IO interface to the Hantro multi-format video
+	  decoder engine.
+
+	  If you compile this as a module, it will be called uio_hantro.
+
+config UIO_MVISP
+	tristate "MVISP UIO device driver"
+	depends on UIO
+	default n
+	help
+	  Userspace IO interface to mmap the Marvell ISP IPC mem
+
+	  If you compile this as a module, it will be called uio_mvisp.
 endif
diff --git a/drivers/uio/Makefile b/drivers/uio/Makefile
index d4dd9a55..ad2d22b9 100644
--- a/drivers/uio/Makefile
+++ b/drivers/uio/Makefile
@@ -7,3 +7,7 @@ obj-$(CONFIG_UIO_SERCOS3)	+= uio_sercos3.o
 obj-$(CONFIG_UIO_PCI_GENERIC)	+= uio_pci_generic.o
 obj-$(CONFIG_UIO_NETX)	+= uio_netx.o
 obj-$(CONFIG_UIO_PRUSS)         += uio_pruss.o
+obj-$(CONFIG_UIO_HDMI) += uio_hdmi.o
+obj-$(CONFIG_UIO_CODA7542)	+= uio_coda7542.o
+obj-$(CONFIG_UIO_HANTRO)	+= uio_hantro.o
+obj-$(CONFIG_UIO_MVISP) += uio_mvisp.o
diff --git a/drivers/uio/uio.c b/drivers/uio/uio.c
index a783d533..a85cb283 100644
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@ -430,11 +430,6 @@ static irqreturn_t uio_interrupt(int irq, void *dev_id)
 	return ret;
 }
 
-struct uio_listener {
-	struct uio_device *dev;
-	s32 event_count;
-};
-
 static int uio_open(struct inode *inode, struct file *filep)
 {
 	struct uio_device *idev;
@@ -465,7 +460,7 @@ static int uio_open(struct inode *inode, struct file *filep)
 	filep->private_data = listener;
 
 	if (idev->info->open) {
-		ret = idev->info->open(idev->info, inode);
+		ret = idev->info->open(idev->info, inode, filep->private_data);
 		if (ret)
 			goto err_infoopen;
 	}
@@ -496,7 +491,8 @@ static int uio_release(struct inode *inode, struct file *filep)
 	struct uio_device *idev = listener->dev;
 
 	if (idev->info->release)
-		ret = idev->info->release(idev->info, inode);
+		ret = idev->info->release(idev->info, inode,
+					filep->private_data);
 
 	module_put(idev->owner);
 	kfree(listener);
@@ -507,13 +503,18 @@ static unsigned int uio_poll(struct file *filep, poll_table *wait)
 {
 	struct uio_listener *listener = filep->private_data;
 	struct uio_device *idev = listener->dev;
+	s32 event_count;
 
 	if (!idev->info->irq)
 		return -EIO;
 
 	poll_wait(filep, &idev->wait, wait);
-	if (listener->event_count != atomic_read(&idev->event))
+
+	event_count = atomic_read(&idev->event);
+	if (listener->event_count != event_count) {
+		listener->event_count = event_count;
 		return POLLIN | POLLRDNORM;
+	}
 	return 0;
 }
 
@@ -711,6 +712,31 @@ static int uio_mmap(struct file *filep, struct vm_area_struct *vma)
 	}
 }
 
+static long uio_unlocked_ioctl(struct file *filep,
+				unsigned int cmd, unsigned long arg)
+{
+	struct uio_listener *listener = filep->private_data;
+	struct uio_device *idev = listener->dev;
+	int ret = 0;
+
+	if (!idev)
+		return -ENODEV;
+
+	if (idev->info) {
+		if (idev->info->ioctl) {
+			if (!try_module_get(idev->owner))
+				return -ENODEV;
+			ret = idev->info->ioctl(idev->info, cmd,
+					arg, filep->private_data);
+			module_put(idev->owner);
+
+			return ret;
+		}
+	}
+
+	return -EINVAL;
+}
+
 static const struct file_operations uio_fops = {
 	.owner		= THIS_MODULE,
 	.open		= uio_open,
@@ -718,6 +744,7 @@ static const struct file_operations uio_fops = {
 	.read		= uio_read,
 	.write		= uio_write,
 	.mmap		= uio_mmap,
+	.unlocked_ioctl	= uio_unlocked_ioctl,
 	.poll		= uio_poll,
 	.fasync		= uio_fasync,
 	.llseek		= noop_llseek,
diff --git a/drivers/uio/uio_coda7542.c b/drivers/uio/uio_coda7542.c
new file mode 100644
index 00000000..cab325ff
--- /dev/null
+++ b/drivers/uio/uio_coda7542.c
@@ -0,0 +1,596 @@
+/*
+ * drivers/uio/uio_coda7542.c
+ *
+ * chip&media coda7542 UIO driver
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/uaccess.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/slab.h>
+#include <linux/uio_driver.h>
+#include <linux/uio_coda7542.h>
+
+#include <mach/hardware.h>
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#include <plat/pm.h>
+#endif
+
+#define VDEC_WORKING_BUFFER_SIZE	SZ_1M
+#define UIO_CODA7542_VERSION		"build-001"
+
+/* HW capability is 16, only use 10 instance to reduce memory requirements. */
+#define MAX_NUM_VPUSLOT	10
+#define MAX_NUM_FILEHANDLE 10
+
+#define BIT_INT_CLEAR		(0xC)
+#define BIT_BUSY_FLAG		(0x160)
+
+struct uio_coda7542_dev {
+	struct uio_info uio_info;
+	void *reg_base;
+	struct clk *clk;
+	struct mutex mutex;	/* used to protect open/release */
+	int power_status;       /* 0-off 1-on */
+	int clk_status;
+	int filehandle_ins_num;
+	int firmware_download;
+	struct semaphore sema;
+	unsigned int coda_features;
+};
+
+/*
+ * use following data structure to assicate fd and codec instance,
+ * one fd corresponding to one codec instance
+*/
+struct coda7542_instance {
+	int occupied;
+	int gotsemaphore;
+	int vpuslotidx; /* the item idex in fd_codecinst_arr[]*/
+	int slotusing;
+	unsigned int codectypeid;
+};
+static struct coda7542_instance fd_codecinst_arr[MAX_NUM_VPUSLOT];
+
+struct vpu_info {
+	unsigned int off;
+	void *value;
+};
+
+static int coda7542_power_on(struct uio_coda7542_dev *cdev)
+{
+	if (cdev->power_status == 1)
+		return 0;
+
+	coda7542_power_switch(1);
+	cdev->power_status = 1;
+
+	return 0;
+}
+
+static int coda7542_clk_on(struct uio_coda7542_dev *cdev)
+{
+	if (cdev->clk_status != 0)
+		return 0;
+
+	clk_enable(cdev->clk);
+	cdev->clk_status = 1;
+
+	return 0;
+}
+
+static int coda7542_power_off(struct uio_coda7542_dev *cdev)
+{
+	if (cdev->power_status == 0)
+		return 0;
+
+	coda7542_power_switch(0);
+	cdev->power_status = 0;
+	return 0;
+}
+
+static int coda7542_clk_off(struct uio_coda7542_dev *cdev)
+{
+	if (cdev->clk_status == 0)
+		return 0;
+
+	clk_disable(cdev->clk);
+	cdev->clk_status = 0;
+
+	return 0;
+}
+
+static int active_coda7542(struct uio_coda7542_dev *cdev, int on)
+{
+	int i, ret;
+
+	if (on) {
+		ret = coda7542_power_on(cdev);
+		if (ret)
+			return -1;
+
+		ret = coda7542_clk_on(cdev);
+		if (ret)
+			return -1;
+
+		sema_init(&cdev->sema, 1);
+	} else {
+		ret = coda7542_clk_off(cdev);
+		if (ret)
+			return -1;
+
+		ret = coda7542_power_off(cdev);
+		if (ret)
+			return -1;
+	}
+
+	cdev->firmware_download = 0;
+
+	/*clear fd_codecinst_arr */
+	for (i = 0; i < MAX_NUM_VPUSLOT; i++) {
+		fd_codecinst_arr[i].occupied = 0;
+		fd_codecinst_arr[i].slotusing = 0;
+		fd_codecinst_arr[i].codectypeid = 0;
+	}
+
+	return 0;
+}
+
+
+static int coda7542_abnormal_stop(struct uio_coda7542_dev *cdev)
+{
+	int i;
+	printk(KERN_INFO "process was killed abnormal\n");
+	/*
+	 *currently, we couldn't do other thing except waiting
+	 *for CNM VPU stop by itself
+	 */
+	for (i = 0; i < 6; i++) {
+		schedule_timeout(msecs_to_jiffies(5));
+		if (0 == __raw_readl(cdev->reg_base + BIT_BUSY_FLAG))
+			return 0;
+	}
+	return -1;
+}
+
+static int coda7542_open(struct uio_info *info, struct inode *inode,
+			void *file_priv)
+{
+	struct uio_coda7542_dev *cdev;
+	struct uio_listener *listener = file_priv;
+	int ret = 0, i;
+
+	pr_debug("Enter coda7542_open()\n");
+	cdev = (struct uio_coda7542_dev *)info->priv;
+	mutex_lock(&cdev->mutex);
+	if (cdev->filehandle_ins_num < MAX_NUM_FILEHANDLE)
+		cdev->filehandle_ins_num++;
+	else {
+		printk(KERN_ERR "current coda7542 cannot accept " \
+				"more file handle instance!!\n");
+		ret = -EACCES;
+		goto out;
+	}
+
+	if (cdev->filehandle_ins_num == 1) {
+		if (0 != active_coda7542(cdev, 1)) {
+			cdev->filehandle_ins_num = 0;
+			ret = -EACCES;
+			goto out;
+		}
+	}
+
+	for (i = 0; i < MAX_NUM_VPUSLOT; i++) {
+		if (fd_codecinst_arr[i].occupied == 0) {
+			listener->extend = &fd_codecinst_arr[i];
+			fd_codecinst_arr[i].occupied = 1;
+			fd_codecinst_arr[i].gotsemaphore = 0;
+			break;
+		}
+	}
+	if (i == MAX_NUM_VPUSLOT) {
+		cdev->filehandle_ins_num--;
+		printk(KERN_ERR "couldn't found any idle seat for new fd!!\n");
+		ret = -EACCES;
+	}
+
+out:
+	mutex_unlock(&cdev->mutex);
+	pr_debug("Leave coda7542_open(), ret = %d\n", ret);
+	return ret;
+}
+
+static int coda7542_release(struct uio_info *info, struct inode *inode,
+			void *file_priv)
+{
+	struct uio_coda7542_dev *cdev;
+	struct uio_listener *listener = file_priv;
+	struct coda7542_instance *pinst;
+	int ret = 0;
+
+	pr_debug("Enter coda7542_release()\n");
+	cdev = (struct uio_coda7542_dev *)info->priv;
+	pinst = (struct coda7542_instance *)listener->extend;
+	mutex_lock(&cdev->mutex);
+
+	/*
+	 * if this codec instance got semaphore, it means this codec instance
+	 * want VPU to do something, and other codec instance will wait.
+	 * If process is killed before VPU finished working for this codec
+	 * instance and instance release semaphore, we need do something.
+	 */
+	if (pinst->gotsemaphore) {
+		if (cdev->clk_status == 1) {
+			if (__raw_readl(cdev->reg_base + BIT_BUSY_FLAG) != 0)
+				coda7542_abnormal_stop(cdev);
+		}
+		up(&cdev->sema);
+		pinst->gotsemaphore = 0;
+	}
+
+	if (pinst->slotusing)
+		pinst->slotusing = 0;
+	pinst->occupied = 0;
+	pinst->codectypeid = 0;
+	listener->extend = NULL;
+
+	if (cdev->filehandle_ins_num > 0) {
+		cdev->filehandle_ins_num--;
+		if (cdev->filehandle_ins_num == 0) {
+			if (0 != active_coda7542(cdev, 0))
+				ret = -EFAULT;
+		}
+	}
+	mutex_unlock(&cdev->mutex);
+	pr_debug("Leave coda7542_release(), ret = %d\n", ret);
+	return ret;
+}
+
+static irqreturn_t coda7542_irq_handler(int irq, struct uio_info *dev_info)
+{
+	struct uio_coda7542_dev *cdev = dev_info->priv;
+	/* clear the interrupt */
+	__raw_writel(0x1, cdev->reg_base + BIT_INT_CLEAR);
+
+	return IRQ_HANDLED;
+}
+
+static int coda7542_ioctl(struct uio_info *info, unsigned int cmd,
+			unsigned long arg, void *file_priv)
+{
+	unsigned int value;
+	int ret, idx;
+	struct vpu_info vpu_info;
+	void __user *argp = (void __user *)arg;
+	struct uio_coda7542_dev *cdev = info->priv;
+	struct coda7542_instance *pinst;
+	struct uio_listener *listener = file_priv;
+	pinst = (struct coda7542_instance *)listener->extend;
+
+	switch (cmd) {
+	case CODA7542_POWER_ON:
+		mutex_lock(&cdev->mutex);
+		ret = coda7542_power_on(cdev);
+		if (0 != ret) {
+			mutex_unlock(&cdev->mutex);
+			return -EFAULT;
+		}
+		mutex_unlock(&cdev->mutex);
+		break;
+	case CODA7542_POWER_OFF:
+		mutex_lock(&cdev->mutex);
+		ret = coda7542_power_off(cdev);
+		if (0 != ret) {
+			mutex_unlock(&cdev->mutex);
+			return -EFAULT;
+		}
+		mutex_unlock(&cdev->mutex);
+		break;
+	case CODA7542_CLK_ON:
+		mutex_lock(&cdev->mutex);
+		ret = coda7542_clk_on(cdev);
+		if (0 != ret) {
+			mutex_unlock(&cdev->mutex);
+			return -EFAULT;
+		}
+		mutex_unlock(&cdev->mutex);
+		break;
+	case CODA7542_CLK_OFF:
+		mutex_lock(&cdev->mutex);
+		ret = coda7542_clk_off(cdev);
+		if (0 != ret) {
+			mutex_unlock(&cdev->mutex);
+			return -EFAULT;
+		}
+		mutex_unlock(&cdev->mutex);
+		break;
+	case CODA7542_LOCK:
+		if (copy_from_user(&vpu_info, argp, sizeof(struct vpu_info)))
+			return -EFAULT;
+		if (pinst->gotsemaphore == 0) {
+			value = down_timeout(&cdev->sema,
+					msecs_to_jiffies(vpu_info.off));
+			if (value == 0)
+				pinst->gotsemaphore = 1;
+		} else
+			value = 0;
+		if (copy_to_user(vpu_info.value, &value, sizeof(unsigned int)))
+			return -EFAULT;
+		break;
+	case CODA7542_UNLOCK:
+		if (pinst->gotsemaphore) {
+			up(&cdev->sema);
+			pinst->gotsemaphore = 0;
+		}
+		break;
+	case CODA7542_GETSET_INFO:
+		if (copy_from_user(&vpu_info, argp, sizeof(struct vpu_info)))
+			return -EFAULT;
+		switch (vpu_info.off) {
+		case 0:
+			/* 0 get firmware_download */
+			if (copy_to_user(vpu_info.value,
+				&cdev->firmware_download, sizeof(int)))
+				return -EFAULT;
+			break;
+		case 1:
+			/* 1 set firmware_download */
+			cdev->firmware_download = 1;
+			break;
+		case 2:
+			/* 2 get vpu slot */
+			if (pinst->slotusing == 0 && pinst->vpuslotidx
+					< MAX_NUM_VPUSLOT)
+				idx = pinst->vpuslotidx;
+			else
+				idx = -1;
+			if (copy_to_user(vpu_info.value, &idx, sizeof(idx)))
+				return -EFAULT;
+			pinst->slotusing = 1;
+			break;
+		case 3:
+			/* 3 release vpu slot */
+			if (pinst->vpuslotidx < MAX_NUM_VPUSLOT)
+				pinst->slotusing = 0;
+			break;
+		case 4:
+			if (copy_to_user(vpu_info.value, &cdev->coda_features,
+				sizeof(cdev->coda_features)))
+				return -EFAULT;
+			break;
+		case 6:
+			pinst->codectypeid = (unsigned int)(vpu_info.value);
+			break;
+		default:
+			return -EFAULT;
+		}
+		break;
+	default:
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int coda7542_probe(struct platform_device *pdev)
+{
+	struct resource *res, *sram_res;
+	struct uio_coda7542_dev *cdev;
+	int i, irq_func, ret = 0;
+	dma_addr_t mem_dma_addr;
+	void *mem_vir_addr;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resources given\n");
+		return -ENODEV;
+	}
+
+	sram_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!sram_res)
+		dev_info(&pdev->dev, "no sram resources given\n");
+
+	irq_func = platform_get_irq(pdev, 0);
+	if (irq_func < 0) {
+		dev_err(&pdev->dev, "missing irq resource in interrupt mode\n");
+		return -ENODEV;
+	}
+
+	cdev = devm_kzalloc(&pdev->dev, sizeof(*cdev), GFP_KERNEL);
+	if (!cdev) {
+		dev_err(&pdev->dev, "uio_coda7542_dev: out of memory\n");
+		return -ENOMEM;
+	}
+
+	cdev->clk = clk_get(&pdev->dev, "VPUCLK");
+	if (IS_ERR(cdev->clk)) {
+		dev_err(&pdev->dev, "cannot get coda7542 clock\n");
+		ret = PTR_ERR(cdev->clk);
+		goto err_clk;
+	}
+
+	cdev->reg_base = (void *)ioremap(res->start, res->end - res->start + 1);
+	if (!cdev->reg_base) {
+		dev_err(&pdev->dev, "can't remap register area\n");
+		ret = -ENOMEM;
+		goto err_reg_base;
+	}
+
+	platform_set_drvdata(pdev, cdev);
+
+	cdev->uio_info.name = UIO_CODA7542_NAME;
+	cdev->uio_info.version = UIO_CODA7542_VERSION;
+	cdev->uio_info.mem[0].internal_addr = (void __iomem *)cdev->reg_base;
+	cdev->uio_info.mem[0].addr = res->start;
+	cdev->uio_info.mem[0].memtype = UIO_MEM_PHYS;
+	cdev->uio_info.mem[0].size = res->end - res->start + 1;
+
+	/*
+	 * this 2MB buffer contains firmware buffer, working buffer
+	 * and parameter buffer, which shares in multi-process.
+	 */
+	mem_vir_addr = (void *)__get_free_pages(GFP_DMA | GFP_KERNEL,
+					get_order(VDEC_WORKING_BUFFER_SIZE));
+	if (!mem_vir_addr) {
+		ret = -ENOMEM;
+		goto err_uio_mem;
+	}
+	mem_dma_addr = (dma_addr_t)__virt_to_phys((unsigned int)mem_vir_addr);
+
+	cdev->uio_info.mem[1].internal_addr = (void __iomem *)mem_vir_addr;
+	cdev->uio_info.mem[1].addr = mem_dma_addr;
+	cdev->uio_info.mem[1].memtype = UIO_MEM_PHYS;
+	cdev->uio_info.mem[1].size = VDEC_WORKING_BUFFER_SIZE;
+	dev_info(&pdev->dev, "[1] internal addr[0x%08x]," \
+			"addr[0x%08x] size[%ld]\n",
+			(unsigned int)cdev->uio_info.mem[1].internal_addr,
+			(unsigned int)cdev->uio_info.mem[1].addr,
+			cdev->uio_info.mem[1].size);
+
+	if (sram_res) {
+		cdev->uio_info.mem[2].addr = sram_res->start;
+		cdev->uio_info.mem[2].memtype = UIO_MEM_PHYS;
+		cdev->uio_info.mem[2].size = sram_res->end -
+					     sram_res->start + 1;
+		dev_info(&pdev->dev, "[2] addr[0x%08x] size[%ld]\n",
+				(unsigned int)cdev->uio_info.mem[2].addr,
+				cdev->uio_info.mem[2].size);
+	}
+
+	cdev->uio_info.irq_flags = IRQF_DISABLED;
+	cdev->uio_info.irq = irq_func;
+	cdev->uio_info.handler = coda7542_irq_handler;
+	cdev->uio_info.priv = cdev;
+
+	cdev->uio_info.open = coda7542_open;
+	cdev->uio_info.release = coda7542_release;
+	cdev->uio_info.ioctl = coda7542_ioctl;
+	cdev->uio_info.mmap = NULL;
+
+	if (pdev->dev.platform_data)
+		cdev->coda_features =
+			*((unsigned int *)(pdev->dev.platform_data));
+
+	mutex_init(&(cdev->mutex));
+	cdev->filehandle_ins_num = 0;
+	for (i = 0; i < MAX_NUM_VPUSLOT; i++)
+		fd_codecinst_arr[i].vpuslotidx = i;
+
+	ret = uio_register_device(&pdev->dev, &cdev->uio_info);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register uio device\n");
+		goto err_uio_register;
+	}
+
+	return 0;
+
+err_uio_register:
+	free_pages((unsigned long)cdev->uio_info.mem[1].internal_addr,
+			get_order(VDEC_WORKING_BUFFER_SIZE));
+err_uio_mem:
+	iounmap(cdev->uio_info.mem[0].internal_addr);
+err_reg_base:
+	clk_put(cdev->clk);
+err_clk:
+	devm_kfree(&pdev->dev, cdev);
+
+	return ret;
+}
+
+static int coda7542_remove(struct platform_device *pdev)
+{
+	struct uio_coda7542_dev *cdev = platform_get_drvdata(pdev);
+
+	uio_unregister_device(&cdev->uio_info);
+	free_pages((unsigned long)cdev->uio_info.mem[1].internal_addr,
+			get_order(VDEC_WORKING_BUFFER_SIZE));
+	iounmap(cdev->uio_info.mem[0].internal_addr);
+
+	clk_put(cdev->clk);
+
+	kfree(cdev);
+
+	return 0;
+}
+
+static bool is_suspend;
+
+static int coda7542_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct uio_coda7542_dev *cdev = platform_get_drvdata(pdev);
+	int i;
+	bool cannot_off = 0;
+
+	if (cdev->filehandle_ins_num <= 0)
+		return 0;
+	if (cdev->clk_status != 0)
+		return 0;
+
+	for (i = 0; i < MAX_NUM_VPUSLOT; i++) {
+		if ((fd_codecinst_arr[i].occupied == 1) &&
+			((fd_codecinst_arr[i].codectypeid & VPU_CODEC_TYPEID_ENC_MASK)
+			 || fd_codecinst_arr[i].codectypeid == 0)) {
+			cannot_off = 1;
+			break;
+		}
+	}
+
+	if (!cannot_off) {
+		printk(KERN_INFO "coda7542 poweroff in suspend\n");
+		coda7542_power_off(cdev);
+		is_suspend = 1;
+	}
+
+	return 0;
+}
+
+static int coda7542_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct uio_coda7542_dev *cdev = platform_get_drvdata(pdev);
+
+	if (is_suspend) {
+		printk(KERN_INFO "coda7542 poweron in resume\n");
+		coda7542_power_on(cdev);
+		is_suspend = 0;
+	}
+	return 0;
+}
+
+static void coda7542_shutdown(struct platform_device *dev)
+{
+}
+
+static const struct dev_pm_ops coda7542_pm_ops = {
+	.suspend = coda7542_suspend,
+	.resume	= coda7542_resume,
+};
+
+static struct platform_driver coda7542_driver = {
+	.probe = coda7542_probe,
+	.remove = coda7542_remove,
+	.shutdown = coda7542_shutdown,
+	.driver = {
+		.name = UIO_CODA7542_NAME,
+		.owner = THIS_MODULE,
+		.pm	= &coda7542_pm_ops,
+	},
+};
+
+module_platform_driver(coda7542_driver);
+
+MODULE_AUTHOR("Yuhua Guo (guoyh@marvell.com)");
+MODULE_DESCRIPTION("UIO driver for Chip and Media Coda7542 codec");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" UIO_CODA7542_NAME);
diff --git a/drivers/uio/uio_mvisp.c b/drivers/uio/uio_mvisp.c
new file mode 100644
index 00000000..2497528d
--- /dev/null
+++ b/drivers/uio/uio_mvisp.c
@@ -0,0 +1,338 @@
+/*
+ * drivers/uio/uio_mvisp.c
+ *
+ * Marvell ISP UIO driver
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/uaccess.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/slab.h>
+#include <linux/uio_driver.h>
+#include <linux/uio_mvisp.h>
+
+#include <mach/hardware.h>
+
+#define VDEC_WORKING_BUFFER_SIZE	SZ_1M
+#define UIO_MVISP_VERSION		"build-0"
+
+#define MAX_NUM_SLOT	10
+#define MAX_NUM_FILEHANDLE 10
+
+#define BIT_INT_CLEAR		(0xC)
+#define BIT_BUSY_FLAG		(0x160)
+
+struct uio_mvisp_dev {
+	struct uio_info uio_info;
+	void *reg_base;
+	struct clk *clk;
+	struct mutex mutex;	/* used to protect open/release */
+	int power_status;       /* 0-off 1-on */
+	int clk_status;
+	int filehandle_ins_num;
+	int firmware_download;
+};
+
+static int mvisp_power_on(struct uio_mvisp_dev *cdev)
+{
+	if (cdev->power_status == 1)
+		return 0;
+
+	cdev->power_status = 1;
+
+	return 0;
+}
+
+static int mvisp_clk_on(struct uio_mvisp_dev *cdev)
+{
+	if (cdev->clk_status != 0)
+		return 0;
+
+	clk_enable(cdev->clk);
+	cdev->clk_status = 1;
+
+	return 0;
+}
+
+static int mvisp_power_off(struct uio_mvisp_dev *cdev)
+{
+	if (cdev->power_status == 0)
+		return 0;
+
+	cdev->power_status = 0;
+	return 0;
+}
+
+static int mvisp_clk_off(struct uio_mvisp_dev *cdev)
+{
+	if (cdev->clk_status == 0)
+		return 0;
+
+	clk_disable(cdev->clk);
+	cdev->clk_status = 0;
+
+	return 0;
+}
+
+static int active_mvisp(struct uio_mvisp_dev *cdev, int on)
+{
+	int ret;
+
+	if (on) {
+		ret = mvisp_power_on(cdev);
+		if (ret)
+			return -1;
+
+		ret = mvisp_clk_on(cdev);
+		if (ret)
+			return -1;
+	} else {
+		ret = mvisp_clk_off(cdev);
+		if (ret)
+			return -1;
+
+		ret = mvisp_power_off(cdev);
+		if (ret)
+			return -1;
+	}
+
+	cdev->firmware_download = 0;
+
+	return 0;
+}
+
+static int mvisp_open(struct uio_info *info, struct inode *inode,
+			void *file_priv)
+{
+	struct uio_mvisp_dev *cdev;
+	int ret = 0;
+
+	pr_debug("Enter uio-mvisp_open()\n");
+	cdev = (struct uio_mvisp_dev *)info->priv;
+	mutex_lock(&cdev->mutex);
+	if (cdev->filehandle_ins_num < MAX_NUM_FILEHANDLE)
+		cdev->filehandle_ins_num++;
+	else {
+		printk(KERN_ERR "current mvisp cannot accept " \
+				"more file handle instance!!\n");
+		ret = -EACCES;
+		goto out;
+	}
+
+	if (cdev->filehandle_ins_num == 1) {
+		if (0 != active_mvisp(cdev, 1)) {
+			cdev->filehandle_ins_num = 0;
+			ret = -EACCES;
+			goto out;
+		}
+	}
+
+out:
+	mutex_unlock(&cdev->mutex);
+	pr_debug("Leave mvisp_open(), ret = %d\n", ret);
+	return ret;
+}
+
+static int mvisp_release(struct uio_info *info, struct inode *inode,
+			void *file_priv)
+{
+	struct uio_mvisp_dev *cdev;
+	int ret = 0;
+
+	pr_debug("Enter mvisp_release()\n");
+	cdev = (struct uio_mvisp_dev *)info->priv;
+	mutex_lock(&cdev->mutex);
+
+	if (cdev->filehandle_ins_num > 0) {
+		cdev->filehandle_ins_num--;
+		if (cdev->filehandle_ins_num == 0) {
+			if (0 != active_mvisp(cdev, 0))
+				ret = -EFAULT;
+		}
+	}
+	mutex_unlock(&cdev->mutex);
+	pr_debug("Leave mvisp_release(), ret = %d\n", ret);
+	return ret;
+}
+static int mvisp_uio_name(struct uio_info *info,
+		struct mvisp_get_uio_name *uio_name)
+{
+	if (!uio_name)
+		return -EINVAL;
+
+	strcpy(uio_name->driver, "uio-mvisp");
+	return 0;
+}
+static int mvisp_ioctl(struct uio_info *info, unsigned int cmd,
+			unsigned long arg, void *file_priv)
+{
+	int ret;
+	struct uio_mvisp_dev *cdev = info->priv;
+
+	switch (cmd) {
+	case MVISP_UIO_NAME:
+		mutex_lock(&cdev->mutex);
+		ret = mvisp_uio_name(info,
+				(struct mvisp_get_uio_name *)arg);
+		mutex_unlock(&cdev->mutex);
+		break;
+	case MVISP_POWER_ON:
+		mutex_lock(&cdev->mutex);
+		ret = mvisp_power_on(cdev);
+		if (0 != ret) {
+			mutex_unlock(&cdev->mutex);
+			return -EFAULT;
+		}
+		mutex_unlock(&cdev->mutex);
+		break;
+	case MVISP_POWER_OFF:
+		mutex_lock(&cdev->mutex);
+		ret = mvisp_power_off(cdev);
+		if (0 != ret) {
+			mutex_unlock(&cdev->mutex);
+			return -EFAULT;
+		}
+		mutex_unlock(&cdev->mutex);
+		break;
+	case MVISP_CLK_ON:
+		mutex_lock(&cdev->mutex);
+		ret = mvisp_clk_on(cdev);
+		if (0 != ret) {
+			mutex_unlock(&cdev->mutex);
+			return -EFAULT;
+		}
+		mutex_unlock(&cdev->mutex);
+		break;
+	case MVISP_CLK_OFF:
+		mutex_lock(&cdev->mutex);
+		ret = mvisp_clk_off(cdev);
+		if (0 != ret) {
+			mutex_unlock(&cdev->mutex);
+			return -EFAULT;
+		}
+		mutex_unlock(&cdev->mutex);
+		break;
+	default:
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int uio_mvisp_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct uio_mvisp_dev *cdev;
+	int ret = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resources given\n");
+		return -ENODEV;
+	}
+
+	cdev = devm_kzalloc(&pdev->dev, sizeof(*cdev), GFP_KERNEL);
+	if (!cdev) {
+		dev_err(&pdev->dev, "uio_mvisp_dev: out of memory\n");
+		return -ENOMEM;
+	}
+
+	cdev->clk = clk_get(&pdev->dev, "ISP-CLK");
+	if (IS_ERR(cdev->clk)) {
+		dev_err(&pdev->dev, "cannot get mvisp clock\n");
+		ret = PTR_ERR(cdev->clk);
+		goto err_clk;
+	}
+
+	cdev->reg_base = (void *)ioremap(res->start, res->end - res->start + 1);
+	if (!cdev->reg_base) {
+		dev_err(&pdev->dev, "can't remap register area\n");
+		ret = -ENOMEM;
+		goto err_reg_base;
+	}
+
+	platform_set_drvdata(pdev, cdev);
+
+	cdev->uio_info.name = UIO_MVISP_NAME;
+	cdev->uio_info.version = UIO_MVISP_VERSION;
+	cdev->uio_info.mem[0].internal_addr = (void __iomem *)cdev->reg_base;
+	cdev->uio_info.mem[0].addr = res->start;
+	cdev->uio_info.mem[0].memtype = UIO_MEM_PHYS;
+	cdev->uio_info.mem[0].size = res->end - res->start + 1;
+
+	cdev->uio_info.priv = cdev;
+
+	cdev->uio_info.open = mvisp_open;
+	cdev->uio_info.release = mvisp_release;
+	cdev->uio_info.ioctl = mvisp_ioctl;
+	cdev->uio_info.mmap = NULL;
+
+	mutex_init(&(cdev->mutex));
+	cdev->filehandle_ins_num = 0;
+
+	ret = uio_register_device(&pdev->dev, &cdev->uio_info);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register uio device\n");
+		goto err_uio_register;
+	}
+
+	return 0;
+
+err_uio_register:
+	free_pages((unsigned long)cdev->uio_info.mem[1].internal_addr,
+			get_order(VDEC_WORKING_BUFFER_SIZE));
+err_reg_base:
+	clk_put(cdev->clk);
+err_clk:
+	devm_kfree(&pdev->dev, cdev);
+
+	return ret;
+}
+
+static int mvisp_remove(struct platform_device *pdev)
+{
+	struct uio_mvisp_dev *cdev = platform_get_drvdata(pdev);
+
+	uio_unregister_device(&cdev->uio_info);
+	free_pages((unsigned long)cdev->uio_info.mem[1].internal_addr,
+			get_order(VDEC_WORKING_BUFFER_SIZE));
+	iounmap(cdev->uio_info.mem[0].internal_addr);
+
+	clk_put(cdev->clk);
+
+	kfree(cdev);
+
+	return 0;
+}
+
+static void mvisp_shutdown(struct platform_device *dev)
+{
+}
+
+static struct platform_driver uio_mvisp_driver = {
+	.probe = uio_mvisp_probe,
+	.remove = mvisp_remove,
+	.shutdown = mvisp_shutdown,
+	.driver = {
+		.name = UIO_MVISP_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+
+module_platform_driver(uio_mvisp_driver);
+
+MODULE_AUTHOR("Owen zhang(xinzha@marvell.com)");
+MODULE_DESCRIPTION("UIO driver for Marvell ISP");
+MODULE_LICENSE("GPL v0");
+MODULE_ALIAS("platform:" UIO_MVISP_NAME);
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index a290be51..350d9fd7 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -23,6 +23,8 @@ source "drivers/gpu/drm/Kconfig"
 
 source "drivers/gpu/stub/Kconfig"
 
+source "drivers/gpu/ion/Kconfig"
+
 config VGASTATE
        tristate
        default n
@@ -1880,14 +1882,41 @@ config FB_68328
 
 config FB_PXA168
 	tristate "PXA168/910 LCD framebuffer support"
-	depends on FB && (CPU_PXA168 || CPU_PXA910)
+	depends on FB && (CPU_PXA168 || CPU_PXA910 ||CPU_MMP3 || CPU_MMP2 || CPU_PXA988 || CPU_PXA1088 || CPU_EDEN)
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
+        select PXA688_PHY if (CPU_MMP3 || CPU_MMP2 || CPU_PXA988 || CPU_PXA1088)
 	---help---
 	  Frame buffer driver for the built-in LCD controller in the Marvell
 	  MMP processor.
 
+config PXA688_PHY
+        bool "MMP2/MMP3 & PXA988 LCD DSI support"
+        depends on FB && (CPU_MMP3 || CPU_MMP2 || CPU_PXA988 || CPU_PXA1088)
+
+config PXA688_VDMA
+	tristate "MMP VDMA support"
+	depends on FB && (CPU_MMP2 || CPU_MMP3)
+	help
+	  Say Y here if you want to enable VDMA for MMP2 and MMP3
+
+config PXA688_MISC
+	tristate "MMP2 MISC features support"
+	depends on FB && (CPU_MMP2 || CPU_MMP3 || CPU_PXA988 || CPU_PXA1088)
+	help
+	  Say Y here if you want to enable vertical smooth, partial display, etc.
+
+config LDI_SUPPORT_MDNIE
+	bool "enable mdnie feature"
+	help
+	  Support the mDNIE feature.
+
+config LCD_ESD_RECOVERY
+	bool "enable esd recovery feature"
+	help
+	  Support esd recovery feature.
+
 config FB_PXA
 	tristate "PXA LCD framebuffer support"
 	depends on FB && ARCH_PXA
@@ -2414,6 +2443,7 @@ config FB_PUV3_UNIGFX
 source "drivers/video/omap/Kconfig"
 source "drivers/video/omap2/Kconfig"
 source "drivers/video/exynos/Kconfig"
+# source "drivers/video/mmp/Kconfig"
 source "drivers/video/backlight/Kconfig"
 
 if VT
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 9356add9..5a979793 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -104,8 +104,13 @@ obj-$(CONFIG_FB_GBE)              += gbefb.o
 obj-$(CONFIG_FB_CIRRUS)		  += cirrusfb.o
 obj-$(CONFIG_FB_ASILIANT)	  += asiliantfb.o
 obj-$(CONFIG_FB_PXA)		  += pxafb.o
-obj-$(CONFIG_FB_PXA168)		  += pxa168fb.o
+obj-$(CONFIG_FB_PXA168)		  += pxa168fb.o pxa168fb_common.o \
+					 pxa168fb_ovly.o
+obj-$(CONFIG_PXA688_PHY)	  += pxa688_phy.o
+obj-$(CONFIG_PXA688_VDMA)	  += pxa688_vdma.o
+obj-$(CONFIG_PXA688_MISC)	  += pxa688_misc.o
 obj-$(CONFIG_PXA3XX_GCU)	  += pxa3xx-gcu.o
+#obj-$(CONFIG_MMP_DISP)           += mmp/
 obj-$(CONFIG_FB_W100)		  += w100fb.o
 obj-$(CONFIG_FB_TMIO)		  += tmiofb.o
 obj-$(CONFIG_FB_AU1100)		  += au1100fb.o
diff --git a/drivers/video/backlight/Kconfig b/drivers/video/backlight/Kconfig
index af168844..8296361b 100644
--- a/drivers/video/backlight/Kconfig
+++ b/drivers/video/backlight/Kconfig
@@ -125,6 +125,15 @@ config LCD_AMS369FG06
 	  If you have an AMS369FG06 AMOLED Panel, say Y to enable its
 	  LCD control driver.
 
+config LCD_TEMPERATURE_COMPENSATION  
+	tristate "Temperature compensation needed LCD Driver"
+	depends on SPI && BACKLIGHT_CLASS_DEVICE
+	default n
+	help
+	  If you have an Panel which needed temperature compensation,
+	  say Y to enable its
+	  LCD control driver.
+
 endif # LCD_CLASS_DEVICE
 
 #
@@ -320,6 +329,30 @@ config BACKLIGHT_ADP8870
 	  To compile this driver as a module, choose M here: the module will
 	  be called adp8870_bl.
 
+config BACKLIGHT_KTD253
+	tristate "Backlight Driver for KTD253 using WLED"
+	depends on BACKLIGHT_CLASS_DEVICE
+	select NEW_LEDS
+	select LEDS_CLASS
+	help
+	  If you have a LCD backlight connected to the KTD253,
+	  say Y here to enable this driver.
+
+	  To compile this driver as a module, choose M here: the module will
+	  be called adp8885_bl.
+
+config BACKLIGHT_KTD3102
+	tristate "Backlight Driver for KTD3102 using WLED"
+	depends on BACKLIGHT_CLASS_DEVICE
+	select NEW_LEDS
+	select LEDS_CLASS
+	help
+	  If you have a LCD backlight connected to the KTD3102,
+	  say Y here to enable this driver.
+
+	  To compile this driver as a module, choose M here: the module will
+	  be called adp8885_bl.
+
 config BACKLIGHT_88PM860X
 	tristate "Backlight Driver for 88PM8606 using WLED"
 	depends on MFD_88PM860X
diff --git a/drivers/video/backlight/Makefile b/drivers/video/backlight/Makefile
index 36855ae8..753b4ae5 100644
--- a/drivers/video/backlight/Makefile
+++ b/drivers/video/backlight/Makefile
@@ -38,6 +38,8 @@ obj-$(CONFIG_BACKLIGHT_WM831X)	+= wm831x_bl.o
 obj-$(CONFIG_BACKLIGHT_ADP5520)	+= adp5520_bl.o
 obj-$(CONFIG_BACKLIGHT_ADP8860)	+= adp8860_bl.o
 obj-$(CONFIG_BACKLIGHT_ADP8870)	+= adp8870_bl.o
+obj-$(CONFIG_BACKLIGHT_KTD253)	+= ktd_bl.o
+obj-$(CONFIG_BACKLIGHT_KTD3102)	+= ktd_bl.o
 obj-$(CONFIG_BACKLIGHT_88PM860X) += 88pm860x_bl.o
 obj-$(CONFIG_BACKLIGHT_PCF50633)	+= pcf50633-backlight.o
 obj-$(CONFIG_BACKLIGHT_AAT2870) += aat2870_bl.o
diff --git a/drivers/video/backlight/lcd.c b/drivers/video/backlight/lcd.c
index 79c1b0d6..3f3be6a5 100644
--- a/drivers/video/backlight/lcd.c
+++ b/drivers/video/backlight/lcd.c
@@ -159,7 +159,7 @@ static ssize_t lcd_show_max_contrast(struct device *dev,
 	return sprintf(buf, "%d\n", ld->props.max_contrast);
 }
 
-static struct class *lcd_class;
+struct class *lcd_class;
 
 static void lcd_device_release(struct device *dev)
 {
diff --git a/drivers/video/fbmem.c b/drivers/video/fbmem.c
index c6ce416a..48b87eb5 100644
--- a/drivers/video/fbmem.c
+++ b/drivers/video/fbmem.c
@@ -418,6 +418,7 @@ static void fb_rotate_logo(struct fb_info *info, u8 *dst,
 static void fb_do_show_logo(struct fb_info *info, struct fb_image *image,
 			    int rotate, unsigned int num)
 {
+#ifndef CONFIG_ANDROID
 	unsigned int x;
 
 	if (rotate == FB_ROTATE_UR) {
@@ -445,6 +446,28 @@ static void fb_do_show_logo(struct fb_info *info, struct fb_image *image,
 			image->dy -= image->height + 8;
 		}
 	}
+#else
+	/* show the android logo at screen center */
+	image->dx = (info->var.xres - image->width) >> 1;
+	image->dy = (info->var.yres - image->height) >> 1;
+
+	if (image->dx <= 0)
+		image->dx = 0;
+	if (image->dy <= 0)
+		image->dy = 0;
+	if (rotate == FB_ROTATE_UR || rotate == FB_ROTATE_UD) {
+		if (image->dx > info->var.xres)
+			image->dx = info->var.xres;
+		if (image->dy > info->var.yres)
+			image->dy = info->var.yres;
+	} else {
+		if (image->dx > info->var.yres)
+			image->dx = info->var.yres;
+		if (image->dy > info->var.xres)
+			image->dy = info->var.xres;
+	}
+	info->fbops->fb_imageblit(info, image);
+#endif
 }
 
 static int fb_show_logo_line(struct fb_info *info, int rotate,
@@ -504,7 +527,6 @@ static int fb_show_logo_line(struct fb_info *info, int rotate,
 		if (logo_rotate)
 			fb_rotate_logo(info, logo_rotate, &image, rotate);
 	}
-
 	fb_do_show_logo(info, &image, rotate, n);
 
 	kfree(palette);
@@ -1362,15 +1384,12 @@ fb_mmap(struct file *file, struct vm_area_struct * vma)
 {
 	struct fb_info *info = file_fb_info(file);
 	struct fb_ops *fb;
-	unsigned long off;
+	unsigned long mmio_pgoff;
 	unsigned long start;
 	u32 len;
 
 	if (!info)
 		return -ENODEV;
-	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))
-		return -EINVAL;
-	off = vma->vm_pgoff << PAGE_SHIFT;
 	fb = info->fbops;
 	if (!fb)
 		return -ENODEV;
@@ -1382,33 +1401,24 @@ fb_mmap(struct file *file, struct vm_area_struct * vma)
 		return res;
 	}
 
-	/* frame buffer memory */
+	/*
+	 * Ugh. This can be either the frame buffer mapping, or
+	 * if pgoff points past it, the mmio mapping.
+	 */
 	start = info->fix.smem_start;
-	len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);
-	if (off >= len) {
-		/* memory mapped io */
-		off -= len;
-		if (info->var.accel_flags) {
-			mutex_unlock(&info->mm_lock);
-			return -EINVAL;
-		}
+	len = info->fix.smem_len;
+	mmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;
+	if (vma->vm_pgoff >= mmio_pgoff) {
+		vma->vm_pgoff -= mmio_pgoff;
 		start = info->fix.mmio_start;
-		len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);
+		len = info->fix.mmio_len;
 	}
 	mutex_unlock(&info->mm_lock);
-	start &= PAGE_MASK;
-	if ((vma->vm_end - vma->vm_start + off) > len)
-		return -EINVAL;
-	off += start;
-	vma->vm_pgoff = off >> PAGE_SHIFT;
-	/* This is an IO map - tell maydump to skip this VMA */
-	vma->vm_flags |= VM_IO | VM_RESERVED;
+
 	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
-	fb_pgprotect(file, vma, off);
-	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
-			     vma->vm_end - vma->vm_start, vma->vm_page_prot))
-		return -EAGAIN;
-	return 0;
+	fb_pgprotect(file, vma, start);
+
+	return vm_iomap_memory(vma, start, len);
 }
 
 static int
diff --git a/drivers/video/logo/Makefile b/drivers/video/logo/Makefile
index 3b437813..2a09cc2a 100644
--- a/drivers/video/logo/Makefile
+++ b/drivers/video/logo/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_LOGO_SUPERH_CLUT224)	+= logo_superh_clut224.o
 obj-$(CONFIG_LOGO_M32R_CLUT224)		+= logo_m32r_clut224.o
 
 obj-$(CONFIG_SPU_BASE)			+= logo_spe_clut224.o
+obj-$(CONFIG_ANDROID)			+= logo_android_clut224.o
 
 # How to generate logo's
 
diff --git a/drivers/video/logo/logo.c b/drivers/video/logo/logo.c
index 080c35b3..2faf2ede 100644
--- a/drivers/video/logo/logo.c
+++ b/drivers/video/logo/logo.c
@@ -64,9 +64,14 @@ const struct linux_logo * __init_refok fb_find_logo(int depth)
 	
 	if (depth >= 8) {
 #ifdef CONFIG_LOGO_LINUX_CLUT224
+#ifdef CONFIG_ANDROID
+		/* Android logo */
+		logo = &logo_android_clut224;
+#else
 		/* Generic Linux logo */
 		logo = &logo_linux_clut224;
 #endif
+#endif
 #ifdef CONFIG_LOGO_BLACKFIN_CLUT224
 		/* Blackfin Linux logo */
 		logo = &logo_blackfin_clut224;
diff --git a/drivers/video/logo/logo_android_clut224.ppm b/drivers/video/logo/logo_android_clut224.ppm
new file mode 100644
index 00000000..3dfc45a5
--- /dev/null
+++ b/drivers/video/logo/logo_android_clut224.ppm
@@ -0,0 +1,8163 @@
+P3
+200 240
+255
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  2 1 1
+3 3 2  4 3 3  5 4 3  5 4 3  5 4 3  5 4 3
+4 3 3  3 3 2  2 1 1  1 1 1  1 1 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  2 1 1
+3 3 2  3 3 2  4 3 3  4 3 3  3 3 2  3 3 2
+2 1 1  1 1 1  1 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 1  3 3 2  5 4 4  8 7 6  9 8 7
+13 11 10  14 13 11  16 14 12  16 14 13  16 14 13  16 14 12
+14 13 11  13 11 10  9 8 7  7 6 5  4 3 3  2 2 2
+1 1 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 2 2  4 3 3  6 5 4  8 7 6  10 9 8
+13 11 10  14 13 11  14 13 11  14 13 11  14 13 11  13 11 10
+10 9 8  9 8 7  6 5 4  4 3 3  2 2 2  1 1 1
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
+3 3 2  5 4 4  7 6 5  11 10 8  14 13 11  18 16 13
+23 20 17  26 23 20  28 24 21  28 24 21  29 25 22  28 24 21
+26 23 20  23 20 17  18 16 13  14 13 11  10 9 8  7 6 5
+4 3 3  2 2 2  1 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  2 2 2
+4 3 3  6 5 4  9 8 7  13 11 10  16 14 12  21 18 16
+24 21 18  26 23 20  26 23 20  26 23 20  26 23 20  24 21 18
+21 18 16  18 16 13  14 12 10  10 9 8  7 6 5  4 3 3
+2 2 2  1 1 1  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  3 3 2
+6 5 4  8 7 6  13 11 10  18 16 13  24 21 18  28 24 21
+34 30 26  37 33 29  40 35 31  40 35 31  40 35 31  37 33 29
+37 33 29  34 30 26  28 24 21  23 20 17  18 16 13  11 10 8
+9 8 7  5 4 4  3 3 2  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 2 2  5 4 4
+8 7 6  11 10 8  16 14 12  21 18 16  26 23 20  31 27 23
+34 30 26  37 33 29  37 33 29  37 33 29  37 33 29  34 30 26
+31 27 23  28 24 21  23 20 17  18 16 13  11 10 8  8 7 6
+5 4 4  3 3 2  1 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  2 2 2  6 5 4
+9 8 7  14 13 11  21 18 16  28 24 21  34 30 26  37 33 29
+43 37 32  47 41 35  49 43 38  53 47 40  53 47 40  49 43 38
+47 41 35  43 37 32  37 33 29  31 27 23  26 23 20  21 18 16
+13 11 10  8 7 6  5 4 4  2 2 2  1 1 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 2 2  5 4 4  8 7 6
+11 10 8  18 16 13  24 21 18  31 27 23  37 33 29  40 35 31
+47 41 35  47 41 35  49 43 38  49 43 38  49 43 38  47 41 35
+41 36 31  37 33 29  31 27 23  26 23 20  21 18 16  14 12 10
+8 7 6  5 4 4  3 3 2  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 1  3 3 2  5 4 4  9 8 7
+14 13 11  21 18 16  28 24 21  34 30 26  43 37 32  49 43 38
+53 47 40  57 50 44  57 50 44  57 50 44  57 50 44  57 50 44
+57 50 44  53 47 40  49 43 38  41 36 31  34 30 26  28 24 21
+21 18 16  14 12 10  8 7 6  5 4 4  2 2 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 1  4 3 3  8 7 6  13 11 10
+18 16 13  26 23 20  34 30 26  40 35 31  47 41 35  53 47 40
+57 50 44  57 50 44  57 50 44  57 50 44  57 50 44  57 50 44
+53 47 40  47 41 35  40 35 31  34 30 26  28 24 21  21 18 16
+14 12 10  9 8 7  5 4 4  2 2 2  1 1 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 2 2  5 4 4  8 7 6  13 11 10
+21 18 16  28 24 21  34 30 26  43 37 32  53 47 40  57 50 44
+57 50 44  73 64 56  73 64 56  94 81 64  94 81 64  73 64 56
+73 64 56  57 50 44  53 47 40  53 47 40  43 37 32  34 30 26
+26 23 20  21 18 16  13 11 10  8 7 6  4 3 3  2 2 2
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 1  4 3 3  7 6 5  11 10 8  18 16 13
+26 23 20  34 30 26  41 36 31  49 43 38  57 50 44  57 50 44
+57 50 44  73 64 56  73 64 56  73 64 56  73 64 56  57 50 44
+57 50 44  57 50 44  49 43 38  43 37 32  34 30 26  26 23 20
+21 18 16  13 11 10  8 7 6  4 3 3  2 2 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  3 3 2  7 6 5  11 10 8  18 16 13
+26 23 20  34 30 26  43 37 32  49 43 38  49 43 38  73 64 56
+142 113 92  166 134 109  183 141 112  187 146 116  187 146 116  181 140 110
+163 127 97  118 101 76  73 64 56  49 43 38  49 43 38  43 37 32
+34 30 26  24 21 18  18 16 13  11 10 8  6 5 4  3 3 2
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 2 2  6 5 4  10 9 8  16 14 12  24 21 18
+31 27 23  41 36 31  49 43 38  49 43 38  57 50 44  94 81 64
+142 113 92  166 134 109  178 138 109  183 141 112  166 134 109  158 123 96
+118 101 76  73 64 56  49 43 38  49 43 38  43 37 32  34 30 26
+24 21 18  18 16 13  11 10 8  7 6 5  3 3 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 1  4 3 3  8 7 6  14 12 10  21 18 16
+29 25 22  37 33 29  43 37 32  47 41 35  118 101 76  178 138 109
+183 141 112  186 144 112  187 146 116  187 146 116  187 146 116  187 146 116
+186 144 112  183 141 112  166 134 109  94 81 64  47 41 35  47 41 35
+40 35 31  31 27 23  23 20 17  14 13 11  8 7 6  5 4 4
+1 1 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 1 1  5 4 4  8 7 6  14 12 10  21 18 16  29 25 22
+37 33 29  47 41 35  43 37 32  73 64 56  158 123 96  183 141 112
+186 144 112  186 144 112  187 146 116  187 146 116  187 146 116  186 144 112
+186 144 112  166 134 109  94 81 64  47 41 35  47 41 35  37 33 29
+29 25 22  21 18 16  14 12 10  8 7 6  4 3 3  1 1 1
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 2 2  6 5 4  10 9 8  16 14 12  24 21 18
+31 27 23  37 33 29  41 36 31  142 113 92  180 137 106  183 141 109
+186 144 112  186 144 112  186 144 112  186 144 112  186 144 112  186 144 112
+186 144 112  186 144 112  183 141 109  182 139 108  118 101 76  40 35 31
+41 36 31  34 30 26  26 23 20  21 18 16  13 11 10  7 6 5
+3 3 2  1 1 1  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+3 3 2  7 6 5  11 10 8  18 16 13  26 23 20  34 30 26
+41 36 31  37 33 29  94 81 64  177 133 103  183 141 109  186 144 112
+186 144 112  186 144 112  186 144 112  186 144 112  186 144 112  186 144 112
+186 144 112  183 141 109  182 139 108  118 101 76  40 35 31  40 35 31
+34 30 26  24 21 18  16 14 12  10 9 8  6 5 4  2 2 2
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 2 2  7 6 5  11 10 8  18 16 13  24 21 18
+31 27 23  28 24 21  118 101 76  179 134 102  183 141 109  183 141 109
+183 141 109  183 141 109  183 141 109  183 141 109  183 141 109  183 141 109
+183 141 109  183 141 109  183 141 112  183 141 109  181 137 105  118 101 76
+34 30 26  37 33 29  31 27 23  23 20 17  16 14 12  9 8 7
+6 5 4  3 3 2  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
+4 3 3  8 7 6  14 13 11  23 20 17  29 25 22  37 33 29
+34 30 26  94 81 64  177 133 103  182 139 108  183 141 112  183 141 112
+183 141 109  183 141 109  183 141 109  183 141 109  183 141 109  183 141 109
+183 141 109  183 141 109  183 141 109  181 137 105  118 101 76  29 25 22
+34 30 26  24 21 18  18 16 13  11 10 8  7 6 5  3 3 2
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  3 3 2  7 6 5  11 10 8  18 16 13  24 21 18
+21 18 16  73 64 56  172 131 98  181 137 105  182 139 108  182 139 108
+182 139 108  180 137 106  181 137 105  180 137 106  180 137 106  181 137 105
+180 137 106  182 139 108  183 141 109  183 141 109  181 137 105  172 131 98
+57 50 44  31 27 23  34 30 26  26 23 20  21 18 16  13 11 10
+8 7 6  4 3 3  1 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  3 3 2
+7 6 5  11 10 8  18 16 13  26 23 20  34 30 26  34 30 26
+49 43 38  163 127 97  181 137 105  183 141 109  182 139 108  182 139 108
+181 137 105  180 137 106  181 137 105  181 137 105  181 137 105  180 137 106
+182 139 108  182 139 108  182 139 108  181 137 105  172 131 98  73 64 56
+23 20 17  24 21 18  18 16 13  11 10 8  7 6 5  3 3 2
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  3 3 2  7 6 5  11 10 8  16 14 12  21 18 16
+21 18 16  142 113 92  176 130 98  179 134 102  179 134 102  179 134 102
+179 134 102  177 132 101  177 132 101  177 132 101  177 132 101  177 132 101
+177 132 101  179 134 102  181 137 105  181 137 105  181 137 105  179 134 102
+142 113 92  31 27 23  34 30 26  29 25 22  23 20 17  16 14 12
+10 9 8  6 5 4  2 2 2  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 2 2  5 4 4
+9 8 7  14 13 11  23 20 17  28 24 21  34 30 26  28 24 21
+118 101 76  179 134 102  181 137 105  181 137 105  181 137 105  181 137 105
+179 134 102  177 132 101  177 132 101  177 132 101  177 132 101  179 134 102
+179 134 102  181 137 105  181 137 105  181 137 105  177 131 99  142 113 92
+21 18 16  21 18 16  16 14 12  11 10 8  7 6 5  3 3 2
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 2 2  6 5 4  8 7 6  13 11 10  8 7 6
+49 43 38  173 127 96  177 131 99  177 132 101  177 132 101  177 131 99
+176 130 98  176 129 96  174 128 96  175 128 95  175 128 95  174 128 96
+176 129 96  177 131 99  177 132 101  179 134 102  181 137 105  181 137 105
+177 132 101  73 64 56  26 23 20  34 30 26  26 23 20  21 18 16
+13 11 10  8 7 6  4 3 3  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  4 3 3  8 7 6
+11 10 8  18 16 13  24 21 18  31 27 23  29 25 22  57 50 44
+172 131 98  181 137 105  181 137 105  179 134 102  179 134 102  177 131 99
+176 130 98  176 129 96  174 128 96  174 128 96  176 129 96  176 130 98
+177 131 99  177 132 101  177 132 101  177 132 101  177 132 101  173 127 96
+53 47 40  9 8 7  14 12 10  9 8 7  6 5 4  2 2 2
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 2 2  4 3 3  6 5 4  8 7 6  0 0 0
+94 81 64  171 123 90  176 129 96  174 128 96  174 128 96  175 128 95
+174 127 94  173 126 93  173 125 92  172 124 92  172 124 92  173 125 92
+173 126 93  175 128 95  176 130 98  177 131 99  179 134 102  181 137 105
+177 132 101  142 113 92  31 27 23  31 27 23  29 25 22  23 20 17
+16 14 12  11 10 8  6 5 4  2 2 2  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 2 2  6 5 4  10 9 8
+16 14 12  23 20 17  28 24 21  34 30 26  26 23 20  118 101 76
+177 132 101  181 137 105  179 134 102  177 132 101  176 130 98  174 128 96
+174 127 94  172 125 93  173 125 92  173 125 92  173 126 93  173 126 93
+174 127 94  175 128 95  176 129 96  176 129 96  176 129 96  172 124 91
+94 81 64  0 0 0  9 8 7  7 6 5  4 3 3  2 2 2
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 1  1 1 1  2 2 2  0 0 0
+94 81 64  169 121 86  173 126 93  172 125 93  173 125 92  173 125 92
+172 125 92  172 124 91  171 124 91  171 123 90  171 123 90  171 124 91
+172 124 91  173 126 93  174 128 95  176 129 96  177 131 99  177 132 101
+179 134 102  177 131 99  94 81 64  23 20 17  31 27 23  26 23 20
+21 18 16  14 12 10  8 7 6  4 3 3  1 1 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 1 1  3 3 2
+5 4 4  5 4 4  6 5 4  7 6 5  7 6 5  8 7 6
+9 8 7  10 9 8  10 9 8  10 9 8  10 9 8  10 9 8
+9 8 7  8 7 6  7 6 5  8 7 6  6 5 4  5 4 4
+4 3 3  3 3 2  2 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 1  4 3 3  8 7 6  13 11 10
+18 16 13  24 21 18  31 27 23  24 21 18  73 64 56  176 130 98
+179 134 102  179 134 102  177 132 101  176 130 98  174 128 96  173 126 93
+172 125 92  171 124 91  171 124 91  171 123 90  172 124 91  172 124 91
+172 125 92  172 125 93  173 126 93  173 126 93  173 126 93  170 121 89
+118 101 76  0 0 0  3 3 2  2 2 2  1 1 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+97 66 41  172 123 91  170 122 89  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 125 92  173 126 93  175 127 95  176 129 96  177 132 101
+179 134 102  177 131 99  158 123 96  34 30 26  31 27 23  29 25 22
+23 20 17  18 16 13  11 10 8  8 7 6  6 5 4  5 4 4
+6 5 4  7 6 5  9 8 7  10 9 8  13 11 10  14 13 11
+16 14 12  18 16 13  21 18 16  21 18 16  21 18 16  23 20 17
+23 20 17  24 21 18  24 21 18  24 21 18  24 21 18  24 21 18
+23 20 17  23 20 17  21 18 16  21 18 16  18 16 13  18 16 13
+16 14 12  14 13 11  13 11 10  10 9 8  9 8 7  7 6 5
+5 4 4  4 3 3  5 4 4  8 7 6  11 10 8  16 14 12
+23 20 17  28 24 21  31 27 23  26 23 20  142 113 92  177 131 99
+179 134 102  177 132 101  176 130 98  174 128 95  173 127 94  172 125 92
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  172 124 91
+115 77 51  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  2 1 0  3 2 1  4 2 1  0 0 0
+74 57 39  169 121 89  164 117 85  167 118 86  167 120 88  168 120 88
+167 121 88  170 122 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  173 125 92  173 126 93  174 128 95  176 130 98
+177 132 101  179 134 102  176 130 98  94 81 64  23 20 17  34 30 26
+29 25 22  24 21 18  21 18 16  18 16 13  16 14 12  14 13 11
+16 14 12  18 16 13  21 18 16  23 20 17  24 21 18  26 23 20
+28 24 21  29 25 22  31 27 23  34 30 26  34 30 26  34 30 26
+34 30 26  34 30 26  34 30 26  34 30 26  34 30 26  34 30 26
+34 30 26  34 30 26  34 30 26  31 27 23  31 27 23  29 25 22
+28 24 21  26 23 20  24 21 18  23 20 17  21 18 16  18 16 13
+16 14 12  14 13 11  14 13 11  16 14 12  21 18 16  24 21 18
+28 24 21  34 30 26  24 21 18  73 64 56  176 130 98  179 134 102
+177 132 101  176 130 98  174 128 96  173 127 94  173 125 92  172 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+169 121 88  169 121 86  168 120 88  166 119 87  166 119 87  169 121 89
+97 66 41  0 0 0  3 2 1  2 1 0  1 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 0  3 2 1  5 3 1  6 4 2  2 1 0
+58 40 23  164 117 85  162 115 82  163 116 84  164 117 85  164 117 85
+167 120 88  169 121 88  170 122 89  171 123 90  171 123 90  171 123 90
+171 123 90  171 124 91  172 125 92  172 125 93  175 127 95  176 130 98
+177 132 101  177 132 101  177 132 101  163 127 97  47 41 35  34 30 26
+37 33 29  34 30 26  31 27 23  29 25 22  28 24 21  28 24 21
+28 24 21  31 27 23  34 30 26  34 30 26  37 33 29  37 33 29
+40 35 31  41 36 31  43 37 32  43 37 32  43 37 32  47 41 35
+47 41 35  47 41 35  47 41 35  47 41 35  47 41 35  47 41 35
+47 41 35  47 41 35  43 37 32  43 37 32  43 37 32  40 35 31
+40 35 31  37 33 29  37 33 29  34 30 26  31 27 23  31 27 23
+28 24 21  26 23 20  26 23 20  28 24 21  31 27 23  34 30 26
+34 30 26  34 30 26  34 30 26  158 123 96  177 132 101  179 134 102
+177 132 101  176 130 98  174 128 95  173 126 93  172 125 92  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  169 121 88
+168 120 88  167 118 86  164 117 85  163 116 84  162 115 82  164 117 85
+68 46 25  1 1 0  6 4 2  5 3 1  3 2 1  1 1 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 1 0  4 2 1  6 4 2  8 5 2  8 5 2
+28 19 9  152 106 74  157 113 79  159 112 81  162 115 82  163 116 84
+164 117 85  167 120 88  169 121 88  170 122 89  171 123 90  171 123 90
+171 123 90  171 123 90  172 124 91  172 125 92  173 127 94  174 128 96
+176 130 98  177 132 101  179 134 102  177 131 99  118 101 76  29 25 22
+41 36 31  41 36 31  40 35 31  40 35 31  37 33 29  37 33 29
+40 35 31  43 37 32  43 37 32  47 41 35  49 43 38  49 43 38
+53 47 40  53 47 40  53 47 40  57 50 44  57 50 44  57 50 44
+57 50 44  57 50 44  57 50 44  57 50 44  57 50 44  57 50 44
+57 50 44  57 50 44  57 50 44  53 47 40  53 47 40  53 47 40
+49 43 38  49 43 38  47 41 35  47 41 35  43 37 32  41 36 31
+40 35 31  37 33 29  37 33 29  37 33 29  40 35 31  40 35 31
+41 36 31  29 25 22  94 81 64  177 132 101  179 134 102  177 132 101
+177 131 99  174 128 96  173 127 94  172 125 92  172 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  170 122 89  169 121 88  168 120 88
+164 117 85  163 116 84  162 115 82  159 112 81  157 113 79  157 113 79
+36 25 11  7 5 2  8 5 2  6 4 2  4 2 1  2 1 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 1 0  5 3 1  7 5 2  10 6 3  13 8 3
+12 8 3  97 66 41  155 109 77  155 109 77  159 112 81  159 112 81
+163 116 84  164 117 85  168 120 88  169 122 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 124 91  172 124 91  173 125 92  175 127 95
+176 129 96  177 131 99  177 132 101  179 134 102  172 131 98  57 50 44
+40 35 31  49 43 38  49 43 38  49 43 38  49 43 38  49 43 38
+49 43 38  53 47 40  57 50 44  57 50 44  57 50 44  57 50 44
+57 50 44  57 50 44  57 50 44  57 50 44  57 50 44  57 50 44
+57 50 44  57 50 44  57 50 44  57 50 44  57 50 44  57 50 44
+57 50 44  57 50 44  57 50 44  57 50 44  57 50 44  57 50 44
+57 50 44  57 50 44  57 50 44  57 50 44  53 47 40  53 47 40
+49 43 38  49 43 38  49 43 38  49 43 38  49 43 38  49 43 38
+43 37 32  49 43 38  163 127 97  177 133 103  177 132 101  177 131 99
+176 129 96  175 127 95  172 125 93  172 124 91  171 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  169 122 89  169 121 86  167 118 86
+163 116 84  162 115 82  159 112 81  155 109 77  155 109 77  115 77 51
+16 10 4  13 8 3  10 6 3  7 5 2  5 3 1  2 1 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 1 0  5 3 1  7 5 2  11 7 4  16 10 4
+13 8 3  39 26 12  149 107 69  154 107 75  155 109 77  157 113 79
+162 115 82  164 117 85  166 119 87  169 121 88  170 122 89  171 123 90
+171 123 90  171 123 90  171 123 90  171 124 91  172 125 92  174 127 94
+176 129 96  176 130 98  177 132 101  179 134 102  177 132 101  142 113 92
+40 35 31  53 47 40  57 50 44  57 50 44  57 50 44  57 50 44
+57 50 44  57 50 44  57 50 44  57 50 44  57 50 44  57 50 44
+73 64 56  73 64 56  73 64 56  94 81 64  94 81 64  94 81 64
+94 81 64  118 101 76  118 101 76  118 101 76  118 101 76  118 101 76
+94 81 64  94 81 64  94 81 64  73 64 56  73 64 56  73 64 56
+73 64 56  57 50 44  57 50 44  57 50 44  57 50 44  57 50 44
+57 50 44  57 50 44  57 50 44  57 50 44  57 50 44  53 47 40
+37 33 29  118 101 76  177 132 101  181 137 105  177 132 101  176 130 98
+176 129 96  174 127 94  172 125 92  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  169 121 88  167 120 88  164 117 85
+162 115 82  159 112 81  155 109 77  154 107 75  152 106 74  49 35 24
+13 8 3  16 10 4  11 7 4  7 5 2  5 3 1  2 1 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 1 0  4 3 1  7 5 2  10 6 3  16 10 4
+20 14 6  16 10 4  97 66 41  154 107 75  152 106 74  155 109 77
+159 112 81  163 116 84  164 117 85  168 120 88  170 122 89  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  172 124 91  172 125 93
+175 127 95  176 129 96  177 131 99  179 134 102  181 137 105  177 133 103
+73 64 56  49 43 38  57 50 44  73 64 56  57 50 44  57 50 44
+57 50 44  73 64 56  94 81 64  94 81 64  118 101 76  142 113 92
+158 123 96  166 134 109  178 138 109  183 141 112  183 141 112  183 141 112
+186 144 112  187 146 116  187 146 116  187 146 116  187 146 116  187 146 116
+187 146 116  187 146 116  183 141 112  183 141 112  178 138 109  166 134 109
+158 123 96  142 113 92  118 101 76  94 81 64  73 64 56  73 64 56
+57 50 44  57 50 44  57 50 44  57 50 44  57 50 44  53 47 40
+73 64 56  172 131 98  179 134 102  179 134 102  177 132 101  176 129 96
+174 128 95  173 126 93  172 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  168 120 88  167 118 86  163 116 84
+159 112 81  155 109 77  152 106 74  152 106 74  115 77 51  19 12 5
+19 12 5  16 10 4  11 7 4  7 5 2  4 3 1  2 1 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 0  3 2 1  6 4 2  10 6 3  13 8 3
+19 12 5  19 12 5  32 22 10  137 93 64  152 106 74  152 106 74
+155 109 77  159 112 81  163 116 84  166 119 87  169 121 88  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  172 125 92
+173 127 94  174 128 95  176 130 98  177 132 101  181 137 105  179 134 102
+158 123 96  49 43 38  57 50 44  73 64 56  94 81 64  118 101 76
+158 123 96  166 134 109  178 138 109  187 146 116  187 146 116  186 144 112
+186 144 112  187 146 116  187 146 116  187 146 116  187 146 116  186 144 112
+186 144 112  187 146 116  187 146 116  187 146 116  187 146 116  187 146 116
+186 144 112  186 144 112  187 146 116  187 146 116  186 144 112  186 144 112
+186 144 112  186 144 112  187 146 116  187 146 116  178 138 109  166 134 109
+142 113 92  118 101 76  94 81 64  73 64 56  57 50 44  47 41 35
+142 113 92  179 134 102  181 137 105  177 133 103  176 130 98  174 128 96
+174 127 94  172 125 92  171 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  170 122 89  169 121 88  167 118 86  163 116 84  162 115 82
+155 109 77  154 107 75  152 106 74  145 99 68  42 29 13  17 12 5
+20 14 6  16 10 4  10 6 3  6 4 2  3 2 1  1 1 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 1 0  5 4 1  8 5 2  13 8 3
+17 12 5  20 14 6  17 12 5  74 57 39  152 106 74  152 106 74
+154 107 75  159 112 81  162 115 82  164 117 85  168 120 88  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  172 124 91
+172 125 93  173 127 94  176 129 96  177 132 101  179 134 102  180 137 106
+182 139 108  118 101 76  142 113 92  166 134 109  183 141 112  186 144 112
+186 144 112  186 144 112  186 144 112  187 146 116  186 144 112  186 144 112
+186 144 112  186 144 112  186 144 112  186 144 112  183 141 112  183 141 112
+183 141 109  183 141 109  183 141 109  183 141 109  183 141 109  183 141 109
+183 141 109  183 141 112  183 141 112  186 144 112  186 144 112  186 144 112
+186 144 112  187 146 116  187 146 116  187 146 116  186 144 112  186 144 112
+186 144 112  187 146 116  183 141 112  163 127 97  118 101 76  118 101 76
+180 137 106  180 137 106  181 137 105  177 132 101  176 129 96  174 127 94
+172 125 93  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  168 120 88  164 117 85  162 115 82  157 113 79
+154 107 75  152 106 74  152 106 74  97 66 41  19 12 5  20 14 6
+19 12 5  13 8 3  10 6 3  5 4 1  2 2 0  1 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 1 0  4 2 1  7 5 2  12 8 3
+16 10 4  20 14 6  20 14 6  28 19 9  132 88 59  152 106 74
+152 106 74  155 109 77  159 112 81  163 116 84  166 119 87  169 121 88
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 124 91
+172 125 92  173 126 93  174 128 95  176 130 98  177 132 101  179 134 102
+181 137 105  182 139 108  182 139 108  183 141 109  186 144 112  186 144 112
+186 144 112  186 144 112  186 144 112  183 141 112  183 141 109  183 141 109
+183 141 109  182 139 108  182 139 108  182 139 108  182 139 108  182 139 108
+181 137 105  181 137 105  181 137 105  181 137 105  181 137 105  181 137 105
+181 137 105  182 139 108  182 139 108  182 139 108  183 141 109  183 141 109
+183 141 109  183 141 109  183 141 109  186 144 112  186 144 112  186 144 112
+186 144 112  186 144 112  186 144 112  183 141 109  183 141 109  182 139 108
+182 139 108  181 137 105  177 132 101  176 130 98  174 128 96  173 126 93
+173 125 92  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  169 122 89  167 120 88  163 116 84  159 112 81  155 109 77
+152 106 74  152 106 74  139 97 68  39 26 12  20 14 6  20 14 6
+17 12 5  12 8 3  7 5 2  5 3 1  2 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 0  2 2 0  5 4 1  10 6 3
+13 8 3  19 12 5  22 15 7  19 12 5  68 46 25  152 106 74
+152 106 74  154 107 75  159 112 81  162 115 82  164 117 85  168 120 88
+169 121 88  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  172 125 92  173 127 94  174 128 96  176 130 98  177 132 101
+179 134 102  180 137 106  182 139 108  183 141 109  183 141 109  183 141 109
+183 141 109  182 139 108  182 139 108  181 137 105  181 137 105  181 137 105
+181 137 105  181 137 105  179 134 102  179 134 102  179 134 102  179 134 102
+179 134 102  179 134 102  179 134 102  179 134 102  179 134 102  179 134 102
+179 134 102  179 134 102  179 134 102  179 134 102  181 137 105  181 137 105
+181 137 105  181 137 105  180 137 106  181 137 105  182 139 108  183 141 109
+183 141 109  183 141 109  183 141 109  183 141 109  182 139 108  181 137 105
+181 137 105  177 132 101  176 130 98  176 129 96  174 127 94  172 125 92
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 122 89  167 121 88  167 118 86  162 115 82  159 112 81  154 107 75
+152 106 74  152 106 74  74 57 39  19 12 5  22 15 7  19 12 5
+13 8 3  10 6 3  6 4 2  3 2 1  1 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 1 0  4 3 1  7 5 2
+12 8 3  16 10 4  20 14 6  20 14 6  24 16 7  115 77 51
+154 107 75  154 107 75  157 113 79  162 115 82  164 117 85  167 120 88
+169 121 88  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 124 91  173 125 92  174 127 94  174 128 96  176 130 98
+177 132 101  179 134 102  179 134 102  181 137 105  181 137 105  181 137 105
+181 137 105  179 134 102  179 134 102  179 134 102  179 134 102  177 132 101
+177 132 101  177 131 99  177 131 99  177 131 99  177 131 99  176 130 98
+176 130 98  176 130 98  176 130 98  176 130 98  176 130 98  176 130 98
+176 130 98  176 130 98  177 131 99  177 131 99  177 131 99  177 132 101
+177 132 101  177 132 101  179 134 102  179 134 102  179 134 102  181 137 105
+181 137 105  181 137 105  181 137 105  181 137 105  181 137 105  179 134 102
+177 132 101  177 131 99  174 128 96  174 127 94  172 125 93  172 124 91
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 121 88  168 120 88  164 117 85  162 115 82  159 112 81  154 107 75
+152 106 74  133 92 63  30 20 10  20 14 6  20 14 6  17 12 5
+12 8 3  7 5 2  5 3 1  2 1 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 0  2 2 0  5 4 1
+8 5 2  12 8 3  16 10 4  19 12 5  16 10 4  49 35 24
+155 109 77  155 109 77  159 112 81  162 115 82  164 117 85  167 120 88
+169 121 88  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  172 124 91  173 126 93  174 127 94  174 128 96
+176 130 98  177 131 99  177 131 99  177 132 101  177 132 101  177 132 101
+177 132 101  177 131 99  176 130 98  176 130 98  176 129 96  176 129 96
+174 128 96  174 128 95  175 127 95  174 127 94  174 127 94  173 127 94
+173 126 93  173 126 93  173 126 93  173 126 93  173 126 93  173 126 93
+173 126 93  173 127 94  174 127 94  174 127 94  175 127 95  174 128 95
+174 128 96  176 129 96  176 130 98  176 130 98  177 131 99  177 132 101
+177 132 101  177 132 101  177 132 101  177 132 101  177 132 101  177 131 99
+176 130 98  176 129 96  174 127 94  173 127 94  172 125 92  172 124 91
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 121 88  168 120 88  164 117 85  162 115 82  159 112 81  155 109 77
+155 109 77  68 46 25  16 10 4  20 14 6  17 12 5  13 8 3
+8 5 2  6 4 2  3 2 1  1 1 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 0  3 2 1
+5 3 1  7 5 2  10 6 3  13 8 3  13 8 3  11 7 4
+115 77 51  162 115 82  162 115 82  163 116 84  166 119 87  167 121 88
+169 121 88  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 124 91  172 125 92  172 125 93  173 127 94
+175 127 95  174 128 96  176 129 96  176 129 96  176 129 96  174 128 96
+174 128 96  175 127 95  174 127 94  173 127 94  173 126 93  172 125 92
+172 124 91  172 124 91  171 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  172 124 91
+172 125 92  172 125 92  173 126 93  173 127 94  174 127 94  174 128 95
+174 128 96  176 129 96  176 129 96  176 129 96  176 129 96  176 129 96
+174 128 95  173 127 94  172 125 93  172 125 92  172 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 121 88  167 121 88  166 119 87  163 116 84  159 112 81  162 115 82
+132 88 59  17 12 5  13 8 3  13 8 3  11 7 4  8 5 2
+6 4 2  3 2 1  2 1 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 1 0  3 2 1  3 2 1  5 3 1  6 4 2  2 1 0
+30 20 10  159 112 81  164 117 85  166 119 87  168 120 88  169 121 88
+169 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 124 91  172 124 91  172 124 91
+172 125 92  173 125 92  173 125 92  173 125 92  172 125 92  172 125 92
+172 125 92  172 124 91  171 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 124 91  171 124 91  172 124 91
+172 125 92  172 125 92  172 125 93  172 125 93  172 125 93  172 125 93
+172 125 92  172 125 92  172 124 91  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 122 89  169 121 88  167 120 88  167 118 86  164 117 85  164 117 85
+42 29 13  3 2 1  8 5 2  6 4 2  5 3 1  3 2 1
+2 1 0  1 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 2 2  3 3 2
+3 3 2  3 3 2  3 3 2  2 2 2  2 1 1  1 1 1
+0 0 0  97 66 41  170 122 89  169 121 89  170 122 89  170 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  169 122 89  167 121 88  170 121 89  115 77 51
+3 3 2  1 0 0  2 1 1  1 1 1  2 1 1  2 1 1
+2 1 1  1 1 1  1 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 1  3 3 2  6 5 4  8 7 6
+13 11 10  14 13 11  16 14 12  16 14 12  14 13 11  13 11 10
+0 0 0  23 20 17  158 114 83  171 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  164 117 85  41 36 31
+0 0 0  9 8 7  11 10 8  13 11 10  13 11 10  13 11 10
+10 9 8  8 7 6  5 4 4  2 2 2  1 1 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 1  4 3 3  7 6 5  11 10 8  16 14 12
+21 18 16  24 21 18  28 24 21  31 27 23  31 27 23  21 18 16
+18 16 13  94 81 64  167 121 88  173 127 94  172 125 93  172 124 91
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 124 91  172 125 92  172 125 93  167 120 88  73 64 56
+9 8 7  21 18 16  28 24 21  28 24 21  26 23 20  23 20 17
+21 18 16  14 13 11  10 9 8  6 5 4  3 3 2  1 1 1
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 1 1  3 3 2  8 7 6  11 10 8  18 16 13  24 21 18
+31 27 23  34 30 26  37 33 29  41 36 31  31 27 23  53 47 40
+142 113 92  174 128 96  176 130 98  174 128 96  173 127 94  172 125 92
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  172 125 92  173 127 94  174 128 96  176 129 96  174 128 95
+118 101 76  37 33 29  31 27 23  40 35 31  37 33 29  34 30 26
+29 25 22  23 20 17  16 14 12  10 9 8  6 5 4  3 3 2
+1 1 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
+4 3 3  7 6 5  11 10 8  18 16 13  24 21 18  31 27 23
+37 33 29  47 41 35  47 41 35  37 33 29  94 81 64  163 127 97
+177 132 101  179 134 102  177 131 99  176 129 96  174 127 94  172 125 92
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  172 125 92  173 127 94  176 129 96  177 131 99  177 132 101
+177 131 99  158 123 96  73 64 56  37 33 29  47 41 35  43 37 32
+37 33 29  31 27 23  23 20 17  16 14 12  10 9 8  6 5 4
+3 3 2  1 1 1  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  3 3 2
+7 6 5  11 10 8  16 14 12  24 21 18  31 27 23  40 35 31
+47 41 35  49 43 38  43 37 32  118 101 76  180 137 106  181 137 105
+181 137 105  179 134 102  177 131 99  176 129 96  173 127 94  172 125 92
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  172 125 92  173 127 94  176 129 96  177 131 99  179 134 102
+181 137 105  179 134 102  172 131 98  94 81 64  40 35 31  49 43 38
+47 41 35  37 33 29  31 27 23  24 21 18  16 14 12  9 8 7
+6 5 4  3 3 2  1 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  4 3 3  7 6 5
+10 9 8  16 14 12  24 21 18  31 27 23  37 33 29  47 41 35
+49 43 38  49 43 38  118 101 76  181 137 105  182 139 108  182 139 108
+181 137 105  177 132 101  177 131 99  175 128 95  173 126 93  172 125 92
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  172 125 92  173 126 93  175 128 95  177 131 99  177 132 101
+181 137 105  182 139 108  181 137 105  180 137 106  118 101 76  43 37 32
+49 43 38  47 41 35  37 33 29  31 27 23  23 20 17  16 14 12
+10 9 8  6 5 4  3 3 2  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 1  3 3 2  6 5 4  10 9 8
+16 14 12  23 20 17  31 27 23  37 33 29  47 41 35  47 41 35
+53 47 40  142 113 92  180 137 106  183 141 109  182 139 108  181 137 105
+179 134 102  177 131 99  176 129 96  175 127 95  172 125 93  172 124 91
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  172 124 91  172 125 93  175 127 95  176 129 96  177 131 99
+179 134 102  180 137 106  183 141 109  183 141 109  182 139 108  118 101 76
+47 41 35  49 43 38  43 37 32  37 33 29  29 25 22  23 20 17
+14 13 11  9 8 7  6 5 4  2 2 2  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 2 2  5 4 4  9 8 7  16 14 12
+23 20 17  29 25 22  37 33 29  47 41 35  43 37 32  53 47 40
+142 113 92  180 137 106  183 141 109  182 139 108  181 137 105  179 134 102
+177 132 101  176 130 98  176 129 96  174 127 94  173 125 92  172 124 91
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 124 91  173 125 92  174 127 94  176 129 96  176 130 98
+177 132 101  179 134 102  181 137 105  183 141 109  183 141 109  181 137 105
+118 101 76  43 37 32  47 41 35  43 37 32  37 33 29  28 24 21
+21 18 16  14 13 11  8 7 6  5 4 4  2 2 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 2 2  5 4 4  8 7 6  14 12 10  21 18 16
+28 24 21  37 33 29  43 37 32  43 37 32  49 43 38  142 113 92
+181 137 105  183 141 109  182 139 108  181 137 105  179 134 102  177 132 101
+176 130 98  175 127 95  173 127 94  172 125 92  172 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 124 91  172 124 91  173 125 92  174 127 94  174 128 95
+176 130 98  177 132 101  179 134 102  181 137 105  182 139 108  183 141 109
+181 137 105  142 113 92  43 37 32  47 41 35  43 37 32  34 30 26
+28 24 21  21 18 16  13 11 10  8 7 6  4 3 3  2 2 2
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 1 1  4 3 3  8 7 6  13 11 10  21 18 16  26 23 20
+34 30 26  41 36 31  43 37 32  49 43 38  142 113 92  181 137 105
+182 139 108  182 139 108  181 137 105  177 132 101  177 131 99  176 129 96
+175 127 95  173 125 92  172 124 91  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 124 91  172 124 92  173 126 93
+175 127 95  176 130 98  177 131 99  179 134 102  181 137 105  182 139 108
+183 141 109  181 137 105  118 101 76  41 36 31  47 41 35  40 35 31
+34 30 26  26 23 20  18 16 13  11 10 8  7 6 5  3 3 2
+1 1 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+3 3 2  7 6 5  11 10 8  18 16 13  26 23 20  34 30 26
+40 35 31  43 37 32  43 37 32  142 113 92  181 137 105  182 139 108
+181 137 105  181 137 105  179 134 102  177 131 99  174 128 96  174 127 94
+172 125 92  172 125 92  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  172 124 92
+173 126 93  175 127 95  176 129 96  177 131 99  179 134 102  181 137 105
+181 137 105  182 139 108  181 137 105  118 101 76  37 33 29  43 37 32
+37 33 29  31 27 23  24 21 18  16 14 12  10 9 8  6 5 4
+2 2 2  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  2 2 2
+5 4 4  9 8 7  16 14 12  23 20 17  31 27 23  37 33 29
+43 37 32  37 33 29  118 101 76  181 137 105  182 139 108  181 137 105
+181 137 105  179 134 102  177 131 99  174 128 96  173 127 94  172 125 93
+172 124 91  171 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 124 91
+172 125 92  173 126 93  174 127 94  176 129 96  177 131 99  179 134 102
+181 137 105  181 137 105  182 139 108  180 137 106  94 81 64  34 30 26
+43 37 32  37 33 29  29 25 22  23 20 17  14 13 11  8 7 6
+4 3 3  2 2 2  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 2 2  5 4 4
+8 7 6  14 12 10  21 18 16  28 24 21  34 30 26  41 36 31
+34 30 26  118 101 76  179 134 102  182 139 108  181 137 105  179 134 102
+177 132 101  177 131 99  174 128 96  173 127 94  172 125 92  172 124 91
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 121 89  168 118 83  167 117 83
+168 119 85  170 122 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 121 86  168 118 83  167 117 83  169 121 86  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 125 92  172 125 92  174 127 94  176 129 96  177 131 99
+177 132 101  181 137 105  181 137 105  180 137 106  177 133 103  73 64 56
+34 30 26  40 35 31  34 30 26  26 23 20  21 18 16  11 10 8
+8 7 6  4 3 3  1 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  3 3 2  7 6 5
+11 10 8  18 16 13  26 23 20  34 30 26  40 35 31  34 30 26
+73 64 56  177 133 103  181 137 105  181 137 105  179 134 102  177 132 101
+176 130 98  174 128 96  173 127 94  172 125 92  172 124 91  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  170 122 89  166 116 81  173 127 94  187 146 116  187 146 116
+182 139 108  168 119 85  168 118 83  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 121 89  166 116 81
+176 130 98  187 146 116  187 146 116  180 137 106  167 117 83  168 119 85
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 124 91  172 124 91  172 125 92  173 127 94  176 129 96
+177 131 99  177 132 101  181 137 105  182 139 108  181 137 105  163 127 97
+57 50 44  37 33 29  37 33 29  31 27 23  24 21 18  16 14 12
+10 9 8  6 5 4  3 3 2  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 2 2  5 4 4  10 9 8
+14 13 11  23 20 17  31 27 23  37 33 29  34 30 26  53 47 40
+163 127 97  181 137 105  181 137 105  179 134 102  179 134 102  177 131 99
+174 128 96  174 127 94  172 125 93  172 124 91  171 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 121 89  168 118 83  195 162 138  236 226 219  247 243 239  248 245 242
+243 238 233  224 209 198  183 141 112  166 116 81  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  168 119 85  171 123 90  210 188 172
+238 234 230  247 243 240  248 245 242  243 238 233  209 203 196  177 133 103
+167 117 83  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 124 91  172 124 91  173 126 93  175 127 95
+176 129 96  177 131 99  179 134 102  181 137 105  180 137 106  179 134 102
+142 113 92  40 35 31  37 33 29  34 30 26  28 24 21  21 18 16
+14 12 10  8 7 6  4 3 3  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 1  4 3 3  8 7 6  13 11 10
+21 18 16  26 23 20  34 30 26  37 33 29  34 30 26  142 113 92
+179 134 102  181 137 105  179 134 102  179 134 102  177 131 99  174 128 96
+173 127 94  172 125 93  172 124 91  171 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  170 122 89
+167 117 83  210 188 172  253 253 252  250 247 244  247 243 239  247 243 239
+247 243 240  253 253 252  243 238 233  187 146 116  167 117 83  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 121 89  170 122 88  224 209 198  253 253 252
+250 247 244  247 243 239  247 243 239  248 245 242  253 253 252  236 226 219
+177 133 103  168 119 85  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 124 91  172 124 91  173 126 93
+174 127 94  176 129 96  177 131 99  179 134 102  181 137 105  181 137 105
+179 134 102  118 101 76  31 27 23  37 33 29  31 27 23  24 21 18
+18 16 13  11 10 8  7 6 5  3 3 2  1 1 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 2 2  6 5 4  11 10 8  16 14 12
+24 21 18  31 27 23  37 33 29  28 24 21  118 101 76  177 132 101
+181 137 105  179 134 102  177 132 101  177 131 99  176 129 96  174 127 94
+172 125 92  172 124 91  171 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  167 117 83
+195 162 138  251 249 248  247 243 240  246 242 238  246 242 238  246 242 238
+246 242 238  246 242 238  251 249 248  236 226 219  173 126 93  170 121 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  166 116 81  210 188 172  253 253 252  247 243 239
+246 242 238  246 242 238  246 242 238  246 242 238  246 242 238  253 253 252
+224 209 198  168 119 85  170 122 89  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  172 125 92
+173 125 92  174 127 94  176 129 96  177 131 99  177 133 103  181 137 105
+181 137 105  177 132 101  73 64 56  29 25 22  37 33 29  29 25 22
+23 20 17  16 14 12  10 9 8  5 4 4  2 2 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 1  4 3 3  8 7 6  14 12 10  21 18 16
+26 23 20  34 30 26  31 27 23  57 50 44  172 131 98  179 134 102
+181 137 105  179 134 102  177 132 101  174 128 96  174 127 94  173 126 93
+172 124 91  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  168 119 85
+224 209 198  251 249 248  246 242 238  246 242 238  246 242 238  246 242 238
+246 242 238  246 242 238  246 242 238  251 249 248  195 162 138  167 117 83
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  170 122 88  173 127 94  236 226 219  250 247 244  246 242 238
+246 242 238  246 242 238  246 242 238  246 242 238  246 242 238  247 243 240
+247 243 239  187 146 116  168 119 85  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 124 91
+172 124 91  173 126 93  174 127 94  176 130 98  177 132 101  179 134 102
+181 137 105  179 134 102  158 123 96  43 37 32  34 30 26  31 27 23
+26 23 20  18 16 13  13 11 10  8 7 6  3 3 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 2 2  6 5 4  10 9 8  16 14 12  23 20 17
+31 27 23  34 30 26  31 27 23  142 113 92  177 132 101  181 137 105
+179 134 102  177 132 101  176 130 98  175 127 95  173 126 93  172 125 92
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 121 89  173 127 94
+236 226 219  248 245 242  246 242 238  246 242 238  246 242 238  246 242 238
+246 242 238  246 242 238  246 242 238  250 247 244  210 188 172  166 116 81
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  168 119 85  178 138 109  243 238 233  247 243 240  246 242 238
+246 242 238  246 242 238  246 242 238  246 242 238  246 242 238  247 243 239
+250 247 244  195 162 138  166 116 81  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 125 92  173 127 94  174 128 95  176 130 98  177 132 101
+179 134 102  181 137 105  177 131 99  118 101 76  26 23 20  34 30 26
+28 24 21  21 18 16  16 14 12  9 8 7  6 5 4  2 2 2
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 1 1  4 3 3  8 7 6  14 12 10  21 18 16  26 23 20
+31 27 23  24 21 18  94 81 64  177 132 101  179 134 102  179 134 102
+177 132 101  176 130 98  174 128 95  173 126 93  172 125 92  172 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  166 119 87
+209 203 196  245 241 237  247 243 239  246 242 238  246 242 238  246 242 238
+246 242 238  246 242 238  247 243 239  238 234 230  195 162 138  164 114 81
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  169 121 86  172 131 98  226 222 217  246 242 238  247 243 239
+246 242 238  246 242 238  246 242 238  246 242 238  246 242 238  247 243 239
+236 226 219  173 140 120  167 117 83  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  173 125 92  173 126 93  174 128 95  176 130 98
+177 132 101  179 134 102  179 134 102  172 131 98  73 64 56  26 23 20
+31 27 23  24 21 18  21 18 16  13 11 10  7 6 5  4 3 3
+1 1 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+2 2 2  6 5 4  10 9 8  16 14 12  23 20 17  28 24 21
+29 25 22  43 37 32  158 123 96  177 132 101  179 134 102  177 132 101
+176 130 98  174 128 96  173 126 93  172 125 92  172 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  172 124 91  162 112 77
+174 158 143  238 234 230  247 243 240  246 242 238  246 242 238  246 242 238
+246 242 238  247 243 239  245 241 237  224 209 198  166 134 109  168 118 83
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 123 89  158 114 83  192 182 171  238 234 230  247 243 240
+246 242 238  246 242 238  246 242 238  246 242 238  247 243 239  243 238 233
+209 203 196  158 123 96  169 121 86  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 124 91  172 125 92  173 127 94  174 128 96
+177 131 99  177 132 101  179 134 102  177 132 101  142 113 92  31 27 23
+31 27 23  26 23 20  21 18 16  14 13 11  9 8 7  5 4 4
+2 2 2  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
+4 3 3  8 7 6  13 11 10  18 16 13  24 21 18  31 27 23
+21 18 16  118 101 76  176 130 98  179 134 102  177 132 101  177 131 99
+176 129 96  175 127 95  172 125 93  172 124 91  171 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  172 124 91  167 117 83
+158 123 96  209 203 196  243 238 233  247 243 240  247 243 239  247 243 239
+247 243 240  247 243 239  236 226 219  192 182 171  157 113 79  172 123 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  164 114 81  173 140 120  226 222 217  245 241 237
+247 243 240  247 243 239  247 243 239  247 243 240  246 242 238  226 222 217
+174 158 143  157 113 79  172 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 124 91  172 124 91  173 126 93  174 128 95
+176 130 98  177 131 99  177 132 101  179 134 102  177 131 99  94 81 64
+21 18 16  29 25 22  23 20 17  18 16 13  11 10 8  7 6 5
+3 3 2  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  2 2 2
+6 5 4  9 8 7  14 13 11  21 18 16  26 23 20  24 21 18
+47 41 35  163 127 97  177 132 101  177 132 101  177 131 99  176 129 96
+175 128 95  173 126 93  172 125 92  171 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 124 91
+155 109 77  173 140 120  209 203 196  238 234 230  245 241 237  245 241 237
+243 238 233  226 222 217  192 182 171  155 115 87  167 117 83  172 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 123 89  155 109 77  174 158 143  226 222 217
+238 234 230  245 241 237  245 241 237  243 238 233  226 222 217  192 182 171
+155 115 87  169 121 86  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 124 91  172 125 92  173 127 94
+174 128 96  176 130 98  177 132 101  179 134 102  177 131 99  158 123 96
+31 27 23  28 24 21  24 21 18  21 18 16  14 12 10  8 7 6
+5 4 4  1 1 1  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  3 3 2
+7 6 5  11 10 8  16 14 12  23 20 17  28 24 21  18 16 13
+118 101 76  176 129 96  177 132 101  177 132 101  176 130 98  174 128 95
+174 127 94  172 125 92  172 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 123 89  155 109 77  166 134 109  192 182 171  209 203 196  209 203 196
+210 188 172  174 158 143  155 115 87  166 116 81  172 124 92  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 124 91  170 122 88  155 109 77  173 140 120
+192 182 171  209 203 196  209 203 196  192 182 171  174 158 143  157 113 79
+168 119 85  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  172 124 91  173 125 92
+174 127 94  174 128 96  176 130 98  177 132 101  179 134 102  176 129 96
+94 81 64  18 16 13  28 24 21  23 20 17  16 14 12  10 9 8
+7 6 5  2 2 2  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  5 4 4
+8 7 6  14 12 10  21 18 16  24 21 18  23 20 17  43 37 32
+163 127 97  177 131 99  177 132 101  177 131 99  176 129 96  173 127 94
+173 126 93  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  164 114 81  157 113 79  161 118 91  158 123 96
+155 115 87  155 109 77  168 119 85  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 124 91  172 123 89  162 112 77
+158 114 83  158 123 96  158 123 96  155 115 87  162 112 77  169 121 86
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  172 124 91
+173 126 93  175 127 95  176 129 96  177 131 99  177 132 101  176 130 98
+155 115 87  26 23 20  24 21 18  23 20 17  18 16 13  11 10 8
+8 7 6  3 3 2  1 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 2 2  6 5 4
+9 8 7  14 12 10  21 18 16  24 21 18  14 13 11  94 81 64
+176 129 96  177 132 101  177 131 99  176 130 98  174 128 95  173 126 93
+173 125 92  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 124 91  172 123 89  169 121 86  168 119 85
+170 121 89  173 124 92  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  173 124 92
+172 123 89  169 121 86  168 119 85  170 122 88  173 124 92  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 124 91
+172 125 93  173 127 94  174 128 96  176 130 98  177 131 99  177 132 101
+176 129 96  73 64 56  16 14 12  24 21 18  18 16 13  13 11 10
+8 7 6  5 4 4  2 2 2  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  4 3 3  7 6 5
+11 10 8  16 14 12  21 18 16  23 20 17  31 27 23  158 123 96
+176 130 98  177 131 99  176 130 98  174 128 96  174 127 94  173 125 92
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 124 91
+172 125 92  173 125 92  174 127 94  176 129 96  176 130 98  177 131 99
+174 128 96  143 108 80  18 16 13  23 20 17  21 18 16  16 14 12
+10 9 8  6 5 4  2 2 2  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  4 3 3  8 7 6
+13 11 10  16 14 12  21 18 16  13 11 10  73 64 56  174 128 96
+177 131 99  176 130 98  176 129 96  174 128 95  173 126 93  172 124 91
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  172 125 92  173 126 93  174 128 95  176 129 96  176 130 98
+177 131 99  172 128 95  53 47 40  16 14 12  21 18 16  16 14 12
+11 10 8  8 7 6  4 3 3  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 2 2  5 4 4  8 7 6
+13 11 10  16 14 12  21 18 16  14 13 11  143 108 80  174 128 95
+177 131 99  176 129 96  175 127 95  174 127 94  172 125 93  172 124 91
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 124 91  173 126 93  175 127 95  175 129 95  176 130 98
+177 131 99  174 127 94  118 101 76  9 8 7  21 18 16  16 14 12
+11 10 8  8 7 6  5 4 4  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  3 3 2  6 5 4  10 9 8
+14 12 10  18 16 13  14 13 11  43 37 32  163 127 97  176 129 96
+176 130 98  174 128 96  174 127 94  173 126 93  172 125 92  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 124 91  172 125 92  173 127 94  175 127 95  176 129 96
+176 130 98  174 128 96  155 115 87  24 21 18  16 14 13  16 14 12
+13 11 10  9 8 7  6 5 4  2 2 2  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 1  3 3 2  8 7 6  10 9 8
+14 12 10  18 16 13  6 5 4  94 81 64  172 125 93  176 130 98
+176 129 96  174 128 95  173 126 93  172 125 93  172 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 124 91  173 126 93  174 127 94  174 128 95
+176 129 96  176 130 98  173 127 94  57 50 44  9 8 7  16 14 12
+14 12 10  9 8 7  7 6 5  3 3 2  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 1  4 3 3  8 7 6  11 10 8
+14 12 10  16 14 12  8 7 6  143 108 80  173 126 93  176 130 98
+174 128 95  175 127 95  173 126 93  172 125 92  171 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 124 91  173 125 92  173 126 93  174 127 94
+174 128 96  176 130 98  172 125 93  118 101 76  4 3 3  18 16 13
+14 12 10  10 9 8  8 7 6  4 3 3  1 1 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 2 2  5 4 4  8 7 6  11 10 8
+14 12 10  10 9 8  31 27 23  161 118 91  175 127 95  176 129 96
+174 128 95  173 127 94  172 125 93  172 125 92  171 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 124 91  172 125 92  173 126 93  174 127 94
+174 128 95  176 129 96  173 126 93  142 113 92  14 12 10  14 12 10
+14 12 10  10 9 8  8 7 6  4 3 3  1 1 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 2 2  5 4 4  8 7 6  10 9 8
+14 12 10  4 3 3  73 64 56  172 125 92  174 128 96  174 128 95
+174 127 94  173 126 93  172 125 92  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 124 91  172 125 92  173 126 93
+174 127 94  174 128 96  175 127 95  169 122 89  41 36 31  7 6 5
+13 11 10  10 9 8  8 7 6  4 3 3  2 2 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  3 3 2  5 4 4  8 7 6  10 9 8
+13 11 10  0 0 0  94 81 64  171 123 90  174 128 95  175 127 95
+173 127 94  173 125 92  172 125 92  171 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 124 91  172 124 92  172 125 93
+173 127 94  175 127 95  174 128 96  172 124 91  73 64 56  1 1 1
+11 10 8  9 8 7  8 7 6  5 4 4  2 2 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  3 3 2  6 5 4  8 7 6  10 9 8
+11 10 8  7 6 5  143 108 80  171 124 91  174 128 95  174 127 94
+173 126 93  173 125 92  172 124 91  171 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 124 91  172 124 91  173 125 92
+173 126 93  174 127 94  174 128 95  171 123 90  118 101 76  0 0 0
+11 10 8  9 8 7  8 7 6  5 4 4  2 2 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  3 3 2  6 5 4  8 7 6  9 8 7
+7 6 5  24 21 18  161 118 91  172 125 93  174 127 94  173 127 94
+172 125 93  172 125 92  171 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  168 118 83  164 114 81  166 116 81  168 118 83  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  170 121 89  170 122 89  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  172 124 91  172 125 92
+173 126 93  173 127 94  174 127 94  172 124 91  143 108 80  7 6 5
+10 9 8  8 7 6  7 6 5  5 4 4  3 3 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 1  3 3 2  5 4 4  7 6 5  8 7 6
+0 0 0  49 43 38  169 122 89  173 126 93  173 126 93  173 126 93
+173 125 92  172 124 91  171 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+167 117 83  187 146 116  210 188 172  210 188 172  183 141 112  166 116 81
+172 123 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  169 121 86  168 118 83  172 124 92  168 119 85  168 119 85
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  172 125 92
+173 125 92  173 126 93  173 126 93  172 125 93  161 118 91  24 21 18
+5 4 4  8 7 6  6 5 4  5 4 4  3 3 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 1  3 3 2  5 4 4  6 5 4  8 7 6
+0 0 0  73 64 56  170 122 89  173 126 93  172 125 93  173 125 92
+172 125 92  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  168 118 83
+187 146 116  245 241 237  253 253 252  253 253 252  243 238 233  195 162 138
+164 114 81  169 121 86  171 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+166 116 81  176 130 98  209 203 196  236 226 219  224 209 198  180 137 106
+168 119 85  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 124 91
+172 125 92  172 125 93  172 125 93  172 125 93  167 121 88  47 41 35
+0 0 0  7 6 5  6 5 4  5 4 4  3 3 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 1  3 3 2  5 4 4  5 4 4  7 6 5
+0 0 0  94 81 64  170 121 89  173 126 93  173 125 92  173 125 92
+172 125 92  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  166 116 81
+210 188 172  253 253 252  246 242 238  245 241 237  250 247 244  248 245 242
+210 188 172  173 126 93  166 116 81  170 121 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  169 121 86  164 114 81
+183 141 112  236 226 219  253 253 252  250 247 244  253 253 252  226 222 217
+171 123 90  170 121 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 124 91
+172 125 92  173 125 92  172 125 93  172 125 93  172 123 89  73 64 56
+0 0 0  7 6 5  5 4 4  4 3 3  2 2 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 1  2 2 2  4 3 3  4 3 3  4 3 3
+0 0 0  118 101 76  170 121 89  173 125 92  172 125 92  172 125 92
+172 124 91  171 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  172 124 91  164 114 81
+174 158 143  236 226 219  246 242 238  247 243 239  246 242 238  247 243 240
+251 249 248  236 226 219  195 162 138  168 119 85  166 116 81  170 122 88
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  169 121 86  164 114 81  172 124 91  210 188 172
+243 238 233  251 249 248  246 242 238  246 242 238  247 243 240  238 234 230
+177 133 103  168 119 85  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 124 91
+172 124 91  172 125 92  172 125 92  173 125 92  170 121 89  94 81 64
+0 0 0  5 4 4  4 3 3  4 3 3  2 2 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 1  2 2 2  3 3 2  3 3 2  2 2 2
+4 3 2  118 101 76  170 122 89  172 125 92  172 124 91  172 124 91
+172 124 91  171 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  170 121 89
+158 114 83  192 182 171  226 222 217  245 241 237  247 243 239  246 242 238
+246 242 238  250 247 244  251 249 248  224 209 198  195 162 138  170 122 89
+166 116 81  168 119 85  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+168 118 83  166 116 81  172 125 93  195 162 138  236 226 219  251 249 248
+248 245 242  246 242 238  246 242 238  247 243 239  238 234 230  192 182 171
+163 116 84  170 122 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 124 91
+172 124 91  172 124 91  172 125 92  172 125 92  169 121 86  94 81 64
+0 0 0  3 3 2  3 3 2  3 3 2  2 2 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 2 2  2 2 2  3 3 2  0 0 0
+8 7 6  140 107 74  170 122 89  172 124 91  172 124 91  172 124 91
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 124 91
+167 117 83  155 115 87  174 158 143  226 222 217  243 238 233  247 243 239
+247 243 239  246 242 238  246 242 238  250 247 244  250 247 244  226 222 217
+195 162 138  177 133 103  166 116 81  166 116 81  168 119 85  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  171 123 90  170 121 89  168 118 83  166 116 81  167 117 83
+182 139 108  210 188 172  236 226 219  250 247 244  250 247 244  246 242 238
+246 242 238  247 243 240  246 242 238  238 234 230  209 203 196  158 123 96
+164 116 83  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 124 91
+172 124 91  172 124 91  172 124 91  172 125 92  169 121 86  118 101 76
+0 0 0  1 1 1  3 3 2  2 2 2  1 1 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 1  1 1 1  2 2 2  0 0 0
+11 10 8  143 108 80  170 122 89  172 124 91  172 124 91  171 124 91
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  168 119 85  155 109 77  173 140 120  209 203 196  236 226 219
+245 241 237  247 243 239  247 243 239  246 242 238  246 242 238  250 247 244
+251 249 248  238 234 230  224 209 198  195 162 138  177 133 103  168 119 85
+164 114 81  166 116 81  168 119 85  170 121 89  170 122 89  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  170 121 89  169 121 86  168 118 83
+166 116 81  166 116 81  172 123 89  183 141 112  195 162 138  224 209 198
+243 238 233  251 249 248  250 247 244  246 242 238  246 242 238  247 243 239
+247 243 240  243 238 233  226 222 217  192 182 171  158 123 96  162 112 77
+173 124 92  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 124 91  172 124 91  172 124 91  169 121 86  118 101 76
+1 1 1  0 0 0  2 2 2  1 1 1  1 1 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  1 1 1  0 0 0
+14 13 11  158 114 83  170 122 89  171 124 91  171 124 91  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  172 123 89  158 109 74  155 115 87  174 158 143
+209 203 196  238 234 230  245 241 237  247 243 240  247 243 239  246 242 238
+246 242 238  248 245 242  251 249 248  251 249 248  243 238 233  224 209 198
+210 188 172  195 162 138  180 137 106  171 124 91  168 118 83  166 116 81
+166 116 81  166 116 81  167 117 83  168 119 85  169 121 86  169 121 86
+169 121 86  170 121 89  170 121 89  170 121 89  170 121 89  169 121 86
+169 121 86  169 121 86  168 119 85  168 118 83  167 117 83  166 116 81
+166 116 81  166 116 81  168 118 83  170 122 88  177 131 99  187 146 116
+195 162 138  210 188 172  226 222 217  246 242 238  251 249 248  251 249 248
+247 243 240  246 242 238  246 242 238  247 243 239  247 243 239  243 238 233
+236 226 219  209 203 196  174 158 143  155 109 77  166 116 81  173 124 92
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 124 91  171 124 91  171 124 91  169 121 88  140 107 74
+5 4 4  0 0 0  1 1 1  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 1 1  2 1 1  3 3 2  6 5 4  7 6 5  8 7 6
+9 8 7  9 8 7  9 8 7  9 8 7  9 8 7  7 6 5
+7 6 5  5 4 4  4 3 3  2 2 2  2 2 2  0 0 0
+11 7 4  152 106 74  172 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  173 124 92  167 117 83  155 109 77
+166 134 109  192 182 171  224 209 198  238 234 230  243 238 233  247 243 239
+247 243 239  247 243 239  246 242 238  246 242 238  248 245 242  250 247 244
+251 249 248  250 247 244  243 238 233  236 226 219  224 209 198  210 188 172
+195 162 138  195 162 138  187 146 116  183 141 112  177 133 103  177 131 99
+176 129 96  173 127 96  173 127 94  173 127 94  173 127 94  176 129 96
+176 130 98  177 133 103  180 137 106  183 141 112  187 146 116  195 162 138
+195 162 138  210 188 172  224 209 198  226 222 217  238 234 230  247 243 240
+251 249 248  251 249 248  250 247 244  247 243 240  246 242 238  246 242 238
+247 243 239  247 243 240  246 242 238  243 238 233  236 226 219  209 203 196
+174 158 143  158 123 96  158 109 74  170 122 88  172 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  173 124 92  126 83 55
+7 6 5  0 0 0  2 2 2  2 2 2  4 3 3  5 4 4
+6 5 4  7 6 5  8 7 6  8 7 6  8 7 6  8 7 6
+8 7 6  6 5 4  5 4 4  4 3 3  2 1 1  1 1 1
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  3 3 2  5 4 4
+7 6 5  9 8 7  13 11 10  16 14 12  18 16 13  18 16 13
+21 18 16  23 20 17  23 20 17  21 18 16  21 18 16  18 16 13
+18 16 13  14 13 11  11 10 8  8 7 6  6 5 4  0 0 0
+23 20 17  158 114 83  170 122 89  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  172 124 91  173 124 92
+164 114 81  155 109 77  166 134 109  174 158 143  209 203 196  226 222 217
+238 234 230  246 242 238  247 243 239  247 243 240  247 243 239  246 242 238
+246 242 238  246 242 238  247 243 240  250 247 244  251 249 248  251 249 248
+251 249 248  250 247 244  247 243 239  243 238 233  238 234 230  238 234 230
+236 226 219  236 226 219  236 226 219  236 226 219  236 226 219  236 226 219
+236 226 219  238 234 230  243 238 233  245 241 237  247 243 240  250 247 244
+251 249 248  251 249 248  251 249 248  250 247 244  248 245 242  247 243 239
+246 242 238  246 242 238  246 242 238  247 243 239  247 243 240  247 243 239
+245 241 237  238 234 230  226 222 217  209 203 196  174 158 143  158 123 96
+155 109 77  167 117 83  173 124 92  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  169 121 86  143 108 80
+9 8 7  0 0 0  7 6 5  8 7 6  11 10 8  14 13 11
+18 16 13  18 16 13  21 18 16  21 18 16  21 18 16  21 18 16
+21 18 16  18 16 13  16 14 12  13 11 10  10 9 8  8 7 6
+6 5 4  3 3 2  1 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 1  3 3 2  6 5 4  8 7 6  11 10 8
+16 14 12  21 18 16  24 21 18  28 24 21  31 27 23  31 27 23
+34 30 26  34 30 26  34 30 26  34 30 26  34 30 26  31 27 23
+29 25 22  26 23 20  23 20 17  18 16 13  14 12 10  3 3 2
+26 23 20  158 114 83  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  172 123 89  164 114 81  155 109 77  158 123 96  174 158 143
+192 182 171  224 209 198  236 226 219  238 234 230  245 241 237  247 243 239
+247 243 239  247 243 239  247 243 239  246 242 238  246 242 238  246 242 238
+246 242 238  247 243 239  247 243 240  247 243 240  248 245 242  248 245 242
+248 245 242  250 247 244  250 247 244  250 247 244  250 247 244  248 245 242
+248 245 242  248 245 242  247 243 240  247 243 240  247 243 239  247 243 239
+246 242 238  246 242 238  246 242 238  247 243 239  247 243 239  247 243 239
+247 243 240  247 243 240  246 242 238  243 238 233  238 234 230  226 222 217
+209 203 196  192 182 171  173 140 120  155 115 87  155 109 77  166 116 81
+172 124 91  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  169 121 86  143 108 80
+11 10 8  7 6 5  14 12 10  18 16 13  23 20 17  26 23 20
+28 24 21  31 27 23  34 30 26  34 30 26  34 30 26  34 30 26
+31 27 23  31 27 23  28 24 21  24 21 18  21 18 16  16 14 12
+13 11 10  9 8 7  7 6 5  4 3 3  2 2 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
+3 3 2  5 4 4  8 7 6  11 10 8  16 14 12  21 18 16
+26 23 20  31 27 23  34 30 26  37 33 29  43 37 32  43 37 32
+47 41 35  47 41 35  47 41 35  47 41 35  47 41 35  43 37 32
+40 35 31  37 33 29  34 30 26  28 24 21  23 20 17  10 9 8
+31 27 23  164 117 85  172 124 91  172 124 91  171 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 124 91  172 124 91  168 118 83  158 109 74
+157 113 79  158 123 96  174 158 143  192 182 171  209 203 196  226 222 217
+236 226 219  238 234 230  243 238 233  245 241 237  246 242 238  247 243 239
+247 243 240  247 243 240  247 243 240  247 243 239  247 243 239  247 243 239
+247 243 239  247 243 239  247 243 239  247 243 239  247 243 239  247 243 239
+247 243 239  247 243 239  247 243 239  247 243 240  247 243 240  247 243 240
+247 243 240  247 243 239  246 242 238  245 241 237  243 238 233  238 234 230
+238 234 230  226 222 217  224 209 198  209 203 196  192 182 171  173 140 120
+158 123 96  155 109 77  162 112 77  169 121 86  173 124 92  172 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 124 91  171 124 91  172 124 91  170 122 89  143 108 80
+14 13 11  14 13 11  24 21 18  28 24 21  34 30 26  37 33 29
+40 35 31  43 37 32  43 37 32  47 41 35  47 41 35  47 41 35
+43 37 32  41 36 31  37 33 29  34 30 26  31 27 23  28 24 21
+23 20 17  18 16 13  13 11 10  9 8 7  6 5 4  3 3 2
+2 2 2  1 1 1  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  4 3 3
+7 6 5  9 8 7  14 13 11  21 18 16  26 23 20  31 27 23
+37 33 29  41 36 31  47 41 35  49 43 38  53 47 40  53 47 40
+57 50 44  57 50 44  57 50 44  57 50 44  57 50 44  53 47 40
+49 43 38  49 43 38  43 37 32  37 33 29  31 27 23  18 16 13
+37 33 29  166 119 87  173 125 92  173 125 92  172 124 91  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  173 124 92
+172 123 89  167 117 83  157 113 79  157 113 79  158 123 96  173 140 120
+174 158 143  192 182 171  209 203 196  209 203 196  226 222 217  226 222 217
+236 226 219  238 234 230  238 234 230  243 238 233  243 238 233  243 238 233
+245 241 237  245 241 237  245 241 237  245 241 237  245 241 237  245 241 237
+245 241 237  243 238 233  243 238 233  243 238 233  238 234 230  238 234 230
+236 226 219  226 222 217  226 222 217  224 209 198  209 203 196  192 182 171
+174 158 143  173 140 120  166 134 109  155 115 87  155 109 77  162 112 77
+168 118 83  172 123 89  173 124 92  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 124 91  172 124 91  172 125 92  171 123 90  142 113 92
+21 18 16  24 21 18  34 30 26  37 33 29  43 37 32  47 41 35
+49 43 38  53 47 40  53 47 40  57 50 44  57 50 44  57 50 44
+53 47 40  53 47 40  49 43 38  47 41 35  43 37 32  37 33 29
+34 30 26  28 24 21  23 20 17  16 14 12  11 10 8  8 7 6
+5 4 4  2 2 2  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  4 3 3  7 6 5
+11 10 8  16 14 12  23 20 17  29 25 22  34 30 26  40 35 31
+47 41 35  53 47 40  57 50 44  57 50 44  57 50 44  57 50 44
+57 50 44  57 50 44  57 50 44  57 50 44  57 50 44  57 50 44
+57 50 44  57 50 44  53 47 40  47 41 35  41 36 31  28 24 21
+41 36 31  161 118 91  173 127 94  173 126 93  172 124 91  172 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  173 124 92  172 123 89  168 119 85  164 114 81
+157 113 79  157 113 79  155 115 87  158 123 96  166 134 109  173 140 120
+174 158 143  174 158 143  192 182 171  192 182 171  210 188 172  209 203 196
+209 203 196  209 203 196  209 203 196  209 203 196  209 203 196  209 203 196
+209 203 196  210 188 172  192 182 171  192 182 171  192 182 171  174 158 143
+174 158 143  173 140 120  166 134 109  163 127 97  155 115 87  158 114 83
+157 113 79  162 112 77  166 116 81  169 121 86  172 124 91  172 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  172 125 92  173 126 93  172 125 92  155 115 87
+28 24 21  31 27 23  43 37 32  49 43 38  53 47 40  57 50 44
+57 50 44  57 50 44  57 50 44  57 50 44  57 50 44  57 50 44
+57 50 44  57 50 44  57 50 44  57 50 44  53 47 40  49 43 38
+43 37 32  37 33 29  31 27 23  24 21 18  18 16 13  13 11 10
+8 7 6  5 4 4  2 2 2  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 2 2  5 4 4  8 7 6  11 10 8
+16 14 12  24 21 18  31 27 23  37 33 29  47 41 35  53 47 40
+57 50 44  57 50 44  57 50 44  73 64 56  73 64 56  94 81 64
+118 101 76  118 101 76  118 101 76  118 101 76  118 101 76  94 81 64
+73 64 56  57 50 44  57 50 44  57 50 44  49 43 38  37 33 29
+47 41 35  163 127 97  175 127 95  174 127 94  172 125 92  172 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  172 124 91  172 124 91
+173 124 92  172 123 89  170 122 88  168 118 83  164 114 81  162 112 77
+162 112 77  155 109 77  157 113 79  158 114 83  155 115 87  155 115 87
+155 115 87  155 115 87  155 115 87  155 115 87  155 115 87  155 115 87
+155 115 87  155 115 87  158 114 83  157 113 79  157 113 79  157 113 79
+162 112 77  162 112 77  164 114 81  167 117 83  169 121 86  172 123 89
+172 124 91  172 124 91  172 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 125 92  173 125 92  174 127 94  174 127 94  155 115 87
+34 30 26  40 35 31  53 47 40  57 50 44  57 50 44  57 50 44
+73 64 56  94 81 64  94 81 64  118 101 76  118 101 76  118 101 76
+94 81 64  73 64 56  73 64 56  57 50 44  57 50 44  57 50 44
+53 47 40  49 43 38  41 36 31  34 30 26  26 23 20  21 18 16
+14 12 10  9 8 7  6 5 4  3 3 2  1 1 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 2 2  4 3 3  7 6 5  11 10 8  18 16 13
+24 21 18  31 27 23  40 35 31  49 43 38  57 50 44  57 50 44
+57 50 44  73 64 56  118 101 76  158 123 96  178 138 109  187 146 116
+187 146 116  187 146 116  187 146 116  187 146 116  187 146 116  186 144 112
+166 134 109  142 113 92  94 81 64  57 50 44  49 43 38  43 37 32
+53 47 40  163 127 97  176 129 96  174 128 95  173 126 93  172 125 92
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 124 91  172 124 91  172 124 91
+173 124 92  172 124 91  172 123 89  172 123 89  170 122 88  170 122 88
+169 121 86  169 121 86  169 121 86  169 121 86  169 121 86  169 121 86
+170 122 88  170 122 88  172 123 89  172 123 89  172 123 89  172 124 91
+173 124 92  172 124 91  172 124 91  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  173 125 92  173 126 93  175 128 95  174 128 96  158 123 96
+43 37 32  47 41 35  49 43 38  73 64 56  118 101 76  142 113 92
+166 134 109  183 141 112  187 146 116  187 146 116  187 146 116  187 146 116
+187 146 116  178 138 109  166 134 109  142 113 92  94 81 64  57 50 44
+57 50 44  57 50 44  49 43 38  43 37 32  34 30 26  28 24 21
+21 18 16  14 13 11  9 8 7  6 5 4  3 3 2  1 1 1
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  3 3 2  6 5 4  10 9 8  16 14 12  24 21 18
+31 27 23  40 35 31  49 43 38  53 47 40  49 43 38  73 64 56
+142 113 92  178 138 109  186 144 112  186 144 112  187 146 116  187 146 116
+187 146 116  187 146 116  187 146 116  187 146 116  187 146 116  187 146 116
+186 144 112  186 144 112  183 141 112  163 127 97  94 81 64  43 37 32
+49 43 38  172 131 98  176 129 96  174 128 96  173 126 93  173 125 92
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  173 125 92  173 127 94  176 129 96  176 129 96  155 115 87
+31 27 23  53 47 40  118 101 76  166 134 109  186 144 112  186 144 112
+186 144 112  187 146 116  187 146 116  187 146 116  187 146 116  187 146 116
+187 146 116  187 146 116  186 144 112  186 144 112  183 141 112  158 123 96
+94 81 64  57 50 44  53 47 40  53 47 40  43 37 32  34 30 26
+28 24 21  21 18 16  13 11 10  8 7 6  5 4 4  2 2 2
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+2 2 2  5 4 4  9 8 7  14 13 11  23 20 17  31 27 23
+37 33 29  47 41 35  49 43 38  53 47 40  118 101 76  178 138 109
+183 141 109  186 144 112  187 146 116  186 144 112  186 144 112  183 141 112
+183 141 112  183 141 109  183 141 109  183 141 112  183 141 112  186 144 112
+186 144 112  186 144 112  186 144 112  183 141 109  181 137 105  142 113 92
+73 64 56  163 127 97  176 130 98  176 129 96  173 127 94  172 125 93
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  173 126 93  174 127 94  176 129 96  176 129 96  142 113 92
+94 81 64  163 127 97  180 137 106  183 141 109  186 144 112  186 144 112
+186 144 112  186 144 112  186 144 112  183 141 112  183 141 112  183 141 112
+186 144 112  186 144 112  186 144 112  187 146 116  186 144 112  183 141 112
+183 141 112  142 113 92  73 64 56  47 41 35  49 43 38  43 37 32
+34 30 26  26 23 20  18 16 13  11 10 8  7 6 5  4 3 3
+1 1 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
+4 3 3  8 7 6  14 12 10  21 18 16  28 24 21  37 33 29
+47 41 35  43 37 32  57 50 44  158 123 96  183 141 109  186 144 112
+186 144 112  186 144 112  183 141 109  183 141 109  183 141 109  182 139 108
+182 139 108  181 137 105  181 137 105  181 137 105  182 139 108  182 139 108
+183 141 109  183 141 109  183 141 109  183 141 109  182 139 108  179 134 102
+172 131 98  177 131 99  176 130 98  174 128 96  173 126 93  173 125 92
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  172 125 93  173 127 94  174 128 96  177 131 99  172 131 98
+177 132 101  179 134 102  182 139 108  183 141 109  183 141 109  183 141 109
+183 141 109  183 141 109  182 139 108  182 139 108  182 139 108  182 139 108
+182 139 108  183 141 109  183 141 109  183 141 109  186 144 112  186 144 112
+186 144 112  183 141 109  177 133 103  94 81 64  43 37 32  47 41 35
+40 35 31  31 27 23  24 21 18  16 14 12  10 9 8  6 5 4
+2 2 2  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  2 2 2
+6 5 4  11 10 8  18 16 13  24 21 18  31 27 23  41 36 31
+40 35 31  57 50 44  158 123 96  181 137 105  186 144 112  183 141 109
+183 141 109  182 139 108  181 137 105  181 137 105  181 137 105  179 134 102
+179 134 102  179 134 102  179 134 102  179 134 102  179 134 102  179 134 102
+181 137 105  181 137 105  181 137 105  181 137 105  181 137 105  179 134 102
+177 132 101  177 131 99  176 130 98  174 128 95  173 126 93  172 125 92
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  173 125 92  173 126 93  174 128 95  176 130 98  177 131 99
+177 132 101  181 137 105  181 137 105  181 137 105  181 137 105  181 137 105
+181 137 105  181 137 105  179 134 102  179 134 102  179 134 102  179 134 102
+179 134 102  181 137 105  181 137 105  180 137 106  182 139 108  183 141 109
+183 141 109  183 141 112  183 141 109  180 137 106  118 101 76  37 33 29
+43 37 32  37 33 29  28 24 21  21 18 16  14 12 10  8 7 6
+4 3 3  1 1 1  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  4 3 3
+8 7 6  14 12 10  21 18 16  28 24 21  37 33 29  37 33 29
+53 47 40  158 123 96  180 137 106  183 141 109  183 141 109  182 139 108
+180 137 106  181 137 105  179 134 102  177 132 101  177 131 99  177 131 99
+176 130 98  176 130 98  176 130 98  176 130 98  176 130 98  177 131 99
+177 132 101  177 132 101  179 134 102  179 134 102  177 132 101  177 132 101
+177 131 99  176 130 98  174 128 96  174 127 94  173 125 92  172 125 92
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 125 92  172 125 93  174 127 94  174 128 96  176 130 98
+177 131 99  177 132 101  179 134 102  179 134 102  179 134 102  177 132 101
+177 132 101  177 131 99  177 131 99  176 130 98  176 130 98  176 130 98
+177 131 99  177 132 101  177 132 101  179 134 102  181 137 105  181 137 105
+182 139 108  183 141 109  183 141 109  182 139 108  180 137 106  94 81 64
+34 30 26  40 35 31  31 27 23  24 21 18  16 14 12  10 9 8
+7 6 5  2 2 2  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 2 2  6 5 4
+10 9 8  16 14 12  23 20 17  31 27 23  34 30 26  37 33 29
+142 113 92  179 134 102  182 139 108  181 137 105  181 137 105  179 134 102
+177 132 101  177 131 99  176 130 98  174 128 96  175 127 95  174 127 94
+173 126 93  173 126 93  173 126 93  173 126 93  173 126 93  174 127 94
+174 128 95  174 128 96  176 129 96  176 130 98  176 130 98  176 129 96
+176 129 96  175 128 95  174 127 94  173 126 93  172 125 92  172 124 91
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 124 91  172 125 92  173 126 93  174 127 94  175 128 95
+176 129 96  176 129 96  176 130 98  176 130 98  176 129 96  174 128 96
+174 128 95  175 127 95  173 127 94  173 126 93  173 126 93  173 126 93
+174 127 94  174 128 95  174 128 96  176 130 98  177 131 99  177 132 101
+179 134 102  181 137 105  181 137 105  182 139 108  182 139 108  177 133 103
+73 64 56  31 27 23  34 30 26  28 24 21  21 18 16  14 12 10
+8 7 6  4 3 3  1 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  3 3 2  8 7 6
+11 10 8  18 16 13  26 23 20  31 27 23  26 23 20  118 101 76
+179 134 102  181 137 105  181 137 105  179 134 102  179 134 102  177 132 101
+176 130 98  174 128 95  173 127 94  172 125 92  172 124 91  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 124 91
+172 124 91  172 125 92  173 126 93  173 127 94  173 127 94  173 127 94
+173 127 94  173 126 93  173 125 92  173 125 92  172 124 91  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  172 125 92  173 125 92  173 125 92  173 126 93
+173 127 94  173 127 94  173 127 94  173 127 94  173 126 93  172 125 92
+172 124 91  171 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 124 91  172 125 92  173 126 93  174 128 95  176 129 96
+177 131 99  177 132 101  181 137 105  181 137 105  181 137 105  179 134 102
+163 127 97  47 41 35  31 27 23  29 25 22  23 20 17  16 14 12
+9 8 7  5 4 4  1 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  4 3 3  8 7 6
+13 11 10  21 18 16  26 23 20  24 21 18  53 47 40  172 131 98
+179 134 102  181 137 105  179 134 102  177 132 101  177 131 99  176 129 96
+174 127 94  172 125 93  172 125 92  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  172 124 91  172 124 91  172 125 92  172 125 92  173 125 92
+172 125 92  172 125 92  172 125 92  172 124 91  171 124 91  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 90  172 123 91  176 124 92  176 124 92
+176 124 92  172 123 91  170 121 89  170 122 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 124 91  172 124 91  172 124 91  172 125 92  172 125 92
+172 125 92  172 125 92  172 125 92  172 125 92  172 124 91  172 124 91
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 124 91  172 125 92  172 125 93  173 126 93
+175 128 95  176 130 98  177 132 101  179 134 102  179 134 102  181 137 105
+177 131 99  118 101 76  23 20 17  29 25 22  23 20 17  16 14 12
+11 10 8  7 6 5  2 2 2  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  5 4 4  8 7 6
+14 12 10  21 18 16  26 23 20  18 16 13  118 101 76  176 130 98
+179 134 102  179 134 102  177 132 101  176 130 98  176 129 96  174 127 94
+172 125 92  172 124 91  171 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 123 91  178 132 97  175 148 97  156 152 79  156 152 79
+156 152 79  175 148 97  175 148 97  176 128 96  172 123 91  170 122 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 90  170 122 90
+170 121 89  170 122 90  170 122 90  172 123 89  170 122 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  172 124 91  172 125 92
+173 126 93  174 128 95  176 130 98  177 131 99  177 132 101  179 134 102
+179 134 102  173 127 96  53 47 40  21 18 16  23 20 17  18 16 13
+11 10 8  8 7 6  4 3 3  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 2 2  6 5 4  9 8 7
+14 12 10  18 16 13  16 14 13  47 41 35  163 127 97  177 131 99
+177 132 101  177 131 99  176 130 98  174 128 95  173 127 94  172 125 92
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+173 124 92  175 148 97  156 152 79  136 174 66  136 174 66  136 174 66
+136 174 66  136 174 66  136 174 66  156 152 79  175 148 97  176 129 96
+172 123 91  170 122 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  170 124 90  170 122 90  172 123 91  175 127 95  177 134 98
+175 148 97  175 148 97  175 148 97  175 148 97  176 129 96  172 123 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 124 91
+172 124 91  172 125 93  175 127 95  176 129 96  176 130 98  177 132 101
+177 132 101  174 128 96  118 101 76  13 11 10  23 20 17  16 14 12
+11 10 8  8 7 6  4 3 3  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 2 2  6 5 4  9 8 7
+13 11 10  16 14 12  8 7 6  94 81 64  174 127 94  177 131 99
+177 131 99  176 130 98  174 128 96  174 127 94  173 126 93  172 124 91
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 123 91
+177 134 98  136 174 66  136 174 66  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  130 169 62  136 174 66  136 174 66  156 152 79
+175 148 97  176 124 92  170 122 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  170 122 89  170 122 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 121 89  173 124 92  178 132 97  175 148 97  156 152 79  136 174 66
+136 174 66  136 174 66  136 174 66  136 174 66  156 152 79  175 148 97
+172 123 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 124 91  172 124 91  173 127 94  175 127 95  176 129 96  176 130 98
+177 131 99  176 130 98  161 118 91  31 27 23  14 13 11  16 14 12
+11 10 8  8 7 6  5 4 4  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 2 2  6 5 4  8 7 6
+11 10 8  13 11 10  11 10 8  143 108 80  173 127 94  176 130 98
+174 128 96  174 128 95  174 127 94  173 125 92  172 125 92  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 90  174 127 94
+156 152 79  136 174 66  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  136 174 66
+136 174 66  175 148 97  176 128 96  170 121 89  171 123 90  170 122 90
+170 122 90  173 124 92  176 124 92  175 127 95  173 124 92  170 121 89
+170 122 90  171 123 90  171 123 90  171 123 90  170 122 90  172 123 91
+178 132 97  175 148 97  156 152 79  136 174 66  136 174 66  136 174 66
+131 167 63  131 167 63  131 167 63  131 167 63  136 174 66  136 174 66
+175 129 95  172 123 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  173 125 92  173 126 93  175 127 95  174 128 96
+176 129 96  176 130 98  172 125 93  73 64 56  5 4 4  14 12 10
+10 9 8  8 7 6  5 4 4  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 2 2  5 4 4  8 7 6
+9 8 7  6 5 4  28 24 21  161 118 91  174 127 94  174 128 95
+175 127 95  173 127 94  172 125 93  172 125 92  171 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  172 123 91  172 128 95
+136 174 66  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+130 169 62  136 174 66  156 152 79  178 132 97  170 122 90  173 124 92
+175 148 97  175 148 97  156 152 79  156 152 79  175 148 97  175 148 97
+176 124 92  170 122 90  170 122 89  170 122 90  176 129 96  175 148 97
+136 174 66  136 174 66  136 174 66  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  136 174 66
+156 152 79  173 124 92  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 124 91  172 125 92  173 126 93  174 127 94
+174 128 95  174 128 96  172 123 91  94 81 64  0 0 0  10 9 8
+8 7 6  7 6 5  4 3 3  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 2 2  4 3 3  7 6 5
+8 7 6  0 0 0  49 43 38  171 124 91  174 127 94  173 126 93
+173 126 93  173 125 92  172 125 92  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  172 123 91  156 152 79
+130 169 62  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  130 169 62  136 174 66  156 152 79  175 148 97  175 148 97
+136 174 66  136 174 66  136 174 66  136 174 66  136 174 66  136 174 66
+175 148 97  176 128 96  176 124 92  175 148 97  156 152 79  136 174 66
+136 174 66  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  130 169 62
+136 174 66  170 124 90  172 123 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 124 91  172 125 92  173 126 93
+173 126 93  173 127 94  172 124 91  118 101 76  4 3 3  7 6 5
+7 6 5  5 4 4  3 3 2  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  3 3 2  4 3 3
+6 5 4  0 0 0  69 49 38  172 124 91  173 126 93  172 125 93
+173 125 92  172 125 92  172 124 91  171 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  172 123 89  128 161 62
+130 169 62  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  136 174 66  136 174 66  136 174 66
+136 174 66  131 167 63  131 167 63  131 167 63  131 167 63  130 169 62
+136 174 66  156 152 79  175 148 97  136 174 66  136 174 66  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+130 169 62  170 124 90  172 123 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 124 91  172 125 92  173 125 92
+172 125 93  173 126 93  171 123 90  143 108 80  10 9 8  3 3 2
+5 4 4  4 3 3  3 3 2  1 1 1  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 1  2 2 2  3 3 2
+3 3 2  0 0 0  73 64 56  171 124 91  172 125 92  172 125 92
+172 124 91  172 124 91  171 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 123 91  167 121 88  128 161 62
+130 169 62  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  130 169 62  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  136 174 66  136 174 66  136 174 66  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+130 169 62  156 152 79  172 123 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 124 91  172 124 91  172 124 91
+172 125 92  172 125 92  170 122 89  155 115 87  14 12 10  0 0 0
+3 3 2  2 2 2  1 1 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
+1 1 1  0 0 0  74 57 39  171 123 90  171 124 91  171 124 91
+171 124 91  171 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 123 91  160 118 82  128 161 62
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+130 169 62  122 138 58  170 121 89  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  171 124 91
+171 124 91  171 124 91  170 122 88  155 115 87  11 10 8  0 0 0
+1 1 1  1 1 1  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  58 40 23  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 123 91  160 118 82  128 161 62
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+128 161 62  122 138 58  170 121 89  172 123 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 124 91  142 97 68  5 4 3  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  58 40 23  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 123 91  160 118 82  122 138 58
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+128 161 62  122 138 58  170 121 89  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  173 124 92  142 97 68  5 3 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 124 90  170 122 89  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  173 124 92  157 113 79  122 138 58
+128 161 62  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+128 161 62  122 138 58  170 121 89  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  170 122 89  172 124 91  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 90  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  173 124 92  158 114 83  122 138 58
+128 161 62  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+128 161 62  122 138 58  170 121 89  172 123 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  170 122 89  172 124 91  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 90  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  173 124 92  164 117 85  122 138 58
+128 161 62  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  128 161 62  128 161 62  128 161 62
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  128 161 62  128 161 62  128 161 62  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+128 161 62  139 108 70  170 121 89  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 124 91  170 121 89  120 103 56
+122 138 58  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  128 161 62  122 138 58  122 138 58  128 161 62
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+128 161 62  122 138 58  120 103 56  122 138 58  128 161 62  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+128 161 62  139 108 70  172 123 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  173 124 92  139 108 70
+122 138 58  128 161 62  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  128 161 62  122 138 58  140 107 74  140 107 74  122 138 58
+128 161 62  128 161 62  131 167 63  131 167 63  128 161 62  128 161 62
+122 138 58  139 108 70  155 109 77  122 138 58  122 138 58  128 161 62
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+122 138 58  139 108 70  172 123 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  173 124 92  163 116 84
+122 138 58  128 161 62  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  128 161 62
+122 138 58  122 138 58  139 108 70  172 123 91  172 123 91  139 108 70
+122 138 58  122 138 58  122 138 58  122 138 58  122 138 58  122 138 58
+139 108 70  172 123 91  176 124 92  157 113 79  120 103 56  122 138 58
+128 161 62  131 167 63  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  128 161 62
+122 138 58  150 108 73  173 124 92  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  173 124 92
+139 108 70  122 138 58  128 161 62  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  128 161 62  122 138 58  122 138 58
+120 103 56  155 109 77  172 123 91  172 123 89  172 123 89  172 123 91
+162 115 82  139 108 70  139 108 70  139 108 70  139 108 70  162 115 82
+172 123 91  172 124 91  171 123 90  176 124 92  157 113 79  120 103 56
+122 138 58  128 161 62  131 167 63  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  128 161 62
+122 138 58  158 114 83  173 124 92  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  173 124 92
+170 121 89  120 103 56  122 138 58  122 138 58  128 161 62  128 161 62
+128 161 62  128 161 62  122 138 58  122 138 58  120 103 56  140 107 74
+167 118 86  173 124 92  172 124 91  171 123 90  171 123 90  171 123 90
+173 124 92  173 124 92  172 123 91  172 123 91  173 124 92  173 124 92
+171 123 90  171 123 90  171 123 90  171 123 90  176 124 92  159 112 81
+120 103 56  122 138 58  128 161 62  131 167 63  131 167 63  131 167 63
+131 167 63  131 167 63  131 167 63  131 167 63  131 167 63  122 138 58
+120 103 56  170 121 89  172 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+173 124 92  168 120 88  139 108 70  120 103 56  122 138 58  122 138 58
+122 138 58  122 138 58  139 108 70  150 108 73  167 118 86  173 124 92
+173 124 92  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 123 89  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  176 124 92
+164 117 85  120 103 56  122 138 58  128 161 62  128 161 62  131 167 63
+131 167 63  131 167 63  131 167 63  128 161 62  122 138 58  122 138 58
+155 109 77  173 124 92  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  173 124 92  168 119 87  158 114 83  158 114 83
+158 114 83  167 118 86  172 123 91  173 124 92  172 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+173 124 92  170 118 87  139 108 70  122 138 58  122 138 58  122 138 58
+128 161 62  128 161 62  128 161 62  122 138 58  122 138 58  150 108 73
+172 123 91  172 123 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 124 91  173 124 92  173 124 92
+173 124 92  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  173 124 92  172 123 91  158 114 83  139 108 70  120 103 56
+122 138 58  122 138 58  122 138 58  139 108 70  159 112 81  172 123 91
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  173 124 92  173 124 92  170 121 89
+167 118 86  164 117 85  167 118 86  172 123 91  173 124 92  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 124 91
+173 124 92  173 124 92  172 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  170 124 90  170 124 90  170 124 90  170 124 90  170 124 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  170 124 90
+170 124 90  173 124 92  176 124 92  180 119 91  176 124 92  173 124 92
+170 124 90  170 124 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 124 90  170 124 90  180 119 91
+191 101 83  191 101 83  191 101 83  191 101 83  191 101 83  191 101 83
+191 101 83  180 119 91  170 124 90  170 124 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 124 90  172 123 89  191 101 83  209 65 67
+209 65 67  209 65 67  209 65 67  209 65 67  209 65 67  209 65 67
+209 65 67  191 101 83  191 101 83  172 123 89  170 124 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 124 91  172 123 89  191 101 83  209 65 67  209 65 67
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  209 65 67  209 65 67  191 101 83  172 123 89  170 124 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 124 90  171 124 91  191 101 83  209 65 67  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  209 65 67  191 101 83  170 124 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 124 90  191 101 83  209 65 67  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  209 65 67  191 101 83
+172 125 92  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 124 91
+172 123 89  209 65 67  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  209 65 67
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 125 92
+191 101 83  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+170 118 87  171 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 128 95
+191 101 83  202 40 44  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  202 40 44
+191 101 83  172 128 95  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 128 95
+183 65 60  192 38 41  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  192 38 41
+183 65 60  172 128 95  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 128 95
+183 65 60  174 32 31  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  174 32 31
+183 65 60  172 128 95  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 128 95
+183 65 60  174 32 31  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  192 38 41  174 32 31
+158 109 74  172 128 95  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  170 122 89  170 122 88  170 122 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  173 127 94
+162 112 77  174 32 31  192 38 41  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  192 38 41  174 32 31
+164 114 81  172 125 92  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  168 118 83
+166 116 81  168 119 85  169 121 86  167 117 83  167 117 83  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 123 89
+168 118 83  166 116 81  166 116 81  166 116 81  167 117 83  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  171 123 90  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  170 122 89  167 117 83  164 114 81
+166 116 81  170 122 88  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 124 91
+171 124 91  174 32 31  174 32 31  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  174 32 31  183 65 60
+172 125 92  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 122 89  166 116 81  183 141 112
+210 188 172  224 209 198  224 209 198  224 209 198  195 162 138  169 121 86
+169 121 86  171 123 90  171 123 90  171 123 90  169 121 86  168 118 83
+187 146 116  210 188 172  210 188 172  210 188 172  195 162 138  170 122 88
+167 117 83  171 123 90  171 123 90  171 123 90  171 123 90  169 121 86
+164 114 81  164 114 81  167 117 83  142 97 68  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  167 117 83  181 140 110  210 188 172
+195 162 138  171 123 90  169 121 86  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  169 121 86  166 116 81  164 114 81  164 114 81
+167 117 83  169 121 86  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 121 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 128 95  158 109 74  174 32 31  192 38 41  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  192 38 41  174 32 31  158 109 74
+172 128 95  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 121 89  167 117 83  210 188 172  245 241 237
+251 249 248  251 249 248  250 247 244  251 249 248  251 249 248  224 209 198
+171 124 91  169 121 86  171 124 91  168 118 83  174 128 96  224 209 198
+248 245 242  251 249 248  251 249 248  251 249 248  250 247 244  224 209 198
+183 141 112  164 114 81  171 123 90  171 123 90  169 121 86  176 130 98
+210 188 172  210 188 172  195 162 138  140 95 66  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  187 146 116  243 238 233  253 253 252
+253 253 252  209 203 196  168 119 85  170 122 89  171 123 90  171 123 90
+170 121 89  166 116 81  177 131 99  195 162 138  210 188 172  210 188 172
+195 162 138  172 124 92  166 116 81  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 121 89  166 116 81  168 119 85  172 123 89
+168 119 85  166 116 81  169 121 86  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 128 95  183 65 60  174 32 31  192 38 41  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  192 38 41  174 32 31  183 65 60  172 128 95
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 123 89  166 116 81  210 188 172  253 253 252  248 245 242
+246 242 238  246 242 238  246 242 238  246 242 238  247 243 239  253 253 252
+210 188 172  167 117 83  167 117 83  175 127 95  226 222 217  253 253 252
+247 243 240  246 242 238  246 242 238  246 242 238  247 243 239  251 249 248
+243 238 233  187 146 116  164 114 81  169 121 86  170 122 89  224 209 198
+253 253 252  253 253 252  251 249 248  166 134 109  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  210 188 172  253 253 252  246 242 238
+248 245 242  250 247 244  187 146 116  167 117 83  171 124 91  168 119 85
+170 121 89  210 188 172  238 234 230  251 249 248  251 249 248  251 249 248
+251 249 248  236 226 219  195 162 138  166 116 81  171 123 90  171 123 90
+171 123 90  168 118 83  172 124 91  195 162 138  224 209 198  236 226 219
+224 209 198  195 162 138  173 127 96  167 117 83  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 125 92  171 124 91  183 65 60  174 32 31  174 32 31
+192 38 41  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+192 38 41  174 32 31  174 32 31  183 65 60  172 125 93  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  166 116 81  195 162 138  251 249 248  247 243 240  246 242 238
+246 242 238  246 242 238  246 242 238  246 242 238  246 242 238  247 243 240
+250 247 244  195 162 138  164 114 81  224 209 198  253 253 252  246 242 238
+246 242 238  247 243 239  247 243 239  247 243 239  246 242 238  246 242 238
+250 247 244  245 241 237  187 146 116  158 109 74  195 162 138  253 253 252
+246 242 238  245 241 237  253 253 252  192 182 171  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  195 162 138  238 234 230  247 243 239
+246 242 238  251 249 248  210 188 172  164 114 81  167 117 83  174 128 96
+224 209 198  253 253 252  248 245 242  246 242 238  246 242 238  246 242 238
+246 242 238  251 249 248  247 243 240  195 162 138  164 114 81  171 124 91
+167 117 83  177 132 101  224 209 198  253 253 252  251 249 248  250 247 244
+251 249 248  251 249 248  236 226 219  183 141 112  166 116 81  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 125 92  172 125 92  183 65 60  174 32 31
+174 32 31  174 32 31  174 32 31  174 32 31  174 32 31  174 32 31
+174 32 31  174 32 31  183 65 60  172 125 92  171 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 121 86  173 127 94  236 226 219  250 247 244  246 242 238  246 242 238
+243 238 233  226 222 217  226 222 217  243 238 233  247 243 239  246 242 238
+248 245 242  238 234 230  226 222 217  248 245 242  246 242 238  246 242 238
+246 242 238  238 234 230  236 226 219  238 234 230  245 241 237  246 242 238
+246 242 238  250 247 244  243 238 233  209 203 196  238 234 230  248 245 242
+246 242 238  247 243 239  243 238 233  174 158 143  8 5 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  163 127 97  224 209 198  246 242 238
+246 242 238  250 247 244  236 226 219  169 121 86  177 132 101  226 222 217
+251 249 248  246 242 238  246 242 238  247 243 239  247 243 239  247 243 239
+247 243 239  246 242 238  248 245 242  247 243 240  187 146 116  158 109 74
+176 129 96  236 226 219  253 253 252  246 242 238  246 242 238  247 243 239
+246 242 238  246 242 238  251 249 248  238 234 230  183 141 112  167 117 83
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 124 91  172 128 95  167 117 83
+183 65 60  174 32 31  174 32 31  174 32 31  174 32 31  183 65 60
+183 65 60  170 118 87  172 128 95  171 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+166 116 81  195 162 138  251 249 248  246 242 238  246 242 238  245 241 237
+226 222 217  174 158 143  173 140 120  226 222 217  245 241 237  247 243 239
+246 242 238  248 245 242  250 247 244  246 242 238  246 242 238  247 243 240
+238 234 230  209 203 196  173 140 120  192 182 171  236 226 219  246 242 238
+247 243 239  246 242 238  247 243 240  251 249 248  247 243 240  246 242 238
+247 243 239  245 241 237  226 222 217  143 108 80  7 5 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  0 0 0  58 40 23  155 109 77  192 182 171  238 234 230
+247 243 239  246 242 238  250 247 244  209 203 196  236 226 219  251 249 248
+246 242 238  246 242 238  245 241 237  238 234 230  226 222 217  226 222 217
+238 234 230  247 242 238  246 242 238  250 247 244  238 234 230  187 146 116
+224 209 198  251 249 248  246 242 238  246 242 238  246 242 238  245 241 237
+245 241 237  246 242 238  246 242 238  251 249 248  226 222 217  172 125 93
+169 121 86  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 125 92
+172 128 95  173 127 94  170 121 89  170 118 87  170 121 89  173 127 94
+172 128 95  172 125 92  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  170 122 88
+168 119 85  224 209 198  251 249 248  246 242 238  247 243 239  238 234 230
+174 158 143  152 106 74  152 106 74  174 158 143  236 226 219  247 243 239
+247 243 239  247 243 239  246 242 238  247 243 239  247 243 240  243 238 233
+209 203 196  166 134 109  149 107 69  155 109 77  192 182 171  226 222 217
+245 241 237  247 243 240  247 243 239  246 242 238  247 243 239  247 243 239
+246 242 238  226 222 217  174 158 143  132 88 59  6 4 2  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 0 0
+1 1 0  0 0 0  58 40 23  162 112 77  173 140 120  226 222 217
+245 241 237  247 243 239  246 242 238  250 247 244  250 247 244  246 242 238
+247 243 239  245 241 237  226 222 217  192 182 171  166 134 109  173 140 120
+209 203 196  243 238 233  247 243 239  246 242 238  248 245 242  245 241 237
+248 245 242  246 242 238  247 243 239  245 241 237  226 222 217  209 203 196
+226 222 217  243 238 233  247 243 239  246 242 238  253 253 252  210 188 172
+167 117 83  172 123 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 124 91  171 124 91  172 125 92  171 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  170 122 89
+164 116 83  210 188 172  243 238 233  247 243 240  245 241 237  224 209 198
+158 123 96  168 118 83  169 121 86  155 115 87  192 182 171  226 222 217
+243 238 233  245 241 237  245 241 237  243 238 233  238 234 230  209 203 196
+173 140 120  155 109 77  176 124 92  167 117 83  155 115 87  192 182 171
+226 222 217  243 238 233  245 241 237  246 242 238  245 241 237  243 238 233
+226 222 217  192 182 171  155 115 87  139 97 68  6 4 2  0 0 0
+1 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 0 0
+1 1 0  0 0 0  58 40 23  170 122 88  155 109 77  192 182 171
+238 234 230  247 243 240  247 243 239  246 242 238  246 242 238  247 243 239
+245 241 237  226 222 217  192 182 171  155 115 87  162 112 77  154 107 75
+173 140 120  226 222 217  245 241 237  247 243 239  246 242 238  247 243 240
+246 242 238  247 243 239  247 243 239  236 226 219  192 182 171  143 108 80
+174 158 143  226 222 217  246 242 238  247 243 239  250 247 244  236 226 219
+170 122 90  169 121 86  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 124 91
+164 114 81  166 134 109  209 203 196  226 222 217  226 222 217  174 158 143
+157 113 79  172 123 89  172 124 91  166 116 81  155 115 87  174 158 143
+210 188 172  209 203 196  224 209 198  209 203 196  192 182 171  166 134 109
+158 109 74  172 123 89  171 123 90  172 124 91  168 119 85  155 109 77
+173 140 120  210 188 172  224 209 198  226 222 217  224 209 198  210 188 172
+174 158 143  157 113 79  167 117 83  140 107 74  7 5 2  0 0 0
+1 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 0 0
+1 1 0  0 0 0  58 40 23  171 123 90  164 114 81  158 123 96
+210 188 172  238 234 230  246 242 238  247 243 239  246 242 238  238 234 230
+226 222 217  174 158 143  155 109 77  168 119 85  173 125 92  172 123 89
+152 106 74  174 158 143  226 222 217  243 238 233  247 243 240  247 243 239
+247 243 240  246 242 238  236 226 219  192 182 171  155 115 87  166 116 81
+155 109 77  192 182 171  238 234 230  246 242 238  238 234 230  210 188 172
+163 116 84  172 123 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 123 89  159 112 81  163 127 97  174 158 143  173 140 120  158 114 83
+169 121 86  172 123 89  171 123 90  172 124 91  168 119 85  155 109 77
+155 115 87  158 123 96  158 123 96  155 115 87  155 109 77  164 114 81
+173 124 92  171 123 90  171 123 90  171 123 90  172 124 91  170 122 88
+162 112 77  155 115 87  166 134 109  166 134 109  166 134 109  155 115 87
+158 109 74  168 119 85  172 124 91  142 97 68  7 5 2  0 0 0
+1 0 0  1 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 0 0  1 1 0
+2 1 0  0 0 0  58 40 23  169 121 89  171 123 90  162 112 77
+158 123 96  192 182 171  224 209 198  226 222 217  226 222 217  209 203 196
+173 140 120  154 107 75  169 121 86  172 124 91  171 123 90  172 124 91
+170 121 89  155 109 77  174 158 143  224 209 198  238 234 230  238 234 230
+238 234 230  226 222 217  192 182 171  155 115 87  167 117 83  173 126 93
+166 116 81  158 123 96  192 182 171  224 209 198  192 182 171  158 123 96
+167 117 83  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  167 117 83  162 112 77  162 112 77  172 123 89
+172 124 91  171 123 90  171 123 90  171 123 90  172 124 91  172 124 91
+170 122 88  168 119 85  168 118 83  169 121 86  172 123 89  172 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+173 124 92  169 121 86  167 117 83  164 114 81  166 116 81  169 121 86
+171 123 90  169 122 89  170 122 90  139 97 68  8 5 2  0 0 0
+1 1 0  1 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 0 0  2 1 0
+2 1 0  0 0 0  58 40 23  167 120 88  167 121 88  170 122 89
+164 114 81  157 113 79  166 134 109  173 140 120  173 140 120  155 115 87
+157 113 79  172 123 89  172 124 91  171 123 90  171 123 90  171 123 90
+172 124 91  169 121 86  155 109 77  166 134 109  192 182 171  192 182 171
+192 182 171  173 140 120  157 113 79  167 117 83  172 124 91  171 123 90
+172 124 91  162 115 82  155 115 87  166 134 109  155 115 87  162 115 82
+172 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 124 91  173 124 92  172 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 124 91  172 124 91  171 123 90  170 122 89
+169 122 89  169 121 88  170 121 89  139 97 68  8 5 2  1 0 0
+2 1 0  1 1 0  1 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 0 0  2 1 0  2 2 0
+3 2 1  0 0 0  58 40 23  167 120 88  167 120 88  168 120 88
+169 122 89  169 121 86  164 114 81  164 114 81  164 114 81  169 121 86
+173 124 92  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 124 91  172 123 89  164 114 81  157 113 79  158 114 83
+157 113 79  162 112 77  170 122 88  172 124 91  171 123 90  171 123 90
+171 123 90  172 124 91  169 121 86  167 117 83  169 121 86  172 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 122 89  170 122 89  169 121 88
+169 121 88  168 120 88  168 120 88  139 97 68  10 6 3  2 1 0
+2 2 0  2 1 0  1 1 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 0 0  2 1 0  3 2 1
+5 3 1  0 0 0  49 35 24  168 120 88  164 117 85  166 119 87
+167 120 88  169 121 88  170 122 89  171 123 90  172 124 91  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 124 91  172 123 89  172 123 89
+172 124 91  172 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  170 122 89  169 121 88  168 120 88
+167 120 88  166 119 87  166 119 87  139 97 68  11 7 4  3 2 1
+4 2 1  2 2 0  2 1 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 0  3 2 1  4 3 1
+6 4 2  1 1 0  42 29 13  164 117 85  163 116 84  164 117 85
+166 119 87  166 119 87  167 121 88  170 122 89  170 122 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 90  170 122 89  168 120 88  166 119 87
+167 118 86  164 117 85  164 117 85  133 92 63  10 6 3  5 3 1
+5 3 1  3 2 1  2 1 0  1 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 1 0  3 2 1  5 3 1
+7 5 2  4 3 1  30 20 10  159 112 81  162 115 82  163 116 84
+164 117 85  166 119 87  168 120 88  169 122 89  170 122 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  169 122 89  169 121 88  167 120 88  167 118 86
+163 116 84  162 115 82  164 117 85  115 77 51  6 4 2  7 5 2
+5 4 1  4 3 1  2 2 0  1 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 1 0  3 2 1  6 4 2
+8 5 2  8 5 2  17 12 5  139 97 68  159 112 81  159 112 81
+162 115 82  163 116 84  166 119 87  167 121 88  169 121 88  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  170 122 89  169 121 88  167 120 88  166 119 87  163 116 84
+162 115 82  159 112 81  162 115 82  74 57 39  6 4 2  10 6 3
+7 5 2  5 3 1  2 2 0  1 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 1 0  4 2 1  6 4 2
+8 5 2  12 8 3  10 6 3  97 66 41  159 112 81  157 113 79
+159 112 81  162 115 82  163 116 84  166 119 87  168 120 88  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  169 122 89  168 120 88  167 118 86  163 116 84  162 115 82
+159 112 81  157 113 79  159 112 81  49 35 24  8 5 2  10 6 3
+7 5 2  5 3 1  2 2 0  1 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 1 0  4 2 1  6 4 2
+10 6 3  13 8 3  11 7 4  58 40 23  155 109 77  155 109 77
+155 109 77  159 112 81  162 115 82  164 117 85  167 120 88  169 121 88
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 124 90  170 124 90  170 124 90  170 124 90  170 124 90  170 124 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  169 121 88  166 119 87  163 116 84  162 115 82  159 112 81
+155 109 77  155 109 77  137 93 64  22 15 7  12 8 3  12 8 3
+8 5 2  5 4 1  2 2 0  1 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 0  3 2 1  6 4 2
+10 6 3  13 8 3  16 10 4  24 16 7  133 92 63  152 106 74
+152 106 74  155 109 77  159 112 81  162 115 82  164 117 85  168 120 88
+169 121 88  170 122 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 124 90  170 124 90
+176 124 92  180 119 91  180 119 91  180 119 91  180 119 91  176 124 92
+170 124 90  170 124 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+169 121 88  166 119 87  163 116 84  159 112 81  157 113 79  155 109 77
+152 106 74  154 107 75  97 66 41  13 8 3  16 10 4  12 8 3
+8 5 2  5 3 1  2 2 0  1 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 0 0  3 2 1  6 4 2
+10 6 3  13 8 3  19 12 5  16 10 4  74 57 39  152 106 74
+145 99 68  152 106 74  154 107 75  157 113 79  162 115 82  164 117 85
+167 120 88  169 121 88  169 122 89  170 122 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  170 122 89  170 122 89  170 122 89  169 122 89  169 122 89
+169 121 88  169 121 88  169 122 89  170 122 89  170 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 124 90  180 119 91  191 101 83
+191 101 83  191 101 83  209 65 67  209 65 67  191 101 83  191 101 83
+191 101 83  180 119 91  170 124 90  170 124 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 122 89  170 122 89  170 122 89
+170 122 89  170 122 89  170 122 89  170 122 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 122 89  169 122 89  169 121 88
+167 118 86  163 116 84  159 112 81  155 109 77  152 106 74  152 106 74
+152 106 74  142 97 68  36 25 11  17 12 5  17 12 5  12 8 3
+8 5 2  5 3 1  2 1 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 1 0  5 3 1
+8 5 2  13 8 3  19 12 5  20 14 6  28 19 9  132 88 59
+145 99 68  145 99 68  152 106 74  152 106 74  155 109 77  159 112 81
+164 117 85  166 119 87  169 121 86  169 122 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 123 89
+170 122 89  169 121 89  168 120 88  168 120 88  167 120 88  166 119 87
+167 118 86  167 118 86  167 120 88  168 120 88  169 121 88  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 124 90  191 101 83  191 101 83  209 65 67
+209 65 67  200 43 45  200 43 45  200 43 45  200 43 45  209 65 67
+209 65 67  209 65 67  191 101 83  171 123 90  170 124 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  169 122 89  169 121 88  168 120 88  168 120 88
+168 120 88  168 120 88  167 121 88  169 121 88  170 121 89  170 122 89
+172 123 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  169 121 89  168 120 88  167 118 86
+163 116 84  159 112 81  155 109 77  152 106 74  149 107 69  145 99 68
+145 99 68  97 66 41  19 12 5  20 14 6  17 12 5  12 8 3
+7 5 2  4 2 1  2 1 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 1 0  4 3 1
+7 5 2  12 8 3  17 12 5  22 15 7  20 14 6  58 40 23
+142 97 68  142 97 68  145 99 68  145 99 68  152 106 74  154 107 75
+159 112 81  162 115 82  164 117 85  166 119 87  167 121 88  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  170 122 89  167 121 88
+167 120 88  167 118 86  164 117 85  163 116 84  163 116 84  162 115 82
+163 116 84  163 116 84  164 117 85  166 119 87  167 121 88  169 121 88
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  170 124 90  191 101 83  209 65 67  209 65 67  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  209 65 67  209 65 67  191 101 83  170 124 90  171 124 91
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  169 122 89  169 121 88  168 120 88  166 119 87  164 117 85
+164 117 85  164 117 85  164 117 85  166 119 87  166 119 87  167 120 88
+169 122 89  169 121 89  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  169 122 89  167 121 88  166 119 87  163 116 84  162 115 82
+157 113 79  154 107 75  152 106 74  145 99 68  142 97 68  145 99 68
+126 83 55  34 23 10  22 15 7  20 14 6  16 10 4  10 6 3
+6 4 2  3 2 1  1 1 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 0  3 2 1
+6 4 2  10 6 3  16 10 4  20 14 6  24 16 7  24 16 7
+74 57 39  142 97 68  140 95 66  142 97 68  145 99 68  145 99 68
+152 106 74  155 109 77  157 113 79  159 112 81  162 115 82  163 116 84
+164 117 85  164 117 85  164 117 85  164 117 85  163 116 84  162 115 82
+162 115 82  159 112 81  159 112 81  157 113 79  157 113 79  157 113 79
+159 112 81  159 112 81  162 115 82  164 117 85  166 119 87  168 120 88
+169 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 124 90  191 101 83  209 65 67  209 65 67  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  209 65 67  191 101 83  170 124 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  167 121 88  168 120 88  167 118 86  163 116 84  162 115 82
+159 112 81  159 112 81  159 112 81  159 112 81  159 112 81  162 115 82
+163 116 84  164 117 85  164 117 85  167 118 86  167 118 86  164 117 85
+164 117 85  163 116 84  162 115 82  159 112 81  157 113 79  155 109 77
+152 106 74  145 99 68  145 99 68  142 97 68  140 95 66  137 93 64
+58 40 23  24 16 7  24 16 7  19 12 5  13 8 3  8 5 2
+5 3 1  2 1 0  1 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 0 0  2 1 0
+5 3 1  8 5 2  13 8 3  19 12 5  24 16 7  26 18 7
+32 22 10  97 66 41  140 95 66  137 93 64  137 93 64  142 97 68
+145 99 68  145 99 68  152 106 74  154 107 75  155 109 77  155 109 77
+157 113 79  157 113 79  157 113 79  157 113 79  155 109 77  155 109 77
+154 107 75  152 106 74  152 106 74  152 106 74  152 106 74  152 106 74
+154 107 75  155 109 77  159 112 81  163 116 84  164 117 85  166 119 87
+169 121 88  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 124 91
+172 123 89  209 65 67  209 65 67  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  209 65 67  170 118 87
+170 124 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 122 89  168 120 88  166 119 87  163 116 84  162 115 82  159 112 81
+155 109 77  154 107 75  154 107 75  154 107 75  154 107 75  155 109 77
+155 109 77  155 109 77  159 112 81  159 112 81  159 112 81  159 112 81
+157 113 79  155 109 77  155 109 77  152 106 74  152 106 74  145 99 68
+145 99 68  140 95 66  137 93 64  137 93 64  140 95 66  68 46 25
+26 18 7  26 18 7  22 15 7  17 12 5  12 8 3  7 5 2
+4 2 1  2 1 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  2 1 0
+3 2 1  6 4 2  10 6 3  16 10 4  20 14 6  26 18 7
+30 20 10  36 25 11  97 66 41  137 93 64  133 92 63  137 93 64
+137 93 64  142 97 68  142 97 68  145 99 68  145 99 68  149 107 69
+152 106 74  152 106 74  152 106 74  152 106 74  152 106 74  145 99 68
+145 99 68  145 99 68  145 99 68  145 99 68  145 99 68  145 99 68
+152 106 74  154 107 75  157 113 79  162 115 82  164 117 85  166 119 87
+169 121 88  170 122 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 125 92
+191 101 83  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  191 101 83
+172 125 92  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 121 88  167 120 88  166 119 87  163 116 84  159 112 81  155 109 77
+152 106 74  152 106 74  145 99 68  145 99 68  145 99 68  145 99 68
+149 107 69  152 106 74  152 106 74  152 106 74  152 106 74  152 106 74
+152 106 74  152 106 74  145 99 68  145 99 68  142 97 68  140 95 66
+137 93 64  133 92 63  137 93 64  133 92 63  68 46 25  28 19 9
+30 20 10  24 16 7  20 14 6  13 8 3  8 5 2  5 4 1
+3 2 1  1 1 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 0 0
+2 1 0  5 3 1  8 5 2  12 8 3  19 12 5  24 16 7
+28 19 9  32 22 10  36 25 11  74 57 39  132 88 59  132 88 59
+132 88 59  133 92 63  137 93 64  137 93 64  140 95 66  142 97 68
+142 97 68  142 97 68  142 97 68  142 97 68  142 97 68  140 95 66
+140 95 66  137 93 64  137 93 64  137 93 64  140 95 66  145 99 68
+115 77 51  97 66 41  155 109 77  159 112 81  163 116 84  166 119 87
+167 121 88  170 122 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 125 92
+183 65 60  202 40 44  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  183 65 60
+171 123 90  171 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 121 88  167 118 86  164 117 85  162 115 82  155 109 77  142 97 68
+145 99 68  145 99 68  142 97 68  140 95 66  140 95 66  140 95 66
+142 97 68  142 97 68  142 97 68  145 99 68  145 99 68  145 99 68
+142 97 68  142 97 68  140 95 66  137 93 64  137 93 64  133 92 63
+132 88 59  132 88 59  126 83 55  68 46 25  32 22 10  32 22 10
+26 18 7  20 14 6  16 10 4  10 6 3  6 4 2  4 2 1
+2 1 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 1 0  3 2 1  5 4 1  8 5 2  13 8 3  20 14 6
+24 16 7  32 22 10  34 23 10  34 23 10  58 40 23  115 77 51
+132 88 59  132 88 59  132 88 59  132 88 59  132 88 59  133 92 63
+133 92 63  137 93 64  137 93 64  133 92 63  133 92 63  132 88 59
+132 88 59  132 88 59  132 88 59  133 92 63  132 88 59  74 57 39
+26 18 7  74 57 39  155 109 77  159 112 81  163 116 84  166 119 87
+169 121 88  170 122 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  171 123 90
+183 65 60  202 40 44  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+170 118 87  171 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 121 88  167 118 86  163 116 84  159 112 81  155 109 77  97 66 41
+49 35 24  126 83 55  137 93 64  133 92 63  132 88 59  132 88 59
+133 92 63  133 92 63  137 93 64  137 93 64  137 93 64  137 93 64
+133 92 63  133 92 63  132 88 59  132 88 59  132 88 59  132 88 59
+132 88 59  97 66 41  49 35 24  34 23 10  34 23 10  28 19 9
+22 15 7  17 12 5  12 8 3  7 5 2  5 3 1  2 1 0
+1 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 1 0  4 2 1  6 4 2  10 6 3  16 10 4
+20 14 6  24 16 7  32 22 10  36 25 11  36 25 11  42 29 13
+68 46 25  97 66 41  126 83 55  126 83 55  126 83 55  126 83 55
+126 83 55  132 88 59  132 88 59  126 83 55  126 83 55  126 83 55
+126 83 55  126 83 55  115 77 51  97 66 41  49 35 24  30 20 10
+22 15 7  74 57 39  155 109 77  159 112 81  163 116 84  166 119 87
+169 121 88  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  170 121 89
+192 38 41  192 38 41  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  192 38 41
+164 114 81  172 125 92  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 121 88  166 119 87  163 116 84  159 112 81  157 113 79  97 66 41
+20 14 6  39 26 12  74 57 39  115 77 51  132 88 59  126 83 55
+126 83 55  126 83 55  132 88 59  132 88 59  132 88 59  132 88 59
+132 88 59  126 83 55  126 83 55  126 83 55  126 83 55  97 66 41
+68 46 25  39 26 12  36 25 11  36 25 11  28 19 9  24 16 7
+19 12 5  13 8 3  8 5 2  5 3 1  3 2 1  1 1 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  2 1 0  4 2 1  6 4 2  10 6 3
+16 10 4  20 14 6  24 16 7  30 20 10  36 25 11  39 26 12
+39 26 12  42 29 13  58 40 23  74 57 39  97 66 41  115 77 51
+115 77 51  126 83 55  126 83 55  115 77 51  115 77 51  97 66 41
+97 66 41  68 46 25  49 35 24  39 26 12  36 25 11  32 22 10
+20 14 6  74 57 39  159 112 81  162 115 82  164 117 85  166 119 87
+169 121 88  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  170 122 89
+174 32 31  192 38 41  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  192 38 41  174 32 31
+166 116 81  172 125 92  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 121 88  166 119 87  164 117 85  162 115 82  159 112 81  97 66 41
+24 16 7  32 22 10  34 23 10  42 29 13  68 46 25  97 66 41
+115 77 51  115 77 51  126 83 55  126 83 55  126 83 55  126 83 55
+126 83 55  115 77 51  97 66 41  74 57 39  58 40 23  42 29 13
+39 26 12  39 26 12  34 23 10  28 19 9  24 16 7  19 12 5
+13 8 3  8 5 2  5 4 1  3 2 1  2 1 0  1 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 0 0  2 1 0  4 3 1  6 4 2
+10 6 3  13 8 3  20 14 6  24 16 7  28 19 9  32 22 10
+36 25 11  39 26 12  39 26 12  42 29 13  42 29 13  49 35 24
+58 40 23  58 40 23  58 40 23  58 40 23  58 40 23  42 29 13
+42 29 13  39 26 12  39 26 12  36 25 11  32 22 10  28 19 9
+17 12 5  74 57 39  162 115 82  163 116 84  167 118 86  168 120 88
+169 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 124 91  172 125 92
+183 65 60  174 32 31  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  192 38 41  174 32 31
+170 118 87  171 124 91  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 122 89  167 120 88  164 117 85  162 115 82  159 112 81  97 66 41
+20 14 6  28 19 9  36 25 11  39 26 12  39 26 12  42 29 13
+42 29 13  58 40 23  68 46 25  68 46 25  68 46 25  68 46 25
+58 40 23  58 40 23  42 29 13  42 29 13  39 26 12  39 26 12
+36 25 11  32 22 10  26 18 7  22 15 7  19 12 5  13 8 3
+8 5 2  6 4 2  3 2 1  2 1 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 0 0  2 1 0  4 2 1
+6 4 2  10 6 3  13 8 3  17 12 5  20 14 6  24 16 7
+28 19 9  32 22 10  36 25 11  39 26 12  39 26 12  42 29 13
+42 29 13  42 29 13  42 29 13  42 29 13  42 29 13  39 26 12
+39 26 12  36 25 11  34 23 10  30 20 10  26 18 7  22 15 7
+12 8 3  74 57 39  164 117 85  164 117 85  167 120 88  169 121 88
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 128 95
+183 65 60  174 32 31  192 38 41  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  174 32 31  183 65 60
+172 128 95  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+169 122 89  168 120 88  166 119 87  163 116 84  163 116 84  97 66 41
+16 10 4  24 16 7  28 19 9  32 22 10  36 25 11  39 26 12
+39 26 12  42 29 13  42 29 13  42 29 13  42 29 13  42 29 13
+42 29 13  42 29 13  39 26 12  39 26 12  36 25 11  32 22 10
+28 19 9  24 16 7  20 14 6  17 12 5  12 8 3  8 5 2
+5 4 1  3 2 1  1 1 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  2 1 0
+3 2 1  5 4 1  8 5 2  12 8 3  16 10 4  19 12 5
+22 15 7  24 16 7  28 19 9  32 22 10  32 22 10  34 23 10
+36 25 11  36 25 11  36 25 11  36 25 11  36 25 11  34 23 10
+32 22 10  28 19 9  26 18 7  24 16 7  20 14 6  17 12 5
+8 5 2  74 57 39  166 119 87  166 119 87  167 121 88  169 121 88
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  172 125 92
+167 117 83  174 32 31  174 32 31  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  192 38 41  174 32 31  158 109 74
+172 128 95  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  167 121 88  167 120 88  164 117 85  164 117 85  97 66 41
+12 8 3  20 14 6  22 15 7  26 18 7  28 19 9  32 22 10
+34 23 10  36 25 11  36 25 11  36 25 11  36 25 11  36 25 11
+36 25 11  34 23 10  32 22 10  32 22 10  28 19 9  24 16 7
+20 14 6  19 12 5  13 8 3  10 6 3  7 5 2  5 3 1
+3 2 1  1 1 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 1 0  2 2 0  4 3 1  6 4 2  10 6 3  12 8 3
+16 10 4  19 12 5  20 14 6  24 16 7  24 16 7  26 18 7
+26 18 7  28 19 9  28 19 9  28 19 9  26 18 7  26 18 7
+24 16 7  22 15 7  20 14 6  17 12 5  16 10 4  12 8 3
+3 2 1  74 57 39  169 121 89  168 120 88  169 121 88  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+172 128 95  183 65 60  174 32 31  192 38 41  200 43 45  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  200 43 45  192 38 41  174 32 31  183 65 60  173 127 94
+171 124 91  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  169 121 88  168 120 88  166 119 87  167 118 86  97 66 41
+8 5 2  13 8 3  17 12 5  20 14 6  22 15 7  24 16 7
+26 18 7  26 18 7  28 19 9  28 19 9  28 19 9  28 19 9
+28 19 9  26 18 7  24 16 7  22 15 7  20 14 6  17 12 5
+16 10 4  12 8 3  8 5 2  6 4 2  4 2 1  2 1 0
+1 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 0 0  2 2 0  4 3 1  6 4 2
+8 5 2  11 7 4  13 8 3  16 10 4  17 12 5  20 14 6
+20 14 6  20 14 6  20 14 6  20 14 6  20 14 6  19 12 5
+17 12 5  16 10 4  13 8 3  11 7 4  8 5 2  6 4 2
+0 0 0  74 57 39  170 122 90  167 121 88  169 122 89  170 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 124 91  171 124 91  174 32 31  174 32 31  192 38 41  200 43 45
+200 43 45  200 43 45  200 43 45  200 43 45  200 43 45  200 43 45
+200 43 45  192 38 41  174 32 31  174 32 31  167 117 83  172 125 92
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  170 122 89
+170 122 89  169 121 88  167 121 88  166 119 87  167 121 88  97 66 41
+3 2 1  10 6 3  12 8 3  13 8 3  16 10 4  17 12 5
+19 12 5  20 14 6  20 14 6  20 14 6  20 14 6  20 14 6
+20 14 6  20 14 6  17 12 5  16 10 4  13 8 3  10 6 3
+8 5 2  5 4 1  4 2 1  2 1 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 0 0  1 1 0
+2 2 0  4 2 1  5 4 1  6 4 2  8 5 2  10 6 3
+11 7 4  12 8 3  12 8 3  11 7 4  10 6 3  8 5 2
+8 5 2  8 5 2  6 4 2  5 4 1  5 3 1  4 3 1
+0 0 0  74 57 39  171 124 91  167 121 88  169 121 88  169 121 88
+170 122 89  170 122 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  172 125 93  170 121 89  183 65 60  174 32 31  174 32 31
+192 38 41  200 43 45  200 43 45  200 43 45  200 43 45  192 38 41
+174 32 31  174 32 31  174 32 31  164 114 81  172 128 95  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  170 122 89
+169 122 89  167 121 88  168 120 88  167 120 88  169 121 89  74 57 39
+0 0 0  6 4 2  6 4 2  7 5 2  8 5 2  10 6 3
+10 6 3  10 6 3  12 8 3  13 8 3  13 8 3  12 8 3
+12 8 3  10 6 3  8 5 2  7 5 2  5 4 1  4 2 1
+2 2 0  1 1 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 0 0  1 1 0  1 1 0
+2 1 0  2 1 0  2 1 0  2 1 0  2 1 0  1 1 0
+2 1 0  2 2 0  2 2 0  2 2 0  3 2 1  4 2 1
+0 0 0  74 57 39  170 122 90  167 120 88  167 121 88  169 121 88
+169 122 89  170 122 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  172 125 92  171 124 91  183 65 60  174 32 31
+174 32 31  174 32 31  174 32 31  174 32 31  174 32 31  174 32 31
+174 32 31  183 65 60  170 118 87  173 127 94  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  170 122 89
+169 121 88  168 120 88  168 120 88  166 119 87  169 121 89  68 46 25
+0 0 0  5 3 1  4 3 1  4 3 1  4 2 1  4 2 1
+2 2 0  2 1 0  2 2 0  3 2 1  3 2 1  3 2 1
+2 1 0  2 1 0  2 1 0  1 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 0  2 1 0  3 2 1  4 3 1
+0 0 0  74 57 39  168 120 88  166 119 87  166 119 87  167 120 88
+169 121 88  169 122 89  170 124 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 124 91  172 128 95  170 118 87
+158 109 74  183 65 60  183 65 60  183 65 60  183 65 60  145 99 68
+167 117 83  172 128 95  172 125 92  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  169 121 88
+168 120 88  166 119 87  166 119 87  164 117 85  167 118 86  58 40 23
+1 0 0  5 4 1  4 3 1  3 2 1  2 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 1 0  3 2 1  4 3 1  6 4 2
+1 1 0  68 46 25  167 118 86  163 116 84  164 117 85  167 118 86
+167 120 88  169 121 88  170 122 89  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 124 91
+172 128 95  172 128 95  172 128 95  172 128 95  172 128 95  172 128 95
+172 125 92  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 122 89  169 122 89  167 121 88
+166 119 87  164 117 85  164 117 85  163 116 84  164 117 85  49 35 24
+2 1 0  6 4 2  5 3 1  3 2 1  2 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 1 0  4 2 1  5 4 1  7 5 2
+4 2 1  49 35 24  163 116 84  162 115 82  163 116 84  164 117 85
+166 119 87  168 120 88  169 121 89  170 122 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 122 89  169 121 88  168 120 88
+167 118 86  163 116 84  162 115 82  162 115 82  159 112 81  39 26 12
+5 3 1  8 5 2  6 4 2  4 2 1  2 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 1 0  4 3 1  6 4 2  8 5 2
+7 5 2  30 20 10  154 107 75  159 112 81  159 112 81  162 115 82
+163 116 84  166 119 87  167 121 88  169 122 89  170 122 89  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  169 121 88  169 121 86  167 118 86
+163 116 84  162 115 82  159 112 81  159 112 81  142 97 68  20 14 6
+8 5 2  8 5 2  6 4 2  4 3 1  2 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 1 0  4 3 1  6 4 2  10 6 3
+12 8 3  16 10 4  126 83 55  155 109 77  155 109 77  159 112 81
+162 115 82  163 116 84  166 119 87  168 120 88  169 122 89  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  169 122 89  168 120 88  167 118 86  163 116 84
+159 112 81  157 113 79  155 109 77  157 113 79  97 66 41  12 8 3
+13 8 3  10 6 3  6 4 2  4 3 1  2 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 1 0  4 3 1  7 5 2  10 6 3
+16 10 4  12 8 3  68 46 25  155 109 77  152 106 74  155 109 77
+157 113 79  159 112 81  163 116 84  167 118 86  168 120 88  170 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  169 122 89  169 121 86  167 118 86  163 116 84  159 112 81
+157 113 79  155 109 77  152 106 74  155 109 77  58 40 23  12 8 3
+13 8 3  10 6 3  6 4 2  4 2 1  2 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 1 0  4 3 1  7 5 2  10 6 3
+16 10 4  17 12 5  32 22 10  140 95 66  152 106 74  152 106 74
+152 106 74  155 109 77  159 112 81  162 115 82  167 118 86  168 120 88
+169 121 89  170 122 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  170 122 89
+169 121 88  167 121 88  164 117 85  162 115 82  159 112 81  155 109 77
+152 106 74  152 106 74  152 106 74  132 88 59  24 16 7  17 12 5
+16 10 4  10 6 3  6 4 2  4 2 1  2 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 0  3 2 1  6 4 2  10 6 3
+16 10 4  20 14 6  17 12 5  74 57 39  145 99 68  145 99 68
+145 99 68  152 106 74  154 107 75  157 113 79  162 115 82  164 117 85
+166 119 87  167 120 88  168 120 88  170 121 89  170 122 89  170 122 89
+170 122 90  170 122 90  170 124 90  170 124 90  170 124 90  171 123 90
+172 123 89  171 123 90  170 124 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 124 90  170 124 90  170 122 89  169 121 89  168 120 88  167 120 88
+164 117 85  163 116 84  159 112 81  155 109 77  154 107 75  152 106 74
+145 99 68  145 99 68  145 99 68  68 46 25  17 12 5  20 14 6
+16 10 4  10 6 3  6 4 2  3 2 1  1 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 0 0  3 2 1  5 4 1  10 6 3
+13 8 3  20 14 6  22 15 7  28 19 9  115 77 51  145 99 68
+142 97 68  145 99 68  145 99 68  152 106 74  154 107 75  155 109 77
+159 112 81  159 112 81  162 115 82  163 116 84  163 116 84  163 116 84
+164 117 85  164 117 85  164 117 85  164 117 85  164 117 85  164 117 85
+164 117 85  166 119 87  166 119 87  168 119 87  167 121 88  169 121 88
+169 122 89  170 122 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 122 89  170 122 89  169 122 89
+169 121 88  167 121 88  168 119 87  166 119 87  166 119 87  167 118 86
+164 117 85  164 117 85  164 117 85  164 117 85  164 117 85  164 117 85
+164 117 85  164 117 85  163 116 84  163 116 84  162 115 82  159 112 81
+157 113 79  155 109 77  154 107 75  152 106 74  145 99 68  145 99 68
+142 97 68  145 99 68  115 77 51  28 19 9  22 15 7  19 12 5
+13 8 3  8 5 2  5 3 1  2 2 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  2 1 0  5 3 1  8 5 2
+13 8 3  19 12 5  24 16 7  24 16 7  42 29 13  133 92 63
+140 95 66  140 95 66  140 95 66  142 97 68  145 99 68  152 106 74
+152 106 74  154 107 75  154 107 75  155 109 77  155 109 77  155 109 77
+155 109 77  155 109 77  155 109 77  157 113 79  157 113 79  157 113 79
+159 112 81  159 112 81  162 115 82  163 116 84  164 117 85  166 119 87
+167 121 88  169 121 88  170 122 89  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 122 89  169 121 88  168 120 88
+166 119 87  167 118 86  163 116 84  162 115 82  159 112 81  159 112 81
+157 113 79  157 113 79  157 113 79  157 113 79  157 113 79  157 113 79
+157 113 79  155 109 77  155 109 77  155 109 77  154 107 75  152 106 74
+152 106 74  149 107 69  145 99 68  142 97 68  140 95 66  140 95 66
+140 95 66  132 88 59  42 29 13  24 16 7  22 15 7  17 12 5
+12 8 3  7 5 2  4 3 1  2 1 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 1 0  3 2 1  6 4 2
+11 7 4  16 10 4  20 14 6  26 18 7  26 18 7  68 46 25
+137 93 64  137 93 64  137 93 64  137 93 64  140 95 66  142 97 68
+145 99 68  145 99 68  145 99 68  149 107 69  149 107 69  152 106 74
+152 106 74  152 106 74  152 106 74  152 106 74  152 106 74  152 106 74
+154 107 75  155 109 77  157 113 79  159 112 81  163 116 84  166 119 87
+167 120 88  169 121 88  170 122 89  170 122 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  169 122 89  169 121 88  166 119 87
+164 117 85  163 116 84  159 112 81  155 109 77  155 109 77  154 107 75
+152 106 74  152 106 74  152 106 74  152 106 74  152 106 74  152 106 74
+152 106 74  152 106 74  152 106 74  149 107 69  145 99 68  145 99 68
+142 97 68  142 97 68  140 95 66  137 93 64  137 93 64  137 93 64
+133 92 63  58 40 23  26 18 7  26 18 7  20 14 6  16 10 4
+10 6 3  6 4 2  3 2 1  1 1 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 0 0  2 2 0  5 3 1
+8 5 2  13 8 3  19 12 5  24 16 7  30 20 10  28 19 9
+68 46 25  132 88 59  133 92 63  132 88 59  133 92 63  137 93 64
+137 93 64  137 93 64  140 95 66  140 95 66  140 95 66  142 97 68
+142 97 68  142 97 68  142 97 68  142 97 68  145 99 68  145 99 68
+145 99 68  152 106 74  154 107 75  155 109 77  159 112 81  163 116 84
+167 118 86  168 120 88  169 122 89  170 124 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  169 121 88  168 120 88  164 117 85
+163 116 84  159 112 81  155 109 77  152 106 74  152 106 74  145 99 68
+145 99 68  142 97 68  142 97 68  142 97 68  142 97 68  142 97 68
+142 97 68  142 97 68  140 95 66  140 95 66  140 95 66  137 93 64
+137 93 64  133 92 63  132 88 59  132 88 59  133 92 63  126 83 55
+58 40 23  28 19 9  30 20 10  24 16 7  19 12 5  13 8 3
+8 5 2  5 3 1  2 1 0  1 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 0  3 2 1
+6 4 2  10 6 3  16 10 4  20 14 6  26 18 7  32 22 10
+32 22 10  58 40 23  97 66 41  132 88 59  132 88 59  132 88 59
+132 88 59  132 88 59  132 88 59  133 92 63  133 92 63  133 92 63
+133 92 63  133 92 63  133 92 63  133 92 63  137 93 64  137 93 64
+142 97 68  145 99 68  149 107 69  154 107 75  157 113 79  162 115 82
+164 117 85  167 120 88  169 121 88  170 122 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  168 120 88  166 119 87  163 116 84
+159 112 81  155 109 77  152 106 74  145 99 68  145 99 68  140 95 66
+137 93 64  137 93 64  137 93 64  137 93 64  133 92 63  133 92 63
+133 92 63  133 92 63  133 92 63  132 88 59  132 88 59  132 88 59
+132 88 59  132 88 59  132 88 59  126 83 55  97 66 41  49 35 24
+32 22 10  32 22 10  26 18 7  20 14 6  16 10 4  10 6 3
+6 4 2  3 2 1  1 1 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 0 0  2 1 0
+4 3 1  7 5 2  12 8 3  17 12 5  22 15 7  28 19 9
+34 23 10  36 25 11  42 29 13  68 46 25  97 66 41  126 83 55
+126 83 55  126 83 55  126 83 55  126 83 55  126 83 55  126 83 55
+126 83 55  126 83 55  126 83 55  132 88 59  132 88 59  132 88 59
+137 93 64  140 95 66  145 99 68  152 106 74  155 109 77  159 112 81
+163 116 84  166 119 87  169 121 88  172 123 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  169 121 88  166 119 87  162 115 82
+159 112 81  154 107 75  152 106 74  145 99 68  140 95 66  137 93 64
+132 88 59  132 88 59  132 88 59  132 88 59  132 88 59  132 88 59
+126 83 55  126 83 55  126 83 55  126 83 55  126 83 55  126 83 55
+126 83 55  115 77 51  97 66 41  58 40 23  39 26 12  36 25 11
+34 23 10  28 19 9  22 15 7  17 12 5  11 7 4  7 5 2
+4 3 1  2 1 0  1 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 0
+3 2 1  5 3 1  8 5 2  12 8 3  17 12 5  22 15 7
+28 19 9  34 23 10  39 26 12  39 26 12  42 29 13  58 40 23
+68 46 25  74 57 39  97 66 41  97 66 41  97 66 41  97 66 41
+97 66 41  97 66 41  97 66 41  97 66 41  97 66 41  97 66 41
+97 66 41  115 77 51  115 77 51  132 88 59  154 107 75  157 113 79
+162 115 82  167 118 86  169 121 88  170 122 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  169 122 89  167 120 88  164 117 85  162 115 82
+155 109 77  152 106 74  126 83 55  115 77 51  115 77 51  115 77 51
+115 77 51  115 77 51  115 77 51  115 77 51  115 77 51  115 77 51
+115 77 51  115 77 51  97 66 41  97 66 41  97 66 41  74 57 39
+68 46 25  49 35 24  42 29 13  39 26 12  36 25 11  32 22 10
+28 19 9  22 15 7  17 12 5  12 8 3  7 5 2  5 3 1
+3 2 1  1 1 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 1 0  3 2 1  5 4 1  8 5 2  12 8 3  17 12 5
+20 14 6  26 18 7  32 22 10  36 25 11  39 26 12  39 26 12
+42 29 13  42 29 13  42 29 13  42 29 13  42 29 13  42 29 13
+42 29 13  42 29 13  42 29 13  42 29 13  42 29 13  42 29 13
+39 26 12  36 25 11  24 16 7  68 46 25  155 109 77  159 112 81
+163 116 84  166 119 87  169 121 88  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  169 122 89  167 121 88  164 117 85  162 115 82
+155 109 77  149 107 69  42 29 13  32 22 10  39 26 12  42 29 13
+42 29 13  42 29 13  49 35 24  49 35 24  49 35 24  49 35 24
+49 35 24  49 35 24  42 29 13  42 29 13  42 29 13  42 29 13
+42 29 13  39 26 12  39 26 12  36 25 11  30 20 10  26 18 7
+20 14 6  17 12 5  12 8 3  8 5 2  5 3 1  3 2 1
+1 1 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  2 1 0  3 2 1  5 4 1  8 5 2  12 8 3
+17 12 5  20 14 6  24 16 7  28 19 9  32 22 10  36 25 11
+36 25 11  39 26 12  39 26 12  42 29 13  42 29 13  42 29 13
+42 29 13  42 29 13  42 29 13  42 29 13  39 26 12  39 26 12
+36 25 11  32 22 10  20 14 6  68 46 25  159 112 81  159 112 81
+164 117 85  166 119 87  169 121 88  172 123 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  167 121 88  167 118 86  163 116 84
+159 112 81  152 106 74  42 29 13  24 16 7  32 22 10  36 25 11
+39 26 12  42 29 13  42 29 13  42 29 13  42 29 13  42 29 13
+42 29 13  42 29 13  42 29 13  42 29 13  39 26 12  39 26 12
+36 25 11  34 23 10  32 22 10  26 18 7  24 16 7  20 14 6
+16 10 4  12 8 3  8 5 2  5 3 1  3 2 1  2 1 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 1 0  3 2 1  5 3 1  7 5 2
+10 6 3  13 8 3  19 12 5  20 14 6  24 16 7  26 18 7
+28 19 9  32 22 10  32 22 10  34 23 10  34 23 10  36 25 11
+36 25 11  36 25 11  36 25 11  34 23 10  34 23 10  32 22 10
+28 19 9  26 18 7  17 12 5  68 46 25  162 115 82  162 115 82
+164 117 85  167 120 88  169 122 89  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  168 120 88  166 119 87  163 116 84
+162 115 82  155 109 77  39 26 12  20 14 6  28 19 9  32 22 10
+32 22 10  36 25 11  36 25 11  36 25 11  36 25 11  36 25 11
+36 25 11  36 25 11  34 23 10  34 23 10  32 22 10  32 22 10
+28 19 9  26 18 7  24 16 7  20 14 6  17 12 5  13 8 3
+10 6 3  7 5 2  5 3 1  2 2 0  1 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 0 0  2 1 0  4 2 1
+6 4 2  8 5 2  12 8 3  16 10 4  17 12 5  20 14 6
+20 14 6  24 16 7  24 16 7  26 18 7  26 18 7  26 18 7
+26 18 7  26 18 7  26 18 7  26 18 7  26 18 7  24 16 7
+22 15 7  20 14 6  11 7 4  68 46 25  164 117 85  163 116 84
+167 118 86  168 120 88  169 122 89  170 124 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  169 121 88  167 120 88  164 117 85
+162 115 82  157 113 79  36 25 11  16 10 4  22 15 7  24 16 7
+26 18 7  26 18 7  28 19 9  28 19 9  28 19 9  28 19 9
+26 18 7  26 18 7  26 18 7  26 18 7  24 16 7  22 15 7
+20 14 6  20 14 6  17 12 5  13 8 3  10 6 3  8 5 2
+5 4 1  3 2 1  2 1 0  1 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 0 0
+2 1 0  4 2 1  5 4 1  7 5 2  10 6 3  12 8 3
+13 8 3  16 10 4  17 12 5  19 12 5  19 12 5  20 14 6
+20 14 6  20 14 6  20 14 6  20 14 6  19 12 5  19 12 5
+17 12 5  16 10 4  6 4 2  68 46 25  166 119 87  164 117 85
+167 120 88  169 121 88  170 122 89  170 122 89  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  169 121 88  167 121 88  166 119 87
+164 117 85  159 112 81  32 22 10  10 6 3  17 12 5  19 12 5
+19 12 5  20 14 6  20 14 6  20 14 6  20 14 6  20 14 6
+20 14 6  20 14 6  20 14 6  19 12 5  17 12 5  16 10 4
+13 8 3  12 8 3  10 6 3  7 5 2  5 3 1  3 2 1
+1 1 0  1 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 0 0  2 1 0  2 2 0  4 2 1
+5 3 1  6 4 2  7 5 2  8 5 2  8 5 2  10 6 3
+10 6 3  10 6 3  10 6 3  12 8 3  12 8 3  11 7 4
+10 6 3  10 6 3  2 1 0  68 46 25  169 121 89  166 119 87
+168 120 88  169 121 88  170 122 89  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  169 122 89  169 121 88  168 120 88
+167 118 86  163 116 84  28 19 9  5 3 1  10 6 3  12 8 3
+12 8 3  12 8 3  12 8 3  11 7 4  11 7 4  11 7 4
+10 6 3  10 6 3  10 6 3  8 5 2  7 5 2  6 4 2
+5 3 1  4 2 1  2 1 0  2 1 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  1 0 0  1 1 0  4 2 1  4 2 1  3 2 1
+4 2 1  4 2 1  0 0 0  68 46 25  172 124 92  169 121 88
+169 121 88  170 122 89  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 122 89  170 122 89  169 121 88
+169 121 88  166 119 87  24 16 7  0 0 0  4 3 1  4 3 1
+5 3 1  4 3 1  4 2 1  1 1 0  1 1 0  1 1 0
+1 1 0  1 0 0  1 0 0  1 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  169 121 86  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  0 0 0  68 46 25  173 125 92  169 122 89
+170 122 89  171 123 90  171 123 90  172 123 89  170 121 89  169 121 86
+170 121 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  170 122 89
+170 122 89  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 0  0 0 0  68 46 25  173 124 92  169 122 89
+170 122 89  170 122 89  168 118 83  167 117 83  172 124 91  174 128 96
+170 122 90  166 116 81  169 121 86  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  167 117 83  166 116 81  168 118 83
+167 117 83  166 116 81  169 121 86  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  168 119 85
+166 116 81  166 116 81  168 119 85  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  170 122 89  170 122 89
+170 122 89  167 121 88  24 16 7  0 0 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  1 1 0  0 0 0  68 46 25  173 124 92  169 122 89
+169 121 88  164 114 81  187 146 116  210 188 172  236 226 219  236 226 219
+226 222 217  210 188 172  177 131 99  167 117 83  171 123 90  171 123 90
+171 123 90  168 119 85  169 121 86  195 162 138  210 188 172  224 209 198
+224 209 198  192 182 171  177 133 103  166 116 81  170 122 89  171 123 90
+171 123 90  171 123 90  169 121 86  167 117 83  168 118 83  166 116 81
+169 121 88  171 123 90  171 123 90  171 123 90  167 117 83  183 141 112
+210 188 172  210 188 172  186 144 112  168 118 83  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  168 119 85  166 116 81  167 117 83
+167 117 83  166 116 81  168 118 83  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  170 122 88
+169 121 86  169 121 86  171 123 90  171 123 90  170 122 89  170 122 89
+169 121 88  167 120 88  24 16 7  0 0 0  1 1 0  1 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  2 1 0  0 0 0  68 46 25  173 124 92  168 120 88
+166 116 81  210 188 172  247 243 240  251 249 248  250 247 244  248 245 242
+250 247 244  253 253 252  236 226 219  180 137 106  167 117 83  171 124 91
+168 118 83  176 130 98  224 209 198  250 247 244  251 249 248  251 249 248
+251 249 248  251 249 248  238 234 230  195 162 138  166 116 81  170 121 89
+171 124 91  169 121 86  177 131 99  210 188 172  224 209 198  210 188 172
+169 121 88  168 120 88  170 122 89  168 119 85  180 137 106  236 226 219
+253 253 252  253 253 252  238 234 230  180 137 106  168 119 85  171 123 90
+171 123 90  170 121 89  166 116 81  177 133 103  195 162 138  210 188 172
+224 209 198  210 188 172  187 146 116  166 116 81  169 121 86  171 123 90
+171 123 90  171 123 90  171 123 90  169 121 86  166 116 81  170 122 89
+177 131 99  175 127 95  167 117 83  167 117 83  170 122 89  169 122 89
+169 121 88  167 120 88  24 16 7  0 0 0  1 1 0  1 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 0 0
+1 1 0  2 1 0  0 0 0  68 46 25  172 123 89  162 112 77
+210 188 172  253 253 252  248 245 242  246 242 238  246 242 238  246 242 238
+246 242 238  246 242 238  251 249 248  226 222 217  171 123 90  166 116 81
+173 125 92  226 222 217  253 253 252  247 243 239  246 242 238  246 242 238
+246 242 238  246 242 238  250 247 244  251 249 248  210 188 172  164 114 81
+168 119 85  168 119 85  224 209 198  253 253 252  251 249 248  253 253 252
+210 188 172  166 116 81  167 121 88  162 112 77  195 162 138  251 249 248
+246 242 238  246 242 238  253 253 252  210 188 172  164 114 81  171 124 91
+168 119 85  168 119 85  210 188 172  243 238 233  251 249 248  251 249 248
+251 249 248  251 249 248  248 245 242  210 188 172  170 122 89  168 119 85
+171 123 90  171 123 90  168 119 85  170 122 88  192 182 171  226 222 217
+238 234 230  236 226 219  224 209 198  187 146 116  164 114 81  169 121 86
+169 121 89  166 119 87  24 16 7  0 0 0  2 1 0  1 1 0
+1 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 0 0  1 1 0
+2 1 0  3 2 1  0 0 0  68 46 25  167 117 83  195 162 138
+250 247 244  247 243 240  246 242 238  246 242 238  246 242 238  246 242 238
+246 242 238  246 242 238  246 242 238  251 249 248  210 188 172  168 119 85
+224 209 198  253 253 252  246 242 238  246 242 238  247 243 239  246 242 238
+247 243 239  246 242 238  246 242 238  248 245 242  251 249 248  210 188 172
+164 114 81  195 162 138  250 247 244  247 243 240  245 241 237  250 247 244
+226 222 217  167 120 88  167 118 86  164 114 81  166 134 109  226 222 217
+245 241 237  246 242 238  250 247 244  226 222 217  169 121 86  167 117 83
+172 125 93  224 209 198  253 253 252  250 247 244  246 242 238  246 242 238
+246 242 238  246 242 238  248 245 242  253 253 252  224 209 198  171 123 90
+169 121 86  168 119 85  174 128 96  224 209 198  253 253 252  250 247 244
+248 245 242  248 245 242  251 249 248  248 245 242  210 188 172  164 114 81
+167 118 86  166 119 87  24 16 7  0 0 0  2 2 0  2 1 0
+1 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 0  1 1 0
+2 1 0  3 2 1  0 0 0  58 40 23  170 122 90  226 222 217
+250 247 244  246 242 238  247 243 239  243 238 233  226 222 217  224 209 198
+238 234 230  246 242 238  246 242 238  247 243 240  245 241 237  236 226 219
+248 245 242  246 242 238  246 242 238  246 242 238  238 234 230  226 222 217
+236 226 219  243 238 233  247 243 239  246 242 238  247 243 240  248 245 242
+226 222 217  238 234 230  247 243 240  246 242 238  247 243 239  243 238 233
+192 182 171  155 109 77  164 117 85  164 116 83  155 109 77  192 182 171
+243 238 233  247 243 239  246 242 238  250 247 244  187 146 116  172 124 92
+224 209 198  253 253 252  246 242 238  246 242 238  247 243 239  246 242 238
+246 242 238  246 242 238  246 242 238  246 242 238  253 253 252  210 188 172
+162 112 77  170 121 89  224 209 198  253 253 252  246 242 238  246 242 238
+247 243 239  247 243 239  245 241 237  247 243 240  253 253 252  210 188 172
+162 112 77  163 116 84  24 16 7  0 0 0  3 2 1  2 1 0
+1 1 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 0  2 1 0
+3 2 1  5 3 1  0 0 0  58 40 23  195 162 138  251 249 248
+246 242 238  246 242 238  245 241 237  226 222 217  174 158 143  158 123 96
+209 203 196  243 238 233  247 243 240  246 242 238  247 243 239  248 245 242
+246 242 238  246 242 238  247 243 240  238 234 230  209 203 196  166 134 109
+174 158 143  226 222 217  243 238 233  247 243 239  246 242 238  246 242 238
+250 247 244  247 243 240  246 242 238  247 243 239  245 241 237  226 222 217
+166 134 109  154 107 75  159 112 81  162 115 82  152 106 74  174 158 143
+236 226 219  247 243 239  246 242 238  248 245 242  236 226 219  226 222 217
+251 249 248  246 242 238  247 243 239  246 242 238  238 234 230  224 209 198
+224 209 198  236 226 219  246 242 238  246 242 238  247 243 239  250 247 244
+210 188 172  210 188 172  251 249 248  246 242 238  246 242 238  245 241 237
+243 238 233  245 241 237  246 242 238  246 242 238  248 245 242  248 245 242
+187 146 116  152 106 74  22 15 7  2 1 0  4 3 1  3 2 1
+2 1 0  1 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 1 0  2 2 0
+4 3 1  6 4 2  1 1 0  42 29 13  224 209 198  251 249 248
+246 242 238  247 243 240  238 234 230  192 182 171  152 106 74  152 106 74
+174 158 143  226 222 217  245 241 237  247 243 240  247 243 239  247 243 239
+247 243 239  247 243 240  243 238 233  209 203 196  166 134 109  152 106 74
+152 106 74  174 158 143  226 222 217  243 238 233  247 243 240  247 243 239
+246 242 238  247 243 239  247 243 239  245 241 237  236 226 219  174 158 143
+145 99 68  159 112 81  133 92 63  145 99 68  158 109 74  155 115 87
+209 203 196  243 238 233  247 243 239  246 242 238  248 245 242  250 247 244
+246 242 238  247 242 238  245 241 237  236 226 219  192 182 171  158 123 96
+158 123 96  192 182 171  236 226 219  247 243 239  246 242 238  247 243 239
+250 247 244  250 247 244  246 242 238  246 242 238  245 241 237  226 222 217
+192 182 171  209 203 196  238 234 230  246 242 238  246 242 238  251 249 248
+226 222 217  150 108 73  17 12 5  4 3 1  5 4 1  4 2 1
+2 2 0  1 1 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 1 0  3 2 1
+5 3 1  7 5 2  4 3 1  30 20 10  195 162 138  238 234 230
+245 241 237  245 241 237  224 209 198  163 127 97  164 114 81  172 123 89
+155 109 77  174 158 143  224 209 198  238 234 230  243 238 233  243 238 233
+243 238 233  236 226 219  209 203 196  173 140 120  155 109 77  173 125 91
+172 123 89  154 107 75  174 158 143  209 203 196  238 234 230  243 238 233
+245 241 237  245 241 237  238 234 230  226 222 217  192 182 171  143 108 80
+154 107 75  157 113 79  97 66 41  126 83 55  159 112 81  145 99 68
+173 140 120  226 222 217  245 241 237  247 243 240  246 242 238  246 242 238
+247 243 240  245 241 237  226 222 217  192 182 171  155 115 87  164 114 81
+164 114 81  155 115 87  210 188 172  238 234 230  247 243 239  246 242 238
+247 243 239  246 242 238  246 242 238  247 243 239  236 226 219  192 182 171
+143 108 80  158 123 96  209 203 196  243 238 233  247 243 240  247 243 239
+245 241 237  140 107 74  11 7 2  6 4 2  6 4 2  5 3 1
+3 2 1  1 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 1 0  4 2 1
+6 4 2  8 5 2  7 5 2  19 12 5  140 107 74  192 182 171
+226 222 217  224 209 198  174 158 143  154 107 75  169 121 86  170 124 90
+169 121 86  155 109 77  173 140 120  192 182 171  209 203 196  209 203 196
+210 188 172  174 158 143  158 123 96  157 113 79  172 123 89  171 123 90
+171 124 91  172 123 89  155 109 77  166 134 109  192 182 171  209 203 196
+209 203 196  209 203 196  192 182 171  173 140 120  143 108 80  152 106 74
+155 109 77  154 107 75  58 40 23  97 66 41  155 109 77  154 107 75
+142 97 68  174 158 143  226 222 217  243 238 233  246 242 238  246 242 238
+243 238 233  226 222 217  174 158 143  155 109 77  167 117 83  173 125 92
+173 124 92  162 112 77  158 123 96  209 203 196  238 234 230  247 243 239
+247 243 240  247 243 240  246 242 238  236 226 219  192 182 171  155 115 87
+166 116 81  152 106 74  173 140 120  226 222 217  243 238 233  238 234 230
+209 203 196  97 66 41  7 5 2  10 6 3  7 5 2  5 3 1
+3 2 1  1 1 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 1 0  4 2 1
+6 4 2  10 6 3  12 8 3  10 6 3  97 66 41  143 108 80
+166 134 109  166 134 109  150 108 73  162 115 82  167 118 86  169 121 88
+171 123 90  170 122 89  162 112 77  157 113 79  155 115 87  155 115 87
+155 115 87  157 113 79  166 116 81  172 124 91  171 123 90  171 123 90
+171 123 90  171 124 91  172 124 91  164 114 81  157 113 79  158 123 96
+158 123 96  158 123 96  143 108 80  149 107 69  158 109 74  155 109 77
+152 106 74  145 99 68  36 25 11  68 46 25  152 106 74  152 106 74
+152 106 74  145 99 68  174 158 143  209 203 196  224 209 198  224 209 198
+210 188 172  173 140 120  155 109 77  169 121 86  172 124 91  171 123 90
+171 123 90  173 125 92  162 112 77  166 134 109  210 188 172  226 222 217
+238 234 230  238 234 230  226 222 217  192 182 171  155 115 87  164 114 81
+170 122 90  164 116 83  150 108 73  174 158 143  209 203 196  192 182 171
+166 134 109  58 40 23  8 5 2  11 7 4  8 5 2  5 4 1
+3 2 1  1 1 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  2 1 0  4 2 1
+6 4 2  10 6 3  13 8 3  10 6 3  58 40 23  154 107 75
+145 99 68  149 107 69  159 112 81  162 115 82  164 117 85  166 119 87
+169 121 88  170 122 89  172 124 91  172 123 89  169 121 86  169 121 86
+170 122 88  172 124 91  172 124 91  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  172 124 91  172 123 89  168 119 85
+164 114 81  164 114 81  162 115 82  159 112 81  155 109 77  152 106 74
+145 99 68  115 77 51  26 18 7  42 29 13  140 95 66  145 99 68
+152 106 74  154 107 75  145 99 68  155 115 87  166 134 109  163 127 97
+155 115 87  162 112 77  172 123 89  172 124 91  171 123 90  171 123 90
+171 123 90  171 123 90  173 125 91  162 112 77  155 115 87  173 140 120
+174 158 143  174 158 143  173 140 120  155 109 77  166 116 81  170 122 89
+167 118 86  164 117 85  157 113 79  145 99 68  143 108 80  140 107 74
+133 92 63  30 20 10  12 8 3  12 8 3  8 5 2  6 4 2
+3 2 1  1 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 0  4 2 1
+6 4 2  10 6 3  13 8 3  16 10 4  28 19 9  137 93 64
+154 107 75  154 107 75  155 109 77  157 113 79  162 115 82  164 117 85
+168 120 88  169 121 88  170 122 89  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  170 124 90  169 121 88  169 121 88
+167 118 86  163 116 84  159 112 81  155 109 77  152 106 74  145 99 68
+145 99 68  68 46 25  28 19 9  30 20 10  97 66 41  145 99 68
+145 99 68  152 106 74  157 113 79  157 113 79  158 109 74  164 114 81
+168 119 85  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  173 124 92  169 121 86  162 112 77
+157 113 79  157 113 79  162 112 77  169 121 86  170 122 89  167 118 86
+163 116 84  159 112 81  157 113 79  154 107 75  149 107 69  152 106 74
+97 66 41  16 10 4  17 12 5  13 8 3  8 5 2  6 4 2
+3 2 1  1 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 1 0  3 2 1
+6 4 2  10 6 3  13 8 3  19 12 5  17 12 5  74 57 39
+152 106 74  152 106 74  152 106 74  154 107 75  157 113 79  162 115 82
+164 117 85  166 119 87  169 121 88  170 122 89  170 122 89  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  170 122 89  169 122 89  168 120 88  166 119 87
+163 116 84  159 112 81  155 109 77  152 106 74  145 99 68  145 99 68
+126 83 55  39 26 12  34 23 10  32 22 10  58 40 23  142 97 68
+145 99 68  149 107 69  152 106 74  157 113 79  159 112 81  164 117 85
+167 120 88  169 121 88  170 122 89  171 123 90  171 123 90  171 123 90
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  173 124 92
+172 124 91  172 123 89  170 124 90  169 121 88  166 119 87  164 117 85
+159 112 81  155 109 77  152 106 74  152 106 74  149 107 69  145 99 68
+42 29 13  17 12 5  17 12 5  12 8 3  8 5 2  5 3 1
+2 2 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 0 0  2 2 0
+5 4 1  10 6 3  13 8 3  19 12 5  20 14 6  32 22 10
+132 88 59  145 99 68  145 99 68  149 107 69  152 106 74  155 109 77
+159 112 81  163 116 84  167 118 86  168 120 88  169 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  170 122 89  167 121 88  167 120 88  164 117 85  162 115 82
+157 113 79  154 107 75  152 106 74  145 99 68  142 97 68  142 97 68
+68 46 25  30 20 10  36 25 11  36 25 11  32 22 10  97 66 41
+142 97 68  145 99 68  145 99 68  152 106 74  155 109 77  159 112 81
+162 115 82  164 117 85  168 120 88  169 121 88  169 122 89  170 122 89
+171 123 90  171 123 90  171 123 90  171 123 90  171 123 90  171 123 90
+170 122 89  169 121 88  168 120 88  166 119 87  162 115 82  159 112 81
+155 109 77  152 106 74  145 99 68  145 99 68  145 99 68  97 66 41
+20 14 6  20 14 6  17 12 5  12 8 3  7 5 2  5 3 1
+2 1 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  2 1 0
+4 3 1  8 5 2  12 8 3  17 12 5  22 15 7  20 14 6
+58 40 23  142 97 68  142 97 68  142 97 68  145 99 68  152 106 74
+154 107 75  159 112 81  162 115 82  164 117 85  166 119 87  168 120 88
+169 121 88  170 122 89  170 122 90  170 122 90  170 122 89  169 121 88
+169 121 88  166 119 87  164 117 85  162 115 82  159 112 81  155 109 77
+152 106 74  149 107 69  145 99 68  142 97 68  142 97 68  97 66 41
+32 22 10  34 23 10  34 23 10  34 23 10  32 22 10  42 29 13
+132 88 59  142 97 68  142 97 68  145 99 68  152 106 74  152 106 74
+157 113 79  159 112 81  163 116 84  167 118 86  167 120 88  167 121 88
+170 122 89  170 122 89  170 122 90  170 122 89  170 121 89  169 121 88
+167 120 88  164 117 85  163 116 84  162 115 82  157 113 79  154 107 75
+152 106 74  145 99 68  142 97 68  142 97 68  132 88 59  36 25 11
+22 15 7  20 14 6  16 10 4  10 6 3  6 4 2  3 2 1
+1 1 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 0
+3 2 1  6 4 2  10 6 3  16 10 4  20 14 6  26 18 7
+24 16 7  74 57 39  142 97 68  140 95 66  140 95 66  145 99 68
+145 99 68  152 106 74  155 109 77  157 113 79  159 112 81  162 115 82
+163 116 84  164 117 85  164 117 85  164 117 85  164 117 85  163 116 84
+163 116 84  162 115 82  159 112 81  155 109 77  154 107 75  152 106 74
+145 99 68  142 97 68  140 95 66  140 95 66  126 83 55  42 29 13
+30 20 10  32 22 10  32 22 10  32 22 10  32 22 10  28 19 9
+58 40 23  140 95 66  140 95 66  140 95 66  142 97 68  145 99 68
+152 106 74  154 107 75  157 113 79  159 112 81  162 115 82  163 116 84
+164 117 85  164 117 85  164 117 85  164 117 85  163 116 84  163 116 84
+162 115 82  159 112 81  155 109 77  154 107 75  152 106 74  145 99 68
+142 97 68  140 95 66  140 95 66  137 93 64  58 40 23  24 16 7
+24 16 7  19 12 5  13 8 3  10 6 3  5 4 1  2 2 0
+1 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+2 2 0  5 3 1  8 5 2  13 8 3  19 12 5  24 16 7
+28 19 9  32 22 10  97 66 41  140 95 66  137 93 64  140 95 66
+142 97 68  145 99 68  145 99 68  152 106 74  152 106 74  155 109 77
+155 109 77  157 113 79  157 113 79  157 113 79  157 113 79  155 109 77
+155 109 77  154 107 75  152 106 74  149 107 69  145 99 68  142 97 68
+140 95 66  137 93 64  137 93 64  126 83 55  49 35 24  28 19 9
+32 22 10  28 19 9  26 18 7  26 18 7  28 19 9  32 22 10
+28 19 9  68 46 25  140 95 66  137 93 64  137 93 64  140 95 66
+142 97 68  145 99 68  152 106 74  152 106 74  154 107 75  155 109 77
+157 113 79  157 113 79  157 113 79  157 113 79  155 109 77  155 109 77
+155 109 77  152 106 74  152 106 74  145 99 68  142 97 68  140 95 66
+137 93 64  137 93 64  137 93 64  68 46 25  26 18 7  26 18 7
+22 15 7  17 12 5  12 8 3  7 5 2  4 3 1  2 1 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 1 0  3 2 1  6 4 2  10 6 3  16 10 4  20 14 6
+26 18 7  28 19 9  36 25 11  97 66 41  137 93 64  133 92 63
+133 92 63  137 93 64  140 95 66  142 97 68  145 99 68  145 99 68
+149 107 69  152 106 74  152 106 74  152 106 74  152 106 74  149 107 69
+149 107 69  145 99 68  145 99 68  142 97 68  140 95 66  137 93 64
+133 92 63  137 93 64  126 83 55  49 35 24  28 19 9  30 20 10
+26 18 7  24 16 7  22 15 7  22 15 7  24 16 7  28 19 9
+32 22 10  30 20 10  68 46 25  133 92 63  133 92 63  133 92 63
+137 93 64  140 95 66  142 97 68  145 99 68  145 99 68  149 107 69
+152 106 74  152 106 74  152 106 74  152 106 74  152 106 74  149 107 69
+145 99 68  145 99 68  142 97 68  140 95 66  137 93 64  133 92 63
+133 92 63  132 88 59  68 46 25  28 19 9  30 20 10  24 16 7
+20 14 6  13 8 3  10 6 3  5 4 1  2 2 0  1 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  2 1 0  5 3 1  8 5 2  12 8 3  19 12 5
+24 16 7  28 19 9  32 22 10  36 25 11  74 57 39  132 88 59
+132 88 59  132 88 59  133 92 63  137 93 64  137 93 64  140 95 66
+142 97 68  142 97 68  142 97 68  142 97 68  142 97 68  142 97 68
+140 95 66  140 95 66  137 93 64  137 93 64  132 88 59  132 88 59
+132 88 59  115 77 51  42 29 13  32 22 10  32 22 10  26 18 7
+22 15 7  19 12 5  17 12 5  17 12 5  20 14 6  24 16 7
+28 19 9  32 22 10  32 22 10  68 46 25  115 77 51  132 88 59
+132 88 59  132 88 59  137 93 64  137 93 64  140 95 66  142 97 68
+142 97 68  142 97 68  142 97 68  142 97 68  142 97 68  142 97 68
+140 95 66  137 93 64  133 92 63  132 88 59  132 88 59  132 88 59
+115 77 51  58 40 23  32 22 10  32 22 10  26 18 7  20 14 6
+17 12 5  11 7 4  6 4 2  3 2 1  2 1 0  1 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 1 0  3 2 1  5 4 1  8 5 2  13 8 3
+20 14 6  24 16 7  32 22 10  36 25 11  36 25 11  58 40 23
+115 77 51  132 88 59  132 88 59  132 88 59  132 88 59  132 88 59
+133 92 63  133 92 63  133 92 63  133 92 63  133 92 63  133 92 63
+132 88 59  132 88 59  132 88 59  132 88 59  132 88 59  126 83 55
+74 57 39  42 29 13  34 23 10  32 22 10  26 18 7  22 15 7
+17 12 5  13 8 3  12 8 3  12 8 3  16 10 4  19 12 5
+24 16 7  28 19 9  34 23 10  34 23 10  49 35 24  97 66 41
+126 83 55  132 88 59  132 88 59  132 88 59  132 88 59  133 92 63
+133 92 63  133 92 63  133 92 63  133 92 63  133 92 63  133 92 63
+132 88 59  132 88 59  132 88 59  132 88 59  126 83 55  97 66 41
+42 29 13  34 23 10  34 23 10  28 19 9  24 16 7  17 12 5
+12 8 3  7 5 2  5 3 1  2 2 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  2 1 0  3 2 1  6 4 2  10 6 3
+16 10 4  20 14 6  24 16 7  32 22 10  36 25 11  36 25 11
+42 29 13  68 46 25  97 66 41  126 83 55  126 83 55  126 83 55
+126 83 55  126 83 55  126 83 55  126 83 55  126 83 55  126 83 55
+126 83 55  126 83 55  126 83 55  115 77 51  74 57 39  49 35 24
+36 25 11  36 25 11  32 22 10  26 18 7  22 15 7  17 12 5
+12 8 3  10 6 3  7 5 2  8 5 2  10 6 3  13 8 3
+19 12 5  24 16 7  28 19 9  36 25 11  36 25 11  39 26 12
+58 40 23  97 66 41  115 77 51  126 83 55  126 83 55  126 83 55
+126 83 55  126 83 55  126 83 55  126 83 55  126 83 55  126 83 55
+126 83 55  126 83 55  115 77 51  97 66 41  58 40 23  39 26 12
+36 25 11  36 25 11  28 19 9  24 16 7  19 12 5  13 8 3
+8 5 2  5 4 1  3 2 1  1 1 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 0 0  2 1 0  4 2 1  6 4 2
+10 6 3  16 10 4  20 14 6  24 16 7  30 20 10  36 25 11
+39 26 12  39 26 12  42 29 13  58 40 23  74 57 39  97 66 41
+115 77 51  115 77 51  115 77 51  115 77 51  115 77 51  115 77 51
+97 66 41  97 66 41  68 46 25  49 35 24  39 26 12  39 26 12
+36 25 11  32 22 10  26 18 7  20 14 6  17 12 5  12 8 3
+8 5 2  6 4 2  5 3 1  5 3 1  6 4 2  10 6 3
+13 8 3  19 12 5  24 16 7  28 19 9  34 23 10  39 26 12
+39 26 12  42 29 13  58 40 23  68 46 25  97 66 41  97 66 41
+115 77 51  115 77 51  115 77 51  115 77 51  115 77 51  97 66 41
+97 66 41  68 46 25  58 40 23  42 29 13  39 26 12  39 26 12
+34 23 10  28 19 9  22 15 7  19 12 5  13 8 3  8 5 2
+5 4 1  3 2 1  2 1 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 0 0  2 1 0  4 3 1
+6 4 2  10 6 3  16 10 4  19 12 5  24 16 7  28 19 9
+32 22 10  36 25 11  39 26 12  39 26 12  42 29 13  42 29 13
+49 35 24  58 40 23  58 40 23  58 40 23  58 40 23  49 35 24
+42 29 13  42 29 13  42 29 13  42 29 13  39 26 12  34 23 10
+30 20 10  24 16 7  20 14 6  17 12 5  12 8 3  8 5 2
+5 3 1  3 2 1  2 1 0  2 2 0  4 2 1  6 4 2
+10 6 3  13 8 3  19 12 5  22 15 7  26 18 7  32 22 10
+36 25 11  39 26 12  39 26 12  42 29 13  42 29 13  42 29 13
+58 40 23  58 40 23  58 40 23  58 40 23  58 40 23  42 29 13
+42 29 13  42 29 13  42 29 13  39 26 12  36 25 11  32 22 10
+26 18 7  22 15 7  17 12 5  13 8 3  8 5 2  6 4 2
+3 2 1  2 1 0  1 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 0 0  2 1 0
+4 2 1  6 4 2  10 6 3  13 8 3  17 12 5  20 14 6
+24 16 7  28 19 9  32 22 10  36 25 11  39 26 12  39 26 12
+42 29 13  42 29 13  42 29 13  42 29 13  42 29 13  42 29 13
+39 26 12  39 26 12  36 25 11  34 23 10  32 22 10  26 18 7
+22 15 7  19 12 5  16 10 4  10 6 3  7 5 2  5 3 1
+2 2 0  1 1 0  0 0 0  1 0 0  2 1 0  3 2 1
+5 4 1  8 5 2  12 8 3  17 12 5  20 14 6  24 16 7
+28 19 9  32 22 10  36 25 11  39 26 12  39 26 12  42 29 13
+42 29 13  42 29 13  42 29 13  42 29 13  42 29 13  39 26 12
+39 26 12  36 25 11  36 25 11  32 22 10  28 19 9  24 16 7
+20 14 6  16 10 4  12 8 3  8 5 2  5 4 1  3 2 1
+1 1 0  1 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+2 1 0  3 2 1  5 4 1  8 5 2  12 8 3  16 10 4
+19 12 5  20 14 6  24 16 7  28 19 9  30 20 10  32 22 10
+34 23 10  36 25 11  36 25 11  36 25 11  36 25 11  34 23 10
+32 22 10  32 22 10  28 19 9  26 18 7  22 15 7  20 14 6
+17 12 5  13 8 3  8 5 2  6 4 2  4 3 1  2 1 0
+1 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 0
+2 2 0  5 3 1  7 5 2  10 6 3  13 8 3  17 12 5
+20 14 6  24 16 7  26 18 7  30 20 10  32 22 10  32 22 10
+36 25 11  36 25 11  36 25 11  36 25 11  34 23 10  32 22 10
+32 22 10  28 19 9  26 18 7  24 16 7  20 14 6  17 12 5
+13 8 3  10 6 3  7 5 2  5 3 1  2 2 0  1 1 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  1 0 0  2 1 0  4 2 1  6 4 2  8 5 2
+12 8 3  16 10 4  19 12 5  20 14 6  22 15 7  24 16 7
+26 18 7  26 18 7  28 19 9  28 19 9  26 18 7  26 18 7
+26 18 7  24 16 7  20 14 6  20 14 6  17 12 5  13 8 3
+10 6 3  7 5 2  5 3 1  3 2 1  1 1 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 0 0  2 1 0  3 2 1  5 4 1  8 5 2  11 7 4
+16 10 4  17 12 5  20 14 6  22 15 7  24 16 7  26 18 7
+26 18 7  28 19 9  28 19 9  28 19 9  26 18 7  26 18 7
+24 16 7  22 15 7  20 14 6  17 12 5  13 8 3  11 7 4
+8 5 2  5 4 1  3 2 1  2 1 0  1 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  1 0 0  2 1 0  4 3 1
+6 4 2  8 5 2  10 6 3  13 8 3  16 10 4  17 12 5
+20 14 6  20 14 6  20 14 6  20 14 6  20 14 6  20 14 6
+19 12 5  17 12 5  13 8 3  12 8 3  10 6 3  6 4 2
+5 3 1  3 2 1  1 1 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  1 0 0  2 1 0  3 2 1  5 4 1
+7 5 2  10 6 3  13 8 3  16 10 4  17 12 5  19 12 5
+20 14 6  20 14 6  20 14 6  20 14 6  20 14 6  19 12 5
+17 12 5  16 10 4  12 8 3  10 6 3  7 5 2  5 3 1
+3 2 1  2 1 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 1 0  2 1 0  4 2 1  5 3 1  6 4 2  8 5 2
+10 6 3  11 7 4  11 7 4  11 7 4  11 7 4  10 6 3
+10 6 3  7 5 2  6 4 2  4 3 1  3 2 1  2 1 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 0
+2 1 0  3 2 1  5 3 1  6 4 2  8 5 2  10 6 3
+10 6 3  11 7 4  11 7 4  11 7 4  10 6 3  10 6 3
+8 5 2  6 4 2  5 3 1  3 2 1  2 1 0  1 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 0 0
+1 1 0  2 1 0  2 1 0  2 1 0  2 1 0  1 1 0
+1 0 0  1 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  1 0 0  1 1 0
+1 1 0  2 1 0  2 1 0  2 1 0  1 1 0  1 1 0
+1 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
diff --git a/drivers/video/pxa168fb.c b/drivers/video/pxa168fb.c
index f1460892..b153c9b2 100644
--- a/drivers/video/pxa168fb.c
+++ b/drivers/video/pxa168fb.c
@@ -4,8 +4,10 @@
  *  Copyright (C) 2008 Marvell International Ltd.
  *  All rights reserved.
  *
- *  2009-02-16  adapted from original version for PXA168/910
- *              Jun Nie <njun@marvell.com>
+ *  2009-02-16  adapted from original version for PXA168
+ *		Green Wan <gwan@marvell.com>
+ *		Jun Nie <njun@marvell.com>
+ *		Kevin Liu <kliu5@marvell.com>
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License. See the file COPYING in the main directory of this archive for
@@ -13,172 +15,500 @@
  */
 
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/errno.h>
 #include <linux/string.h>
 #include <linux/interrupt.h>
+#include <linux/console.h>
 #include <linux/slab.h>
-#include <linux/fb.h>
 #include <linux/delay.h>
 #include <linux/init.h>
-#include <linux/io.h>
 #include <linux/ioport.h>
-#include <linux/platform_device.h>
+#include <linux/cpufreq.h>
 #include <linux/dma-mapping.h>
 #include <linux/clk.h>
 #include <linux/err.h>
+#include <linux/fb.h>
 #include <linux/uaccess.h>
-#include <video/pxa168fb.h>
+#include <linux/proc_fs.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/pm_runtime.h>
+#include <mach/irqs.h>
+#include <mach/gpio.h>
+#include <mach/features.h>
+#include "pxa168fb_common.h"
+#include <mach/regs-apmu.h>
+#include <linux/memblock.h>
+#if defined(CONFIG_BACKLIGHT_KTD253) || defined(CONFIG_BACKLIGHT_KTD3102)
+#include <linux/ktd_bl.h>
+extern int wakeup_brightness;
+#endif
+#if defined(CONFIG_MACH_CS05)
+#include <mach/Quicklogic_Vxbridge_interface.h>
+#elif defined(CONFIG_MACH_GOLDEN)
+#include "../../../../arch/arm/mach-mmp/onboard/lcd_s6e63m0_param.h"
+#endif
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+
+/* interrupt timestamp collection to get:
+ * 0. ITC_NONE		don't enable any timestamp collection
+ * 1. ITC_INTERVAL	collect timestamps each time enter lcd interrupt
+ *			service, normally only display done interrupt is
+ *			enabled, should be same as LCD refresh period;
+ *			while test results shows it takes longer time
+ * 2. ITC_VSYNC		collect timestamp for display done interrupt and
+ *			vsync interrupt
+ * 3. ITC_GFX_DONE	collect timestamp for display done interrupt and
+ *			graphics layer frame done(dma finish) interrupt
+ * 4. ITC_VID_DONE	collect timestamp for display done interrupt and
+ *			video layer frame done(dma finish) interrupt
+ * 5. ITC_HANDLER	collect timestamp for display done interrupt and
+ *			main handler finish time
+ * usage:
+ * "echo x > /sys/devices/platform/pxa168-fb.0/itc" to enable/disable
+ * "cat /sys/devices/platform/pxa168-fb.0/itc" to get timestamps
+ *
+ * note: only panel path timestamp collection is supported now
+ */
+#define ITC_MAX_NUM		32
+#define ITC_NONE		(irqtm_check == 0)
+#define ITC_INTERVAL		(irqtm_check == 1)
+#define ITC_VSYNC		(irqtm_check == 2)
+#define ITC_GFX_DONE		(irqtm_check == 3)
+#define ITC_VID_DONE		(irqtm_check == 4)
+#define ITC_HANDLER		(irqtm_check == 5)
+#define gettime(val, count, update) do {			\
+	count %= ITC_MAX_NUM;					\
+	do_gettimeofday(&val[update ? count++ : count]);	\
+} while (0)
+static int ct1, ct2, irqtm_check;
+static struct timeval t0, t1[ITC_MAX_NUM], t2[ITC_MAX_NUM];
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+static atomic_t framedone = ATOMIC_INIT(0);
+atomic_t displayon = ATOMIC_INIT(0);
+#endif
+
+/* interrupt number collection to get real frame rate */
+#define VSYNC_CHECK_TIME	(10 * HZ)
+static int vsync_check;
+static int irq_count;
+static int vsync_count;
+static int dispd_count;
+static int f0_count;
+static int f1_count;
+static int vf0_count;
+static int vf1_count;
+static struct timer_list vsync_timer;
+
+#ifdef CONFIG_KERNEL_DEBUG_SEC
+extern void sec_getlog_supply_fbinfo(struct fb_info *fb);
+#endif
+
+#ifdef CONFIG_MACH_GOYA
+static struct clk *vcxo_clk;
+#endif
+#if defined(CONFIG_MACH_WILCOX)
+#define LCD_ESD_RECOVERY
+#define LCD_ESD_INTERRUPT
+#endif
+
+#if defined(LCD_ESD_RECOVERY)
+#define GPIO_ESD_DET	(19)
+extern int get_panel_id(void);
+static struct pxa168fb_info *fbi_global = NULL;
+static int esd_irq;
+static struct workqueue_struct *esd_wq;
+static struct work_struct esd_work;
+struct delayed_work esd_dwork;
+#define LCD_ESD_INTERVAL	(1000)
+#endif
+
+static void vsync_check_timer(unsigned long data)
+{
+	int path = DBG_VSYNC_PATH;
+	int mask = vsync_imask(path) | gf0_imask(path) | gf1_imask(path) |
+		vf0_imask(path) | vf1_imask(path);
+
+	/* disable count interrupts */
+	irq_mask_set(path, mask, 0);
+	irq_mask_eof(path);
+
+	vsync_check = 0;
+	del_timer(&vsync_timer);
+	pr_info("fbi %d: irq_count %d\n", path, irq_count);
+	pr_info("\tvsync_count %d\n",  vsync_count);
+	pr_info("\tdispd_count %d\n",  dispd_count);
+	pr_info("\tf0_count %d\n", f0_count);
+	pr_info("\tf1_count %d\n", f1_count);
+	pr_info("\tvf0_count %d\n", vf0_count);
+	pr_info("\tvf1_count %d\n", vf1_count);
+}
+
+void vsync_check_count()
+{
+	int path = DBG_VSYNC_PATH;
+	int mask = vsync_imask(path) | gf0_imask(path) | gf1_imask(path)
+		| vf0_imask(path) | vf1_imask(path);
 
-#include "pxa168fb.h"
+	if (vsync_check) {
+		pr_alert("count vsync ongoing, try again after 10s\n");
+		return;
+	}
+	irq_unmask_eof(path);
+	/* enable count interrupts */
+	irq_mask_set(path, mask, mask);
+	irq_status_clear(path, mask);
+
+	/* clear counts */
+	vsync_count = dispd_count = irq_count = 0;
+	f0_count = f1_count = vf0_count = vf1_count = 0;
+	ct1 = 0; memset(t1, 0, sizeof(t1));
+	ct2 = 0; memset(t2, 0, sizeof(t2));
+
+	/* trigger vsync check */
+	vsync_check = 1;
+	init_timer(&vsync_timer);
+	vsync_timer.function = vsync_check_timer;
+	mod_timer(&vsync_timer, jiffies + 10*HZ);
+}
 
 #define DEFAULT_REFRESH		60	/* Hz */
 
-static int determine_best_pix_fmt(struct fb_var_screeninfo *var)
-{
-	/*
-	 * Pseudocolor mode?
-	 */
-	if (var->bits_per_pixel == 8)
-		return PIX_FMT_PSEUDOCOLOR;
+static unsigned int max_fb_size = 0;
+static unsigned int fb_size_from_cmd = 0;
 
-	/*
-	 * Check for 565/1555.
-	 */
-	if (var->bits_per_pixel == 16 && var->red.length <= 5 &&
-	    var->green.length <= 6 && var->blue.length <= 5) {
-		if (var->transp.length == 0) {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGB565;
-			else
-				return PIX_FMT_BGR565;
-		}
+static unsigned int disp_start_addr;
+static unsigned int skip_power_on = 0;
 
-		if (var->transp.length == 1 && var->green.length <= 5) {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGB1555;
-			else
-				return PIX_FMT_BGR1555;
-		}
+/* Globals:
+ * fb_share mode: TV path graphics share same frame buffer with panel path
+ */
+int fb_share = 0;
+struct fbi_info gfx_info;
+int gfx_udflow_count = 0;
+int vid_udflow_count = 0;
+int irq_retry_count;
+int axi_err_count = 0;
+int debug_flag = 0;
+
+struct lcd_regs *get_regs(int id)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[id];
+	struct lcd_regs *regs;
 
-		/* fall through */
+	if (!fbi) {
+		pr_err("%s: failed\n", __func__);
+		BUG_ON(1);
+		return NULL;
 	}
 
-	/*
-	 * Check for 888/A888.
-	 */
-	if (var->bits_per_pixel <= 32 && var->red.length <= 8 &&
-	    var->green.length <= 8 && var->blue.length <= 8) {
-		if (var->bits_per_pixel == 24 && var->transp.length == 0) {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGB888PACK;
-			else
-				return PIX_FMT_BGR888PACK;
-		}
+	regs = (struct lcd_regs *)((unsigned)fbi->reg_base);
 
-		if (var->bits_per_pixel == 32 && var->transp.length == 8) {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGBA888;
-			else
-				return PIX_FMT_BGRA888;
-		} else {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGB888UNPACK;
-			else
-				return PIX_FMT_BGR888UNPACK;
-		}
+	if (id == 0)
+		regs = (struct lcd_regs *)((unsigned)fbi->reg_base + 0xc0);
+	if (id == 2)
+		regs = (struct lcd_regs *)((unsigned)fbi->reg_base + 0x200);
+
+	return regs;
+}
+u32 dma_ctrl_read(int id, int ctrl1)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[id];
+	u32 reg = (u32)fbi->reg_base + dma_ctrl(ctrl1, id);
 
-		/* fall through */
+	return __raw_readl(reg);
+}
+
+void dma_ctrl_write(int id, int ctrl1, u32 value)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[id];
+	u32 reg = (u32)fbi->reg_base + dma_ctrl(ctrl1, id);
+
+	__raw_writel(value, reg);
+}
+
+void dma_ctrl_set(int id, int ctrl1, u32 mask, u32 value)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[id];
+	u32 reg = (u32)fbi->reg_base + dma_ctrl(ctrl1, id);
+	u32 tmp1, tmp2;
+
+	tmp1 = tmp2 = __raw_readl(reg);
+	tmp2 &= ~mask;
+	tmp2 |= value;
+	if (tmp1 != tmp2)
+		__raw_writel(tmp2, reg);
+}
+
+void yuvsp_fmt_ctrl(u32 mask, u32 value)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 reg = (u32)fbi->reg_base + LCD_YUV420SP_FMT_CTRL;
+	u32 tmp1, tmp2;
+
+	tmp1 = tmp2 = __raw_readl(reg);
+	tmp2 &= ~mask;
+	tmp2 |= value;
+	if (tmp1 != tmp2)
+		__raw_writel(tmp2, reg);
+}
+
+/*
+ * This is a workaround for still image capture:
+ * As DxO and LCD DMA can't access DDR at the same time
+ * so when still image capture, we disable LCD DMA.
+ * After capture, re-enable the LCD DMA.
+ * flag: 1: enable LCD DMA;
+ *       0: disable LCD DMA;
+ */
+void panel_dma_ctrl(bool flag)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 reg = (u32)fbi->reg_base + LCD_SPU_DMA_CTRL0;
+	u32 tmp1, tmp2, mask;
+	unsigned long flags;
+
+	tmp1 = tmp2 = __raw_readl(reg);
+
+	if (has_feat_video_replace_graphics_dma())
+		mask = CFG_DMA_ENA_MASK;
+	else
+		mask = CFG_GRA_ENA_MASK;
+
+	spin_lock_irqsave(&fbi->var_lock, flags);
+	if (flag)
+		/* enable panel DMA */
+		tmp2 |= mask;
+	else
+		/* disable panel DMA */
+		tmp2 &= ~mask;
+
+	if (tmp1 != tmp2) {
+		fbi->dma_on = flag ? 1 : 0;
+		__raw_writel(tmp2, reg);
 	}
 
-	return -EINVAL;
+	spin_unlock_irqrestore(&fbi->var_lock, flags);
 }
 
-static void set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)
+void irq_mask_set(int id, u32 mask, u32 val)
 {
-	switch (pix_fmt) {
-	case PIX_FMT_RGB565:
-		var->bits_per_pixel = 16;
-		var->red.offset = 11;    var->red.length = 5;
-		var->green.offset = 5;   var->green.length = 6;
-		var->blue.offset = 0;    var->blue.length = 5;
-		var->transp.offset = 0;  var->transp.length = 0;
-		break;
-	case PIX_FMT_BGR565:
-		var->bits_per_pixel = 16;
-		var->red.offset = 0;     var->red.length = 5;
-		var->green.offset = 5;   var->green.length = 6;
-		var->blue.offset = 11;   var->blue.length = 5;
-		var->transp.offset = 0;  var->transp.length = 0;
-		break;
-	case PIX_FMT_RGB1555:
-		var->bits_per_pixel = 16;
-		var->red.offset = 10;    var->red.length = 5;
-		var->green.offset = 5;   var->green.length = 5;
-		var->blue.offset = 0;    var->blue.length = 5;
-		var->transp.offset = 15; var->transp.length = 1;
-		break;
-	case PIX_FMT_BGR1555:
-		var->bits_per_pixel = 16;
-		var->red.offset = 0;     var->red.length = 5;
-		var->green.offset = 5;   var->green.length = 5;
-		var->blue.offset = 10;   var->blue.length = 5;
-		var->transp.offset = 15; var->transp.length = 1;
-		break;
-	case PIX_FMT_RGB888PACK:
-		var->bits_per_pixel = 24;
-		var->red.offset = 16;    var->red.length = 8;
-		var->green.offset = 8;   var->green.length = 8;
-		var->blue.offset = 0;    var->blue.length = 8;
-		var->transp.offset = 0;  var->transp.length = 0;
+	struct pxa168fb_info *fbi = gfx_info.fbi[id];
+	u32 temp = readl(fbi->reg_base + SPU_IRQ_ENA);
+	int retry = 0;
+
+	temp &= ~mask; temp |= val;
+	writel(temp, fbi->reg_base + SPU_IRQ_ENA);
+	/* FIXME: irq register write failure */
+	while (temp != readl(fbi->reg_base + SPU_IRQ_ENA) && retry < 10000) {
+		retry++;
+		writel(temp, fbi->reg_base + SPU_IRQ_ENA);
+	}
+	if (retry)
+		irq_retry_count = retry;
+}
+
+void irq_status_clear(int id, u32 mask)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[id];
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+
+	writel(mi->isr_clear_mask & (~mask), fbi->reg_base + SPU_IRQ_ISR);
+}
+
+u32 clk_reg(int id, u32 type)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[id];
+	u32 offset = 0;
+
+	switch (type) {
+	case clk_sclk:
+		offset = id ? (id & 1 ? LCD_TCLK_DIV : LCD_PN2_SCLK_DIV)
+				: LCD_CFG_SCLK_DIV;
 		break;
-	case PIX_FMT_BGR888PACK:
-		var->bits_per_pixel = 24;
-		var->red.offset = 0;     var->red.length = 8;
-		var->green.offset = 8;   var->green.length = 8;
-		var->blue.offset = 16;   var->blue.length = 8;
-		var->transp.offset = 0;  var->transp.length = 0;
+	case clk_lvds_rd:
+		offset = LCD_LVDS_SCLK_DIV_RD;
 		break;
-	case PIX_FMT_RGBA888:
-		var->bits_per_pixel = 32;
-		var->red.offset = 16;    var->red.length = 8;
-		var->green.offset = 8;   var->green.length = 8;
-		var->blue.offset = 0;    var->blue.length = 8;
-		var->transp.offset = 24; var->transp.length = 8;
+	case clk_lvds_wr:
+		offset = LCD_LVDS_SCLK_DIV_WR;
 		break;
-	case PIX_FMT_BGRA888:
-		var->bits_per_pixel = 32;
-		var->red.offset = 0;     var->red.length = 8;
-		var->green.offset = 8;   var->green.length = 8;
-		var->blue.offset = 16;   var->blue.length = 8;
-		var->transp.offset = 24; var->transp.length = 8;
+	case clk_tclk:
+		if (id == 1)
+			offset = LCD_TCLK_DIV;
+		else if (id == 2)
+			offset = LCD_PN2_TCLK_DIV;
 		break;
-	case PIX_FMT_PSEUDOCOLOR:
-		var->bits_per_pixel = 8;
-		var->red.offset = 0;     var->red.length = 8;
-		var->green.offset = 0;   var->green.length = 8;
-		var->blue.offset = 0;    var->blue.length = 8;
-		var->transp.offset = 0;  var->transp.length = 0;
+	default:
+		pr_err("%s path %d type %x not found\n", __func__, id, type);
 		break;
 	}
+
+	if (offset)
+		return (u32)fbi->reg_base + offset;
+
+	return 0;
+}
+
+int lcd_clk_get(int id, u32 type)
+{
+	u32 reg = clk_reg(id, type), val;
+
+	if (!reg)
+		return 0;
+
+	val = __raw_readl(reg);
+	pr_debug("%s path %d type %d: 0x%x (@ 0x%x)\n", __func__,
+		id, type, val, clk_reg(id, type));
+	return val;
+}
+
+void lcd_clk_set(int id, u32 type, u32 mask, u32 val)
+{
+	u32 reg = clk_reg(id, type), tmp1, tmp2;
+
+	if (!reg)
+		return;
+
+	tmp1 = tmp2 = __raw_readl(reg);
+	tmp2 &= ~mask;
+	tmp2 |= val;
+	if (tmp1 != tmp2)
+		__raw_writel(tmp2, reg);
+
+	pr_debug("%s type %d mask %x val %x: 0x%x -> 0x%x (@ 0x%x)\n",
+		__func__, type, mask, val, tmp1, tmp2,
+		clk_reg(id, type) & 0xfff);
+}
+
+int pxa168fb_spi_send(struct pxa168fb_info *fbi, void *value,
+		int count, unsigned int spi_gpio_cs)
+{
+	u32 x, spi_byte_len;
+	u8 *cmd = (u8 *)value;
+	int i, err, isr, iopad;
+	unsigned int timeout = 0;
+
+	if (spi_gpio_cs != -1) {
+		err = gpio_request(spi_gpio_cs, "LCD_SPI_CS");
+		if (err) {
+			pr_err("failed to request GPIO for LCD CS\n");
+			return -1;
+		}
+		gpio_direction_output(spi_gpio_cs, 1);
+	}
+	/* get spi data size */
+	spi_byte_len = readl(fbi->reg_base + LCD_SPU_SPI_CTRL);
+	spi_byte_len = (spi_byte_len >> 8) & 0xff;
+	/* It should be (spi_byte_len + 7) >> 3, but spi controller
+	 * request set one less than bit length */
+	spi_byte_len = (spi_byte_len + 8) >> 3;
+	/* spi command provided by platform should be 1, 2, or 4 byte aligned */
+	if (spi_byte_len == 3)
+		spi_byte_len = 4;
+
+	/*After set mode1 it need a time to pull up the spi singals,
+	 * or it would cause the wrong waveform when send spi command,
+	 * especially on pxa910h*/
+	iopad = readl(fbi->reg_base + SPU_IOPAD_CONTROL);
+	if ((iopad & CFG_IOPADMODE_MASK) != PIN_MODE_DUMB_18_SPI)
+		writel(PIN_MODE_DUMB_18_SPI |
+			(iopad & ~CFG_IOPADMODE_MASK),
+			fbi->reg_base + SPU_IOPAD_CONTROL);
+	udelay(20);
+
+	for (i = 0; i < count; i++) {
+		if (spi_gpio_cs != -1)
+			gpio_direction_output(spi_gpio_cs, 0);
+
+		irq_status_clear(fbi->id, SPI_IRQ_MASK);
+
+		switch (spi_byte_len) {
+		case 1:
+			writel(*cmd, fbi->reg_base + LCD_SPU_SPI_TXDATA);
+			break;
+		case 2:
+			writel(*(u16 *)cmd, fbi->reg_base + LCD_SPU_SPI_TXDATA);
+			break;
+		case 4:
+			writel(*(u32 *)cmd, fbi->reg_base + LCD_SPU_SPI_TXDATA);
+			break;
+		default:
+			pr_err("Wrong spi bit length\n");
+		}
+		cmd += spi_byte_len;
+		x = readl(fbi->reg_base + LCD_SPU_SPI_CTRL);
+		x |= 0x1;
+		writel(x, fbi->reg_base + LCD_SPU_SPI_CTRL);
+		isr = readl(fbi->reg_base + SPU_IRQ_ISR);
+		timeout = 0;
+		while (!(isr & SPI_IRQ_ENA_MASK)) {
+			udelay(100);
+			isr = readl(fbi->reg_base + SPU_IRQ_ISR);
+			if (timeout++ > 100) {
+				pr_err("SPI IRQ may miss, just skip and send "
+				"the following command, count %d!\n", i);
+				break;
+			}
+		}
+		irq_status_clear(fbi->id, SPI_IRQ_MASK);
+		x = readl(fbi->reg_base + LCD_SPU_SPI_CTRL);
+		x &= ~0x1;
+		writel(x, fbi->reg_base + LCD_SPU_SPI_CTRL);
+		if (spi_gpio_cs != -1)
+			gpio_direction_output(spi_gpio_cs, 1);
+	}
+
+	if ((iopad & CFG_IOPADMODE_MASK) != PIN_MODE_DUMB_18_SPI)
+		writel(iopad, fbi->reg_base + SPU_IOPAD_CONTROL);
+
+	if (spi_gpio_cs != -1)
+		gpio_free(spi_gpio_cs);
+	return 0;
+}
+
+static int pxa168fb_power(struct pxa168fb_info *fbi,
+		struct pxa168fb_mach_info *mi, int on)
+{
+	int ret = 0;
+	pr_debug("fbi->active %d on %d\n", fbi->active, on);
+	if ((mi->spi_ctrl != -1) && (mi->spi_ctrl & CFG_SPI_ENA_MASK))
+		writel(mi->spi_ctrl, fbi->reg_base + LCD_SPU_SPI_CTRL);
+
+	if ((mi->pxa168fb_lcd_power) && \
+		((fbi->active && !on) || (!fbi->active && on)))
+		ret = mi->pxa168fb_lcd_power(fbi, mi->spi_gpio_cs,
+					mi->spi_gpio_reset, on);
+
+	if ((mi->spi_ctrl != -1) && (mi->spi_ctrl & CFG_SPI_ENA_MASK))
+		writel(mi->spi_ctrl & ~CFG_SPI_ENA_MASK,
+			fbi->reg_base + LCD_SPU_SPI_CTRL);
+	return ret;
 }
 
 static void set_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var,
-		     struct fb_videomode *mode, int pix_fmt, int ystretch)
+		     const struct fb_videomode *mode, int pix_fmt, int ystretch)
 {
-	struct fb_info *info = fbi->info;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
 
+	dev_dbg(fbi->fb_info->dev, "Enter %s\n", __func__);
 	set_pix_fmt(var, pix_fmt);
 
 	var->xres = mode->xres;
 	var->yres = mode->yres;
 	var->xres_virtual = max(var->xres, var->xres_virtual);
-	if (ystretch)
-		var->yres_virtual = info->fix.smem_len /
-			(var->xres_virtual * (var->bits_per_pixel >> 3));
+	if (ystretch && !fb_share)
+		var->yres_virtual = var->yres * ((ystretch > 1) ? ystretch : 2);
 	else
 		var->yres_virtual = max(var->yres, var->yres_virtual);
 	var->grayscale = 0;
+	var->width = mi->width;
+	var->height = mi->height;
 	var->accel_flags = FB_ACCEL_NONE;
 	var->pixclock = mode->pixclock;
 	var->left_margin = mode->left_margin;
@@ -192,45 +522,93 @@ static void set_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var,
 	var->rotate = FB_ROTATE_UR;
 }
 
-static int pxa168fb_check_var(struct fb_var_screeninfo *var,
-			      struct fb_info *info)
+/*
+ * When DSI is used to refresh panel, the timing configuration should
+ * follow the rules below:
+ * 1.Because Async fifo exists between the pixel clock and byte clock
+ *   domain, so there is no strict ratio requirement between pix_clk
+ *   and byte_clk, we just need to meet the following inequation to
+ *   promise the data supply from LCD controller:
+ *   pix_clk * (nbytes/pixel) >= byte_clk * lane_num
+ *   (nbyte/pixel: the real byte in DSI transmission)
+ *   a)16-bit format n = 2; b) 18-bit packed format n = 18/8 = 9/4;
+ *   c)18-bit unpacked format  n=3; d)24-bit format  n=3;
+ *   if lane_num = 1 or 2, we can configure pix_clk/byte_clk = 1:1 >
+ *   lane_num/nbytes/pixel
+ *   if lane_num = 3 or 4, we can configure pix_clk/byte_clk = 2:1 >
+ *   lane_num/nbytes/pixel
+ * 2.The horizontal sync for LCD is synchronized from DSI,
+ *    so the refresh rate calculation should base on the
+ *    configuration of DSI.
+ *    byte_clk = (h_total * nbytes/pixel) * v_total * fps / lane_num;
+ */
+static void disp_clk_cal_set(struct pxa168fb_info *fbi)
 {
-	struct pxa168fb_info *fbi = info->par;
-	int pix_fmt;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct fb_var_screeninfo *var = &fbi->fb_info->var;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	u32 clk_req, clk_real, frm_pixels;
+	u64 div;
 
-	/*
-	 * Determine which pixel format we're going to use.
-	 */
-	pix_fmt = determine_best_pix_fmt(var);
-	if (pix_fmt < 0)
-		return pix_fmt;
-	set_pix_fmt(var, pix_fmt);
-	fbi->pix_fmt = pix_fmt;
+	if (!var->pixclock) {
+		pr_err("invalid pixclock\n");
+		return;
+	}
 
-	/*
-	 * Basic geometry sanity checks.
-	 */
-	if (var->xoffset + var->xres > var->xres_virtual)
-		return -EINVAL;
-	if (var->yoffset + var->yres > var->yres_virtual)
-		return -EINVAL;
-	if (var->xres + var->right_margin +
-	    var->hsync_len + var->left_margin > 2048)
-		return -EINVAL;
-	if (var->yres + var->lower_margin +
-	    var->vsync_len + var->upper_margin > 2048)
-		return -EINVAL;
+	if (!fbi->path_clk) {
+		pr_info("no path clock\n");
+		return;
+	}
 
-	/*
-	 * Check size of framebuffer.
-	 */
-	if (var->xres_virtual * var->yres_virtual *
-	    (var->bits_per_pixel >> 3) > info->fix.smem_len)
-		return -EINVAL;
+	if (!fbi->phy_clk && (mi->phy_type & (DSI | DSI2DPI | LVDS))) {
+		pr_info("no phy clock while DSI\n");
+		return;
+	}
 
-	return 0;
+	div = 1000000000000ll;
+	do_div(div, var->pixclock);
+	clk_req = (u32)div;
+
+	/*cal clock according to pixclock */
+	if (mi->phy_type & (DSI | DSI2DPI | LVDS)) {
+		u32 phy_rate, path_rate;
+
+		phy_rate = clk_req * di->bpp / di->lanes; /*bit clock*/
+		path_rate = phy_rate / ((di->lanes > 2) ? 4 : 8);
+
+		clk_set_rate(fbi->phy_clk, phy_rate);
+		pr_info("set phy clock %d Mhz\n", phy_rate / 1000000);
+
+		clk_set_rate(fbi->path_clk, path_rate);
+		pr_info("set path clock %d Mhz\n", path_rate / 1000000);
+
+		path_rate = clk_get_rate(fbi->path_clk)/1000000;
+		phy_rate = clk_get_rate(fbi->phy_clk);
+		clk_real = phy_rate * di->lanes / di->bpp / 1000000;
+		phy_rate /= 1000000;
+		mi->sclk_default = phy_rate; /* unit MHz */
+		pr_info("real path clock %d Mhz, phy clock %d Mhz, pixclock %d Mhz\n",
+				(int) path_rate, (int) phy_rate, clk_real);
+	} else {
+		clk_set_rate(fbi->path_clk, clk_req);
+		pr_info("set path clock %d Mhz\n", clk_req / 1000000);
+
+		clk_real = clk_get_rate(fbi->path_clk);
+		mi->sclk_default = clk_real / 1000000; /* unit MHz */
+		pr_info("real path clock %d Mhz\n", clk_real / 1000000);
+	}
+
+	div = 1000000000000ll;
+	do_div(div, clk_real*1000000);
+	var->pixclock = (u32)div;
+	frm_pixels = (var->xres + var->left_margin + var->hsync_len
+		 + var->right_margin) * (var->yres + var->upper_margin
+		+ var->vsync_len + var->lower_margin);
+	fbi->frm_usec = (var->pixclock / 1000) * frm_pixels / 1000;
+	pr_info("result fps = %d\n", (int) (1000000 / fbi->frm_usec));
 }
 
+
 /*
  * The hardware clock divider has an integer and a fractional
  * stage:
@@ -241,124 +619,108 @@ static int pxa168fb_check_var(struct fb_var_screeninfo *var,
  * Calculate integer and fractional divider for given clk_in
  * and clk_out.
  */
-static void set_clock_divider(struct pxa168fb_info *fbi,
-			      const struct fb_videomode *m)
+static void set_clock_divider(struct pxa168fb_info *fbi)
 {
-	int divider_int;
-	int needed_pixclk;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct fb_var_screeninfo *var = &fbi->fb_info->var;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	u32 divider_int, needed_pixclk, val, x = 0;
 	u64 div_result;
-	u32 x = 0;
 
-	/*
-	 * Notice: The field pixclock is used by linux fb
+	/* check whether divider is fixed by platform */
+	if (mi->sclk_div) {
+		val = mi->sclk_div;
+		/*for 480i and 576i, pixel clock should be half of
+		 * the spec value because of pixel repetition */
+		if ((var->yres == 480 || var->yres == 576) &&
+			(var->vmode == FB_VMODE_INTERLACED)) {
+			val &= ~0xf;
+			val |= (mi->sclk_div & 0xf) << 1;
+		}
+
+		/* for lcd controller */
+		lcd_clk_set(fbi->id, clk_sclk, 0xfffff0ff, val & (~0xf00));
+
+		/* FIXME: for dsi/lvds clock */
+		if ((mi->phy_type & (DSI | DSI2DPI)) && di) {
+			if (di->id == 1)
+				lcd_clk_set(0, clk_sclk, 0xf00, val & 0xf00);
+			else if (di->id == 2) {
+				/* LCD_TCLK_DIV 0x9c: (11:8) for DSI2 */
+				lcd_clk_set(1, clk_sclk, 0xf00, val & 0xf00);
+				/* LCD_PN2_SCLK_DIV 0x1ec: (31:28) (7:0) for DSI2 */
+				lcd_clk_set(2, clk_sclk, 0xfffff0ff, val & (~0xf00));
+			}
+		} else if (mi->phy_type & LVDS)
+			lcd_clk_set(fbi->id, clk_lvds_wr, 0xffffffff, val);
+
+			divider_int = mi->sclk_div & CLK_INT_DIV_MASK;
+			if (!divider_int)
+			divider_int = 1;
+			if (!clk_get_rate(fbi->clk)) {
+			pr_err("%s: fbi->clk get rate null\n",
+					__func__);
+			return;
+		}
+		if ((mi->phy_type & (DSI | DSI2DPI)) && di)
+			x = (clk_get_rate(fbi->clk) * di->lanes) /
+				(di->bpp * 1000);
+		else
+			x = clk_get_rate(fbi->clk) / divider_int / 1000;
+
+		var->pixclock = 1000000000 / x;
+		pr_debug("%s pixclock %d x %d divider_int %d\n",
+			__func__, var->pixclock, x, divider_int);
+		x = var->xres + var->left_margin + var->hsync_len +
+			var->right_margin;
+		fbi->frm_usec = var->pixclock * (var->yres + var->upper_margin
+			+ var->vsync_len + var->lower_margin) / 1000 * x / 1000;
+		return;
+	}
+
+	/* Notice: The field pixclock is used by linux fb
 	 * is in pixel second. E.g. struct fb_videomode &
 	 * struct fb_var_screeninfo
 	 */
 
-	/*
-	 * Check input values.
-	 */
-	if (!m || !m->pixclock || !m->refresh) {
-		dev_err(fbi->dev, "Input refresh or pixclock is wrong.\n");
+	/* Check input values */
+	dev_dbg(fbi->fb_info->dev, "Enter %s\n", __func__);
+	if (!var->pixclock) {
+		pr_err("Input refresh or pixclock is wrong.\n");
 		return;
 	}
 
-	/*
-	 * Using PLL/AXI clock.
-	 */
-	x = 0x80000000;
+	/* Using PLL/AXI clock. */
+	x = 0x40000000;
 
-	/*
-	 * Calc divider according to refresh rate.
-	 */
+	/* Calc divider according to refresh rate */
 	div_result = 1000000000000ll;
-	do_div(div_result, m->pixclock);
+	do_div(div_result, var->pixclock);
 	needed_pixclk = (u32)div_result;
 
 	divider_int = clk_get_rate(fbi->clk) / needed_pixclk;
 
 	/* check whether divisor is too small. */
 	if (divider_int < 2) {
-		dev_warn(fbi->dev, "Warning: clock source is too slow."
-				"Try smaller resolution\n");
+		pr_warning("Warning: clock source is too slow."
+				 "Try smaller resolution\n");
 		divider_int = 2;
 	}
 
-	/*
-	 * Set setting to reg.
-	 */
+	/* Set setting to reg */
 	x |= divider_int;
-	writel(x, fbi->reg_base + LCD_CFG_SCLK_DIV);
-}
-
-static void set_dma_control0(struct pxa168fb_info *fbi)
-{
-	u32 x;
-
-	/*
-	 * Set bit to enable graphics DMA.
-	 */
-	x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
-	x &= ~CFG_GRA_ENA_MASK;
-	x |= fbi->active ? CFG_GRA_ENA(1) : CFG_GRA_ENA(0);
-
-	/*
-	 * If we are in a pseudo-color mode, we need to enable
-	 * palette lookup.
-	 */
-	if (fbi->pix_fmt == PIX_FMT_PSEUDOCOLOR)
-		x |= 0x10000000;
-
-	/*
-	 * Configure hardware pixel format.
-	 */
-	x &= ~(0xF << 16);
-	x |= (fbi->pix_fmt >> 1) << 16;
-
-	/*
-	 * Check red and blue pixel swap.
-	 * 1. source data swap
-	 * 2. panel output data swap
-	 */
-	x &= ~(1 << 12);
-	x |= ((fbi->pix_fmt & 1) ^ (fbi->panel_rbswap)) << 12;
-
-	writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL0);
-}
-
-static void set_dma_control1(struct pxa168fb_info *fbi, int sync)
-{
-	u32 x;
-
-	/*
-	 * Configure default bits: vsync triggers DMA, gated clock
-	 * enable, power save enable, configure alpha registers to
-	 * display 100% graphics, and set pixel command.
-	 */
-	x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1);
-	x |= 0x2032ff81;
-
-	/*
-	 * We trigger DMA on the falling edge of vsync if vsync is
-	 * active low, or on the rising edge if vsync is active high.
-	 */
-	if (!(sync & FB_SYNC_VERT_HIGH_ACT))
-		x |= 0x08000000;
-
-	writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL1);
+	if (fbi->id != 1)
+		lcd_clk_set(fbi->id, clk_sclk, CLK_INT_DIV_MASK, x);
 }
 
-static void set_graphics_start(struct fb_info *info, int xoffset, int yoffset)
+void enable_graphic_layer(int id)
 {
-	struct pxa168fb_info *fbi = info->par;
-	struct fb_var_screeninfo *var = &info->var;
-	int pixel_offset;
-	unsigned long addr;
+	int val;
 
-	pixel_offset = (yoffset * var->xres_virtual) + xoffset;
-
-	addr = fbi->fb_start_dma + (pixel_offset * (var->bits_per_pixel >> 3));
-	writel(addr, fbi->reg_base + LCD_CFG_GRA_START_ADDR0);
+	val = check_modex_active(gfx_info.fbi[id]);
+	if (!(dma_ctrl_read(id, 0) & CFG_GRA_ENA_MASK)) {
+		dma_ctrl_set(id, 0, CFG_GRA_ENA_MASK, CFG_GRA_ENA(val));
+	}
 }
 
 static void set_dumb_panel_control(struct fb_info *info)
@@ -367,14 +729,18 @@ static void set_dumb_panel_control(struct fb_info *info)
 	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
 	u32 x;
 
-	/*
-	 * Preserve enable flag.
-	 */
-	x = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL) & 0x00000001;
+	dev_dbg(info->dev, "Enter %s\n", __func__);
 
+	/* Preserve enable flag */
+	x = readl(fbi->reg_base + intf_ctrl(fbi->id));
 	x |= (fbi->is_blanked ? 0x7 : mi->dumb_mode) << 28;
-	x |= mi->gpio_output_data << 20;
-	x |= mi->gpio_output_mask << 12;
+	if (fbi->id == 1) {
+		/* enable AXI urgent flag and vblank(for 3d formater) */
+		x |= (0xff << 16) | TV_VBLNK_VALID_EN;
+	} else {
+		x |= mi->gpio_output_data << 20;
+		x |= mi->gpio_output_mask << 12;
+	}
 	x |= mi->panel_rgb_reverse_lanes ? 0x00000080 : 0;
 	x |= mi->invert_composite_blank ? 0x00000040 : 0;
 	x |= (info->var.sync & FB_SYNC_COMP_HIGH_ACT) ? 0x00000020 : 0;
@@ -382,94 +748,187 @@ static void set_dumb_panel_control(struct fb_info *info)
 	x |= (info->var.sync & FB_SYNC_VERT_HIGH_ACT) ? 0 : 0x00000008;
 	x |= (info->var.sync & FB_SYNC_HOR_HIGH_ACT) ? 0 : 0x00000004;
 	x |= mi->invert_pixclock ? 0x00000002 : 0;
+	writel(x, fbi->reg_base + intf_ctrl(fbi->id));	/* FIXME */
+}
 
-	writel(x, fbi->reg_base + LCD_SPU_DUMB_CTRL);
+static void set_tv_interlace(void)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[1];
+	struct fb_info *info = fbi->fb_info;
+	struct fb_var_screeninfo *v = &info->var;
+	struct lcd_regs *regs = get_regs(fbi->id);
+	int x, y, yres, interlaced = 0, vsync_ctrl;
+	static int vdma_enabled, vdma_layer;
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+
+	dev_dbg(info->dev, "Enter %s\n", __func__);
+
+	if (v->vmode & FB_VMODE_INTERLACED) {
+		/* enable interlaced mode */
+		interlaced = CFG_TV_INTERLACE_EN | CFG_TV_NIB;
+
+		x = v->xres + v->right_margin + v->hsync_len + v->left_margin;
+
+		/* interlaced mode, recalculate vertical pixels */
+		yres = v->yres >> 1;
+		y = yres + v->lower_margin + v->vsync_len + v->upper_margin;
+
+		/* even field */
+		writel(((y + 1) << 16) | yres,
+			fbi->reg_base + LCD_TV_V_H_TOTAL_FLD);
+		writel(((v->upper_margin) << 16) | (v->lower_margin),
+			fbi->reg_base + LCD_TV_V_PORCH_FLD);
+		vsync_ctrl = (x >> 1) - v->left_margin - v->hsync_len;
+		writel(vsync_ctrl << 16 | vsync_ctrl,
+			fbi->reg_base + LCD_TV_SEPXLCNT_FLD);
+
+		/* odd field */
+		writel((yres << 16) | v->xres, &regs->screen_active);
+		writel((y << 16) | x, &regs->screen_size);
+	}
+	dma_ctrl_set(fbi->id, 1, CFG_TV_INTERLACE_EN | CFG_TV_NIB, interlaced);
+
+	lcd_vdma = request_vdma(fbi->id, 0);
+	if (!lcd_vdma) {
+		lcd_vdma = request_vdma(fbi->id, 1);
+		if (!lcd_vdma)
+			return;
+	}
+	if (v->vmode & FB_VMODE_INTERLACED) {
+		/* interlaced mode, TV path VDMA should be disabled */
+		if (lcd_vdma->enable) {
+			vdma_enabled = 1;
+			vdma_layer = lcd_vdma->vid;
+			pxa688_vdma_en(lcd_vdma, 0, lcd_vdma->vid);
+		}
+	} else if (vdma_enabled) {
+		/* vdma recovery */
+		vdma_enabled = 0;
+		pxa688_vdma_en(lcd_vdma, 1, vdma_layer);
+	}
 }
 
 static void set_dumb_screen_dimensions(struct fb_info *info)
 {
 	struct pxa168fb_info *fbi = info->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
 	struct fb_var_screeninfo *v = &info->var;
-	int x;
-	int y;
+	struct lcd_regs *regs = get_regs(fbi->id);
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	int x, y, h_porch, vec = 10, vsync_ctrl, value;
+
+	dev_dbg(info->dev, "Enter %s fb %d regs->screen_active 0x%p\n",
+			__func__, fbi->id, &regs->screen_active);
+
+	/* resolution, active */
+	writel(((v->yres+mi->last_dummy_lines) << 16) | v->xres, &regs->screen_active);
+
+	if ((mi->phy_type & (DSI2DPI | DSI)) && di) {
+		vec = ((di->lanes <= 2) ? 1 : 2) * 10 * di->bpp / 8 / di->lanes;
+
+		h_porch = (v->xres + v->right_margin) * vec / 10 - v->xres;
+		h_porch = (v->left_margin * vec / 10) << 16 | h_porch;
+		vsync_ctrl = 0x01330133;
+
+		value = readl(fbi->reg_base + TIMING_MASTER_CONTROL);
+		if (di->master_mode)
+			value = timing_master_config(fbi->id,
+					di->id - 1, di->id - 1);
+		else
+			value &= ~(timing_master_config(fbi->id,
+					di->id - 1, di->id - 1));
+		writel(value, fbi->reg_base + TIMING_MASTER_CONTROL);
+	} else {
+		h_porch = (v->left_margin) << 16 | v->right_margin;
+
+		if ((fbi->id == 0) || (fbi->id == 2))
+			vsync_ctrl = ((v->width + v->left_margin) << 16)
+				| (v->width + v->left_margin);
+		else
+			vsync_ctrl = ((v->xres + v->right_margin) << 16)
+				| (v->xres + v->right_margin);
+	}
+	/* h porch, left/right margin */
+	writel(h_porch, &regs->screen_h_porch);
+
+	/* v porch, upper/lower margin */
+	writel((v->upper_margin << 16) | v->lower_margin,
+			&regs->screen_v_porch);
 
 	x = v->xres + v->right_margin + v->hsync_len + v->left_margin;
-	y = v->yres + v->lower_margin + v->vsync_len + v->upper_margin;
+	x = x * vec / 10;
+	y = v->yres + mi->last_dummy_lines + v->lower_margin + v->vsync_len + v->upper_margin;
+	/* screen total size */
+	writel((y << 16) | x, &regs->screen_size);
+
+	/* vsync ctrl */
+	writel(vsync_ctrl, &regs->vsync_ctrl);	/* FIXME */
+
+}
+
+static void pxa168fb_clear_framebuffer(struct fb_info *info)
+{
+	struct pxa168fb_info *fbi = info->par;
 
-	writel((y << 16) | x, fbi->reg_base + LCD_SPUT_V_H_TOTAL);
+	memset(fbi->fb_start, 0, fbi->fb_size);
 }
 
 static int pxa168fb_set_par(struct fb_info *info)
 {
 	struct pxa168fb_info *fbi = info->par;
 	struct fb_var_screeninfo *var = &info->var;
-	struct fb_videomode mode;
-	u32 x;
-	struct pxa168fb_mach_info *mi;
+	struct regshadow *shadowreg = &fbi->shadowreg;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	int pix_fmt;
+	u32 flags;
 
-	mi = fbi->dev->platform_data;
+	dev_dbg(info->dev, "Enter %s, graphics layer\n", __func__);
 
-	/*
-	 * Set additional mode info.
-	 */
+	/* Determine which pixel format we're going to use */
+	pix_fmt = determine_best_pix_fmt(var, fbi);
+	if (pix_fmt < 0)
+		return pix_fmt;
+
+	fbi->pix_fmt = pix_fmt;
+	set_pix_fmt(var, pix_fmt);
+
+	if (!var->xres_virtual)
+		var->xres_virtual = var->xres;
+	if (!var->yres_virtual)
+		var->yres_virtual = var->yres *
+			((mi->mmap > 1) ? mi->mmap : 2);
+	var->grayscale = 0;
+	var->accel_flags = FB_ACCEL_NONE;
+	var->rotate = FB_ROTATE_UR;
+
+	/* Set additional mode info */
 	if (fbi->pix_fmt == PIX_FMT_PSEUDOCOLOR)
 		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
 	else
 		info->fix.visual = FB_VISUAL_TRUECOLOR;
-	info->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
-	info->fix.ypanstep = var->yres;
-
-	/*
-	 * Disable panel output while we setup the display.
-	 */
-	x = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL);
-	writel(x & ~1, fbi->reg_base + LCD_SPU_DUMB_CTRL);
-
-	/*
-	 * Configure global panel parameters.
-	 */
-	writel((var->yres << 16) | var->xres,
-		fbi->reg_base + LCD_SPU_V_H_ACTIVE);
 
-	/*
-	 * convet var to video mode
-	 */
-	fb_var_to_videomode(&mode, &info->var);
-
-	/* Calculate clock divisor. */
-	set_clock_divider(fbi, &mode);
+	info->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
 
-	/* Configure dma ctrl regs. */
-	set_dma_control0(fbi);
-	set_dma_control1(fbi, info->var.sync);
+	/* when lcd is suspend, read or write lcd controller's
+	* register is not effective, so just return*/
+	if (!(gfx_info.fbi[fbi->id]->active)) {
+		printk(KERN_DEBUG"LCD is not active, don't touch hardware\n");
+		return 0;
+	}
 
-	/*
-	 * Configure graphics DMA parameters.
-	 */
-	x = readl(fbi->reg_base + LCD_CFG_GRA_PITCH);
-	x = (x & ~0xFFFF) | ((var->xres_virtual * var->bits_per_pixel) >> 3);
-	writel(x, fbi->reg_base + LCD_CFG_GRA_PITCH);
-	writel((var->yres << 16) | var->xres,
-		fbi->reg_base + LCD_SPU_GRA_HPXL_VLN);
-	writel((var->yres << 16) | var->xres,
-		fbi->reg_base + LCD_SPU_GZM_HPXL_VLN);
+	set_dumb_screen_dimensions(info);
 
-	/*
-	 * Configure dumb panel ctrl regs & timings.
-	 */
+	/* Configure dumb panel ctrl regs & timings */
 	set_dumb_panel_control(info);
-	set_dumb_screen_dimensions(info);
 
-	writel((var->left_margin << 16) | var->right_margin,
-			fbi->reg_base + LCD_SPU_H_PORCH);
-	writel((var->upper_margin << 16) | var->lower_margin,
-			fbi->reg_base + LCD_SPU_V_PORCH);
+	if (gfx_info.fbi[1] && (fbi->id == 1))
+		set_tv_interlace();
 
-	/*
-	 * Re-enable panel output.
-	 */
-	x = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL);
-	writel(x | 1, fbi->reg_base + LCD_SPU_DUMB_CTRL);
+	flags = UPDATE_ADDR | UPDATE_MODE | UPDATE_VIEW;
+	pxa168fb_set_var(info, shadowreg, flags);
+
+	if (!NEED_VSYNC(fbi))
+		pxa168fb_set_regs(fbi, shadowreg);
 
 	return 0;
 }
@@ -481,9 +940,7 @@ static unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
 
 static u32 to_rgb(u16 red, u16 green, u16 blue)
 {
-	red >>= 8;
-	green >>= 8;
-	blue >>= 8;
+	red >>= 8; green >>= 8; blue >>= 8;
 
 	return (red << 16) | (green << 8) | blue;
 }
@@ -518,9 +975,40 @@ pxa168fb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,
 static int pxa168fb_blank(int blank, struct fb_info *info)
 {
 	struct pxa168fb_info *fbi = info->par;
+	int is_blanked = fbi->is_blanked;
 
 	fbi->is_blanked = (blank == FB_BLANK_UNBLANK) ? 0 : 1;
+#ifdef CONFIG_PM
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+			/* do nothing if already blank */
+			if (is_blanked)
+				return 0;
+
+			/* de-activate the device */
+			pm_runtime_put_sync_suspend(fbi->dev);
+			break;
+
+	case FB_BLANK_UNBLANK:
+			/* do nothing if already unblank */
+			if (!is_blanked)
+				return 0;
+
+			/* activate the device */
+			pm_runtime_get_sync(fbi->dev);
+#ifdef CONFIG_ANDROID
+			set_dma_active(fbi);
+#endif
+			break;
+	default:
+			break;
+	}
+#else
 	set_dumb_panel_control(info);
+#endif
 
 	return 0;
 }
@@ -528,29 +1016,474 @@ static int pxa168fb_blank(int blank, struct fb_info *info)
 static int pxa168fb_pan_display(struct fb_var_screeninfo *var,
 				struct fb_info *info)
 {
-	set_graphics_start(info, var->xoffset, var->yoffset);
+	struct pxa168fb_info *fbi = info->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+
+	dev_dbg(info->dev, "Enter %s\n", __func__);
 
+	set_start_address(info, var->xoffset, var->yoffset, &fbi->shadowreg);
+	fbi->shadowreg.flags |= UPDATE_ADDR;
+	if (fbi->shadowreg.flags == UPDATE_ADDR)
+		/* only if address needs to be updated */
+		pxa168fb_set_regs(fbi, &fbi->shadowreg);
+	/*
+	 *if only 2 buffers, wait for vsync for each pan display
+	 *if 3 buffurs support, and two buffers deliverd in one vsync,
+	 * second frame need to wait for vsync
+	 */
+	if ((mi->mmap < 3 || atomic_dec_and_test(&fbi->vsync_cnt)) &&
+			NEED_VSYNC(fbi)) {
+		dev_dbg(info->dev, "need to wait for vsync, vsync_cnt = %d\n",
+				atomic_read(&fbi->vsync_cnt));
+		wait_for_vsync(fbi, SYNC_SELF);
+	}
 	return 0;
 }
 
-static irqreturn_t pxa168fb_handle_irq(int irq, void *dev_id)
+#ifdef CONFIG_EOF_FC_WORKAROUND
+static irqreturn_t pxa168fb_threaded_handle_irq(int irq, void *dev_id)
 {
-	struct pxa168fb_info *fbi = dev_id;
-	u32 isr = readl(fbi->reg_base + SPU_IRQ_ISR);
-
-	if ((isr & GRA_FRAME_IRQ0_ENA_MASK)) {
+	if (atomic_read(&framedone)) {
+		if (cpu_is_pxa988_z3() || cpu_is_pxa986_z3())
+			wakeup_ddr_fc_seq();
+		atomic_set(&framedone, 0);
+	}
 
-		writel(isr & (~GRA_FRAME_IRQ0_ENA_MASK),
-			fbi->reg_base + SPU_IRQ_ISR);
+	return IRQ_HANDLED;
+}
+#endif
 
-		return IRQ_HANDLED;
+#ifdef CONFIG_DISP_DFC
+extern atomic_t disp_dfc;
+extern atomic_t disp_pll1;
+#endif
+static irqreturn_t pxa168fb_handle_irq(int irq, void *dev_id)
+{
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)dev_id;
+	u32 isr_en = readl(fbi->reg_base + SPU_IRQ_ISR) &
+		readl(fbi->reg_base + SPU_IRQ_ENA);
+	struct pxa168fb_mach_info *mi;
+	u32 id, dispd, err, sts;
+
+#ifdef CONFIG_DISP_DFC
+	if (atomic_read(&disp_dfc) && (isr_en & display_done_imask(0))
+		&& !(isr_en & vsync_imask(0))) {
+		mi = fbi->dev->platform_data;
+		lcd_clk_set(fbi->id, clk_sclk, 0xffffffff, mi->sclk_div);
+		if (atomic_read(&disp_pll1))
+			__raw_writel(mi->sclk_rst, (void __iomem *)APMU_LCD);
+		atomic_set(&disp_dfc, 0);
 	}
-	return IRQ_NONE;
-}
+#endif
 
-static struct fb_ops pxa168fb_ops = {
+#ifdef CONFIG_EOF_FC_WORKAROUND
+	if (isr_en & display_done_imask(0))
+		atomic_set(&framedone, 1);
+#endif
+
+#ifdef CONFIG_VIDEO_MVISP
+	if (has_feat_isp_reset()) {
+		if (isr_en & display_done_imask(0))
+			isp_reset_clock();
+	}
+#endif
+	if (ITC_INTERVAL) {
+		gettime(t1, ct1, 0);
+
+		t0 = ct1 ? t1[ct1 - 1] : t1[ITC_MAX_NUM - 1];
+		if (t0.tv_sec) {
+			t2[ct2].tv_usec = t1[ct1].tv_usec -
+				t0.tv_usec;
+			if (t1[ct1].tv_sec > t0.tv_sec)
+				t2[ct2].tv_usec += 1000000;
+		}
+		ct1++; ct2++; ct2 %= ITC_MAX_NUM;
+	}
+
+	do {
+		irq_status_clear(0, isr_en);
+		/* display done irq */
+		dispd = isr_en & display_done_imasks;
+		if (dispd) {
+			for (id = 0; id < 2; id++) {
+				sts = dispd & display_done_imask(id);
+				if (sts) {
+					if (vsync_check &&
+						id == DBG_VSYNC_PATH) {
+						if (!ITC_INTERVAL)
+							gettime(t1, ct1, 1);
+						dispd_count++;
+					}
+#ifdef CONFIG_MMP_V4L2_OVERLAY
+					mmp_v4l2_isr(id);
+#endif
+					pxa168_fb_isr(id);
+
+					if (ITC_HANDLER && vsync_check &&
+						id == DBG_VSYNC_PATH)
+						gettime(t2, ct2, 1);
+				}
+			}
+		}
+
+		/* LCD under run error detect */
+		err = isr_en & err_imasks;
+		if (err) {
+			for (id = 0; id < 3; id++) {
+				if (err & gfx_udflow_imask(id)) {
+					gfx_udflow_count++;
+					if (DBG_ERR_IRQ)
+						pr_err("fb%d gfx udflow\n", id);
+				}
+				if (err & vid_udflow_imask(id)) {
+					vid_udflow_count++;
+					if (DBG_ERR_IRQ)
+						pr_err("fb%d vid udflow\n", id);
+				}
+			}
+			if (err & AXI_BUS_ERROR_IRQ_ENA_MASK) {
+				axi_err_count++;
+				if (DBG_ERR_IRQ)
+					pr_info("axi bus err\n");
+			}
+			if (err & AXI_LATENCY_TOO_LONG_IRQ_ENA_MASK) {
+				axi_err_count++;
+				if (DBG_ERR_IRQ)
+					pr_info("axi lantency too long\n");
+			}
+		}
+
+		/* count interrupts numbers in 10s */
+		if (vsync_check) {
+			id = DBG_VSYNC_PATH;
+			if (isr_en & path_imasks(id))
+				irq_count++;
+			if (isr_en & gf0_imask(id)) {
+				if (ITC_GFX_DONE)
+					gettime(t2, ct2, 1);
+				f0_count++;
+			}
+			if (isr_en & gf1_imask(id)) {
+				if (ITC_GFX_DONE)
+					gettime(t2, ct2, 1);
+				f1_count++;
+			}
+			if (isr_en & vf0_imask(id)) {
+				if (ITC_VID_DONE)
+					gettime(t2, ct2, 1);
+				vf0_count++;
+			}
+			if (isr_en & vf1_imask(id)) {
+				if (ITC_VID_DONE)
+					gettime(t2, ct2, 1);
+				vf1_count++;
+			}
+			if (isr_en & vsync_imask(id)) {
+				if (ITC_VSYNC)
+					gettime(t2, ct2, 1);
+				vsync_count++;
+			}
+		}
+	} while (((isr_en = readl(fbi->reg_base + SPU_IRQ_ISR) &
+			readl(fbi->reg_base + SPU_IRQ_ENA)) &
+			(path_imasks(0) | path_imasks(1) | err_imasks)) &&
+			!(irqtm_check && vsync_check));
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+	return IRQ_WAKE_THREAD;
+#else
+	return IRQ_HANDLED;
+#endif
+}
+
+#ifdef CONFIG_DYNAMIC_PRINTK_DEBUG
+static void debug_identify_called_ioctl(struct fb_info *info, int cmd,
+					 unsigned long arg)
+{
+	switch (cmd) {
+	case FB_IOCTL_CLEAR_FRAMEBUFFER:
+		dev_dbg(info->dev, "FB_IOCTL_CLEAR_FRAMEBUFFER\n");
+		break;
+	case FB_IOCTL_PUT_SWAP_GRAPHIC_RED_BLUE:
+		dev_dbg(info->dev, "FB_IOCTL_PUT_SWAP_GRAPHIC_RED_BLUE\
+			 with arg = %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_PUT_SWAP_GRAPHIC_U_V:
+		dev_dbg(info->dev, "FB_IOCTL_PUT_SWAP_GRAPHIC_U_V with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_PUT_SWAP_GRAPHIC_Y_UV:
+		dev_dbg(info->dev, "FB_IOCTL_PUT_SWAP_GRAPHIC_Y_UV with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_PUT_VIDEO_ALPHABLEND:
+		dev_dbg(info->dev, "FB_IOCTL_PUT_VIDEO_ALPHABLEND with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_PUT_GLOBAL_ALPHABLEND:
+		dev_dbg(info->dev, "FB_IOCTL_PUT_GLOBAL_ALPHABLEND with arg = %08x\n",
+			 (unsigned int) arg);
+		break;
+	case FB_IOCTL_PUT_GRAPHIC_ALPHABLEND:
+		dev_dbg(info->dev, "FB_IOCTL_PUT_GRAPHIC_ALPHABLEND with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_FLIP_VID_BUFFER:
+		dev_dbg(info->dev, "FB_IOCTL_FLIP_VID_BUFFER with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_FLIP_VSYNC:
+		dev_dbg(info->dev, "FB_IOCTL_FLIP_VSYNC with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_GET_FREELIST:
+		dev_dbg(info->dev, "FB_IOCTL_GET_FREELIST with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_SWITCH_GRA_OVLY:
+		dev_dbg(info->dev, "FB_IOCTL_SWITCH_GRA_OVLY with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	}
+}
+#endif
+
+static int pxa168_graphic_ioctl(struct fb_info *info, unsigned int cmd,
+				 unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int blendval;
+	int val, mask, gra_on;
+	unsigned long flags;
+	unsigned char param;
+	struct pxa168fb_info *fbi = info->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct mvdisp_partdisp grap;
+	struct mvdisp_vdma vdma;
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+
+#ifdef CONFIG_DYNAMIC_PRINTK_DEBUG
+	debug_identify_called_ioctl(info, cmd, arg);
+#endif
+	dev_dbg(info->dev, "%s cmd 0x%x\n", __func__, cmd);
+
+	switch (cmd) {
+
+	case FB_IOCTL_CLEAR_FRAMEBUFFER:
+		pxa168fb_clear_framebuffer(info);
+		break;
+	case FB_IOCTL_WAIT_VSYNC:
+		param = (arg & 0x3);
+		wait_for_vsync(fbi, param);
+		break;
+	case FB_IOCTL_WAIT_VSYNC_ON:
+		fbi->wait_vsync = 1;
+		break;
+	case FB_IOCTL_WAIT_VSYNC_OFF:
+		fbi->wait_vsync = 0;
+		break;
+	case FB_IOCTL_PUT_VIDEO_ALPHABLEND:
+		/* This puts the blending control to the Video layer */
+		mask = CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK;
+		val = CFG_ALPHA_MODE(0) | CFG_ALPHA(0xff);
+		dma_ctrl_set(fbi->id, 1, mask, val);
+		break;
+
+	case FB_IOCTL_PUT_GLOBAL_ALPHABLEND:
+		/*  The userspace application can specify a byte value for
+		 *  the amount of global blend between the video layer and
+		 *  the graphic layer.
+		 *  The alpha blending is per the formula below:
+		 *  P = (V[P] * blendval/255) + (G[P] * (1 - blendval/255))
+		 *
+		 *  where: P = Pixel value, V = Video Layer, G = Graphic Layer
+		 */
+		blendval = (arg & 0xff);
+		mask = CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK;
+		val = CFG_ALPHA_MODE(2) | CFG_ALPHA(blendval);
+		dma_ctrl_set(fbi->id, 1, mask, val);
+		break;
+
+	case FB_IOCTL_PUT_GRAPHIC_ALPHABLEND:
+		/*  This puts the blending back to the default mode of
+		 * allowing the graphic layer to do pixel level blending.
+		 */
+		mask = CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK;
+		val = CFG_ALPHA_MODE(1) | CFG_ALPHA(0x0);
+		dma_ctrl_set(fbi->id, 1, mask, val);
+		break;
+
+	case FB_IOCTL_SWAP_GRAPHIC_RED_BLUE:
+		param = (arg & 0x1);
+		mask = CFG_GRA_SWAPRB_MASK;
+		val = CFG_GRA_SWAPRB(param);
+		dma_ctrl_set(fbi->id, 0, mask, val);
+		break;
+
+	case FB_IOCTL_SWAP_GRAPHIC_U_V:
+		param = (arg & 0x1);
+		mask = CFG_GRA_SWAPUV_MASK;
+		val = CFG_GRA_SWAPUV(param);
+		dma_ctrl_set(fbi->id, 0, mask, val);
+		break;
+
+	case FB_IOCTL_SWAP_GRAPHIC_Y_UV:
+		param = (arg & 0x1);
+		mask = CFG_GRA_SWAPYU_MASK;
+		val = CFG_GRA_SWAPYU(param);
+		dma_ctrl_set(fbi->id, 0, mask, val);
+		break;
+
+	case FB_IOCTL_FLIP_VSYNC:
+		return flip_buffer_vsync(info, arg);
+	case FB_IOCTL_FLIP_VID_BUFFER:
+		val = flip_buffer(info, arg);
+		return val;
+	case FB_IOCTL_GET_FREELIST:
+		return get_freelist(info, arg);
+
+	case FB_IOCTL_SWITCH_GRA_OVLY:
+		if (copy_from_user(&gra_on, argp, sizeof(int)))
+			return -EFAULT;
+
+		spin_lock_irqsave(&fbi->var_lock, flags);
+		fbi->dma_on = gra_on ? 1 : 0;
+		mask = CFG_GRA_ENA_MASK;
+		val = CFG_GRA_ENA(check_modex_active(fbi));
+		if (!val && fbi->active) {
+			pxa688_vdma_release(fbi->id, fbi->vid);
+			/* switch off, disable DMA */
+			dma_ctrl_set(fbi->id, 0, mask, val);
+		}
+
+		printk(KERN_DEBUG"SWITCH_GRA_OVLY fbi %d dma_on %d, val %d\n",
+			fbi->id, fbi->dma_on, val);
+
+		spin_unlock_irqrestore(&fbi->var_lock, flags);
+		break;
+
+	case FB_IOCTL_GRA_PARTDISP:
+		if (copy_from_user(&grap, argp, sizeof(grap)))
+			return -EFAULT;
+		return pxa688fb_partdisp_set(grap);
+		break;
+
+	case FB_IOCTL_GAMMA_SET:
+#ifdef CONFIG_PXA688_MISC
+		if (copy_from_user(&fbi->gamma, argp, sizeof(fbi->gamma)))
+			return -EFAULT;
+		return gamma_set(fbi->id, fbi->gamma.flag, fbi->gamma.table);
+#else
+		return -EINVAL;
+#endif
+		break;
+
+	case FB_IOCTL_VDMA_SET:
+		if (copy_from_user(&vdma, argp, sizeof(vdma)))
+			return -EFAULT;
+		lcd_vdma = request_vdma(vdma.path, vdma.layer);
+		if (!lcd_vdma) {
+			if (vdma.enable)
+				pr_err("request fail, vdma is occupied!\n");
+			return -EINVAL;
+		}
+		if (!lcd_vdma->sram_size && vdma.enable) {
+			pr_err("ERR: SRAM size is 0KB!!!!\n");
+			return -EINVAL;
+		}
+		return pxa688_vdma_en(lcd_vdma, vdma.enable, vdma.layer);
+
+	default:
+		if (mi->ioctl)
+			return mi->ioctl(info, cmd, arg);
+		else
+			pr_warning("%s: unknown IOCTL 0x%x\n", __func__, cmd);
+		break;
+
+	}
+	return 0;
+}
+
+static int pxa168fb_open(struct fb_info *info, int user)
+{
+	struct pxa168fb_mach_info *mi;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	struct _sVideoBufferAddr *new_addr = &fbi->surface.videoBufferAddr;
+
+	if (fbi->debug & (1<<4))
+		return 0;
+
+	pr_info("%s GFX layer, fbi %d opened %d times ----\n",
+		 __func__, fbi->id, atomic_read(&fbi->op_count));
+
+	/* Save screen info */
+	fbi->var_bak = *var;
+
+	mi = fbi->dev->platform_data;
+
+	memset(new_addr, 0, sizeof(struct _sVideoBufferAddr));
+	fbi->surface.videoMode = -1;
+	fbi->surface.viewPortInfo.srcWidth = var->xres;
+	fbi->surface.viewPortInfo.srcHeight = var->yres;
+
+	set_pix_fmt(var, fbi->pix_fmt);
+
+	if (mutex_is_locked(&fbi->access_ok))
+		mutex_unlock(&fbi->access_ok);
+
+	/* increase open count */
+	atomic_inc(&fbi->op_count);
+
+	return 0;
+}
+
+static int pxa168fb_release(struct fb_info *info, int user)
+{
+	struct fb_var_screeninfo *var = &info->var;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)info->par;
+	struct regshadow *shadowreg = &fbi->shadowreg;
+	u32 flags;
+
+	if (fbi->debug & (1<<4))
+		return 0;
+
+	pr_info("%s GFX layer, fbi %d opened %d times ----\n",
+		__func__, fbi->id, atomic_read(&fbi->op_count));
+
+	if (atomic_dec_and_test(&fbi->op_count))
+		pxa688_vdma_release(fbi->id, fbi->vid);
+
+	/* Turn off compatibility mode */
+	var->nonstd &= ~0xff000000;
+	fbi->compat_mode = 0;
+
+	memset(&fbi->surface, 0, sizeof(struct _sOvlySurface));
+	fbi->surface.videoMode = -1;
+
+	/* clear buffer list */
+	clear_buffer(fbi);
+
+	/* Recovery screen info */
+	*var = fbi->var_bak;
+
+	fbi->pix_fmt = determine_best_pix_fmt(var, fbi);
+	flags = UPDATE_ADDR | UPDATE_MODE | UPDATE_VIEW;
+	pxa168fb_set_var(info, shadowreg, flags);
+
+	if (NEED_VSYNC(fbi))
+		wait_for_vsync(fbi, SYNC_SELF);
+	else
+		pxa168fb_set_regs(fbi, shadowreg);
+
+	return 0;
+}
+
+static struct fb_ops pxa168fb_ops = {
 	.owner		= THIS_MODULE,
 	.fb_check_var	= pxa168fb_check_var,
+	.fb_open	= pxa168fb_open,
+	.fb_release	= pxa168fb_release,
 	.fb_set_par	= pxa168fb_set_par,
 	.fb_setcolreg	= pxa168fb_setcolreg,
 	.fb_blank	= pxa168fb_blank,
@@ -558,47 +1491,742 @@ static struct fb_ops pxa168fb_ops = {
 	.fb_fillrect	= cfb_fillrect,
 	.fb_copyarea	= cfb_copyarea,
 	.fb_imageblit	= cfb_imageblit,
+	.fb_ioctl       = pxa168_graphic_ioctl,
 };
 
-static int __devinit pxa168fb_init_mode(struct fb_info *info,
+static int pxa168fb_init_mode(struct fb_info *info,
 			      struct pxa168fb_mach_info *mi)
 {
 	struct pxa168fb_info *fbi = info->par;
 	struct fb_var_screeninfo *var = &info->var;
 	int ret = 0;
-	u32 total_w, total_h, refresh;
-	u64 div_result;
+	u32 refresh;
 	const struct fb_videomode *m;
 
-	/*
-	 * Set default value
-	 */
+	dev_dbg(info->dev, "Enter %s\n", __func__);
+
+	/* Set default value */
 	refresh = DEFAULT_REFRESH;
 
+	/* If has bootargs, apply it first */
+	if (fbi->dft_vmode.xres && fbi->dft_vmode.yres &&
+	    fbi->dft_vmode.refresh) {
+		/* set data according bootargs */
+		var->xres = fbi->dft_vmode.xres;
+		var->yres = fbi->dft_vmode.yres;
+		refresh = fbi->dft_vmode.refresh;
+	}
+
 	/* try to find best video mode. */
 	m = fb_find_best_mode(&info->var, &info->modelist);
 	if (m)
 		fb_videomode_to_var(&info->var, m);
 
 	/* Init settings. */
-	var->xres_virtual = var->xres;
-	var->yres_virtual = info->fix.smem_len /
-		(var->xres_virtual * (var->bits_per_pixel >> 3));
-	dev_dbg(fbi->dev, "pxa168fb: find best mode: res = %dx%d\n",
-				var->xres, var->yres);
-
-	/* correct pixclock. */
-	total_w = var->xres + var->left_margin + var->right_margin +
-		  var->hsync_len;
-	total_h = var->yres + var->upper_margin + var->lower_margin +
-		  var->vsync_len;
+	if (mi->xres_alignment)
+		var->xres_virtual = ALIGN(var->xres, mi->xres_alignment);
+	else
+		var->xres_virtual = var->xres;
 
-	div_result = 1000000000000ll;
-	do_div(div_result, total_w * total_h * refresh);
-	var->pixclock = (u32)div_result;
+	if (mi->yres_alignment)
+		var->yres_virtual = ALIGN(var->yres, mi->yres_alignment) * 2;
+	else
+		var->yres_virtual = var->yres * 2;
+	if (!var->pixclock) {
+		u32 total_w, total_h;
+		u64 div_result;
+
+		/* correct pixclock. */
+		total_w = var->xres + var->left_margin + var->right_margin +
+			var->hsync_len;
+		total_h = var->yres + var->upper_margin + var->lower_margin +
+			var->vsync_len;
+
+		div_result = 1000000000000ll;
+		do_div(div_result, total_w * total_h * refresh);
+		var->pixclock = (u32)div_result;
+	}
+	return ret;
+}
+
+static void pxa168fb_set_default(struct pxa168fb_info *fbi,
+		struct pxa168fb_mach_info *mi)
+{
+	struct lcd_regs *regs = get_regs(fbi->id);
+	u32 dma_ctrl1 = 0x2032ff81, flag, tmp;
+
+	if (has_feat_video_replace_graphics_dma())
+		dma_ctrl1 = 0x20320081;
+	/*
+	 * LCD Global control(LCD_TOP_CTRL) should be configed before
+	 * any other LCD registers read/write, or there maybe issues.
+	 */
+	tmp = readl(fbi->reg_base + LCD_TOP_CTRL);
+	tmp |= 0xfff0;		/* FIXME */
+	if (has_feat_video_replace_graphics_dma())
+		tmp |= 0x1 << 22;	/*TV DMA object go to panel */
+	writel(tmp, fbi->reg_base + LCD_TOP_CTRL);
+
+	if (has_feat_video_replace_graphics_dma()) {
+		tmp = readl(fbi->reg_base + LCD_AFA_ALL2ONE);
+		tmp &= 0xfffffcf0;
+
+		/*
+		 * PN video DMA as first layer, TV video DMA as second layer;
+		 * select panel path configured alpha by default when panel and
+		 * TV path videos overlaid.
+		 */
+		tmp |= 0x208;
+		writel(tmp, fbi->reg_base + LCD_AFA_ALL2ONE);
+	}
+
+	/* Configure default register values */
+	writel(mi->io_pad_ctrl, fbi->reg_base + SPU_IOPAD_CONTROL);
+	/* enable 16 cycle burst length to get better formance */
+
+	writel(0x00000000, &regs->blank_color);
+	writel(0x00000000, &regs->g_1);
+	writel(0x00000000, &regs->g_start);
+
+	/* Configure default bits: vsync triggers DMA,
+	 * power save enable, configure alpha registers to
+	 * display 100% graphics, and set pixel command.
+	 */
+	if (fbi->id == 1) {
+		if (mi->phy_type & (DSI2DPI | DSI))
+			dma_ctrl1 = 0xa03eff00;
+		else
+			dma_ctrl1 = 0x203eff00;	/* FIXME */
+	}
+
+	/*
+	 * vsync in LCD internal controller is always positive,
+	 * we default configure dma trigger @vsync falling edge,
+	 * so that DMA idle time between DMA frame done and
+	 *  next DMA transfer begin can be as large as possible
+	 */
+	dma_ctrl1 |= CFG_VSYNC_INV_MASK;
+	dma_ctrl_write(fbi->id, 1, dma_ctrl1);
+
+	/*
+	 * 1.enable multiple burst request in DMA AXI
+	 * bus arbiter for faster read if not tv path;
+	 * 2.enable horizontal smooth filter;
+	 */
+	tmp = CFG_GRA_HSMOOTH_MASK | CFG_DMA_HSMOOTH_MASK;
+	flag = CFG_ARBFAST_ENA(1) | tmp;
+	if (fbi->id != 1)
+		dma_ctrl_set(fbi->id, 0, flag, flag);
+	else
+		dma_ctrl_set(fbi->id, 0, flag, tmp);
+
+	fbi->irq_mask = readl(fbi->reg_base + SPU_IRQ_ENA);
+}
+
+static int __init get_fb_size(char *str)
+{
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	max_fb_size = n;
+	fb_size_from_cmd = 1;
+	return 1;
+}
+__setup("fb_size=", get_fb_size);
+
+static int __init get_fb_share(char *str)
+{
+	fb_share = 1;
+	return 1;
+}
+__setup("fb_share", get_fb_share);
+
+static int __init get_boot_startaddr(char *str)
+{
+	u32 fb_address;
+	char *endp;
+
+	fb_address = memparse(str, &endp);
+	disp_start_addr = fb_address;
+#ifndef CONFIG_MACH_LT02
+	skip_power_on = 1;
+#endif
+	printk("get_boot_startaddr: fb_address = 0x%8x\n", fb_address);
+	return 1;
+}
+early_param("disp_start_addr", get_boot_startaddr);
+
+void pxa988_reserve_fb_mem(void)
+{
+	u32 fb_size_align;
+
+	if (!skip_power_on)
+		return;
+
+	/* make sure that reserved base address and size is MB aligned */
+	if (DEFAULT_FB_SIZE != (DEFAULT_FB_SIZE & (~0xfffff)))
+		fb_size_align = (DEFAULT_FB_SIZE & (~0xfffff)) + 0x100000;
+
+	if (disp_start_addr != (disp_start_addr & (~0xfffff)))
+		pr_err("%s: disp_start_addr is not MB aligned, 0x%8x\n", __func__, disp_start_addr);
+
+	BUG_ON(memblock_reserve(disp_start_addr, fb_size_align) != 0);
+	memblock_free(disp_start_addr, fb_size_align);
+	memblock_remove(disp_start_addr, fb_size_align);
+	printk(KERN_INFO "Reserving fb memory: addr[0x%8x], size[0x%8x]\n",
+				(unsigned)disp_start_addr, (unsigned)fb_size_align);
+}
+
+static int init_once;
+static int pxa168fb_disable(struct pxa168fb_info *fbi)
+{
+	struct fb_info *info = fbi->fb_info;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct pxa168fb_mipi_lcd_driver *lcd_driver = mi->lcd_driver;
+	u32 mask = CFG_GRA_ENA_MASK;
+	u32 x;
+
+	pr_info("pxa168fb.%d disable +\n", fbi->id);
+	if (lcd_driver)
+		lcd_driver->disable(fbi);
+
+	if (mi->exter_brige_pwr)
+		mi->exter_brige_pwr(fbi,0);
+
+#if defined (CONFIG_MACH_CS02)
+	/* disable external panel power */
+	if (pxa168fb_power(fbi, mi, 0))
+		pr_err("%s %d pxa168fb_power control failed!\n",
+				__func__, __LINE__);
+#endif
+
+	if (mi->phy_type & (DSI | DSI2DPI))
+	{
+#if defined(CONFIG_MACH_WILCOX)	
+		dsi_set_panel_intf(fbi,0);
+
+
+		dsi_cclk_set(fbi, 0);
+		dsi_reset_dsi_module(fbi);
+	
+		dsi_dphy_force_ulps_mode(fbi);
+#else
+		dsi_reset(fbi, 1);
+#endif		
+	}
+
+	/* stop dma transaction */
+#ifndef CONFIG_MMP_V4L2_OVERLAY
+	mask |= CFG_DMA_ENA_MASK;
+#endif
+	dma_ctrl_set(fbi->id, 0, mask, 0);
+	/* Disable DMA path, it will reset the blank idle signal */
+	x = readl(fbi->reg_base + intf_ctrl(fbi->id));
+	writel(x & (~CFG_DUMB_ENA_MASK), fbi->reg_base + intf_ctrl(fbi->id));
+
+	/* disable external panel power */
+	if (pxa168fb_power(fbi, mi, 0))
+		pr_err("%s %d pxa168fb_power control failed!\n",
+				__func__, __LINE__);
+
+	spin_lock(&fbi->var_lock);
+	fbi->active = 0;
+
+	/* Before disable lcd clk, disable all lcd interrupts */
+	if (!fbi->id) {
+		/* Only operate on panel path is enough */
+		fbi->irq_mask = readl(fbi->reg_base + SPU_IRQ_ENA);
+		irq_mask_set(fbi->id, 0xffffffff, 0);
+	}
+	spin_unlock(&fbi->var_lock);
+
+	mutex_lock(&fbi->access_ok);
+	if (mi->no_legacy_clk && fbi->id != 1) {
+		if (fbi->phy_clk)
+			clk_disable(fbi->phy_clk);
+		if (fbi->path_clk)
+			clk_disable(fbi->path_clk);
+	} else if (fbi->id != 1) {
+		/* disable pixel clock, expect TV path which need it
+		 * for audio playback @ early suspend */
+		lcd_clk_set(fbi->id, clk_sclk, SCLK_DISABLE, SCLK_DISABLE);
+	}
+	mutex_unlock(&fbi->access_ok);
+	pr_info("pxa168fb.%d disable -\n", fbi->id);
+	return 0;
+
+}
+
+static int pxa168fb_enable(struct pxa168fb_info *fbi)
+{
+	struct fb_info *info = fbi->fb_info;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	u32 x;
+
+	pr_info("pxa168fb.%d enable +\n", fbi->id);
+
+	mutex_lock(&fbi->access_ok);
+	/* Calculate clock divisor. */
+	if (!init_once) {
+		pxa168fb_set_default(fbi, mi);	/* FIXME */
+		/* fbi clk exists = legacy */
+		if (mi->no_legacy_clk)
+			disp_clk_cal_set(fbi);
+		else
+			set_clock_divider(fbi);
+		init_once = 1;
+	}
+
+	if (mi->no_legacy_clk && fbi->id != 1) {
+		if (fbi->path_clk)
+			clk_enable(fbi->path_clk);
+		if (fbi->phy_clk)
+			clk_enable(fbi->phy_clk);
+	} else if (fbi->id != 1)
+		/* enable pixel clock */
+		lcd_clk_set(fbi->id, clk_sclk, SCLK_DISABLE, 0);
+	mutex_unlock(&fbi->access_ok);
+
+	/* enable external panel power */
+	if (pxa168fb_power(fbi, mi, 1)) {
+		pr_err("%s %d pxa168fb_power control failed!\n",
+				__func__, __LINE__);
+		return -EINVAL;
+	}
+
+	/* initialize external phy if needed */
+	if (mi->phy_init && mi->phy_init(fbi)) {
+		pr_err("%s fbi %d phy error\n", __func__, fbi->id);
+		return -EIO;
+	}
+
+	/* restore gamma correction table */
+	gamma_set(fbi->id, fbi->gamma.flag, fbi->gamma.table);
+
+	spin_lock(&fbi->var_lock);
+	/*After enable lcd clk, restore lcd interrupts*/
+	if (!fbi->id)
+		irq_mask_set(fbi->id, 0xffffffff, fbi->irq_mask);
+
+	fbi->active = 1;
+	spin_unlock(&fbi->var_lock);
+
+	/* restore dma after resume */
+#ifndef CONFIG_ANDROID
+	set_dma_active(fbi);
+#ifndef CONFIG_MMP_V4L2_OVERLAY
+	if (ovly_info.fbi[fbi->id])
+		set_dma_active(ovly_info.fbi[fbi->id]);
+#endif
+#endif
+	/* Need enable the DMA path */
+	x = readl(fbi->reg_base + intf_ctrl(fbi->id));
+	writel(x | CFG_DUMB_ENA_MASK, fbi->reg_base + intf_ctrl(fbi->id));
+
+	pr_info("pxa168fb.%d enable -\n", fbi->id);
+	return 0;
+}
+
+int pxa168fb_reinit(struct pxa168fb_info *fbi)
+{
+#if defined(CONFIG_BACKLIGHT_KTD253) || defined(CONFIG_BACKLIGHT_KTD3102)
+	backlight_set_brightness(0);
+#endif
+	pxa168fb_disable(fbi);
+	pxa168fb_enable(fbi);
+	set_dma_active(fbi);
+#if defined(CONFIG_BACKLIGHT_KTD253) || defined(CONFIG_BACKLIGHT_KTD3102)
+	backlight_set_brightness(wakeup_brightness);
+#elif defined(CONFIG_MACH_GOLDEN)
+	s6e63m0_gamma_set();
+#endif
+
+	return 0;
+}
+
+static int _pxa168fb_suspend(struct pxa168fb_info *fbi)
+{
+	struct fb_info *info = fbi->fb_info;
+
+	pr_info("pxa168fb.%d suspend +\n", fbi->id);
+	mutex_lock(&fbi->output_lock);
+#ifdef LCD_ESD_RECOVERY
+#ifdef LCD_ESD_INTERRUPT
+	if (esd_irq) {
+		/*
+		 * Block pending interrupt after irq disabled.
+		 * if CONFIG_HARDIRQS_SW_RESEND is set, 
+		 * pending irq is re-send when irq is enabled.
+		 */
+		irq_set_irq_type(esd_irq, IRQF_TRIGGER_NONE);
+		disable_irq(esd_irq);
+		pr_info("%s, disable esd_irq : %d\n", __func__, esd_irq);
+	}
+#endif
+#endif
+	fbi->output_on = false;
+#if defined(CONFIG_BACKLIGHT_KTD253) || defined(CONFIG_BACKLIGHT_KTD3102)
+	ktd_backlight_disable();
+	backlight_set_brightness(0);
+#endif
+#if !defined(CONFIG_MACH_GOLDEN)
+	pxa168fb_clear_framebuffer(info);
+#endif	
+	/* notify others */
+	fb_set_suspend(info, 1);
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+	atomic_set(&displayon, 0);
+	if (atomic_read(&ddr_fc_trigger)) {
+		if (cpu_is_pxa988_z3() || cpu_is_pxa986_z3())
+			wakeup_ddr_fc_seq();
+	}
+#endif
+	pxa168fb_disable(fbi);
+	if (!has_feat_video_replace_graphics_dma()) {
+		/* release D1P LPM constraint */
+		pm_qos_update_request(&fbi->qos_idle,
+				PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+	}
+
+#ifdef CONFIG_MACH_GOYA
+       clk_disable(vcxo_clk);
+#endif
+
+	mutex_unlock(&fbi->output_lock);
+	pr_info("pxa168fb.%d suspend -\n", fbi->id);
+	return 0;
+}
+
+static int _pxa168fb_resume(struct pxa168fb_info *fbi)
+{
+	struct fb_info *info = fbi->fb_info;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	u32 x;
 
+	mutex_lock(&fbi->output_lock);
+#ifdef CONFIG_MACH_GOYA
+       clk_enable(vcxo_clk);
+#endif
+	pr_info("pxa168fb.%d resume +\n", fbi->id);
+	pxa168fb_enable(fbi);
+
+	/* notify others */
+	fb_set_suspend(info, 0);
+	msleep(80);
+
+#if defined(CONFIG_BACKLIGHT_KTD253) || defined(CONFIG_BACKLIGHT_KTD3102)
+	backlight_set_brightness(wakeup_brightness);
+	ktd_backlight_enable();
+#endif
+#if defined(CONFIG_MACH_CS05)
+	hx8369_backlight_updata();
+#elif defined(CONFIG_MACH_GOLDEN)
+//    if(!fbi->skip_pw_on)
+//    	s6e63m0_gamma_set();
+#endif
+	fbi->output_on = true;
+#ifdef LCD_ESD_RECOVERY
+	if (!fbi->skip_pw_on && esd_irq) {
+#ifdef LCD_ESD_INTERRUPT
+		pr_info("%s, enable esd_irq : %d\n", __func__, esd_irq);
+		enable_irq(esd_irq);
+		irq_set_irq_type(esd_irq, IRQF_TRIGGER_RISING);
+#else
+		schedule_delayed_work(&esd_dwork,
+				msecs_to_jiffies(LCD_ESD_INTERVAL));
+#endif
+	}
+#endif
+	mutex_unlock(&fbi->output_lock);
+	pr_info("pxa168fb.%d resume -\n", fbi->id);
+	return 0;
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static int pxa168fb_runtime_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = _pxa168fb_suspend(fbi);
+	return ret;
+}
+
+static int pxa168fb_runtime_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = _pxa168fb_resume(fbi);
 	return ret;
 }
+#endif /* CONFIG_PM_RUNTIME */
+
+static void vsync_notify_work(struct work_struct *data)
+{
+	struct pxa168fb_info *fbi;
+
+	fbi = container_of(data, struct pxa168fb_info, vsync_work);
+	sysfs_notify(&fbi->dev->kobj, NULL, "vsync_ts");
+}
+
+static size_t vsync_help(char *buf)
+{
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "commands:\n");
+	mvdisp_dump(f, " - dump path(pn/tv/pn2:0/1/2) graphics layer"
+			" wait vsync @ pan_display or not\n");
+	mvdisp_dump(f, "\tcat vsync\n");
+	mvdisp_dump(f, " - enable[1]/disable[0] wait vsync @ pan_display\n");
+	mvdisp_dump(f, "\techo [en/dis:1/0] > vsync\n");
+	mvdisp_dump(f, " - enable[1]/disable[0] vsync uevent report\n");
+	mvdisp_dump(f, "\techo [en/dis:u1/u0] > vsync\n");
+
+	return s;
+}
+
+static ssize_t vsync_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	int s = 0;
+
+	s += sprintf(buf, "path %d wait vsync @ pan_display %s\n",
+			 fbi->id, fbi->wait_vsync ? "enabled" : "disabled");
+	s += sprintf(buf + s, "%s vsync uevent report\n\n",
+			 fbi->vsync_en ? "enable" : "disable");
+	s += sprintf(buf + s, "vsyn: irq enable count: %d\n\n",
+			 atomic_read(&fbi->irq_en_count));
+
+	s += vsync_help(buf + s);
+
+	return s;
+}
+
+static ssize_t vsync_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	char *endp;
+
+	if (sysfs_streq(buf, "u1")) {
+		fbi->vsync_en = 1;
+		irq_unmask_eof(fbi->id);
+	} else if (sysfs_streq(buf, "u0")) {
+		fbi->vsync_en = 0;
+		irq_mask_eof(fbi->id);
+	} else if (simple_strtoul(buf, &endp, 0) != 1)
+		pr_err("%s %d erro input of wait vsync flag\n",\
+			__func__, __LINE__);
+
+	dev_dbg(fbi->dev, "fbi->vsync_en = %d, fbi->wait_vsync = %d\n",
+			fbi->vsync_en, fbi->wait_vsync);
+	return size;
+}
+static DEVICE_ATTR(vsync, S_IRUGO | S_IWUSR, vsync_show, vsync_store);
+
+/* Get time stamp of vsync */
+static ssize_t vsync_ts_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+
+	if (!fbi->vsync_en)
+		return 0;
+
+	return sprintf(buf, "%llx\n", fbi->vsync_ts_nano);
+}
+static DEVICE_ATTR(vsync_ts, S_IRUGO, vsync_ts_show, NULL);
+
+static ssize_t itc_help(char *buf)
+{
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "\ncommands:\n");
+	mvdisp_dump(f, " - dump display controller interrupt timestamps\n");
+	mvdisp_dump(f, "\tcat itc\n");
+	mvdisp_dump(f, " - set interrupt timestamp collection flag\n");
+	mvdisp_dump(f, "   [0]: disable all timestamps collection\n");
+	mvdisp_dump(f, "   [1]: collect timestamp each time enter lcd"
+			" interrupts service\n");
+	mvdisp_dump(f, "   [2]: collect timestamp for display done interrupt"
+			" and vsync interrupt\n");
+	mvdisp_dump(f, "   [3]: collect timestamp for display done interrupt"
+			" and graphic frame done interrupt\n");
+	mvdisp_dump(f, "   [4]: collect timestamp for display done interrupt"
+			" and video frame done interrupt\n");
+	mvdisp_dump(f, "   [5]: collect timestamp for display done interrupt"
+			" and main handler finish time\n");
+	mvdisp_dump(f, "\techo [0/1/2/3/4/5] > itc\n");
+
+	return s;
+}
+
+static ssize_t itc_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	int i, j, s = 0, val, f = 1;
+
+	mvdisp_dump(f, "irqtm_check %d: t1 - %s, t2 - ", irqtm_check,
+			irqtm_check ? "display done" : "none");
+	if (ITC_INTERVAL)
+		mvdisp_dump(f, "irq interval\n");
+	else if (ITC_VSYNC)
+		mvdisp_dump(f, "vsync\n");
+	else if (ITC_GFX_DONE)
+		mvdisp_dump(f, "gfx frame done\n");
+	else if (ITC_VID_DONE)
+		mvdisp_dump(f, "vid frame done\n");
+	else if (ITC_HANDLER)
+		mvdisp_dump(f, "main handler\n");
+	else
+		mvdisp_dump(f, "none\n");
+
+	mvdisp_dump(f, "     t1     t2 :   ");
+	if (ITC_INTERVAL)
+		mvdisp_dump(f, "t2-frm_usec\n");
+	else
+		mvdisp_dump(f, "t2-t1\n");
+	for (i = 0; i < ITC_MAX_NUM; i++) {
+		if (ITC_INTERVAL) {
+			val = 0;
+			if ((int)t2[i].tv_usec > 10000)
+				val = (int)t2[i].tv_usec - fbi->frm_usec;
+		} else
+			val = t2[i].tv_usec - t1[i].tv_usec;
+
+		for (j = 0; j < ITC_MAX_NUM; j++) {
+			val = (val < -10000 || val > 10000) ?
+				(t2[j].tv_usec - t1[i].tv_usec) : val;
+		}
+
+		mvdisp_dump(f, " %6ld %6ld :  %6d", t1[i].tv_usec,
+			t2[i].tv_usec, val);
+		mvdisp_dump(f, "\n");
+	}
+
+	s += itc_help(buf + s);
+	return s;
+}
+
+static ssize_t itc_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	char *endp;
+
+	irqtm_check = simple_strtoul(buf, &endp, 0);
+//	sscanf(buf, "%d", &irqtm_check);
+
+	if (irqtm_check && !ITC_INTERVAL)
+		vsync_check_count();
+
+	return size;
+}
+static DEVICE_ATTR(itc, S_IRUGO | S_IWUSR, itc_show, itc_store);
+
+#if defined(CONFIG_MACH_GOLDEN)
+#define INIT_CHANGE
+#endif
+
+#if defined(LCD_ESD_RECOVERY)
+static void esd_dwork_func(struct work_struct *work)
+{
+	struct pxa168fb_info *fbi = fbi_global;
+	int gpio = GPIO_ESD_DET;
+
+	mutex_lock(&fbi->output_lock);
+
+	if (!fbi->active)
+		goto out;
+
+	if (gpio_get_value(gpio))
+		pxa168fb_reinit(fbi);
+
+	schedule_delayed_work(&esd_dwork,
+			msecs_to_jiffies(LCD_ESD_INTERVAL));
+out:
+	mutex_unlock(&fbi->output_lock);
+}
+
+static void esd_work_func(struct work_struct *work)
+{
+	struct pxa168fb_info *fbi = fbi_global;
+	int gpio = GPIO_ESD_DET;
+	int retry = 3;
+
+	mutex_lock(&fbi->output_lock);
+	pr_info("%s, gpio[%d] = %s\n", __func__,
+			gpio, gpio_get_value(gpio) ? "high" : "low");
+	while(retry--) {
+		if (fbi->active) {
+			pxa168fb_reinit(fbi);
+			pr_info("%s, esd recovery done\n", __func__);
+		}
+		if (!gpio_get_value(gpio)) {
+			pr_info("%s, succeeded to recover lcd\n", __func__); 
+			break;
+		} else {
+			pr_info("%s, failed to recover lcd\n", __func__); 
+			continue;
+		}
+	}
+
+	enable_irq(esd_irq);
+	irq_set_irq_type(esd_irq, IRQF_TRIGGER_RISING);
+	mutex_unlock(&fbi->output_lock);
+
+	return;
+}
+
+static irqreturn_t esd_irq_handler(int irq, void *dev_id)
+{
+	irq_set_irq_type(esd_irq, IRQF_TRIGGER_NONE);
+	disable_irq_nosync(esd_irq);
+	queue_work(esd_wq, &esd_work);
+	pr_info("%s, esd detected\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+static int esd_det_enable(int gpio)
+{
+	esd_irq = gpio_to_irq(gpio);
+
+	if (gpio_request(gpio, "LCD_ESD_INT GPIO")) {
+		printk(KERN_ERR "Failed to request GPIO %d "
+				"for LCD_ESD_INT\n", gpio);
+		return;
+	}
+	gpio_direction_input(gpio);
+	gpio_free(gpio);
+
+#ifdef LCD_ESD_INTERRUPT
+	if (request_irq(esd_irq, esd_irq_handler,
+				IRQF_TRIGGER_RISING,
+				"LCD_ESD_DETECT", NULL)) {
+		pr_err("%s, request_irq failed for esd\n", __func__);
+		return -1;
+	}
+
+	if (!(esd_wq = create_singlethread_workqueue("lcd_esd_det"))) {
+		pr_err("%s, fail to create workqueue!!\n", __func__);
+		return -1;
+	}
+	INIT_WORK(&esd_work, esd_work_func);
+#else
+	INIT_DELAYED_WORK(&esd_dwork, esd_dwork_func); // ESD self protect    
+	schedule_delayed_work(&esd_dwork,
+			msecs_to_jiffies(20000));
+#endif
+	return 0;
+}
+#endif	/* LCD_ESD_RECOVERY */
 
 static int __devinit pxa168fb_probe(struct platform_device *pdev)
 {
@@ -606,21 +2234,70 @@ static int __devinit pxa168fb_probe(struct platform_device *pdev)
 	struct fb_info *info = 0;
 	struct pxa168fb_info *fbi = 0;
 	struct resource *res;
-	struct clk *clk;
-	int irq, ret;
-
+	struct clk *clk = NULL;
+	struct clk *path_clk = NULL, *phy_clk = NULL;
+	int irq, irq_mask, irq_enable_value, ret = 0;
+	struct dsi_info *di = NULL;
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+	struct pxa168fb_mipi_lcd_driver *lcd_driver;
+
+	if(1 == skip_power_on) //clk div has set in uboot,so skip
+		init_once = 1;
+	else
+	init_once = 0;
 	mi = pdev->dev.platform_data;
 	if (mi == NULL) {
 		dev_err(&pdev->dev, "no platform data defined\n");
 		return -EINVAL;
 	}
+	/* if isr_clear_mask not initizlized, set to 0xffffffff as default */
+	if (!mi->isr_clear_mask) {
+		pr_err("%s: %s isr_clear_mask not been initialized!\n",
+			__func__, mi->id);
+		mi->isr_clear_mask = 0xffffffff;
+	}
 
-	clk = clk_get(&pdev->dev, "LCDCLK");
-	if (IS_ERR(clk)) {
-		dev_err(&pdev->dev, "unable to get LCDCLK");
-		return PTR_ERR(clk);
+	if (mi->no_legacy_clk) {
+		if (mi->path_clk_name) {
+			path_clk = clk_get(NULL, mi->path_clk_name);
+			if (IS_ERR(path_clk)) {
+				dev_err(&pdev->dev, "unable to get clk %s\n",
+					mi->path_clk_name);
+				return PTR_ERR(path_clk);
+			}
+		}
+		if (mi->phy_clk_name) {
+			phy_clk = clk_get(NULL, mi->phy_clk_name);
+			if (IS_ERR(phy_clk)) {
+				dev_err(&pdev->dev, "unable to get clk %s\n",
+					mi->phy_clk_name);
+				return PTR_ERR(phy_clk);
+			}
+		}
+	} else {
+#if defined(CONFIG_MACH_WILCOX) || defined(CONFIG_MACH_LT02)
+		clk = clk_get(NULL, "mmp_disp");
+		if (IS_ERR(clk)) {
+			dev_err(&pdev->dev, "unable to get mmp_disp");
+			return PTR_ERR(clk);
+		}
+#else
+		clk = clk_get(NULL, "LCDCLK");
+		if (IS_ERR(clk)) {
+			dev_err(&pdev->dev, "unable to get LCDCLK");
+			return PTR_ERR(clk);
+		}
+#endif
 	}
 
+#ifdef CONFIG_MACH_GOYA
+       vcxo_clk = clk_get(NULL, "VCXO_OUT");
+       if (IS_ERR(vcxo_clk)) {
+               dev_err(&pdev->dev, "unable to get VCXO_OUT\n");
+               return PTR_ERR(vcxo_clk);
+       }
+#endif
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {
 		dev_err(&pdev->dev, "no IO memory defined\n");
@@ -636,31 +2313,76 @@ static int __devinit pxa168fb_probe(struct platform_device *pdev)
 	}
 
 	info = framebuffer_alloc(sizeof(struct pxa168fb_info), &pdev->dev);
-	if (info == NULL) {
+	if ((info == NULL) || (!info->par)) {
 		ret = -ENOMEM;
 		goto failed_put_clk;
 	}
 
 	/* Initialize private data */
 	fbi = info->par;
-	fbi->info = info;
+	fbi->id = pdev->id;
+
+	if (has_feat_video_replace_graphics_dma()) {
+		if (!fbi->id)
+			fbi->vid = 1;
+		else
+			fbi->vid = 0;
+	} else
+		fbi->vid = 0;
+
+	if (!fbi->id) {
+		memset(&gfx_info, 0, sizeof(gfx_info));
+		fbi->dma_on = 1;
+	}
+
+	gfx_info.fbi[fbi->id] = fbi;
+	if (mi->phy_type & (DSI | DSI2DPI))
+		di = (struct dsi_info *)mi->phy_info;
+	if (di) {
+		pr_info("fb%d dsi %d di->lanes %d di->bpp %d\n",
+			fbi->id, di->id, di->lanes, di->bpp);
+		if (di->id & 1)
+			di->regs = (unsigned)ioremap_nocache\
+			(DSI1_REGS_PHYSICAL_BASE, sizeof(struct dsi_regs));
+		else
+			di->regs = (unsigned)ioremap_nocache\
+			(DSI2_REGS_PHYSICAL_BASE, sizeof(struct dsi_regs));
+	}
+
+	fbi->fb_info = info;
+	platform_set_drvdata(pdev, fbi);
 	fbi->clk = clk;
-	fbi->dev = info->dev = &pdev->dev;
-	fbi->panel_rbswap = mi->panel_rbswap;
+	fbi->path_clk = path_clk;
+	fbi->phy_clk = phy_clk;
+	fbi->dev = &pdev->dev;
+	fbi->fb_info->dev = &pdev->dev;
 	fbi->is_blanked = 0;
 	fbi->active = mi->active;
+	lcd_driver = mi->lcd_driver;
 
-	/*
-	 * Initialise static fb parameters.
-	 */
+	/* Initialize boot setting */
+	fbi->dft_vmode.xres = mi->modes->xres;
+	fbi->dft_vmode.yres = mi->modes->yres;
+	fbi->dft_vmode.refresh = mi->modes->refresh;
+
+	init_waitqueue_head(&fbi->w_intr_wq);
+	init_waitqueue_head(&fbi->w_intr_wq1);
+	mutex_init(&fbi->access_ok);
+	mutex_init(&fbi->output_lock);
+	spin_lock_init(&fbi->var_lock);
+	spin_lock_init(&fbi->job_lock);
+
+	pxa168fb_list_init(fbi);
+
+	/* Initialise static fb parameters */
 	info->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK |
-		      FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
+			FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
 	info->node = -1;
-	strlcpy(info->fix.id, mi->id, 16);
+	strcpy(info->fix.id, mi->id);
 	info->fix.type = FB_TYPE_PACKED_PIXELS;
 	info->fix.type_aux = 0;
-	info->fix.xpanstep = 0;
-	info->fix.ypanstep = 0;
+	info->fix.xpanstep = 1;
+	info->fix.ypanstep = 1;
 	info->fix.ywrapstep = 0;
 	info->fix.mmio_start = res->start;
 	info->fix.mmio_len = resource_size(res);
@@ -668,9 +2390,7 @@ static int __devinit pxa168fb_probe(struct platform_device *pdev)
 	info->fbops = &pxa168fb_ops;
 	info->pseudo_palette = fbi->pseudo_palette;
 
-	/*
-	 * Map LCD controller registers.
-	 */
+	/* Map LCD controller registers */
 	fbi->reg_base = devm_ioremap_nocache(&pdev->dev, res->start,
 					     resource_size(res));
 	if (fbi->reg_base == NULL) {
@@ -678,111 +2398,323 @@ static int __devinit pxa168fb_probe(struct platform_device *pdev)
 		goto failed_free_info;
 	}
 
-	/*
-	 * Allocate framebuffer memory.
-	 */
-	info->fix.smem_len = PAGE_ALIGN(DEFAULT_FB_SIZE);
+	/* Allocate framebuffer memory */
+	if (!fb_size_from_cmd) {
+		if (mi->max_fb_size)
+			max_fb_size = mi->max_fb_size;
+		else
+			max_fb_size = DEFAULT_FB_SIZE;
+	}
+	if (fb_share) {
+		/* fb_share mode, allocate more memory as frame buffer */
+		max_fb_size = max(max_fb_size, 2 * 4 * (mi->modes->xres *
+				(mi->modes->xres + mi->modes->yres)));
+	}
 
-	info->screen_base = dma_alloc_writecombine(fbi->dev, info->fix.smem_len,
-						&fbi->fb_start_dma, GFP_KERNEL);
-	if (info->screen_base == NULL) {
-		ret = -ENOMEM;
-		goto failed_free_info;
+	max_fb_size = PAGE_ALIGN(max_fb_size);
+	if (mi->mmap)
+		fbi->fb_size = max_fb_size;
+
+	if (fb_share && (fbi->id == 1) && gfx_info.fbi[0] &&\
+			gfx_info.fbi[0]->fb_start) {
+		fbi->fb_size = gfx_info.fbi[0]->fb_size;
+		fbi->fb_start = gfx_info.fbi[0]->fb_start;
+		fbi->fb_start_dma = gfx_info.fbi[0]->fb_start_dma;
+		dev_info(&pdev->dev, "--share--FB DMA buffer phy addr : %x\n",
+			(unsigned int)fbi->fb_start_dma);
+	} else if (mi->mmap) {
+		if (skip_power_on) {
+			fbi->skip_pw_on = 1;
+			if (!fbi->fb_start || !fbi->fb_start_dma) {
+				fbi->fb_start = ioremap_wc(disp_start_addr, max_fb_size);
+				fbi->fb_start_dma = disp_start_addr;
+			}
+		} else {
+#if !defined(CONFIG_MACH_LT02)
+		fbi->fb_start = dma_alloc_writecombine(fbi->dev, max_fb_size,
+				&fbi->fb_start_dma, GFP_KERNEL);
+#else
+		fbi->fb_start = pxa168fb_alloc_framebuffer(fbi->fb_size,
+				&fbi->fb_start_dma);
+#endif
+		if (fbi->fb_start == NULL) {
+			dev_err(&pdev->dev, "no enough memory!\n");
+			ret = -ENOMEM;
+			goto failed_free_info;
+		}
+		dev_info(&pdev->dev, "---------FB DMA buffer phy addr : %x\n",
+			(unsigned int)fbi->fb_start_dma);
+			memset(fbi->fb_start, 0x0, fbi->fb_size);
+		}
 	}
+#ifdef VSYNC_DSI_CMD
+	mutex_init(&fbi->cmd_mutex);
+	mutex_init(&fbi->vsync_mutex);
+#endif
 
-	info->fix.smem_start = (unsigned long)fbi->fb_start_dma;
-	set_graphics_start(info, 0, 0);
+	info->fix.smem_start = fbi->fb_start_dma;
+	info->fix.smem_len = fbi->fb_size;
+	info->screen_base = fbi->fb_start;
+	info->screen_size = fbi->fb_size;
 
-	/*
-	 * Set video mode according to platform data.
-	 */
-	set_mode(fbi, &info->var, mi->modes, mi->pix_fmt, 1);
+	/* Set video mode according to platform data */
+	set_mode(fbi, &info->var, mi->modes, mi->pix_fmt, mi->mmap);
 
 	fb_videomode_to_modelist(mi->modes, mi->num_modes, &info->modelist);
 
-	/*
-	 * init video mode data.
-	 */
+	/* init video mode data */
 	pxa168fb_init_mode(info, mi);
 
-	/*
-	 * Fill in sane defaults.
-	 */
-	ret = pxa168fb_check_var(&info->var, info);
-	if (ret)
-		goto failed_free_fbmem;
+	/* enable controller clock */
+	if (!mi->no_legacy_clk && mi->sclk_src)
+		clk_set_rate(fbi->clk, mi->sclk_src);
 
-	/*
-	 * enable controller clock
-	 */
-	clk_enable(fbi->clk);
+	if (lcd_driver)
+		lcd_driver->probe(fbi);
+
+	/* enable power supply */
+	fbi->active = 0;
+
+#ifdef INIT_CHANGE
+	fbi->qos_idle.name = pdev->name;
+	pm_qos_add_request(&fbi->qos_idle, PM_QOS_CPUIDLE_BLOCK,
+			PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+
+	fbi->workqueue = alloc_workqueue(pdev->name, WQ_HIGHPRI | WQ_UNBOUND |
+							WQ_MEM_RECLAIM, 1);
+	if (!fbi->workqueue) {
+		dev_err(&pdev->dev, "alloc_workqueue failed\n");
+		goto failed_free_cmap;
+	}
 
+	INIT_WORK(&fbi->vsync_work, vsync_notify_work);
+#endif
+#ifdef LCD_ESD_RECOVERY
+	if (get_panel_id()) {
+		fbi_global = fbi;
+		if (esd_det_enable(GPIO_ESD_DET))
+			pr_err("%s, Failed to enable esd interrupt\n", __func__);
+	}
+#endif
+	pm_runtime_enable(&pdev->dev);
+	ret = pm_runtime_get_sync(&pdev->dev);
+	if (ret < 0)
+		goto failed_free_clk;
+
+	/* init vdma clock/sram, etc. */
+	lcd_vdma = request_vdma(fbi->id, fbi->vid);
+	if (lcd_vdma) {
+		lcd_vdma->dev = fbi->dev;
+		lcd_vdma->reg_base = fbi->reg_base;
+		pxa688_vdma_init(lcd_vdma);
+	} else
+		pr_warn("path %d layer %d: request vdma fail\n", fbi->id, fbi->vid);
+
+	/* Fill in sane defaults */
 	pxa168fb_set_par(info);
 
-	/*
-	 * Configure default register values.
-	 */
-	writel(0, fbi->reg_base + LCD_SPU_BLANKCOLOR);
-	writel(mi->io_pin_allocation_mode, fbi->reg_base + SPU_IOPAD_CONTROL);
-	writel(0, fbi->reg_base + LCD_CFG_GRA_START_ADDR1);
-	writel(0, fbi->reg_base + LCD_SPU_GRA_OVSA_HPXL_VLN);
-	writel(0, fbi->reg_base + LCD_SPU_SRAM_PARA0);
-	writel(CFG_CSB_256x32(0x1)|CFG_CSB_256x24(0x1)|CFG_CSB_256x8(0x1),
-		fbi->reg_base + LCD_SPU_SRAM_PARA1);
+	if (mi->dither_en)
+		dither_set(fbi, mi->dither_table, mi->dither_mode, 1);
 
-	/*
-	 * Allocate color map.
-	 */
+	/* Allocate color map */
 	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
 		ret = -ENOMEM;
 		goto failed_free_clk;
 	}
 
-	/*
-	 * Register irq handler.
-	 */
-	ret = devm_request_irq(&pdev->dev, irq, pxa168fb_handle_irq,
-			       IRQF_SHARED, info->fix.id, fbi);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "unable to request IRQ\n");
-		ret = -ENXIO;
-		goto failed_free_cmap;
+	/* Register irq handler */
+	if (!fbi->id) {
+		/* Clear the irq status before kernel startup */
+		irq_status_clear(fbi->id, 0xFFFFFFFF);
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+		ret = devm_request_threaded_irq(&pdev->dev, irq,
+					pxa168fb_handle_irq,
+					pxa168fb_threaded_handle_irq,
+					IRQF_DISABLED, mi->id, fbi);
+#else
+		ret = devm_request_irq(&pdev->dev, irq, pxa168fb_handle_irq,
+					IRQF_DISABLED, mi->id, fbi);
+#endif
+		if (ret < 0) {
+			dev_err(&pdev->dev, "unable to request IRQ\n");
+			ret = -ENXIO;
+			goto failed_free_cmap;
+		}
 	}
 
-	/*
-	 * Enable GFX interrupt
-	 */
-	writel(GRA_FRAME_IRQ0_ENA(0x1), fbi->reg_base + SPU_IRQ_ENA);
+	/* disable GFX interrupt enable err interrupt */
+	irq_mask = path_imasks(fbi->id) | err_imask(fbi->id);
+	irq_enable_value = err_imask(fbi->id);
+	if (!cpu_is_pxa988() && !cpu_is_pxa986() && !cpu_is_pxa1088())
+		irq_enable_value |= display_done_imask(fbi->id);
+	irq_mask_set(fbi->id, irq_mask, irq_enable_value);
+	fbi->wait_vsync = 1;
 
-	/*
-	 * Register framebuffer.
-	 */
+	pm_runtime_put_sync(&pdev->dev);
+
+	/* Register framebuffer */
 	ret = register_framebuffer(info);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "Failed to register pxa168-fb: %d\n", ret);
 		ret = -ENXIO;
 		goto failed_free_cmap;
 	}
+	pr_info("pxa168fb: frame buffer device was loaded"
+		" to /dev/fb%d <%s>.\n", info->node, info->fix.id);
 
-	platform_set_drvdata(pdev, fbi);
+	atomic_set(&fbi->vsync_cnt, 2);
+
+#ifdef CONFIG_PXA688_PHY
+	ret = device_create_file(&pdev->dev, &dev_attr_phy);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "device attr create fail: %d\n", ret);
+		goto failed_free_cmap;
+	}
+#endif
+
+#ifdef CONFIG_PXA688_VDMA
+	ret = device_create_file(&pdev->dev, &dev_attr_vdma);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "device attr create fail: %d\n", ret);
+		goto failed_free_cmap;
+	}
+#endif
+
+#ifdef CONFIG_PXA688_MISC
+	ret = device_create_file(&pdev->dev, &dev_attr_misc);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "device attr misc create fail: %d\n", ret);
+		goto failed_free_cmap;
+	}
+#endif
+
+#ifdef CONFIG_LCD_MDNIE_ENABLE
+	ret = device_create_file(&pdev->dev, &dev_attr_tuning);
+        if (ret < 0) {
+                dev_err(&pdev->dev, "device attr create fail: %d\n", ret);
+                goto failed_free_cmap;
+        }
+
+	ret = device_create_file(&pdev->dev, &dev_attr_scenario);
+        if (ret < 0) {
+                dev_err(&pdev->dev, "device attr create fail: %d\n", ret);
+                goto failed_free_cmap;
+        }
+#endif
+
+#ifdef CONFIG_DISP_DFC
+	ret = device_create_file(&pdev->dev, &dev_attr_freq);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "device attr freq create fail: %d\n", ret);
+		goto failed_free_cmap;
+	}
+#endif
+
+	ret = device_create_file(&pdev->dev, &dev_attr_lcd);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "device attr lcd create fail: %d\n", ret);
+		goto failed_free_cmap;
+	}
+
+	ret = device_create_file(&pdev->dev, &dev_attr_vsync);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "device attr create fail: %d\n", ret);
+		goto failed_free_cmap;
+	}
+
+	ret = device_create_file(&pdev->dev, &dev_attr_vsync_ts);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "device attr create fail: %d\n", ret);
+		goto failed_free_cmap;
+	}
+
+	if (!fbi->id) {
+		ret = device_create_file(&pdev->dev, &dev_attr_itc);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "device attr create fail: %d\n",\
+					ret);
+			goto failed_free_cmap;
+		}
+	}
+
+#ifndef INIT_CHANGE
+	fbi->qos_idle.name = pdev->name;
+	pm_qos_add_request(&fbi->qos_idle, PM_QOS_CPUIDLE_BLOCK,
+			PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+
+	fbi->workqueue = alloc_workqueue(pdev->name, WQ_HIGHPRI | WQ_UNBOUND |
+							WQ_MEM_RECLAIM, 1);
+	if (!fbi->workqueue) {
+		dev_err(&pdev->dev, "alloc_workqueue failed\n");
+		goto failed_free_cmap;
+	}
+
+	INIT_WORK(&fbi->vsync_work, vsync_notify_work);
+#endif
+
+#ifdef CONFIG_KERNEL_DEBUG_SEC
+	sec_getlog_supply_fbinfo(fbi->fb_info);
+#endif
+
+#ifdef CONFIG_ANDROID
+	if (fbi->fb_start && (!fbi->id || !fb_share) && !fbi->skip_pw_on) {
+		//fb_prepare_logo(info, 0);
+		//fb_show_logo(info, 0);
+		/* The size of frambuffer is too large to use
+		 * dma_alloc_writecombine to alloc non-cacheable dma buffer,
+		 * we use __get_free_pages instead. Therefore, it needs
+		 * flushing cache after frambuffer filled. Otherwise, the
+		 * logo data would lose some lines in cache when begins
+		 * to display */
+	}
+#endif
+	fbi->skip_pw_on = 0;
+	pm_runtime_forbid(&pdev->dev);
 	return 0;
 
 failed_free_cmap:
 	fb_dealloc_cmap(&info->cmap);
 failed_free_clk:
-	clk_disable(fbi->clk);
-failed_free_fbmem:
-	dma_free_coherent(fbi->dev, info->fix.smem_len,
-			info->screen_base, fbi->fb_start_dma);
+	pxa168fb_free_framebuffer(fbi->fb_size, fbi->fb_start,
+			&fbi->fb_start_dma);
 failed_free_info:
+	platform_set_drvdata(pdev, NULL);
+	if (fbi)
+	{
+		gfx_info.fbi[fbi->id] = NULL;
+		kfree(fbi);
+	}
 	kfree(info);
 failed_put_clk:
-	clk_put(clk);
-
+	pm_qos_remove_request(&fbi->qos_idle);
+	if (clk)
+		clk_put(clk);
+	if (path_clk)
+		clk_put(path_clk);
+	if (phy_clk)
+		clk_put(phy_clk);
+#ifdef CONFIG_MACH_GOYA
+       clk_put(vcxo_clk);
+#endif
 	dev_err(&pdev->dev, "frame buffer device init failed with %d\n", ret);
 	return ret;
 }
 
+static void pxa168fb_shutdown(struct platform_device *pdev)
+{
+	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
+
+	printk("%s +\n", __func__);
+	if (!fbi)
+		return 0;
+
+	_pxa168fb_suspend(fbi);
+
+	printk("%s -\n", __func__);
+	return;
+}
+
 static int __devexit pxa168fb_remove(struct platform_device *pdev)
 {
 	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
@@ -794,38 +2726,60 @@ static int __devexit pxa168fb_remove(struct platform_device *pdev)
 		return 0;
 
 	/* disable DMA transfer */
-	data = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
-	data &= ~CFG_GRA_ENA_MASK;
-	writel(data, fbi->reg_base + LCD_SPU_DMA_CTRL0);
 
-	info = fbi->info;
+	data = dma_ctrl_read(fbi->id, 0);
+	data &= ~0x00000100;
+	dma_ctrl_write(fbi->id, 0, data);
+
+	info = fbi->fb_info;
 
 	unregister_framebuffer(info);
 
-	writel(GRA_FRAME_IRQ0_ENA(0x0), fbi->reg_base + SPU_IRQ_ENA);
+	irq_mask_set(fbi->id, 0xffffffff, 0);
+
+	/* disable runtime pm */
+	pm_runtime_put_sync(fbi->dev);
+	pm_runtime_disable(fbi->dev);
 
 	if (info->cmap.len)
 		fb_dealloc_cmap(&info->cmap);
 
 	irq = platform_get_irq(pdev, 0);
 
-	dma_free_writecombine(fbi->dev, PAGE_ALIGN(info->fix.smem_len),
-				info->screen_base, info->fix.smem_start);
+	pxa168fb_free_framebuffer(fbi->fb_size, fbi->fb_start,
+			&fbi->fb_start_dma);
+
+	pm_qos_remove_request(&fbi->qos_idle);
 
-	clk_disable(fbi->clk);
-	clk_put(fbi->clk);
+	if (fbi->clk)
+		clk_put(fbi->clk);
+	if (fbi->path_clk)
+		clk_put(fbi->path_clk);
+	if (fbi->phy_clk)
+		clk_put(fbi->phy_clk);
+
+#ifdef CONFIG_MACH_GOYA
+       clk_put(vcxo_clk);
+#endif
 
 	framebuffer_release(info);
 
 	return 0;
 }
 
+static const struct dev_pm_ops pxa168fb_pm_ops = {
+	SET_RUNTIME_PM_OPS(pxa168fb_runtime_suspend, pxa168fb_runtime_resume,
+			   NULL)
+};
+
 static struct platform_driver pxa168fb_driver = {
 	.driver		= {
 		.name	= "pxa168-fb",
 		.owner	= THIS_MODULE,
+		.pm	= &pxa168fb_pm_ops,
 	},
 	.probe		= pxa168fb_probe,
+	.shutdown	= pxa168fb_shutdown,
 	.remove		= __devexit_p(pxa168fb_remove),
 };
 
diff --git a/drivers/video/pxa168fb.h b/drivers/video/pxa168fb.h
index eee09279..abbcf0ab 100644
--- a/drivers/video/pxa168fb.h
+++ b/drivers/video/pxa168fb.h
@@ -1,39 +1,225 @@
-#ifndef __PXA168FB_H__
-#define __PXA168FB_H__
+/*
+ * linux/include/video/dovefbreg.h -- Marvell frame buffer for DOVE
+ *
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * Written by Green Wan <gwan@marvell.com>
+ *
+ * Adapted from:  linux/drivers/video/skeletonfb.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+#ifndef _PXA168FB_H_
+#define _PXA168FB_H_
 
 /* ------------< LCD register >------------ */
+struct lcd_regs {
+/* TV patch register for MMP2 */
+/* 32 bit		TV Video Frame0 Y Starting Address */
+#define LCD_TVD_START_ADDR_Y0			(0x0000)
+/* 32 bit		TV Video Frame0 U Starting Address */
+#define LCD_TVD_START_ADDR_U0			(0x0004)
+/* 32 bit		TV Video Frame0 V Starting Address */
+#define LCD_TVD_START_ADDR_V0			(0x0008)
+/* 32 bit		TV Video Frame0 Command Starting Address */
+#define LCD_TVD_START_ADDR_C0			(0x000C)
+/* 32 bit		TV Video Frame1 Y Starting Address Register*/
+#define LCD_TVD_START_ADDR_Y1			(0x0010)
+/* 32 bit		TV Video Frame1 U Starting Address Register*/
+#define LCD_TVD_START_ADDR_U1			(0x0014)
+/* 32 bit		TV Video Frame1 V Starting Address Register*/
+#define LCD_TVD_START_ADDR_V1			(0x0018)
+/* 32 bit		TV Video Frame1 Command Starting Address Register*/
+#define LCD_TVD_START_ADDR_C1			(0x001C)
+/* 32 bit		TV Video Y andC Line Length(Pitch)Register*/
+#define LCD_TVD_PITCH_YC			(0x0020)
+/* 32 bit		TV Video U andV Line Length(Pitch)Register*/
+#define LCD_TVD_PITCH_UV			(0x0024)
+/* 32 bit	  TV Video Starting Point on Screen Register*/
+#define LCD_TVD_OVSA_HPXL_VLN			(0x0028)
+/* 32 bit		TV Video Source Size Register*/
+#define LCD_TVD_HPXL_VLN			(0x002C)
+/* 32 bit	  TV Video Destination Size (After Zooming)Register*/
+#define LCD_TVDZM_HPXL_VLN			(0x0030)
+	u32 v_y0;
+	u32 v_u0;
+	u32 v_v0;
+	u32 v_c0;
+	u32 v_y1;
+	u32 v_u1;
+	u32 v_v1;
+	u32 v_c1;
+	u32 v_pitch_yc;		/* Video Y and C Line Length (Pitch) */
+	u32 v_pitch_uv;		/* Video U and V Line Length (Pitch) */
+	u32 v_start;		/* Video Starting Point on Screen */
+	u32 v_size;			/* Video Source Size */
+	u32 v_size_z;		/* Video Destination Size (After Zooming) */
+
+/* 32 bit	   TV Graphic Frame 0 Starting Address Register*/
+#define LCD_TVG_START_ADDR0				(0x0034)
+/* 32 bit	  TV Graphic Frame 1 Starting Address Register*/
+#define LCD_TVG_START_ADDR1				(0x0038)
+/* 32 bit		TV Graphic Line Length(Pitch)Register*/
+#define LCD_TVG_PITCH					(0x003C)
+/* 32 bit		TV Graphic Starting Point on Screen Register*/
+#define LCD_TVG_OVSA_HPXL_VLN				(0x0040)
+/* 32 bit		TV Graphic Source Size Register*/
+#define LCD_TVG_HPXL_VLN				(0x0044)
+/* 32 bit		TV Graphic Destination size (after Zooming)Register*/
+#define LCD_TVGZM_HPXL_VLN				(0x0048)
+	u32 g_0;			/* Graphic Frame 0/1 Starting Address */
+	u32 g_1;
+	u32 g_pitch;		/* Graphic Line Length (Pitch) */
+	u32 g_start;		/* Graphic Starting Point on Screen */
+	u32 g_size;			/* Graphic Source Size */
+	u32 g_size_z;		/* Graphic Destination Size (After Zooming) */
+
+/* 32 bit	  TV Hardware Cursor Starting Point on screen Register*/
+#define LCD_TVC_OVSA_HPXL_VLN				(0x004C)
+/* 32 bit		TV Hardware Cursor Size Register */
+#define LCD_TVC_HPXL_VLN				(0x0050)
+	u32 hc_start;			/* Hardware Cursor */
+	u32 hc_size;			/* Hardware Cursor */
+
+/* 32 bit		TV Total Screen Size Register*/
+#define LCD_TV_V_H_TOTAL				(0x0054)
+/* 32 bit		TV Screen Active Size Register*/
+#define LCD_TV_V_H_ACTIVE				(0x0058)
+/* 32 bit		TV Screen Horizontal Porch Register*/
+#define LCD_TV_H_PORCH					(0x005C)
+/* 32 bit		TV Screen Vertical Porch Register*/
+#define LCD_TV_V_PORCH					(0x0060)
+	u32 screen_size;		/* Screen Total Size */
+	u32 screen_active;		/* Screen Active Size */
+	u32 screen_h_porch;		/* Screen Horizontal Porch */
+	u32 screen_v_porch;		/* Screen Vertical Porch */
+
+/* 32 bit		TV Screen Blank Color Register*/
+#define LCD_TV_BLANKCOLOR				(0x0064)
+/* 32 bit		TV Hardware Cursor Color1 Register*/
+#define LCD_TV_ALPHA_COLOR1				(0x0068)
+/* 32 bit		TV Hardware Cursor Color2 Register*/
+#define LCD_TV_ALPHA_COLOR2				(0x006C)
+	u32 blank_color;		/* Screen Blank Color */
+	u32 hc_Alpha_color1;	/* Hardware Cursor Color1 */
+	u32 hc_Alpha_color2;	/* Hardware Cursor Color2 */
+
+/* 32 bit		TV Video Y Color Key Control*/
+#define LCD_TV_COLORKEY_Y				(0x0070)
+/* 32 bit		TV Video U Color Key Control*/
+#define LCD_TV_COLORKEY_U				(0x0074)
+/* 32 bit		TV Video V Color Key Control*/
+#define LCD_TV_COLORKEY_V				(0x0078)
+	u32 v_colorkey_y;		/* Video Y Color Key Control */
+	u32 v_colorkey_u;		/* Video U Color Key Control */
+	u32 v_colorkey_v;		/* Video V Color Key Control */
+
+/* 32 bit		TV VSYNC PulsePixel Edge Control Register*/
+#define LCD_TV_SEPXLCNT					(0x007C)
+	u32 vsync_ctrl;			/* VSYNC PulsePixel Edge Control */
+};
+
+#define intf_ctrl(id)		((id) ? (((id) & 1) ? LCD_TVIF_CTRL : \
+				LCD_DUMB2_CTRL) : LCD_SPU_DUMB_CTRL)
+#define dma_ctrl0(id)	   ((id) ? (((id) & 1) ? LCD_TV_CTRL0 : \
+				LCD_PN2_CTRL0) : LCD_SPU_DMA_CTRL0)
+#define dma_ctrl1(id)	   ((id) ? (((id) & 1) ? LCD_TV_CTRL1 : \
+				LCD_PN2_CTRL1) : LCD_SPU_DMA_CTRL1)
+#define dma_ctrl(ctrl1, id)	 (ctrl1 ? dma_ctrl1(id) : dma_ctrl0(id))
+
+/* 32 bit		TV Path DMA Control 0*/
+#define LCD_TV_CTRL0					(0x0080)
+/* 32 bit		TV Path DMA Control 1*/
+#define LCD_TV_CTRL1					(0x0084)
+/* 32 bit		TV Path Video Contrast*/
+#define LCD_TV_CONTRAST					(0x0088)
+/* 32 bit		TV Path Video Saturation*/
+#define LCD_TV_SATURATION				(0x008C)
+/* 32 bit		TV Path Video Hue Adjust*/
+#define LCD_TV_CBSH_HUE					(0x0090)
+/* 32 bit TV Path TVIF Control	Register */
+#define LCD_TVIF_CTRL					(0x0094)
+#define TV_VBLNK_VALID_EN				(1 << 12)
+
+/* 32 bit TV Path I/O Pad Control*/
+#define LCD_TVIOPAD_CTRL				(0x0098)
+/* 32 bit TV Path Cloc	Divider  */
+#define LCD_TCLK_DIV					(0x009C)
+
+/* dither configure */
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define LCD_DITHER_CTRL				(0x01EC)
+#else
+#define LCD_DITHER_CTRL				(0x00A0)
+#endif
+
+#define DITHER_TBL_INDEX_SEL(s)		((s) << 16)
+#define DITHER_MODE2(m)				((m) << 12)
+#define DITHER_MODE2_SHIFT			(12)
+#define DITHER_4X8_EN2				(1 << 9)
+#define DITHER_4X8_EN2_SHIFT		(9)
+#define DITHER_EN2					(1 << 8)
+#define DITHER_MODE1(m)				((m) << 4)
+#define DITHER_MODE1_SHIFT			(4)
+#define DITHER_4X8_EN1				(1 << 1)
+#define DITHER_4X8_EN1_SHIFT		(1)
+#define DITHER_EN1					(1)
+
+/* dither table data was fixed by video bpp of input and output*/
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define DITHER_TB_4X4_INDEX0		(0x6e4ca280)
+#define DITHER_TB_4X4_INDEX1		(0x5d7f91b3)
+#define DITHER_TB_4X8_INDEX0		(0xb391a280)
+#define DITHER_TB_4X8_INDEX1		(0x7f5d6e4c)
+#define DITHER_TB_4X8_INDEX2		(0x80a291b3)
+#define DITHER_TB_4X8_INDEX3		(0x4c6e5d7f)
+#define LCD_DITHER_TBL_DATA		(0x01F0)
+#else
+#define DITHER_TB_4X4_INDEX0		(0x3b19f7d5)
+#define DITHER_TB_4X4_INDEX1		(0x082ac4e6)
+#define DITHER_TB_4X8_INDEX0		(0xf7d508e6)
+#define DITHER_TB_4X8_INDEX1		(0x3b194c2a)
+#define DITHER_TB_4X8_INDEX2		(0xc4e6d5f7)
+#define DITHER_TB_4X8_INDEX3		(0x082a193b)
+#define LCD_DITHER_TBL_DATA		(0x00A4)
+#endif
+
 /* Video Frame 0&1 start address registers */
-#define	LCD_SPU_DMA_START_ADDR_Y0		0x00C0
-#define	LCD_SPU_DMA_START_ADDR_U0		0x00C4
-#define	LCD_SPU_DMA_START_ADDR_V0		0x00C8
-#define LCD_CFG_DMA_START_ADDR_0		0x00CC /* Cmd address */
-#define	LCD_SPU_DMA_START_ADDR_Y1		0x00D0
-#define	LCD_SPU_DMA_START_ADDR_U1		0x00D4
-#define	LCD_SPU_DMA_START_ADDR_V1		0x00D8
-#define LCD_CFG_DMA_START_ADDR_1		0x00DC /* Cmd address */
+#define	LCD_SPU_DMA_START_ADDR_Y0	0x00C0
+#define	LCD_SPU_DMA_START_ADDR_U0	0x00C4
+#define	LCD_SPU_DMA_START_ADDR_V0	0x00C8
+#define LCD_CFG_DMA_START_ADDR_0	0x00CC /* Cmd address */
+#define	LCD_SPU_DMA_START_ADDR_Y1	0x00D0
+#define	LCD_SPU_DMA_START_ADDR_U1	0x00D4
+#define	LCD_SPU_DMA_START_ADDR_V1	0x00D8
+#define LCD_CFG_DMA_START_ADDR_1	0x00DC /* Cmd address */
 
 /* YC & UV Pitch */
-#define LCD_SPU_DMA_PITCH_YC			0x00E0
-#define     SPU_DMA_PITCH_C(c)			((c) << 16)
-#define     SPU_DMA_PITCH_Y(y)			(y)
-#define LCD_SPU_DMA_PITCH_UV			0x00E4
-#define     SPU_DMA_PITCH_V(v)			((v) << 16)
-#define     SPU_DMA_PITCH_U(u)			(u)
+#define LCD_SPU_DMA_PITCH_YC		0x00E0
+#define	 SPU_DMA_PITCH_C(c)		((c)<<16)
+#define	 SPU_DMA_PITCH_Y(y)		(y)
+#define LCD_SPU_DMA_PITCH_UV		0x00E4
+#define	 SPU_DMA_PITCH_V(v)		((v)<<16)
+#define	 SPU_DMA_PITCH_U(u)		(u)
 
 /* Video Starting Point on Screen Register */
 #define LCD_SPUT_DMA_OVSA_HPXL_VLN		0x00E8
-#define     CFG_DMA_OVSA_VLN(y)			((y) << 16) /* 0~0xfff */
-#define     CFG_DMA_OVSA_HPXL(x)		(x)     /* 0~0xfff */
+#define	 CFG_DMA_OVSA_VLN(y)			((y)<<16) /* 0~0xfff */
+#define	 CFG_DMA_OVSA_HPXL(x)			(x)	 /* 0~0xfff */
 
 /* Video Size Register */
 #define LCD_SPU_DMA_HPXL_VLN			0x00EC
-#define     CFG_DMA_VLN(y)			((y) << 16)
-#define     CFG_DMA_HPXL(x)			(x)
+#define	 CFG_DMA_VLN(y)				((y)<<16)
+#define	 CFG_DMA_HPXL(x)			(x)
 
 /* Video Size After zooming Register */
 #define LCD_SPU_DZM_HPXL_VLN			0x00F0
-#define     CFG_DZM_VLN(y)			((y) << 16)
-#define     CFG_DZM_HPXL(x)			(x)
+#define	 CFG_DZM_VLN(y)				((y)<<16)
+#define	 CFG_DZM_HPXL(x)			(x)
 
 /* Graphic Frame 0&1 Starting Address Register */
 #define LCD_CFG_GRA_START_ADDR0			0x00F4
@@ -44,155 +230,191 @@
 
 /* Graphic Starting Point on Screen Register */
 #define LCD_SPU_GRA_OVSA_HPXL_VLN		0x0100
-#define     CFG_GRA_OVSA_VLN(y)			((y) << 16)
-#define     CFG_GRA_OVSA_HPXL(x)		(x)
+#define	 CFG_GRA_OVSA_VLN(y)			((y)<<16)
+#define	 CFG_GRA_OVSA_HPXL(x)			(x)
 
 /* Graphic Size Register */
 #define LCD_SPU_GRA_HPXL_VLN			0x0104
-#define     CFG_GRA_VLN(y)			((y) << 16)
-#define     CFG_GRA_HPXL(x)			(x)
+#define	 CFG_GRA_VLN(y)				((y)<<16)
+#define	 CFG_GRA_HPXL(x)			(x)
 
 /* Graphic Size after Zooming Register */
 #define LCD_SPU_GZM_HPXL_VLN			0x0108
-#define     CFG_GZM_VLN(y)			((y) << 16)
-#define     CFG_GZM_HPXL(x)			(x)
+#define	 CFG_GZM_VLN(y)				((y)<<16)
+#define	 CFG_GZM_HPXL(x)			(x)
 
 /* HW Cursor Starting Point on Screen Register */
 #define LCD_SPU_HWC_OVSA_HPXL_VLN		0x010C
-#define     CFG_HWC_OVSA_VLN(y)			((y) << 16)
-#define     CFG_HWC_OVSA_HPXL(x)		(x)
+#define	 CFG_HWC_OVSA_VLN(y)			((y)<<16)
+#define	 CFG_HWC_OVSA_HPXL(x)			(x)
 
 /* HW Cursor Size */
 #define LCD_SPU_HWC_HPXL_VLN			0x0110
-#define     CFG_HWC_VLN(y)			((y) << 16)
-#define     CFG_HWC_HPXL(x)			(x)
+#define	 CFG_HWC_VLN(y)				((y)<<16)
+#define	 CFG_HWC_HPXL(x)			(x)
 
 /* Total Screen Size Register */
 #define LCD_SPUT_V_H_TOTAL			0x0114
-#define     CFG_V_TOTAL(y)			((y) << 16)
-#define     CFG_H_TOTAL(x)			(x)
+#define	 CFG_V_TOTAL(y)				((y)<<16)
+#define	 CFG_H_TOTAL(x)				(x)
 
 /* Total Screen Active Size Register */
 #define LCD_SPU_V_H_ACTIVE			0x0118
-#define     CFG_V_ACTIVE(y)			((y) << 16)
-#define     CFG_H_ACTIVE(x)			(x)
+#define	 CFG_V_ACTIVE(y)			((y)<<16)
+#define	 CFG_H_ACTIVE(x)			(x)
 
 /* Screen H&V Porch Register */
 #define LCD_SPU_H_PORCH				0x011C
-#define     CFG_H_BACK_PORCH(b)			((b) << 16)
-#define     CFG_H_FRONT_PORCH(f)		(f)
+#define	 CFG_H_BACK_PORCH(b)			((b)<<16)
+#define	 CFG_H_FRONT_PORCH(f)			(f)
 #define LCD_SPU_V_PORCH				0x0120
-#define     CFG_V_BACK_PORCH(b)			((b) << 16)
-#define     CFG_V_FRONT_PORCH(f)		(f)
+#define	 CFG_V_BACK_PORCH(b)			((b)<<16)
+#define	 CFG_V_FRONT_PORCH(f)			(f)
 
 /* Screen Blank Color Register */
 #define LCD_SPU_BLANKCOLOR			0x0124
-#define     CFG_BLANKCOLOR_MASK			0x00FFFFFF
-#define     CFG_BLANKCOLOR_R_MASK		0x000000FF
-#define     CFG_BLANKCOLOR_G_MASK		0x0000FF00
-#define     CFG_BLANKCOLOR_B_MASK		0x00FF0000
+#define  CFG_BLANKCOLOR_MASK			0x00FFFFFF
+#define  CFG_BLANKCOLOR_R_MASK			0x000000FF
+#define  CFG_BLANKCOLOR_G_MASK			0x0000FF00
+#define  CFG_BLANKCOLOR_B_MASK			0x00FF0000
 
 /* HW Cursor Color 1&2 Register */
 #define LCD_SPU_ALPHA_COLOR1			0x0128
-#define     CFG_HWC_COLOR1			0x00FFFFFF
-#define     CFG_HWC_COLOR1_R(red)		((red) << 16)
-#define     CFG_HWC_COLOR1_G(green)		((green) << 8)
-#define     CFG_HWC_COLOR1_B(blue)		(blue)
-#define     CFG_HWC_COLOR1_R_MASK		0x000000FF
-#define     CFG_HWC_COLOR1_G_MASK		0x0000FF00
-#define     CFG_HWC_COLOR1_B_MASK		0x00FF0000
+#define	 CFG_HWC_COLOR1				0x00FFFFFF
+#define	 CFG_HWC_COLOR1_R(red)			((red)<<16)
+#define	 CFG_HWC_COLOR1_G(green)		((green)<<8)
+#define	 CFG_HWC_COLOR1_B(blue)			(blue)
+#define	 CFG_HWC_COLOR1_R_MASK			0x000000FF
+#define	 CFG_HWC_COLOR1_G_MASK			0x0000FF00
+#define	 CFG_HWC_COLOR1_B_MASK			0x00FF0000
 #define LCD_SPU_ALPHA_COLOR2			0x012C
-#define     CFG_HWC_COLOR2			0x00FFFFFF
-#define     CFG_HWC_COLOR2_R_MASK		0x000000FF
-#define     CFG_HWC_COLOR2_G_MASK		0x0000FF00
-#define     CFG_HWC_COLOR2_B_MASK		0x00FF0000
+#define	 CFG_HWC_COLOR2				0x00FFFFFF
+#define	 CFG_HWC_COLOR2_R_MASK			0x000000FF
+#define	 CFG_HWC_COLOR2_G_MASK			0x0000FF00
+#define	 CFG_HWC_COLOR2_B_MASK			0x00FF0000
 
 /* Video YUV Color Key Control */
 #define LCD_SPU_COLORKEY_Y			0x0130
-#define     CFG_CKEY_Y2(y2)			((y2) << 24)
-#define     CFG_CKEY_Y2_MASK			0xFF000000
-#define     CFG_CKEY_Y1(y1)			((y1) << 16)
-#define     CFG_CKEY_Y1_MASK			0x00FF0000
-#define     CFG_CKEY_Y(y)			((y) << 8)
-#define     CFG_CKEY_Y_MASK			0x0000FF00
-#define     CFG_ALPHA_Y(y)			(y)
-#define     CFG_ALPHA_Y_MASK			0x000000FF
+#define	 CFG_CKEY_Y2(y2)			((y2)<<24)
+#define	 CFG_CKEY_Y2_MASK			0xFF000000
+#define	 CFG_CKEY_Y1(y1)			((y1)<<16)
+#define	 CFG_CKEY_Y1_MASK			0x00FF0000
+#define	 CFG_CKEY_Y(y)				((y)<<8)
+#define	 CFG_CKEY_Y_MASK			0x0000FF00
+#define	 CFG_ALPHA_Y(y)				(y)
+#define	 CFG_ALPHA_Y_MASK			0x000000FF
 #define LCD_SPU_COLORKEY_U			0x0134
-#define     CFG_CKEY_U2(u2)			((u2) << 24)
-#define     CFG_CKEY_U2_MASK			0xFF000000
-#define     CFG_CKEY_U1(u1)			((u1) << 16)
-#define     CFG_CKEY_U1_MASK			0x00FF0000
-#define     CFG_CKEY_U(u)			((u) << 8)
-#define     CFG_CKEY_U_MASK			0x0000FF00
-#define     CFG_ALPHA_U(u)			(u)
-#define     CFG_ALPHA_U_MASK			0x000000FF
+#define	 CFG_CKEY_U2(u2)			((u2)<<24)
+#define	 CFG_CKEY_U2_MASK			0xFF000000
+#define	 CFG_CKEY_U1(u1)			((u1)<<16)
+#define	 CFG_CKEY_U1_MASK			0x00FF0000
+#define	 CFG_CKEY_U(u)				((u)<<8)
+#define	 CFG_CKEY_U_MASK			0x0000FF00
+#define	 CFG_ALPHA_U(u)				(u)
+#define	 CFG_ALPHA_U_MASK			0x000000FF
 #define LCD_SPU_COLORKEY_V			0x0138
-#define     CFG_CKEY_V2(v2)			((v2) << 24)
-#define     CFG_CKEY_V2_MASK			0xFF000000
-#define     CFG_CKEY_V1(v1)			((v1) << 16)
-#define     CFG_CKEY_V1_MASK			0x00FF0000
-#define     CFG_CKEY_V(v)			((v) << 8)
-#define     CFG_CKEY_V_MASK			0x0000FF00
-#define     CFG_ALPHA_V(v)			(v)
-#define     CFG_ALPHA_V_MASK			0x000000FF
+#define	 CFG_CKEY_V2(v2)			((v2)<<24)
+#define	 CFG_CKEY_V2_MASK			0xFF000000
+#define	 CFG_CKEY_V1(v1)			((v1)<<16)
+#define	 CFG_CKEY_V1_MASK			0x00FF0000
+#define	 CFG_CKEY_V(v)				((v)<<8)
+#define	 CFG_CKEY_V_MASK			0x0000FF00
+#define	 CFG_ALPHA_V(v)				(v)
+#define	 CFG_ALPHA_V_MASK			0x000000FF
+
+/* Graphics/Video DMA color key enable bits in LCD_TV_CTRL1 */
+#define	 CFG_CKEY_GRA				0x2
+#define	 CFG_CKEY_DMA				0x1
+
+/* Interlace mode enable bits in LCD_TV_CTRL1 */
+#define     CFG_TV_INTERLACE_EN                 (1 << 22)
+#define     CFG_TV_NIB                          (1 << 0)
+
+#define LCD_PN_SEPXLCNT				0x013c /* MMP2 */
 
 /* SPI Read Data Register */
 #define LCD_SPU_SPI_RXDATA			0x0140
 
 /* Smart Panel Read Data Register */
 #define LCD_SPU_ISA_RSDATA			0x0144
-#define     ISA_RXDATA_16BIT_1_DATA_MASK	0x000000FF
-#define     ISA_RXDATA_16BIT_2_DATA_MASK	0x0000FF00
-#define     ISA_RXDATA_16BIT_3_DATA_MASK	0x00FF0000
-#define     ISA_RXDATA_16BIT_4_DATA_MASK	0xFF000000
-#define     ISA_RXDATA_32BIT_1_DATA_MASK	0x00FFFFFF
+#define	 ISA_RXDATA_16BIT_1_DATA_MASK		0x000000FF
+#define	 ISA_RXDATA_16BIT_2_DATA_MASK		0x0000FF00
+#define	 ISA_RXDATA_16BIT_3_DATA_MASK		0x00FF0000
+#define	 ISA_RXDATA_16BIT_4_DATA_MASK		0xFF000000
+#define	 ISA_RXDATA_32BIT_1_DATA_MASK		0x00FFFFFF
+
+#define LCD_SPU_DBG_ISA				(0x0148) /* TTC */
+#define LCD_SPU_DMAVLD_YC			(0x014C)
+#define LCD_SPU_DMAVLD_UV			(0x0150)
+#define LCD_SPU_DMAVLD_UVSPU_GRAVLD		(0x0154)
+
+#define LCD_READ_IOPAD				(0x0148) /* MMP2*/
+#define LCD_DMAVLD_YC				(0x014C)
+#define LCD_DMAVLD_UV				(0x0150)
+#define LCD_TVGGRAVLD_HLEN			(0x0154)
 
 /* HWC SRAM Read Data Register */
 #define LCD_SPU_HWC_RDDAT			0x0158
 
 /* Gamma Table SRAM Read Data Register */
 #define LCD_SPU_GAMMA_RDDAT			0x015c
-#define     CFG_GAMMA_RDDAT_MASK		0x000000FF
+#define	 CFG_GAMMA_RDDAT_MASK			0x000000FF
 
 /* Palette Table SRAM Read Data Register */
 #define LCD_SPU_PALETTE_RDDAT			0x0160
-#define     CFG_PALETTE_RDDAT_MASK		0x00FFFFFF
+#define	 CFG_PALETTE_RDDAT_MASK			0x00FFFFFF
+
+#define LCD_SPU_DBG_DMATOP			(0x0164) /* TTC */
+#define LCD_SPU_DBG_GRATOP			(0x0168)
+#define LCD_SPU_DBG_TXCTRL			(0x016C)
+#define LCD_SPU_DBG_SLVTOP			(0x0170)
+#define LCD_SPU_DBG_MUXTOP			(0x0174)
+
+#define LCD_SLV_DBG				(0x0164) /* MMP2 */
+#define LCD_TVDVLD_YC				(0x0168)
+#define LCD_TVDVLD_UV				(0x016C)
+#define LCD_TVC_RDDAT				(0x0170)
+#define LCD_TV_GAMMA_RDDAT			(0x0174)
 
 /* I/O Pads Input Read Only Register */
 #define LCD_SPU_IOPAD_IN			0x0178
-#define     CFG_IOPAD_IN_MASK			0x0FFFFFFF
+#define	 CFG_IOPAD_IN_MASK			0x0FFFFFFF
+
+#define LCD_TV_PALETTE_RDDAT			(0x0178) /* MMP2 */
 
 /* Reserved Read Only Registers */
 #define LCD_CFG_RDREG5F				0x017C
-#define     IRE_FRAME_CNT_MASK			0x000000C0
-#define     IPE_FRAME_CNT_MASK			0x00000030
-#define     GRA_FRAME_CNT_MASK			0x0000000C  /* Graphic */
-#define     DMA_FRAME_CNT_MASK			0x00000003  /* Video */
+#define	 IRE_FRAME_CNT_MASK			0x000000C0
+#define	 IPE_FRAME_CNT_MASK			0x00000030
+#define	 GRA_FRAME_CNT_MASK			0x0000000C /* Graphic */
+#define	 DMA_FRAME_CNT_MASK			0x00000003 /* Video */
+
+#define LCD_FRAME_CNT				(0x017C) /* MMP2 */
 
 /* SPI Control Register. */
 #define LCD_SPU_SPI_CTRL			0x0180
-#define     CFG_SCLKCNT(div)			((div) << 24)  /* 0xFF~0x2 */
-#define     CFG_SCLKCNT_MASK			0xFF000000
-#define     CFG_RXBITS(rx)			((rx) << 16)   /* 0x1F~0x1 */
-#define     CFG_RXBITS_MASK			0x00FF0000
-#define     CFG_TXBITS(tx)			((tx) << 8)    /* 0x1F~0x1 */
-#define     CFG_TXBITS_MASK			0x0000FF00
-#define     CFG_CLKINV(clk)			((clk) << 7)
-#define     CFG_CLKINV_MASK			0x00000080
-#define     CFG_KEEPXFER(transfer)		((transfer) << 6)
-#define     CFG_KEEPXFER_MASK			0x00000040
-#define     CFG_RXBITSTO0(rx)			((rx) << 5)
-#define     CFG_RXBITSTO0_MASK			0x00000020
-#define     CFG_TXBITSTO0(tx)			((tx) << 4)
-#define     CFG_TXBITSTO0_MASK			0x00000010
-#define     CFG_SPI_ENA(spi)			((spi) << 3)
-#define     CFG_SPI_ENA_MASK			0x00000008
-#define     CFG_SPI_SEL(spi)			((spi) << 2)
-#define     CFG_SPI_SEL_MASK			0x00000004
-#define     CFG_SPI_3W4WB(wire)			((wire) << 1)
-#define     CFG_SPI_3W4WB_MASK			0x00000002
-#define     CFG_SPI_START(start)		(start)
-#define     CFG_SPI_START_MASK			0x00000001
+#define	 CFG_SCLKCNT(div)			((div)<<24) /* 0xFF~0x2 */
+#define	 CFG_SCLKCNT_MASK			0xFF000000
+#define	 CFG_RXBITS(rx)				(((rx) - 1)<<16) /* 0x1F~0x1 */
+#define	 CFG_RXBITS_MASK			0x00FF0000
+#define	 CFG_TXBITS(tx)				(((tx) - 1)<<8) /* 0x1F~0x1 */
+#define	 CFG_TXBITS_MASK			0x0000FF00
+#define	 CFG_CLKINV(clk)			((clk)<<7)
+#define	 CFG_CLKINV_MASK			0x00000080
+#define	 CFG_KEEPXFER(transfer)			((transfer)<<6)
+#define	 CFG_KEEPXFER_MASK			0x00000040
+#define	 CFG_RXBITSTO0(rx)			((rx)<<5)
+#define	 CFG_RXBITSTO0_MASK			0x00000020
+#define	 CFG_TXBITSTO0(tx)			((tx)<<4)
+#define	 CFG_TXBITSTO0_MASK			0x00000010
+#define	 CFG_SPI_ENA(spi)			((spi)<<3)
+#define	 CFG_SPI_ENA_MASK			0x00000008
+#define	 CFG_SPI_SEL(spi)			((spi)<<2)
+#define	 CFG_SPI_SEL_MASK			0x00000004
+#define	 CFG_SPI_3W4WB(wire)			((wire)<<1)
+#define	 CFG_SPI_3W4WB_MASK			0x00000002
+#define	 CFG_SPI_START(start)			(start)
+#define	 CFG_SPI_START_MASK			0x00000001
 
 /* SPI Tx Data Register */
 #define LCD_SPU_SPI_TXDATA			0x0184
@@ -205,97 +427,115 @@
 
 /* DMA Control 0 Register */
 #define LCD_SPU_DMA_CTRL0			0x0190
-#define     CFG_NOBLENDING(nb)			((nb) << 31)
-#define     CFG_NOBLENDING_MASK			0x80000000
-#define     CFG_GAMMA_ENA(gn)			((gn) << 30)
-#define     CFG_GAMMA_ENA_MASK			0x40000000
-#define     CFG_CBSH_ENA(cn)			((cn) << 29)
-#define     CFG_CBSH_ENA_MASK			0x20000000
-#define     CFG_PALETTE_ENA(pn)			((pn) << 28)
-#define     CFG_PALETTE_ENA_MASK		0x10000000
-#define     CFG_ARBFAST_ENA(an)			((an) << 27)
-#define     CFG_ARBFAST_ENA_MASK		0x08000000
-#define     CFG_HWC_1BITMOD(mode)		((mode) << 26)
-#define     CFG_HWC_1BITMOD_MASK		0x04000000
-#define     CFG_HWC_1BITENA(mn)			((mn) << 25)
-#define     CFG_HWC_1BITENA_MASK		0x02000000
-#define     CFG_HWC_ENA(cn)		        ((cn) << 24)
-#define     CFG_HWC_ENA_MASK			0x01000000
-#define     CFG_DMAFORMAT(dmaformat)		((dmaformat) << 20)
-#define     CFG_DMAFORMAT_MASK			0x00F00000
-#define     CFG_GRAFORMAT(graformat)		((graformat) << 16)
-#define     CFG_GRAFORMAT_MASK			0x000F0000
+#define	 CFG_NOBLENDING(nb)			((nb)<<31)
+#define	 CFG_NOBLENDING_MASK			0x80000000
+#define	 CFG_GAMMA_ENA(gn)			((gn)<<30)
+#define	 CFG_GAMMA_ENA_MASK			0x40000000
+#define	 CFG_CBSH_ENA(cn)			((cn)<<29)
+#define	 CFG_CBSH_ENA_MASK			0x20000000
+#define	 CFG_PALETTE_ENA(pn)			((pn)<<28)
+#define	 CFG_PALETTE_ENA_MASK			0x10000000
+#define	 CFG_ARBFAST_ENA(an)			((an)<<27)
+#define	 CFG_ARBFAST_ENA_MASK			0x08000000
+#define	 CFG_HWC_1BITMOD(mode)			((mode)<<26)
+#define	 CFG_HWC_1BITMOD_MASK			0x04000000
+#define	 CFG_HWC_1BITENA(mn)			((mn)<<25)
+#define	 CFG_HWC_1BITENA_MASK			0x02000000
+#define	 CFG_HWC_ENA(cn)			((cn)<<24)
+#define	 CFG_HWC_ENA_MASK			0x01000000
+#define	 CFG_DMAFORMAT(dmaformat)		((dmaformat)<<20)
+#define	 CFG_DMAFORMAT_MASK			0x00F00000
+#define	 CFG_GRAFORMAT(graformat)		((graformat)<<16)
+#define	 CFG_GRAFORMAT_MASK			0x000F0000
 /* for graphic part */
-#define     CFG_GRA_FTOGGLE(toggle)		((toggle) << 15)
-#define     CFG_GRA_FTOGGLE_MASK		0x00008000
-#define     CFG_GRA_HSMOOTH(smooth)		((smooth) << 14)
-#define     CFG_GRA_HSMOOTH_MASK		0x00004000
-#define     CFG_GRA_TSTMODE(test)		((test) << 13)
-#define     CFG_GRA_TSTMODE_MASK		0x00002000
-#define     CFG_GRA_SWAPRB(swap)		((swap) << 12)
-#define     CFG_GRA_SWAPRB_MASK			0x00001000
-#define     CFG_GRA_SWAPUV(swap)		((swap) << 11)
-#define     CFG_GRA_SWAPUV_MASK			0x00000800
-#define     CFG_GRA_SWAPYU(swap)		((swap) << 10)
-#define     CFG_GRA_SWAPYU_MASK			0x00000400
-#define     CFG_YUV2RGB_GRA(cvrt)		((cvrt) << 9)
-#define     CFG_YUV2RGB_GRA_MASK		0x00000200
-#define     CFG_GRA_ENA(gra)			((gra) << 8)
-#define     CFG_GRA_ENA_MASK			0x00000100
+#define	 CFG_GRA_FTOGGLE(toggle)		((toggle)<<15)
+#define	 CFG_GRA_FTOGGLE_MASK			0x00008000
+#define	 CFG_GRA_HSMOOTH(smooth)		((smooth)<<14)
+#define	 CFG_GRA_HSMOOTH_MASK			0x00004000
+#define	 CFG_GRA_TSTMODE(test)			((test)<<13)
+#define	 CFG_GRA_TSTMODE_MASK			0x00002000
+#define	 CFG_GRA_SWAPRB(swap)			((swap)<<12)
+#define	 CFG_GRA_SWAPRB_MASK			0x00001000
+#define	 CFG_GRA_SWAPUV(swap)			((swap)<<11)
+#define	 CFG_GRA_SWAPUV_MASK			0x00000800
+#define	 CFG_GRA_SWAPYU(swap)			((swap)<<10)
+#define	 CFG_GRA_SWAPYU_MASK			0x00000400
+#define	 CFG_GRA_SWAP_MASK			0x00001C00
+#define	 CFG_YUV2RGB_GRA(cvrt)			((cvrt)<<9)
+#define	 CFG_YUV2RGB_GRA_MASK			0x00000200
+#define	 CFG_GRA_ENA(gra)			((gra)<<8)
+#define	 CFG_GRA_ENA_MASK			0x00000100
+#define dma0_gfx_masks	(CFG_GRAFORMAT_MASK | CFG_GRA_FTOGGLE_MASK | \
+	CFG_GRA_HSMOOTH_MASK | CFG_GRA_TSTMODE_MASK | CFG_GRA_SWAP_MASK | \
+	CFG_YUV2RGB_GRA_MASK | CFG_GRA_ENA_MASK)
 /* for video part */
-#define     CFG_DMA_FTOGGLE(toggle)		((toggle) << 7)
-#define     CFG_DMA_FTOGGLE_MASK		0x00000080
-#define     CFG_DMA_HSMOOTH(smooth)		((smooth) << 6)
-#define     CFG_DMA_HSMOOTH_MASK		0x00000040
-#define     CFG_DMA_TSTMODE(test)		((test) << 5)
-#define     CFG_DMA_TSTMODE_MASK		0x00000020
-#define     CFG_DMA_SWAPRB(swap)		((swap) << 4)
-#define     CFG_DMA_SWAPRB_MASK			0x00000010
-#define     CFG_DMA_SWAPUV(swap)		((swap) << 3)
-#define     CFG_DMA_SWAPUV_MASK			0x00000008
-#define     CFG_DMA_SWAPYU(swap)		((swap) << 2)
-#define     CFG_DMA_SWAPYU_MASK			0x00000004
-#define     CFG_DMA_SWAP_MASK			0x0000001C
-#define     CFG_YUV2RGB_DMA(cvrt)		((cvrt) << 1)
-#define     CFG_YUV2RGB_DMA_MASK		0x00000002
-#define     CFG_DMA_ENA(video)			(video)
-#define     CFG_DMA_ENA_MASK			0x00000001
+#define	 CFG_DMA_FTOGGLE(toggle)		((toggle)<<7)
+#define	 CFG_DMA_FTOGGLE_MASK			0x00000080
+#define	 CFG_DMA_HSMOOTH(smooth)		((smooth)<<6)
+#define	 CFG_DMA_HSMOOTH_MASK			0x00000040
+#define	 CFG_DMA_TSTMODE(test)			((test)<<5)
+#define	 CFG_DMA_TSTMODE_MASK			0x00000020
+#define	 CFG_DMA_SWAPRB(swap)			((swap)<<4)
+#define	 CFG_DMA_SWAPRB_MASK			0x00000010
+#define	 CFG_DMA_SWAPUV(swap)			((swap)<<3)
+#define	 CFG_DMA_SWAPUV_MASK			0x00000008
+#define	 CFG_DMA_SWAPYU(swap)			((swap)<<2)
+#define	 CFG_DMA_SWAPYU_MASK			0x00000004
+#define	 CFG_DMA_SWAP_MASK			0x0000001C
+#define	 CFG_YUV2RGB_DMA(cvrt)			((cvrt)<<1)
+#define	 CFG_YUV2RGB_DMA_MASK			0x00000002
+#define	 CFG_DMA_ENA(video)			(video)
+#define	 CFG_DMA_ENA_MASK			0x00000001
+#define dma0_vid_masks	(CFG_DMAFORMAT_MASK | CFG_DMA_FTOGGLE_MASK | \
+	CFG_DMA_HSMOOTH_MASK | CFG_DMA_TSTMODE_MASK | CFG_DMA_SWAP_MASK | \
+	CFG_YUV2RGB_DMA_MASK | CFG_DMA_ENA_MASK)
+#define dma_palette(val)		((val ? 1 : 0) << 28)
+#define dma_fmt(vid, val)		((val & 0xf) << ((vid) ? 20 : 16))
+#define dma_swaprb(vid, val)		((val ? 1 : 0) << ((vid) ? 4 : 12))
+#define dma_swapuv(vid, val)		((val ? 1 : 0) << ((vid) ? 3 : 11))
+#define dma_swapyuv(vid, val)		((val ? 1 : 0) << ((vid) ? 2 : 10))
+#define dma_csc(vid, val)		((val ? 1 : 0) << ((vid) ? 1 : 9))
+#define dma_hsmooth(vid, val)		((val ? 1 : 0) << ((vid) ? 6 : 14))
+#define dma_mask(vid)	(dma_palette(1) | dma_fmt(vid, 0xf) | dma_csc(vid, 1) \
+	| dma_swaprb(vid, 1) | dma_swapuv(vid, 1) | dma_swapyuv(vid, 1))
+#define swap_spuv(id)			((id) ? (((id) == 1) ? 2 : 4) : 1)
+#define yuvsp_mask(id)			((id) ? (((id) == 1) ? 2 : 4) : 1)
 
 /* DMA Control 1 Register */
 #define LCD_SPU_DMA_CTRL1			0x0194
-#define     CFG_FRAME_TRIG(trig)		((trig) << 31)
-#define     CFG_FRAME_TRIG_MASK			0x80000000
-#define     CFG_VSYNC_TRIG(trig)		((trig) << 28)
-#define     CFG_VSYNC_TRIG_MASK			0x70000000
-#define     CFG_VSYNC_INV(inv)			((inv) << 27)
-#define     CFG_VSYNC_INV_MASK			0x08000000
-#define     CFG_COLOR_KEY_MODE(cmode)		((cmode) << 24)
-#define     CFG_COLOR_KEY_MASK			0x07000000
-#define     CFG_CARRY(carry)			((carry) << 23)
-#define     CFG_CARRY_MASK			0x00800000
-#define     CFG_LNBUF_ENA(lnbuf)		((lnbuf) << 22)
-#define     CFG_LNBUF_ENA_MASK			0x00400000
-#define     CFG_GATED_ENA(gated)		((gated) << 21)
-#define     CFG_GATED_ENA_MASK			0x00200000
-#define     CFG_PWRDN_ENA(power)		((power) << 20)
-#define     CFG_PWRDN_ENA_MASK			0x00100000
-#define     CFG_DSCALE(dscale)			((dscale) << 18)
-#define     CFG_DSCALE_MASK			0x000C0000
-#define     CFG_ALPHA_MODE(amode)		((amode) << 16)
-#define     CFG_ALPHA_MODE_MASK			0x00030000
-#define     CFG_ALPHA(alpha)			((alpha) << 8)
-#define     CFG_ALPHA_MASK			0x0000FF00
-#define     CFG_PXLCMD(pxlcmd)			(pxlcmd)
-#define     CFG_PXLCMD_MASK			0x000000FF
+#define	 CFG_FRAME_TRIG(trig)			((trig)<<31)
+#define	 CFG_FRAME_TRIG_MASK			0x80000000
+#define	 CFG_VSYNC_TRIG(trig)			((trig)<<28)
+#define	 CFG_VSYNC_TRIG_MASK			0x70000000
+#define	 CFG_VSYNC_INV(inv)			((inv)<<27)
+#define	 CFG_VSYNC_INV_MASK			0x08000000
+#define	 CFG_COLOR_KEY_MODE(cmode)		((cmode)<<24)
+#define	 CFG_COLOR_KEY_MASK			0x07000000
+#define	 CFG_CARRY(carry)			((carry)<<23)
+#define	 CFG_CARRY_MASK				0x00800000
+#define	 CFG_LNBUF_ENA(lnbuf)			((lnbuf)<<22)
+#define	 CFG_LNBUF_ENA_MASK			0x00400000
+#define	 CFG_GATED_ENA(gated)			((gated)<<21)
+#define	 CFG_GATED_ENA_MASK			0x00200000
+#define	 CFG_PWRDN_ENA(power)			((power)<<20)
+#define	 CFG_PWRDN_ENA_MASK			0x00100000
+#define	 CFG_DSCALE(dscale)			((dscale)<<18)
+#define	 CFG_DSCALE_MASK			0x000C0000
+#define	 CFG_ALPHA_MODE(amode)			((amode)<<16)
+#define	 CFG_ALPHA_MODE_MASK			0x00030000
+#define	 CFG_ALPHA(alpha)			((alpha)<<8)
+#define	 CFG_ALPHA_MASK				0x0000FF00
+#define	 CFG_PXLCMD(pxlcmd)			(pxlcmd)
+#define	 CFG_PXLCMD_MASK			0x000000FF
 
 /* SRAM Control Register */
 #define LCD_SPU_SRAM_CTRL			0x0198
-#define     CFG_SRAM_INIT_WR_RD(mode)		((mode) << 14)
-#define     CFG_SRAM_INIT_WR_RD_MASK		0x0000C000
-#define     CFG_SRAM_ADDR_LCDID(id)		((id) << 8)
-#define     CFG_SRAM_ADDR_LCDID_MASK		0x00000F00
-#define     CFG_SRAM_ADDR(addr)			(addr)
-#define     CFG_SRAM_ADDR_MASK			0x000000FF
+#define	 CFG_SRAM_INIT_WR_RD(mode)		((mode)<<14)
+#define	 CFG_SRAM_INIT_WR_RD_MASK		0x0000C000
+#define	 CFG_SRAM_ADDR_LCDID(id)		((id)<<8)
+#define	 CFG_SRAM_ADDR_LCDID_MASK		0x00000F00
+#define	 CFG_SRAM_ADDR(addr)			(addr)
+#define	 CFG_SRAM_ADDR_MASK			0x000000FF
 
 /* SRAM Write Data Register */
 #define LCD_SPU_SRAM_WRDAT			0x019C
@@ -305,178 +545,412 @@
 
 /* SRAM Power Down Control Register */
 #define LCD_SPU_SRAM_PARA1			0x01A4
-#define     CFG_CSB_256x32(hwc)			((hwc) << 15)	/* HWC */
-#define     CFG_CSB_256x32_MASK			0x00008000
-#define     CFG_CSB_256x24(palette)		((palette) << 14)	/* Palette */
-#define     CFG_CSB_256x24_MASK			0x00004000
-#define     CFG_CSB_256x8(gamma)		((gamma) << 13)	/* Gamma */
-#define     CFG_CSB_256x8_MASK			0x00002000
-#define     CFG_PDWN256x32(pdwn)		((pdwn) << 7)	/* HWC */
-#define     CFG_PDWN256x32_MASK			0x00000080
-#define     CFG_PDWN256x24(pdwn)		((pdwn) << 6)	/* Palette */
-#define     CFG_PDWN256x24_MASK			0x00000040
-#define     CFG_PDWN256x8(pdwn)			((pdwn) << 5)	/* Gamma */
-#define     CFG_PDWN256x8_MASK			0x00000020
-#define     CFG_PDWN32x32(pdwn)			((pdwn) << 3)
-#define     CFG_PDWN32x32_MASK			0x00000008
-#define     CFG_PDWN16x66(pdwn)			((pdwn) << 2)
-#define     CFG_PDWN16x66_MASK			0x00000004
-#define     CFG_PDWN32x66(pdwn)			((pdwn) << 1)
-#define     CFG_PDWN32x66_MASK			0x00000002
-#define     CFG_PDWN64x66(pdwn)			(pdwn)
-#define     CFG_PDWN64x66_MASK			0x00000001
+#define	 CFG_CSB_256x32(hwc)			((hwc)<<15)	/* HWC */
+#define	 CFG_CSB_256x32_MASK			0x00008000
+#define	 CFG_CSB_256x24(palette)		((palette)<<14)	/* Palette */
+#define	 CFG_CSB_256x24_MASK			0x00004000
+#define	 CFG_CSB_256x8(gamma)			((gamma)<<13)	/* Gamma */
+#define	 CFG_CSB_256x8_MASK			0x00002000
+#define	 CFG_PDWN256x32(pdwn)			((pdwn)<<7)	/* HWC */
+#define	 CFG_PDWN256x32_MASK			0x00000080
+#define	 CFG_PDWN256x24(pdwn)			((pdwn)<<6)	/* Palette */
+#define	 CFG_PDWN256x24_MASK			0x00000040
+#define	 CFG_PDWN256x8(pdwn)			((pdwn)<<5)	/* Gamma */
+#define	 CFG_PDWN256x8_MASK			0x00000020
+#define	 CFG_PDWN32x32(pdwn)			((pdwn)<<3)
+#define	 CFG_PDWN32x32_MASK			0x00000008
+#define	 CFG_PDWN16x66(pdwn)			((pdwn)<<2)
+#define	 CFG_PDWN16x66_MASK			0x00000004
+#define	 CFG_PDWN32x66(pdwn)			((pdwn)<<1)
+#define	 CFG_PDWN32x66_MASK			0x00000002
+#define	 CFG_PDWN64x66(pdwn)			(pdwn)
+#define	 CFG_PDWN64x66_MASK			0x00000001
 
 /* Smart or Dumb Panel Clock Divider */
 #define LCD_CFG_SCLK_DIV			0x01A8
-#define     SCLK_SOURCE_SELECT(src)		((src) << 31)
-#define     SCLK_SOURCE_SELECT_MASK		0x80000000
-#define     CLK_FRACDIV(frac)			((frac) << 16)
-#define     CLK_FRACDIV_MASK			0x0FFF0000
-#define     CLK_INT_DIV(div)			(div)
-#define     CLK_INT_DIV_MASK			0x0000FFFF
+#define	 SCLK_SOURCE_SELECT(src)		((src)<<30)
+#define	 SCLK_SOURCE_SELECT_MASK		0xc0000000
+#define  SCLK_SOURCE_AXI 			(0x0 << 30)
+#define  SCLK_SOURCE_DISP1 			(0x1 << 30)
+#define  SCLK_SOURCE_DISP2 			(0x2 << 30)
+#define  SCLK_SOURCE_DSI_PLL 			(0x3 << 30)
+#define  SCLK_DISABLE				(1<<28)
+#define	 CLK_FRACDIV(frac)			((frac)<<16)
+#define	 CLK_FRACDIV_MASK			0x0FFF0000
+#define	 DSI1_BITCLK_DIV(div)			(div<<8)
+#define	 DSI1_BITCLK_DIV_MASK			0x00000F00
+#define	 CLK_INT_DIV(div)			(div)
+#define	 CLK_INT_DIV_MASK			0x000000FF
 
 /* Video Contrast Register */
 #define LCD_SPU_CONTRAST			0x01AC
-#define     CFG_BRIGHTNESS(bright)		((bright) << 16)
-#define     CFG_BRIGHTNESS_MASK			0xFFFF0000
-#define     CFG_CONTRAST(contrast)		(contrast)
-#define     CFG_CONTRAST_MASK			0x0000FFFF
+#define	 CFG_BRIGHTNESS(bright)			((bright)<<16)
+#define	 CFG_BRIGHTNESS_MASK			0xFFFF0000
+#define	 CFG_CONTRAST(contrast)			(contrast)
+#define	 CFG_CONTRAST_MASK			0x0000FFFF
 
 /* Video Saturation Register */
 #define LCD_SPU_SATURATION			0x01B0
-#define     CFG_C_MULTS(mult)			((mult) << 16)
-#define     CFG_C_MULTS_MASK			0xFFFF0000
-#define     CFG_SATURATION(sat)			(sat)
-#define     CFG_SATURATION_MASK			0x0000FFFF
+#define	 CFG_C_MULTS(mult)			((mult)<<16)
+#define	 CFG_C_MULTS_MASK			0xFFFF0000
+#define	 CFG_SATURATION(sat)			(sat)
+#define	 CFG_SATURATION_MASK			0x0000FFFF
 
 /* Video Hue Adjust Register */
 #define LCD_SPU_CBSH_HUE			0x01B4
-#define     CFG_SIN0(sin0)			((sin0) << 16)
-#define     CFG_SIN0_MASK			0xFFFF0000
-#define     CFG_COS0(con0)			(con0)
-#define     CFG_COS0_MASK			0x0000FFFF
+#define	 CFG_SIN0(sin0)				((sin0)<<16)
+#define	 CFG_SIN0_MASK				0xFFFF0000
+#define	 CFG_COS0(con0)				(con0)
+#define	 CFG_COS0_MASK				0x0000FFFF
 
 /* Dump LCD Panel Control Register */
 #define LCD_SPU_DUMB_CTRL			0x01B8
-#define     CFG_DUMBMODE(mode)			((mode) << 28)
-#define     CFG_DUMBMODE_MASK			0xF0000000
-#define     CFG_LCDGPIO_O(data)			((data) << 20)
-#define     CFG_LCDGPIO_O_MASK			0x0FF00000
-#define     CFG_LCDGPIO_ENA(gpio)		((gpio) << 12)
-#define     CFG_LCDGPIO_ENA_MASK		0x000FF000
-#define     CFG_BIAS_OUT(bias)			((bias) << 8)
-#define     CFG_BIAS_OUT_MASK			0x00000100
-#define     CFG_REVERSE_RGB(rRGB)		((rRGB) << 7)
-#define     CFG_REVERSE_RGB_MASK		0x00000080
-#define     CFG_INV_COMPBLANK(blank)		((blank) << 6)
-#define     CFG_INV_COMPBLANK_MASK		0x00000040
-#define     CFG_INV_COMPSYNC(sync)		((sync) << 5)
-#define     CFG_INV_COMPSYNC_MASK		0x00000020
-#define     CFG_INV_HENA(hena)			((hena) << 4)
-#define     CFG_INV_HENA_MASK			0x00000010
-#define     CFG_INV_VSYNC(vsync)		((vsync) << 3)
-#define     CFG_INV_VSYNC_MASK			0x00000008
-#define     CFG_INV_HSYNC(hsync)		((hsync) << 2)
-#define     CFG_INV_HSYNC_MASK			0x00000004
-#define     CFG_INV_PCLK(pclk)			((pclk) << 1)
-#define     CFG_INV_PCLK_MASK			0x00000002
-#define     CFG_DUMB_ENA(dumb)			(dumb)
-#define     CFG_DUMB_ENA_MASK			0x00000001
+#define	 CFG_DUMBMODE(mode)			((mode)<<28)
+#define	 CFG_DUMBMODE_MASK			0xF0000000
+#define	 CFG_LCDGPIO_O(data)			((data)<<20)
+#define	 CFG_LCDGPIO_O_MASK			0x0FF00000
+#define	 CFG_LCDGPIO_ENA(gpio)			((gpio)<<12)
+#define	 CFG_LCDGPIO_ENA_MASK			0x000FF000
+#define	 CFG_BIAS_OUT(bias)			((bias)<<8)
+#define	 CFG_BIAS_OUT_MASK			0x00000100
+#define	 CFG_REVERSE_RGB(rRGB)			((rRGB)<<7)
+#define	 CFG_REVERSE_RGB_MASK			0x00000080
+#define	 CFG_INV_COMPBLANK(blank)		((blank)<<6)
+#define	 CFG_INV_COMPBLANK_MASK			0x00000040
+#define	 CFG_INV_COMPSYNC(sync)			((sync)<<5)
+#define	 CFG_INV_COMPSYNC_MASK			0x00000020
+#define	 CFG_INV_HENA(hena)			((hena)<<4)
+#define	 CFG_INV_HENA_MASK			0x00000010
+#define	 CFG_INV_VSYNC(vsync)			((vsync)<<3)
+#define	 CFG_INV_VSYNC_MASK			0x00000008
+#define	 CFG_INV_HSYNC(hsync)			((hsync)<<2)
+#define	 CFG_INV_HSYNC_MASK			0x00000004
+#define	 CFG_INV_PCLK(pclk)			((pclk)<<1)
+#define	 CFG_INV_PCLK_MASK			0x00000002
+#define	 CFG_DUMB_ENA(dumb)			(dumb)
+#define	 CFG_DUMB_ENA_MASK			0x00000001
 
 /* LCD I/O Pads Control Register */
 #define SPU_IOPAD_CONTROL			0x01BC
-#define     CFG_GRA_VM_ENA(vm)			((vm) << 15)        /* gfx */
-#define     CFG_GRA_VM_ENA_MASK			0x00008000
-#define     CFG_DMA_VM_ENA(vm)			((vm) << 13)	/* video */
-#define     CFG_DMA_VM_ENA_MASK			0x00002000
-#define     CFG_CMD_VM_ENA(vm)			((vm) << 13)
-#define     CFG_CMD_VM_ENA_MASK			0x00000800
-#define     CFG_CSC(csc)			((csc) << 8)	/* csc */
-#define     CFG_CSC_MASK			0x00000300
-#define     CFG_AXICTRL(axi)			((axi) << 4)
-#define     CFG_AXICTRL_MASK			0x000000F0
-#define     CFG_IOPADMODE(iopad)		(iopad)
-#define     CFG_IOPADMODE_MASK			0x0000000F
+#define	 CFG_GRA_VM_ENA(vm)			((vm)<<15)
+#define	 CFG_GRA_VM_ENA_MASK			0x00008000
+#define	 CFG_DMA_VM_ENA(vm)			((vm)<<13)
+#define	 CFG_DMA_VM_ENA_MASK			0x00002000
+#define	 CFG_CMD_VM_ENA(vm)			((vm)<<13)
+#define	 CFG_CMD_VM_ENA_MASK			0x00000800
+#define	 CFG_CSC(csc)				((csc)<<8)
+#define	 CFG_CSC_MASK				0x00000300
+#define	 CFG_CYC_BURST_LEN16			(1<<4)
+#define	 CFG_CYC_BURST_LEN8			(0<<4)
+#define	 CFG_IOPADMODE(iopad)			(iopad)
+#define	 CFG_IOPADMODE_MASK			0x0000000F
 
 /* LCD Interrupt Control Register */
 #define SPU_IRQ_ENA				0x01C0
-#define     DMA_FRAME_IRQ0_ENA(irq)		((irq) << 31)
-#define     DMA_FRAME_IRQ0_ENA_MASK		0x80000000
-#define     DMA_FRAME_IRQ1_ENA(irq)		((irq) << 30)
-#define     DMA_FRAME_IRQ1_ENA_MASK		0x40000000
-#define     DMA_FF_UNDERFLOW_ENA(ff)		((ff) << 29)
-#define     DMA_FF_UNDERFLOW_ENA_MASK		0x20000000
-#define     GRA_FRAME_IRQ0_ENA(irq)		((irq) << 27)
-#define     GRA_FRAME_IRQ0_ENA_MASK		0x08000000
-#define     GRA_FRAME_IRQ1_ENA(irq)		((irq) << 26)
-#define     GRA_FRAME_IRQ1_ENA_MASK		0x04000000
-#define     GRA_FF_UNDERFLOW_ENA(ff)		((ff) << 25)
-#define     GRA_FF_UNDERFLOW_ENA_MASK		0x02000000
-#define     VSYNC_IRQ_ENA(vsync_irq)		((vsync_irq) << 23)
-#define     VSYNC_IRQ_ENA_MASK			0x00800000
-#define     DUMB_FRAMEDONE_ENA(fdone)		((fdone) << 22)
-#define     DUMB_FRAMEDONE_ENA_MASK		0x00400000
-#define     TWC_FRAMEDONE_ENA(fdone)		((fdone) << 21)
-#define     TWC_FRAMEDONE_ENA_MASK		0x00200000
-#define     HWC_FRAMEDONE_ENA(fdone)		((fdone) << 20)
-#define     HWC_FRAMEDONE_ENA_MASK		0x00100000
-#define     SLV_IRQ_ENA(irq)			((irq) << 19)
-#define     SLV_IRQ_ENA_MASK			0x00080000
-#define     SPI_IRQ_ENA(irq)			((irq) << 18)
-#define     SPI_IRQ_ENA_MASK			0x00040000
-#define     PWRDN_IRQ_ENA(irq)			((irq) << 17)
-#define     PWRDN_IRQ_ENA_MASK			0x00020000
-#define     ERR_IRQ_ENA(irq)			((irq) << 16)
-#define     ERR_IRQ_ENA_MASK			0x00010000
-#define     CLEAN_SPU_IRQ_ISR(irq)		(irq)
-#define     CLEAN_SPU_IRQ_ISR_MASK		0x0000FFFF
+#define	 DMA_FRAME_IRQ0_ENA(irq)		((irq)<<31)
+#define	 DMA_FRAME_IRQ0_ENA_MASK		0x80000000
+#define	 DMA_FRAME_IRQ1_ENA(irq)		((irq)<<30)
+#define	 DMA_FRAME_IRQ1_ENA_MASK		0x40000000
+#define	 DMA_FF_UNDERFLOW_ENA(ff)		((ff)<<29)
+#define	 DMA_FF_UNDERFLOW_ENA_MASK		0x20000000
+#define	 AXI_BUS_ERROR_IRQ_ENA(irq)		((irq)<<28)
+#define	 AXI_BUS_ERROR_IRQ_ENA_MASK		0x10000000
+#define	 GRA_FRAME_IRQ0_ENA(irq)		((irq)<<27)
+#define	 GRA_FRAME_IRQ0_ENA_MASK		0x08000000
+#define	 GRA_FRAME_IRQ1_ENA(irq)		((irq)<<26)
+#define	 GRA_FRAME_IRQ1_ENA_MASK		0x04000000
+#define	 GRA_FF_UNDERFLOW_ENA(ff)		((ff)<<25)
+#define	 GRA_FF_UNDERFLOW_ENA_MASK		0x02000000
+#define	 VSYNC_IRQ_ENA(vsync_irq)		((vsync_irq)<<23)
+#define	 VSYNC_IRQ_ENA_MASK			0x00800000
+#define	 DUMB_FRAMEDONE_ENA(fdone)		((fdone)<<22)
+#define	 DUMB_FRAMEDONE_ENA_MASK		0x00400000
+#define	 TWC_FRAMEDONE_ENA(fdone)		((fdone)<<21)
+#define	 TWC_FRAMEDONE_ENA_MASK			0x00200000
+#define	 HWC_FRAMEDONE_ENA(fdone)		((fdone)<<20)
+#define	 HWC_FRAMEDONE_ENA_MASK			0x00100000
+#define	 SLV_IRQ_ENA(irq)			((irq)<<19)
+#define	 SLV_IRQ_ENA_MASK			0x00080000
+#define	 SPI_IRQ_ENA(irq)			((irq)<<18)
+#define	 SPI_IRQ_ENA_MASK			0x00040000
+#define	 PWRDN_IRQ_ENA(irq)			((irq)<<17)
+#define	 PWRDN_IRQ_ENA_MASK			0x00020000
+#define	 AXI_LATENCY_TOO_LONG_IRQ_ENA(irq)	((irq)<<16)
+#define  AXI_LATENCY_TOO_LONG_IRQ_ENA_MASK	0x00010000
+#define	 CLEAN_SPU_IRQ_ISR(irq)			(irq)
+#define	 CLEAN_SPU_IRQ_ISR_MASK			0x0000FFFF
+#define	 TV_DMA_FRAME_IRQ0_ENA(irq)		((irq)<<15)
+#define	 TV_DMA_FRAME_IRQ0_ENA_MASK		0x00008000
+#define	 TV_DMA_FRAME_IRQ1_ENA(irq)		((irq)<<14)
+#define	 TV_DMA_FRAME_IRQ1_ENA_MASK		0x00004000
+#define	 TV_DMA_FF_UNDERFLOW_ENA(unerrun)	((unerrun)<<13)
+#define	 TV_DMA_FF_UNDERFLOW_ENA_MASK		0x00002000
+#define	 TVSYNC_IRQ_ENA(irq)			((irq)<<12)
+#define	 TVSYNC_IRQ_ENA_MASK			0x00001000
+#define	 TV_FRAME_IRQ0_ENA(irq)			((irq)<<11)
+#define	 TV_FRAME_IRQ0_ENA_MASK			0x00000800
+#define	 TV_FRAME_IRQ1_ENA(irq)			((irq)<<10)
+#define	 TV_FRAME_IRQ1_ENA_MASK			0x00000400
+#define	 TV_GRA_FF_UNDERFLOW_ENA(unerrun)	((unerrun)<<9)
+#define	 TV_GRA_FF_UNDERFLOW_ENA_MASK		0x00000200
+#define	 TV_FRAMEDONE_ENA(irq)			((irq)<<8)
+#define	 TV_FRAMEDONE_ENA_MASK			0x00000100
+
+/* FIXME - JUST GUESS */
+#define	 PN2_DMA_FRAME_IRQ0_ENA(irq)		((irq)<<7)
+#define	 PN2_DMA_FRAME_IRQ0_ENA_MASK		0x00000080
+#define	 PN2_DMA_FRAME_IRQ1_ENA(irq)		((irq)<<6)
+#define	 PN2_DMA_FRAME_IRQ1_ENA_MASK		0x00000040
+#define	 PN2_DMA_FF_UNDERFLOW_ENA(ff)		((ff)<<5)
+#define	 PN2_DMA_FF_UNDERFLOW_ENA_MASK		0x00000020
+#define	 PN2_GRA_FRAME_IRQ0_ENA(irq)		((irq)<<3)
+#define	 PN2_GRA_FRAME_IRQ0_ENA_MASK		0x00000008
+#define	 PN2_GRA_FRAME_IRQ1_ENA(irq)		((irq)<<2)
+#define	 PN2_GRA_FRAME_IRQ1_ENA_MASK		0x04000004
+#define	 PN2_GRA_FF_UNDERFLOW_ENA(ff)		((ff)<<1)
+#define	 PN2_GRA_FF_UNDERFLOW_ENA_MASK		0x00000002
+#define	 PN2_VSYNC_IRQ_ENA(irq)			((irq)<<0)
+#define	 PN2_SYNC_IRQ_ENA_MASK			0x00000001
+
+#define gf0_imask(id)	((id) ? (((id) & 1) ? TV_FRAME_IRQ0_ENA_MASK \
+		: PN2_GRA_FRAME_IRQ0_ENA_MASK) : GRA_FRAME_IRQ0_ENA_MASK)
+#define gf1_imask(id)	((id) ? (((id) & 1) ? TV_FRAME_IRQ1_ENA_MASK \
+		: PN2_GRA_FRAME_IRQ1_ENA_MASK) : GRA_FRAME_IRQ1_ENA_MASK)
+#define vsync_imask(id)	((id) ? (((id) & 1) ? TVSYNC_IRQ_ENA_MASK \
+		: PN2_SYNC_IRQ_ENA_MASK) : VSYNC_IRQ_ENA_MASK)
+#define vsync_imasks	(vsync_imask(0) | vsync_imask(1))
+
+#define display_done_imask(id)	((id) ? (((id) & 1) ? TV_FRAMEDONE_ENA_MASK\
+	: (PN2_DMA_FRAME_IRQ0_ENA_MASK | PN2_DMA_FRAME_IRQ1_ENA_MASK))\
+	: DUMB_FRAMEDONE_ENA_MASK)
 
+#define display_done_imasks	(display_done_imask(0) | display_done_imask(1))
+
+#define vf0_imask(id)	((id) ? (((id) & 1) ? TV_DMA_FRAME_IRQ0_ENA_MASK \
+		: PN2_DMA_FRAME_IRQ0_ENA_MASK) : DMA_FRAME_IRQ0_ENA_MASK)
+#define vf1_imask(id)	((id) ? (((id) & 1) ? TV_DMA_FRAME_IRQ1_ENA_MASK \
+		: PN2_DMA_FRAME_IRQ1_ENA_MASK) : DMA_FRAME_IRQ1_ENA_MASK)
+
+#define gfx_imasks	(gf0_imask(0) | gf1_imask(0) | gf0_imask(1) | \
+		gf1_imask(1))
+#define vid_imasks	(vf0_imask(0) | vf1_imask(0) | vf0_imask(1) | \
+		vf1_imask(1))
+#define vid_imask(id)	(display_done_imask(id))
+
+#define pn1_imasks	(gf0_imask(0) | gf1_imask(0) | vsync_imask(0) | \
+		display_done_imask(0) | vf0_imask(0) | vf1_imask(0))
+#define tv_imasks	(gf0_imask(1) | gf1_imask(1) | vsync_imask(1) | \
+		display_done_imask(1) | vf0_imask(1) | vf1_imask(1))
+#define path_imasks(id)	((id) ? (tv_imasks) : (pn1_imasks))
+
+/* error indications */
+#define vid_udflow_imask(id)	((id) ? (((id) & 1) ? \
+	(TV_DMA_FF_UNDERFLOW_ENA_MASK) : (PN2_DMA_FF_UNDERFLOW_ENA_MASK)) : \
+	(DMA_FF_UNDERFLOW_ENA_MASK))
+#define gfx_udflow_imask(id)	((id) ? (((id) & 1) ? \
+	(TV_GRA_FF_UNDERFLOW_ENA_MASK) : (PN2_GRA_FF_UNDERFLOW_ENA_MASK)) : \
+	(GRA_FF_UNDERFLOW_ENA_MASK))
+
+#define err_imask(id) (vid_udflow_imask(id) | gfx_udflow_imask(id) | \
+	AXI_BUS_ERROR_IRQ_ENA_MASK | AXI_LATENCY_TOO_LONG_IRQ_ENA_MASK)
+#define err_imasks (err_imask(0) | err_imask(1) | err_imask(2))
 /* LCD Interrupt Status Register */
-#define SPU_IRQ_ISR				0x01C4
-#define     DMA_FRAME_IRQ0(irq)			((irq) << 31)
-#define     DMA_FRAME_IRQ0_MASK			0x80000000
-#define     DMA_FRAME_IRQ1(irq)			((irq) << 30)
-#define     DMA_FRAME_IRQ1_MASK			0x40000000
-#define     DMA_FF_UNDERFLOW(ff)		((ff) << 29)
-#define     DMA_FF_UNDERFLOW_MASK		0x20000000
-#define     GRA_FRAME_IRQ0(irq)			((irq) << 27)
-#define     GRA_FRAME_IRQ0_MASK			0x08000000
-#define     GRA_FRAME_IRQ1(irq)			((irq) << 26)
-#define     GRA_FRAME_IRQ1_MASK			0x04000000
-#define     GRA_FF_UNDERFLOW(ff)		((ff) << 25)
-#define     GRA_FF_UNDERFLOW_MASK		0x02000000
-#define     VSYNC_IRQ(vsync_irq)		((vsync_irq) << 23)
-#define     VSYNC_IRQ_MASK			0x00800000
-#define     DUMB_FRAMEDONE(fdone)		((fdone) << 22)
-#define     DUMB_FRAMEDONE_MASK			0x00400000
-#define     TWC_FRAMEDONE(fdone)		((fdone) << 21)
-#define     TWC_FRAMEDONE_MASK			0x00200000
-#define     HWC_FRAMEDONE(fdone)		((fdone) << 20)
-#define     HWC_FRAMEDONE_MASK			0x00100000
-#define     SLV_IRQ(irq)			((irq) << 19)
-#define     SLV_IRQ_MASK			0x00080000
-#define     SPI_IRQ(irq)			((irq) << 18)
-#define     SPI_IRQ_MASK			0x00040000
-#define     PWRDN_IRQ(irq)			((irq) << 17)
-#define     PWRDN_IRQ_MASK			0x00020000
-#define     ERR_IRQ(irq)			((irq) << 16)
-#define     ERR_IRQ_MASK			0x00010000
+#define SPU_IRQ_ISR			0x01C4
+#define	 DMA_FRAME_IRQ0(irq)		((irq)<<31)
+#define	 DMA_FRAME_IRQ0_MASK		0x80000000
+#define	 DMA_FRAME_IRQ1(irq)		((irq)<<30)
+#define	 DMA_FRAME_IRQ1_MASK		0x40000000
+#define	 DMA_FF_UNDERFLOW(ff)		((ff)<<29)
+#define	 DMA_FF_UNDERFLOW_MASK		0x20000000
+#define	 AXI_BUS_ERROR_IRQ(irq)		((irq)<<28)
+#define	 AXI_BUS_ERROR_IRQ_MASK		0x10000000
+#define	 GRA_FRAME_IRQ0(irq)		((irq)<<27)
+#define	 GRA_FRAME_IRQ0_MASK		0x08000000
+#define	 GRA_FRAME_IRQ1(irq)		((irq)<<26)
+#define	 GRA_FRAME_IRQ1_MASK		0x04000000
+#define	 GRA_FF_UNDERFLOW(ff)		((ff)<<25)
+#define	 GRA_FF_UNDERFLOW_MASK		0x02000000
+#define	 VSYNC_IRQ(vsync_irq)		((vsync_irq)<<23)
+#define	 VSYNC_IRQ_MASK			0x00800000
+#define	 DUMB_FRAMEDONE(fdone)		((fdone)<<22)
+#define	 DUMB_FRAMEDONE_MASK		0x00400000
+#define	 TWC_FRAMEDONE(fdone)		((fdone)<<21)
+#define	 TWC_FRAMEDONE_MASK		0x00200000
+#define	 HWC_FRAMEDONE(fdone)		((fdone)<<20)
+#define	 HWC_FRAMEDONE_MASK		0x00100000
+#define	 SLV_IRQ(irq)			((irq)<<19)
+#define	 SLV_IRQ_MASK			0x00080000
+#define	 SPI_IRQ(irq)			((irq)<<18)
+#define	 SPI_IRQ_MASK			0x00040000
+#define	 PWRDN_IRQ(irq)			((irq)<<17)
+#define	 PWRDN_IRQ_MASK			0x00020000
+#define	 AXI_LATENCY_TOO_LONGR_IRQ(irq)	((irq)<<16)
+#define	 AXI_LATENCY_TOO_LONGR_IRQ_MASK	0x00010000
+#define	 TV_DMA_FRAME_IRQ0(irq)		((irq)<<15)
+#define	 TV_DMA_FRAME_IRQ0_MASK		0x00008000
+#define	 TV_DMA_FRAME_IRQ1(irq)		((irq)<<14)
+#define	 TV_DMA_FRAME_IRQ1_MASK		0x00004000
+#define	 TV_DMA_FF_UNDERFLOW(unerrun)	((unerrun)<<13)
+#define	 TV_DMA_FF_UNDERFLOW_MASK	0x00002000
+#define	 TVSYNC_IRQ(irq)		((irq)<<12)
+#define	 TVSYNC_IRQ_MASK		0x00001000
+#define	 TV_FRAME_IRQ0(irq)		((irq)<<11)
+#define	 TV_FRAME_IRQ0_MASK		0x00000800
+#define	 TV_FRAME_IRQ1(irq)		((irq)<<10)
+#define	 TV_FRAME_IRQ1_MASK		0x00000400
+#define	 TV_GRA_FF_UNDERFLOW(unerrun)	((unerrun)<<9)
+#define	 TV_GRA_FF_UNDERFLOW_MASK	0x00000200
+#define	 PN2_DMA_FRAME_IRQ0(irq)	((irq)<<7)
+#define	 PN2_DMA_FRAME_IRQ0_MASK	0x00000080
+#define	 PN2_DMA_FRAME_IRQ1(irq)	((irq)<<6)
+#define	 PN2_DMA_FRAME_IRQ1_MASK	0x00000040
+#define	 PN2_DMA_FF_UNDERFLOW(ff)	((ff)<<5)
+#define	 PN2_DMA_FF_UNDERFLOW_MASK	0x00000020
+#define	 PN2_GRA_FRAME_IRQ0(irq)	((irq)<<3)
+#define	 PN2_GRA_FRAME_IRQ0_MASK	0x00000008
+#define	 PN2_GRA_FRAME_IRQ1(irq)	((irq)<<2)
+#define	 PN2_GRA_FRAME_IRQ1_MASK	0x04000004
+#define	 PN2_GRA_FF_UNDERFLOW(ff)	((ff)<<1)
+#define	 PN2_GRA_FF_UNDERFLOW_MASK	0x00000002
+#define	 PN2_VSYNC_IRQ(irq)		((irq)<<0)
+#define	 PN2_SYNC_IRQ_MASK		0x00000001
+
+/* LCD FIFO Depth register */
+#define LCD_FIFO_DEPTH			0x01c8
+#define	 VIDEO_FIFO(fi)			((fi) << 0)
+#define	 VIDEO_FIFO_MASK		0x00000003
+#define	 GRAPHIC_FIFO(fi)		((fi) << 2)
+#define	 GRAPHIC_FIFO_MASK		0x0000000c
+
 /* read-only */
-#define     DMA_FRAME_IRQ0_LEVEL_MASK		0x00008000
-#define     DMA_FRAME_IRQ1_LEVEL_MASK		0x00004000
-#define     DMA_FRAME_CNT_ISR_MASK		0x00003000
-#define     GRA_FRAME_IRQ0_LEVEL_MASK		0x00000800
-#define     GRA_FRAME_IRQ1_LEVEL_MASK		0x00000400
-#define     GRA_FRAME_CNT_ISR_MASK		0x00000300
-#define     VSYNC_IRQ_LEVEL_MASK		0x00000080
-#define     DUMB_FRAMEDONE_LEVEL_MASK		0x00000040
-#define     TWC_FRAMEDONE_LEVEL_MASK		0x00000020
-#define     HWC_FRAMEDONE_LEVEL_MASK		0x00000010
-#define     SLV_FF_EMPTY_MASK			0x00000008
-#define     DMA_FF_ALLEMPTY_MASK		0x00000004
-#define     GRA_FF_ALLEMPTY_MASK		0x00000002
-#define     PWRDN_IRQ_LEVEL_MASK		0x00000001
+#define	 DMA_FRAME_IRQ0_LEVEL_MASK		0x00008000
+#define	 DMA_FRAME_IRQ1_LEVEL_MASK		0x00004000
+#define	 DMA_FRAME_CNT_ISR_MASK			0x00003000
+#define	 GRA_FRAME_IRQ0_LEVEL_MASK		0x00000800
+#define	 GRA_FRAME_IRQ1_LEVEL_MASK		0x00000400
+#define	 GRA_FRAME_CNT_ISR_MASK			0x00000300
+#define	 VSYNC_IRQ_LEVEL_MASK			0x00000080
+#define	 DUMB_FRAMEDONE_LEVEL_MASK		0x00000040
+#define	 TWC_FRAMEDONE_LEVEL_MASK		0x00000020
+#define	 HWC_FRAMEDONE_LEVEL_MASK		0x00000010
+#define	 SLV_FF_EMPTY_MASK			0x00000008
+#define	 DMA_FF_ALLEMPTY_MASK			0x00000004
+#define	 GRA_FF_ALLEMPTY_MASK			0x00000002
+#define	 PWRDN_IRQ_LEVEL_MASK			0x00000001
+
+/* 32 bit LCD Interrupt Reset Status*/
+#define SPU_IRQ_RSR				(0x01C8)
+/* 32 bit Panel Path Graphic Partial Display Horizontal Control Register*/
+#define LCD_GRA_CUTHPXL				(0x01CC)
+/* 32 bit Panel Path Graphic Partial Display Vertical Control Register*/
+#define LCD_GRA_CUTVLN				(0x01D0)
+/* 32 bit TV Path Graphic Partial Display	  Horizontal Control Register*/
+#define LCD_TVG_CUTHPXL				(0x01D4)
+/* 32 bit TV Path Graphic Partial Display Vertical Control Register*/
+#define LCD_TVG_CUTVLN				(0x01D8)
+/* 32 bit LCD Global Control Register*/
+#define LCD_TOP_CTRL				(0x01DC)
+/* 32 bit LCD SQU Line Buffer Control Register 1*/
+#define LCD_SQULN1_CTRL				(0x01E0)
+/* 32 bit LCD SQU Line Buffer Control Register 2*/
+#define LCD_SQULN2_CTRL				(0x01E4)
+#define squln_ctrl(id)	((id) ? (((id) & 1) ? LCD_SQULN2_CTRL : \
+			LCD_PN2_SQULN1_CTRL) : LCD_SQULN1_CTRL)
+
+/* 32 bit LCD Mixed Overlay Control Register */
+#define LCD_AFA_ALL2ONE				(0x01E8)
+
+#define LCD_PN2_SCLK_DIV			(0x01EC)
+#define LCD_PN2_TCLK_DIV			(0x01F0)
+#define LCD_LVDS_SCLK_DIV_WR			(0x01F4)
+#define LCD_YUV420SP_FMT_CTRL			(0x01F4)
+#define LCD_LVDS_SCLK_DIV_RD			(0x01FC)
+#define PN2_LCD_DMA_START_ADDR_Y0		(0x0200)
+#define PN2_LCD_DMA_START_ADDR_U0		(0x0204)
+#define PN2_LCD_DMA_START_ADDR_V0		(0x0208)
+#define PN2_LCD_DMA_START_ADDR_C0		(0x020C)
+#define PN2_LCD_DMA_START_ADDR_Y1		(0x0210)
+#define PN2_LCD_DMA_START_ADDR_U1		(0x0214)
+#define PN2_LCD_DMA_START_ADDR_V1		(0x0218)
+#define PN2_LCD_DMA_START_ADDR_C1		(0x021C)
+#define PN2_LCD_DMA_PITCH_YC			(0x0220)
+#define PN2_LCD_DMA_PITCH_UV			(0x0224)
+#define PN2_LCD_DMA_OVSA_HPXL_VLN		(0x0228)
+#define PN2_LCD_DMA_HPXL_VLN			(0x022C)
+#define PN2_LCD_DMAZM_HPXL_VLN			(0x0230)
+#define PN2_LCD_GRA_START_ADDR0			(0x0234)
+#define PN2_LCD_GRA_START_ADDR1			(0x0238)
+#define PN2_LCD_GRA_PITCH			(0x023C)
+#define PN2_LCD_GRA_OVSA_HPXL_VLN		(0x0240)
+#define PN2_LCD_GRA_HPXL_VLN			(0x0244)
+#define PN2_LCD_GRAZM_HPXL_VLN			(0x0248)
+#define PN2_LCD_HWC_OVSA_HPXL_VLN		(0x024C)
+#define PN2_LCD_HWC_HPXL_VLN			(0x0250)
+#define LCD_PN2_V_H_TOTAL			(0x0254)
+#define LCD_PN2_V_H_ACTIVE			(0x0258)
+#define LCD_PN2_H_PORCH				(0x025C)
+#define LCD_PN2_V_PORCH				(0x0260)
+#define LCD_PN2_BLANKCOLOR			(0x0264)
+#define LCD_PN2_ALPHA_COLOR1			(0x0268)
+#define LCD_PN2_ALPHA_COLOR2			(0x026C)
+#define LCD_PN2_COLORKEY_Y			(0x0270)
+#define LCD_PN2_COLORKEY_U			(0x0274)
+#define LCD_PN2_COLORKEY_V			(0x0278)
+#define LCD_PN2_SEPXLCNT			(0x027C)
+#define LCD_TV_V_H_TOTAL_FLD			(0x0280)
+#define LCD_TV_V_PORCH_FLD			(0x0284)
+#define LCD_TV_SEPXLCNT_FLD			(0x0288)
+
+#define LCD_2ND_ALPHA				(0x0294)
+#define LCD_PN2_CONTRAST			(0x0298)
+#define LCD_PN2_SATURATION			(0x029c)
+#define LCD_PN2_CBSH_HUE			(0x02a0)
+#define LCD_TIMING_EXT				(0x02C0)
+#define LCD_PN2_LAYER_ALPHA_SEL1		(0x02c4)
+#define LCD_PN2_CTRL0				(0x02C8)
+#define TV_LAYER_ALPHA_SEL1			(0x02cc)
+#define LCD_SMPN2_CTRL				(0x02D0)
+#define LCD_IO_OVERL_MAP_CTRL			(0x02D4)
+#define LCD_DUMB2_CTRL				(0x02d8)
+#define LCD_PN2_CTRL1				(0x02DC)
+#define PN2_IOPAD_CONTROL			(0x02E0)
+#define LCD_PN2_SQULN1_CTRL			(0x02E4)
+#define PN2_LCD_GRA_CUTHPXL			(0x02e8)
+#define PN2_LCD_GRA_CUTVLN			(0x02ec)
+#define LCD_PN2_SQULN2_CTRL			(0x02F0)
+#define ALL_LAYER_ALPHA_SEL			(0x02F4)
+
+/* pxa988 has different MASTER_CTRL from MMP3/MMP2 */
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define TIMING_MASTER_CONTROL			(0x01F4)
+#define MASTER_ENH(id)				(1 << ((id) + 4))
+#define MASTER_ENV(id)				(1 << ((id) + 6))
+#else
+#define TIMING_MASTER_CONTROL			(0x02F8)
+#define MASTER_ENH(id)				(1 << (id))
+#define MASTER_ENV(id)				(1 << ((id) + 4))
+#endif
+
+#define DSI_START_SEL_SHIFT(id)		(((id) << 1) + 8)
+#define timing_master_config(path, dsi_id, lcd_id) \
+	(MASTER_ENH(path) | MASTER_ENV(path) | \
+	(((lcd_id) + ((dsi_id) << 1)) << DSI_START_SEL_SHIFT(path)))
 
+#define LCD_2ND_BLD_CTL				(0x02Fc)
+#define LVDS_SRC_MASK				(3 << 30)
+#define LVDS_SRC_SHIFT				(30)
+#define LVDS_FMT_MASK				(1 << 28)
+#define LVDS_FMT_SHIFT				(28)
+
+#define clk_sclk	(1 << 0)
+#define clk_tclk	(1 << 1)
+#define clk_lvds_rd	(1 << 2)
+#define clk_lvds_wr	(1 << 3)
+
+#define gra_partdisp_ctrl_hor(id)	((id) ? (((id) & 1) ? \
+	LCD_TVG_CUTHPXL : PN2_LCD_GRA_CUTHPXL) : LCD_GRA_CUTHPXL)
+#define gra_partdisp_ctrl_ver(id)	((id) ? (((id) & 1) ? \
+	LCD_TVG_CUTVLN : PN2_LCD_GRA_CUTVLN) : LCD_GRA_CUTVLN)
 
 /*
  * defined Video Memory Color format for DMA control 0 register
@@ -511,6 +985,7 @@
 #define GMODE_PALETTE4BIT	0x9
 #define GMODE_PALETTE8BIT	0xa
 #define GMODE_RESERVED		0xb
+#define GMODE_YUV420SPLANAR	0xc
 
 /*
  * define for DMA control 1 register
@@ -555,4 +1030,901 @@
 #define IOPAD_SMART16SPI	0x7
 #define IOPAD_SMART8BOTH	0x8
 
-#endif /* __PXA168FB_H__ */
+/*
+ * defined Dumb Panel Clock Divider register
+ * SCLK_Source bit[31]
+ */
+ /* 0: PLL clock select*/
+#define AXI_BUS_SEL			0x80000000
+#define CCD_CLK_SEL			0x40000000
+#define DCON_CLK_SEL			0x20000000
+#define ENA_CLK_INT_DIV			CONFIG_FB_DOVE_CLCD_SCLK_DIV
+#define IDLE_CLK_INT_DIV		0x1	  /* idle Integer Divider */
+#define DIS_CLK_INT_DIV			0x0	  /* Disable Integer Divider */
+
+/* SRAM ID */
+#define SRAMID_gamma_yr			0x0
+#define SRAMID_gamma_ug			0x1
+#define SRAMID_gamma_vb			0x2
+#define SRAMID_palette			0x3
+#define SRAMID_hwc			0xf
+
+/* SRAM INIT Read/Write */
+#define SRAMID_INIT_READ		0x0
+#define SRAMID_INIT_WRITE		0x2
+#define SRAMID_INIT_DEFAULT		0x3
+
+/*
+ * defined VSYNC selection mode for DMA control 1 register
+ * DMA1 bit[30:28]
+ */
+#define VMODE_SMPN			0x0
+#define VMODE_SMPNIRQ			0x1
+#define VMODE_DUMB			0x2
+#define VMODE_IPE			0x3
+#define VMODE_IRE			0x4
+
+/*
+ * defined Configure Alpha and Alpha mode for DMA control 1 register
+ * DMA1 bit[15:08](alpha) / bit[17:16](alpha mode)
+ */
+/* ALPHA mode */
+#define MODE_ALPHA_DMA			0x0
+#define MODE_ALPHA_GRA			0x1
+#define MODE_ALPHA_CFG			0x2
+
+/* alpha value */
+#define ALPHA_NOGRAPHIC			0xFF	  /* all video, no graphic */
+#define ALPHA_NOVIDEO			0x00	  /* all graphic, no video */
+#define ALPHA_GRAPHnVIDEO		0x0F	  /* Selects graphic & video */
+
+/*
+ * defined Pixel Command for DMA control 1 register
+ * DMA1 bit[07:00]
+ */
+#define PIXEL_CMD			0x81
+
+/* DSI */
+/* DSI1 - 4 Lane Controller base */
+#define DSI1_REGS_PHYSICAL_BASE		0xD420B800
+/* DSI2 - 3 Lane Controller base */
+#define DSI2_REGS_PHYSICAL_BASE		0xD420BA00
+
+/*	   DSI Controller Registers	   */
+struct dsi_lcd_regs {
+#define DSI_LCD1_CTRL_0  0x100   /* DSI Active Panel 1 Control register 0 */
+#define DSI_LCD1_CTRL_1  0x104   /* DSI Active Panel 1 Control register 1 */
+	u32 ctrl0;
+	u32 ctrl1;
+	u32 reserved1[2];
+
+#define DSI_LCD1_TIMING_0		0x110   /* Timing register 0 */
+#define DSI_LCD1_TIMING_1		0x114   /* Timing register 1 */
+#define DSI_LCD1_TIMING_2		0x118   /* Timing register 2 */
+#define DSI_LCD1_TIMING_3		0x11C   /* Timing register 3 */
+#define DSI_LCD1_WC_0			0x120   /* Word Count register 0 */
+#define DSI_LCD1_WC_1			0x124   /* Word Count register 1 */
+#define DSI_LCD1_WC_2			0x128	 /* Word Count register 2 */
+	u32 timing0;
+	u32 timing1;
+	u32 timing2;
+	u32 timing3;
+	u32 wc0;
+	u32 wc1;
+	u32 wc2;
+	u32 reserved2[1];
+	u32 slot_cnt0;
+	u32 slot_cnt1;
+	u32 reserved3[2];
+	u32 status_0;
+	u32 status_1;
+	u32 status_2;
+	u32 status_3;
+	u32 status_4;
+};
+
+struct dsi_regs {
+#define DSI_CTRL_0	  0x000   /* DSI control register 0 */
+#define DSI_CTRL_1	  0x004   /* DSI control register 1 */
+	u32 ctrl0;
+	u32 ctrl1;
+	u32 reserved1[2];
+	u32 irq_status;
+	u32 irq_mask;
+	u32 reserved2[2];
+
+#define DSI_CPU_CMD_0   0x020   /* DSI CPU packet command register 0 */
+#define DSI_CPU_CMD_1   0x024   /* DSU CPU Packet Command Register 1 */
+#define DSI_CPU_CMD_3	0x02C   /* DSU CPU Packet Command Register 3 */
+#define DSI_CPU_WDAT_0	0x030   /* DSI CUP */
+	u32 cmd0;
+	u32 cmd1;
+	u32 cmd2;
+	u32 cmd3;
+	u32 dat0;
+	u32 status0;
+	u32 status1;
+	u32 status2;
+	u32 status3;
+	u32 status4;
+	u32 reserved3[2];
+
+	u32 smt_cmd;
+	u32 smt_ctrl0;
+	u32 smt_ctrl1;
+	u32 reserved4[1];
+
+	u32 rx0_status;
+
+/* Rx Packet Header - data from slave device */
+#define DSI_RX_PKT_HDR_0 0x064
+	u32 rx0_header;
+	u32 rx1_status;
+	u32 rx1_header;
+	u32 rx_ctrl;
+	u32 rx_ctrl1;
+	u32 rx2_status;
+	u32 rx2_header;
+	u32 reserved5[1];
+
+	u32 phy_ctrl1;
+#define DSI_PHY_CTRL_2		0x088   /* DSI DPHI Control Register 2 */
+#define DSI_PHY_CTRL_3		0x08C   /* DPHY Control Register 3 */
+	u32 phy_ctrl2;
+	u32 phy_ctrl3;
+	u32 phy_status0;
+	u32 phy_status1;
+	u32 reserved6[5];
+	u32 phy_status2;
+
+#define DSI_PHY_RCOMP_0		0x0B0   /* DPHY Rcomp Control Register */
+	u32 phy_rcomp0;
+	u32 reserved7[3];
+#define DSI_PHY_TIME_0		0x0C0   /* DPHY Timing Control Register 0 */
+#define DSI_PHY_TIME_1		0x0C4   /* DPHY Timing Control Register 1 */
+#define DSI_PHY_TIME_2		0x0C8   /* DPHY Timing Control Register 2 */
+#define DSI_PHY_TIME_3		0x0CC   /* DPHY Timing Control Register 3 */
+#define DSI_PHY_TIME_4		0x0D0   /* DPHY Timing Control Register 4 */
+#define DSI_PHY_TIME_5		0x0D4   /* DPHY Timing Control Register 5 */
+	u32 phy_timing0;
+	u32 phy_timing1;
+	u32 phy_timing2;
+	u32 phy_timing3;
+	u32 phy_code_0;
+	u32 phy_code_1;
+	u32 reserved8[2];
+	u32 mem_ctrl;
+	u32 tx_timer;
+	u32 rx_timer;
+	u32 turn_timer;
+	u32 reserved9[4];
+
+#define DSI_LCD1_CTRL_0  0x100   /* DSI Active Panel 1 Control register 0 */
+#define DSI_LCD1_CTRL_1  0x104   /* DSI Active Panel 1 Control register 1 */
+#define DSI_LCD1_TIMING_0		0x110   /* Timing register 0 */
+#define DSI_LCD1_TIMING_1		0x114   /* Timing register 1 */
+#define DSI_LCD1_TIMING_2		0x118   /* Timing register 2 */
+#define DSI_LCD1_TIMING_3		0x11C   /* Timing register 3 */
+#define DSI_LCD1_WC_0			0x120   /* Word Count register 0 */
+#define DSI_LCD1_WC_1			0x124   /* Word Count register 1 */
+#define DSI_LCD1_WC_2			0x128   /* Word Count register 2 */
+	struct dsi_lcd_regs lcd1;
+	u32 reserved10[11];
+	struct dsi_lcd_regs lcd2;
+};
+
+#define DSI_LCD2_CTRL_0  0x180   /* DSI Active Panel 2 Control register 0 */
+#define DSI_LCD2_CTRL_1  0x184   /* DSI Active Panel 2 Control register 1 */
+#define DSI_LCD2_TIMING_0		0x190   /* Timing register 0 */
+#define DSI_LCD2_TIMING_1		0x194   /* Timing register 1 */
+#define DSI_LCD2_TIMING_2		0x198   /* Timing register 2 */
+#define DSI_LCD2_TIMING_3		0x19C   /* Timing register 3 */
+#define DSI_LCD2_WC_0			0x1A0   /* Word Count register 0 */
+#define DSI_LCD2_WC_1			0x1A4   /* Word Count register 1 */
+#define DSI_LCD2_WC_2			0x1A8	 /* Word Count register 2 */
+
+/*	DSI_CTRL_0		0x0000	DSI Control Register 0 */
+#define DSI_CTRL_0_CFG_SOFT_RST			(1<<31)
+#define DSI_CTRL_0_CFG_SOFT_RST_REG		(1<<30)
+#define DSI_CTRL_0_CFG_LCD1_TX_EN		(1<<8)
+#define DSI_CTRL_0_CFG_LCD1_SLV			(1<<4)
+#define DSI_CTRL_0_CFG_LCD1_EN			(1<<0)
+
+/*	DSI_CTRL_1		0x0004	DSI Control Register 1 */
+#define DSI_CTRL_1_CFG_EOTP			(1<<8)
+#define DSI_CTRL_1_CFG_RSVD			(2<<4)
+#define DSI_CTRL_1_CFG_LCD2_VCH_NO_MASK		(3<<2)
+#define DSI_CTRL_1_CFG_LCD2_VCH_NO_SHIFT	2
+#define DSI_CTRL_1_CFG_LCD1_VCH_NO_MASK		(3<<0)
+#define DSI_CTRL_1_CFG_LCD1_VCH_NO_SHIFT	0
+
+/*	DSI_IRQ_ST		0x0010	DSI Interrupt Status Register */
+#define IRQ_TA_TIMEOUT				(1<<29)
+#define IRQ_RX_TIMEOUT				(1<<28)
+#define IRQ_TX_TIMEOUT				(1<<27)
+#define IRQ_RX_STATE_ERR			(1<<26)
+#define IRQ_RX_ERR				(1<<25)
+#define IRQ_RX_FIFO_FULL_ERR			(1<<24)
+#define IRQ_PHY_FIFO_UNDERRUN			(1<<23)
+#define IRQ_REQ_CNT_ERR				(1<<22)
+#define IRQ_DPHY_ERR_SYNC_ESC			(1<<10)
+#define IRQ_DPHY_ERR_ESC			(1<<9)
+#define IRQ_DPHY_RX_LINE_ERR			(1<<8)
+#define IRQ_RX_TRG3				(1<<7)
+#define IRQ_RX_TRG2				(1<<6)
+#define IRQ_RX_TRG1				(1<<5)
+#define IRQ_RX_TRG0				(1<<4)
+#define IRQ_RX_PKT				(1<<2)
+#define IRQ_CPU_TX_DONE				(1<<0)
+
+/*	DSI_LCD1_CTRL_1	0x0104	DSI Active Panel 1 Control Register 1 */
+/* LCD 1 Vsync Reset Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_VSYNC_RST_EN	(1<<31)
+/* LCD 1 2K Pixel Buffer Mode Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_M2K_EN		(1<<30)
+/*		Bit(s) DSI_LCD1_CTRL_1_RSRV_29_23 reserved */
+/* Long Blanking Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HLP_PKT_EN	(1<<22)
+/* Extra Long Blanking Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HEX_PKT_EN	(1<<21)
+/* Front Porch Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HFP_PKT_EN	(1<<20)
+/* hact Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HACT_PKT_EN	(1<<19)
+/* Back Porch Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HBP_PKT_EN	(1<<18)
+/* hse Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HSE_PKT_EN	(1<<17)
+/* hsa Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HSA_PKT_EN	(1<<16)
+/* All Item Enable after Pixel Data */
+#define	DSI_LCD1_CTRL_1_CFG_L1_ALL_SLOT_EN	(1<<15)
+/* Extra Long Packet Enable after Pixel Data */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HEX_SLOT_EN	(1<<14)
+/*		Bit(s) DSI_LCD1_CTRL_1_RSRV_13_11 reserved */
+/* Turn Around Bus at Last h Line */
+#define	DSI_LCD1_CTRL_1_CFG_L1_LAST_LINE_TURN	(1<<10)
+/* Go to Low Power Every Frame */
+#define	DSI_LCD1_CTRL_1_CFG_L1_LPM_FRAME_EN	(1<<9)
+/* Go to Low Power Every Line */
+#define	DSI_LCD1_CTRL_1_CFG_L1_LPM_LINE_EN	(1<<8)
+/*		Bit(s) DSI_LCD1_CTRL_1_RSRV_7_4 reserved */
+/* DSI Transmission Mode for LCD 1 */
+#define DSI_LCD1_CTRL_1_CFG_L1_BURST_MODE_SHIFT	2
+#define DSI_LCD1_CTRL_1_CFG_L1_BURST_MODE_MASK	(3<<2)
+/* LCD 1 Input Data RGB Mode for LCD 1 */
+#define DSI_LCD2_CTRL_1_CFG_L1_RGB_TYPE_SHIFT	0
+#define DSI_LCD2_CTRL_1_CFG_L1_RGB_TYPE_MASK	(3<<2)
+
+/*	DSI_PHY_CTRL_2		0x0088	DPHY Control Register 2 */
+/*		Bit(s) DSI_PHY_CTRL_2_RSRV_31_12 reserved */
+/* DPHY LP Receiver Enable */
+#define	DSI_PHY_CTRL_2_CFG_CSR_LANE_RESC_EN_MASK	(0xf<<8)
+#define	DSI_PHY_CTRL_2_CFG_CSR_LANE_RESC_EN_SHIFT	8
+/* DPHY Data Lane Enable */
+#define	DSI_PHY_CTRL_2_CFG_CSR_LANE_EN_MASK		(0xf<<4)
+#define	DSI_PHY_CTRL_2_CFG_CSR_LANE_EN_SHIFT		4
+/* DPHY Bus Turn Around */
+#define	DSI_PHY_CTRL_2_CFG_CSR_LANE_TURN_MASK		(0xf)
+#define	DSI_PHY_CTRL_2_CFG_CSR_LANE_TURN_SHIFT		0
+
+/*	DSI_CPU_CMD_0		0x0020	DSI CPU Packet Command Register 0 */
+#define DSI_CFG_CPU_CMD_REQ_MASK			(0x1 << 31)
+#define DSI_CFG_CPU_CMD_REQ_SHIFT			31
+#define DSI_CFG_CPU_SP_MASK				(0x1 << 30)
+#define DSI_CFG_CPU_SP_SHIFT				30
+#define DSI_CFG_CPU_TURN_MASK				(0x1 << 29)
+#define DSI_CFG_CPU_TURN_SHIFT				29
+#define DSI_CFG_CPU_TXLP_MASK				(0x1 << 27)
+#define DSI_CFG_CPU_TXLP_SHIFT				27
+#define DSI_CFG_CPU_WC_MASK				(0xff)
+#define DSI_CFG_CPU_WC_SHIFT				0
+
+/*	DSI_CPU_CMD_1		0x0024	DSI CPU Packet Command Register 1 */
+/*		Bit(s) DSI_CPU_CMD_1_RSRV_31_24 reserved */
+/* LPDT TX Enable */
+#define	DSI_CPU_CMD_1_CFG_TXLP_LPDT_MASK		(0xf<<20)
+#define	DSI_CPU_CMD_1_CFG_TXLP_LPDT_SHIFT		20
+/* ULPS TX Enable */
+#define	DSI_CPU_CMD_1_CFG_TXLP_ULPS_MASK		(0xf<<16)
+#define	DSI_CPU_CMD_1_CFG_TXLP_ULPS_SHIFT		16
+/* Low Power TX Trigger Code */
+#define	DSI_CPU_CMD_1_CFG_TXLP_TRIGGER_CODE_MASK	(0xffff)
+#define	DSI_CPU_CMD_1_CFG_TXLP_TRIGGER_CODE_SHIFT	0
+
+/*	DSI_CPU_CMD_3		0x002C	DSI CPU Packet Command Register 3 */
+#define DSI_CFG_CPU_DAT_REQ_MASK			(0x1 << 31)
+#define DSI_CFG_CPU_DAT_REQ_SHIFT			31
+#define DSI_CFG_CPU_DAT_RW_MASK				(0x1 << 30)
+#define DSI_CFG_CPU_DAT_RW_SHIFT			30
+#define DSI_CFG_CPU_DAT_ADDR_MASK			(0xff << 16)
+#define DSI_CFG_CPU_DAT_ADDR_SHIFT			16
+
+/*	DSI_RX_PKT_ST_0		0x0060	DSI RX Packet 0 Status Register */
+#define RX_PKT0_ST_VLD					(0x1 << 31)
+#define RX_PKT0_ST_SP					(0x1 << 24)
+#define RX_PKT0_PKT_PTR_MASK				(0xf << 16)
+#define RX_PKT0_PKT_PTR_SHIFT				16
+
+/*	DSI_RX_PKT_CTRL		0x0070	DSI RX Packet Read Control Register */
+#define RX_PKT_RD_REQ					(0x1 << 31)
+#define RX_PKT_RD_PTR_MASK				(0x3f << 16)
+#define RX_PKT_RD_PTR_SHIFT				16
+#define RX_PKT_RD_DATA_MASK				(0xff)
+#define RX_PKT_RD_DATA_SHIFT				0
+
+
+/*	DSI_RX_PKT_CTRL_1	0x0074	DSI RX Packet Read Control1 Register */
+#define RX_PKT_CNT_MASK					(0xf << 8)
+#define RX_PKT_CNT_SHIFT				8
+#define RX_PKT_BCNT_MASK				(0xff)
+#define RX_PKT_BCNT_SHIFT				0
+
+
+/*	DSI_PHY_TIME_0	0x00c0	DPHY Timing Control Register 0 */
+/* Length of HS Exit Period in tx_clk_esc Cycles */
+#define	DSI_PHY_TIME_0_CFG_CSR_TIME_HS_EXIT_MASK	(0xff<<24)
+#define	DSI_PHY_TIME_0_CFG_CSR_TIME_HS_EXIT_SHIFT	24
+/* DPHY HS Trail Period Length */
+#define	DSI_PHY_TIME_0_CFG_CSR_TIME_HS_TRAIL_MASK	(0xff<<16)
+#define	DSI_PHY_TIME_0_CFG_CSR_TIME_HS_TRAIL_SHIFT	16
+/* DPHY HS Zero State Length */
+#define	DSI_PHY_TIME_0_CDG_CSR_TIME_HS_ZERO_MASK	(0xff<<8)
+#define	DSI_PHY_TIME_0_CDG_CSR_TIME_HS_ZERO_SHIFT	8
+/* DPHY HS Prepare State Length */
+#define	DSI_PHY_TIME_0_CFG_CSR_TIME_HS_PREP_MASK	(0xff)
+#define	DSI_PHY_TIME_0_CFG_CSR_TIME_HS_PREP_SHIFT	0
+
+/*	DSI_PHY_TIME_1		0x00c4	DPHY Timing Control Register 1 */
+/* Time to Drive LP-00 by New Transmitter */
+#define	DSI_PHY_TIME_1_CFG_CSR_TIME_TA_GET_MASK		(0xff<<24)
+#define	DSI_PHY_TIME_1_CFG_CSR_TIME_TA_GET_SHIFT	24
+/* Time to Drive LP-00 after Turn Request */
+#define	DSI_PHY_TIME_1_CFG_CSR_TIME_TA_GO_MASK		(0xff<<16)
+#define	DSI_PHY_TIME_1_CFG_CSR_TIME_TA_GO_SHIFT		16
+/* DPHY HS Wakeup Period Length */
+#define	DSI_PHY_TIME_1_CFG_CSR_TIME_WAKEUP_MASK		(0xffff)
+#define	DSI_PHY_TIME_1_CFG_CSR_TIME_WAKEUP_SHIFT	0
+
+/*	DSI_PHY_TIME_2		0x00c8	DPHY Timing Control Register 2 */
+/* DPHY CLK Exit Period Length */
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_EXIT_MASK	(0xff<<24)
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_EXIT_SHIFT	24
+/* DPHY CLK Trail Period Length */
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_TRAIL_MASK	(0xff<<16)
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_TRAIL_SHIFT	16
+/* DPHY CLK Zero State Length */
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_ZERO_MASK	(0xff<<8)
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_ZERO_SHIFT	8
+/* DPHY CLK LP Length */
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_LPX_MASK		(0xff)
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_LPX_SHIFT	0
+
+/*	DSI_PHY_TIME_3		0x00cc	DPHY Timing Control Register 3 */
+/*		Bit(s) DSI_PHY_TIME_3_RSRV_31_16 reserved */
+/* DPHY LP Length */
+#define	DSI_PHY_TIME_3_CFG_CSR_TIME_LPX_MASK		(0xff<<8)
+#define	DSI_PHY_TIME_3_CFG_CSR_TIME_LPX_SHIFT		8
+/* DPHY HS req to rdy Length */
+#define	DSI_PHY_TIME_3_CFG_CSR_TIME_REQRDY_MASK		(0xff)
+#define	DSI_PHY_TIME_3_CFG_CSR_TIME_REQRDY_SHIFT	0
+
+/*
+ * DSI timings
+ * PXA988 has diffrent ESC CLK with MMP2/MMP3
+ * it will be used in dsi_set_dphy() in pxa688_phy.c
+ * as low power mode clock.
+ */
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define DSI_ESC_CLK				52  /* Unit: Mhz */
+#define DSI_ESC_CLK_T				19  /* Unit: ns */
+#else
+#define DSI_ESC_CLK				66  /* Unit: Mhz */
+#define DSI_ESC_CLK_T				15  /* Unit: ns */
+#endif
+
+/* LVDS */
+/* LVDS_PHY_CTRL */
+#define LVDS_PHY_CTL				0x2A4
+#define LVDS_PLL_LOCK				(1 << 31)
+#define LVDS_PHY_EXT_MASK			(7 << 28)
+#define LVDS_PHY_EXT_SHIFT			(28)
+#define LVDS_CLK_PHASE_MASK			(0x7f << 16)
+#define LVDS_CLK_PHASE_SHIFT			(16)
+#define LVDS_SSC_RESET_EXT			(1 << 13)
+#define LVDS_SSC_MODE_DOWN_SPREAD		(1 << 12)
+#define LVDS_SSC_EN				(1 << 11)
+#define LVDS_PU_PLL				(1 << 10)
+#define LVDS_PU_TX				(1 << 9)
+#define LVDS_PU_IVREF				(1 << 8)
+#define LVDS_CLK_SEL				(1 << 7)
+#define LVDS_CLK_SEL_LVDS_PCLK			(1 << 7)
+#define LVDS_PD_CH_MASK				(0x3f << 1)
+#define LVDS_PD_CH(ch)				((ch) << 1)
+#define LVDS_RST				(1 << 0)
+
+#define LVDS_PHY_CTL_EXT	0x2A8
+
+/* LVDS_PHY_CTRL_EXT1 */
+#define LVDS_SSC_RNGE_MASK			(0x7ff << 16)
+#define LVDS_SSC_RNGE_SHIFT			(16)
+#define LVDS_RESERVE_IN_MASK			(0xf << 12)
+#define LVDS_RESERVE_IN_SHIFT			(12)
+#define LVDS_TEST_MON_MASK			(0x7 << 8)
+#define LVDS_TEST_MON_SHIFT			(8)
+#define LVDS_POL_SWAP_MASK			(0x3f << 0)
+#define LVDS_POL_SWAP_SHIFT			(0)
+
+/* LVDS_PHY_CTRL_EXT2 */
+#define LVDS_TX_DIF_AMP_MASK			(0xf << 24)
+#define LVDS_TX_DIF_AMP_SHIFT			(24)
+#define LVDS_TX_DIF_CM_MASK			(0x3 << 22)
+#define LVDS_TX_DIF_CM_SHIFT			(22)
+#define LVDS_SELLV_TXCLK_MASK			(0x1f << 16)
+#define LVDS_SELLV_TXCLK_SHIFT			(16)
+#define LVDS_TX_CMFB_EN				(0x1 << 15)
+#define LVDS_TX_TERM_EN				(0x1 << 14)
+#define LVDS_SELLV_TXDATA_MASK			(0x1f << 8)
+#define LVDS_SELLV_TXDATA_SHIFT			(8)
+#define LVDS_SELLV_OP7_MASK			(0x3 << 6)
+#define LVDS_SELLV_OP7_SHIFT			(6)
+#define LVDS_SELLV_OP6_MASK			(0x3 << 4)
+#define LVDS_SELLV_OP6_SHIFT			(4)
+#define LVDS_SELLV_OP9_MASK			(0x3 << 2)
+#define LVDS_SELLV_OP9_SHIFT			(2)
+#define LVDS_STRESSTST_EN			(0x1 << 0)
+
+/* LVDS_PHY_CTRL_EXT3 */
+#define LVDS_KVCO_MASK				(0xf << 28)
+#define LVDS_KVCO_SHIFT				(28)
+#define LVDS_CTUNE_MASK				(0x3 << 26)
+#define LVDS_CTUNE_SHIFT			(26)
+#define LVDS_VREG_IVREF_MASK			(0x3 << 24)
+#define LVDS_VREG_IVREF_SHIFT			(24)
+#define LVDS_VDDL_MASK				(0xf << 20)
+#define LVDS_VDDL_SHIFT				(20)
+#define LVDS_VDDM_MASK				(0x3 << 18)
+#define LVDS_VDDM_SHIFT				(18)
+#define LVDS_FBDIV_MASK				(0xf << 8)
+#define LVDS_FBDIV_SHIFT			(8)
+#define LVDS_REFDIV_MASK			(0x7f << 0)
+#define LVDS_REFDIV_SHIFT			(0)
+
+/* LVDS_PHY_CTRL_EXT4 */
+#define LVDS_SSC_FREQ_DIV_MASK			(0xffff << 16)
+#define LVDS_SSC_FREQ_DIV_SHIFT			(16)
+#define LVDS_INTPI_MASK				(0xf << 12)
+#define LVDS_INTPI_SHIFT			(12)
+#define LVDS_VCODIV_SEL_SE_MASK			(0xf << 8)
+#define LVDS_VCODIV_SEL_SE_SHIFT		(8)
+#define LVDS_RESET_INTP_EXT			(0x1 << 7)
+#define LVDS_VCO_VRNG_MASK			(0x7 << 4)
+#define LVDS_VCO_VRNG_SHIFT			(4)
+#define LVDS_PI_EN				(0x1 << 3)
+#define LVDS_ICP_MASK				(0x7 << 0)
+#define LVDS_ICP_SHIFT				(0)
+
+/* LVDS_PHY_CTRL_EXT5 */
+#define LVDS_FREQ_OFFSET_MASK			(0x1ffff << 15)
+#define LVDS_FREQ_OFFSET_SHIFT			(15)
+#define LVDS_FREQ_OFFSET_VALID			(0x1 << 2)
+#define LVDS_FREQ_OFFSET_MODE_CK_DIV4_OUT	(0x1 << 1)
+#define LVDS_FREQ_OFFSET_MODE_EN		(0x1 << 0)
+
+/* VDMA */
+struct vdma_ch_regs {
+#define VDMA_DC_SADDR_1		0x320
+#define VDMA_DC_SADDR_2		0x3A0
+#define VDMA_DC_SZ_1		0x324
+#define VDMA_DC_SZ_2		0x3A4
+#define VDMA_CTRL_1		0x328
+#define VDMA_CTRL_2		0x3A8
+#define VDMA_SRC_SZ_1		0x32C
+#define VDMA_SRC_SZ_2		0x3AC
+#define VDMA_SA_1		0x330
+#define VDMA_SA_2		0x3B0
+#define VDMA_DA_1		0x334
+#define VDMA_DA_2		0x3B4
+#define VDMA_SZ_1		0x338
+#define VDMA_SZ_2		0x3B8
+	u32	dc_saddr;
+	u32	dc_size;
+	u32	ctrl;
+	u32	src_size;
+	u32	src_addr;
+	u32	dst_addr;
+	u32	dst_size;
+#define VDMA_PITCH_1		0x33C
+#define VDMA_PITCH_2		0x3BC
+#define VDMA_ROT_CTRL_1		0x340
+#define VDMA_ROT_CTRL_2		0x3C0
+#define VDMA_RAM_CTRL0_1	0x344
+#define VDMA_RAM_CTRL0_2	0x3C4
+#define VDMA_RAM_CTRL1_1	0x348
+#define VDMA_RAM_CTRL1_2	0x3C8
+	u32	pitch;
+	u32	rot_ctrl;
+	u32	ram_ctrl0;
+	u32	ram_ctrl1;
+
+};
+struct vdma_regs {
+#define VDMA_ARBR_CTRL		0x300
+#define VDMA_IRQR		0x304
+#define VDMA_IRQM		0x308
+#define VDMA_IRQS		0x30C
+#define VDMA_MDMA_ARBR_CTRL	0x310
+	u32	arbr_ctr;
+	u32	irq_raw;
+	u32	irq_mask;
+	u32	irq_status;
+	u32	mdma_arbr_ctrl;
+	u32	reserved[3];
+
+	struct vdma_ch_regs	ch1;
+	u32	reserved2[21];
+	struct vdma_ch_regs	ch2;
+};
+
+/* CMU */
+#define CMU_PIP_DE_H_CFG	0x0008
+#define CMU_PRI1_H_CFG		0x000C
+#define CMU_PRI2_H_CFG		0x0010
+#define CMU_ACE_MAIN_DE1_H_CFG	0x0014
+#define CMU_ACE_MAIN_DE2_H_CFG	0x0018
+#define CMU_ACE_PIP_DE1_H_CFG	0x001C
+#define CMU_ACE_PIP_DE2_H_CFG	0x0020
+#define CMU_PIP_DE_V_CFG	0x0024
+#define CMU_PRI_V_CFG		0x0028
+#define CMU_ACE_MAIN_DE_V_CFG	0x002C
+#define CMU_ACE_PIP_DE_V_CFG	0x0030
+#define CMU_BAR_0_CFG		0x0034
+#define CMU_BAR_1_CFG		0x0038
+#define CMU_BAR_2_CFG		0x003C
+#define CMU_BAR_3_CFG		0x0040
+#define CMU_BAR_4_CFG		0x0044
+#define CMU_BAR_5_CFG		0x0048
+#define CMU_BAR_6_CFG		0x004C
+#define CMU_BAR_7_CFG		0x0050
+#define CMU_BAR_8_CFG		0x0054
+#define CMU_BAR_9_CFG		0x0058
+#define CMU_BAR_10_CFG		0x005C
+#define CMU_BAR_11_CFG		0x0060
+#define CMU_BAR_12_CFG		0x0064
+#define CMU_BAR_13_CFG		0x0068
+#define CMU_BAR_14_CFG		0x006C
+#define CMU_BAR_15_CFG		0x0070
+#define CMU_BAR_CTRL		0x0074
+#define PATTERN_TOTAL		0x0078
+#define PATTERN_ACTIVE		0x007C
+#define PATTERN_FRONT_PORCH	0x0080
+#define PATTERN_BACK_PORCH	0x0084
+#define CMU_CLK_CTRL		0x0088
+
+#define CMU_ICSC_M_C0_L		0x0900
+#define CMU_ICSC_M_C0_H		0x0901
+#define CMU_ICSC_M_C1_L		0x0902
+#define CMU_ICSC_M_C1_H		0x0903
+#define CMU_ICSC_M_C2_L		0x0904
+#define CMU_ICSC_M_C2_H		0x0905
+#define CMU_ICSC_M_C3_L		0x0906
+#define CMU_ICSC_M_C3_H		0x0907
+#define CMU_ICSC_M_C4_L		0x0908
+#define CMU_ICSC_M_C4_H		0x0909
+#define CMU_ICSC_M_C5_L		0x090A
+#define CMU_ICSC_M_C5_H		0x090B
+#define CMU_ICSC_M_C6_L		0x090C
+#define CMU_ICSC_M_C6_H		0x090D
+#define CMU_ICSC_M_C7_L		0x090E
+#define CMU_ICSC_M_C7_H		0x090F
+#define CMU_ICSC_M_C8_L		0x0910
+#define CMU_ICSC_M_C8_H		0x0911
+#define CMU_ICSC_M_O1_0		0x0914
+#define CMU_ICSC_M_O1_1		0x0915
+#define CMU_ICSC_M_O1_2		0x0916
+#define CMU_ICSC_M_O2_0		0x0918
+#define CMU_ICSC_M_O2_1		0x0919
+#define CMU_ICSC_M_O2_2		0x091A
+#define CMU_ICSC_M_O3_0		0x091C
+#define CMU_ICSC_M_O3_1		0x091D
+#define CMU_ICSC_M_O3_2		0x091E
+#define CMU_ICSC_P_C0_L		0x0920
+#define CMU_ICSC_P_C0_H		0x0921
+#define CMU_ICSC_P_C1_L		0x0922
+#define CMU_ICSC_P_C1_H		0x0923
+#define CMU_ICSC_P_C2_L		0x0924
+#define CMU_ICSC_P_C2_H		0x0925
+#define CMU_ICSC_P_C3_L		0x0926
+#define CMU_ICSC_P_C3_H		0x0927
+#define CMU_ICSC_P_C4_L		0x0928
+#define CMU_ICSC_P_C4_H		0x0929
+#define CMU_ICSC_P_C5_L		0x092A
+#define CMU_ICSC_P_C5_H		0x092B
+#define CMU_ICSC_P_C6_L		0x092C
+#define CMU_ICSC_P_C6_H		0x092D
+#define CMU_ICSC_P_C7_L		0x092E
+#define CMU_ICSC_P_C7_H		0x092F
+#define CMU_ICSC_P_C8_L		0x0930
+#define CMU_ICSC_P_C8_H		0x0931
+#define CMU_ICSC_P_O1_0		0x0934
+#define CMU_ICSC_P_O1_1		0x0935
+#define CMU_ICSC_P_O1_2		0x0936
+#define CMU_ICSC_P_O2_0		0x0938
+#define CMU_ICSC_P_O2_1		0x0939
+#define CMU_ICSC_P_O2_2		0x093A
+#define CMU_ICSC_P_O3_0		0x093C
+#define CMU_ICSC_P_O3_1		0x093D
+#define CMU_ICSC_P_O3_2		0x093E
+#define CMU_BR_M_EN		0x0940
+#define CMU_BR_M_TH1_L		0x0942
+#define CMU_BR_M_TH1_H		0x0943
+#define CMU_BR_M_TH2_L		0x0944
+#define CMU_BR_M_TH2_H		0x0945
+#define CMU_ACE_M_EN		0x0950
+#define CMU_ACE_M_WFG1		0x0951
+#define CMU_ACE_M_WFG2		0x0952
+#define CMU_ACE_M_WFG3		0x0953
+#define CMU_ACE_M_TH0		0x0954
+#define CMU_ACE_M_TH1		0x0955
+#define CMU_ACE_M_TH2		0x0956
+#define CMU_ACE_M_TH3		0x0957
+#define CMU_ACE_M_TH4		0x0958
+#define CMU_ACE_M_TH5		0x0959
+#define CMU_ACE_M_OP0_L		0x095A
+#define CMU_ACE_M_OP0_H		0x095B
+#define CMU_ACE_M_OP5_L		0x095C
+#define CMU_ACE_M_OP5_H		0x095D
+#define CMU_ACE_M_GB2		0x095E
+#define CMU_ACE_M_GB3		0x095F
+#define CMU_ACE_M_MS1		0x0960
+#define CMU_ACE_M_MS2		0x0961
+#define CMU_ACE_M_MS3		0x0962
+#define CMU_BR_P_EN		0x0970
+#define CMU_BR_P_TH1_L		0x0972
+#define CMU_BR_P_TH1_H		0x0973
+#define CMU_BR_P_TH2_L		0x0974
+#define CMU_BR_P_TH2_H		0x0975
+#define CMU_ACE_P_EN		0x0980
+#define CMU_ACE_P_WFG1		0x0981
+#define CMU_ACE_P_WFG2		0x0982
+#define CMU_ACE_P_WFG3		0x0983
+#define CMU_ACE_P_TH0		0x0984
+#define CMU_ACE_P_TH1		0x0985
+#define CMU_ACE_P_TH2		0x0986
+#define CMU_ACE_P_TH3		0x0987
+#define CMU_ACE_P_TH4		0x0988
+#define CMU_ACE_P_TH5		0x0989
+#define CMU_ACE_P_OP0_L		0x098A
+#define CMU_ACE_P_OP0_H		0x098B
+#define CMU_ACE_P_OP5_L		0x098C
+#define CMU_ACE_P_OP5_H		0x098D
+#define CMU_ACE_P_GB2		0x098E
+#define CMU_ACE_P_GB3		0x098F
+#define CMU_ACE_P_MS1		0x0990
+#define CMU_ACE_P_MS2		0x0991
+#define CMU_ACE_P_MS3		0x0992
+#define CMU_FTDC_M_EN		0x09A0
+#define CMU_FTDC_P_EN		0x09A1
+#define CMU_FTDC_INLOW_L	0x09A2
+#define CMU_FTDC_INLOW_H	0x09A3
+#define CMU_FTDC_INHIGH_L	0x09A4
+#define CMU_FTDC_INHIGH_H	0x09A5
+#define CMU_FTDC_OUTLOW_L	0x09A6
+#define CMU_FTDC_OUTLOW_H	0x09A7
+#define CMU_FTDC_OUTHIGH_L	0x09A8
+#define CMU_FTDC_OUTHIGH_H	0x09A9
+#define CMU_FTDC_YLOW		0x09AA
+#define CMU_FTDC_YHIGH		0x09AB
+#define CMU_FTDC_CH1		0x09AC
+#define CMU_FTDC_CH2_L		0x09AE
+#define CMU_FTDC_CH2_H		0x09AF
+#define CMU_FTDC_CH3_L		0x09B0
+#define CMU_FTDC_CH3_H		0x09B1
+#define CMU_FTDC_1_C00_6	0x09B2
+#define CMU_FTDC_1_C01_6	0x09B8
+#define CMU_FTDC_1_C11_6	0x09BE
+#define CMU_FTDC_1_C10_6	0x09C4
+#define CMU_FTDC_1_OFF00_6	0x09CA
+#define CMU_FTDC_1_OFF10_6	0x09D0
+#define CMU_HS_M_EN		0x0A00
+#define CMU_HS_M_AX1_L		0x0A02
+#define CMU_HS_M_AX1_H		0x0A03
+#define CMU_HS_M_AX2_L		0x0A04
+#define CMU_HS_M_AX2_H		0x0A05
+#define CMU_HS_M_AX3_L		0x0A06
+#define CMU_HS_M_AX3_H		0x0A07
+#define CMU_HS_M_AX4_L		0x0A08
+#define CMU_HS_M_AX4_H		0x0A09
+#define CMU_HS_M_AX5_L		0x0A0A
+#define CMU_HS_M_AX5_H		0x0A0B
+#define CMU_HS_M_AX6_L		0x0A0C
+#define CMU_HS_M_AX6_H		0x0A0D
+#define CMU_HS_M_AX7_L		0x0A0E
+#define CMU_HS_M_AX7_H		0x0A0F
+#define CMU_HS_M_AX8_L		0x0A10
+#define CMU_HS_M_AX8_H		0x0A11
+#define CMU_HS_M_AX9_L		0x0A12
+#define CMU_HS_M_AX9_H		0x0A13
+#define CMU_HS_M_AX10_L		0x0A14
+#define CMU_HS_M_AX10_H		0x0A15
+#define CMU_HS_M_AX11_L		0x0A16
+#define CMU_HS_M_AX11_H		0x0A17
+#define CMU_HS_M_AX12_L		0x0A18
+#define CMU_HS_M_AX12_H		0x0A19
+#define CMU_HS_M_AX13_L		0x0A1A
+#define CMU_HS_M_AX13_H		0x0A1B
+#define CMU_HS_M_AX14_L		0x0A1C
+#define CMU_HS_M_AX14_H		0x0A1D
+#define CMU_HS_M_H1_H14		0x0A1E
+#define CMU_HS_M_S1_S14		0x0A2C
+#define CMU_HS_M_GL		0x0A3A
+#define CMU_HS_M_MAXSAT_RGB_Y_L	0x0A3C
+#define CMU_HS_M_MAXSAT_RGB_Y_H	0x0A3D
+#define CMU_HS_M_MAXSAT_RCR_L	0x0A3E
+#define CMU_HS_M_MAXSAT_RCR_H	0x0A3F
+#define CMU_HS_M_MAXSAT_RCB_L	0x0A40
+#define CMU_HS_M_MAXSAT_RCB_H	0x0A41
+#define CMU_HS_M_MAXSAT_GCR_L	0x0A42
+#define CMU_HS_M_MAXSAT_GCR_H	0x0A43
+#define CMU_HS_M_MAXSAT_GCB_L	0x0A44
+#define CMU_HS_M_MAXSAT_GCB_H	0x0A45
+#define CMU_HS_M_MAXSAT_BCR_L	0x0A46
+#define CMU_HS_M_MAXSAT_BCR_H	0x0A47
+#define CMU_HS_M_MAXSAT_BCB_L	0x0A48
+#define CMU_HS_M_MAXSAT_BCB_H	0x0A49
+#define CMU_HS_M_ROFF_L		0x0A4A
+#define CMU_HS_M_ROFF_H		0x0A4B
+#define CMU_HS_M_GOFF_L		0x0A4C
+#define CMU_HS_M_GOFF_H		0x0A4D
+#define CMU_HS_M_BOFF_L		0x0A4E
+#define CMU_HS_M_BOFF_H		0x0A4F
+#define CMU_HS_P_EN		0x0A50
+#define CMU_HS_P_AX1_L		0x0A52
+#define CMU_HS_P_AX1_H		0x0A53
+#define CMU_HS_P_AX2_L		0x0A54
+#define CMU_HS_P_AX2_H		0x0A55
+#define CMU_HS_P_AX3_L		0x0A56
+#define CMU_HS_P_AX3_H		0x0A57
+#define CMU_HS_P_AX4_L		0x0A58
+#define CMU_HS_P_AX4_H		0x0A59
+#define CMU_HS_P_AX5_L		0x0A5A
+#define CMU_HS_P_AX5_H		0x0A5B
+#define CMU_HS_P_AX6_L		0x0A5C
+#define CMU_HS_P_AX6_H		0x0A5D
+#define CMU_HS_P_AX7_L		0x0A5E
+#define CMU_HS_P_AX7_H		0x0A5F
+#define CMU_HS_P_AX8_L		0x0A60
+#define CMU_HS_P_AX8_H		0x0A61
+#define CMU_HS_P_AX9_L		0x0A62
+#define CMU_HS_P_AX9_H		0x0A63
+#define CMU_HS_P_AX10_L		0x0A64
+#define CMU_HS_P_AX10_H		0x0A65
+#define CMU_HS_P_AX11_L		0x0A66
+#define CMU_HS_P_AX11_H		0x0A67
+#define CMU_HS_P_AX12_L		0x0A68
+#define CMU_HS_P_AX12_H		0x0A69
+#define CMU_HS_P_AX13_L		0x0A6A
+#define CMU_HS_P_AX13_H		0x0A6B
+#define CMU_HS_P_AX14_L		0x0A6C
+#define CMU_HS_P_AX14_H		0x0A6D
+#define CMU_HS_P_H1_H14		0x0A6E
+#define CMU_HS_P_S1_S14		0x0A7C
+#define CMU_HS_P_GL		0x0A8A
+#define CMU_HS_P_MAXSAT_RGB_Y_L	0x0A8C
+#define CMU_HS_P_MAXSAT_RGB_Y_H	0x0A8D
+#define CMU_HS_P_MAXSAT_RCR_L	0x0A8E
+#define CMU_HS_P_MAXSAT_RCR_H	0x0A8F
+#define CMU_HS_P_MAXSAT_RCB_L	0x0A90
+#define CMU_HS_P_MAXSAT_RCB_H	0x0A91
+#define CMU_HS_P_MAXSAT_GCR_L	0x0A92
+#define CMU_HS_P_MAXSAT_GCR_H	0x0A93
+#define CMU_HS_P_MAXSAT_GCB_L	0x0A94
+#define CMU_HS_P_MAXSAT_GCB_H	0x0A95
+#define CMU_HS_P_MAXSAT_BCR_L	0x0A96
+#define CMU_HS_P_MAXSAT_BCR_H	0x0A97
+#define CMU_HS_P_MAXSAT_BCB_L	0x0A98
+#define CMU_HS_P_MAXSAT_BCB_H	0x0A99
+#define CMU_HS_P_ROFF_L		0x0A9A
+#define CMU_HS_P_ROFF_H		0x0A9B
+#define CMU_HS_P_GOFF_L		0x0A9C
+#define CMU_HS_P_GOFF_H		0x0A9D
+#define CMU_HS_P_BOFF_L		0x0A9E
+#define CMU_HS_P_BOFF_H		0x0A9F
+#define CMU_GLCSC_M_C0_L	0x0AA0
+#define CMU_GLCSC_M_C0_H	0x0AA1
+#define CMU_GLCSC_M_C1_L	0x0AA2
+#define CMU_GLCSC_M_C1_H	0x0AA3
+#define CMU_GLCSC_M_C2_L	0x0AA4
+#define CMU_GLCSC_M_C2_H	0x0AA5
+#define CMU_GLCSC_M_C3_L	0x0AA6
+#define CMU_GLCSC_M_C3_H	0x0AA7
+#define CMU_GLCSC_M_C4_L	0x0AA8
+#define CMU_GLCSC_M_C4_H	0x0AA9
+#define CMU_GLCSC_M_C5_L	0x0AAA
+#define CMU_GLCSC_M_C5_H	0x0AAB
+#define CMU_GLCSC_M_C6_L	0x0AAC
+#define CMU_GLCSC_M_C6_H	0x0AAD
+#define CMU_GLCSC_M_C7_L	0x0AAE
+#define CMU_GLCSC_M_C7_H	0x0AAF
+#define CMU_GLCSC_M_C8_L	0x0AB0
+#define CMU_GLCSC_M_C8_H	0x0AB1
+#define CMU_GLCSC_M_O1_1	0x0AB4
+#define CMU_GLCSC_M_O1_2	0x0AB5
+#define CMU_GLCSC_M_O1_3	0x0AB6
+#define CMU_GLCSC_M_O2_1	0x0AB8
+#define CMU_GLCSC_M_O2_2	0x0AB9
+#define CMU_GLCSC_M_O2_3	0x0ABA
+#define CMU_GLCSC_M_O3_1	0x0ABC
+#define CMU_GLCSC_M_O3_2	0x0ABD
+#define CMU_GLCSC_M_O3_3	0x0ABE
+#define CMU_GLCSC_P_C0_L	0x0AC0
+#define CMU_GLCSC_P_C0_H	0x0AC1
+#define CMU_GLCSC_P_C1_L	0x0AC2
+#define CMU_GLCSC_P_C1_H	0x0AC3
+#define CMU_GLCSC_P_C2_L	0x0AC4
+#define CMU_GLCSC_P_C2_H	0x0AC5
+#define CMU_GLCSC_P_C3_L	0x0AC6
+#define CMU_GLCSC_P_C3_H	0x0AC7
+#define CMU_GLCSC_P_C4_L	0x0AC8
+#define CMU_GLCSC_P_C4_H	0x0AC9
+#define CMU_GLCSC_P_C5_L	0x0ACA
+#define CMU_GLCSC_P_C5_H	0x0ACB
+#define CMU_GLCSC_P_C6_L	0x0ACC
+#define CMU_GLCSC_P_C6_H	0x0ACD
+#define CMU_GLCSC_P_C7_L	0x0ACE
+#define CMU_GLCSC_P_C7_H	0x0ACF
+#define CMU_GLCSC_P_C8_L	0x0AD0
+#define CMU_GLCSC_P_C8_H	0x0AD1
+#define CMU_GLCSC_P_O1_1	0x0AD4
+#define CMU_GLCSC_P_O1_2	0x0AD5
+#define CMU_GLCSC_P_O1_3	0x0AD6
+#define CMU_GLCSC_P_O2_1	0x0AD8
+#define CMU_GLCSC_P_O2_2	0x0AD9
+#define CMU_GLCSC_P_O2_3	0x0ADA
+#define CMU_GLCSC_P_O3_1	0x0ADC
+#define CMU_GLCSC_P_O3_2	0x0ADD
+#define CMU_GLCSC_P_O3_3	0x0ADE
+#define CMU_PIXVAL_M_EN		0x0AE0
+#define CMU_PIXVAL_P_EN		0x0AE1
+
+#define CMU_CLK_CTRL_TCLK	0x0
+#define CMU_CLK_CTRL_SCLK	0x2
+#define CMU_CLK_CTRL_MSK	0x2
+#define CMU_CLK_CTRL_ENABLE	0x1
+
+#define LCD_TOP_CTRL_TV		0x2
+#define LCD_TOP_CTRL_PN		0x0
+#define LCD_TOP_CTRL_SEL_MSK	0x2
+#define LCD_IO_CMU_IN_SEL_MSK	(0x3 << 20)
+#define LCD_IO_CMU_IN_SEL_TV	0
+#define LCD_IO_CMU_IN_SEL_PN	1
+#define LCD_IO_CMU_IN_SEL_PN2	2
+#define LCD_IO_TV_OUT_SEL_MSK	(0x3 << 26)
+#define LCD_IO_PN_OUT_SEL_MSK	(0x3 << 24)
+#define LCD_IO_PN2_OUT_SEL_MSK	(0x3 << 28)
+#define LCD_IO_TV_OUT_SEL_NON	3
+#define LCD_IO_PN_OUT_SEL_NON	3
+#define LCD_IO_PN2_OUT_SEL_NON	3
+#define LCD_TOP_CTRL_CMU_ENABLE 0x1
+#define LCD_IO_OVERL_MSK	0xC00000
+#define LCD_IO_OVERL_TV		0x0
+#define LCD_IO_OVERL_LCD1	0x400000
+#define LCD_IO_OVERL_LCD2	0xC00000
+#define HINVERT_MSK		0x4
+#define VINVERT_MSK		0x8
+#define HINVERT_LEN		0x2
+#define VINVERT_LEN		0x3
+
+#define CMU_CTRL		0x88
+#define CMU_CTRL_A0_MSK		0x6
+#define CMU_CTRL_A0_TV		0x0
+#define CMU_CTRL_A0_LCD1	0x1
+#define CMU_CTRL_A0_LCD2	0x2
+#define CMU_CTRL_A0_HDMI	0x3
+
+#define ICR_DRV_ROUTE_OFF	0x0
+#define ICR_DRV_ROUTE_TV	0x1
+#define ICR_DRV_ROUTE_LCD1	0x2
+#define ICR_DRV_ROUTE_LCD2	0x3
+
+#endif	/* __PXA168FB_H__ */
diff --git a/drivers/video/pxa168fb_common.c b/drivers/video/pxa168fb_common.c
new file mode 100644
index 00000000..f35ec056
--- /dev/null
+++ b/drivers/video/pxa168fb_common.c
@@ -0,0 +1,2651 @@
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <plat/clock.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <mach/features.h>
+#include <mach/regs-apmu.h>
+#include "pxa168fb_common.h"
+#include <linux/delay.h>
+#include <asm/cacheflush.h>
+#include <plat/clock.h>
+#include <linux/fb.h>
+
+/* buffer management:
+ *    filterBufList: list return to upper layer which indicates buff is free
+ *    freelist: list indicates buff is free
+ *    waitlist: wait queue which indicates "using" buffer, will be writen in
+ *              DMA register
+ *    current: buffer on showing
+ * Operation:
+ *    flip: if !waitlist[0] || !waitlist[1] enqueue to waiting list;
+ *          else enqueue the  waitlist[0] to freelist, new buf to waitlist
+ *    get freelist: return freelist
+ *    eof intr: enqueue current to freelist; dequeue waitlist[0] to current;
+ *    buffers are protected spin_lock_irq disable/enable
+ *    suspend: when lcd is suspend, move all buffers as "switched",
+ *             but don't really set hw register.
+ */
+
+static int check_yuv_status(FBVideoMode videoMode, struct pxa168fb_info *fbi)
+{
+	u32 x;
+
+	if (fbi->vid) {     /* now in video layer */
+		x = dma_ctrl_read(fbi->id, 0);
+
+		if (!((videoMode & 0xf00) >> 8)) {
+			if ((x & 0xf0000)>>16 == 0x5) {
+				/* graphic layer broadcast YUV */
+				pr_warning(" vid layer: dma_ctrl0 0x%x\n", x);
+				return -EFAULT;
+			}
+		}
+	} else {
+		x = dma_ctrl_read(fbi->id, 0);
+
+		if (!((videoMode & 0xf00) >> 8)) {
+			if ((x & 0xf00000)>>20 >= 0x5
+					&& (x & 0xf00000)>>20 <= 0x7) {
+				pr_warning(" gfx layer: dma_ctrl0 0x%x\n", x);
+				return -EFAULT; /* video layer broadcast YUV */
+			}
+		}
+	}
+
+	return 0;
+}
+
+static void ovlysurface_clear_pitch(struct _sOvlySurface *surface)
+{
+	surface->viewPortInfo.yPitch = 0;
+	surface->viewPortInfo.uPitch = 0;
+	surface->viewPortInfo.vPitch = 0;
+}
+
+static void update_surface(struct _sOvlySurface *surface)
+{
+	int tmp;
+
+	if (surface->viewPortInfo.rotation == 90 ||
+		surface->viewPortInfo.rotation == 270) {
+		surface->viewPortInfo.rotation = 360 -
+		surface->viewPortInfo.rotation;
+		tmp = surface->viewPortInfo.srcWidth;
+		surface->viewPortInfo.srcWidth =
+		surface->viewPortInfo.srcHeight;
+		surface->viewPortInfo.srcHeight = tmp;
+		switch (surface->videoMode) {
+		case FB_VMODE_YUV422PACKED:
+			surface->videoMode = FB_VMODE_YUV422PACKED_IRE_90_270;
+			surface->viewPortInfo.yuv_format = 1;
+			ovlysurface_clear_pitch(surface);
+			break;
+		case FB_VMODE_YUV422PACKED_SWAPUV:
+			surface->videoMode = FB_VMODE_YUV422PACKED_IRE_90_270;
+			surface->viewPortInfo.yuv_format = 2;
+			ovlysurface_clear_pitch(surface);
+			break;
+		case FB_VMODE_YUV422PACKED_SWAPYUorV:
+			surface->videoMode = FB_VMODE_YUV422PACKED_IRE_90_270;
+			surface->viewPortInfo.yuv_format = 4;
+			ovlysurface_clear_pitch(surface);
+			break;
+		default:
+			surface->viewPortInfo.yuv_format = 0;
+		}
+	}
+}
+
+int unsupport_format(struct pxa168fb_info *fbi, struct _sViewPortInfo
+		viewPortInfo, FBVideoMode videoMode)
+{
+	if (check_yuv_status(videoMode, fbi) < 0)
+		return 1;
+
+	if ((viewPortInfo.rotation == 0) || (viewPortInfo.rotation == 1)) {
+		if (!fbi->vid) {
+			/* In graphic layer now */
+			switch (videoMode) {
+			case FB_VMODE_YUV422PLANAR:
+			case FB_VMODE_YUV420PLANAR:
+				pr_err("Planar is not supported!\n");
+				return 1;
+			default:
+				break;
+			}
+		}
+
+		return 0;
+	}
+
+	if (viewPortInfo.srcHeight == 1080) {
+		pr_err("1080P rotation is not supported!\n");
+		return 1;
+	}
+	if (viewPortInfo.srcHeight == 720) {
+		if (viewPortInfo.rotation == 180) {
+			pr_err("720p rotation 180 is not supported!\n");
+			return 1;
+		}
+	}
+
+	switch (videoMode) {
+	case FB_VMODE_YUV422PLANAR:
+	case FB_VMODE_YUV422PLANAR_SWAPUV:
+	case FB_VMODE_YUV422PLANAR_SWAPYUorV:
+	case FB_VMODE_YUV420PLANAR:
+	case FB_VMODE_YUV420PLANAR_SWAPUV:
+	case FB_VMODE_YUV420PLANAR_SWAPYUorV:
+		pr_err("Planar is not supported!\n");
+		return 1;
+	default:
+		break;
+	}
+	return 0;
+}
+
+int convert_pix_fmt(u32 vmode)
+{
+/*	pr_info("vmode=%d\n", vmode); */
+	switch (vmode) {
+	case FB_VMODE_YUV422PACKED:
+		return PIX_FMT_YUV422PACK;
+	case FB_VMODE_YUV422PACKED_SWAPUV:
+		return PIX_FMT_YVU422PACK;
+	case FB_VMODE_YUV422PLANAR:
+		return PIX_FMT_YUV422PLANAR;
+	case FB_VMODE_YUV422PLANAR_SWAPUV:
+		return PIX_FMT_YVU422PLANAR;
+	case FB_VMODE_YUV420PLANAR:
+		return PIX_FMT_YUV420PLANAR;
+	case FB_VMODE_YUV420PLANAR_SWAPUV:
+		return PIX_FMT_YVU420PLANAR;
+	case FB_VMODE_YUV420SEMIPLANAR:
+		return PIX_FMT_YUV420SEMIPLANAR;
+	case FB_VMODE_YUV420SEMIPLANAR_SWAPUV:
+		return PIX_FMT_YVU420SEMIPLANAR;
+	case FB_VMODE_YUV422PACKED_SWAPYUorV:
+		return PIX_FMT_YUYV422PACK;
+	case FB_VMODE_YUV422PACKED_IRE_90_270:
+		return PIX_FMT_YUV422PACK_IRE_90_270;
+	case FB_VMODE_RGB565:
+		return PIX_FMT_RGB565;
+	case FB_VMODE_BGR565:
+		return PIX_FMT_BGR565;
+	case FB_VMODE_RGB1555:
+		return PIX_FMT_RGB1555;
+	case FB_VMODE_BGR1555:
+		return PIX_FMT_BGR1555;
+	case FB_VMODE_RGB888PACK:
+		return PIX_FMT_RGB888PACK;
+	case FB_VMODE_BGR888PACK:
+		return PIX_FMT_BGR888PACK;
+	case FB_VMODE_RGBA888:
+		return PIX_FMT_RGBA888;
+	case FB_VMODE_BGRA888:
+		return PIX_FMT_BGRA888;
+	case FB_VMODE_RGB888A:
+		return PIX_FMT_RGB888A;
+	case FB_VMODE_BGR888A:
+		return PIX_FMT_BGR888A;
+	case FB_VMODE_RGB888UNPACK:
+		return PIX_FMT_RGB888UNPACK;
+	case FB_VMODE_BGR888UNPACK:
+		return PIX_FMT_BGR888UNPACK;
+	case FB_VMODE_YUV422PLANAR_SWAPYUorV:
+	case FB_VMODE_YUV420PLANAR_SWAPYUorV:
+	default:
+		return -1;
+	}
+}
+
+void *pxa168fb_alloc_framebuffer(size_t size, dma_addr_t *dma)
+{
+	int nr, i = 0;
+	struct page **pages;
+	void *start;
+
+	size = PAGE_ALIGN(size);
+	nr = size >> PAGE_SHIFT;
+	start = alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);
+	if (start == NULL)
+		return NULL;
+
+	*dma = virt_to_phys(start);
+
+	memset(start, 0x0, size);
+	/* invalidate the buffer before vmap as noncacheable */
+	flush_cache_all();
+	outer_flush_range(*dma, *dma + size);
+
+	pages = vmalloc(sizeof(struct page *) * nr);
+	if (pages == NULL) {
+		free_pages_exact(start, size);
+		return NULL;
+	}
+
+	while (i < nr) {
+		pages[i] = phys_to_page(*dma + (i << PAGE_SHIFT));
+		i++;
+	}
+	start = vmap(pages, nr, 0, pgprot_writecombine(pgprot_kernel));
+
+	vfree(pages);
+	return start;
+}
+
+void pxa168fb_free_framebuffer(size_t size, void *vaddr, dma_addr_t *dma)
+{
+	int nr, i = 0;
+	struct page *page;
+
+	vunmap(vaddr);
+
+	size = PAGE_ALIGN(size);
+	nr = size >> PAGE_SHIFT;
+	page = phys_to_page(*dma);
+
+	while (i < nr) {
+		__free_page(page++);
+		i++;
+	}
+
+	return;
+}
+
+int set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)
+{
+	switch (pix_fmt) {
+	case PIX_FMT_RGB565:
+		var->bits_per_pixel = 16;
+		var->red.offset = 11;    var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 6;
+		var->blue.offset = 0;    var->blue.length = 5;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		break;
+	case PIX_FMT_BGR565:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;     var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 6;
+		var->blue.offset = 11;   var->blue.length = 5;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		break;
+	case PIX_FMT_RGB1555:
+		var->bits_per_pixel = 16;
+		var->red.offset = 10;    var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 5;
+		var->blue.offset = 0;    var->blue.length = 5;
+		var->transp.offset = 15; var->transp.length = 1;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 5 << 20;
+		break;
+	case PIX_FMT_BGR1555:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;     var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 5;
+		var->blue.offset = 10;   var->blue.length = 5;
+		var->transp.offset = 15; var->transp.length = 1;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 5 << 20;
+		break;
+	case PIX_FMT_RGB888PACK:
+		var->bits_per_pixel = 24;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 6 << 20;
+		break;
+	case PIX_FMT_BGR888PACK:
+		var->bits_per_pixel = 24;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 6 << 20;
+		break;
+	case PIX_FMT_RGB888UNPACK:
+		var->bits_per_pixel = 32;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 7 << 20;
+		break;
+	case PIX_FMT_BGR888UNPACK:
+		var->bits_per_pixel = 32;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 7 << 20;
+		break;
+	case PIX_FMT_RGBA888:
+		var->bits_per_pixel = 32;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 24; var->transp.length = 8;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 8 << 20;
+		break;
+	case PIX_FMT_BGRA888:
+		var->bits_per_pixel = 32;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 24; var->transp.length = 8;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 8 << 20;
+		break;
+	case PIX_FMT_RGB888A:
+		var->bits_per_pixel = 32;
+		var->red.offset = 24;    var->red.length = 8;
+		var->green.offset = 16;   var->green.length = 8;
+		var->blue.offset = 8;    var->blue.length = 8;
+		var->transp.offset = 0; var->transp.length = 8;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 0xA << 20;
+		break;
+	case PIX_FMT_BGR888A:
+		var->bits_per_pixel = 32;
+		var->red.offset = 8;     var->red.length = 8;
+		var->green.offset = 16;   var->green.length = 8;
+		var->blue.offset = 24;   var->blue.length = 8;
+		var->transp.offset = 0; var->transp.length = 8;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 0xA << 20;
+		break;
+	case PIX_FMT_YUYV422PACK:
+		var->bits_per_pixel = 16;
+		var->red.offset = 8;     var->red.length = 16;
+		var->green.offset = 4;   var->green.length = 16;
+		var->blue.offset = 0;   var->blue.length = 16;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 9 << 20;
+		break;
+	case PIX_FMT_YVU422PACK:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;     var->red.length = 16;
+		var->green.offset = 8;   var->green.length = 16;
+		var->blue.offset = 12;   var->blue.length = 16;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 9 << 20;
+		break;
+	case PIX_FMT_YUV422PACK:
+		var->bits_per_pixel = 16;
+		var->red.offset = 4;     var->red.length = 16;
+		var->green.offset = 12;   var->green.length = 16;
+		var->blue.offset = 0;    var->blue.length = 16;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 9 << 20;
+		break;
+	case PIX_FMT_PSEUDOCOLOR:
+		var->bits_per_pixel = 8;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 0;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_YUV422PLANAR:
+		var->bits_per_pixel = 16;
+		var->red.offset = 8;    var->red.length = 8;
+		var->green.offset = 4;   var->green.length = 4;
+		var->blue.offset = 0;   var->blue.length = 4;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 3 << 20;
+		break;
+	case PIX_FMT_YVU422PLANAR:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 4;
+		var->blue.offset = 12;   var->blue.length = 4;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 3 << 20;
+		break;
+	case PIX_FMT_YUV420PLANAR:
+		var->bits_per_pixel = 12;
+		var->red.offset = 0;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 2;
+		var->blue.offset = 10;   var->blue.length = 2;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 4 << 20;
+		break;
+	case PIX_FMT_YVU420PLANAR:
+		var->bits_per_pixel = 12;
+		var->red.offset = 0;    var->red.length = 8;
+		var->green.offset = 10;   var->green.length = 2;
+		var->blue.offset = 8;   var->blue.length = 2;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 4 << 20;
+		break;
+	case PIX_FMT_YUV420SEMIPLANAR:
+		var->bits_per_pixel = 12;
+		var->red.offset = 4;    var->red.length = 8;
+		var->green.offset = 0;   var->green.length = 2;
+		var->blue.offset = 2;   var->blue.length = 2;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 0xB << 20;
+		break;
+	case PIX_FMT_YVU420SEMIPLANAR:
+		var->bits_per_pixel = 12;
+		var->red.offset = 4;    var->red.length = 8;
+		var->green.offset = 2;   var->green.length = 2;
+		var->blue.offset = 0;   var->blue.length = 2;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 0xB << 20;
+		break;
+	/*
+	 * YUV422 Packed will be YUV444 Packed after
+	 * IRE 90 and 270 degree rotation
+	 */
+	case PIX_FMT_YUV422PACK_IRE_90_270:
+		var->bits_per_pixel = 32;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 24;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 7 << 20;
+		break;
+	default:
+		return  -EINVAL;
+	}
+
+	return 0;
+}
+
+int determine_best_pix_fmt(struct fb_var_screeninfo *var,
+			 struct pxa168fb_info *fbi)
+{
+	unsigned char pxa_format;
+
+	/* compatibility switch: if var->nonstd MSB is 0xAA then skip to
+	 * using the nonstd variable to select the color space
+	 */
+	if (fbi->compat_mode != 0x2625) {
+
+		/*
+		 * Pseudocolor mode?
+		 */
+		if (var->bits_per_pixel == 8)
+			return PIX_FMT_PSEUDOCOLOR;
+		/*
+		 * Check for YUV422PACK.
+		 */
+		if (var->bits_per_pixel == 16 && var->red.length == 16 &&
+			var->green.length == 16 && var->blue.length == 16) {
+			if (var->red.offset >= var->blue.offset)
+				return (var->red.offset == 4)
+					? PIX_FMT_YUV422PACK : PIX_FMT_YUYV422PACK;
+			else
+				return PIX_FMT_YVU422PACK;
+		}
+		/*
+		 * Check for YUV422PLANAR.
+		 */
+		if (var->bits_per_pixel == 16 && var->red.length == 8 &&
+			var->green.length == 4 && var->blue.length == 4 &&
+			fbi->vid)
+			return (var->red.offset >= var->blue.offset)
+				? PIX_FMT_YUV422PLANAR : PIX_FMT_YVU422PLANAR;
+		/*
+		 * Check for YUV420PLANAR, YUV420SEMIPLANAR.
+		 */
+		if (var->bits_per_pixel == 12 && var->red.length == 8 &&
+			var->green.length == 2 && var->blue.length == 2 &&
+			 fbi->vid) {
+			if (var->red.offset == 0)
+				return (var->green.offset <= var->blue.offset)
+					? PIX_FMT_YUV420PLANAR : PIX_FMT_YVU420PLANAR;
+			else
+				return (var->green.offset <= var->blue.offset)
+					? PIX_FMT_YUV420SEMIPLANAR : PIX_FMT_YVU420SEMIPLANAR;
+		}
+		/*
+		 * Check for 565/1555.
+		 */
+		if (var->bits_per_pixel == 16 && var->red.length <= 5 &&
+		    var->green.length <= 6 && var->blue.length <= 5) {
+			if (var->transp.length == 0)
+				return (var->red.offset >= var->blue.offset)
+					? PIX_FMT_RGB565 : PIX_FMT_BGR565;
+			else if (var->transp.length == 1 && var->green.length <= 5)
+				return (var->red.offset >= var->blue.offset)
+					? PIX_FMT_RGB1555 : PIX_FMT_BGR1555;
+			/* fall through */
+		}
+
+		/*
+		 * Check for 888/A888/888A.
+		 */
+		if (var->bits_per_pixel <= 32 && var->red.length <= 8 &&
+			var->green.length <= 8 && var->blue.length <= 8) {
+			if (var->bits_per_pixel == 24 &&
+				var->transp.length == 0)
+				return (var->red.offset >= var->blue.offset)
+					? PIX_FMT_RGB888PACK : PIX_FMT_BGR888PACK;
+			else if (var->bits_per_pixel == 32) {
+				if (0 == var->transp.offset)
+					return (var->red.offset >= var->blue.offset)
+						? PIX_FMT_RGB888UNPACK : PIX_FMT_BGR888UNPACK;
+				else if (8 == var->transp.length) {
+					if (24 == var->transp.offset)
+						return (var->red.offset >= var->blue.offset)
+							? PIX_FMT_RGBA888 : PIX_FMT_BGRA888;
+					else
+						return (var->red.offset >= var->blue.offset)
+							? PIX_FMT_RGB888A : PIX_FMT_BGR888A;
+				} else
+					return PIX_FMT_YUV422PACK_IRE_90_270;
+			}
+			/* fall through */
+		}
+	} else {
+
+		pxa_format = (var->nonstd >> 20) & 0xf;
+
+		switch (pxa_format) {
+		case 0:
+			return PIX_FMT_RGB565;
+		case 3:
+			if (fbi->vid)
+				return PIX_FMT_YUV422PLANAR;
+			break;
+		case 4:
+			if (fbi->vid)
+				return PIX_FMT_YUV420PLANAR;
+			break;
+		case 5:
+			return PIX_FMT_RGB1555;
+		case 6:
+			return PIX_FMT_RGB888PACK;
+		case 7:
+			return PIX_FMT_RGB888UNPACK;
+		case 8:
+			return PIX_FMT_RGBA888;
+		case 9:
+			return PIX_FMT_YUV422PACK;
+		case 0xA:
+			return PIX_FMT_RGB888A;
+		case 0xB:
+			if (fbi->vid)
+				return PIX_FMT_YUV420SEMIPLANAR;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return -EINVAL;
+}
+
+int pxa168fb_check_var(struct fb_var_screeninfo *var, struct fb_info *fi)
+{
+	struct pxa168fb_info *fbi = fi->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	int pix_fmt;
+
+	dev_dbg(fi->dev, "Enter %s\n", __func__);
+	if (var->bits_per_pixel == 8) {
+		pr_info("bits per pixel too small\n");
+		return -EINVAL;
+	}
+
+	/* compatibility mode: if the MSB of var->nonstd is 0xAA then
+	 * set xres_virtual and yres_virtual to xres and yres.
+	 */
+
+	if ((var->nonstd >> 24) == 0xAA)
+		fbi->compat_mode = 0x2625;
+	else if ((var->nonstd >> 24) == 0x55)
+		fbi->compat_mode = 0x0;
+
+	/*
+	 * Basic geometry sanity checks.
+	 */
+
+	if (var->xoffset + var->xres > var->xres_virtual) {
+		pr_err("ERROR: xoffset(%d) + xres(%d) is greater than "
+			"xres_virtual(%d)\n", var->xoffset, var->xres,
+			var->xres_virtual);
+		return -EINVAL;
+	}
+	if (var->yoffset + var->yres > var->yres_virtual) {
+		pr_err("ERROR: yoffset(%d) + yres(%d) is greater than "
+			"yres_virtual(%d)\n", var->yoffset, var->yres,
+			var->yres_virtual);
+		return -EINVAL;
+	}
+
+	if (var->xres + var->right_margin +
+	    var->hsync_len + var->left_margin > 3500) {
+		pr_err("ERROR: var->xres(%d) + var->right_margin(%d) + "
+			"var->hsync_len(%d) + var->left_margin(%d) > 2048",
+			var->xres, var->right_margin, var->hsync_len,
+			var->left_margin);
+		return -EINVAL;
+	}
+	if (var->yres + var->lower_margin +
+	    var->vsync_len + var->upper_margin > 2500) {
+		pr_err("var->yres(%d) + var->lower_margin(%d) + "
+			"var->vsync_len(%d) + var->upper_margin(%d) > 2048",
+			var->yres, var->lower_margin, var->vsync_len,
+			var->upper_margin);
+		return -EINVAL;
+	}
+
+	/*
+	 * Check size of framebuffer.
+	 */
+	if (mi->mmap && (var->xres_virtual * var->yres_virtual *
+	    (var->bits_per_pixel >> 3) > fbi->fb_size)) {
+		pr_err("xres_virtual(%d) * yres_virtual(%d) * "
+			"(bits_per_pixel(%d) >> 3) > max_fb_size(%d)",
+			var->xres_virtual, var->yres_virtual,
+			var->bits_per_pixel, fbi->fb_size);
+		return -EINVAL;
+	}
+
+	/*
+	 * Select most suitable hardware pixel format.
+	 */
+	pix_fmt = determine_best_pix_fmt(var, fbi);
+	dev_dbg(fi->dev, "%s determine_best_pix_fmt returned: %d\n",
+		 __func__, pix_fmt);
+	if (pix_fmt < 0)
+		return pix_fmt;
+
+	return 0;
+}
+
+int check_surface(struct fb_info *fi, struct _sOvlySurface *surface)
+{
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)fi->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct fb_var_screeninfo *var = &fi->var;
+	FBVideoMode new_mode = surface->videoMode;
+	struct _sViewPortInfo *new_info = &surface->viewPortInfo;
+	struct _sViewPortOffset *new_offset = &surface->viewPortOffset;
+	struct _sVideoBufferAddr *new_addr = &surface->videoBufferAddr;
+	int ret = 0;
+
+	dev_dbg(fi->dev, "Enter %s\n", __func__);
+
+	/* check view port settings. */
+	if (new_info && memcmp(&fbi->surface.viewPortInfo, new_info,
+			sizeof(struct _sViewPortInfo))) {
+		if (!(new_addr && new_addr->startAddr[0])) {
+			if (mi->mmap && (((new_info->srcWidth *
+			new_info->srcHeight * var->bits_per_pixel / 8) * 2)
+			> fbi->fb_size)) {
+				pr_err("%s: requested memory buffer size %d"
+					"exceed the max limit %d!\n", __func__,
+				(new_info->srcWidth * new_info->srcHeight
+				 * var->bits_per_pixel / 4), fbi->fb_size);
+				return -1;
+			}
+		}
+		fbi->surface.viewPortInfo = *new_info;
+		ret |= UPDATE_VIEW;
+	}
+
+	/* check mode */
+	if (new_mode >= 0 && fbi->surface.videoMode != new_mode) {
+		fbi->surface.videoMode = new_mode;
+		fbi->pix_fmt = convert_pix_fmt(new_mode);
+		set_pix_fmt(var, fbi->pix_fmt);
+		ret |= UPDATE_MODE;
+	}
+
+	/* Check offset	 */
+	if (new_offset && memcmp(&fbi->surface.viewPortOffset, new_offset,
+		sizeof(struct _sViewPortOffset))) {
+		fbi->surface.viewPortOffset.xOffset = new_offset->xOffset;
+		fbi->surface.viewPortOffset.yOffset = new_offset->yOffset;
+		ret |= UPDATE_VIEW;
+	}
+
+	/* Check buffer address */
+	if (new_addr && new_addr->startAddr[0] &&
+		(fbi->surface.videoBufferAddr.startAddr[0] !=
+		 new_addr->startAddr[0])) {
+		/*check overlay buffer address and pitch alignment*/
+		if (((unsigned long)new_addr->startAddr[0] & 63) &&
+			(fbi->surface.viewPortInfo.yPitch & 7) &&
+			(fbi->surface.viewPortInfo.uPitch & 7)) {
+			printk(KERN_WARNING "Ovly: the memory base 0x%08lx is"
+			" not 64 bytes aligned, pitch is not 8 bytes aligned,"
+			" video playback maybe wrong!\n",
+			(unsigned long)new_addr->startAddr[0]);
+		}
+		memcpy(fbi->surface.videoBufferAddr.startAddr,
+			 new_addr->startAddr, sizeof(new_addr->startAddr));
+		ret |= UPDATE_ADDR;
+	}
+
+	return ret;
+}
+
+int check_modex_active(struct pxa168fb_info *fbi)
+{
+	int active;
+
+	if (!fbi)
+		return 0;
+
+	active = fbi->active && fbi->dma_on;
+
+	/* disable all layers if in suspend */
+	if (!gfx_info.fbi[0]->active)
+		active = 0;
+
+	pr_debug("%s fbi[%d] vid %d fbi->active %d"
+		" dma_on %d: %d\n", __func__, fbi->id,
+		fbi->vid, fbi->active, fbi->dma_on, active);
+	return active;
+}
+
+void collectFreeBuf(struct pxa168fb_info *fbi,
+		u8 *filterList[][3], struct regshadow_list *reglist)
+{
+	struct regshadow_list *shadowreg_list = 0;
+	struct regshadow *shadowreg = 0;
+	struct list_head *pos, *n;
+	int i = 0;
+
+	if (!filterList || !reglist)
+		return;
+
+	if (fbi->debug == 1)
+		printk(KERN_DEBUG"%s fbi %d vid %d\n",
+			 __func__, fbi->id, fbi->vid);
+
+	list_for_each_safe(pos, n, &reglist->dma_queue) {
+		shadowreg_list = list_entry(pos, struct regshadow_list,
+			dma_queue);
+		list_del(pos);
+		shadowreg = &shadowreg_list->shadowreg;
+
+		if (shadowreg) {
+			/* save ptrs which need to be freed.*/
+			memcpy(filterList[i], &shadowreg->paddr0,
+				 3 * sizeof(u8 *));
+			if (fbi->debug == 1)
+				printk(KERN_DEBUG"buf %x will be returned\n",
+				 shadowreg->paddr0[0]);
+		}
+
+		i++;
+
+		if (i >= MAX_QUEUE_NUM)
+			break;
+
+		kfree(shadowreg_list);
+	}
+}
+
+void clearFilterBuf(u8 *ppBufList[][3], int iFlag)
+{
+	/* Check null pointer. */
+	if (!ppBufList)
+		return;
+	if (RESET_BUF & iFlag)
+		memset(ppBufList, 0, 3 * MAX_QUEUE_NUM * sizeof(u8 *));
+}
+
+void buf_clear(struct regshadow_list *reglist, int iFlag)
+{
+	struct regshadow_list *shadowreg_list;
+	struct list_head *pos, *n;
+
+	/* Check null pointer. */
+	if (!reglist)
+		return;
+
+	/* free */
+	if (FREE_ENTRY & iFlag) {
+		list_for_each_safe(pos, n, &reglist->dma_queue) {
+			shadowreg_list = list_entry(pos, struct regshadow_list,
+				dma_queue);
+			list_del(pos);
+			kfree(shadowreg_list);
+		}
+	}
+}
+
+void clear_buffer(struct pxa168fb_info *fbi)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&fbi->buf_lock, flags);
+	clearFilterBuf(fbi->filterBufList, RESET_BUF);
+	buf_clear(&fbi->buf_freelist, FREE_ENTRY);
+	buf_clear(&fbi->buf_waitlist, FREE_ENTRY);
+	kfree(fbi->buf_current);
+	fbi->buf_current = 0;
+	spin_unlock_irqrestore(&fbi->buf_lock, flags);
+}
+
+void buf_endframe(void *point)
+{
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)point;
+	struct regshadow_list *shadowreg_list = 0;
+	struct regshadow *shadowreg;
+
+	if (list_empty(&fbi->buf_waitlist.dma_queue))
+		return;
+
+	shadowreg_list = list_first_entry(&fbi->buf_waitlist.dma_queue,
+					struct regshadow_list, dma_queue);
+	shadowreg = &shadowreg_list->shadowreg;
+	list_del(&shadowreg_list->dma_queue);
+
+	/* Update new surface settings */
+	pxa168fb_set_regs(fbi, shadowreg);
+
+	if (fbi->buf_current)
+		list_add_tail(&fbi->buf_current->dma_queue,
+				&fbi->buf_freelist.dma_queue);
+	fbi->buf_current = shadowreg_list;
+}
+
+#if 0
+static int get_list_count(struct regshadow_list *reglist)
+{
+	struct list_head *pos, *n;
+	int count = 0;
+
+	list_for_each_safe(pos, n, &reglist->dma_queue)
+		count++;
+	return count;
+}
+#endif
+
+/*
+ * flip buffer vsync would only do flip for user allocated buffer
+ * and wait vsync to make sure buffer flipped on
+ * only user allocated buffer is supported
+ */
+int flip_buffer_vsync(struct fb_info *info, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)info->par;
+	struct regshadow shadowreg;
+	struct _sOvlySurface surface;
+	u8 *start_addr[3], *input_data;
+	int ret;
+
+	memset(&shadowreg, 0, sizeof(shadowreg));
+	mutex_lock(&fbi->access_ok);
+
+	/* Get user-mode data. */
+	if (copy_from_user(&surface, argp,
+				sizeof(struct _sOvlySurface))
+		&& unsupport_format(fbi, surface.viewPortInfo,
+				surface.videoMode))
+		goto failed;
+
+	update_surface(&surface);
+
+	start_addr[0] = surface.videoBufferAddr.startAddr[0];
+	input_data = surface.videoBufferAddr.inputData;
+
+	if (fbi->debug == 1)
+		pr_info("%s: fbi %d vid %d flip buf %p\n",
+			__func__, fbi->id, fbi->vid, start_addr[0]);
+	/*
+	 * Has DMA addr?
+	 */
+	if (!start_addr[0] || (input_data)) {
+		pr_err("%s only support DMA buffer\n", __func__);
+		goto failed;
+	}
+
+	ret = check_surface(info, &surface);
+	if (ret < 0) {
+		pr_err("fbi %d (line %d): vid %d, check surface"
+			" return error\n", fbi->id, __LINE__, fbi->vid);
+		goto failed;
+	}
+
+	pxa168fb_set_var(info, &shadowreg, ret);
+	/* we update immediately if only addr update */
+	if (shadowreg.flags == UPDATE_ADDR)
+		pxa168fb_set_regs(fbi, &shadowreg);
+	else
+		memcpy(&fbi->shadowreg, &shadowreg, sizeof(shadowreg));
+
+	mutex_unlock(&fbi->access_ok);
+
+	wait_for_vsync(fbi, SYNC_SELF);
+
+	return 0;
+
+failed:
+	mutex_unlock(&fbi->access_ok);
+	return -EFAULT;
+}
+
+int flip_buffer(struct fb_info *info, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)info->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	unsigned long flags;
+	struct regshadow_list *shadowreg_list = 0, *list;
+	struct regshadow *shadowreg = 0;
+	struct _sOvlySurface surface;
+	u8 *start_addr[3], *input_data;
+	u32 length;
+	int ret = 0;
+
+	mutex_lock(&fbi->access_ok);
+
+	/* Get user-mode data. */
+	if (copy_from_user(&surface, argp,
+				sizeof(struct _sOvlySurface))) {
+		mutex_unlock(&fbi->access_ok);
+		return -EFAULT;
+	}
+	if (unsupport_format(fbi, surface.viewPortInfo, surface.videoMode)) {
+		mutex_unlock(&fbi->access_ok);
+		return -EFAULT;
+	}
+
+	shadowreg_list = kzalloc(sizeof(struct regshadow_list), GFP_KERNEL);
+	if (shadowreg_list == NULL) {
+		mutex_unlock(&fbi->access_ok);
+		return -EFAULT;
+	}
+	shadowreg = &shadowreg_list->shadowreg;
+
+	update_surface(&surface);
+
+	length = surface.videoBufferAddr.length;
+	start_addr[0] = surface.videoBufferAddr.startAddr[0];
+	input_data = surface.videoBufferAddr.inputData;
+
+	if (fbi->debug == 1)
+		printk(KERN_DEBUG"fbi %d vid %d flip buf %p\n",
+				fbi->id, fbi->vid, start_addr[0]);
+	/*
+	 * Has DMA addr?
+	 */
+	if (start_addr[0] && (!input_data)) {
+		spin_lock_irqsave(&fbi->buf_lock, flags);
+#if 0
+		if (get_list_count(&fbi->buf_waitlist) >= 2) {
+			/*if there are more than two frames in waitlist, dequeue
+			*the older frame and enqueue it to freelist,
+			*then enqueue this frame to waitlist*/
+#else
+		while (!list_empty(&fbi->buf_waitlist.dma_queue)) {
+			/* free the waitlist elements if any */
+#endif
+			list = list_first_entry(&fbi->buf_waitlist.dma_queue,
+				struct regshadow_list, dma_queue);
+			list_del(&list->dma_queue);
+			list_add_tail(&list->dma_queue,
+				&fbi->buf_freelist.dma_queue);
+			memset(&fbi->surface, 0, sizeof(fbi->surface));
+			fbi->surface.videoMode = -1;
+		}
+		ret = check_surface(info, &surface);
+		if (ret >= 0) {
+			pxa168fb_set_var(info, shadowreg, ret);
+			if (ret) {
+				/* we update immediately if only addr update */
+				if (shadowreg->flags == UPDATE_ADDR)
+					pxa168fb_set_regs(fbi, shadowreg);
+				list_add_tail(&shadowreg_list->dma_queue,
+					&fbi->buf_waitlist.dma_queue);
+				ret = 0;
+			} else
+				/* enqueue the repeated buffer to freelist */
+				list_add_tail(&shadowreg_list->dma_queue,
+					&fbi->buf_freelist.dma_queue);
+		} else {
+			pr_err("fbi %d (line %d): vid %d, check surface"
+				"return error\n", fbi->id, __LINE__, fbi->vid);
+			ret = -EFAULT;
+		}
+		spin_unlock_irqrestore(&fbi->buf_lock, flags);
+	} else {
+		if (!mi->mmap) {
+			pr_err("fbi %d(line %d): input err, mmap is not"
+				" supported\n", fbi->id, __LINE__);
+			kfree(shadowreg_list);
+			mutex_unlock(&fbi->access_ok);
+			return -EINVAL;
+		}
+
+		ret = check_surface(info, &surface);
+		if (ret >= 0) {
+			pxa168fb_set_var(info, shadowreg, ret);
+			ret = 0;
+		} else {
+			pr_err("fbi %d (line %d): vid %d, check surface"
+				"return error\n", fbi->id, __LINE__, fbi->vid);
+			kfree(shadowreg_list);
+			mutex_unlock(&fbi->access_ok);
+			return -EFAULT;
+		}
+
+		/* copy buffer */
+		if (input_data) {
+			if (NEED_VSYNC(fbi))
+				wait_for_vsync(fbi, SYNC_SELF);
+			/* if support hw DMA, replace this. */
+			if (copy_from_user(fbi->fb_start,
+						input_data, length)){
+				kfree(shadowreg_list);
+				mutex_unlock(&fbi->access_ok);
+				return -EFAULT;
+			}
+			kfree(shadowreg_list);
+			mutex_unlock(&fbi->access_ok);
+			return 0;
+		}
+
+		/*
+		 * if it has its own physical address,
+		 * switch to this memory. don't support YUV planar format
+		 * with split YUV buffers. but below code seems have no
+		 * chancee to execute. - FIXME
+		 */
+		if (start_addr[0]) {
+			pxa168fb_free_framebuffer(fbi->fb_size, fbi->fb_start,
+					&fbi->fb_start_dma);
+
+			fbi->fb_start = __va(start_addr[0]);
+			fbi->fb_size = length;
+			fbi->fb_start_dma =
+				(dma_addr_t)__pa(fbi->fb_start);
+			info->fix.smem_start = fbi->fb_start_dma;
+			info->fix.smem_len = fbi->fb_size;
+			info->screen_base = fbi->fb_start;
+			info->screen_size = fbi->fb_size;
+		}
+	}
+
+	kfree(shadowreg_list);
+	mutex_unlock(&fbi->access_ok);
+
+	return ret;
+}
+
+static void free_buf(struct pxa168fb_info *fbi)
+{
+	struct list_head *pos, *n;
+
+	/* put all buffers into free list */
+	list_for_each_safe(pos, n, &fbi->buf_waitlist.dma_queue) {
+		list_del(pos);
+		list_add_tail(pos, &fbi->buf_freelist.dma_queue);
+	}
+
+	if (fbi->buf_current) {
+		list_add_tail(&fbi->buf_current->dma_queue,
+			&fbi->buf_freelist.dma_queue);
+		fbi->buf_current = 0;
+	}
+
+	memset(&fbi->surface, 0, sizeof(struct _sOvlySurface));
+	fbi->surface.videoMode = -1;
+}
+
+int get_freelist(struct fb_info *info, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)info->par;
+	unsigned long flags;
+
+	if (fbi->debug == 1)
+		printk(KERN_DEBUG"fbi %d vid %d get freelist\n",
+				 fbi->id, fbi->vid);
+
+	spin_lock_irqsave(&fbi->buf_lock, flags);
+
+	/* when lcd is suspend, move all buffers as "switched"*/
+	if (!(gfx_info.fbi[fbi->id]->active))
+		buf_endframe(fbi);
+	/* when video layer dma is off, free all buffers */
+	if (!fbi->dma_on)
+		free_buf(fbi);
+
+	/* Collect expired frame to list */
+	collectFreeBuf(fbi, fbi->filterBufList, &fbi->buf_freelist);
+	spin_unlock_irqrestore(&fbi->buf_lock, flags);
+
+	if (copy_to_user(argp, fbi->filterBufList,
+				3*MAX_QUEUE_NUM*sizeof(u8 *))) {
+		return -EFAULT;
+	}
+	clearFilterBuf(fbi->filterBufList, RESET_BUF);
+
+	if (fbi->debug == 1)
+		printk(KERN_DEBUG"fbi %d vid %d get freelist end\n",
+				fbi->id, fbi->vid);
+
+	return 0;
+}
+
+void set_dma_active(struct pxa168fb_info *fbi)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct lcd_regs *regs = get_regs(fbi->id);
+	struct fb_var_screeninfo *v = &gfx_info.fbi[fbi->id]->fb_info->var;
+	struct _sVideoBufferAddr *new_addr = &fbi->surface.videoBufferAddr;
+	u32 flag = fbi->vid ? CFG_DMA_ENA_MASK : CFG_GRA_ENA_MASK;
+	u32 enable = fbi->vid ? CFG_DMA_ENA(1) : CFG_GRA_ENA(1);
+	u32 value, dma1, v_size_dst, screen_active, active = 0;
+
+	if ((unsigned long)new_addr->startAddr[0] || mi->mmap ||
+		(!fbi->vid && fb_share && fbi->id == 1))
+		active = check_modex_active(fbi);
+
+	value = active ? enable : 0;
+
+	/* don't enalbe graphic dma for pxa988 z1/z2 series */
+	if (has_feat_video_replace_graphics_dma() && !fbi->vid)
+		value = 0;
+
+	/* if video layer is full screen without alpha blending
+	 * then turn off graphics dma to save bandwidth */
+	if (fbi->vid && active) {
+		dma1 = dma_ctrl_read(fbi->id, 1);
+		dma1 &= (CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK);
+		if (dma1 == (CFG_ALPHA_MODE(2) | CFG_ALPHA(0xff))) {
+			v_size_dst = readl(&regs->v_size_z);
+			screen_active = readl(&regs->screen_active);
+			if (v->vmode & FB_VMODE_INTERLACED) {
+				screen_active = (screen_active & 0xffff) |
+					(((screen_active >> 16) << 1) << 16);
+			}
+			if (v_size_dst == screen_active) {
+				flag |= CFG_GRA_ENA_MASK;
+				value &= ~CFG_GRA_ENA_MASK;
+			} else if (check_modex_active(gfx_info.fbi[fbi->id])) {
+				flag |= CFG_GRA_ENA_MASK;
+				value |= CFG_GRA_ENA_MASK;
+			}
+		}
+	}
+
+	dma_ctrl_set(fbi->id, 0, flag, value);
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+	if (!atomic_read(&displayon) && (value != 0))
+		atomic_set(&displayon, 1);
+#endif
+
+	pr_debug("%s fbi %d: vid %d mask %x vaule %x fbi->active %d\
+		 new_addr %lu\n", __func__, fbi->id, fbi->vid, flag,
+		 value, fbi->active, (unsigned long)new_addr->startAddr[0]);
+}
+
+int dispd_dma_enabled(struct pxa168fb_info *fbi)
+{
+	if (irqs_disabled() || !fbi->active)
+		return 0;
+
+	/* check whether display done irq enabled */
+	if (!(readl(fbi->reg_base + SPU_IRQ_ENA) &
+		display_done_imask(fbi->id)))
+		return 0;
+
+	/* check whether path clock is disabled */
+	if (lcd_clk_get(fbi->id, clk_sclk) & SCLK_DISABLE)
+		return 0;
+
+	/* in modex dma may not be enabled */
+	return dma_ctrl_read(fbi->id, 0) & (fbi->vid ?
+		CFG_DMA_ENA_MASK : CFG_GRA_ENA_MASK);
+}
+
+void clear_dispd_irq(struct pxa168fb_info *fbi)
+{
+	int isr = readl(fbi->reg_base + SPU_IRQ_ISR);
+
+	if ((isr & display_done_imask(fbi->id))) {
+		irq_status_clear(fbi->id, display_done_imask(fbi->id));
+		pr_info("fbi %d irq miss, clear isr %x\n", fbi->id, isr);
+	}
+}
+
+void irq_mask_eof(int id)
+{
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	struct pxa168fb_info *fbi = gfx_info.fbi[id];
+	int irq_mask = display_done_imask(fbi->id);
+
+#ifdef CONFIG_DISP_DFC
+	irq_mask |= vsync_imask(fbi->id);
+#endif
+	spin_lock(&fbi->var_lock);
+	if (atomic_dec_and_test(&fbi->irq_en_count)) {
+		if (fbi->active) {
+			irq_mask_set(fbi->id, irq_mask, 0);
+			if (!has_feat_video_replace_graphics_dma())
+				pm_qos_update_request(&fbi->qos_idle,
+					PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE);
+		} else {
+			fbi->irq_mask &= ~irq_mask;
+			pr_err("%s: LCD is suspended, do nothing\n", __func__);
+		}
+	}
+	spin_unlock(&fbi->var_lock);
+
+	dev_dbg(fbi->dev, "mask eof intr: irq enable count %d\n",
+		atomic_read(&fbi->irq_en_count));
+#endif
+
+}
+
+void irq_unmask_eof(int id)
+{
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	struct pxa168fb_info *fbi = gfx_info.fbi[id];
+	int irq_mask = display_done_imask(fbi->id);
+#ifdef CONFIG_DISP_DFC
+	irq_mask |= vsync_imask(fbi->id);
+#endif
+
+	spin_lock(&fbi->var_lock);
+	if (!atomic_read(&fbi->irq_en_count)) {
+		if (fbi->active) {
+			if (!has_feat_video_replace_graphics_dma())
+				pm_qos_update_request(&fbi->qos_idle,
+					PM_QOS_CPUIDLE_BLOCK_AXI_VALUE);
+			irq_status_clear(fbi->id, irq_mask);
+			irq_mask_set(fbi->id, irq_mask, irq_mask);
+		} else {
+			fbi->irq_mask |= irq_mask;
+			pr_err("%s: LCD is suspended, do nothing\n", __func__);
+		}
+	}
+	atomic_inc(&fbi->irq_en_count);
+	spin_unlock(&fbi->var_lock);
+
+	dev_dbg(fbi->dev, "unmask eof intr: irq enable count %d\n",
+		atomic_read(&fbi->irq_en_count));
+#endif
+}
+
+void wait_for_vsync(struct pxa168fb_info *fbi, unsigned char param)
+{
+	struct fbi_info *info = (fbi->vid) ? &ovly_info : &gfx_info;
+	int ret = 0;
+
+	pr_debug("fbi->id %d vid: %d\n", fbi->id, fbi->vid);
+#ifdef VSYNC_DSI_CMD
+	mutex_lock(&fbi->vsync_mutex);
+#endif
+
+	irq_unmask_eof(fbi->id);
+
+	switch (param) {
+	case SYNC_SELF:
+		atomic_set(&fbi->w_intr, 0);
+		ret = wait_event_interruptible_timeout(gfx_info.fbi[0]->w_intr_wq,
+				atomic_read(&fbi->w_intr), HZ/20);
+		if (!ret)
+			clear_dispd_irq(fbi);
+		break;
+	case SYNC_PANEL:
+		atomic_set(&info->fbi[0]->w_intr, 0);
+		ret = wait_event_interruptible_timeout(gfx_info.fbi[0]->w_intr_wq,
+				atomic_read(&info->fbi[0]->w_intr), HZ/20);
+		if (!ret)
+			clear_dispd_irq(info->fbi[0]);
+		break;
+	case SYNC_TV:
+		atomic_set(&info->fbi[1]->w_intr, 0);
+		ret = wait_event_interruptible_timeout(gfx_info.fbi[0]->w_intr_wq,
+				atomic_read(&info->fbi[1]->w_intr), HZ/20);
+		if (!ret)
+			clear_dispd_irq(info->fbi[1]);
+		break;
+	case SYNC_PANEL_TV:
+		atomic_set(&info->fbi[0]->w_intr, 0);
+		atomic_set(&info->fbi[1]->w_intr, 0);
+		ret = wait_event_interruptible_timeout(gfx_info.fbi[0]->w_intr_wq,
+				atomic_read(&info->fbi[0]->w_intr) &&
+				atomic_read(&info->fbi[1]->w_intr), HZ/20);
+		if (!ret) {
+			if (atomic_read(&info->fbi[0]->w_intr) == 0)
+				clear_dispd_irq(info->fbi[0]);
+			if (atomic_read(&info->fbi[1]->w_intr) == 0)
+				clear_dispd_irq(info->fbi[1]);
+		}
+		break;
+	default:
+		break;
+	}
+	irq_mask_eof(fbi->id);
+#ifdef VSYNC_DSI_CMD
+	mutex_unlock(&fbi->vsync_mutex);
+#endif
+}
+
+enum VSYNC_JOB_TYPE {
+	VSYNC_DSI_SEND_COMMAND = 1,
+	VSYNC_DSI_READ_COMMAND,
+	VSYNC_DSI_LANE_RESET,
+	END_OF_TYPE
+};
+
+struct VSYNC_JOB {
+	enum VSYNC_JOB_TYPE type;
+	void *data;
+};
+
+static struct VSYNC_JOB *todo_job;
+
+int wait_for_vsync_job(struct pxa168fb_info *fbi, struct VSYNC_JOB *job)
+{
+	int ret = 0;
+	unsigned long flags;
+	unsigned long time;
+ #ifdef VSYNC_DSI_CMD
+	mutex_lock(&fbi->vsync_mutex);
+#endif
+	spin_lock_irqsave(&fbi->job_lock, flags);
+	todo_job = job;
+	spin_unlock_irqrestore(&fbi->job_lock, flags);
+	//printk("%s : +Queing job %d\n", __func__, job ? job->type : -1);
+	irq_unmask_eof(fbi->id);
+	atomic_set(&fbi->w_intr1, 0);
+	time = jiffies;
+	ret = wait_event_interruptible_timeout(gfx_info.fbi[0]->w_intr_wq1,
+		atomic_read(&fbi->w_intr1), HZ/20);
+	time = jiffies - time;
+	if (!ret) {
+			clear_dispd_irq(fbi);
+		printk("%s, timeout!(type:%d, elapsed:%dms)\n",
+				__func__, job->type, jiffies_to_msecs(time));
+		printk("%s, irq_mask =0x%08x, active=%d, dma_on=%d, output_on=%d\n", __func__, vsync_imask(fbi->id),!!(fbi->active), !!(fbi->dma_on), !!(fbi->output_on));
+		;
+	}
+	spin_lock_irqsave(&fbi->job_lock, flags);
+	todo_job = NULL;
+	spin_unlock_irqrestore(&fbi->job_lock, flags);
+	//printk("%s : -Queing job\n", __func__);
+	irq_mask_eof(fbi->id);
+#ifdef VSYNC_DSI_CMD
+	mutex_unlock(&fbi->vsync_mutex);
+#endif
+	return ret;
+}
+
+void reset_lanes(struct pxa168fb_info *fbi)
+{
+	panel_dma_ctrl(0);
+	dsi_lanes_enable(fbi, 0);
+	udelay(5);
+	dsi_lanes_enable(fbi, 1);
+	udelay(5);
+	panel_dma_ctrl(1);
+}
+
+void dsi_lanes_reset(struct pxa168fb_info *fbi)
+{
+	struct VSYNC_JOB job;
+	if (!fbi) return;
+	//printk("Reset DSI lanes\n");
+	mutex_lock(&fbi->cmd_mutex);
+	job.type = VSYNC_DSI_LANE_RESET;
+	job.data = NULL;
+	if (fbi->active) wait_for_vsync_job(fbi, &job);
+	//else printk("fbi->active : %d\n", fbi->active);
+	mutex_unlock(&fbi->cmd_mutex);
+	return;
+}
+void dsi_lanes_check(struct pxa168fb_info *fbi)
+{
+	//struct VSYNC_JOB job;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi;
+	unsigned int irq_status, rx0_status,rx_ctrl1,lcd1_status_0,count=0;
+#if 0 // Force reset testing
+	static int count2 = 20;
+#endif
+	if (!di) {
+		pr_err("%s: no dsi info available\n", __func__);
+		return;
+	}
+	dsi = (struct dsi_regs *)di->regs;
+retry:
+	irq_status = readl(&dsi->irq_status);
+	rx0_status = readl(&dsi->rx0_status);
+	rx_ctrl1 = readl(&dsi->rx_ctrl1);
+	lcd1_status_0 = readl(&dsi->lcd1.status_0);
+#if 0 // Force reset testing
+	count2--;
+	if (count2 < 7)
+	{
+		lcd1_status_0 = 0xE0000000;
+		if (count2 == 0) count2=20;
+	}
+#endif
+	if ((lcd1_status_0 & 0xE0000000)== 0xE0000000) // Check DPHY_STOP_STATE_BYTE, and Ready/Request check
+	{
+					// check it 5 times, normal state, can have stop state.
+					if (count++ < 5)
+					{
+									msleep(5);
+									goto retry;
+					}
+	} else return;
+	if ((lcd1_status_0 & 0xE0000000)== 0xE0000000) // Check DPHY_STOP_STATE_BYTE, and Ready/Request check
+	{
+		//printk("Begin 0x%08x,0x%08x,0x%08x,0x%08x\n",lcd1_status_0,irq_status,rx0_status,rx_ctrl1);
+		dsi_lanes_reset(fbi);
+		//printk("Finish 0x%08x,0x%08x,0x%08x,0x%08x\n",lcd1_status_0,irq_status,rx0_status,rx_ctrl1);
+	}
+	return;
+}
+
+void dsi_lanes_debug(struct pxa168fb_info *fbi)
+{
+
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi;
+	unsigned int irq_status, rx0_status,rx_ctrl1,lcd1_status_0,count=0;
+	if (!di) {
+		pr_err("%s: no dsi info available\n", __func__);
+		return;
+	}
+	dsi = (struct dsi_regs *)di->regs;
+	irq_status = readl(&dsi->irq_status);
+	rx0_status = readl(&dsi->rx0_status);
+	rx_ctrl1 = readl(&dsi->rx_ctrl1);
+	lcd1_status_0 = readl(&dsi->lcd1.status_0);
+	printk("ESD.isr : 0x%08x\n",readl(fbi->reg_base + SPU_IRQ_ISR));
+	printk("ESD.phy 0x%08x,0x%08x,0x%08x,0x%08x\n",lcd1_status_0,irq_status,rx0_status,rx_ctrl1);
+}
+struct VSYNC_DSI_TX_CMD_DATA {
+	struct pxa168fb_info *fbi;
+	struct dsi_cmd_desc *cmds;
+	int count;
+	u8 *buffer;
+	u8 *packet_len;
+};
+void pxa168_dsi_cmd_array_tx(struct pxa168fb_info *fbi, struct dsi_cmd_desc cmds[],
+		int count)
+{
+#ifdef VSYNC_DSI_CMD
+	u8 *buffer, *packet_len;
+	int ret = 0;
+	buffer = kzalloc(DSI_MAX_DATA_BYTES*count, GFP_KERNEL);
+	packet_len = kmalloc(count, GFP_KERNEL);
+
+	if (!buffer) {
+		printk(KERN_WARNING"Cannot get dsi cmd buffer\n");
+		if (packet_len) {
+			kfree(packet_len);
+			packet_len = NULL;
+		}
+	} else {
+		if (!packet_len) {
+			printk(KERN_WARNING"Cannot get dsi cmd buffer\n");
+			kfree(buffer);
+			buffer = NULL;
+		}
+		//printk("Use prepareing method\n");
+	}
+
+	mutex_lock(&fbi->cmd_mutex);
+	if (buffer && packet_len) {
+		int loop;
+		struct VSYNC_JOB job;
+		struct VSYNC_DSI_TX_CMD_DATA txcmd_data;
+
+		dsi_prepare_cmd_array_tx(fbi, cmds, count,buffer, packet_len);
+		printk("%s : fbi->active = %d fbi->output_on = %d\n", __func__, fbi->active,fbi->output_on);
+		if (fbi->active && fbi->output_on) {
+			txcmd_data.fbi = fbi;
+			txcmd_data.cmds = cmds;
+			txcmd_data.count = count;
+			txcmd_data.buffer = buffer;
+			txcmd_data.packet_len = packet_len;
+			job.type = VSYNC_DSI_SEND_COMMAND;
+			job.data = &txcmd_data;
+			ret = wait_for_vsync_job(fbi, &job);
+			if (!ret) // request occured during non fb emitting period
+			{
+				printk("%s : timout send directly...\n", __func__);
+				for(loop = 0; loop < count; loop++)
+					dsi_send_prepared_cmd_tx(fbi, cmds[loop], buffer+DSI_MAX_DATA_BYTES*loop, packet_len[loop]);
+			}
+		} else {
+			for(loop = 0; loop < count; loop++)
+				dsi_send_prepared_cmd_tx(fbi, cmds[loop], buffer+DSI_MAX_DATA_BYTES*loop, packet_len[loop]);
+		}
+		kfree(buffer);
+		kfree(packet_len);
+	} else {
+		if (fbi->active) wait_for_vsync_job(fbi, NULL); // dummy call
+		panel_dma_ctrl(0);
+		dsi_cmd_array_tx(fbi, cmds, count);
+		panel_dma_ctrl(1);
+	}
+	mutex_unlock(&fbi->cmd_mutex);
+#else
+	dsi_cmd_array_tx(fbi, cmds, count);
+#endif
+}
+
+void pxa168_dsi_cmd_array_rx(struct pxa168fb_info *fbi, struct dsi_buf *dbuf,
+		struct dsi_cmd_desc cmds[], int count)
+{
+#ifdef VSYNC_DSI_CMD
+	u8 *buffer, *packet_len;
+	int ret;
+
+	buffer = kzalloc(DSI_MAX_DATA_BYTES*count, GFP_KERNEL);
+	packet_len = kmalloc(count, GFP_KERNEL);
+
+	if (!buffer) {
+		printk(KERN_WARNING"Cannot get dsi cmd buffer\n");
+		if (packet_len) {
+			kfree(packet_len);
+			packet_len = NULL;
+		}
+	} else {
+		if (!packet_len) {
+			printk(KERN_WARNING"Cannot get dsi cmd buffer\n");
+			kfree(buffer);
+			buffer = NULL;
+		}
+		//printk("Use prepareing method\n");
+	}
+
+	mutex_lock(&fbi->cmd_mutex);
+	if (buffer && packet_len) {
+		int loop;
+		struct VSYNC_JOB job;
+		struct VSYNC_DSI_TX_CMD_DATA txcmd_data;
+		dsi_prepare_cmd_array_tx(fbi, cmds, count,buffer, packet_len);
+		printk("%s : fbi->active = %d fbi->output_on = %d\n", __func__, fbi->active,fbi->output_on);
+		if (fbi->active && fbi->output_on) {
+			txcmd_data.fbi = fbi;
+			txcmd_data.cmds = cmds;
+			txcmd_data.count = count;
+			txcmd_data.buffer = buffer;
+			txcmd_data.packet_len = packet_len;
+			job.type = VSYNC_DSI_SEND_COMMAND;
+			job.data = &txcmd_data;
+			ret=wait_for_vsync_job(fbi, &job);
+			if (!ret) // request occured during non fb emitting period
+			{
+				for(loop = 0; loop < count; loop++)
+					dsi_send_prepared_cmd_tx(fbi, cmds[loop], buffer+DSI_MAX_DATA_BYTES*loop, packet_len[loop]);
+			}
+		} else {
+			for(loop = 0; loop < count; loop++)
+				dsi_send_prepared_cmd_tx(fbi, cmds[loop], buffer+DSI_MAX_DATA_BYTES*loop, packet_len[loop]);
+		}
+		kfree(buffer);
+		kfree(packet_len);
+	} else {
+		if (fbi->active) wait_for_vsync_job(fbi, NULL); // dummy call
+		panel_dma_ctrl(0);
+		dsi_cmd_array_tx(fbi, cmds, count);
+		panel_dma_ctrl(1);
+	}
+	dsi_cmd_array_rx_process(fbi, dbuf);
+	mutex_unlock(&fbi->cmd_mutex);
+#else
+	dsi_cmd_array_rx(fbi,dbuf,cmds,count);
+#endif
+}
+
+void pxa168fb_list_init(struct pxa168fb_info *fbi)
+{
+	INIT_LIST_HEAD(&fbi->buf_freelist.dma_queue);
+	INIT_LIST_HEAD(&fbi->buf_waitlist.dma_queue);
+	fbi->buf_current = 0;
+}
+
+void pxa168fb_misc_update(struct pxa168fb_info *fbi)
+{
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+
+	lcd_vdma = request_vdma(fbi->id, fbi->vid);
+	if (lcd_vdma) {
+		vdma_info_update(lcd_vdma, fbi->active, fbi->dma_on, fbi->pix_fmt,
+				fbi->surface.viewPortInfo.rotation,
+				fbi->surface.viewPortInfo.yuv_format);
+		pxa688_vdma_config(lcd_vdma);
+	}
+	if (fbi->vid && vid_vsmooth)
+		pxa688fb_vsmooth_set(fbi->id, 1, vid_vsmooth);
+	if (!fbi->vid) {
+		pxa688fb_partdisp_update(fbi->id);
+		if (gfx_vsmooth)
+			pxa688fb_vsmooth_set(fbi->id, 0, gfx_vsmooth);
+	}
+}
+
+void set_start_address(struct fb_info *info, int xoffset, int yoffset,
+			struct regshadow *shadowreg)
+{
+	struct pxa168fb_info *fbi = info->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct fb_var_screeninfo *var = &info->var;
+	unsigned long addr_y0 = 0, addr_u0 = 0, addr_v0 = 0;
+	struct _sVideoBufferAddr *new_addr = &fbi->surface.videoBufferAddr;
+	int  pixel_offset;
+
+	dev_dbg(info->dev, "Enter %s\n", __func__);
+
+	if ((unsigned long)new_addr->startAddr[0]) {
+		memcpy(&shadowreg->paddr0, new_addr->startAddr,
+			 sizeof(new_addr->startAddr));
+		if (fbi->debug == 1)
+			printk(KERN_DEBUG"%s: buffer updated to %x\n",
+				 __func__, (int)new_addr->startAddr[0]);
+	} else {
+		if (!mi->mmap) {
+			pr_debug("fbi %d(line %d): input err, mmap is not"
+				" supported\n", fbi->id, __LINE__);
+			return;
+		}
+		pixel_offset = (yoffset * var->xres_virtual) + xoffset;
+		addr_y0 = fbi->fb_start_dma + (pixel_offset *
+			(var->bits_per_pixel >> 3));
+		if ((fbi->pix_fmt >= 12) && (fbi->pix_fmt <= 15))
+			addr_u0 = addr_y0 + var->xres * var->yres;
+
+		if ((fbi->pix_fmt >> 1) == 6)
+			addr_v0 = addr_u0 + (var->xres * var->yres >> 1);
+		else if ((fbi->pix_fmt >> 1) == 7)
+			addr_v0 = addr_u0 + (var->xres * var->yres >> 2);
+
+		shadowreg->paddr0[0] = addr_y0;
+		shadowreg->paddr0[1] = addr_u0;
+		shadowreg->paddr0[2] = addr_v0;
+	}
+}
+
+void set_dma_control0(struct pxa168fb_info *fbi, struct regshadow *shadowreg)
+{
+	struct pxa168fb_mach_info *mi;
+	u32 x = 0, pix_fmt;
+
+	dev_dbg(fbi->fb_info->dev, "Enter %s\n", __func__);
+
+	mi = fbi->dev->platform_data;
+	pix_fmt = fbi->pix_fmt;
+	shadowreg->yuv420sp_ctrl = 0;
+
+	/* If we are in a pseudo-color mode, we need to enable
+	 * palette lookup  */
+	if (pix_fmt == PIX_FMT_PSEUDOCOLOR)
+		x |= dma_palette(1);
+
+	/* Configure hardware pixel format */
+	x |= dma_fmt(fbi->vid, (pix_fmt & ~0x1000) >> 1);
+
+	/*
+	 * color format in memory:
+	 * PXA168/PXA910:
+	 * PIX_FMT_YUV422PACK: UYVY(CbY0CrY1)
+	 * PIX_FMT_YUV422PLANAR: YUV
+	 * PIX_FMT_YUV420PLANAR: YUV
+	 */
+	if (((pix_fmt & ~0x1000) >> 1) == 5) {
+		/* YUV422PACK, YVU422PACK, YUYV422PACK */
+		x |= dma_csc(fbi->vid, 1);
+		x |= dma_swaprb(fbi->vid, mi->panel_rbswap);
+		if (pix_fmt & 0x1000)
+			/* YUYV422PACK */
+			x |= dma_swapyuv(fbi->vid, 1);
+		else
+			/* YVU422PACK */
+			x |= dma_swapuv(fbi->vid, pix_fmt & 1);
+	} else if (pix_fmt >= 12) {
+		/* PLANAR, SEMIPLANAR, YUV422PACK_IRE_90_270, PSEUDOCOLOR */
+		if (!fbi->vid)
+			pr_err("%s fmt %d not supported on graphics layer...\n",
+				__func__, pix_fmt);
+		x |= dma_csc(fbi->vid, 1);
+		if (pix_fmt == PIX_FMT_YUV420SEMIPLANAR ||
+			pix_fmt == PIX_FMT_YVU420SEMIPLANAR)
+			/* YUV420SP format owns independent UV swap ctrl */
+			shadowreg->yuv420sp_ctrl = swap_spuv(fbi->id);
+		else
+			x |= dma_swapuv(fbi->vid, pix_fmt & 1);
+		x |= dma_swaprb(fbi->vid, (mi->panel_rbswap));
+	} else {
+		/* RGB formats */
+		/* Check red and blue pixel swap.
+		 * 1. source data swap. BGR[M:L] rather than RGB[M:L]
+		 *    is stored in memeory as source format.
+		 * 2. panel output data swap
+		 */
+		x |= dma_swaprb(fbi->vid, ((pix_fmt & 1) ^ 1) ^
+			 (mi->panel_rbswap));
+	}
+
+	shadowreg->dma_ctrl0 = x;
+}
+
+void set_screen(struct pxa168fb_info *fbi, struct regshadow *shadowreg)
+{
+	struct fb_var_screeninfo *var = &fbi->fb_info->var;
+	struct _sOvlySurface *surface = &fbi->surface;
+	struct _sVideoBufferAddr *new_addr = &fbi->surface.videoBufferAddr;
+	u32 xres, yres, xres_z, yres_z, xres_virtual, bits_per_pixel;
+	u32 left = 0, top = 0, pitch[3], x;
+
+	var = &fbi->fb_info->var;
+	xres = var->xres; yres = var->yres;
+	xres_z = var->xres; yres_z = var->yres;
+	xres_virtual = var->xres_virtual;
+	bits_per_pixel = var->bits_per_pixel;
+
+	/* xres_z = total - left - right */
+	xres_z = xres_z - (left << 1);
+	/* yres_z = yres_z - top - bottom */
+	yres_z = yres_z - (top << 1);
+
+	if ((unsigned long)new_addr->startAddr[0]) {
+		xres = surface->viewPortInfo.srcWidth;
+		yres = surface->viewPortInfo.srcHeight;
+		var->xres_virtual = surface->viewPortInfo.srcWidth;
+		var->yres_virtual = surface->viewPortInfo.srcHeight * 2;
+		xres_virtual = surface->viewPortInfo.srcWidth;
+
+		xres_z = surface->viewPortInfo.zoomXSize;
+		yres_z = surface->viewPortInfo.zoomYSize;
+
+		left = surface->viewPortOffset.xOffset;
+		top = surface->viewPortOffset.yOffset;
+
+		pr_debug("surface: xres %d xres_z %d"
+			" yres %d yres_z %d\n left %d top %d\n",
+			xres, xres_z, yres, yres_z, left, top);
+	}
+
+	dev_dbg(fbi->fb_info->dev, "adjust: xres %d xres_z %d"
+		" yres %d yres_z %d\n left %d top %d\n",
+		xres, xres_z, yres, yres_z, left, top);
+
+	pitch[0] = surface->viewPortInfo.yPitch;
+	pitch[1] = surface->viewPortInfo.uPitch;
+	pitch[2] = surface->viewPortInfo.vPitch;
+
+	if (((fbi->pix_fmt & ~0x1000) >> 1) < 6) {
+		pitch[0] = pitch[0] ? pitch[0] : (xres_virtual *
+				 bits_per_pixel >> 3);
+		pitch[1] = pitch[2] = 0;
+	} else {
+		pitch[0] = pitch[0] ? pitch[0] : xres;
+		pitch[1] = pitch[1] ? pitch[1] : xres >> 1;
+		pitch[2] = pitch[2] ? pitch[2] : xres >> 1;
+	}
+	/* start address on screen */
+	shadowreg->start_point = (top << 16) | left;
+	/* resolution, src size */
+	shadowreg->src_size = (yres << 16) | xres;
+	/* resolution, dst size */
+	shadowreg->dst_size = (yres_z << 16) | xres_z;
+	/* pitch, pixels per line */
+	shadowreg->pitch[0] = pitch[0] & 0xFFFF;
+	shadowreg->pitch[1] = pitch[2] << 16 | pitch[1];
+
+	/* enable two-level zoom down if the ratio exceed 2 */
+	if (fbi->vid && xres_z && var->bits_per_pixel) {
+		int shift = (fbi->id == 1) ? 22 : 20;
+		u32 reg = (fbi->id == 2) ? LCD_PN2_LAYER_ALPHA_SEL1 :\
+			 LCD_AFA_ALL2ONE;
+
+		x = readl(fbi->reg_base + reg);
+		if (!(var->xres & 0x1) && ((var->xres >> 1) >= xres_z))
+			x |= 1 << shift;
+		else
+			x &= ~(1 << shift);
+		shadowreg->zoom = x;
+	}
+}
+
+int pxa168fb_set_var(struct fb_info *info, struct regshadow *shadowreg,
+		 u32 flags)
+{
+	struct pxa168fb_info *fbi = info->par;
+
+	/* Configure global panel parameters. */
+	if (flags & UPDATE_VIEW)
+		set_screen(fbi, shadowreg);
+	if (flags & UPDATE_MODE)
+		set_dma_control0(fbi, shadowreg);
+	/* buffer return to user in shadowreg_list->shadowreg */
+	set_start_address(info, info->var.xoffset,
+		info->var.yoffset, shadowreg);
+	shadowreg->flags = flags;
+	return 0;
+}
+
+void pxa168fb_set_regs(struct pxa168fb_info *fbi, struct regshadow *shadowreg)
+{
+	struct lcd_regs *regs = get_regs(fbi->id);
+
+	/* when lcd is suspend, read or write lcd controller's
+	* register is not effective, so just return*/
+	if (!(gfx_info.fbi[fbi->id]->active)) {
+		printk(KERN_DEBUG"LCD is not active, don't touch hardware\n");
+		return;
+	}
+
+	if (shadowreg->flags & UPDATE_ADDR) {
+		if (fbi->vid) {
+			writel(shadowreg->paddr0[0], &regs->v_y0);
+			writel(shadowreg->paddr0[1], &regs->v_u0);
+			writel(shadowreg->paddr0[2], &regs->v_v0);
+		} else
+			writel(shadowreg->paddr0[0], &regs->g_0);
+		shadowreg->flags &= ~UPDATE_ADDR;
+	}
+
+	if (shadowreg->flags & UPDATE_MODE) {
+		dma_ctrl_set(fbi->id, 0, dma_mask(fbi->vid),
+				 shadowreg->dma_ctrl0);
+		if (fbi->vid)
+			yuvsp_fmt_ctrl(yuvsp_mask(fbi->id),
+				shadowreg->yuv420sp_ctrl);
+		shadowreg->flags &= ~UPDATE_MODE;
+	}
+
+	if (shadowreg->flags & UPDATE_VIEW) {
+		if (fbi->vid) {
+			/* start address on screen */
+			writel(shadowreg->start_point, &regs->v_start);
+			/* pitch, pixels per line */
+			writel(shadowreg->pitch[0], &regs->v_pitch_yc);
+			writel(shadowreg->pitch[1], &regs->v_pitch_uv);
+			/* resolution, src size */
+			writel(shadowreg->src_size, &regs->v_size);
+			/* resolution, dst size */
+			writel(shadowreg->dst_size, &regs->v_size_z);
+
+			writel(shadowreg->zoom, fbi->reg_base +
+			 ((fbi->id == 2) ? (LCD_PN2_LAYER_ALPHA_SEL1) :
+			 (LCD_AFA_ALL2ONE)));
+		} else {
+			/* start address on screen */
+			writel(shadowreg->start_point, &regs->g_start);
+			/* pitch, pixels per line */
+			writel(shadowreg->pitch[0], &regs->g_pitch);
+			/* resolution, src size */
+			writel(shadowreg->src_size, &regs->g_size);
+			/* resolution, dst size */
+			writel(shadowreg->dst_size, &regs->g_size_z);
+		}
+		shadowreg->flags &= ~UPDATE_VIEW;
+	}
+
+	set_dma_active(fbi);
+	pxa168fb_misc_update(fbi);
+}
+
+irqreturn_t pxa168_fb_isr(int id)
+{
+	struct pxa168fb_info *fbi;
+	struct regshadow *shadowreg;
+	int vid;
+	struct timespec vsync_time;
+	unsigned long flags;
+
+	/* First do video layer update, then graphics layer */
+	for (vid = 1; vid >= 0; vid--) {
+		fbi = vid ? (ovly_info.fbi[id]) : (gfx_info.fbi[id]);
+		if (!fbi)
+			continue;
+
+		shadowreg = &fbi->shadowreg;
+		if (shadowreg && shadowreg->flags)
+			pxa168fb_set_regs(fbi, shadowreg);
+
+		if (atomic_read(&fbi->op_count)) {
+			spin_lock(&fbi->buf_lock);
+			/* do buffer switch for video flip */
+			buf_endframe(fbi);
+			spin_unlock(&fbi->buf_lock);
+		}
+
+		/* wake up queue, only use one queue for all layer */
+		if (atomic_read(&fbi->w_intr) == 0) {
+			atomic_set(&fbi->w_intr, 1);
+			wake_up_all(&gfx_info.fbi[0]->w_intr_wq);
+		}
+
+		/* wake up queue, for some operations which must be done
+		 * after vsync happen, so it should be done by sequence */
+		if (atomic_read(&fbi->w_intr1) == 0) {
+			atomic_set(&fbi->w_intr1, 1);
+			spin_lock_irqsave(&fbi->job_lock, flags);
+			if (todo_job) {
+				switch(todo_job->type) {
+					case VSYNC_DSI_SEND_COMMAND :
+						{
+							int loop;
+							struct VSYNC_DSI_TX_CMD_DATA *txcmd_data = (struct VSYNC_DSI_TX_CMD_DATA *)todo_job->data;
+							for(loop = 0; loop < txcmd_data->count; loop++) {
+									dsi_send_prepared_cmd_tx(txcmd_data->fbi,
+											txcmd_data->cmds[loop],
+											txcmd_data->buffer+DSI_MAX_DATA_BYTES*loop,
+											txcmd_data->packet_len[loop]);
+							}
+						}
+						break;
+					case VSYNC_DSI_READ_COMMAND :
+						break;
+					case VSYNC_DSI_LANE_RESET :
+						reset_lanes(fbi);
+						break;
+					default :
+						break;
+				}
+				todo_job = NULL;
+			}
+			spin_unlock_irqrestore(&fbi->job_lock, flags);
+			wake_up(&gfx_info.fbi[0]->w_intr_wq1);
+		}
+		atomic_set(&fbi->vsync_cnt, 2);
+
+		if (fbi->vsync_en) {
+			/* Get time stamp of vsync */
+			ktime_get_ts(&vsync_time);
+			fbi->vsync_ts_nano = ((uint64_t)vsync_time.tv_sec)
+				* 1000 * 1000 * 1000 +
+				((uint64_t)vsync_time.tv_nsec);
+			/* notify sysfs in work queue */
+			queue_work(fbi->workqueue, &fbi->vsync_work);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+/*****************************************************************************/
+static int pxa168fb_regs_dump(int id, char *buf)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	struct lcd_regs *regs = get_regs(id);
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "register base: 0x%p\n", fbi->reg_base);
+	mvdisp_dump(f, "  video layer\n");
+	mvdisp_dump(f, "\tv_y0        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_y0) & 0xfff, readl(&regs->v_y0));
+	mvdisp_dump(f, "\tv_u0        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_u0) & 0xfff, readl(&regs->v_u0));
+	mvdisp_dump(f, "\tv_v0        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_v0) & 0xfff, readl(&regs->v_v0));
+	mvdisp_dump(f, "\tv_c0        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_c0) & 0xfff, readl(&regs->v_c0));
+	mvdisp_dump(f, "\tv_y1        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_y1) & 0xfff, readl(&regs->v_y1));
+	mvdisp_dump(f, "\tv_u1        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_u1) & 0xfff, readl(&regs->v_u1));
+	mvdisp_dump(f, "\tv_v1        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_v1) & 0xfff, readl(&regs->v_v1));
+	mvdisp_dump(f, "\tv_c1        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_c1) & 0xfff, readl(&regs->v_c1));
+	mvdisp_dump(f, "\tv_pitch_yc  ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_pitch_yc) & 0xfff, readl(&regs->v_pitch_yc));
+	mvdisp_dump(f, "\tv_pitch_uv  ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_pitch_uv) & 0xfff, readl(&regs->v_pitch_uv));
+	mvdisp_dump(f, "\tv_start     ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_start) & 0xfff, readl(&regs->v_start));
+	mvdisp_dump(f, "\tv_size      ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_size) & 0xfff, readl(&regs->v_size));
+	mvdisp_dump(f, "\tv_size_z    ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_size_z) & 0xfff, readl(&regs->v_size_z));
+
+	mvdisp_dump(f, "  graphic layer\n");
+	mvdisp_dump(f, "\tg_0         ( @%3x ) 0x%x\n",
+		(int)(&regs->g_0) & 0xfff, readl(&regs->g_0));
+	mvdisp_dump(f, "\tg_1         ( @%3x ) 0x%x\n",
+		(int)(&regs->g_1) & 0xfff, readl(&regs->g_1));
+	mvdisp_dump(f, "\tg_pitch     ( @%3x ) 0x%x\n",
+		(int)(&regs->g_pitch) & 0xfff, readl(&regs->g_pitch));
+	mvdisp_dump(f, "\tg_start     ( @%3x ) 0x%x\n",
+		(int)(&regs->g_start) & 0xfff, readl(&regs->g_start));
+	mvdisp_dump(f, "\tg_size      ( @%3x ) 0x%x\n",
+		(int)(&regs->g_size) & 0xfff, readl(&regs->g_size));
+	mvdisp_dump(f, "\tg_size_z    ( @%3x ) 0x%x\n",
+		(int)(&regs->g_size_z) & 0xfff, readl(&regs->g_size_z));
+
+	mvdisp_dump(f, "  hardware cursor\n");
+	mvdisp_dump(f, "\thc_start    ( @%3x ) 0x%x\n",
+		(int)(&regs->hc_start) & 0xfff, readl(&regs->hc_start));
+	mvdisp_dump(f, "\thc_size     ( @%3x ) 0x%x\n",
+		(int)(&regs->hc_size) & 0xfff, readl(&regs->hc_size));
+
+	mvdisp_dump(f, "  screen\n");
+	mvdisp_dump(f, "\tscreen_size     ( @%3x ) 0x%x\n",
+		(int)(&regs->screen_size) & 0xfff,
+		 readl(&regs->screen_size));
+	mvdisp_dump(f, "\tscreen_active   ( @%3x ) 0x%x\n",
+		(int)(&regs->screen_active) & 0xfff,
+		 readl(&regs->screen_active));
+	mvdisp_dump(f, "\tscreen_h_porch  ( @%3x ) 0x%x\n",
+		(int)(&regs->screen_h_porch) & 0xfff,
+		 readl(&regs->screen_h_porch));
+	mvdisp_dump(f, "\tscreen_v_porch  ( @%3x ) 0x%x\n",
+		(int)(&regs->screen_v_porch) & 0xfff,
+		 readl(&regs->screen_v_porch));
+
+	mvdisp_dump(f, "  color\n");
+	mvdisp_dump(f, "\tblank_color     ( @%3x ) 0x%x\n",
+		 (int)(&regs->blank_color) & 0xfff,
+		 readl(&regs->blank_color));
+	mvdisp_dump(f, "\thc_Alpha_color1 ( @%3x ) 0x%x\n",
+		 (int)(&regs->hc_Alpha_color1) & 0xfff,
+		 readl(&regs->hc_Alpha_color1));
+	mvdisp_dump(f, "\thc_Alpha_color2 ( @%3x ) 0x%x\n",
+		 (int)(&regs->hc_Alpha_color2) & 0xfff,
+		 readl(&regs->hc_Alpha_color2));
+	mvdisp_dump(f, "\tv_colorkey_y    ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_colorkey_y) & 0xfff,
+		 readl(&regs->v_colorkey_y));
+	mvdisp_dump(f, "\tv_colorkey_u    ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_colorkey_u) & 0xfff,
+		 readl(&regs->v_colorkey_u));
+	mvdisp_dump(f, "\tv_colorkey_v    ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_colorkey_v) & 0xfff,
+		 readl(&regs->v_colorkey_v));
+
+	mvdisp_dump(f, "  control\n");
+	mvdisp_dump(f, "\tvsync_ctrl      ( @%3x ) 0x%x\n",
+		 (int)(&regs->vsync_ctrl) & 0xfff,
+		 readl(&regs->vsync_ctrl));
+	mvdisp_dump(f, "\tdma_ctrl0       ( @%3x ) 0x%x\n",
+		 (int)(dma_ctrl(0, id)) & 0xfff,
+		 readl(fbi->reg_base + dma_ctrl0(id)));
+	mvdisp_dump(f, "\tdma_ctrl1       ( @%3x ) 0x%x\n",
+		 (int)(dma_ctrl(1, id)) & 0xfff,
+		 readl(fbi->reg_base + dma_ctrl1(id)));
+	mvdisp_dump(f, "\tintf_ctrl       ( @%3x ) 0x%x\n",
+		 (int)(intf_ctrl(id)) & 0xfff,
+		 readl(fbi->reg_base + intf_ctrl(id)));
+	mvdisp_dump(f, "\tirq_enable      ( @%3x ) 0x%8x\n",
+		 (int)(SPU_IRQ_ENA) & 0xfff,
+		 readl(fbi->reg_base + SPU_IRQ_ENA));
+	mvdisp_dump(f, "\tirq_status      ( @%3x ) 0x%8x\n",
+		 (int)(SPU_IRQ_ISR) & 0xfff,
+		 readl(fbi->reg_base + SPU_IRQ_ISR));
+	mvdisp_dump(f, "\tclk_sclk        ( @%3x ) 0x%x\n",
+		 (int)(clk_reg(id, clk_sclk)) & 0xfff,
+		 readl(clk_reg(id, clk_sclk)));
+	if (clk_reg(id, clk_tclk))
+		mvdisp_dump(f, "\tclk_tclk        ( @%3x ) 0x%x\n",
+			(int)(clk_reg(id, clk_tclk)) & 0xfff,
+			readl(clk_reg(id, clk_tclk)));
+	mvdisp_dump(f, "\tclk_lvds        ( @%3x ) 0x%x\n",
+		 (int)(clk_reg(id, clk_lvds_rd)) & 0xfff,
+		 readl(clk_reg(id, clk_lvds_rd)));
+
+	/* TV path registers */
+	if (id == 1) {
+		mvdisp_dump(f, "\ntv path interlace related:\n");
+		mvdisp_dump(f, "\tv_h_total         ( @%3x ) 0x%8x\n",
+			(int)(LCD_TV_V_H_TOTAL_FLD) & 0xfff,
+			readl(fbi->reg_base + LCD_TV_V_H_TOTAL_FLD));
+		mvdisp_dump(f, "\tv_porch           ( @%3x ) 0x%8x\n",
+			(int)(LCD_TV_V_PORCH_FLD) & 0xfff,
+			readl(fbi->reg_base + LCD_TV_V_PORCH_FLD));
+		mvdisp_dump(f, "\tvsync_ctrl        ( @%3x ) 0x%8x\n",
+			(int)(LCD_TV_SEPXLCNT_FLD) & 0xfff,
+			readl(fbi->reg_base + LCD_TV_SEPXLCNT_FLD));
+	}
+
+	mvdisp_dump(f, "\n");
+	return s;
+}
+
+/************************************************************************/
+static size_t lcd_help(char *buf)
+{
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "commands:\n");
+	mvdisp_dump(f, " - dump path(pn/tv/pn2:0/1/2) registers, var info\n");
+	mvdisp_dump(f, "\tcat lcd\n");
+	mvdisp_dump(f, " - dump all display controller registers\n");
+	mvdisp_dump(f, "\techo l > /proc/pxa168fb\n");
+	mvdisp_dump(f, " - dump register @ [offset_hex]\n");
+	mvdisp_dump(f, "\techo -0x[offset_hex] > lcd\n");
+	mvdisp_dump(f, " - set register @ [offset_hex] with [value_hex]\n");
+	mvdisp_dump(f, "\techo 0x[value_hex] > lcd\n");
+	mvdisp_dump(f, " - count path(pn/tv/pn2:[0/1/2]) interrupts"
+			" within 10s\n");
+	mvdisp_dump(f, "\techo v[path:0/1/2] > lcd\n");
+	mvdisp_dump(f, " - enable[1]/disable[0] error interrupts dump"
+			" (underflow/axi error) at run time\n");
+	mvdisp_dump(f, "\techo e[en/dis:1/0] > lcd\n");
+	mvdisp_dump(f, " - enable[1]/disable[0] flip/free buffers info"
+			" dump (print level KERN_DEBUG)\n");
+	mvdisp_dump(f, "\techo d[en/dis:1/0] > lcd\n");
+
+	return s;
+}
+
+static ssize_t lcd_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	struct fb_var_screeninfo *var = &fbi->fb_info->var;
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "path %d:\n\tactive %d, dma_on %d\n",
+		fbi->id, fbi->active, fbi->dma_on);
+	if (!fbi->vid)
+		mvdisp_dump(f, "\tpath frm time %luus\n", fbi->frm_usec);
+	if (fbi->clk)
+		mvdisp_dump(f, "\tclk_src %luMhz\n",
+			clk_get_rate(fbi->clk)/1000000);
+	if (fbi->path_clk)
+		mvdisp_dump(f, "\tpath_clk_src %luMhz\n",
+			clk_get_rate(fbi->path_clk)/1000000);
+	if (fbi->phy_clk)
+		mvdisp_dump(f, "\tphy_clk_src %luMhz\n",
+			clk_get_rate(fbi->phy_clk)/1000000);
+	mvdisp_dump(f, "\tgfx_udflow %d, vid_udflow %d, axi_err %d\n",
+		gfx_udflow_count, vid_udflow_count, axi_err_count);
+	mvdisp_dump(f, "\tirq_retry_count %d\n", irq_retry_count);
+	mvdisp_dump(f, "\tdebug %d, DBG_VSYNC_PATH %d, DBG_ERR_IRQ %d\n",
+		fbi->debug, DBG_VSYNC_PATH, DBG_ERR_IRQ);
+
+	mvdisp_dump(f, "var info:\n");
+	mvdisp_dump(f, "\txres              %4d yres              %4d\n",
+		var->xres, var->yres);
+	mvdisp_dump(f, "\txres_virtual      %4d yres_virtual      %4d\n",
+		var->xres_virtual, var->yres_virtual);
+	mvdisp_dump(f, "\txoffset           %4d yoffset           %4d\n",
+		var->xoffset, var->yoffset);
+	mvdisp_dump(f, "\tleft_margin(hbp)  %4d right_margin(hfp) %4d\n",
+		var->left_margin, var->right_margin);
+	mvdisp_dump(f, "\tupper_margin(vbp) %4d lower_margin(vfp) %4d\n",
+		var->upper_margin, var->lower_margin);
+	mvdisp_dump(f, "\thsync_len         %4d vsync_len         %4d\n",
+		var->hsync_len,	var->vsync_len);
+	mvdisp_dump(f, "\tbits_per_pixel    %d\n", var->bits_per_pixel);
+	mvdisp_dump(f, "\tpixclock          %d\n", var->pixclock);
+	mvdisp_dump(f, "\tsync              0x%x\n", var->sync);
+	mvdisp_dump(f, "\tvmode             0x%x\n", var->vmode);
+	mvdisp_dump(f, "\trotate            0x%x\n\n", var->rotate);
+
+	s += pxa168fb_regs_dump(fbi->id, buf + s);
+#ifdef CONFIG_PXA688_MISC
+	if (fbi->id == fb_vsmooth) {
+		mvdisp_dump(f, "=== vertical smooth path %d by filter %d==\n",
+			fb_vsmooth, fb_filter);
+		s += pxa168fb_regs_dump(fb_filter, buf + s);
+	}
+#endif
+
+	s += lcd_help(buf + s);
+
+	return s;
+}
+
+static u32 mvdisp_reg;
+static ssize_t lcd_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	u32 addr = (u32)fbi->reg_base, i, tmp;
+	char vol[30];
+	struct clk *lcdclk;
+
+	if (size > 30) {
+		pr_err("%s size = %d > max 30 chars\n", __func__, size);
+		return size;
+	}else if ('c' == buf[0]) {
+		pr_info("\ndisplay controller regs\n");
+		memcpy(vol, buf+1, size-1);
+		lcdclk = clk_get(NULL, "LCDCLK");
+		if ((int) simple_strtoul(vol, NULL, 16) != 0)
+		{
+			printk("enable lcdclk\n");
+			lcdclk->ops->enable(lcdclk);
+		}
+		else
+		{
+			printk("disable lcdclk\n");
+			lcdclk->ops->disable(lcdclk);
+		}
+		return size;
+	}
+
+	if ('d' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		fbi->debug = (int) simple_strtoul(vol, NULL, 10);
+		/* fbi->debug usage:
+		 *	1: show flip/get freelist sequence
+		 */
+		return size;
+	} else if ('e' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		tmp = (int) simple_strtoul(vol, NULL, 10) << DBG_ERR_SHIFT;
+		if (tmp != DBG_ERR_IRQ) {
+			debug_flag &= ~DBG_ERR_MASK; debug_flag |= tmp;
+		}
+		return size;
+	} else if ('v' == buf[0]) {
+		if (size > 2) {
+			memcpy(vol, (void *)((u32)buf + 1), size - 1);
+			tmp = (int) simple_strtoul(vol, NULL, 10) << DBG_VSYNC_SHIFT;
+		} else
+			tmp = fbi->id;
+		if (tmp != DBG_VSYNC_PATH) {
+			debug_flag &= ~DBG_VSYNC_MASK; debug_flag |= tmp;
+		}
+		vsync_check_count();
+		return size;
+	} else if ('-' == buf[0]) {
+		memcpy(vol, buf+1, size-1);
+		mvdisp_reg = (int) simple_strtoul(vol, NULL, 16);
+		pr_info("reg @ 0x%x: 0x%x\n", mvdisp_reg,
+			__raw_readl(addr + mvdisp_reg));
+		return size;
+	} else if ('0' == buf[0] && 'x' == buf[1]) {
+		/* set the register value */
+		tmp = (int)simple_strtoul(buf, NULL, 16);
+		__raw_writel(tmp, addr + mvdisp_reg);
+		pr_info("set reg @ 0x%x: 0x%x\n", mvdisp_reg,
+			__raw_readl(addr + mvdisp_reg));
+		return size;
+	} else if ('l' == buf[0]) {
+		pr_info("\ndisplay controller regs\n");
+		for (i = 0; i < 0x300; i += 4) {
+			if (!(i % 16))
+				printk("\n0x%3x: ", i);
+			printk(" %8x", __raw_readl(addr + i));
+		}
+		pr_info("\n");
+		return size;
+	}
+
+	return size;
+}
+
+DEVICE_ATTR(lcd, S_IRUGO | S_IWUSR, lcd_show, lcd_store);
+
+#ifdef CONFIG_DISP_DFC
+atomic_t disp_dfc = ATOMIC_INIT(0);
+atomic_t disp_pll3 = ATOMIC_INIT(0);
+atomic_t disp_pll1 = ATOMIC_INIT(0);
+#define ROUND_RATE_RANGE_MHZ 	2  /* unit: MHz */
+#define DFC_RETRY_TIMEOUT 	60
+#define MHZ_TO_HZ 		1000000
+
+enum {
+	PLL1_416 = 0,
+	PLL1_624,
+	PLL3,
+};
+
+static void recalculate_disp_clk(struct pxa168fb_info *fbi,
+				 u32 divider, u32 *reg_val)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	u32  bclk_div, pclk_div, ratio;
+
+	ratio = ((di->lanes > 2) ? 4 : 8);
+	*reg_val = lcd_clk_get(fbi->id, clk_sclk);
+	*reg_val &= ~(SCLK_SOURCE_SELECT_MASK |
+		 DSI1_BITCLK_DIV_MASK |
+		 CLK_INT_DIV_MASK);
+	bclk_div = divider;
+	pclk_div = divider * ratio;
+	*reg_val |= DSI1_BITCLK_DIV(bclk_div) | CLK_INT_DIV(pclk_div);
+}
+
+/*
+ * trigger display dynamic frequency change, retry DFC_RETRY_TIMEOUT times,
+ * if still failed, then give up this dfc.
+ */
+static int disp_dfc_commit(struct pxa168fb_info *fbi, struct clk *best_parent,
+			   int *timeout)
+{
+	int ret = 0, count = 0;
+	unsigned long flags;
+
+	atomic_set(&disp_dfc, 1);
+	do {
+		wait_for_vsync(fbi, SYNC_SELF);
+		count++;
+	} while (atomic_read(&disp_dfc) && (count < DFC_RETRY_TIMEOUT));
+
+	spin_lock_irqsave(&fbi->dfc_lock, flags);
+	if (unlikely(count == DFC_RETRY_TIMEOUT) && atomic_read(&disp_dfc)) {
+		ret = -EINVAL;
+		atomic_set(&disp_dfc, 0);
+	}
+	spin_unlock_irqrestore(&fbi->dfc_lock, flags);
+
+	if (!ret) {
+		clk_reparent(fbi->phy_clk->parent->parent, best_parent);
+		clk_reparent(fbi->path_clk->parent->parent, best_parent);
+	}
+
+	*timeout = count;
+	return ret;
+}
+
+static int disp_sclk_switch_to_pll1(struct pxa168fb_info *fbi, u32 pll1,
+				    u32 divider, int *timeout)
+{
+	int ret = 0;
+	unsigned int reg_val = 0;
+	struct clk *best_parent = NULL, *pll3_clk = NULL;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+
+	mi->sclk_rst = __raw_readl((void __iomem *)APMU_LCD);
+	mi->sclk_rst &= ~(1 << 9);
+	switch (pll1) {
+	case PLL1_624:
+		best_parent = clk_get(NULL, "pll1_624");
+		mi->sclk_rst &= ~(1 << 6);
+		break;
+	case PLL1_416:
+	default:
+		best_parent = clk_get(NULL, "pll1_416");
+		mi->sclk_rst |= 1 << 6;
+		break;
+	}
+
+	recalculate_disp_clk(fbi, divider, &reg_val);
+	mi->sclk_div = reg_val | SCLK_SOURCE_SELECT(1);
+
+	/* trigger display frequency change*/
+	atomic_set(&disp_pll1, 1);
+	ret = disp_dfc_commit(fbi, best_parent, timeout);
+	if (!ret) {
+		atomic_set(&disp_pll1, 0);
+		if(atomic_read(&disp_pll3)) {
+			atomic_set(&disp_pll3, 0);
+			pll3_clk = clk_get(NULL, "pll3");
+			clk_disable(pll3_clk);
+			/* restore pll3 to default rate */
+			dynamic_change_pll3(0);
+		}
+		pr_info("%s: %s, divider %u\n", __func__,
+			pll1 ? "624":"416", divider);
+	}
+	return ret;
+}
+
+static int disp_sclk_pll3_to_pll1(struct pxa168fb_info *fbi, u32 rate,
+				  int *timeout)
+{
+	unsigned long parent_rate, now,bestl = 0, besth = ULONG_MAX;
+	unsigned int bestdivl = 0, bestdivh = 0, div = 0;
+	unsigned int parent_selh = 0, parent_sell = 0, parent_sel = 0;
+	unsigned int i, j, maxdiv = 15;
+	u32 pll1_op_table[2] = {416, 624};
+	int ret = 0;
+
+	for (i = 0; i < 2; i++) {
+		parent_rate = pll1_op_table[i];
+		for (j = 1; j <= maxdiv; j++) {
+			now = parent_rate / j;
+			/* condition to select a best closest rate >= rate */
+			if (now >= rate && now < besth) {
+				bestdivh = j;
+				besth = now;
+				parent_selh = i;
+			/* condition to select a best closest rate <= rate */
+			} else if (now <= rate && now > bestl) {
+				bestdivl = j;
+				bestl = now;
+				parent_sell = i;
+			}
+		}
+	}
+
+	now = ((besth - rate) <= (rate - bestl)) ? besth : bestl;
+	if (now == besth) {
+		div = bestdivh;
+		parent_sel = parent_selh;
+	} else {
+		div = bestdivl;
+		parent_sel = parent_sell;
+	}
+
+	if (!div)
+		div = 1;
+
+	ret = disp_sclk_switch_to_pll1(fbi, parent_sel, div, timeout);
+
+	return ret;
+}
+
+static bool is_pll3_used_by_disp(int id)
+{
+	u32 reg_val;
+
+	reg_val = lcd_clk_get(id, clk_sclk);
+	/* if pll3 was currently used by disp, first change to pll1 */
+	if ((reg_val & SCLK_SOURCE_SELECT_MASK) == SCLK_SOURCE_DSI_PLL)
+		return true;
+	else
+		return false;
+}
+
+static int mmp_disp_dfc(struct pxa168fb_info *fbi, u32 rate)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct clk *pll3_clk = NULL, *best_parent = NULL;
+	u32 tmp, div, real_rate, i, j, reg_val;
+	u32 op_table[3] = {416, 624, 0};
+	static u32 old_rate = 1;
+	int ret = 0, count = 0;
+	bool pll3_to_pll3 = false;
+
+	if (!mi->no_legacy_clk) {
+		pr_err("legacy clock dfc not implemented now!\n");
+		return -EINVAL;
+	}
+	mutex_lock(&fbi->access_ok);
+	if (!fbi->active) {
+		pr_info("LCD enter suspend, don't do disp dfc\n");
+		mutex_unlock(&fbi->access_ok);
+		return -EINVAL;
+	}
+
+	if ((rate >= (old_rate - ROUND_RATE_RANGE_MHZ) &&
+	     rate <= (old_rate + ROUND_RATE_RANGE_MHZ)) || !rate) {
+		pr_err("new rate is %uMHz or around the old rate %uMHz\n",
+			rate, old_rate);
+		mutex_unlock(&fbi->access_ok);
+		return -EINVAL;
+	}
+
+	/*
+	 * We are trying to restore disp freq to default, if current clk
+	 * src is pll1, first restore pll3 to default freq then do disp dfc.
+	 * If current clk src is pll3, pll3 will be restored after dfc.
+	 */
+	if ((rate == mi->sclk_default) && !atomic_read(&disp_pll3))
+		dynamic_change_pll3(0);
+
+	best_parent = pll3_clk = clk_get(NULL, "pll3");
+	/* pll3 frequency */
+	op_table[2] = clk_get_rate(best_parent) / MHZ_TO_HZ;
+
+	tmp = 0xff;
+	for (i = 0; i < ARRAY_SIZE(op_table); i++) {
+		for (j = 1; j < 15; j++) {
+			real_rate = op_table[i] / j;
+			if (rate > real_rate + ROUND_RATE_RANGE_MHZ)
+				break;
+			else if ((rate <= (real_rate + ROUND_RATE_RANGE_MHZ)) &&
+				 (rate >= (real_rate - ROUND_RATE_RANGE_MHZ))) {
+				/* round clock rate in 1MHz range */
+				tmp = real_rate;
+				break;
+			}
+		}
+
+		if (tmp != 0xff)
+			break;
+	}
+#if 0
+	/* can't find a suitable clock source */
+	if (tmp == 0xff)
+		i = 0xff;
+#endif
+
+	switch (i) {
+	case PLL1_416:
+	case PLL1_624:
+		ret = disp_sclk_switch_to_pll1(fbi, i, j, &count);
+		break;
+	case PLL3:
+		if(is_pll3_used_by_disp(fbi->id))
+			pll3_to_pll3 = true;
+		else
+			pll3_to_pll3= false;
+
+		recalculate_disp_clk(fbi, j, &reg_val);
+		mi->sclk_div = reg_val | SCLK_SOURCE_SELECT(3);
+		clk_enable(pll3_clk);
+		atomic_set(&disp_pll3, 1);
+
+		ret = disp_dfc_commit(fbi, best_parent, &count);
+		if (ret) {
+			/* if disp dfc failed, disable pll3 */
+			clk_disable(pll3_clk);
+			/* previous sclk is pll1, restore pll3 to default rate */
+			if (!pll3_to_pll3) {
+				atomic_set(&disp_pll3, 0);
+				dynamic_change_pll3(0);
+			}
+		} else if (atomic_read(&disp_pll1))
+			atomic_set(&disp_pll1, 0);
+		break;
+	default:
+		/* need to dynamic change pll3, firt ensure no one use pll3 */
+		reg_val = lcd_clk_get(fbi->id, clk_sclk);
+		/* if pll3 was currently used by disp, first change to pll1 */
+		if ((reg_val & SCLK_SOURCE_SELECT_MASK) ==
+		    SCLK_SOURCE_DSI_PLL) {
+			div = (reg_val & DSI1_BITCLK_DIV_MASK) >> 8;
+			old_rate = clk_get_rate(pll3_clk) / div / MHZ_TO_HZ;
+			ret = disp_sclk_pll3_to_pll1(fbi, old_rate, &count);
+		}
+		if (ret)
+			goto out;
+
+		/* then re-configure the pll3 clock */
+		dynamic_change_pll3(rate);
+		clk_enable(pll3_clk);
+		/* round off the divider */
+		div = (clk_get_rate(pll3_clk) / MHZ_TO_HZ+ rate / 2) / rate;
+		recalculate_disp_clk(fbi, div, &reg_val);
+		mi->sclk_div = reg_val | SCLK_SOURCE_SELECT(3);
+		atomic_set(&disp_pll3, 1);
+		/* switch disp sclk from pll1 to pll3 */
+		ret = disp_dfc_commit(fbi, best_parent, &count);
+		if (ret) {
+			/* if disp dfc failed, disable pll3 */
+			atomic_set(&disp_pll3, 0);
+			clk_disable(pll3_clk);
+			/* restore pll3 to default rate */
+			dynamic_change_pll3(0);
+		} else if (atomic_read(&disp_pll1))
+			atomic_set(&disp_pll1, 0);
+
+		real_rate = clk_get_rate(pll3_clk) / div / MHZ_TO_HZ;
+		break;
+	}
+out:
+	if (!ret) {
+		old_rate = real_rate;
+
+		pr_info("disp_dfc was done in %d vblank time, new rate %uMHz,"
+			 " clk_src pll%d %luMHz, sclk div 0x%x, rst 0x%x\n",
+			 count, real_rate, (u32)(atomic_read(&disp_pll3) ? 3 : 1),
+			 clk_get_rate(best_parent) / MHZ_TO_HZ,
+			 mi->sclk_div, mi->sclk_rst);
+	} else {
+		pr_err("disp dfc from %dMHz to %dMHz failed for %d times\n",
+			old_rate, rate, DFC_RETRY_TIMEOUT);
+	}
+
+	mutex_unlock(&fbi->access_ok);
+	return ret;
+}
+
+static ssize_t lcd_freq_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	u32 pixel_clk, phy_clk;
+	int s = 0;
+
+	mutex_lock(&fbi->access_ok);
+	if (mi->no_legacy_clk) {
+		if (mi->phy_type & (DSI | DSI2DPI | LVDS)) {
+			phy_clk = clk_get_rate(fbi->phy_clk);
+			pixel_clk = phy_clk * di->lanes / di->bpp;
+			s += sprintf(buf, "real path clock %uMhz,"
+				" phy clock %uMhz, pixclock %uMhz\n",
+				(u32) (clk_get_rate(fbi->path_clk) / MHZ_TO_HZ),
+				(phy_clk / MHZ_TO_HZ), pixel_clk / MHZ_TO_HZ);
+		} else {
+			pixel_clk = clk_get_rate(fbi->path_clk);
+			s += sprintf(buf, "real path clock %uMhz\n",
+				 pixel_clk / MHZ_TO_HZ);
+		}
+	} else
+		s += sprintf(buf, "legacy:real path clock %uMhz\n",
+			(u32) clk_get_rate(fbi->clk) / MHZ_TO_HZ);
+	mutex_unlock(&fbi->access_ok);
+	return s;
+}
+static ssize_t lcd_freq_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	u32 rate;
+
+	rate = (int)simple_strtoul(buf, NULL, 10);
+	mmp_disp_dfc(fbi, rate);
+	return size;
+}
+
+DEVICE_ATTR(freq, S_IRUGO | S_IWUSR, lcd_freq_show, lcd_freq_store);
+
+#endif
diff --git a/drivers/video/pxa168fb_common.h b/drivers/video/pxa168fb_common.h
new file mode 100644
index 00000000..a244239c
--- /dev/null
+++ b/drivers/video/pxa168fb_common.h
@@ -0,0 +1,100 @@
+#ifndef _PXA168FB_COMMON_
+#define _PXA168FB_COMMON_
+
+#include <mach/pxa168fb.h>
+#include "pxa168fb.h"
+
+#define RESET_BUF	0x1
+#define FREE_ENTRY	0x2
+
+#define DBG_VSYNC_SHIFT	(0)
+#define DBG_VSYNC_MASK	(0x3 << DBG_VSYNC_SHIFT)
+#define DBG_VSYNC_PATH	((debug_flag & DBG_VSYNC_MASK) >> DBG_VSYNC_SHIFT)
+#define DBG_ERR_SHIFT	(2)
+#define DBG_ERR_MASK	(0x1 << DBG_ERR_SHIFT)
+#define DBG_ERR_IRQ	((debug_flag & DBG_ERR_MASK) >> DBG_ERR_SHIFT)
+#define DBG_IRQ_PATH	(debug_flag & DBG_VSYNC_MASK)
+
+#if defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+#define NEED_VSYNC(fbi)	(fbi->wait_vsync)
+#else
+#define NEED_VSYNC(fbi)	(fbi->wait_vsync && dispd_dma_enabled(fbi))
+#endif
+
+#define DUMP_SPRINTF	(1 << 0)
+#define DUMP_PRINFO	(1 << 1)
+#define mvdisp_dump(flag, fmt, ...)	do {			\
+	if (flag & DUMP_SPRINTF)				\
+		s += sprintf(buf + s, fmt, ##__VA_ARGS__);	\
+	if (flag & DUMP_PRINFO)					\
+		pr_info(fmt, ##__VA_ARGS__);			\
+} while (0)
+
+extern int fb_share;
+extern int gfx_udflow_count;
+extern int vid_udflow_count;
+extern int irq_retry_count;
+extern int axi_err_count;
+extern int debug_flag;
+extern struct fbi_info gfx_info;
+extern struct fbi_info ovly_info;
+extern struct device_attribute dev_attr_lcd;
+extern struct device_attribute dev_attr_phy;
+extern struct device_attribute dev_attr_vdma;
+extern struct device_attribute dev_attr_freq;
+
+#ifdef CONFIG_LCD_MDNIE_ENABLE
+extern struct device_attribute dev_attr_tuning;
+extern struct device_attribute dev_attr_scenario;
+#endif
+extern u32 clk_reg(int id, u32 type);
+extern void vsync_check_count(void);
+extern int unsupport_format(struct pxa168fb_info *fbi,
+	 struct _sViewPortInfo viewPortInfo, FBVideoMode videoMode);
+extern int convert_pix_fmt(u32 vmode);
+extern int set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt);
+extern int determine_best_pix_fmt(struct fb_var_screeninfo *var,
+	struct pxa168fb_info *fbi);
+extern int pxa168fb_check_var(struct fb_var_screeninfo *var,
+	 struct fb_info *fi);
+extern int check_surface(struct fb_info *fi, struct _sOvlySurface *surface);
+extern int check_surface_addr(struct fb_info *fi,
+	 struct _sOvlySurface *surface);
+extern int check_modex_active(struct pxa168fb_info *fbi);
+extern void *pxa168fb_alloc_framebuffer(size_t size, dma_addr_t *dma);
+extern void pxa168fb_free_framebuffer(size_t size, void *vaddr,
+		dma_addr_t *dma);
+
+extern void buf_endframe(void *point);
+extern void clear_buffer(struct pxa168fb_info *fbi);
+extern void pxa168fb_list_init(struct pxa168fb_info *fbi);
+extern int flip_buffer(struct fb_info *info, unsigned long arg);
+extern int flip_buffer_vsync(struct fb_info *info, unsigned long arg);
+extern int get_freelist(struct fb_info *info, unsigned long arg);
+
+extern void set_dma_active(struct pxa168fb_info *fbi);
+extern int dispd_dma_enabled(struct pxa168fb_info *fbi);
+extern void wait_for_vsync(struct pxa168fb_info *fbi, unsigned char param);
+extern void pxa168fb_misc_update(struct pxa168fb_info *fbi);
+extern void set_start_address(struct fb_info *info, int xoffset,
+		 int yoffset, struct regshadow *shadowreg);
+extern void set_dma_control0(struct pxa168fb_info *fbi,
+		 struct regshadow *shadowreg);
+extern void set_screen(struct pxa168fb_info *fbi, struct regshadow *shadowreg);
+extern int pxa168fb_set_var(struct fb_info *info,
+		 struct regshadow *shadowreg, u32 flags);
+extern void pxa168fb_set_regs(struct pxa168fb_info *fbi,
+		 struct regshadow *shadowreg);
+extern irqreturn_t pxa168_fb_isr(int id);
+extern irqreturn_t mmp_v4l2_isr(int id);
+
+#ifdef CONFIG_EOF_FC_WORKAROUND
+extern atomic_t displayon;
+extern atomic_t ddr_fc_trigger;
+extern int wakeup_ddr_fc_seq(void);
+#endif
+
+#ifdef CONFIG_VIDEO_MVISP
+extern void isp_reset_clock(void);
+#endif
+#endif
diff --git a/drivers/video/pxa168fb_ovly.c b/drivers/video/pxa168fb_ovly.c
new file mode 100644
index 00000000..7652689b
--- /dev/null
+++ b/drivers/video/pxa168fb_ovly.c
@@ -0,0 +1,1174 @@
+/*
+ * linux/drivers/video/pxa168fb_ovly.c -- Marvell PXA168 LCD Controller
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * 2009-03-19   adapted from original version for PXA168
+ *		Green Wan <gwan@marvell.com>
+ *		Kevin Liu <kliu5@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+/*
+ * 1. Adapted from:  linux/drivers/video/skeletonfb.c
+ * 2. Merged from: linux/drivers/video/dovefb.c (Lennert Buytenhek)
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/cpufreq.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/uaccess.h>
+#include <linux/console.h>
+#include <linux/timer.h>
+
+#include "pxa168fb_common.h"
+
+#ifdef OVLY_DVFM_CONSTRAINT
+static int dvfm_dev_idx;
+#include <mach/dvfm.h>
+#endif
+
+#define RESET_BUF	0x1
+#define FREE_ENTRY	0x2
+
+static int pxa168fb_set_par(struct fb_info *fi);
+static int pxa168fb_pan_display(struct fb_var_screeninfo *var,
+				 struct fb_info *fi);
+
+static unsigned int max_fb_size = 0;
+static unsigned int fb_size_from_cmd = 0;
+static struct _sOvlySurface gOvlySurface;
+
+#define xp		pr_info("%s, line %d\n", __func__, __LINE__)
+struct fbi_info ovly_info;
+
+#ifdef FB_PM_DEBUG
+static unsigned int g_regs[1024];
+static unsigned int g_regs1[1024];
+static unsigned int pxa168fb_rw_all_regs(struct pxa168fb_info *fbi,
+		unsigned int *regs, int is_read)
+{
+	u32 i;
+	u32 reg;
+
+	for (i = 0xC0; i <= 0x01C4; i += 4) {
+		if (is_read) {
+			reg = readl(fbi->reg_base + i);
+			regs[i] = reg;
+		} else {
+			writel(regs[i], fbi->reg_base + i);
+		}
+	}
+
+	return 0;
+}
+#endif
+
+#if 0
+static struct fb_videomode *
+find_best_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct fb_videomode *best_mode;
+	int i;
+
+	dev_dbg(fbi->fb_info->dev, "Enter %s\n", __func__);
+	best_mode = NULL;
+	for (i = 0; i < mi->num_modes; i++) {
+		struct fb_videomode *m = mi->modes + i;
+
+		/*
+		 * Check whether this mode is suitable.
+		 */
+		if (var->xres > m->xres)
+			continue;
+		if (var->yres > m->yres)
+			continue;
+
+		/*
+		 * Check whether this mode is more suitable than
+		 * the best mode so far.
+		 */
+		if (best_mode != NULL &&
+		    (best_mode->xres < m->xres ||
+		     best_mode->yres < m->yres ||
+		     best_mode->pixclock > m->pixclock))
+			continue;
+
+		best_mode = m;
+	}
+
+	return best_mode;
+}
+#endif
+
+static u32 pxa168fb_ovly_set_colorkeyalpha(struct pxa168fb_info *fbi)
+{
+	struct _sColorKeyNAlpha color_a = fbi->ckey_alpha;
+	unsigned int rb, x, layer, dma0, shift, r, b;
+	struct pxa168fb_mach_info *mi;
+	struct lcd_regs *regs;
+
+	dev_dbg(fbi->fb_info->dev, "Enter %s\n", __func__);
+
+	mi = fbi->dev->platform_data;
+	regs = get_regs(fbi->id);
+	dma0 = dma_ctrl_read(fbi->id, 0);
+	shift = fbi->id ? 20 : 18;
+	rb = layer = 0;
+	r = color_a.Y_ColorAlpha;
+	b = color_a.V_ColorAlpha;
+
+	/* reset to 0x0 to disable color key. */
+	x = dma_ctrl_read(fbi->id, 1) & ~(CFG_COLOR_KEY_MASK |
+			CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK);
+
+	/* switch to color key mode */
+	switch (color_a.mode) {
+	case FB_DISABLE_COLORKEY_MODE:
+		/* do nothing */
+		break;
+	case FB_ENABLE_Y_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x1);
+		break;
+	case FB_ENABLE_U_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x2);
+		break;
+	case FB_ENABLE_V_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x4);
+		pr_info("V colorkey not supported, Chroma key instead\n");
+		break;
+	case FB_ENABLE_RGB_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x3);
+		rb = 1;
+		break;
+	case FB_ENABLE_R_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x1);
+		rb = 1;
+		break;
+	case FB_ENABLE_G_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x6);
+		pr_info("G colorkey not supported, Luma key instead\n");
+		break;
+	case FB_ENABLE_B_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x7);
+		rb = 1;
+		break;
+	default:
+		pr_info("unknown mode");
+		return -1;
+	}
+
+
+	/* switch to alpha path selection */
+	switch (color_a.alphapath) {
+	case FB_VID_PATH_ALPHA:
+		x |= CFG_ALPHA_MODE(0x0);
+		layer = CFG_CKEY_DMA;
+		if (rb)
+			rb = ((dma0 & CFG_DMA_SWAPRB_MASK) >> 4) ^
+				(mi->panel_rbswap);
+		break;
+	case FB_GRA_PATH_ALPHA:
+		x |= CFG_ALPHA_MODE(0x1);
+		layer = CFG_CKEY_GRA;
+		if (rb)
+			rb = ((dma0 & CFG_GRA_SWAPRB_MASK) >> 12) ^
+				(mi->panel_rbswap);
+		break;
+	case FB_CONFIG_ALPHA:
+		x |= CFG_ALPHA_MODE(0x2);
+		rb = 0;
+		break;
+	default:
+		pr_info("unknown alpha path");
+		return -1;
+	}
+
+	/* check whether DMA turn on RB swap for this pixelformat. */
+	if (rb) {
+		if (color_a.mode == FB_ENABLE_R_COLORKEY_MODE) {
+			x &= ~CFG_COLOR_KEY_MODE(0x1);
+			x |= CFG_COLOR_KEY_MODE(0x7);
+		}
+
+		if (color_a.mode == FB_ENABLE_B_COLORKEY_MODE) {
+			x &= ~CFG_COLOR_KEY_MODE(0x7);
+			x |= CFG_COLOR_KEY_MODE(0x1);
+		}
+
+		/* exchange r b fields. */
+		r = color_a.V_ColorAlpha;
+		b = color_a.Y_ColorAlpha;
+
+		/* only alpha_Y take effect, switch back from V */
+		if (color_a.mode == FB_ENABLE_RGB_COLORKEY_MODE) {
+			r &= 0xffffff00;
+			r |= (color_a.Y_ColorAlpha & 0xff);
+		}
+	}
+
+	/* configure alpha */
+	x |= CFG_ALPHA((color_a.config & 0xff));
+	dma_ctrl_write(fbi->id, 1, x);
+	writel(r, &regs->v_colorkey_y);
+	writel(color_a.U_ColorAlpha, &regs->v_colorkey_u);
+	writel(b, &regs->v_colorkey_v);
+
+	if (fbi->id != 2) {
+		/* enable DMA colorkey on graphics/video layer
+		 * in panel/TV path */
+		x = readl(fbi->reg_base + LCD_TV_CTRL1);
+		x &= ~(3<<shift); x |= layer<<shift;
+		writel(x, fbi->reg_base + LCD_TV_CTRL1);
+	}
+
+	return 0;
+}
+
+static void pxa168fb_clear_framebuffer(struct fb_info *fi)
+{
+	struct pxa168fb_info *fbi = fi->par;
+
+	memset(fbi->fb_start, 0, fbi->fb_size);
+}
+
+#ifdef CONFIG_DYNAMIC_PRINTK_DEBUG
+static void debug_identify_called_ioctl(struct fb_info *fi, int cmd,
+	 unsigned long arg)
+{
+	switch (cmd) {
+	case FB_IOCTL_CLEAR_FRAMEBUFFER:
+		dev_dbg(fi->dev, "FB_IOCTL_CLEAR_FRAMEBUFFER\n");
+		break;
+	case FB_IOCTL_WAIT_VSYNC:
+		dev_dbg(fi->dev, "FB_IOCTL_WAIT_VSYNC\n");
+		break;
+	case FB_IOCTL_GET_VIEWPORT_INFO:
+		dev_dbg(fi->dev, "FB_IOCTL_GET_VIEWPORT_INFO with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_SET_VIEWPORT_INFO:
+		dev_dbg(fi->dev, "FB_IOCTL_SET_VIEWPORT_INFO with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_SET_VIDEO_MODE:
+		dev_dbg(fi->dev, "FB_IOCTL_SET_VIDEO_MODE with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_GET_VIDEO_MODE:
+		dev_dbg(fi->dev, "FB_IOCTL_GET_VIDEO_MODE with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_FLIP_VID_BUFFER:
+		dev_dbg(fi->dev, "FB_IOCTL_FLIP_VID_BUFFER with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_FLIP_VSYNC:
+		dev_dbg(fi->dev, "FB_IOCTL_FLIP_VSYNC with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_GET_FREELIST:
+		dev_dbg(fi->dev, "FB_IOCTL_GET_FREELIST with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_GET_BUFF_ADDR:
+		dev_dbg(fi->dev, "FB_IOCTL_GET_BUFF_ADDR with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_SET_VID_OFFSET:
+		dev_dbg(fi->dev, "FB_IOCTL_SET_VID_OFFSET with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_GET_VID_OFFSET:
+		dev_dbg(fi->dev, "FB_IOCTL_GET_VID_OFFSET with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_SET_MEMORY_TOGGLE:
+		dev_dbg(fi->dev, "FB_IOCTL_SET_MEMORY_TOGGLE with arg =\
+			 %08x\n", (unsigned int) arg);
+		break;
+	case FB_IOCTL_SET_COLORKEYnALPHA:
+		dev_dbg(fi->dev, "FB_IOCTL_SET_COLORKEYnALPHA with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_GET_CHROMAKEYS:
+		dev_dbg(fi->dev, "FB_IOCTL_GET_CHROMAKEYS with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_PUT_CHROMAKEYS:
+		dev_dbg(fi->dev, "FB_IOCTL_PUT_CHROMAKEYS with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_GET_COLORKEYnALPHA:
+		dev_dbg(fi->dev, "FB_IOCTL_GET_COLORKEYnALPHA with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_SWITCH_VID_OVLY:
+		dev_dbg(fi->dev, "FB_IOCTL_SWITCH_VID_OVLY with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_SWAP_VIDEO_RED_BLUE:
+		dev_dbg(fi->dev, "FB_IOCTL_PUT_SWAP_VIDEO_RED_BLUE with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_SWAP_VIDEO_U_V:
+		dev_dbg(fi->dev, "FB_IOCTL_PUT_SWAP_VIDEO_U_V with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_SWAP_VIDEO_Y_UV:
+		dev_dbg(fi->dev, "FB_IOCTL_PUT_SWAP_VIDEO_Y_UV with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_PUT_VIDEO_ALPHABLEND:
+		dev_dbg(fi->dev, "FB_IOCTL_PUT_VIDEO_ALPHABLEND with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_PUT_GLOBAL_ALPHABLEND:
+		dev_dbg(fi->dev, "FB_IOCTL_PUT_GLOBAL_ALPHABLEND with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_PUT_GRAPHIC_ALPHABLEND:
+		dev_dbg(fi->dev, "FB_IOCTL_PUT_GRAPHIC_ALPHABLEND with arg =\
+			 %08x\n", (unsigned int)arg);
+		break;
+
+	}
+}
+#endif
+
+static int pxa168fb_ovly_ioctl(struct fb_info *fi, unsigned int cmd,
+			unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)fi->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	int vid_on = 1;
+	int val = 0, mask = 0;
+	unsigned char param;
+	int blendval = 0;
+	int res, tmp;
+	int ret = 0;
+	unsigned long flags;
+
+#ifdef CONFIG_DYNAMIC_PRINTK_DEBUG
+	debug_identify_called_ioctl(fi, cmd, arg);
+#endif
+
+	switch (cmd) {
+	case FB_IOCTL_CLEAR_FRAMEBUFFER:
+		if (!mi->mmap)
+			return -EINVAL;
+		pxa168fb_clear_framebuffer(fi);
+		return 0;
+		break;
+	case FB_IOCTL_WAIT_VSYNC:
+		param = (arg & 0x3);
+		wait_for_vsync(fbi, param);
+		break;
+	case FB_IOCTL_GET_VIEWPORT_INFO:/*if rotate 90/270, w/h swap*/
+		mutex_lock(&fbi->access_ok);
+		if (fbi->surface.viewPortInfo.rotation == 90 ||
+			fbi->surface.viewPortInfo.rotation == 270) {
+			tmp = fbi->surface.viewPortInfo.srcWidth;
+			fbi->surface.viewPortInfo.srcWidth =
+			fbi->surface.viewPortInfo.srcHeight;
+			fbi->surface.viewPortInfo.srcHeight = tmp;
+			fbi->surface.viewPortInfo.rotation = 360 -
+			fbi->surface.viewPortInfo.rotation;
+		}
+		res = copy_to_user(argp, &fbi->surface.viewPortInfo,
+			sizeof(struct _sViewPortInfo)) ? -EFAULT : 0;
+		if (fbi->surface.viewPortInfo.rotation == 90 ||
+			fbi->surface.viewPortInfo.rotation == 270) {
+			tmp = fbi->surface.viewPortInfo.srcWidth;
+			fbi->surface.viewPortInfo.srcWidth =
+			fbi->surface.viewPortInfo.srcHeight;
+			fbi->surface.viewPortInfo.srcHeight = tmp;
+			fbi->surface.viewPortInfo.rotation = 360 -
+			fbi->surface.viewPortInfo.rotation;
+		}
+		mutex_unlock(&fbi->access_ok);
+		return res;
+	case FB_IOCTL_SET_VIEWPORT_INFO:/*if rotate 90/270, w/h swap*/
+		mutex_lock(&fbi->access_ok);
+		memset(&gOvlySurface, 0, sizeof(gOvlySurface));
+		gOvlySurface.videoMode = -1;
+		if (copy_from_user(&gOvlySurface.viewPortInfo, argp,
+				sizeof(gOvlySurface.viewPortInfo))) {
+			mutex_unlock(&fbi->access_ok);
+			return -EFAULT;
+		}
+		if (unsupport_format(fbi, gOvlySurface.viewPortInfo, -1)) {
+			mutex_unlock(&fbi->access_ok);
+			return -EFAULT;
+		}
+		gOvlySurface.viewPortInfo.rotation =
+		 (360 - gOvlySurface.viewPortInfo.rotation) % 360;
+		if (gOvlySurface.viewPortInfo.rotation == 90 ||
+			gOvlySurface.viewPortInfo.rotation == 270) {
+			tmp = gOvlySurface.viewPortInfo.srcWidth;
+			gOvlySurface.viewPortInfo.srcWidth =
+			gOvlySurface.viewPortInfo.srcHeight;
+			gOvlySurface.viewPortInfo.srcHeight = tmp;
+		}
+
+		ret = check_surface(fi, &gOvlySurface);
+		if (ret > 0) {
+			pxa168fb_set_par(fi);
+			ret = 0;
+		} else if (ret < 0) {
+			pr_err("fbi %d (line %d): vid %d, check surface"
+				"return error\n", fbi->id, __LINE__, fbi->vid);
+			ret = -EFAULT;
+		}
+		mutex_unlock(&fbi->access_ok);
+		return ret;
+		break;
+	case FB_IOCTL_SET_VIDEO_MODE:
+		/*
+		 * Get data from user space.
+		 */
+		memset(&gOvlySurface, 0, sizeof(gOvlySurface));
+		if (copy_from_user(&gOvlySurface.videoMode, argp,
+				 sizeof(gOvlySurface.videoMode)))
+			return -EFAULT;
+
+		if (unsupport_format(fbi, gOvlySurface.viewPortInfo,
+			 gOvlySurface.videoMode))
+			return -EFAULT;
+		ret = check_surface(fi, &gOvlySurface);
+		if (ret > 0) {
+			pxa168fb_set_par(fi);
+			ret = 0;
+		} else if (ret < 0) {
+			pr_err("fbi %d (line %d): vid %d, check surface"
+				"return error\n", fbi->id, __LINE__, fbi->vid);
+			ret = -EFAULT;
+		}
+		return ret;
+		break;
+	case FB_IOCTL_GET_VIDEO_MODE:
+		return copy_to_user(argp, &fbi->surface.videoMode,
+			sizeof(u32)) ? -EFAULT : 0;
+	case FB_IOCTL_FLIP_VID_BUFFER:
+		return flip_buffer(fi, arg);
+	case FB_IOCTL_GET_FREELIST:
+		return get_freelist(fi, arg);
+	case FB_IOCTL_FLIP_VSYNC:
+		return flip_buffer_vsync(fi, arg);
+	case FB_IOCTL_GET_BUFF_ADDR:
+	{
+		return copy_to_user(argp, &fbi->surface.videoBufferAddr,
+			sizeof(struct _sVideoBufferAddr)) ? -EFAULT : 0;
+	}
+	case FB_IOCTL_SET_VID_OFFSET:
+		mutex_lock(&fbi->access_ok);
+		memset(&gOvlySurface, 0, sizeof(gOvlySurface));
+		gOvlySurface.videoMode = -1;
+		if (copy_from_user(&gOvlySurface.viewPortOffset, argp,
+				sizeof(gOvlySurface.viewPortOffset))) {
+			mutex_unlock(&fbi->access_ok);
+			return -EFAULT;
+		}
+
+		ret = check_surface(fi, &gOvlySurface);
+		if (ret > 0) {
+			pxa168fb_set_par(fi);
+			ret = 0;
+		} else if (ret < 0) {
+			pr_err("fbi %d (line %d): vid %d, check surface"
+				"return error\n", fbi->id, __LINE__, fbi->vid);
+			ret = -EFAULT;
+		}
+		mutex_unlock(&fbi->access_ok);
+		return ret;
+		break;
+	case FB_IOCTL_GET_VID_OFFSET:
+		return copy_to_user(argp, &fbi->surface.viewPortOffset,
+			sizeof(struct _sViewPortOffset)) ? -EFAULT : 0;
+
+	case FB_IOCTL_SET_SURFACE:
+	{
+		mutex_lock(&fbi->access_ok);
+		/* Get user-mode data. */
+		if (copy_from_user(&fbi->surface_bak, argp,
+					sizeof(struct _sOvlySurface))) {
+			mutex_unlock(&fbi->access_ok);
+			return -EFAULT;
+		}
+		fbi->surface_set = 1;
+
+		mutex_unlock(&fbi->access_ok);
+		return 0;
+	}
+	case FB_IOCTL_GET_SURFACE:
+	{
+		mutex_lock(&fbi->access_ok);
+		if (fbi->surface_set) {
+			ret = copy_to_user(argp, &fbi->surface_bak,
+				sizeof(struct _sOvlySurface));
+		} else {
+		    ret = copy_to_user(argp, &fbi->surface,
+				sizeof(struct _sOvlySurface));
+		}
+
+		ret = (ret ? -EFAULT : 0);
+		mutex_unlock(&fbi->access_ok);
+		return ret;
+	}
+
+	case FB_IOCTL_SET_COLORKEYnALPHA:
+		if (copy_from_user(&fbi->ckey_alpha, argp,
+		    sizeof(struct _sColorKeyNAlpha)))
+			return -EFAULT;
+
+		pxa168fb_ovly_set_colorkeyalpha(fbi);
+		break;
+
+	case FB_IOCTL_GET_COLORKEYnALPHA:
+		if (copy_to_user(argp, &fbi->ckey_alpha,
+		    sizeof(struct _sColorKeyNAlpha)))
+			return -EFAULT;
+		break;
+	case FB_IOCTL_SWITCH_VID_OVLY:
+		if (copy_from_user(&vid_on, argp, sizeof(int)))
+			return -EFAULT;
+		spin_lock_irqsave(&fbi->var_lock, flags);
+		mask = CFG_DMA_ENA_MASK;
+
+		fbi->dma_on = vid_on ? 1 : 0;
+		val = CFG_DMA_ENA(check_modex_active(fbi));
+		if (!val && gfx_info.fbi[0]->active) {
+			pxa688_vdma_release(fbi->id, fbi->vid);
+			/* switch off, disable DMA */
+			dma_ctrl_set(fbi->id, 0, mask, val);
+		} else if (list_empty(&fbi->buf_waitlist.dma_queue) &&
+			!fbi->buf_current)
+			/* switch on, but no buf flipped, return error */
+			; /* ret = -EAGAIN; */
+
+		printk(KERN_DEBUG "SWITCH_VID_OVLY fbi %d dma_on %d,"
+			" val %d, waitlist empty %d buf_current %p, ret %d\n",
+			fbi->id, fbi->dma_on, val,
+			list_empty(&fbi->buf_waitlist.dma_queue),
+			fbi->buf_current, ret);
+
+		pxa688fb_vsmooth_set(fbi->id, 1, vid_vsmooth & vid_on);
+
+		spin_unlock_irqrestore(&fbi->var_lock, flags);
+		return ret;
+		break;
+
+	case FB_IOCTL_SWAP_VIDEO_RED_BLUE:
+		param = (arg & 0x1);
+		dma_ctrl_set(fbi->id, 0, CFG_DMA_SWAPRB_MASK,
+				 CFG_DMA_SWAPRB(param));
+		return 0;
+		break;
+
+	case FB_IOCTL_SWAP_VIDEO_U_V:
+		param = (arg & 0x1);
+		dma_ctrl_set(fbi->id, 0, CFG_DMA_SWAPUV_MASK,
+				 CFG_DMA_SWAPUV(param));
+		return 0;
+		break;
+
+	case FB_IOCTL_SWAP_VIDEO_Y_UV:
+		param = (arg & 0x1);
+		dma_ctrl_set(fbi->id, 0, CFG_DMA_SWAPYU_MASK,
+				 CFG_DMA_SWAPYU(param));
+		return 0;
+		break;
+
+	case FB_IOCTL_PUT_VIDEO_ALPHABLEND:
+		/*
+		 *  This puts the blending control to the Video layer.
+		 */
+		mask = CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK;
+		val = CFG_ALPHA_MODE(0) | CFG_ALPHA(0xff);
+		dma_ctrl_set(fbi->id, 1, mask, val);
+		return 0;
+		break;
+
+	case FB_IOCTL_PUT_GLOBAL_ALPHABLEND:
+		/*
+		 *  The userspace application can specify a byte value for the
+		 *  amount of global blend between the video layer and thei
+		 *  graphic layer.
+		 *
+		 *  The alpha blending is per the formula below:
+		 *  P = (V[P] * blendval/255) + (G[P] * (1 - blendval/255))
+		 *  where: P = Pixel value, V = Video Layer,
+		 *  and G = Graphic Layer
+		 */
+		blendval = (arg & 0xff);
+		mask = CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK;
+		val = CFG_ALPHA_MODE(2) | CFG_ALPHA(blendval);
+		dma_ctrl_set(fbi->id, 1, mask, val);
+		return 0;
+		break;
+
+	case FB_IOCTL_PUT_GRAPHIC_ALPHABLEND:
+		/*
+		 *  This puts the blending back to the default mode of allowing
+		 *  the graphic layer to do pixel level blending.
+		 */
+		mask = CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK;
+		val = CFG_ALPHA_MODE(1) | CFG_ALPHA(0x0);
+		dma_ctrl_set(fbi->id, 1, mask, val);
+		return 0;
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int pxa168fb_open(struct fb_info *fi, int user)
+{
+	struct pxa168fb_mach_info *mi;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+	struct _sVideoBufferAddr *new_addr = &fbi->surface.videoBufferAddr;
+
+	pr_info("%s Video layer, fbi %d opened %d times ----\n",
+		__func__, fbi->id, atomic_read(&fbi->op_count));
+
+#ifdef OVLY_DVFM_CONSTRAINT
+	dvfm_disable_lowpower(dvfm_dev_idx);
+#endif
+
+	mi = fbi->dev->platform_data;
+	memset(new_addr, 0, sizeof(struct _sVideoBufferAddr));
+	fi->fix.smem_start = fbi->fb_start_dma;
+	fi->screen_base = fbi->fb_start;
+	fbi->surface.videoMode = -1;
+	fbi->surface.viewPortInfo.srcWidth = var->xres;
+	fbi->surface.viewPortInfo.srcHeight = var->yres;
+
+	fbi->active = 1;
+	set_pix_fmt(var, fbi->pix_fmt);
+
+	if (mutex_is_locked(&fbi->access_ok))
+		mutex_unlock(&fbi->access_ok);
+
+	/* clear buffer list. */
+	clear_buffer(fbi);
+
+	/* increase open count */
+	atomic_inc(&fbi->op_count);
+
+	return 0;
+}
+
+extern void enable_graphic_layer(int id);
+
+static int pxa168fb_release(struct fb_info *fi, int user)
+{
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+	u32 mask;
+
+	pr_info("%s Video layer, fbi %d opened %d times ----\n",
+		__func__, fbi->id, atomic_read(&fbi->op_count));
+
+	/* Force Video DMA engine off at release and reset the DMA format.*/
+	if (atomic_dec_and_test(&fbi->op_count)) {
+		pxa688_vdma_release(fbi->id, fbi->vid);
+		mask = CFG_DMA_ENA_MASK | CFG_DMAFORMAT_MASK;
+		dma_ctrl_set(fbi->id, 0, mask, 0);
+		pxa688fb_vsmooth_set(fbi->id, 1, 0);
+	}
+
+	/* Turn off compatibility mode */
+	var->nonstd &= ~0xff000000;
+	fbi->compat_mode = 0;
+
+	/* make sure graphics layer is enabled */
+	enable_graphic_layer(fbi->id);
+
+	/* clear buffer list. */
+	clear_buffer(fbi);
+
+	/* clear some globals */
+	memset(&fbi->surface, 0, sizeof(struct _sOvlySurface));
+	fbi->surface.videoMode = -1;
+	fbi->active = fbi->dma_on = 0;
+
+#ifdef OVLY_DVFM_CONSTRAINT
+	dvfm_enable_lowpower(dvfm_dev_idx);
+#endif
+
+	return 0;
+}
+
+static void set_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var,
+		     struct fb_videomode *mode, int pix_fmt, int ystretch)
+{
+	dev_dbg(fbi->fb_info->dev, "Enter %s\n", __func__);
+	set_pix_fmt(var, pix_fmt);
+
+	var->xres = mode->xres;
+	var->yres = mode->yres;
+	var->xres_virtual = max(var->xres, var->xres_virtual);
+	if (ystretch)
+		var->yres_virtual = var->yres * ((ystretch > 1) ? ystretch : 2);
+	else
+		var->yres_virtual = max(var->yres, var->yres_virtual);
+
+	var->grayscale = 0;
+	var->accel_flags = FB_ACCEL_NONE;
+	var->pixclock = mode->pixclock;
+	var->left_margin = mode->left_margin;
+	var->right_margin = mode->right_margin;
+	var->upper_margin = mode->upper_margin;
+	var->lower_margin = mode->lower_margin;
+	var->hsync_len = mode->hsync_len;
+	var->vsync_len = mode->vsync_len;
+	var->sync = mode->sync;
+	var->vmode = FB_VMODE_NONINTERLACED;
+	var->rotate = FB_ROTATE_UR;
+}
+
+static int pxa168fb_set_par(struct fb_info *fi)
+{
+	struct pxa168fb_info *fbi = fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+	struct regshadow *shadowreg = &fbi->shadowreg;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	int pix_fmt;
+	u32 flags;
+
+	dev_dbg(fi->dev, "Enter %s, video layer\n", __func__);
+	/*
+	 * Determine which pixel format we're going to use.
+	 */
+	pix_fmt = determine_best_pix_fmt(var, fbi);
+	if (pix_fmt < 0)
+		return pix_fmt;
+	fbi->pix_fmt = pix_fmt;
+	set_pix_fmt(var, pix_fmt);
+
+	if (!var->xres_virtual)
+		var->xres_virtual = var->xres;
+	if (!var->yres_virtual)
+		var->yres_virtual = var->yres *
+			((mi->mmap > 1) ? mi->mmap : 2);
+	var->grayscale = 0;
+	var->accel_flags = FB_ACCEL_NONE;
+	var->rotate = FB_ROTATE_UR;
+
+	/* Set additional mode info */
+	if (pix_fmt == PIX_FMT_PSEUDOCOLOR)
+		fi->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	else
+		fi->fix.visual = FB_VISUAL_TRUECOLOR;
+	fi->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
+
+	/* when lcd is suspend, read or write lcd controller's
+	* register is not effective, so just return*/
+	if (!(gfx_info.fbi[fbi->id]->active)) {
+		printk(KERN_DEBUG"LCD is not active, don't touch hardware\n");
+		return 0;
+	}
+
+	flags = UPDATE_ADDR | UPDATE_MODE | UPDATE_VIEW;
+	pxa168fb_set_var(fi, shadowreg, flags);
+
+	if (!NEED_VSYNC(fbi))
+		pxa168fb_set_regs(fbi, shadowreg);
+
+	return 0;
+}
+
+static unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
+{
+	return ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;
+}
+
+static u32 to_rgb(u16 red, u16 green, u16 blue)
+{
+	red >>= 8;
+	green >>= 8;
+	blue >>= 8;
+
+	return (red << 16) | (green << 8) | blue;
+}
+
+static int
+pxa168fb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,
+		 unsigned int blue, unsigned int trans, struct fb_info *fi)
+{
+	struct pxa168fb_info *fbi = fi->par;
+	u32 val;
+
+	if (fi->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16) {
+		val =  chan_to_field(red,   &fi->var.red);
+		val |= chan_to_field(green, &fi->var.green);
+		val |= chan_to_field(blue , &fi->var.blue);
+		fbi->pseudo_palette[regno] = val;
+	}
+
+	if (fi->fix.visual == FB_VISUAL_PSEUDOCOLOR && regno < 256) {
+		val = to_rgb(red, green, blue);
+		writel(val, fbi->reg_base + LCD_SPU_SRAM_WRDAT); /* FIXME */
+		writel(0x8300 | regno, fbi->reg_base + LCD_SPU_SRAM_CTRL);
+	}
+
+	return 0;
+}
+
+static int pxa168fb_pan_display(struct fb_var_screeninfo *var,
+				struct fb_info *fi)
+{
+	struct pxa168fb_info *fbi = fi->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+
+	if (!mi->mmap)
+		return -EINVAL;
+
+	fbi->active = 1;
+	set_start_address(fi, var->xoffset, var->yoffset, &fbi->shadowreg);
+	fbi->shadowreg.flags |= UPDATE_ADDR;
+	pxa168fb_set_regs(fbi, &fbi->shadowreg);
+
+	if (NEED_VSYNC(fbi))
+		wait_for_vsync(fbi, SYNC_SELF);
+
+	return 0;
+}
+
+static int pxa168fb_fb_sync(struct fb_info *info)
+{
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)info->par;
+
+	wait_for_vsync(fbi, SYNC_SELF);
+	return 0;
+}
+
+static struct fb_ops pxa168fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_open	= pxa168fb_open,
+	.fb_release	= pxa168fb_release,
+
+	.fb_check_var	= pxa168fb_check_var,
+	.fb_set_par	= pxa168fb_set_par,
+	.fb_setcolreg	= pxa168fb_setcolreg,
+	.fb_pan_display	= pxa168fb_pan_display,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_sync	= pxa168fb_fb_sync,
+	.fb_ioctl	= pxa168fb_ovly_ioctl,
+};
+
+static int __init get_ovly_size(char *str)
+{
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	max_fb_size = n;
+	fb_size_from_cmd = 1;
+	return 1;
+}
+__setup("ovly_size=", get_ovly_size);
+
+static int __devinit pxa168fb_probe(struct platform_device *pdev)
+{
+	struct pxa168fb_mach_info *mi;
+	struct fb_info *fi;
+	struct pxa168fb_info *fbi;
+	struct lcd_regs *regs;
+	struct resource *res;
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+	int ret;
+
+	mi = pdev->dev.platform_data;
+	if (mi == NULL)
+		return -EINVAL;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL)
+		return -EINVAL;
+
+	fi = framebuffer_alloc(sizeof(struct pxa168fb_info), &pdev->dev);
+	if (fi == NULL) {
+		pr_info("%s: no enough memory!\n", __func__);
+		return -ENOMEM;
+	}
+
+	fbi = fi->par;
+	fbi->id = pdev->id;
+	fbi->vid = 1;
+	if (!fbi->id)
+		memset(&ovly_info, 0, sizeof(ovly_info));
+	ovly_info.fbi[fbi->id] = fbi;
+
+	platform_set_drvdata(pdev, fbi);
+	fbi->fb_info = fi;
+	fbi->dev = &pdev->dev;
+	fbi->id = pdev->id;
+	fbi->fb_info->dev = &pdev->dev;
+	fbi->debug = 0;
+	init_waitqueue_head(&fbi->w_intr_wq);
+	mutex_init(&fbi->access_ok);
+	spin_lock_init(&fbi->buf_lock);
+	spin_lock_init(&fbi->var_lock);
+
+	/* FIXME - video layer has no specific clk. it depend on
+	 * graphic layer clk. fbi->clk = clk_get(&pdev->dev, NULL);
+	 */
+
+	/*
+	 * Initialise static fb parameters.
+	 */
+	fi->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK |
+		    FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
+	fi->node = -1;
+	strcpy(fi->fix.id, mi->id);
+	fi->fix.type = FB_TYPE_PACKED_PIXELS;
+	fi->fix.type_aux = 0;
+	fi->fix.xpanstep = 1;
+	fi->fix.ypanstep = 1;
+	fi->fix.ywrapstep = 0;
+	fi->fix.mmio_start = res->start;
+	fi->fix.mmio_len = resource_size(res);
+	fi->fix.accel = FB_ACCEL_NONE;
+	fi->fbops = &pxa168fb_ops;
+	fi->pseudo_palette = fbi->pseudo_palette;
+
+	/* Map LCD controller registers. */
+	fbi->reg_base = devm_ioremap_nocache(&pdev->dev, res->start,
+					     resource_size(res));
+
+	if (fbi->reg_base == NULL) {
+		pr_info("%s: no enough memory!\n", __func__);
+		ret = -ENOMEM;
+		goto failed;
+	}
+
+	if (mi->mmap) {
+		/*
+		 * Allocate framebuffer memory.
+		 */
+		if (!fb_size_from_cmd) {
+			if (mi->max_fb_size)
+				max_fb_size = mi->max_fb_size;
+			else
+				max_fb_size = DEFAULT_FB_SIZE;
+		}
+		max_fb_size = PAGE_ALIGN(max_fb_size);
+		fbi->fb_size = max_fb_size;
+
+		/*
+		 * FIXME, It may fail to alloc DMA buffer from dma_alloc_xxx
+		 */
+		fbi->fb_start = pxa168fb_alloc_framebuffer(fbi->fb_size,
+				&fbi->fb_start_dma);
+
+		if (fbi->fb_start == NULL) {
+			pr_info("%s: no enough memory!\n", __func__);
+			ret = -ENOMEM;
+			goto failed;
+		}
+		pr_info("---------FBoverlay DMA buffer phy addr : %x\n",
+			(unsigned int)fbi->fb_start_dma);
+
+		memset(fbi->fb_start, 0, fbi->fb_size);
+		fi->fix.smem_start = fbi->fb_start_dma;
+		fi->fix.smem_len = fbi->fb_size;
+		fi->screen_base = fbi->fb_start;
+		fi->screen_size = fbi->fb_size;
+		fbi->wait_vsync = 1;
+	}
+
+#ifdef FB_PM_DEBUG
+	pxa168fb_rw_all_regs(fbi, g_regs, 1);
+#endif
+
+	/* init vdma clock/sram, etc. */
+	lcd_vdma = request_vdma(fbi->id, fbi->vid);
+	if (lcd_vdma) {
+		lcd_vdma->dev = fbi->dev;
+		lcd_vdma->reg_base = fbi->reg_base;
+		pxa688_vdma_init(lcd_vdma);
+	} else
+		pr_warn("path %d layer %d: request vdma fail\n", fbi->id, fbi->vid);
+
+	/*
+	 * Fill in sane defaults.
+	 */
+	set_mode(fbi, &fi->var, mi->modes, mi->pix_fmt, mi->mmap);
+	pxa168fb_set_par(fi);
+
+	pxa168fb_list_init(fbi);
+
+	/*
+	 * Configure default register values.
+	 */
+	regs = get_regs(fbi->id);
+	writel(0, &regs->v_y1);
+	writel(0, &regs->v_u1);
+	writel(0, &regs->v_v1);
+	writel(0, &regs->v_start);
+
+	/* Set this frame off by default */
+	dma_ctrl_set(fbi->id, 0, CFG_DMA_ENA_MASK, 0);
+
+	/*
+	 * Allocate color map.
+	 */
+	if (fb_alloc_cmap(&fi->cmap, 256, 0) < 0) {
+		ret = -ENOMEM;
+		goto failed;
+	}
+
+	/*
+	 * Get IRQ number.
+	 */
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res == NULL)
+		return -EINVAL;
+
+	/*
+	 * Register framebuffer.
+	 */
+	ret = register_framebuffer(fi);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to register pxa168fb: %d\n", ret);
+		ret = -ENXIO;
+		goto failed;
+	}
+
+	pr_info("pxa168fb_ovly: frame buffer device was loaded"
+		" to /dev/fb%d <%s>.\n", fi->node, fi->fix.id);
+
+#ifdef OVLY_DVFM_CONSTRAINT
+	dvfm_register("overlay1", &dvfm_dev_idx);
+#endif
+
+#ifdef CONFIG_PXA688_VDMA
+	ret = device_create_file(&pdev->dev, &dev_attr_vdma);
+	if (ret < 0) {
+		pr_err("device attr create fail: %d\n", ret);
+		return ret;
+	}
+#endif
+
+	ret = device_create_file(&pdev->dev, &dev_attr_lcd);
+	if (ret < 0) {
+		pr_err("device attr create fail: %d\n", ret);
+		goto failed;
+	}
+
+	return 0;
+
+failed:
+	platform_set_drvdata(pdev, NULL);
+	fb_dealloc_cmap(&fi->cmap);
+	if (fbi->fb_start != NULL) {
+		pxa168fb_free_framebuffer(max_fb_size, fbi->fb_start,
+				&fbi->fb_start_dma);
+	}
+	if (fbi->reg_base != NULL)
+		iounmap(fbi->reg_base);
+	kfree(fbi);
+	framebuffer_release(fi);
+	return ret;
+}
+
+#ifdef CONFIG_PM
+#if 0
+static int pxa168fb_vid_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
+	struct fb_info *fi = fbi->fb_info;
+
+#ifdef FB_PM_DEBUG
+	pxa168fb_rw_all_regs(fbi, g_regs1, 1);
+#endif
+
+	if (mesg.event & PM_EVENT_SLEEP)
+		fb_set_suspend(fi, 1);
+	pdev->dev.power.power_state = mesg;
+
+#ifdef FB_PM_DEBUG
+	pxa168fb_rw_all_regs(fbi, g_regs, 0);
+#endif
+	pr_info("pxa168fb_ovly.%d suspended, state = %d.\n",
+		 fbi->id, mesg.event);
+
+	return 0;
+}
+
+static int pxa168fb_vid_resume(struct platform_device *pdev)
+{
+	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
+	struct fb_info *fi = fbi->fb_info;
+
+	fb_set_suspend(fi, 0);
+
+#ifdef FB_PM_DEBUG
+	{
+		u32 i;
+		u32 reg;
+
+		for (i = 0xC0; i <= 0x01C4; i += 4) {
+			reg = readl(fbi->reg_base + i);
+			if (reg != g_regs1[i])
+				pr_info("Register 0x%08x: 0x%08x - 0x%08x.\n",
+						i, g_regs1[i], reg);
+		}
+	}
+#endif
+
+	pr_info("pxa168fb_ovly.%d resumed.\n", fbi->id);
+
+	return 0;
+}
+#endif
+#endif
+
+
+static struct platform_driver pxa168fb_driver = {
+	.probe		= pxa168fb_probe,
+/*	.remove		= pxa168fb_remove,		*/
+#ifdef CONFIG_PM
+/*	.suspend	= pxa168fb_vid_suspend, */
+/*	.resume		= pxa168fb_vid_resume, */
+#endif
+	.driver		= {
+		.name	= "pxa168fb_ovly",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __devinit pxa168fb_init(void)
+{
+	return platform_driver_register(&pxa168fb_driver);
+}
+
+/*module_init(pxa168fb_init);*/
+late_initcall(pxa168fb_init);
+
+MODULE_DESCRIPTION("Framebuffer driver for PXA168");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/pxa688_misc.c b/drivers/video/pxa688_misc.c
new file mode 100644
index 00000000..a255e639
--- /dev/null
+++ b/drivers/video/pxa688_misc.c
@@ -0,0 +1,1064 @@
+/*
+ * linux/drivers/video/pxa688fb_misc.c -- Marvell PXA668 LCD Controller
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * 2011-05-25  Jing Xiang <jxiang@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include "pxa168fb_common.h"
+
+/* fb_vsmooth: the path that need to do smoothing. e.g. TV
+ * fb_filter: the path that used for smoothing. e.g. PN2
+ */
+int fb_vsmooth;
+int fb_filter;
+int gfx_vsmooth;
+int vid_vsmooth;
+
+static int debug;
+
+/* graphic layer partial display, color format should be RGB565 */
+int pxa688fb_partdisp_set(struct mvdisp_partdisp grap)
+{
+	struct pxa168fb_info *fbi;
+	struct fb_info *info;
+	struct fb_var_screeninfo *var;
+	struct lcd_regs *regs;
+	u32 xres, yres, yres_z, color3_0, color7_4, color11_8, color15_12;
+	u32 base, mask, gfx_fmt, bytespp, shift, offset, threshold, region, tmp;
+
+	if (grap.id < 0 || grap.id >= MAX_FB_INFO)
+		return -EINVAL;
+
+	fbi = gfx_info.fbi[grap.id];
+	info = fbi->fb_info;
+	var = &info->var;
+
+	gfx_fmt = (dma_ctrl_read(grap.id, 0) & (0xf << 16)) >> 16;
+	if (gfx_fmt == PIX_FMT_RGB565 || gfx_fmt == PIX_FMT_RGB1555 >> 1 ||
+		gfx_fmt == PIX_FMT_YUV422PACK >> 1)
+		bytespp = 16 >> 3;
+	else if (gfx_fmt == PIX_FMT_RGB888PACK >> 1)
+		bytespp = 24 >> 3;
+	else if (gfx_fmt == PIX_FMT_RGB888UNPACK >> 1 ||
+		gfx_fmt == PIX_FMT_RGBA888 >> 1)
+		bytespp = 32 >> 3;
+	else
+		return -EINVAL;
+
+	regs = get_regs(grap.id);
+	xres = readl(&regs->g_size) & 0xfff;
+	yres = (readl(&regs->g_size) & 0xfff0000) >> 16;
+	yres_z = (readl(&regs->g_size_z) & 0xfff0000) >> 16;
+
+	if (!yres)
+		return -EINVAL;
+
+	/* partial display region should be not larger than source size*/
+	if (grap.horpix_start > xres)
+		grap.horpix_start = xres;
+	if (grap.horpix_end > xres)
+		grap.horpix_end = xres;
+	if (grap.vertline_start > yres)
+		grap.vertline_start = yres;
+	if (grap.vertline_end > yres)
+		grap.vertline_end = yres;
+
+	if (grap.id == 1 &&
+		var->vmode & FB_VMODE_INTERLACED) {
+		/* tv interlace mode */
+		grap.vertline_start = grap.vertline_start >> 1;
+		grap.vertline_end = grap.vertline_end >> 1;
+	}
+
+	/* adjust vertical start/end lines according to zoom size */
+	grap.vertline_start = grap.vertline_start * yres_z / yres;
+	grap.vertline_end = grap.vertline_end * yres_z / yres;
+
+	/* adjust hortizontal start/end pixel number according to:
+	 * 1. start pixel number should be
+	 *    (DMA burst length / bytes per pixel) aligned.
+	 * 2. (end pixel number - start pixel number -
+	 *    path threshold / bytes per pixel) should be
+	 *    64 / bytes per pixel aligned.
+	 */
+	if (grap.horpix_end > grap.horpix_start) {
+		shift = (grap.id == 1 ? 14 : 10);
+		offset = (grap.id == 1 ? 16 : 1);
+
+		/* THRESHOLD_x: the least bytes to operate for
+		 * horizontal partial display
+		 */
+		threshold = (grap.id == 1 ? THRESHOLD_TV : THRESHOLD_PN);
+		base = (u32)fbi->reg_base +
+			(grap.id == 2 ? PN2_IOPAD_CONTROL : LCD_TOP_CTRL);
+		mask = readl(base) & (3 << shift);
+		mask = (((mask >> shift) + 1) << 6) / bytespp;
+
+		/* adjust horizontal start pixel number */
+		grap.horpix_start /= mask;
+		grap.horpix_start *= mask;
+
+		/* adjust horizontal end pixel number */
+		region = grap.horpix_end - grap.horpix_start;
+		if (region  > (threshold / bytespp)) {
+			region -= (threshold / bytespp);
+
+			/* BURST_LEN: AXI burst size, platform dependent */
+			if (region >= (BURST_LEN / bytespp)) {
+				tmp = region % (BURST_LEN / bytespp);
+				region /= (BURST_LEN / bytespp);
+				region *= (BURST_LEN / bytespp);
+				grap.horpix_end = grap.horpix_start + region +
+					threshold / bytespp;
+				if (grap.id == 1 && tmp >= (THRESHOLD_PN * 2 -
+					THRESHOLD_TV) / bytespp)
+					/* add extra 64 /bytespp for TV path*/
+					grap.horpix_end += (BURST_LEN / bytespp);
+			} else
+				grap.horpix_end = grap.horpix_start +
+					threshold / bytespp + offset;
+		} else
+			grap.horpix_end = grap.horpix_start;
+	}
+
+	color3_0 = grap.color & 0x000f;
+	color7_4 = (grap.color & 0x00f0) >> 4;
+	color11_8 = (grap.color & 0x0f00) >> 8;
+	color15_12 = (grap.color & 0xf000) >> 12;
+
+	/* horizontal register setting */
+	mask = grap.horpix_start | (color3_0 << 12)
+		| (grap.horpix_end << 16) | (color7_4 << 28);
+	writel(mask, (u32)fbi->reg_base + gra_partdisp_ctrl_hor(grap.id));
+	/* vertical register setting */
+	mask = grap.vertline_start	| (color11_8  << 12)
+		| (grap.vertline_end << 16) | (color15_12 << 28);
+	writel(mask, (u32)fbi->reg_base + gra_partdisp_ctrl_ver(grap.id));
+
+	return 0;
+}
+
+/* for partial display, only vertical lines need be updated
+ * when zoom size changed */
+void pxa688fb_partdisp_update(int id)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[id];
+	u32 base, mask, vertline_start, vertline_end,
+		screen_active, yres, yres_bak;
+	struct lcd_regs *regs;
+
+	regs = get_regs(fbi->id);
+	screen_active = readl(&regs->screen_active);
+	if (!fbi->scrn_act_bak)
+		fbi->scrn_act_bak = screen_active;
+	if (fbi->scrn_act_bak == screen_active)
+		/* no need to update partial display */
+		return;
+
+	base = (u32)fbi->reg_base;
+	mask = readl(base + gra_partdisp_ctrl_ver(id));
+
+	/* get original partial display vertical setting */
+	vertline_start = mask & 0xfff;
+	vertline_end = (mask & 0xfff0000) >> 16;
+
+	/* get original/new vertical lines */
+	yres_bak = (fbi->scrn_act_bak & 0x0fff0000) >> 16;
+	yres = (screen_active & 0x0fff0000) >> 16;
+
+	/* adjust partial display start/end vertical lines by
+	 * new / original ratio */
+	vertline_start = vertline_start * yres / yres_bak;
+	vertline_end = vertline_end * yres / yres_bak;
+
+	mask &= ~0xfff0fff;
+	mask |= vertline_start | (vertline_end << 16);
+	writel(mask, base + gra_partdisp_ctrl_ver(id));
+	fbi->scrn_act_bak = screen_active;
+}
+
+static int pxa688fb_map_layers(int src, int dst, int vid, int en)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 map = (u32)fbi->reg_base + LCD_IO_OVERL_MAP_CTRL;
+	u32 val = readl(map), shift;
+#ifdef CONFIG_PXA688_VDMA
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+	u32 vdma;
+#endif
+	/* map src path dma to dst */
+	switch (dst) {
+	case 0:
+		if (src == 2)
+			/* p2 -> pn */
+			shift = vid ? 6 : 7;
+		else if (src == 1) {
+			/* tv -> pn */
+			map = (u32)fbi->reg_base + LCD_TOP_CTRL;
+			val = readl(map);
+			shift = 22;
+			val &= ~(3 << shift);
+			if (en)
+				val |= 1 << shift;
+			goto top_ctrl;
+		} else
+			return -EINVAL;
+		break;
+	case 1:
+		if (src == 2)
+			/* p2 -> tv */
+			shift = vid ? 10 : 9;
+		else if (src == 0) {
+			/* pn -> tv */
+			map = (u32)fbi->reg_base + LCD_TOP_CTRL;
+			val = readl(map);
+			shift = 22;
+			val &= ~(3 << shift);
+			if (en)
+				val |= 2 << shift;
+			goto top_ctrl;
+		} else
+			return -EINVAL;
+		break;
+	case 2:
+		if (src == 1)
+			/* tv -> p2 */
+			shift = vid ? 3 : 4;
+		else if (src == 0)
+			/* pn -> p2 */
+			shift = vid ? 0 : 1;
+		else
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	if (en)
+		val |= 1 << shift;
+	else
+		val &= ~(1 << shift);
+top_ctrl:
+	writel(val, map);
+	if (debug)
+		pr_info("%s %d: src %d dst %d vid %d shift %d map(%x): 0x%x\n",
+			__func__, en, src, dst, vid, shift, map & 0xfff, val);
+
+
+#ifdef CONFIG_PXA688_VDMA
+	lcd_vdma = request_vdma(dst, vid);
+	if (lcd_vdma && lcd_vdma->enable) {
+		vdma = readl((u32)fbi->reg_base + LCD_PN2_SQULN2_CTRL);
+		switch (src) {
+		case 2:
+			/* vdma0-pn/vdma1-tv is used for p2 */
+			vdma &= ~(3 << 30);
+			if (en)
+				vdma |= 1 << (dst ? 31 : 30);
+			break;
+		case 1:
+		case 0:
+			/* FIXME */
+		default:
+			pr_info("%s src %d dst %d not supported yet\n",
+				__func__, src, dst);
+		return -EINVAL;
+		}
+		writel(vdma, (u32)fbi->reg_base + LCD_PN2_SQULN2_CTRL);
+		if (debug)
+			pr_info("vdma 0x%x\n", vdma);
+	}
+#endif
+
+
+	return 0;
+}
+
+static int pxa688fb_vsmooth_config(int filter, int dst, int vid, int en)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	int vsmooth = (u32)fbi->reg_base + LCD_AFA_ALL2ONE, shift, val, x;
+
+	switch (filter) {
+	case 0:
+		/* pn dma used as vertical filter channel */
+		shift = vid ? 16 : 18;
+		if (dst == 2) {
+			pr_err("%s (line %d) filter %d dst %d not supported\n",
+				__func__, __LINE__, filter, dst);
+			return -EINVAL;
+		} else
+			x = 3;
+		break;
+	case 1:
+		/* tv dma used as vertical filter channel */
+		shift = vid ? 16 : 18;
+		if (dst == 2) {
+			pr_err("%s (line %d) filter %d dst %d not supported\n",
+				__func__, __LINE__, filter, dst);
+			return -EINVAL;
+		} else
+			x = 2;
+		break;
+	case 2:
+		/* p2 dma used as vertical filter channel */
+		vsmooth = (u32)fbi->reg_base + LCD_PN2_LAYER_ALPHA_SEL1;
+		shift = vid ? 16 : 18;
+		x = dst ? 3 : 2;
+		break;
+	default:
+		pr_err("%s (line %d) filter %d dst %d not supported\n",
+			__func__, __LINE__, filter, dst);
+		return -EINVAL;
+	}
+	val = readl(vsmooth) & ~(3 << shift);
+	if (en)
+		val |= x << shift;
+	writel(val, vsmooth);
+	if (debug)
+		pr_info("%s filter %d en %d dst %d x %x shift %d"
+			" vsmooth(%x) 0x%x\n\n", __func__, filter,
+			en, dst, x, shift, vsmooth & 0xfff, val);
+	return 0;
+}
+
+static int pxa688_colorkey_get(int id, int vid)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 base = (u32)fbi->reg_base, tmp = dma_ctrl_read(1, 1), en = 0;
+
+	if (id == 0)
+		en = vid ? ((tmp & (1 << 18)) >> 18) :
+			((tmp & (1 << 19)) >> 19);
+	else if (id == 1)
+		en = vid ? ((tmp & (1 << 20)) >> 20) :
+			((tmp & (1 << 21)) >> 21);
+	else {
+		tmp = __raw_readl(base + PN2_IOPAD_CONTROL);
+		en = vid ? ((tmp & (1 << 5)) >> 5) :
+			((tmp & (1 << 4)) >> 4);
+	}
+
+	return en;
+}
+
+static void pxa688_colorkey_set(int id, int vid, int en)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 base = (u32)fbi->reg_base, mask;
+
+	if (id <= 1) {
+		mask = id ? (vid ? (en << 20) : (en << 21)) :
+			(vid ? (en << 18) : (en << 19));
+		dma_ctrl_set(1, 1, mask, mask);
+	} else {
+		mask = __raw_readl(base + PN2_IOPAD_CONTROL);
+		mask &= ~(vid ? (1 << 5) : (1 << 4));
+		mask |= vid ? (en << 5) : (en << 4);
+		__raw_writel(mask, base + PN2_IOPAD_CONTROL);
+	}
+}
+
+/* pxa688_clone_xxx(int src, int dst,..)
+ * These functions clone src path settings to dst path.
+ * e.g. if use PN2 path DMA to do TV path smoothing, so
+ * need to clone TV path settings to PN2.
+ */
+
+static int pxa688fb_clone_clk(int src, int dst)
+{
+	u32 mask = ~0;
+	/* video clk shift of register LCD_PN2_TCLK_DIV,
+	 * the shift is different according to MMP2/MMP3 spec,
+	 * default setting is specific for MMP2.
+	*/
+	u32 pn2_vid_shift = 30;
+	u32 pn2_gfx_shift = 2;
+
+	if (src == 1 || dst == 1)
+		/* TV path TCLK_DIV definitions different vs SCLK_DIV */
+		mask = 0xd000000f;
+	/* enable dst path clock */
+	if (dst == 2 && src <= 1) {
+		/* pn2 TCLK_DIV */
+		mask = src ? 2 : 1;
+#ifdef CONFIG_CPU_MMP3
+		pn2_vid_shift = 29;
+#endif
+		lcd_clk_set(dst, clk_tclk, (mask << pn2_vid_shift) | (mask << pn2_gfx_shift) | (mask),
+				(mask << pn2_vid_shift) | (mask << pn2_gfx_shift) | (mask));
+	} else
+		lcd_clk_set(dst, clk_sclk, lcd_clk_get(src, clk_sclk) & mask,
+			lcd_clk_get(src, clk_sclk) & mask);
+
+	return 0;
+}
+
+static void pxa688fb_clone_intf_ctrl(int src, int dst)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 base = (u32)fbi->reg_base, reg = 0, mask = 0;
+
+	reg = readl(base + intf_ctrl(src));
+	switch (dst) {
+	case 0:
+		if (src == 1) {
+			/* tv -> pn */
+			mask = reg & 0xf00009ff;
+			if (reg & (1 << 15))
+				mask |= (1 << 9);
+		} else
+			/* pn2 -> pn */
+			mask = reg;
+		break;
+	case 1:
+		if (src == 0 || src == 2) {
+			/* pn -> tv or pn2 -> tv*/
+			mask = reg & 0xf00009ff;
+			if (reg & (1 << 9))
+				mask |= (1 << 15);
+		} else
+			mask = reg;
+		break;
+	case 2:
+		if (src == 1) {
+			/* tv -> pn2 */
+			mask = reg & 0xf00009ff;
+			if (reg & (1 << 15))
+				mask |= (1 << 9);
+		} else
+			/* pn -> pn2 */
+			mask = reg;
+		break;
+	default:
+		break;
+	}
+	writel(mask, base + intf_ctrl(dst));
+}
+
+static void pxa688fb_clone_vdma(int src, int dst, int vid)
+{
+#ifdef CONFIG_PXA688_VDMA
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 base = (u32)fbi->reg_base, mask, vdma;
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+
+	mask = readl(base + LCD_PN2_SQULN2_CTRL);
+	vdma = readl(base + squln_ctrl(src));
+	lcd_vdma = request_vdma(src, vid);
+	if (lcd_vdma && lcd_vdma->enable) {
+		if (!lcd_vdma->vid) {
+			/* vdma for graphic layer */
+			mask &= ~(dst ? ((dst & 1) ? (1 << 25) :
+				(1 << 26)) : (1 << 24));
+		} else {
+			/* vdma for video layer */
+			mask |= dst ? ((dst & 1) ? (1 << 25) :
+				(1 << 26)) : (1 << 24);
+		}
+	}
+	writel(vdma, base + squln_ctrl(dst));
+	writel(mask, base + LCD_PN2_SQULN2_CTRL);
+#endif
+}
+
+static void pxa688fb_clone_partdisp_ctrl(int src, int dst)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[src];
+	struct fb_info *info = fbi->fb_info;
+	struct fb_var_screeninfo *var = &info->var;
+
+	u32 base = (u32)fbi->reg_base, mask, region, bytespp,
+		horpix_end_src, horpix_end_dst, horpix_start,
+		threshold_src, threshold_dst;
+
+	mask = readl(base + gra_partdisp_ctrl_hor(src));
+	bytespp = var->bits_per_pixel >> 3;
+	horpix_end_src = (mask & 0xfff0000) >> 16;
+	horpix_start = mask & 0xfff;
+
+	/* THRESHOLD_x: the least bytes to operate for
+	 * horizontal partial display
+	 */
+	threshold_src = (src == 1 ? THRESHOLD_TV : THRESHOLD_PN);
+	threshold_dst = (dst == 1 ? THRESHOLD_TV : THRESHOLD_PN);
+	if (horpix_end_src > horpix_start) {
+		region = horpix_end_src - horpix_start;
+
+		/* BURST_LEN: AXI burst size, platform dependent */
+		region = (region - threshold_src / bytespp) /
+			(BURST_LEN / bytespp);
+		horpix_end_dst = horpix_start + threshold_dst / bytespp +
+			region * (BURST_LEN / bytespp);
+		mask &= ~0xfff0000;
+		mask |= horpix_end_dst << 16;
+	}
+	writel(mask, base + gra_partdisp_ctrl_hor(dst));
+	writel(readl(base + gra_partdisp_ctrl_ver(src)),
+		base + gra_partdisp_ctrl_ver(dst));
+}
+
+static void pxa688fb_clone_base(int src, int dst, int vid)
+{
+	struct lcd_regs *regs_src = get_regs(src);
+	struct lcd_regs *regs_dst = get_regs(dst);
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 base = (u32)fbi->reg_base, mask, cokey_en;
+
+	/* screen info */
+	writel(readl(&regs_src->screen_size), &regs_dst->screen_size);
+	writel(readl(&regs_src->screen_active), &regs_dst->screen_active);
+	writel(readl(&regs_src->screen_h_porch), &regs_dst->screen_h_porch);
+	writel(readl(&regs_src->screen_v_porch), &regs_dst->screen_v_porch);
+	writel(readl(&regs_src->vsync_ctrl), &regs_dst->vsync_ctrl);
+
+	/* dma control1 */
+	mask = ~0;
+	if ((src == 1) || (dst ==  1))
+		mask &= ~((0x1f << 18) | 0xff);
+	dma_ctrl_set(dst, 1, mask, dma_ctrl_read(src, 1) & mask);
+
+	/* dma control0 */
+	mask = ~(vid ? dma0_gfx_masks : dma0_vid_masks);
+	if ((src == 1) || (dst ==  1))
+		mask &= ~(1 << 27);
+	dma_ctrl_set(dst, 0, mask, dma_ctrl_read(src, 0) & mask);
+
+	/* DMA burst length */
+	if (dst == 2)
+		writel(readl(base + PN2_IOPAD_CONTROL) |
+			(3 << 10) | (3 << 8), base + PN2_IOPAD_CONTROL);
+
+	/* DMA color key */
+	cokey_en = pxa688_colorkey_get(src, vid);
+	pxa688_colorkey_set(dst, vid, cokey_en);
+
+	/* intf ctrl */
+	pxa688fb_clone_intf_ctrl(src, dst);
+}
+
+/* clone src path graphics layer settings to dst path */
+static int pxa688fb_clone_gfx(int src, int dst, int en)
+{
+	struct lcd_regs *regs_src = get_regs(src);
+	struct lcd_regs *regs_dst = get_regs(dst);
+	struct mvdisp_partdisp grap;
+
+	/* enable dst path clock */
+	pxa688fb_clone_clk(src, dst);
+
+	/* if disable vsmooth, disable dst path dma directly */
+	if (!en) {
+		dma_ctrl_set(dst, 0, CFG_GRA_ENA_MASK, 0);
+		if (debug)
+			pr_info("%s disabled: dma_ctrl0 0x%x\n",
+				__func__, dma_ctrl_read(dst, 0));
+		grap.id = dst;
+		grap.horpix_start = grap.horpix_end = 0;
+		grap.vertline_start = grap.vertline_end = 0;
+		grap.color = 0;
+		/* disable dst partial display */
+		pxa688fb_partdisp_set(grap);
+		return 0;
+	}
+
+	/* configure frame address */
+	writel(readl(&regs_src->g_0), &regs_dst->g_0);
+	writel(readl(&regs_src->g_1), &regs_dst->g_1);
+
+	/* partial display */
+	pxa688fb_clone_partdisp_ctrl(src, dst);
+
+	/* configure dst regs */
+	writel(readl(&regs_src->g_pitch), &regs_dst->g_pitch);
+	writel(readl(&regs_src->g_start), &regs_dst->g_start);
+	writel(readl(&regs_src->g_size), &regs_dst->g_size);
+	writel(readl(&regs_src->g_size_z), &regs_dst->g_size_z);
+	/* configure dma control0/1, screen info, color key, intf ctrl.. */
+	pxa688fb_clone_base(src, dst, 0);
+	return 0;
+}
+
+/* clone src path video layer settings to dst path */
+static int pxa688fb_clone_ovly(int src, int dst, int en)
+{
+	struct lcd_regs *regs_src = get_regs(src);
+	struct lcd_regs *regs_dst = get_regs(dst);
+
+	/* enable dst path clock */
+	pxa688fb_clone_clk(src, dst);
+
+	/* if disable vsmooth, disable dst path dma directly */
+	if (!en) {
+		dma_ctrl_set(dst, 0, CFG_DMA_ENA_MASK, 0);
+		if (debug)
+			pr_info("%s disable %d: dma_ctrl0 0x%x\n",
+				__func__, dst, dma_ctrl_read(dst, 0));
+		return 0;
+	}
+
+
+	/* configure dst regs */
+	writel(readl(&regs_src->v_y0), &regs_dst->v_y0);
+	writel(readl(&regs_src->v_u0), &regs_dst->v_u0);
+	writel(readl(&regs_src->v_v0), &regs_dst->v_v0);
+	writel(readl(&regs_src->v_c0), &regs_dst->v_c0);
+	writel(readl(&regs_src->v_y1), &regs_dst->v_y1);
+	writel(readl(&regs_src->v_u1), &regs_dst->v_u1);
+	writel(readl(&regs_src->v_v1), &regs_dst->v_v1);
+	writel(readl(&regs_src->v_c1), &regs_dst->v_c1);
+	writel(readl(&regs_src->v_pitch_yc), &regs_dst->v_pitch_yc);
+	writel(readl(&regs_src->v_pitch_uv), &regs_dst->v_pitch_uv);
+	writel(readl(&regs_src->v_start), &regs_dst->v_start);
+	writel(readl(&regs_src->v_size), &regs_dst->v_size);
+	writel(readl(&regs_src->v_size_z), &regs_dst->v_size_z);
+	/* configure dma control0/1, screen info, color key, intf ctrl.. */
+	pxa688fb_clone_base(src, dst, 1);
+	return 0;
+}
+
+static int pxa168fb_vsmooth_check(int id, int src, int dst, int vid, int en)
+{
+	struct lcd_regs *regs;
+	int x, x_z;
+
+	if (id != fb_vsmooth) {
+		if (debug)
+			pr_info("%s: fbi %d != fb_vsmooth %d\n",
+				__func__, id, fb_vsmooth);
+		return -EINVAL;
+	}
+
+	if (src == dst || src < 0 || src > 2 || dst < 0 || dst > 1) {
+		if (debug)
+			pr_info("%s input err: src %d dst %d vid %d en %d\n",
+				__func__, src, dst, vid, en);
+		return -EINVAL;
+	}
+
+	regs = get_regs(id);
+	x = (readl(vid ? &regs->v_size : &regs->g_size) >> 16) & 0xfff;
+	x_z = (readl(vid ? &regs->v_size_z : &regs->g_size_z) >> 16) & 0xfff;
+	if (debug)
+		pr_info("%s layer %s: x 0x%x x_z 0x%x\n",
+			__func__, vid ? "vid " : "gfx", x, x_z);
+	return (x_z > x) ? 0 : 1;
+}
+
+/* pxa688fb_vsmooth_set
+ * vid: video layer or graphics layer
+ * en: enable vsmooth mode or not
+ */
+int pxa688fb_vsmooth_set(int id, int vid, int en)
+{
+	int filter = fb_filter, dst = fb_vsmooth, ret = 0;
+
+	ret = pxa168fb_vsmooth_check(id, filter, dst, vid, en);
+	if (ret) {
+		if (ret == 1)
+			/* not scaling, disable mapping and filter path dma */
+			en = 0;
+		else
+			return -EINVAL;
+	}
+
+	if (vid)
+		ret = pxa688fb_clone_ovly(dst, filter, en);
+	else
+		ret = pxa688fb_clone_gfx(dst, filter, en);
+	if (ret) {
+		if (debug)
+			pr_info("%s clone %s err, filter %d dst %d\n",
+				__func__, vid ? "ovly" : "gfx", filter, dst);
+		return -EIO;
+	}
+
+	/* vdma clone */
+	pxa688fb_clone_vdma(dst, filter, vid);
+
+	pxa688fb_map_layers(filter, dst, vid, en);
+	pxa688fb_vsmooth_config(filter, dst, vid, en);
+	return 0;
+}
+
+/* gamma correction related functions */
+#define mmpdisp_regbase		((u32)gfx_info.fbi[0]->reg_base)
+#define sram_ctrl		(mmpdisp_regbase + LCD_SPU_SRAM_CTRL)
+#define sram_wrdat		(mmpdisp_regbase + LCD_SPU_SRAM_WRDAT)
+#define sram_para1		(mmpdisp_regbase + LCD_SPU_SRAM_PARA1)
+#define gamma_rddat(path)	(mmpdisp_regbase + (((path) & 1) ? \
+				LCD_TV_GAMMA_RDDAT : LCD_SPU_GAMMA_RDDAT))
+#define gamma_id_yr(path)	((path) ? (((path) & 1) ? 0x4 : 0x9) : 0x0)
+#define gamma_id_ug(path)	((path) ? (((path) & 1) ? 0x5 : 0xa) : 0x1)
+#define gamma_id_vb(path)	((path) ? (((path) & 1) ? 0x6 : 0xb) : 0x2)
+static u32 gamma_read(u32 addr, int gamma_id, int path)
+{
+	int count = 10000, val, pn2 = (path == 2) ? (1 << 16) : 0;
+
+	val = pn2 | (0x0 << 12) | (gamma_id << 8) | addr;
+	__raw_writel(val, sram_ctrl);
+	while (__raw_readl(sram_ctrl) & (1<<31) && count--);
+
+	if (count > 0)
+		val = __raw_readl(gamma_rddat(path)) & CFG_GAMMA_RDDAT_MASK;
+	else
+		val = -1;
+
+	return val;
+}
+
+static void gamma_write(u32 addr, u32 gamma_id, u32 val)
+{
+	__raw_writel(val, sram_wrdat);
+	val = (0x8 << 12) | (gamma_id << 8 ) | addr;
+	__raw_writel(val, sram_ctrl);
+}
+
+void gamma_dump(int path, int lines)
+{
+	u32 i = 0, val;
+
+	if (!(dma_ctrl_read(path, 0) & CFG_GAMMA_ENA_MASK)) {
+		pr_info("gamma correction not enabled yet\n");
+	}
+
+	/* enable gamma correction table update */
+	val = __raw_readl(sram_para1) | CFG_CSB_256x8_MASK;
+	__raw_writel(val, sram_para1);
+
+	for (; i < lines; i++)
+		pr_info("%3d: yr %3d, ug %3d, vb %3d\n", i,
+			gamma_read(i, gamma_id_yr(path), path),
+			gamma_read(i, gamma_id_ug(path), path),
+			gamma_read(i, gamma_id_vb(path), path));
+
+	val = __raw_readl(sram_para1) & ~CFG_CSB_256x8_MASK;
+	__raw_writel(val, sram_para1);
+}
+
+int gamma_set(int path, int flag, char *gamma_table)
+{
+	u32 i = 0, val;
+
+	/* disable gamma correction */
+	dma_ctrl_set(path, 0, CFG_GAMMA_ENA_MASK, CFG_GAMMA_ENA(0));
+
+	if (!(flag & GAMMA_ENABLE))
+		goto dump;
+
+	/* check as only 2 gamma correction table avialable */
+	if (((path == 2) && (CFG_GAMMA_ENA(1) &
+			dma_ctrl_read(0, 0) & dma_ctrl_read(1, 0))) ||
+	    ((path == 1) && (CFG_GAMMA_ENA(1) &
+			dma_ctrl_read(2, 0) & dma_ctrl_read(0, 0))) ||
+	    ((path == 0) && (CFG_GAMMA_ENA(1) &
+			dma_ctrl_read(1, 0) & dma_ctrl_read(2, 0)))) {
+		pr_err("path %d gamma correction not avialable, pls "
+			"disable other path's and try again\n", path);
+		return -EINVAL;
+	}
+
+	/* enable gamma correction table update */
+	val = __raw_readl(sram_para1) | CFG_CSB_256x8_MASK;
+	__raw_writel(val, sram_para1);
+
+	/* write gamma corrrection table */
+	for (; i < GAMMA_TABLE_LEN; i++) {
+		gamma_write(i, gamma_id_yr(path), gamma_table[i]);
+		gamma_write(i, gamma_id_ug(path), gamma_table[i]);
+		gamma_write(i, gamma_id_vb(path), gamma_table[i]);
+	}
+
+	val = __raw_readl(sram_para1) & ~CFG_CSB_256x8_MASK;
+	__raw_writel(val, sram_para1);
+
+	/* enable gamma correction table */
+	dma_ctrl_set(path, 0, CFG_GAMMA_ENA_MASK, CFG_GAMMA_ENA(1));
+
+dump:
+	if (flag & GAMMA_DUMP)
+		gamma_dump(path, GAMMA_TABLE_LEN);
+
+	return 0;
+}
+
+static void dither_dump(struct pxa168fb_info *fbi)
+{
+	u32 base = (u32)fbi->reg_base;
+	u32 mask = readl(base + LCD_DITHER_CTRL);
+	int enabled, mode, table;
+
+	enabled = mask & (fbi->id ? DITHER_EN2 : DITHER_EN1);
+	if (!enabled)
+		pr_info("fbi%d dither was disabled\n", fbi->id);
+	else {
+		mode = mask & (fbi->id ? DITHER_MODE2(7) : DITHER_MODE1(7));
+		mode = mode >> (fbi->id ? DITHER_MODE2_SHIFT :
+			DITHER_MODE1_SHIFT);
+		table = mask & (fbi->id ? DITHER_4X8_EN2 : DITHER_4X8_EN1);
+		table = table >> (fbi->id ? DITHER_4X8_EN2_SHIFT :
+			DITHER_4X8_EN1_SHIFT);
+
+		pr_info("fbi%d dither mode:%d, table:%d\n",
+			fbi->id, mode, table);
+		mask &= ~DITHER_TBL_INDEX_SEL(3);
+		if (!table) {
+			writel(mask, base + LCD_DITHER_CTRL);
+			pr_info("4x4table index0:%x",
+				readl(base + LCD_DITHER_TBL_DATA));
+			writel(mask | DITHER_TBL_INDEX_SEL(1),
+				base + LCD_DITHER_CTRL);
+			pr_info("4x4table index1:%x",
+				readl(base + LCD_DITHER_TBL_DATA));
+		} else {
+			writel(mask, base + LCD_DITHER_CTRL);
+			pr_info("4x8table index0:%x",
+				readl(base + LCD_DITHER_TBL_DATA));
+			writel(mask | DITHER_TBL_INDEX_SEL(1),
+				base + LCD_DITHER_CTRL);
+			pr_info("4x8table index1:%x",
+				readl(base + LCD_DITHER_TBL_DATA));
+			writel(mask | DITHER_TBL_INDEX_SEL(2),
+				base + LCD_DITHER_CTRL);
+			pr_info("4x8table index2:%x",
+				readl(base + LCD_DITHER_TBL_DATA));
+			writel(mask | DITHER_TBL_INDEX_SEL(3),
+				base + LCD_DITHER_CTRL);
+			pr_info("4x8table index3:%x",
+				readl(base + LCD_DITHER_TBL_DATA));
+		}
+	}
+}
+
+void dither_set(struct pxa168fb_info *fbi, int table, int mode, int enable)
+{
+	u32 base = (u32)fbi->reg_base;
+	u32 mask = readl(base + LCD_DITHER_CTRL);
+
+	if (fbi->id && fbi->id != 2) {
+		pr_err("%s fbi:%d dither not support\n", __func__, fbi->id);
+		return;
+	}
+
+	if (!enable) {
+		mask &= ~(fbi->id ? DITHER_EN2 : DITHER_EN1);
+		writel(mask, base + LCD_DITHER_CTRL);
+		goto dump;
+	}
+
+	if (!fbi->id) {
+		mask = table ? DITHER_4X8_EN1 : 0;
+		mask |= DITHER_MODE1(mode);
+		mask |= DITHER_EN1;
+	} else {
+		mask = table ? DITHER_4X8_EN2 : 0;
+		mask |= DITHER_MODE2(mode);
+		mask |= DITHER_EN2;
+	}
+
+	if (!table) {
+		/* 4X4 table */
+		writel(mask, base + LCD_DITHER_CTRL);
+		writel(DITHER_TB_4X4_INDEX0, base + LCD_DITHER_TBL_DATA);
+		writel(mask | DITHER_TBL_INDEX_SEL(1), base + LCD_DITHER_CTRL);
+		writel(DITHER_TB_4X4_INDEX1, base + LCD_DITHER_TBL_DATA);
+	} else {
+		/* 4X8 table */
+		writel(mask, base + LCD_DITHER_CTRL);
+		writel(DITHER_TB_4X8_INDEX0, base + LCD_DITHER_TBL_DATA);
+		writel(mask | DITHER_TBL_INDEX_SEL(1), base + LCD_DITHER_CTRL);
+		writel(DITHER_TB_4X8_INDEX1, base + LCD_DITHER_TBL_DATA);
+		writel(mask | DITHER_TBL_INDEX_SEL(2), base + LCD_DITHER_CTRL);
+		writel(DITHER_TB_4X8_INDEX2, base + LCD_DITHER_TBL_DATA);
+		writel(mask | DITHER_TBL_INDEX_SEL(3), base + LCD_DITHER_CTRL);
+		writel(DITHER_TB_4X8_INDEX3, base + LCD_DITHER_TBL_DATA);
+	}
+
+dump:
+	if (debug)
+		dither_dump(fbi);
+}
+
+static ssize_t misc_help(char *buf)
+{
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "commands:\n");
+	mvdisp_dump(f, " - dump partial display and vertical"
+			" smooth settings\n");
+	mvdisp_dump(f, "\tcat misc\n");
+	mvdisp_dump(f, " - select path(pn/tv/pn2:0/1/2]) to be"
+			" vertical smoothed\n");
+	mvdisp_dump(f, "\techo s[path:0/1/2] > misc\n");
+	mvdisp_dump(f, " - select path(pn/tv/pn2:0/1/2]) to work as filter"
+			" when vertical smooth enabled\n");
+	mvdisp_dump(f, "\techo f[path:0/1/2] > misc\n");
+	mvdisp_dump(f, " - graphics layer vertical vsmooth"
+			" enable[1]/disable[0]\n");
+	mvdisp_dump(f, "\techo g[en/dis:1/0] > misc\n");
+	mvdisp_dump(f, " - video layer vertical vsmooth"
+			" enable[1]/disable[0]\n");
+	mvdisp_dump(f, "\techo v[en/dis:1/0] > misc\n");
+	mvdisp_dump(f, " - vertical smooth kernel debug"
+			" enable[1]/disable[0]\n");
+	mvdisp_dump(f, "\techo d[en/dis:1/0] > misc\n");
+	mvdisp_dump(f, " - set graphics layer partial display area from pixel"
+			" [h_start][v_start]\n   to pixel [h_end][v_end]"
+			"  with RGB565 format [color]\n");
+	mvdisp_dump(f, "\techo p [h_start] [v_start] [h_end] [v_end]"
+			" [color] > misc\n");
+	mvdisp_dump(f, " - dither setting\n");
+	mvdisp_dump(f, "\techo i [4x4/4x8 table: 0/1]"
+		" [RBG444/RGB565/RGB666 mode: 0/1/2] [en/dis:1/0] > misc\n");
+
+	return s;
+}
+
+ssize_t misc_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	struct mvdisp_partdisp grap;
+	u32 mask;
+	int s = 0;
+
+	grap.id = fbi->id;
+again:
+	mask = readl((u32)fbi->reg_base + gra_partdisp_ctrl_hor(grap.id));
+	/* get horizontal start/end pixel number */
+	grap.horpix_start = mask & 0xfff;
+	grap.horpix_end = (mask & 0xfff0000) >> 16;
+	/* get color bit 0~7 */
+	grap.color = (mask & 0xf000) >> 12;
+	grap.color |= ((mask & 0xf0000000) >> 28) << 4;
+
+	mask = readl((u32)fbi->reg_base + gra_partdisp_ctrl_ver(grap.id));
+	/* get vertical start/end line */
+	grap.vertline_start = mask & 0xfff;
+	grap.vertline_end = (mask & 0xfff0000) >> 16;
+	/* get color bit 8~15 */
+	grap.color |= ((mask & 0xf000) >> 12) << 8;
+	grap.color |= ((mask & 0xf0000000) >> 28) << 12;
+
+	s += sprintf(buf + s, "partial display:\n  path %d, h_start %d,"
+		"v_start %d, h_end %d, v_end %d, color %d\n\n",
+		grap.id, grap.horpix_start, grap.vertline_start,
+		grap.horpix_end, grap.vertline_end, grap.color);
+
+	if (gfx_vsmooth && (fb_filter != fb_vsmooth)
+		&& (grap.id == fb_vsmooth)) {
+		grap.id = fb_filter;
+		goto again;
+	}
+
+	s += sprintf(buf + s, "vertical smooth:\n  filter(%d)->vsmooth(%d),"
+		" gfx %d, vid %d, debug %d\n\n", fb_filter, fb_vsmooth,
+		gfx_vsmooth, vid_vsmooth, debug);
+
+	s += misc_help(buf + s);
+	return s;
+}
+ssize_t misc_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	struct mvdisp_partdisp grap;
+	char vol[30];
+	int tmp, table, mode, enable;
+
+	if (size > 30) {
+		pr_err("%s size = %d > max 30 chars\n", __func__, size);
+		return size;
+	}
+	if ('s' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		tmp = (int) simple_strtoul(vol, NULL, 10);
+		if (tmp != fb_vsmooth) {
+			/* disable vsmooth for original path */
+			pxa688fb_vsmooth_set(fb_vsmooth, 0, 0);
+			pxa688fb_vsmooth_set(fb_vsmooth, 1, 0);
+			/* enable vsmooth for new path */
+			fb_vsmooth = tmp;
+			pxa688fb_vsmooth_set(fb_vsmooth, 0, gfx_vsmooth);
+			pxa688fb_vsmooth_set(fb_vsmooth, 1, vid_vsmooth);
+			pr_info("fb_vsmooth: %d\n", fb_vsmooth);
+		}
+		return size;
+	} else if ('f' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		tmp = (int) simple_strtoul(vol, NULL, 10);
+		if (tmp != fb_filter) {
+			/* disable vsmooth for original path */
+			pxa688fb_vsmooth_set(fb_vsmooth, 0, 0);
+			pxa688fb_vsmooth_set(fb_vsmooth, 1, 0);
+			/* enable vsmooth for new path */
+			fb_filter = tmp;
+			pxa688fb_vsmooth_set(fb_vsmooth, 0, gfx_vsmooth);
+			pxa688fb_vsmooth_set(fb_vsmooth, 1, vid_vsmooth);
+			pr_info("fb_filter: %d\n", fb_filter);
+		}
+		return size;
+	} else if ('g' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		tmp = gfx_vsmooth;
+		gfx_vsmooth = (int) simple_strtoul(vol, NULL, 10);
+		if (tmp != gfx_vsmooth) {
+			pxa688fb_vsmooth_set(fb_vsmooth, 0, gfx_vsmooth);
+			pr_info("gfx_vsmooth: %d -> %d\n", tmp, gfx_vsmooth);
+		}
+		return size;
+	} else if ('v' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		tmp = vid_vsmooth;
+		vid_vsmooth = (int) simple_strtoul(vol, NULL, 10);
+		if (tmp != vid_vsmooth) {
+			pxa688fb_vsmooth_set(fb_vsmooth, 1, vid_vsmooth);
+			pr_info("vid_vsmooth: %d -> %d\n", tmp, vid_vsmooth);
+		}
+		return size;
+	} else if ('d' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		debug = (int) simple_strtoul(vol, NULL, 10);
+		pr_info("debug: %d\n", debug);
+		return size;
+	} else if ('p' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		if (sscanf(vol, "%u %u %u %u %hu", &grap.horpix_start,
+			&grap.vertline_start, &grap.horpix_end,
+			&grap.vertline_end, &grap.color) != 5) {
+			pr_err("partial display cmd should be like: "
+				"p horpix_start vertline_start "
+				"horpix_end verline_end color\n");
+			return size;
+		}
+		grap.id = fbi->id;
+		pxa688fb_partdisp_set(grap);
+		if ((grap.id == fb_vsmooth) && (gfx_vsmooth)) {
+			if (dma_ctrl_read(fb_filter, 0) & CFG_GRA_ENA_MASK) {
+				grap.id = fb_filter;
+				pxa688fb_partdisp_set(grap);
+			}
+		}
+		pr_info("lcd_part_disp\n");
+	} else if ('i' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		if (sscanf(vol, "%u %u %u", &table, &mode, &enable) != 3) {
+			pr_err("dithering cmd should be:"
+				"i table mode enable\n");
+			return size;
+		}
+		dither_set(fbi, table, mode, enable);
+		pr_info("dither setting\n");
+	} else
+		pr_err("%s unknown command %s\n", __func__, buf);
+
+	return size;
+}
+DEVICE_ATTR(misc, S_IRUGO | S_IWUSR, misc_show, misc_store);
diff --git a/drivers/video/pxa688_phy.c b/drivers/video/pxa688_phy.c
new file mode 100644
index 00000000..b3c98822
--- /dev/null
+++ b/drivers/video/pxa688_phy.c
@@ -0,0 +1,1495 @@
+/*
+ * linux/drivers/video/pxa688_phy.c -- Marvell PXA168 LCD Controller
+ *
+ *  Copyright (C) 2008 Marvell International Ltd.
+ *  All rights reserved.
+ *
+ *  2009-02-16  adapted from original version for PXA168
+ *		Kevin Liu <kliu5@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+#include <linux/delay.h>
+#include <linux/clk.h>
+
+#ifdef CONFIG_PXA688_PHY
+#include "pxa168fb_common.h"
+
+/* dsi phy timing */
+static struct dsi_phy phy = {
+	.hs_prep_constant	= 40,    /* Unit: ns. */
+	.hs_prep_ui		= 4,
+	.hs_zero_constant	= 145,
+	.hs_zero_ui		= 10,
+	.hs_trail_constant	= 60,
+	.hs_trail_ui		= 4,
+	.hs_exit_constant	= 100,
+	.hs_exit_ui		= 0,
+	.ck_zero_constant	= 300,
+	.ck_zero_ui		= 0,
+	.ck_trail_constant	= 60,
+	.ck_trail_ui		= 0,
+	.req_ready		= 0x3c,
+	.wakeup_constant        = 1000000,
+	.wakeup_ui      = 0,
+	.lpx_constant       = 50,
+	.lpx_ui     = 0,
+};
+
+#define dsi_ex_pixel_cnt		0
+#define dsi_hex_en			0
+/* (Unit: Mhz) */
+#define dsi_hsclk			(fbi->clk ? \
+					clk_get_rate(fbi->clk)/1000000 :\
+					clk_get_rate(fbi->phy_clk)/1000000)
+#define dsi_lpclk			3
+
+#define to_dsi_bcnt(timing, bpp)	(((timing) * (bpp)) >> 3)
+
+static unsigned int dsi_lane[5] = {0, 0x1, 0x3, 0x7, 0xf};
+
+static unsigned char dsi_bit(unsigned int index, unsigned char *pdata)
+{
+	unsigned char ret;
+	unsigned int cindex, bindex;
+	cindex = index / 8;
+	bindex = index % 8;
+
+	if (pdata[cindex] & (0x1 << bindex))
+		ret = (unsigned char) 0x1;
+	else
+		ret = (unsigned char) 0x0;
+
+	return ret;
+}
+
+static unsigned char calculate_ecc(unsigned char *pdata)
+{
+	unsigned char ret;
+	unsigned char p[8];
+
+	p[7] = (unsigned char) 0x0;
+	p[6] = (unsigned char) 0x0;
+
+	p[5] = (unsigned char) (
+	(
+		dsi_bit(10, pdata) ^ \
+		dsi_bit(11, pdata) ^ \
+		dsi_bit(12, pdata) ^ \
+		dsi_bit(13, pdata) ^ \
+		dsi_bit(14, pdata) ^ \
+		dsi_bit(15, pdata) ^ \
+		dsi_bit(16, pdata) ^ \
+		dsi_bit(17, pdata) ^ \
+		dsi_bit(18, pdata) ^ \
+		dsi_bit(19, pdata) ^ \
+		dsi_bit(21, pdata) ^ \
+		dsi_bit(22, pdata) ^ \
+		dsi_bit(23, pdata)
+		)
+	);
+	p[4] = (unsigned char) (
+		dsi_bit(4, pdata) ^ \
+		dsi_bit(5, pdata) ^ \
+		dsi_bit(6, pdata) ^ \
+		dsi_bit(7, pdata) ^ \
+		dsi_bit(8, pdata) ^ \
+		dsi_bit(9, pdata) ^ \
+		dsi_bit(16, pdata) ^ \
+		dsi_bit(17, pdata) ^ \
+		dsi_bit(18, pdata) ^ \
+		dsi_bit(19, pdata) ^ \
+		dsi_bit(20, pdata) ^ \
+		dsi_bit(22, pdata) ^ \
+		dsi_bit(23, pdata)
+	);
+	p[3] = (unsigned char) (
+	(
+		dsi_bit(1, pdata) ^ \
+		dsi_bit(2, pdata) ^ \
+		dsi_bit(3, pdata) ^ \
+		dsi_bit(7, pdata) ^ \
+		dsi_bit(8, pdata) ^ \
+		dsi_bit(9, pdata) ^ \
+		dsi_bit(13, pdata) ^ \
+		dsi_bit(14, pdata) ^ \
+		dsi_bit(15, pdata) ^ \
+		dsi_bit(19, pdata) ^ \
+		dsi_bit(20, pdata) ^ \
+		dsi_bit(21, pdata) ^ \
+		dsi_bit(23, pdata)
+		)
+	);
+	p[2] = (unsigned char) (
+	(
+		dsi_bit(0, pdata) ^ \
+		dsi_bit(2, pdata) ^ \
+		dsi_bit(3, pdata) ^ \
+		dsi_bit(5, pdata) ^ \
+		dsi_bit(6, pdata) ^ \
+		dsi_bit(9, pdata) ^ \
+		dsi_bit(11, pdata) ^ \
+		dsi_bit(12, pdata) ^ \
+		dsi_bit(15, pdata) ^ \
+		dsi_bit(18, pdata) ^ \
+		dsi_bit(20, pdata) ^ \
+		dsi_bit(21, pdata) ^ \
+		dsi_bit(22, pdata)
+		)
+	);
+	p[1] = (unsigned char) (
+		(
+		dsi_bit(0, pdata) ^ \
+		dsi_bit(1, pdata) ^ \
+		dsi_bit(3, pdata) ^ \
+		dsi_bit(4, pdata) ^ \
+		dsi_bit(6, pdata) ^ \
+		dsi_bit(8, pdata) ^ \
+		dsi_bit(10, pdata) ^ \
+		dsi_bit(12, pdata) ^ \
+		dsi_bit(14, pdata) ^ \
+		dsi_bit(17, pdata) ^ \
+		dsi_bit(20, pdata) ^ \
+		dsi_bit(21, pdata) ^ \
+		dsi_bit(22, pdata) ^ \
+		dsi_bit(23, pdata)
+		)
+	);
+	p[0] = (unsigned char) (
+		(
+		dsi_bit(0, pdata) ^ \
+		dsi_bit(1, pdata) ^ \
+		dsi_bit(2, pdata) ^ \
+		dsi_bit(4, pdata) ^ \
+		dsi_bit(5, pdata) ^ \
+		dsi_bit(7, pdata) ^ \
+		dsi_bit(10, pdata) ^ \
+		dsi_bit(11, pdata) ^ \
+		dsi_bit(13, pdata) ^ \
+		dsi_bit(16, pdata) ^ \
+		dsi_bit(20, pdata) ^ \
+		dsi_bit(21, pdata) ^ \
+		dsi_bit(22, pdata) ^ \
+		dsi_bit(23, pdata)
+		)
+	);
+	ret = (unsigned char)(
+		p[0] | \
+		(p[1] << 0x1) | \
+		(p[2] << 0x2) | \
+		(p[3] << 0x3) | \
+		(p[4] << 0x4) | \
+		(p[5] << 0x5)
+	);
+	return   ret;
+}
+
+static unsigned short gs_crc16_generation_code = 0x8408;
+static unsigned short calculate_crc16(unsigned char *pdata, unsigned
+		short count)
+{
+	unsigned short byte_counter;
+	unsigned char bit_counter;
+	unsigned char data;
+	unsigned short crc16_result = 0xFFFF;
+	if (count > 0) {
+		for (byte_counter = 0; byte_counter < count;
+			byte_counter++) {
+			data = *(pdata + byte_counter);
+			for (bit_counter = 0; bit_counter < 8; bit_counter++) {
+				if (((crc16_result & 0x0001) ^ ((0x0001 *
+					data) & 0x0001)) > 0)
+					crc16_result = ((crc16_result >> 1)
+					& 0x7FFF) ^ gs_crc16_generation_code;
+				else
+					crc16_result = (crc16_result >> 1)
+					& 0x7FFF;
+				data = (data >> 1) & 0x7F;
+			}
+		}
+	}
+	return crc16_result;
+}
+
+static void dsi_send_cmds(struct pxa168fb_info *fbi, u8 *parameter,
+		u8 count, u8 lp)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	u32 send_data = 0, waddr, i, loop, turnaround;
+
+	/* write all packet bytes to packet data buffer */
+	for (i = 0; i < count; i++) {
+		send_data |= parameter[i] << ((i % 4) * 8);
+		if (!((i + 1) % 4)) {
+			writel(send_data, &dsi->dat0);
+			waddr = DSI_CFG_CPU_DAT_REQ_MASK |
+				DSI_CFG_CPU_DAT_RW_MASK |
+				((i - 3) << DSI_CFG_CPU_DAT_ADDR_SHIFT);
+			writel(waddr, &dsi->cmd3);
+			loop = 100000;
+			/* wait write operation done */
+			while (readl(&dsi->cmd3) & DSI_CFG_CPU_DAT_REQ_MASK) {
+				loop--;
+				if (loop <= 0){
+				   pr_err("%s error!\n", __func__);
+				   break;
+				}
+			}
+			send_data = 0;
+		}
+	}
+
+	/* handle last none 4Byte align data */
+	if (i % 4) {
+		writel(send_data, &dsi->dat0);
+		waddr = DSI_CFG_CPU_DAT_REQ_MASK |
+			DSI_CFG_CPU_DAT_RW_MASK |
+			((4 * (i / 4)) << DSI_CFG_CPU_DAT_ADDR_SHIFT);
+		writel(waddr, &dsi->cmd3);
+		loop = 100000;
+		/* wait write operation done */
+		while (readl(&dsi->cmd3) & DSI_CFG_CPU_DAT_REQ_MASK) {
+			loop--;
+			if (loop <= 0) {
+				pr_err("%s error!\n", __func__);
+				break;
+			}
+		}
+
+		send_data = 0;
+	}
+
+	if (parameter[0] == DSI_DI_DCS_READ|| parameter[0] == DSI_DI_SET_MAX_PKT_SIZE)
+		turnaround = 0x1;
+	else
+		turnaround = 0x0;
+
+	waddr = DSI_CFG_CPU_CMD_REQ_MASK |
+		((count == 4) ? DSI_CFG_CPU_SP_MASK : 0) |
+		(turnaround << DSI_CFG_CPU_TURN_SHIFT) |
+		(lp ? DSI_CFG_CPU_TXLP_MASK : 0) |
+		((lp ? count : count -2) << DSI_CFG_CPU_WC_SHIFT);
+
+	/* send out the packet */
+	writel(waddr, &dsi->cmd0);
+	loop = 100000;
+	/* wait packet be sent out */
+	while (readl(&dsi->cmd0) & DSI_CFG_CPU_CMD_REQ_MASK) {
+		//msleep(1);
+		loop--;
+		if (loop <= 0){
+			pr_err("%s error!\n", __func__);
+			break;
+		}
+	}
+}
+
+void dsi_cmd_array_tx(struct pxa168fb_info *fbi, struct dsi_cmd_desc cmds[],
+		int count)
+{
+	struct dsi_cmd_desc cmd_line;
+	u8 command, parameter[DSI_MAX_DATA_BYTES], len;
+	u32 crc, loop;
+
+	for (loop = 0; loop < count; loop++) {
+		cmd_line = cmds[loop];
+		command = cmd_line.data_type;
+		len = cmd_line.length;
+		memset(parameter, 0x00, len + 6);
+		parameter[0] = command & 0xff;
+		switch (command) {
+		case DSI_DI_DCS_SWRITE:
+		case DSI_DI_DCS_SWRITE1:
+		case DSI_DI_DCS_READ:
+		case DSI_DI_SET_MAX_PKT_SIZE:
+			memcpy(&parameter[1], cmd_line.data, len);
+			len = 4;
+			break;
+		case DSI_DI_GENERIC_LWRITE:
+		case DSI_DI_DCS_LWRITE:
+			parameter[1] = len & 0xff;
+			parameter[2] = 0;
+			memcpy(&parameter[4], cmd_line.data, len);
+			crc = calculate_crc16(&parameter[4], len);
+			parameter[len + 4] = crc & 0xff;
+			parameter[len + 5] = (crc >> 8) & 0xff;
+			len += 6;
+			break;
+		default:
+			pr_err("%s: data type not supported 0x%x\n",
+					__func__, command);
+			break;
+		}
+		parameter[3] = calculate_ecc(parameter);
+
+		/* send dsi commands */
+		dsi_send_cmds(fbi, parameter, len, cmd_line.lp);
+
+		if (cmd_line.delay)
+			mdelay(cmd_line.delay);
+	}
+}
+#ifdef VSYNC_DSI_CMD
+
+/*
+	dsi_prepare_cmd_array_tx()
+	Prepare DSI Command packet
+	fbi		: Current LCD
+	cmds	: command array pointer
+	count	: How many commands in the command array
+	buffer	: Should be allocated by caller with count * DSI_MAX_DATA_BYTES
+	packet_len[] : Should be allocated by caller with count
+*/
+void dsi_prepare_cmd_array_tx(struct pxa168fb_info *fbi, struct dsi_cmd_desc cmds[],
+		int count, u8 *buffer, u8 *packet_len)
+{
+	struct dsi_cmd_desc cmd_line;
+	u8 command,len;
+	u32 crc, loop;
+	u8 *parameter;
+	
+	//printk("%s\n", __func__);
+	for (loop = 0; loop < count; loop++) {
+		parameter = buffer + (DSI_MAX_DATA_BYTES*loop);
+		cmd_line = cmds[loop];
+		command = cmd_line.data_type;
+		len = cmd_line.length;
+		memset(parameter, 0x00, len + 6);
+		parameter[0] = command & 0xff;
+		switch (command) {
+		case DSI_DI_DCS_SWRITE:
+		case DSI_DI_DCS_SWRITE1:
+		case DSI_DI_DCS_READ:
+		case DSI_DI_SET_MAX_PKT_SIZE:
+			memcpy(&parameter[1], cmd_line.data, len);
+			len = 4;
+			break;
+		case  DSI_DI_GENERIC_LWRITE:
+		case  DSI_DI_DCS_LWRITE:
+			parameter[1] = len & 0xff;
+			parameter[2] = 0;
+			memcpy(&parameter[4], cmd_line.data, len);
+			crc = calculate_crc16(&parameter[4], len);
+			parameter[len + 4] = crc & 0xff;
+			parameter[len + 5] = (crc >> 8) & 0xff;
+			len += 6;
+			break;
+		default:
+			pr_err("%s: data type not supported 0x%x\n",
+					__func__, command);
+			break;
+		}
+		parameter[3] = calculate_ecc(parameter);
+		packet_len[loop] = len;
+	}
+}
+
+/*
+	dsi_send_prepared_cmd_tx()
+	Send one data cmd to DSI which is prepared by dsi_prepare_cmd_array_tx()
+	
+	eg)
+		count is dsi_prepare_cmd_array_tx()'s count
+		int loop
+		for (loop = 0; loop < count; loop++)
+			dsi_send_prepared_cmd_tx(fbi, buffer[loop], packet_len[loop])
+			
+	fbi 	: Current LCD
+	cmds	: command array pointer
+	count	: How many commands in the command array
+	buffer	: got from dsi_prepare_cmd_array_tx
+	len 		: Sgot from dsi_prepare_cmd_array_tx
+*/
+
+void dsi_send_prepared_cmd_tx(struct pxa168fb_info *fbi, struct dsi_cmd_desc cmds,
+	u8 *buffer,u8 len)
+{
+	//printk("%s : len = %d\n", __func__,len);
+	dsi_send_cmds(fbi, buffer, len, cmds.lp);
+	
+	if (cmds.delay)
+		mdelay(cmds.delay);
+}
+#endif
+void dsi_cclk_set(struct pxa168fb_info *fbi, int en)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+
+	if (en)
+		writel(0x1, &dsi->phy_ctrl1);
+	else
+		writel(0x0, &dsi->phy_ctrl1);
+}
+
+void dsi_lanes_enable(struct pxa168fb_info *fbi, int en)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	u32 reg = readl(&dsi->phy_ctrl2) & ~(0xf << 4);
+
+	reg &= ~(0xf << 4);
+	if (en)
+		reg |= (dsi_lane[di->lanes] << 4);
+
+	pr_debug("%s %d: phy_ctrl2 0x%x\n", __func__, en, reg);
+	writel(reg, &dsi->phy_ctrl2);
+}
+
+void dsi_ulps_tx_enable(struct pxa168fb_info *fbi, int en)
+{
+       struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+       struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+       struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+       u32 reg = readl(&dsi->cmd1);      
+
+	   if(en)
+	   	reg |= (0xf<< 16);
+	   else
+		reg &= ~(0xf<< 16);
+			
+
+       pr_debug("%s %d: phy_cmd1 0x%x\n", __func__, en, reg);
+       writel(reg, &dsi->cmd1);
+}
+void dsi_dphy_force_ulps_mode(struct pxa168fb_info *fbi)
+{
+       struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+       struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+       struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	   
+       u32 reg = readl(&dsi->cmd1) | (0xf<< 16);  
+
+       pr_debug("%s: phy_cmd1 0x%x\n", __func__, reg);
+       writel(reg, &dsi->cmd1);
+
+	   reg =  readl(&dsi->phy_ctrl1) | (1<<1) | (1<<2); 
+	    writel(reg, &dsi->phy_ctrl1);	   
+}
+
+
+
+void dsi_dphy_exit_ulps_mode(struct pxa168fb_info *fbi)
+{
+       struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+       struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+       struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	   
+       u32 reg = readl(&dsi->cmd1)  &  ~(0xf<< 16);  
+
+       pr_debug("%s: phy_cmd1 0x%x\n", __func__, reg);
+       writel(reg, &dsi->cmd1);
+
+	   reg =  readl(&dsi->phy_ctrl1) & ~((1<<1) | (1<<2)); 
+	    writel(reg, &dsi->phy_ctrl1);	   
+}
+
+void dsi_set_dphy(struct pxa168fb_info *fbi)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	int ui, lpx_clk, lpx_time, ta_get, ta_go, wakeup, reg;
+	int hs_prep, hs_zero, hs_trail, hs_exit, ck_zero, ck_trail, ck_exit;
+
+	ui = 1000/dsi_hsclk + 1;
+	pr_debug("ui:%d\n", ui);
+
+	lpx_clk = (phy.lpx_constant + phy.lpx_ui * ui) / DSI_ESC_CLK_T;
+	lpx_time = (lpx_clk + 1) * DSI_ESC_CLK_T;
+	pr_debug("lpx_clk:%d, condition (TIME_LPX:%d > 50)\n",
+		lpx_clk, lpx_time);
+
+	/* Below is for NT35451 */
+	ta_get = lpx_time * 5 / DSI_ESC_CLK_T - 1;
+	ta_go = lpx_time * 4 / DSI_ESC_CLK_T - 1;
+	pr_debug("ta_get:%d, condition (TIME_TA_GET:%d == 5*TIME_LPX:%d)\n",
+		ta_get, (ta_get + 1) * DSI_ESC_CLK_T, lpx_time * 5);
+	pr_debug("ta_go:%d, condition (TIME_TA_GO:%d == 4*TIME_LPX:%d)\n",
+		ta_go, (ta_go + 1) * DSI_ESC_CLK_T, lpx_time * 4);
+
+	wakeup = phy.wakeup_constant;
+	wakeup = wakeup / DSI_ESC_CLK_T + 1;
+	pr_debug("wakeup:%d, condition (WAKEUP:%d > MIN:%d)\n",
+		wakeup, (wakeup + 1) * DSI_ESC_CLK_T, 1000000);
+
+	hs_prep = phy.hs_prep_constant + phy.hs_prep_ui * ui;
+	hs_prep = hs_prep / DSI_ESC_CLK_T + 1;
+	pr_debug("hs_prep:%d, condition (HS_PREP_MAX:%d > HS_PREP:%d "
+		"> HS_PREP_MIN:%d)\n", hs_prep, 85 + 6 * ui,
+		(hs_prep + 1) * DSI_ESC_CLK_T, 40 + 4 * ui);
+
+	/* Our hardware added 3-byte clk automatically.
+	 * 3-byte 3 * 8 * ui.
+	 */
+	hs_zero = phy.hs_zero_constant + phy.hs_zero_ui * ui -
+		(hs_prep + 1) * DSI_ESC_CLK_T;
+	hs_zero = (hs_zero - (3 * ui << 3)) / DSI_ESC_CLK_T + 4;
+	if (hs_zero < 0)
+		hs_zero = 0;
+	pr_debug("hs_zero:%d, condition (HS_ZERO + HS_PREP:%d > SUM_MIN:%d)\n",
+		hs_zero, (hs_zero - 2) * DSI_ESC_CLK_T + 24 * ui +
+		(hs_prep + 1) * DSI_ESC_CLK_T, 145 + 10 * ui);
+
+	hs_trail = phy.hs_trail_constant + phy.hs_trail_ui * ui;
+	hs_trail = hs_trail / DSI_ESC_CLK_T + 1;
+	hs_trail -= 3;
+	pr_debug("hs_trail:%d, condition (HS_TRAIL:%d > MIN1:%d / MIN2:%d "
+		"/ MIN3:%d)\n", hs_trail, (hs_trail + 1) * DSI_ESC_CLK_T,
+		8 * ui, 60 + 4 * ui, 64 * ui);
+
+	hs_exit = phy.hs_exit_constant + phy.hs_exit_ui * ui;
+	hs_exit = hs_exit / DSI_ESC_CLK_T + 1;
+	pr_debug("hs_exit:%d, condition (HS_EXIT:%d > MIN:%d)\n",
+		hs_exit, (hs_exit + 1) * DSI_ESC_CLK_T, 100);
+
+	ck_zero = phy.ck_zero_constant + phy.ck_zero_ui * ui -
+		(hs_prep + 1) * DSI_ESC_CLK_T;
+	ck_zero = ck_zero / DSI_ESC_CLK_T + 1;
+	pr_debug("ck_zero:%d, condition (CK_ZERO + CK_PREP:%d > SUM_MIN:%d)\n",
+		ck_zero, (ck_zero + 1) * DSI_ESC_CLK_T +
+		(hs_prep + 1) * DSI_ESC_CLK_T, 300);
+
+	ck_trail = phy.ck_trail_constant + phy.ck_trail_ui * ui;
+	ck_trail = ck_trail / DSI_ESC_CLK_T + 1;
+	pr_debug("ck_trail:%d, condition (CK_TRIAL:%d > MIN:%d)\n",
+		ck_trail, (ck_trail + 1) * DSI_ESC_CLK_T, 60);
+
+	ck_exit = hs_exit;
+	pr_debug("ck_exit:%d\n", ck_exit);
+
+	/* bandgap ref enable */
+	reg = readl(&dsi->phy_rcomp0);
+	reg |= (1 << 9);
+	writel(reg, &dsi->phy_rcomp0);
+
+	/* timing_0 */
+	reg = (hs_exit << DSI_PHY_TIME_0_CFG_CSR_TIME_HS_EXIT_SHIFT)
+		| (hs_trail << DSI_PHY_TIME_0_CFG_CSR_TIME_HS_TRAIL_SHIFT)
+		| (hs_zero << DSI_PHY_TIME_0_CDG_CSR_TIME_HS_ZERO_SHIFT)
+		| (hs_prep);
+	writel(reg, &dsi->phy_timing0);
+
+	reg = (ta_get << DSI_PHY_TIME_1_CFG_CSR_TIME_TA_GET_SHIFT)
+		| (ta_go << DSI_PHY_TIME_1_CFG_CSR_TIME_TA_GO_SHIFT)
+		| wakeup;
+	writel(reg, &dsi->phy_timing1);
+
+	reg = (ck_exit << DSI_PHY_TIME_2_CFG_CSR_TIME_CK_EXIT_SHIFT)
+		| (ck_trail << DSI_PHY_TIME_2_CFG_CSR_TIME_CK_TRAIL_SHIFT)
+		| (ck_zero << DSI_PHY_TIME_2_CFG_CSR_TIME_CK_ZERO_SHIFT)
+		| lpx_clk;
+	writel(reg, &dsi->phy_timing2);
+
+
+	reg = (lpx_clk << DSI_PHY_TIME_3_CFG_CSR_TIME_LPX_SHIFT) | \
+	      phy.req_ready;
+	writel(reg, &dsi->phy_timing3);
+
+	/* calculated timing on brownstone:
+	 * DSI_PHY_TIME_0 0x06080204
+	 * DSI_PHY_TIME_1 0x6d2bfff0
+	 * DSI_PHY_TIME_2 0x603130a
+	 * DSI_PHY_TIME_3 0xa3c
+	 */
+}
+
+
+void dsi_reset_dsi_module(struct pxa168fb_info *fbi)
+{
+
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	volatile unsigned int reg;
+
+	
+
+	writel(0x80000000, &dsi->ctrl0);
+	mdelay(1);
+	writel(0, &dsi->ctrl0);
+
+}
+void dsi_reset(struct pxa168fb_info *fbi, int hold)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	volatile unsigned int reg;
+
+	pr_debug("%s\n", __func__);
+	writel(0x0, &dsi->ctrl0);
+	reg = readl(&dsi->ctrl0);
+	reg |= DSI_CTRL_0_CFG_SOFT_RST | DSI_CTRL_0_CFG_SOFT_RST_REG;
+
+	if (!hold) {
+		writel(reg, &dsi->ctrl0);
+		reg &= ~(DSI_CTRL_0_CFG_SOFT_RST | DSI_CTRL_0_CFG_SOFT_RST_REG);
+		mdelay(1);
+	}
+	writel(reg, &dsi->ctrl0);
+}
+
+void dsi_set_controller(struct pxa168fb_info *fbi)
+{
+	struct fb_var_screeninfo *var = &(fbi->fb_info->var);
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	struct dsi_lcd_regs *dsi_lcd = &dsi->lcd1;
+	unsigned hsync_b, hbp_b, hact_b, hex_b, hfp_b, httl_b;
+	unsigned hsync, hbp, hact, hfp, httl, h_total, v_total;
+	unsigned hsa_wc, hbp_wc, hact_wc, hex_wc, hfp_wc, hlp_wc;
+	int bpp = di->bpp, hss_bcnt = 4, hse_bct = 4, lgp_over_head = 6, reg;
+
+	if (di->id & 2)
+		dsi_lcd = &dsi->lcd2;
+	pr_debug("%s dsi %d lanes %d burst_mode %d bpp %d\n",
+		__func__, di->id, di->lanes, di->burst_mode, bpp);
+
+	h_total = var->xres + var->left_margin +
+		 var->right_margin + var->hsync_len;
+	v_total = var->yres + mi->last_dummy_lines + var->upper_margin +
+		 var->lower_margin + var->vsync_len;
+
+	hact_b = to_dsi_bcnt(var->xres, bpp);
+	hfp_b = to_dsi_bcnt(var->right_margin, bpp);
+	hbp_b = to_dsi_bcnt(var->left_margin, bpp);
+	hsync_b = to_dsi_bcnt(var->hsync_len, bpp);
+	hex_b = to_dsi_bcnt(dsi_ex_pixel_cnt, bpp);
+	httl_b = hact_b + hsync_b + hfp_b + hbp_b + hex_b;
+
+	hact = hact_b / di->lanes;
+	hfp = hfp_b / di->lanes;
+	hbp = hbp_b / di->lanes;
+	hsync = hsync_b / di->lanes;
+	httl = hact + hfp + hbp + hsync;
+
+	/* word count in the unit of byte */
+	hsa_wc = (di->burst_mode == DSI_BURST_MODE_SYNC_PULSE) ? \
+		(hsync_b - hss_bcnt - lgp_over_head) : 0;
+
+	/* Hse is with backporch */
+	hbp_wc = (di->burst_mode == DSI_BURST_MODE_SYNC_PULSE) ? \
+		(hbp_b - hse_bct - lgp_over_head) \
+		: (hsync_b + hbp_b - hss_bcnt - lgp_over_head);
+
+	hfp_wc = ((di->burst_mode == DSI_BURST_MODE_BURST) && \
+		(dsi_hex_en == 0)) ? \
+		(hfp_b + hex_b - lgp_over_head - lgp_over_head) : \
+		(hfp_b - lgp_over_head - lgp_over_head);
+
+	hact_wc =  ((var->xres) * bpp) >> 3;
+
+	/* disable Hex currently */
+	hex_wc = 0;
+
+	/*  There is no hlp with active data segment.  */
+	hlp_wc = (di->burst_mode == DSI_BURST_MODE_SYNC_PULSE) ? \
+		(httl_b - hsync_b - hse_bct - lgp_over_head) : \
+		(httl_b - hss_bcnt - lgp_over_head);
+
+	/* FIXME - need to double check the (*3) is bytes_per_pixel from
+	 * input data or output to panel */
+	/* dsi_lane_enable - Set according to specified DSI lane count */
+	writel(dsi_lane[di->lanes] << DSI_PHY_CTRL_2_CFG_CSR_LANE_EN_SHIFT,
+		 &dsi->phy_ctrl2);
+	writel(dsi_lane[di->lanes] << DSI_CPU_CMD_1_CFG_TXLP_LPDT_SHIFT,
+		 &dsi->cmd1);
+
+	/* SET UP LCD1 TIMING REGISTERS FOR DSI BUS */
+	/* NOTE: Some register values were obtained by trial and error */
+	writel((hact << 16) | httl, &dsi_lcd->timing0);
+	writel((hsync << 16) | hbp, &dsi_lcd->timing1);
+	/*
+	 * For now the active size is set really low (we'll use 10) to allow
+	 * the hardware to attain V Sync. Once the DSI bus is up and running,
+	 * the final value will be put in place for the active size (this is
+	 * done below). In a later stepping of the processor this workaround
+	 * will not be required.
+	 */
+	writel(((var->yres + mi->last_dummy_lines)<<16) | (v_total), &dsi_lcd->timing2);
+
+	writel(((var->vsync_len) << 16) | (var->upper_margin),
+		 &dsi_lcd->timing3);
+
+	/* SET UP LCD1 WORD COUNT REGISTERS FOR DSI BUS */
+	/* Set up for word(byte) count register 0 */
+	writel((hbp_wc << 16) | hsa_wc, &dsi_lcd->wc0);
+	writel((hfp_wc << 16) | hact_wc, &dsi_lcd->wc1);
+	writel((hex_wc << 16) | hlp_wc, &dsi_lcd->wc2);
+	/* calculated value on brownstone:
+	 * WC0: 0x1a0000
+	 * WC1: 0x1500f00
+	 * WC2: 0x1076 */
+
+	/* Configure LCD control register 1 FOR DSI BUS */
+	reg = ((di->rgb_mode << DSI_LCD2_CTRL_1_CFG_L1_RGB_TYPE_SHIFT)
+	  | (di->burst_mode << DSI_LCD1_CTRL_1_CFG_L1_BURST_MODE_SHIFT)
+	  | (di->lpm_line_en ? DSI_LCD1_CTRL_1_CFG_L1_LPM_LINE_EN : 0)
+	  | (di->lpm_frame_en ? DSI_LCD1_CTRL_1_CFG_L1_LPM_FRAME_EN : 0)
+	  | (di->last_line_turn ? DSI_LCD1_CTRL_1_CFG_L1_LAST_LINE_TURN : 0)
+	  | (di->hex_slot_en ? 0 : 0)   /* disable Hex slot */
+	  | (di->all_slot_en ? 0 : 0)   /* disable all slots */
+	  | (di->hbp_en ? DSI_LCD1_CTRL_1_CFG_L1_HBP_PKT_EN : 0)
+	  | (di->hact_en ? DSI_LCD1_CTRL_1_CFG_L1_HACT_PKT_EN : 0)
+	  | (di->hfp_en ? DSI_LCD1_CTRL_1_CFG_L1_HFP_PKT_EN : 0)
+	  | (di->hex_en ? 0 : 0)      /* Hex packet is disabled */
+	  | (di->hlp_en ? DSI_LCD1_CTRL_1_CFG_L1_HLP_PKT_EN : 0));
+
+	reg |= (di->burst_mode == DSI_BURST_MODE_SYNC_PULSE) ? \
+		(((di->hsa_en) ? DSI_LCD1_CTRL_1_CFG_L1_HSA_PKT_EN : 0)
+		| (DSI_LCD1_CTRL_1_CFG_L1_HSE_PKT_EN))  /* Hse is eabled */
+		:
+		(((di->hsa_en) ? 0 : 0)   /* Hsa packet is disabled */
+		| ((di->hse_en) ? 0 : 0)); /* Hse packet is disabled */
+
+	reg |=  DSI_LCD1_CTRL_1_CFG_L1_VSYNC_RST_EN;
+	writel(reg, &dsi_lcd->ctrl1);
+
+	/*Start the transfer of LCD data over the DSI bus*/
+	/* DSI_CTRL_1 */
+	reg = readl(&dsi->ctrl1);
+	reg &= ~(DSI_CTRL_1_CFG_LCD2_VCH_NO_MASK |
+		 DSI_CTRL_1_CFG_LCD1_VCH_NO_MASK);
+	reg |= 0x1 << ((di->id & 1) ? DSI_CTRL_1_CFG_LCD2_VCH_NO_SHIFT :
+		 DSI_CTRL_1_CFG_LCD1_VCH_NO_SHIFT);
+
+	reg &= ~(DSI_CTRL_1_CFG_EOTP);
+	if (di->eotp_en)
+		reg |= DSI_CTRL_1_CFG_EOTP;	/* EOTP */
+
+	writel(reg, &dsi->ctrl1);
+
+	/* DSI_CTRL_0 */
+	reg = (di->master_mode ? 0 : DSI_CTRL_0_CFG_LCD1_SLV) |
+		DSI_CTRL_0_CFG_LCD1_TX_EN | DSI_CTRL_0_CFG_LCD1_EN;
+	if (di->id & 2)
+		reg = reg << 1;
+	writel(reg, &dsi->ctrl0);
+
+	writel(((var->yres + mi->last_dummy_lines)<<16) | (v_total), &dsi_lcd->timing2);
+}
+
+void dsi_set_panel_interface(struct pxa168fb_info *fbi, bool on)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	int reg;
+	printk("zlp get dphy_ctrl2=%x\n",readl(&dsi->phy_ctrl2));
+	reg = readl(&dsi->ctrl0);
+	if (on)
+		reg |= DSI_CTRL_0_CFG_LCD1_EN << ((di->id & 2) ? 1 : 0);
+	else
+		reg &= ~(DSI_CTRL_0_CFG_LCD1_EN << ((di->id & 2) ? 1 : 0));
+	writel(reg, &dsi->ctrl0);
+}
+void dsi_set_panel_intf(struct pxa168fb_info *fbi, bool on)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	int reg;
+
+	reg = readl(&dsi->ctrl0);
+	if (on)
+		reg |= DSI_CTRL_0_CFG_LCD1_EN << ((di->id & 2) ? 1 : 0);
+	else
+		reg &= ~(DSI_CTRL_0_CFG_LCD1_EN << ((di->id & 2) ? 1 : 0));
+	writel(reg, &dsi->ctrl0);
+}
+
+void set_dsi_low_power_mode(struct pxa168fb_info *fbi)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	u32 reg = readl(&dsi->phy_ctrl2);
+
+	reg |= (2 << 4);
+	writel(reg, &dsi->phy_ctrl2);
+
+	/* enable data lane data0*/
+	reg &= ~(0xf << 4);
+	reg |= (1 << 4);
+	writel(reg, &dsi->phy_ctrl2);
+
+	/* LPDT TX enabled for data0 */
+	reg = readl(&dsi->cmd1);
+	reg &= ~(0xf << 20);
+	reg |= 1 << DSI_CPU_CMD_1_CFG_TXLP_LPDT_SHIFT;
+	writel(reg, &dsi->cmd1);
+}
+
+static void print_ack_errors(unsigned int packet)
+{
+	int i;
+	char ack_error_info[16][30] = {
+	"SoT Error",
+	/*
+	 * may be caused by number of lanes used
+	 * in both lane turn and phy lanes
+	 */
+	"SoT Sync Error",
+	"EoT Sync Error",
+	"Esc Mode Ent Cmd Err",
+	"LP Transmit Sync Err",
+	"HS Rcv TO Err",
+	"False Control Err",
+	"Reserved",
+	"ECC Error, 1Bit",
+	"ECC Error, multi-bit",
+	"Chksm Err -Lg Packt",
+	"DSI DT Not Recognized",
+	"DSI VC ID Invalid",
+	"Invalid Transmission Length",
+	"Reserved",
+	"DSI Protcl Err" };
+
+	pr_info("Ack error packet = 0x%x", packet);
+	for (i = 0; i < 15; i++) {
+		if (packet & (1 << i))
+			pr_err("\t\tBit %d = %s", i, ack_error_info[i]);
+	}
+}
+
+void dsi_cmd_array_rx_process(struct pxa168fb_info *fbi, struct dsi_buf *dbuf)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	u8 parameter[DSI_MAX_DATA_BYTES];
+	u32 i, rx_reg, timeout, tmp, packet,
+	    data_pointer, packet_count, byte_count;
+
+	memset(dbuf, 0x0, sizeof(struct dsi_buf));
+	timeout = 1000;
+	do {
+		timeout--;
+		tmp = readl(&dsi->irq_status);
+	} while (((tmp & 0x4) == 0) && timeout);
+	if (!timeout)
+		pr_err("dsi didn't receive packet, irq status 0x%x\n",
+				readl(&dsi->irq_status));
+	if (tmp & IRQ_RX_TRG2)
+		pr_debug("ACK receiveddf\n");
+	if (tmp & IRQ_RX_TRG1)
+		pr_debug("TE trigger received\n");
+	if (tmp & IRQ_RX_ERR) {
+		pr_err("ACK with error report\n");
+		tmp = readl(&dsi->rx0_header);
+		print_ack_errors(tmp);
+	}
+
+	packet = readl(&dsi->rx0_status);
+	if (packet & RX_PKT0_ST_VLD)
+		pr_debug("Rx packet 0 status valid, 0x%x\n", packet);
+	if (packet & RX_PKT0_ST_SP)
+		pr_debug("Rx packet is short packet\n");
+	else
+		pr_debug("Rx packet is long packet\n");
+
+	data_pointer = (packet & RX_PKT0_PKT_PTR_MASK) >> RX_PKT0_PKT_PTR_SHIFT;
+	pr_debug("Rx FIFO data pointer %x\n", data_pointer);
+	tmp = readl(&dsi->rx_ctrl1);
+	packet_count = (tmp & RX_PKT_CNT_MASK) >> RX_PKT_CNT_SHIFT;
+	byte_count = tmp & RX_PKT_BCNT_MASK;
+	pr_debug("Rx FIFO packet count %d, byte count %d\n",
+			packet_count, byte_count);
+
+	memset(parameter, 0x00, byte_count);
+	for (i = data_pointer; i < data_pointer + byte_count; i++) {
+		rx_reg = readl(&dsi->rx_ctrl);
+		rx_reg &= ~RX_PKT_RD_PTR_MASK;
+		rx_reg |= RX_PKT_RD_REQ | (i << RX_PKT_RD_PTR_SHIFT);
+		
+		writel(rx_reg, &dsi->rx_ctrl);
+		timeout = 10000;
+		do {
+			timeout--;
+			rx_reg = readl(&dsi->rx_ctrl);
+		} while (rx_reg & RX_PKT_RD_REQ && timeout);
+		if (!timeout)
+			pr_err("Rx packet FIFO read request not assert\n");
+		parameter[i - data_pointer] = rx_reg & 0xff;
+	}
+	switch (parameter[0]) {
+	case DSI_DI_ACK_ERR_RESP:
+		pr_err("Acknowledge with erro report\n");
+		break;
+	case DSI_DI_EOTP:
+		pr_err("End of Transmission packet\n");
+		break;
+	case DSI_DI_GEN_READ1_RESP:
+	case DSI_DI_DCS_READ1_RESP:
+		dbuf->data_type = parameter[0];
+		dbuf->length = 1;
+		memcpy(dbuf->data, &parameter[1], dbuf->length);
+		break;
+	case DSI_DI_GEN_READ2_RESP:
+	case DSI_DI_DCS_READ2_RESP:
+		dbuf->data_type = parameter[0];
+		dbuf->length = 2;
+		memcpy(dbuf->data, &parameter[1], dbuf->length);
+		break;
+	case DSI_DI_GEN_LREAD_RESP:
+	case DSI_DI_DCS_LREAD_RESP:
+		dbuf->data_type = parameter[0];
+		dbuf->length = (parameter[2] << 8) | parameter[1];
+		memcpy(dbuf->data, &parameter[4], dbuf->length);
+		break;
+	}
+}
+
+void dsi_cmd_array_rx(struct pxa168fb_info *fbi, struct dsi_buf *dbuf,
+		struct dsi_cmd_desc cmds[], int count)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	u8 parameter[DSI_MAX_DATA_BYTES];
+	u32 i, rx_reg, timeout, tmp, packet,
+	    data_pointer, packet_count, byte_count;
+
+	dsi_cmd_array_tx(fbi, cmds, count);
+	dsi_cmd_array_rx_process(fbi,dbuf);
+}
+
+int dsi_read_data(struct pxa168fb_info *fbi, u8 addr)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	u8 parameter[DSI_MAX_DATA_BYTES], loop;
+	u32 rx_reg, count, ecc, tmp, packet,
+	    data_pointer, packet_count, byte_count;
+	dsi_set_panel_intf(fbi, 0);
+	set_dsi_low_power_mode(fbi);
+	memset(parameter, 0x00, 4);
+	parameter[0] = 0x37; /* DSI_DI_SMRPS */
+	parameter[1] = 0x01;
+	parameter[2] = 0x00;
+	parameter[3] = calculate_ecc(parameter);
+	dsi_send_cmds(fbi, parameter, 4, 1);
+	parameter[0] = 0x06; /* DSI_DI_READ */
+	parameter[1] = addr;
+	parameter[2] = 0x00;
+	parameter[3] = calculate_ecc(parameter);
+	dsi_send_cmds(fbi, parameter, 4, 1);
+	tmp = readl(&dsi->phy_ctrl2) & ~(0xf);
+	tmp |= 0x1;
+	writel(tmp, &dsi->phy_ctrl2);
+	count = 10000;
+	do {
+		count--;
+		tmp = readl(&dsi->phy_ctrl2);
+	} while (((tmp & 0xf) == 0x1) && count);
+	if (!count)
+		pr_err("dphy bus not turn around phy_ctrl2 0x%x\n",
+				readl(&dsi->phy_ctrl2)&0xf);
+	count = 10000;
+	do {
+		count--;
+		tmp = readl(&dsi->irq_status);
+	} while (((tmp & 0x4) == 0) && count);
+	if (!count)
+		pr_err("dsi didn't receive packet, irq status 0x%x\n",
+				readl(&dsi->irq_status));
+	if (tmp & (0x1 << 6))
+		pr_debug("ACK received(VALUE=0x84)\n");
+	if (tmp & (0x1 << 5))
+		pr_debug("TE trigger received(VALUE=0xba)\n");
+	if (tmp & (0x1 << 25)) {
+		pr_err("ACK with error report\n");
+		tmp = readl(&dsi->rx0_header);
+		print_ack_errors(tmp);
+	}
+	packet = readl(&dsi->rx0_status);
+	if (packet & 0x80000000)
+		pr_debug("Rx packet 0 status valid, 0x%x\n", packet);
+	if (packet & (0x1 << 24))
+		pr_debug("Rx packet is short packet\n");
+	else
+		pr_debug("Rx packet is long packet\n");
+	data_pointer = (packet & (0xf << 16)) >> 16;
+	pr_debug("Rx FIFO data pointer %x\n", data_pointer);
+	tmp = readl(&dsi->rx_ctrl1);
+	packet_count = (tmp & 0xf00) >> 8;
+	byte_count = tmp & 0xff;
+	pr_debug("Rx FIFO packet count %d, byte count %x\n",
+			packet_count, byte_count);
+	memset(parameter, 0x00, byte_count);
+	for (loop = data_pointer; loop < data_pointer + byte_count; loop++) {
+		rx_reg = readl(&dsi->rx_ctrl);
+		rx_reg &= ~(0x3f << 16);
+		rx_reg |= (1 << 31) | (loop << 16);
+		writel(rx_reg, &dsi->rx_ctrl);
+		count = 10000;
+		do {
+			count--;
+			rx_reg = readl(&dsi->rx_ctrl);
+		} while (rx_reg & (1 << 31) && count);
+		if (!count)
+			pr_err("Rx packet FIFO read request not assert\n");
+		parameter[loop - data_pointer] = rx_reg & 0xff;
+	}
+	ecc = calculate_ecc(parameter);
+	pr_info("DSI receive data:\n");
+	pr_info("rx_data_type  rx_dcs  rx_parameter  rx_ecc  ecc\n");
+	pr_info("0x%x          0x%x     0x%x          0x%x    0x%x",
+		parameter[0], parameter[1], parameter[2], parameter[3], ecc);
+	for (loop = 0; loop < (byte_count - 4); loop++)
+		pr_info("0x%x \t ", parameter[loop]);
+	pr_info("\n");
+	if (ecc != parameter[3]) {
+		pr_info("ecc error, rx_ecc: 0x%x, cal_ecc: 0x%x!",
+				parameter[3], ecc);
+		return -1;
+	}
+	/* put all lanes to LP-11 state  */
+	dsi_lanes_enable(fbi, 1);
+	dsi_set_panel_intf(fbi, 1);
+	return 0;
+}
+static int dsi_dump(struct pxa168fb_info *fbi, int f, char *buf, int s)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi;
+	int dsi_base;
+
+	if (!di) {
+		pr_err("%s: no dsi info available\n", __func__);
+		return s;
+	}
+	dsi = (struct dsi_regs *)di->regs;
+	dsi_base = (int)(&dsi->ctrl0);
+
+	mvdisp_dump(f, "dsi_info: ch %d lanes %d bpp %d\n\n", di->id,
+			di->lanes, di->bpp);
+
+	mvdisp_dump(f, "dsi regs base 0x%p\n", dsi);
+	mvdisp_dump(f, "\tctrl0      (@%3x):\t0x%x\n",
+		(int)(&dsi->ctrl0) - dsi_base, readl(&dsi->ctrl0));
+	mvdisp_dump(f, "\tctrl1      (@%3x):\t0x%x\n",
+		(int)(&dsi->ctrl1) - dsi_base, readl(&dsi->ctrl1));
+	mvdisp_dump(f, "\tirq_status (@%3x):\t0x%x\n",
+		(int)(&dsi->irq_status) - dsi_base, readl(&dsi->irq_status));
+	mvdisp_dump(f, "\tirq_mask   (@%3x):\t0x%x\n",
+		(int)(&dsi->irq_mask) - dsi_base, readl(&dsi->irq_mask));
+	mvdisp_dump(f, "\tcmd0       (@%3x):\t0x%x\n",
+		(int)(&dsi->cmd0) - dsi_base, readl(&dsi->cmd0));
+	mvdisp_dump(f, "\tcmd1       (@%3x):\t0x%x\n",
+		(int)(&dsi->cmd1) - dsi_base, readl(&dsi->cmd1));
+	mvdisp_dump(f, "\tcmd2       (@%3x):\t0x%x\n",
+		(int)(&dsi->cmd2) - dsi_base, readl(&dsi->cmd2));
+	mvdisp_dump(f, "\tcmd3       (@%3x):\t0x%x\n",
+		(int)(&dsi->cmd3) - dsi_base, readl(&dsi->cmd3));
+	mvdisp_dump(f, "\tdat0       (@%3x):\t0x%x\n",
+		(int)(&dsi->dat0) - dsi_base, readl(&dsi->dat0));
+	mvdisp_dump(f, "\tstatus0    (@%3x):\t0x%x\n",
+		(int)(&dsi->status0) - dsi_base, readl(&dsi->status0));
+	mvdisp_dump(f, "\tstatus1    (@%3x):\t0x%x\n",
+		(int)(&dsi->status1) - dsi_base, readl(&dsi->status1));
+	mvdisp_dump(f, "\tstatus2    (@%3x):\t0x%x\n",
+		(int)(&dsi->status2) - dsi_base, readl(&dsi->status2));
+	mvdisp_dump(f, "\tstatus3    (@%3x):\t0x%x\n",
+		(int)(&dsi->status3) - dsi_base, readl(&dsi->status3));
+	mvdisp_dump(f, "\tstatus4    (@%3x):\t0x%x\n",
+		(int)(&dsi->status4) - dsi_base, readl(&dsi->status4));
+	mvdisp_dump(f, "\tsmt_cmd    (@%3x):\t0x%x\n",
+		(int)(&dsi->smt_cmd) - dsi_base, readl(&dsi->smt_cmd));
+	mvdisp_dump(f, "\tsmt_ctrl0  (@%3x):\t0x%x\n",
+		(int)(&dsi->smt_ctrl0) - dsi_base, readl(&dsi->smt_ctrl0));
+	mvdisp_dump(f, "\tsmt_ctrl1  (@%3x):\t0x%x\n",
+		(int)(&dsi->smt_ctrl1) - dsi_base, readl(&dsi->smt_ctrl1));
+	mvdisp_dump(f, "\trx0_status (@%3x):\t0x%x\n",
+		(int)(&dsi->rx0_status) - dsi_base, readl(&dsi->rx0_status));
+	mvdisp_dump(f, "\trx0_header (@%3x):\t0x%x\n",
+		(int)(&dsi->rx0_header) - dsi_base, readl(&dsi->rx0_header));
+	mvdisp_dump(f, "\trx1_status (@%3x):\t0x%x\n",
+		(int)(&dsi->rx1_status) - dsi_base, readl(&dsi->rx1_status));
+	mvdisp_dump(f, "\trx1_header (@%3x):\t0x%x\n",
+		(int)(&dsi->rx1_header) - dsi_base, readl(&dsi->rx1_header));
+	mvdisp_dump(f, "\trx_ctrl    (@%3x):\t0x%x\n",
+		(int)(&dsi->rx_ctrl) - dsi_base, readl(&dsi->rx_ctrl));
+	mvdisp_dump(f, "\trx_ctrl1   (@%3x):\t0x%x\n",
+		(int)(&dsi->rx_ctrl1) - dsi_base, readl(&dsi->rx_ctrl1));
+	mvdisp_dump(f, "\trx2_status (@%3x):\t0x%x\n",
+		(int)(&dsi->rx2_status) - dsi_base, readl(&dsi->rx2_status));
+	mvdisp_dump(f, "\trx2_header (@%3x):\t0x%x\n",
+		(int)(&dsi->rx2_header) - dsi_base, readl(&dsi->rx2_header));
+	mvdisp_dump(f, "\tphy_ctrl1  (@%3x):\t0x%x\n",
+		(int)(&dsi->phy_ctrl1) - dsi_base, readl(&dsi->phy_ctrl1));
+	mvdisp_dump(f, "\tphy_ctrl2  (@%3x):\t0x%x\n",
+		(int)(&dsi->phy_ctrl2) - dsi_base, readl(&dsi->phy_ctrl2));
+	mvdisp_dump(f, "\tphy_ctrl3  (@%3x):\t0x%x\n",
+		(int)(&dsi->phy_ctrl3) - dsi_base, readl(&dsi->phy_ctrl3));
+	mvdisp_dump(f, "\tphy_status0(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_status0) - dsi_base, readl(&dsi->phy_status0));
+	mvdisp_dump(f, "\tphy_status1(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_status1) - dsi_base, readl(&dsi->phy_status1));
+	mvdisp_dump(f, "\tphy_status2(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_status2) - dsi_base, readl(&dsi->phy_status2));
+	mvdisp_dump(f, "\tphy_rcomp0 (@%3x):\t0x%x\n",
+		(int)(&dsi->phy_rcomp0) - dsi_base, readl(&dsi->phy_rcomp0));
+	mvdisp_dump(f, "\tphy_timing0(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_timing0) - dsi_base, readl(&dsi->phy_timing0));
+	mvdisp_dump(f, "\tphy_timing1(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_timing1) - dsi_base, readl(&dsi->phy_timing1));
+	mvdisp_dump(f, "\tphy_timing2(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_timing2) - dsi_base, readl(&dsi->phy_timing2));
+	mvdisp_dump(f, "\tphy_timing3(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_timing3) - dsi_base, readl(&dsi->phy_timing3));
+	mvdisp_dump(f, "\tphy_code_0 (@%3x):\t0x%x\n",
+		(int)(&dsi->phy_code_0) - dsi_base, readl(&dsi->phy_code_0));
+	mvdisp_dump(f, "\tphy_code_1 (@%3x):\t0x%x\n",
+		(int)(&dsi->phy_code_1) - dsi_base, readl(&dsi->phy_code_1));
+	mvdisp_dump(f, "\tmem_ctrl   (@%3x):\t0x%x\n",
+		(int)(&dsi->mem_ctrl) - dsi_base, readl(&dsi->mem_ctrl));
+	mvdisp_dump(f, "\ttx_timer   (@%3x):\t0x%x\n",
+		(int)(&dsi->tx_timer) - dsi_base, readl(&dsi->tx_timer));
+	mvdisp_dump(f, "\trx_timer   (@%3x):\t0x%x\n",
+		(int)(&dsi->rx_timer) - dsi_base, readl(&dsi->rx_timer));
+	mvdisp_dump(f, "\tturn_timer (@%3x):\t0x%x\n",
+		(int)(&dsi->turn_timer) - dsi_base, readl(&dsi->turn_timer));
+
+	mvdisp_dump(f, "\nlcd1 regs\n");
+	mvdisp_dump(f, "\tctrl0     (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.ctrl0) - dsi_base, readl(&dsi->lcd1.ctrl0));
+	mvdisp_dump(f, "\tctrl1     (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.ctrl1) - dsi_base, readl(&dsi->lcd1.ctrl1));
+	mvdisp_dump(f, "\ttiming0   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.timing0) - dsi_base,
+		readl(&dsi->lcd1.timing0));
+	mvdisp_dump(f, "\ttiming1   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.timing1) - dsi_base,
+		readl(&dsi->lcd1.timing1));
+	mvdisp_dump(f, "\ttiming2   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.timing2) - dsi_base,
+		readl(&dsi->lcd1.timing2));
+	mvdisp_dump(f, "\ttiming3   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.timing3) - dsi_base,
+		readl(&dsi->lcd1.timing3));
+	mvdisp_dump(f, "\twc0       (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.wc0) - dsi_base, readl(&dsi->lcd1.wc0));
+	mvdisp_dump(f, "\twc1       (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.wc1) - dsi_base, readl(&dsi->lcd1.wc1));
+	mvdisp_dump(f, "\twc2       (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.wc2) - dsi_base, readl(&dsi->lcd1.wc2));
+	mvdisp_dump(f, "\tslot_cnt0 (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.slot_cnt0) - dsi_base,
+		readl(&dsi->lcd1.slot_cnt0));
+	mvdisp_dump(f, "\tslot_cnt1 (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.slot_cnt1) - dsi_base,
+		readl(&dsi->lcd1.slot_cnt1));
+	mvdisp_dump(f, "\tstatus_0  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.status_0) - dsi_base,
+		readl(&dsi->lcd1.status_0));
+	mvdisp_dump(f, "\tstatus_1  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.status_1) - dsi_base,
+		readl(&dsi->lcd1.status_1));
+	mvdisp_dump(f, "\tstatus_2  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.status_2) - dsi_base,
+		readl(&dsi->lcd1.status_2));
+	mvdisp_dump(f, "\tstatus_3  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.status_3) - dsi_base,
+		readl(&dsi->lcd1.status_3));
+	mvdisp_dump(f, "\tstatus_4  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.status_4) - dsi_base,
+		readl(&dsi->lcd1.status_4));
+
+	mvdisp_dump(f, "\nlcd2 regs\n");
+	mvdisp_dump(f, "\tctrl0     (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.ctrl0) - dsi_base,
+		readl(&dsi->lcd2.ctrl0));
+	mvdisp_dump(f, "\tctrl1     (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.ctrl1) - dsi_base,
+		readl(&dsi->lcd2.ctrl1));
+	mvdisp_dump(f, "\ttiming0   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.timing0) - dsi_base,
+		readl(&dsi->lcd2.timing0));
+	mvdisp_dump(f, "\ttiming1   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.timing1) - dsi_base,
+		readl(&dsi->lcd2.timing1));
+	mvdisp_dump(f, "\ttiming2   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.timing2) - dsi_base,
+		readl(&dsi->lcd2.timing2));
+	mvdisp_dump(f, "\ttiming3   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.timing3) - dsi_base,
+		readl(&dsi->lcd2.timing3));
+	mvdisp_dump(f, "\twc0       (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.wc0) - dsi_base, readl(&dsi->lcd2.wc0));
+	mvdisp_dump(f, "\twc1       (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.wc1) - dsi_base, readl(&dsi->lcd2.wc1));
+	mvdisp_dump(f, "\twc2       (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.wc2) - dsi_base, readl(&dsi->lcd2.wc2));
+	mvdisp_dump(f, "\tslot_cnt0 (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.slot_cnt0) - dsi_base,
+		readl(&dsi->lcd2.slot_cnt0));
+	mvdisp_dump(f, "\tslot_cnt1 (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.slot_cnt1) - dsi_base,
+		readl(&dsi->lcd2.slot_cnt1));
+	mvdisp_dump(f, "\tstatus_0  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.status_0) - dsi_base,
+		readl(&dsi->lcd2.status_0));
+	mvdisp_dump(f, "\tstatus_1  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.status_1) - dsi_base,
+		readl(&dsi->lcd2.status_1));
+	mvdisp_dump(f, "\tstatus_2  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.status_2) - dsi_base,
+		readl(&dsi->lcd2.status_2));
+	mvdisp_dump(f, "\tstatus_3  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.status_3) - dsi_base,
+		readl(&dsi->lcd2.status_3));
+	mvdisp_dump(f, "\tstatus_4  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.status_4) - dsi_base,
+		readl(&dsi->lcd2.status_4));
+
+	mvdisp_dump(f, "\ncommands:\n");
+	mvdisp_dump(f, " - dump all DSI controller registers\n");
+	mvdisp_dump(f, "\tcat phy\n");
+	mvdisp_dump(f, " - dump DSI register @ [offset_hex]\n");
+	mvdisp_dump(f, "\techo -0x[offset_hex] > phy\n");
+	mvdisp_dump(f, " - set DSI register @ [offset_hex] with [value_hex]\n");
+	mvdisp_dump(f, "\techo 0x[value_hex] > phy\n");
+
+	return s;
+}
+
+/* select LVDS_PHY_CTL_EXTx */
+#define lvds_ext_select(ext, tmp, reg) do {				\
+	if ((ext < 0) || (ext > 5)) {					\
+		pr_err("%s ext %d not supported\n", __func__, ext);	\
+		return 0;						\
+	}								\
+	reg = (u32)gfx_info.fbi[0]->reg_base + LVDS_PHY_CTL;		\
+	if (ext) {							\
+		/* select LVDS_PHY_CTL_EXTx */				\
+		tmp = readl(reg) & (~LVDS_PHY_EXT_MASK);		\
+		writel(tmp | (ext - 1) << LVDS_PHY_EXT_SHIFT, reg);	\
+		/* switch to LVDS_PHY_CTL_EXTx */			\
+		reg -= LVDS_PHY_CTL; reg += LVDS_PHY_CTL_EXT;		\
+	}								\
+} while (0)
+
+static u32 lvds_get(int ext)
+{
+	u32 reg, tmp;
+
+	lvds_ext_select(ext, tmp, reg);
+
+	return readl(reg);
+}
+
+static int lvds_set(int ext, u32 mask, u32 val)
+{
+	u32 reg, tmp, tmp2;
+
+	lvds_ext_select(ext, tmp, reg);
+
+	tmp = tmp2 = readl(reg);
+	tmp2 &= ~mask; tmp2 |= val;
+	if (tmp != tmp2)
+		writel(tmp2, reg);
+
+	return 0;
+}
+
+static int lvds_dump(struct pxa168fb_info *fbi, int f, char *buf, int s)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct lvds_info *lvds = (struct lvds_info *)mi->phy_info;
+	u32 reg = (u32)fbi->reg_base + LCD_2ND_BLD_CTL;
+	char *str;
+
+	switch (lvds->src) {
+	case LVDS_SRC_PN:
+		str = "PN";
+		break;
+	case LVDS_SRC_CMU:
+		str = "CMU";
+		break;
+	case LVDS_SRC_PN2:
+		str = "PN2";
+		break;
+	case LVDS_SRC_TV:
+		str = "TV";
+		break;
+	default:
+		str = "?";
+		break;
+	};
+
+	mvdisp_dump(f, "lvds_info: src %s fmt %s\n", str,
+		(lvds->fmt & LVDS_FMT_18BIT) ? "18bit" : "24bit");
+	mvdisp_dump(f, "LCD_2ND_BLD_CTL(0x%x): 0x%x\n\n",
+		reg & 0xfff, readl(reg));
+
+	mvdisp_dump(f, "LVDS_PHY_CTL: 0x%x\n", lvds_get(0));
+	mvdisp_dump(f, "        EXT1: 0x%x\n", lvds_get(1));
+	mvdisp_dump(f, "        EXT2: 0x%x\n", lvds_get(2));
+	mvdisp_dump(f, "        EXT3: 0x%x\n", lvds_get(3));
+	mvdisp_dump(f, "        EXT4: 0x%x\n", lvds_get(4));
+	mvdisp_dump(f, "        EXT5: 0x%x\n", lvds_get(5));
+
+	return s;
+}
+
+int pxa688_lvds_config(struct lvds_info *lvds)
+{
+	u32 reg = (u32)gfx_info.fbi[0]->reg_base + LCD_2ND_BLD_CTL;
+	u32 val = readl(reg) & ~(LVDS_SRC_MASK | LVDS_FMT_MASK);
+
+	val |= (lvds->src << LVDS_SRC_SHIFT) | (lvds->fmt << LVDS_FMT_SHIFT);
+	writel(val, reg);
+
+	return 0;
+}
+
+int pxa688_lvds_init(struct pxa168fb_info *fbi)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct lvds_info *lvds = (struct lvds_info *)mi->phy_info;
+	int count = 100000;
+	u32 mask, val;
+
+	/* configure lvds src and fmt */
+	pxa688_lvds_config(lvds);
+
+	/* release LVDS PHY from reset */
+	lvds_set(0, LVDS_RST, 0);
+	mdelay(1);
+
+	/* disable LVDS channel 0-5 power-down */
+	lvds_set(0, LVDS_PD_CH_MASK, 0);
+
+	/* select LVDS_PCLK instead of REFCLK as LVDS PHY clock */
+	lvds_set(0, LVDS_CLK_SEL, LVDS_CLK_SEL_LVDS_PCLK);
+
+	/* power up IP */
+	lvds_set(0, LVDS_PU_IVREF, LVDS_PU_IVREF);
+
+	/* REFDIV = 0x3, reference clock divider
+	 * FBDIV = 0xa, feedback clock divider
+	 * KVCO = 0x4, 1.7G - 1.9G */
+	mask = LVDS_REFDIV_MASK | LVDS_FBDIV_MASK | LVDS_REFDIV_MASK
+		| LVDS_CTUNE_MASK | LVDS_VREG_IVREF_MASK
+		| LVDS_VDDL_MASK | LVDS_VDDM_MASK;
+	val = (0x6 << LVDS_REFDIV_SHIFT) | (0x1 << LVDS_FBDIV_SHIFT)
+		| (0x4 << LVDS_KVCO_SHIFT | (0x2 << LVDS_CTUNE_SHIFT)
+		| (0x2 << LVDS_VREG_IVREF_SHIFT) | (0x9 << LVDS_VDDL_SHIFT)
+		| (0x1 << LVDS_VDDM_SHIFT));
+	lvds_set(3, mask, val);
+
+	/* VCO_VRNG = 0x3, LVDS PLL V to I gain control, for KVCO[3:0] = 0x4 */
+	mask = LVDS_VCO_VRNG_MASK | LVDS_ICP_MASK | LVDS_PI_EN
+		| LVDS_VCODIV_SEL_SE_MASK | LVDS_INTPI_MASK;
+	val = (0x3 << LVDS_VCO_VRNG_SHIFT) | (0x1 << LVDS_ICP_SHIFT)
+		| LVDS_PI_EN | (0xd << LVDS_VCODIV_SEL_SE_SHIFT)
+		| (0x3 << LVDS_INTPI_SHIFT);
+	lvds_set(4, mask, val);
+
+	/* enable PUPLL/PUTX to power up rest of PLL and TX */
+	lvds_set(0, LVDS_PU_TX | LVDS_PU_PLL, LVDS_PU_TX | LVDS_PU_PLL);
+
+	/* poll on lock bit until LVDS PLL locks */
+	while (!(lvds_get(0) & LVDS_PLL_LOCK) && count--);
+	if (count <= 0) {
+		pr_err("%s failed\n", __func__);
+		lvds_dump(fbi, DUMP_PRINFO, NULL, 0);
+	}
+
+	/* enable common mode feedback circuit */
+	mask = LVDS_SELLV_OP9_MASK | LVDS_SELLV_OP7_MASK | LVDS_SELLV_OP6_MASK
+		| LVDS_SELLV_TXDATA_MASK | LVDS_SELLV_TXCLK_MASK | LVDS_TX_DIF_CM_MASK
+		| LVDS_TX_DIF_AMP_MASK | LVDS_TX_TERM_EN | LVDS_TX_CMFB_EN;
+	val = (0x1 << LVDS_SELLV_OP9_SHIFT) | (0x1 << LVDS_SELLV_OP7_SHIFT)
+		| (0x1 << LVDS_SELLV_OP6_SHIFT)
+		| (0xa << LVDS_SELLV_TXDATA_SHIFT)
+		| (0xa << LVDS_SELLV_TXCLK_SHIFT)
+		| (0x3 << LVDS_TX_DIF_CM_SHIFT)
+		| (0x8 << LVDS_TX_DIF_AMP_SHIFT) | LVDS_TX_CMFB_EN;
+	lvds_set(2, mask, val);
+
+	/* Flip all the N\P pins in order to get correct display,
+	 * the pins might be inverted in the chip */
+	lvds_set(1, LVDS_POL_SWAP_MASK, 0x3f << LVDS_POL_SWAP_SHIFT);
+
+	return 0;
+}
+
+static void dsi_store(struct pxa168fb_mach_info *mi,
+	const char *buf, size_t size)
+{
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	static u32 mvdsi_reg;
+	char vol[30];
+	u32 addr, tmp;
+
+	if (size > 30) {
+		pr_err("%s size = %d > max 30 chars\n", __func__, size);
+		return;
+	}
+
+	addr = (u32)&dsi->ctrl0;
+	if ('-' == buf[0]) {
+		memcpy(vol, buf + 1, size - 1);
+		mvdsi_reg = (int)simple_strtoul(vol, NULL, 16);
+		pr_info("dsi reg @ 0x%x: 0x%x\n", mvdsi_reg,
+			__raw_readl(addr + mvdsi_reg));
+	} else if ('0' == buf[0] && 'x' == buf[1]) {
+		/* set the register value */
+		tmp = (int)simple_strtoul(buf, NULL, 16);
+		__raw_writel(tmp, addr + mvdsi_reg);
+		pr_info("set dsi reg @ 0x%x: 0x%x\n", mvdsi_reg,
+			__raw_readl(addr + mvdsi_reg));
+	}
+}
+
+ssize_t phy_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	int s = 0;
+
+	if (!mi)
+		goto out;
+
+	if (mi->phy_type & LVDS)
+		s += lvds_dump(fbi, DUMP_SPRINTF, buf, s);
+
+	if ((mi->phy_type & (DSI | DSI2DPI)))
+		s += dsi_dump(fbi, DUMP_SPRINTF, buf, s);
+
+out:
+	return s;
+}
+
+ssize_t phy_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	int value;
+
+	if (mi->phy_type & (DSI | DSI2DPI))
+		dsi_store(mi, buf, size);
+	else
+		sscanf(buf, "%d", &value);
+
+	return size;
+}
+DEVICE_ATTR(phy, S_IRUGO | S_IWUSR, phy_show, phy_store);
+
+#endif
diff --git a/firmware/Makefile b/firmware/Makefile
index 0d15a3d1..8ddf8d3d 100644
--- a/firmware/Makefile
+++ b/firmware/Makefile
@@ -140,7 +140,21 @@ fw-shipped-$(CONFIG_USB_SERIAL_XIRCOM) += keyspan_pda/xircom_pgs.fw
 fw-shipped-$(CONFIG_USB_VICAM) += vicam/firmware.fw
 fw-shipped-$(CONFIG_VIDEO_CPIA2) += cpia2/stv0672_vp4.bin
 fw-shipped-$(CONFIG_YAM) += yam/1200.bin yam/9600.bin
-
+fw-shipped-$(CONFIG_TOUCHSCREEN_MMS136_TS) += melfas/arubaTD/BOOT.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MMS136_TS) += melfas/arubaTD/CORE.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MMS136_TS) += melfas/arubaTD/CONF.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MMS136_TS) += melfas/arubaTD/ARUBA_G1M_CORE53_R20_V09.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MMS136_TS) += melfas/arubaTD/ARUBA_G1F_CORE53_R35_V15.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MMS136_TS) += melfas/arubaTD/ARUBA_G1F_CORE53_R30_V07.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MMS136_TS) += melfas/delosTD/DELOS_G1F_R35_V25.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MMS136_TS) += melfas/delosTD/CONF.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MXT336S) += tsp_atmel/mxt336s_wilcox.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MELFAS_MMS144) += tsp_melfas/baffinq/melfas.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MELFAS_MMS144) += tsp_melfas/baffinq/BOOT.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MELFAS_MMS144) += tsp_melfas/baffinq/CORE.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MELFAS_MMS144) += tsp_melfas/baffinq/CONF.fw
+fw-shipped-$(CONFIG_KEYBOARD_TC360) += coreriver/tc360.fw
+fw-shipped-$(CONFIG_TOUCHSCREEN_MXT224S) += atmel/mxt224s.fw
 fw-shipped-all := $(fw-shipped-y) $(fw-shipped-m) $(fw-shipped-)
 
 # Directories which we _might_ need to create, so we have a rule for them.
diff --git a/fs/Kconfig b/fs/Kconfig
index f95ae3a0..67d5a8fc 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -198,11 +198,16 @@ if MISC_FILESYSTEMS
 source "fs/adfs/Kconfig"
 source "fs/affs/Kconfig"
 source "fs/ecryptfs/Kconfig"
+# source "fs/sdcardfs/Kconfig"
 source "fs/hfs/Kconfig"
 source "fs/hfsplus/Kconfig"
 source "fs/befs/Kconfig"
 source "fs/bfs/Kconfig"
 source "fs/efs/Kconfig"
+
+# Patched by YAFFS
+# source "fs/yaffs2/Kconfig"
+
 source "fs/jffs2/Kconfig"
 # UBIFS File system configuration
 source "fs/ubifs/Kconfig"
diff --git a/fs/Makefile b/fs/Makefile
index 2fb97793..4d67d85e 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -83,6 +83,7 @@ obj-$(CONFIG_ISO9660_FS)	+= isofs/
 obj-$(CONFIG_HFSPLUS_FS)	+= hfsplus/ # Before hfs to find wrapped HFS+
 obj-$(CONFIG_HFS_FS)		+= hfs/
 obj-$(CONFIG_ECRYPT_FS)		+= ecryptfs/
+#obj-$(CONFIG_SDCARD_FS)		+= sdcardfs/
 obj-$(CONFIG_VXFS_FS)		+= freevxfs/
 obj-$(CONFIG_NFS_FS)		+= nfs/
 obj-$(CONFIG_EXPORTFS)		+= exportfs/
@@ -125,3 +126,6 @@ obj-$(CONFIG_GFS2_FS)           += gfs2/
 obj-y				+= exofs/ # Multiple modules
 obj-$(CONFIG_CEPH_FS)		+= ceph/
 obj-$(CONFIG_PSTORE)		+= pstore/
+
+# Patched by YAFFS
+#obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
diff --git a/fs/eventpoll.c b/fs/eventpoll.c
index c0b3c70e..079d1be6 100644
--- a/fs/eventpoll.c
+++ b/fs/eventpoll.c
@@ -33,6 +33,7 @@
 #include <linux/bitops.h>
 #include <linux/mutex.h>
 #include <linux/anon_inodes.h>
+#include <linux/device.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/mman.h>
@@ -87,7 +88,7 @@
  */
 
 /* Epoll private bits inside the event mask */
-#define EP_PRIVATE_BITS (EPOLLONESHOT | EPOLLET)
+#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET)
 
 /* Maximum number of nesting allowed inside epoll sets */
 #define EP_MAX_NESTS 4
@@ -154,6 +155,9 @@ struct epitem {
 	/* List header used to link this item to the "struct file" items list */
 	struct list_head fllink;
 
+	/* wakeup_source used when EPOLLWAKEUP is set */
+	struct wakeup_source *ws;
+
 	/* The structure that describe the interested events and the source fd */
 	struct epoll_event event;
 };
@@ -194,6 +198,9 @@ struct eventpoll {
 	 */
 	struct epitem *ovflist;
 
+	/* wakeup_source used when ep_scan_ready_list is running */
+	struct wakeup_source *ws;
+
 	/* The user that created the eventpoll descriptor */
 	struct user_struct *user;
 
@@ -588,8 +595,10 @@ static int ep_scan_ready_list(struct eventpoll *ep,
 		 * queued into ->ovflist but the "txlist" might already
 		 * contain them, and the list_splice() below takes care of them.
 		 */
-		if (!ep_is_linked(&epi->rdllink))
+		if (!ep_is_linked(&epi->rdllink)) {
 			list_add_tail(&epi->rdllink, &ep->rdllist);
+			__pm_stay_awake(epi->ws);
+		}
 	}
 	/*
 	 * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after
@@ -602,6 +611,7 @@ static int ep_scan_ready_list(struct eventpoll *ep,
 	 * Quickly re-inject items left on "txlist".
 	 */
 	list_splice(&txlist, &ep->rdllist);
+	__pm_relax(ep->ws);
 
 	if (!list_empty(&ep->rdllist)) {
 		/*
@@ -656,6 +666,8 @@ static int ep_remove(struct eventpoll *ep, struct epitem *epi)
 		list_del_init(&epi->rdllink);
 	spin_unlock_irqrestore(&ep->lock, flags);
 
+	wakeup_source_unregister(epi->ws);
+
 	/* At this point it is safe to free the eventpoll item */
 	kmem_cache_free(epi_cache, epi);
 
@@ -706,6 +718,7 @@ static void ep_free(struct eventpoll *ep)
 	mutex_unlock(&epmutex);
 	mutex_destroy(&ep->mtx);
 	free_uid(ep->user);
+	wakeup_source_unregister(ep->ws);
 	kfree(ep);
 }
 
@@ -737,6 +750,7 @@ static int ep_read_events_proc(struct eventpoll *ep, struct list_head *head,
 			 * callback, but it's not actually ready, as far as
 			 * caller requested events goes. We can remove it here.
 			 */
+			__pm_relax(epi->ws);
 			list_del_init(&epi->rdllink);
 		}
 	}
@@ -927,13 +941,23 @@ static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *k
 		if (epi->next == EP_UNACTIVE_PTR) {
 			epi->next = ep->ovflist;
 			ep->ovflist = epi;
+			if (epi->ws) {
+				/*
+				 * Activate ep->ws since epi->ws may get
+				 * deactivated at any time.
+				 */
+				__pm_stay_awake(ep->ws);
+			}
+
 		}
 		goto out_unlock;
 	}
 
 	/* If this file is already in the ready list we exit soon */
-	if (!ep_is_linked(&epi->rdllink))
+	if (!ep_is_linked(&epi->rdllink)) {
 		list_add_tail(&epi->rdllink, &ep->rdllist);
+		__pm_stay_awake(epi->ws);
+	}
 
 	/*
 	 * Wake up ( if active ) both the eventpoll wait list and the ->poll()
@@ -1091,6 +1115,30 @@ static int reverse_path_check(void)
 	return error;
 }
 
+static int ep_create_wakeup_source(struct epitem *epi)
+{
+	const char *name;
+
+	if (!epi->ep->ws) {
+		epi->ep->ws = wakeup_source_register("eventpoll");
+		if (!epi->ep->ws)
+			return -ENOMEM;
+	}
+
+	name = epi->ffd.file->f_path.dentry->d_name.name;
+	epi->ws = wakeup_source_register(name);
+	if (!epi->ws)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void ep_destroy_wakeup_source(struct epitem *epi)
+{
+	wakeup_source_unregister(epi->ws);
+	epi->ws = NULL;
+}
+
 /*
  * Must be called with "mtx" held.
  */
@@ -1118,6 +1166,13 @@ static int ep_insert(struct eventpoll *ep, struct epoll_event *event,
 	epi->event = *event;
 	epi->nwait = 0;
 	epi->next = EP_UNACTIVE_PTR;
+	if (epi->event.events & EPOLLWAKEUP) {
+		error = ep_create_wakeup_source(epi);
+		if (error)
+			goto error_create_wakeup_source;
+	} else {
+		epi->ws = NULL;
+	}
 
 	/* Initialize the poll table using the queue callback */
 	epq.epi = epi;
@@ -1164,6 +1219,7 @@ static int ep_insert(struct eventpoll *ep, struct epoll_event *event,
 	/* If the file is already "ready" we drop it inside the ready list */
 	if ((revents & event->events) && !ep_is_linked(&epi->rdllink)) {
 		list_add_tail(&epi->rdllink, &ep->rdllist);
+		__pm_stay_awake(epi->ws);
 
 		/* Notify waiting tasks that events are available */
 		if (waitqueue_active(&ep->wq))
@@ -1204,6 +1260,9 @@ error_unregister:
 		list_del_init(&epi->rdllink);
 	spin_unlock_irqrestore(&ep->lock, flags);
 
+	wakeup_source_unregister(epi->ws);
+
+error_create_wakeup_source:
 	kmem_cache_free(epi_cache, epi);
 
 	return error;
@@ -1229,6 +1288,12 @@ static int ep_modify(struct eventpoll *ep, struct epitem *epi, struct epoll_even
 	epi->event.events = event->events;
 	pt._key = event->events;
 	epi->event.data = event->data; /* protected by mtx */
+	if (epi->event.events & EPOLLWAKEUP) {
+		if (!epi->ws)
+			ep_create_wakeup_source(epi);
+	} else if (epi->ws) {
+		ep_destroy_wakeup_source(epi);
+	}
 
 	/*
 	 * Get current event bits. We can safely use the file* here because
@@ -1244,6 +1309,7 @@ static int ep_modify(struct eventpoll *ep, struct epitem *epi, struct epoll_even
 		spin_lock_irq(&ep->lock);
 		if (!ep_is_linked(&epi->rdllink)) {
 			list_add_tail(&epi->rdllink, &ep->rdllist);
+			__pm_stay_awake(epi->ws);
 
 			/* Notify waiting tasks that events are available */
 			if (waitqueue_active(&ep->wq))
@@ -1282,6 +1348,18 @@ static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,
 	     !list_empty(head) && eventcnt < esed->maxevents;) {
 		epi = list_first_entry(head, struct epitem, rdllink);
 
+		/*
+		 * Activate ep->ws before deactivating epi->ws to prevent
+		 * triggering auto-suspend here (in case we reactive epi->ws
+		 * below).
+		 *
+		 * This could be rearranged to delay the deactivation of epi->ws
+		 * instead, but then epi->ws would temporarily be out of sync
+		 * with ep_is_linked().
+		 */
+		if (epi->ws && epi->ws->active)
+			__pm_stay_awake(ep->ws);
+		__pm_relax(epi->ws);
 		list_del_init(&epi->rdllink);
 
 		pt._key = epi->event.events;
@@ -1298,6 +1376,7 @@ static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,
 			if (__put_user(revents, &uevent->events) ||
 			    __put_user(epi->event.data, &uevent->data)) {
 				list_add(&epi->rdllink, head);
+				__pm_stay_awake(epi->ws);
 				return eventcnt ? eventcnt : -EFAULT;
 			}
 			eventcnt++;
@@ -1317,6 +1396,7 @@ static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,
 				 * poll callback will queue them in ep->ovflist.
 				 */
 				list_add_tail(&epi->rdllink, &ep->rdllist);
+				__pm_stay_awake(epi->ws);
 			}
 		}
 	}
@@ -1629,6 +1709,10 @@ SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,
 	if (!tfile->f_op || !tfile->f_op->poll)
 		goto error_tgt_fput;
 
+	/* Check if EPOLLWAKEUP is allowed */
+	if ((epds.events & EPOLLWAKEUP) && !capable(CAP_EPOLLWAKEUP))
+		epds.events &= ~EPOLLWAKEUP;
+
 	/*
 	 * We have to check that the file structure underneath the file descriptor
 	 * the user passed to us _is_ an eventpoll file. And also we do not permit
diff --git a/fs/exec.c b/fs/exec.c
index 29e5f840..ba661eeb 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -617,7 +617,7 @@ static int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)
 	 * process cleanup to remove whatever mess we made.
 	 */
 	if (length != move_page_tables(vma, old_start,
-				       vma, new_start, length))
+				       vma, new_start, length, false))
 		return -ENOMEM;
 
 	lru_add_drain();
diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index 539f36cf..42a853ee 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -1082,7 +1082,7 @@ void __mark_inode_dirty(struct inode *inode, int flags)
 	if ((inode->i_state & flags) == flags)
 		return;
 
-	if (unlikely(block_dump))
+	if (unlikely(block_dump > 1))
 		block_dump___mark_inode_dirty(inode);
 
 	spin_lock(&inode->i_lock);
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 9fc77b41..c8cb15dc 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -137,6 +137,12 @@ struct pid_entry {
 
 static int proc_fd_permission(struct inode *inode, int mask);
 
+/* ANDROID is for special files in /proc. */
+#define ANDROID(NAME, MODE, OTYPE)			\
+	NOD(NAME, (S_IFREG|(MODE)),			\
+		&proc_##OTYPE##_inode_operations,	\
+		&proc_##OTYPE##_operations, {})
+
 /*
  * Count the number of hardlinks for the pid_entry table, excluding the .
  * and .. links.
@@ -969,6 +975,35 @@ out:
 	return err < 0 ? err : count;
 }
 
+static int oom_adjust_permission(struct inode *inode, int mask)
+{
+	uid_t uid;
+	struct task_struct *p;
+
+	p = get_proc_task(inode);
+	if(p) {
+		uid = task_uid(p);
+		put_task_struct(p);
+	}
+
+	/*
+	 * System Server (uid == 1000) is granted access to oom_adj of all 
+	 * android applications (uid > 10000) as and services (uid >= 1000)
+	 */
+	if (p && (current_fsuid() == 1000) && (uid >= 1000)) {
+		if (inode->i_mode >> 6 & mask) {
+			return 0;
+		}
+	}
+
+	/* Fall back to default. */
+	return generic_permission(inode, mask);
+}
+
+static const struct inode_operations proc_oom_adjust_inode_operations = {
+	.permission	= oom_adjust_permission,
+};
+
 static const struct file_operations proc_oom_adjust_operations = {
 	.read		= oom_adjust_read,
 	.write		= oom_adjust_write,
@@ -3011,7 +3046,7 @@ static const struct pid_entry tgid_base_stuff[] = {
 	REG("cgroup",  S_IRUGO, proc_cgroup_operations),
 #endif
 	INF("oom_score",  S_IRUGO, proc_oom_score),
-	REG("oom_adj",    S_IRUGO|S_IWUSR, proc_oom_adjust_operations),
+	ANDROID("oom_adj",S_IRUGO|S_IWUSR, oom_adjust),
 	REG("oom_score_adj", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),
 #ifdef CONFIG_AUDITSYSCALL
 	REG("loginuid",   S_IWUSR|S_IRUGO, proc_loginuid_operations),
diff --git a/include/asm-generic/cputime.h b/include/asm-generic/cputime.h
index 9a62937c..172a1237 100644
--- a/include/asm-generic/cputime.h
+++ b/include/asm-generic/cputime.h
@@ -13,6 +13,9 @@ typedef unsigned long __nocast cputime_t;
 
 typedef u64 __nocast cputime64_t;
 
+#define cputime64_zero (0ULL)
+#define cputime64_add(__a, __b)		((__a) + (__b))
+#define cputime64_sub(__a, __b)		((__a) - (__b))
 #define cputime64_to_jiffies64(__ct)	(__force u64)(__ct)
 #define jiffies64_to_cputime64(__jif)	(__force cputime64_t)(__jif)
 
diff --git a/include/asm-generic/dma-contiguous.h b/include/asm-generic/dma-contiguous.h
new file mode 100644
index 00000000..c544356b
--- /dev/null
+++ b/include/asm-generic/dma-contiguous.h
@@ -0,0 +1,28 @@
+#ifndef ASM_DMA_CONTIGUOUS_H
+#define ASM_DMA_CONTIGUOUS_H
+
+#ifdef __KERNEL__
+#ifdef CONFIG_CMA
+
+#include <linux/device.h>
+#include <linux/dma-contiguous.h>
+
+static inline struct cma *dev_get_cma_area(struct device *dev)
+{
+	if (dev && dev->cma_area)
+		return dev->cma_area;
+	return dma_contiguous_default_area;
+}
+
+static inline void dev_set_cma_area(struct device *dev, struct cma *cma)
+{
+	if (dev)
+		dev->cma_area = cma;
+	if (!dev || !dma_contiguous_default_area)
+		dma_contiguous_default_area = cma;
+}
+
+#endif
+#endif
+
+#endif
diff --git a/include/asm-generic/emergency-restart.h b/include/asm-generic/emergency-restart.h
index 0d68a1ea..69fcac7d 100644
--- a/include/asm-generic/emergency-restart.h
+++ b/include/asm-generic/emergency-restart.h
@@ -3,7 +3,7 @@
 
 static inline void machine_emergency_restart(void)
 {
-	machine_restart(NULL);
+	machine_restart("panic");
 }
 
 #endif /* _ASM_GENERIC_EMERGENCY_RESTART_H */
diff --git a/include/asm-generic/mutex-xchg.h b/include/asm-generic/mutex-xchg.h
index 580a6d35..c04e0db8 100644
--- a/include/asm-generic/mutex-xchg.h
+++ b/include/asm-generic/mutex-xchg.h
@@ -26,7 +26,13 @@ static inline void
 __mutex_fastpath_lock(atomic_t *count, void (*fail_fn)(atomic_t *))
 {
 	if (unlikely(atomic_xchg(count, 0) != 1))
-		fail_fn(count);
+		/*
+		 * We failed to acquire the lock, so mark it contended
+		 * to ensure that any waiting tasks are woken up by the
+		 * unlock slow path.
+		 */
+		if (likely(atomic_xchg(count, -1) != 1))
+			fail_fn(count);
 }
 
 /**
@@ -43,7 +49,8 @@ static inline int
 __mutex_fastpath_lock_retval(atomic_t *count, int (*fail_fn)(atomic_t *))
 {
 	if (unlikely(atomic_xchg(count, 0) != 1))
-		return fail_fn(count);
+		if (likely(atomic_xchg(count, -1) != 1))
+			return fail_fn(count);
 	return 0;
 }
 
diff --git a/include/linux/alarmtimer.h b/include/linux/alarmtimer.h
index 975009e1..f122c9fb 100644
--- a/include/linux/alarmtimer.h
+++ b/include/linux/alarmtimer.h
@@ -35,6 +35,7 @@ enum alarmtimer_restart {
  */
 struct alarm {
 	struct timerqueue_node	node;
+	struct hrtimer		timer;
 	enum alarmtimer_restart	(*function)(struct alarm *, ktime_t now);
 	enum alarmtimer_type	type;
 	int			state;
@@ -43,7 +44,7 @@ struct alarm {
 
 void alarm_init(struct alarm *alarm, enum alarmtimer_type type,
 		enum alarmtimer_restart (*function)(struct alarm *, ktime_t));
-void alarm_start(struct alarm *alarm, ktime_t start);
+int alarm_start(struct alarm *alarm, ktime_t start);
 int alarm_try_to_cancel(struct alarm *alarm);
 int alarm_cancel(struct alarm *alarm);
 
@@ -76,4 +77,7 @@ static inline int alarmtimer_callback_running(struct alarm *timer)
 }
 
 
+/* Provide way to access the rtc device being used by alarmtimers */
+struct rtc_device *alarmtimer_get_rtcdev(void);
+
 #endif
diff --git a/include/linux/battery/fuelgauge/88pm80x_fg.h b/include/linux/battery/fuelgauge/88pm80x_fg.h
new file mode 100755
index 00000000..43e20d56
--- /dev/null
+++ b/include/linux/battery/fuelgauge/88pm80x_fg.h
@@ -0,0 +1,60 @@
+#ifndef __88PM80X_FG_H
+#define __88PM80X_FG_H
+
+#include <linux/mfd/88pm822.h>
+
+#define MONITOR_INTERVAL		(HZ * 1)
+
+#define SLP_CNT_RD_LSB			(1 << 7)
+#define HYB_DONE			(1 << 0)
+#define BAT_WU_LOG			(1 << 6)
+
+#if 0
+#define dev_dbg(dev, format, arg...)		\
+dev_printk(KERN_EMERG, dev, format, ##arg)
+#endif
+
+#define sec_fuelgauge_dev_t     struct pm822_chip
+#define sec_fuelgauge_pdata_t   struct pm822_platform_data
+
+struct pm80x_battery_params {
+	int status;
+	int present;
+	int volt;	/* µV */
+	int cap;	/* percents: 0~100% */
+	int health;
+	int tech;
+	int temp;
+	int chg_full;
+	int chg_now;
+};
+
+struct sec_fg_info {
+	struct pm822_chip	*chip;
+	struct device	*dev;
+	struct pm80x_battery_params	bat_params;
+
+	struct delayed_work	monitor_work;
+	struct mutex		lock;
+	struct workqueue_struct *bat_wqueue;
+
+	unsigned	present:1;
+
+	/* State Of Connect */
+	int online;
+	/* battery SOC (capacity) */
+	int batt_soc;
+	/* battery voltage */
+	int batt_voltage;
+	/* battery AvgVoltage */
+	int batt_avgvoltage;
+	/* battery OCV */
+	int batt_ocv;
+	/* Current */
+	int batt_current;
+	/* battery Avg Current */
+	int batt_avgcurrent;
+	/* battery temperatue */
+	u32 current_temp_adc;
+};
+#endif /* __88PM80X_FG_H */
diff --git a/include/linux/battery/fuelgauge/88pm80x_table_goya.h b/include/linux/battery/fuelgauge/88pm80x_table_goya.h
new file mode 100755
index 00000000..841ce37c
--- /dev/null
+++ b/include/linux/battery/fuelgauge/88pm80x_table_goya.h
@@ -0,0 +1,806 @@
+#ifndef __88PM80X_TABLE_H
+#define __88PM80X_TABLE_H
+
+/* We assume 3000mV is the power off voltage */
+#define POWER_OFF_THRESHOLD			(3350)
+#define SAFE_POWER_OFF_THRESHOLD		(3000)
+
+/* temperature for goldenve */
+/* -10       89.4050     93.5136     97.7229 */
+#define TBAT_M10C	94	/* -10C: 93.5136k ohm */
+/* 0        57.5058     59.8810     62.2981 */
+#define TBAT_0C		60	/* 0C: 59.8810k ohm */
+/* 20       25.7312     26.5772     27.4263 */
+#define TBAT_20C	27	/* 20C: 26.5772k ohm */
+/* 35       14.7729     15.2854     15.8013 */
+#define TBAT_35C	15	/* 35C: 15.2854k ohm */
+/* 45       10.4184     10.8172     11.2211 */
+#define TBAT_45C	11	/* 45C: 10.8172k ohm */
+
+/* -25C ~ 60C: multipled by 10000 */
+static int temperature_table[] = {
+	/* -25 ~ -21 */
+	1926293, 1831332, 1741659, 1656946, 1576891,
+	/* -20 ~ -11*/
+	1501207, 1429795, 1362219, 1298249, 1237673, 1180290, 1125914, 1074369, 1025491, 979128,
+	/* -10 ~ -1 */
+	935136, 893194, 853391, 815603, 779718, 745628, 713233, 682439, 653159, 625308,
+	/* 0 ~ 9 */
+	598810, 573672, 549729, 526920, 505183, 484463, 464707, 445864, 427888, 410735,
+	/* 10 ~ 19 */
+	394361, 378705, 363758, 349483, 335847, 322818, 310365, 298460, 287077, 276188,
+	/* 20 ~ 29 */
+	265772, 255819, 246284, 237149, 228393, 220000, 211953, 204236, 196834, 189733,
+	/* 30 ~ 39 */
+	182920, 176398, 170142, 164140, 158381, 152854, 147547, 142452, 137558, 132857,
+	/* 40 ~ 49 */
+	128340, 123985, 119798, 115771, 111898, 108172, 104587, 101136, 97815, 94618,
+	/* 50 ~ 59 */
+	91539, 88576, 85721, 82972, 80322, 77769, 75308, 72935, 70648, 68442,
+	/* 60 ~ 65 */
+	66314, 64292, 62342, 60461, 58646, 56895
+};
+
+/*
+ * Battery parameters from battery vendor for fuel gauge.
+ * For SS aruba battery paramters, the extraction was
+ * performed at T=25C and with ICHG=IDIS=0.5A, they are:
+ * Rs = 0.11 Ohm + 0.01 Ohm;
+ * R1 = 0.04 Ohm;
+ * R2 = 0.03 Ohm;
+ * C1 = 1000F
+ * C2 = 10000F
+ * Csoc = 5476F (Qtot = 5476C)
+ */
+
+/* we use m-Ohm by *1000 for calculation */
+static int r1 = 40;
+static int r2 = 30;
+static int r_s = 120;
+static int rtot;
+static int c1 = 1000;
+static int c2 = 10000;
+//static int c_soc = 6286;
+//static int c_soc = 5868; //SSG env batt 3
+//static int c_soc = 14000; //Asus battery
+static int c_soc = 12960; //Goya 3600 mAh battery
+//static int c_soc_Tm10 = 5400; //GoldenVE battery capacity at T=-10
+//static int c_soc_T0 = 5400; //GoldenVE battery capacity at T=-20
+//static int K_T = 1; // c_soc / c_soc(T)
+
+static int r_off_initial = 32;
+//static int r_off = 80; //new value obtained with adaptive method
+static int r_off = 32; // Value used for Samsung setup (external battery)
+static int deltaR_to_store;
+static int short_slp_counter = 0; // to take in account of slp_cnt = 1 sec in SSG environment
+/*
+ * v1, v2 is voltage, the unit of orignal formula design is "Volt",
+ * since we can not do float calculation, we introduce the factor of
+ * 1024 * 1024 to enlarge the resolution for LSB, the value of it is
+ * "Volt with factor" in the driver.
+ *
+ * v1 and v2 are signded variable, normally, for charging case they
+ * are negative value, for discharging case, they are positive value.
+ *
+ * v3 is SOC, original formular is 0~1, since we can not do float
+ * calculation, for improve the resolution of it, the range value
+ * is enlarged  by multiply 10000 in v3_res, but we report
+ * v3 = v3_res/1000 to APP/Android level.
+ */
+static int v1, v2, v3, cap = 100;
+static int factor = 1024 * 1024;
+static int factor2 = 1000;
+//static int count_cap = 0;
+static int ib_adaptive = 0;
+static int term1,term2,term3 = 0;
+static int adaptive_gain_x_I0 = 125000;
+static int first_long_sleep_flag_adaptive = 0;
+static int deltaR = 0;
+static int v1_mv, v2_mv, v3_res, v3_res_t1, v3_res_t2;
+static int deltat_t2mt1, delta_soc_t1mt2, delta_soc_t1mt3;
+static int vbat_mv;
+static int t1_start;
+
+static int G_T0 = 1;
+static int Off_T0 = 0;
+static int G_Tm10 = 25;
+static int Off_Tm10 = -150;
+
+/*
+ * LUT of exp(-x) function, we need to calcolate exp(-x) with x=SLEEP_CNT/RC,
+ * Since 0<SLEEP_CNT<1000 and RCmin=20 we should calculate exp function in [0-50]
+ * Because exp(-5)= 0.0067 we can use following approximation:
+ *	f(x)= exp(-x) = 0   (if x>5);
+ * 20 points in [0-5] with linear interpolation between points.
+ *  [-0.25, 0.7788] [-0.50, 0.6065] [-0.75, 0.4724] [-1.00, 0.3679]
+ *  [-1.25, 0.2865] [-1.50, 0.2231] [-1.75, 0.1738] [-2.00, 0.1353]
+ *  [-2.25, 0.1054] [-2.50, 0.0821] [-2.75, 0.0639] [-3.00, 0.0498]
+ *  [-3.25, 0.0388] [-3.50, 0.0302] [-3.75, 0.0235] [-4.00, 0.0183]
+ *  [-4.25, 0.0143] [-4.50, 0.0111] [-4.75, 0.0087] [-5.00, 0.0067]
+ */
+static int exp_data[] = {
+	7788, 6065, 4724, 3679,
+	2865, 2231, 1738, 1353,
+	1054, 821,  639,  498,
+	388,  302,  235,  183,
+	143,  111,  87,   67 };
+
+/*
+ * State of Charge.
+ * The first number is voltage, the second number is soc point.
+ */
+#if 0
+static int ocv_table[] = {
+ 3217, 3347, 3438, 3505, 3551, 3582, 3610, 3636, 3658, 3675,
+ 3686, 3693, 3699, 3705, 3713, 3723, 3732, 3741, 3748, 3754,
+ 3759, 3765, 3769, 3772, 3774, 3776, 3778, 3779, 3780, 3781,
+ 3782, 3783, 3784, 3785, 3786, 3788, 3790, 3792, 3794, 3797,
+ 3800, 3803, 3806, 3809, 3813, 3817, 3821, 3825, 3830, 3834,
+ 3840, 3845, 3851, 3858, 3866, 3875, 3886, 3896, 3906, 3915,
+ 3925, 3933, 3942, 3950, 3958, 3966, 3974, 3982, 3990, 3999,
+ 4008, 4017, 4026, 4036, 4046, 4056, 4066, 4076, 4086, 4096,
+ 4107, 4117, 4128, 4139, 4150, 4161, 4172, 4184, 4195, 4207,
+ 4218, 4230, 4242, 4254, 4266, 4278, 4290, 4302, 4314, 4326 };
+#else
+static int ocv_dischg[] = {
+3373, 3474, 3545, 3598, 3640, 3670, 3683, 3688, 3690, 3692,
+3694, 3696, 3701, 3708, 3715, 3719, 3724, 3729, 3734, 3738,
+3742, 3745, 3748, 3751, 3755, 3759, 3763, 3767, 3771, 3774,
+3778, 3782, 3785, 3788, 3791, 3794, 3797, 3800, 3803, 3806,
+3809, 3813, 3816, 3820, 3824, 3828, 3832, 3836, 3840, 3845,
+3850, 3854, 3860, 3865, 3871, 3877, 3883, 3890, 3898, 3906,
+3916, 3926, 3937, 3948, 3958, 3967, 3976, 3984, 3993, 4001,
+4010, 4018, 4027, 4037, 4047, 4056, 4066, 4075, 4084, 4094,
+4104, 4114, 4125, 4135, 4145, 4156, 4167, 4177, 4188, 4199,
+4210, 4221, 4233, 4244, 4256, 4267, 4279, 4291, 4303, 4316, 4320 };
+
+
+static int ocv_chg[] = { //Goya battery
+3373, 3474, 3545, 3598, 3640, 3670, 3683, 3688, 3690, 3692,
+3694, 3696, 3701, 3708, 3715, 3719, 3724, 3729, 3734, 3738,
+3742, 3745, 3748, 3751, 3755, 3759, 3763, 3767, 3771, 3774,
+3778, 3782, 3785, 3788, 3791, 3794, 3797, 3800, 3803, 3806,
+3809, 3813, 3816, 3820, 3824, 3828, 3832, 3836, 3840, 3845,
+3850, 3854, 3860, 3865, 3871, 3877, 3883, 3890, 3898, 3906,
+3916, 3926, 3937, 3948, 3958, 3967, 3976, 3984, 3993, 4001,
+4010, 4018, 4027, 4037, 4047, 4056, 4066, 4075, 4084, 4094,
+4104, 4114, 4125, 4135, 4145, 4156, 4167, 4177, 4188, 4199,
+4210, 4221, 4233, 4244, 4256, 4267, 4279, 4291, 4303, 4316, 4320 };
+
+
+#endif
+/*
+ * The rtot(Rtotal) of battery is much different in different temperature,
+ * so we introduced data in different temperature, the typical sample point
+ * of temperature are -5/10/25/40 C.
+ * For charging case, we support the data of charging current of 1200 mA
+ * in those temperatures, so we have 4 table for it.
+ * For discharging case, we have data 500/1000/1500 mA discharging current
+ * case, then we have 12 tables for it.
+ */
+static int rtot_tm20_i0p15[] = {//GoldenVE battery, modified from 68 to 100
+3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000,
+3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000,
+3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000,
+3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000,
+3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000,
+3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000,
+3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000,
+3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000,
+3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000,
+3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000};
+
+static int rtot_tm20_i0p3[] = {//GoldenVE battery, modified from 68 to 100
+2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500,
+2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500,
+2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500,
+2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500,
+2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500,
+2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500,
+2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500,
+2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500,
+2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500,
+2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500};
+
+static int rtot_tm20_i0p5[] = {//GoldenVE battery
+2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,
+2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,
+2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,
+2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,
+2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,
+2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,
+2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,
+2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,
+2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,
+2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000};
+/*
+static int rtot_tm20_i0p5[] = {//GoldenVE battery
+10500, 10500, 10500, 10500, 10500, 10500, 10500, 10500, 10500, 10500,
+10500, 10500, 10500, 10500, 10500, 10500, 9600, 8790, 8060, 7390,
+6780, 6230, 5730, 5280, 4870, 4510, 4190, 3900, 3640, 3420,
+3220, 3040, 2880, 2790, 2650, 2540, 2460, 2380, 2320, 2270,
+2220, 2180, 2140, 2110, 2080, 2050, 2020, 2000, 1970, 1950,
+1930, 1920, 1900, 1890, 1870, 1860, 1860, 1850, 1850, 1850,
+1850, 1860, 1860, 1850, 1850, 1850, 1840, 1840, 1840, 1830,
+1820, 1810, 1800, 1810, 1820, 1840, 1850, 1860, 1860, 1850,
+1840, 1850, 1840, 1840, 1840, 1840, 1840, 1840, 1840, 1840,
+1840, 1840, 1840, 1840, 1840, 1840, 1840, 1840, 1840, 1840};
+*/
+static int rtot_tm20_i0p7[] = {//GoldenVE battery
+1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500,
+1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500,
+1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500,
+1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500,
+1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500,
+1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500,
+1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500,
+1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500,
+1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500,
+1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500};
+
+static int rtot_tm20_i1p0[] = {//GoldenVE battery, equal to 0.7
+1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300,
+1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300,
+1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300,
+1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300,
+1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300,
+1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300,
+1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300,
+1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300,
+1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300,
+1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300};
+
+static int rtot_tm20_i1p5[] = {// da modificare, ottenuto con interpolazione
+1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
+1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
+1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
+1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
+1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
+1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
+1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
+1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
+1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
+1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100};
+
+static int rtot_tm5_i0p15[] = {//GoldenVE battery, modified from 68 to 100.
+2200, 1000, 750, 650, 500, 500, 500, 500, 500, 500,
+500, 500, 500, 500, 500, 500, 500, 500, 500, 500,
+500, 500, 500, 500, 500, 500, 500, 500, 500, 500,
+500, 500, 500, 500, 500, 500, 500, 500, 500, 500,
+500, 500, 500, 500, 500, 500, 500, 500, 500, 500,
+500, 500, 500, 500, 500, 500, 500, 500, 500, 500,
+500, 500, 500, 500, 500, 500, 500, 500, 500, 500,
+500, 500, 500, 500, 500, 500, 500, 500, 500, 500,
+500, 500, 500, 500, 500, 500, 500, 500, 500, 500,
+500, 500, 500, 500, 500, 500, 500, 500, 500, 500};
+
+static int rtot_tm5_i0p3[] = {//GoldenVE battery, modified from 78 to 100
+2100, 950, 650, 500, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400};
+/*
+966, 950, 935, 920, 907, 893, 881, 869, 858, 847,
+837, 828, 819, 812, 805, 799, 794, 789, 785, 781,
+780, 778, 776, 777, 779, 783, 789, 802, 818, 835,
+851, 865, 873, 878, 881, 882, 880, 877, 866, 850,
+838, 834, 835, 841, 858, 880, 896, 895, 895, 895,
+895, 895, 895, 895, 895, 895, 895, 895, 895, 895,
+895, 895, 895, 895, 895, 895, 895, 895, 895, 895};*/
+
+static int rtot_tm5_i0p5[] = {//GoldenVE battery
+1500, 900, 600, 500, 350, 350, 350, 350, 350, 350,
+350, 350, 350, 350, 350, 350, 350, 350, 350, 350,
+350, 350, 350, 350, 350, 350, 350, 350, 350, 350,
+350, 350, 350, 350, 350, 350, 350, 350, 350, 350,
+350, 350, 350, 350, 350, 350, 350, 350, 350, 350,
+350, 350, 350, 350, 350, 350, 350, 350, 350, 350,
+350, 350, 350, 350, 350, 350, 350, 350, 350, 350,
+350, 350, 350, 350, 350, 350, 350, 350, 350, 350,
+350, 350, 350, 350, 350, 350, 350, 350, 350, 350,
+350, 350, 350, 350, 350, 350, 350, 350, 350, 350};
+
+static int rtot_tm5_i0p7[] = {//GoldenVE battery
+1800, 800, 600, 500, 400, 300, 300, 300, 300, 300,
+300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
+300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
+300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
+300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
+300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
+300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
+300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
+300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
+300, 300, 300, 300, 300, 300, 300, 300, 300, 300};
+
+static int rtot_tm5_i1p0[] = {//GoldenVE battery
+1300, 700, 500, 350, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250};
+
+static int rtot_tm5_i1p5[] = {
+1250, 700, 500, 300, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
+250, 250, 250, 250, 250, 250, 250, 250, 250, 250};
+
+
+static int rtot_tm5_i0p3c[] = {//GoldenVE battery
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600};
+
+static int rtot_tm5_i0p5c[] = {//GoldenVE battery
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600};
+
+static int rtot_tm5_i0p7c[] = {
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600};
+
+static int rtot_tm5_i1p0c[] = {
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
+600, 600, 600, 600, 600, 600, 600, 600, 600, 600};
+
+static int rtot_t10_i0p15[] = {//GoldenVE battery, modified from 73 t0 100
+1100, 800, 400, 367, 347, 337, 337, 337, 327, 327,
+327, 327, 327, 327, 327, 327, 327, 327, 327, 327,
+327, 327, 327, 327, 327, 327, 327, 327, 327, 327,
+327, 327, 327, 327, 327, 327, 327, 327, 327, 327,
+327, 327, 327, 327, 327, 327, 327, 327, 327, 327,
+327, 327, 327, 327, 327, 327, 327, 327, 327, 327,
+327, 327, 327, 327, 327, 327, 327, 327, 327, 327,
+327, 327, 327, 327, 327, 327, 327, 327, 327, 327,
+327, 327, 327, 327, 327, 327, 327, 327, 327, 327,
+327, 327, 327, 327, 327, 327, 327, 327, 327, 327};
+
+static int rtot_t10_i0p3[] = {//GoldenVE battery, modified from 78 to 100
+1200, 750, 400, 342, 332, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230};
+
+static int rtot_t10_i0p5[] = {//GoldenVE battery, modified from 78 to 100
+1200, 650, 350, 242, 232, 200, 180, 180, 180, 180,
+180, 180, 180, 180, 180, 180, 180, 180, 180, 180,
+180, 180, 180, 180, 180, 180, 180, 180, 180, 180,
+180, 180, 180, 180, 180, 180, 180, 180, 180, 180,
+180, 180, 180, 180, 180, 180, 180, 180, 180, 180,
+180, 180, 180, 180, 180, 180, 180, 180, 180, 180,
+180, 180, 180, 180, 180, 180, 180, 180, 180, 180,
+180, 180, 180, 180, 180, 180, 180, 180, 180, 180,
+180, 180, 180, 180, 180, 180, 180, 180, 180, 180,
+180, 180, 180, 180, 180, 180, 180, 180, 180, 180};
+
+static int rtot_t10_i0p7[] = {//GoldenVE battery
+1200, 500, 350, 200, 200, 170, 170, 170, 170, 170,
+170, 170, 170, 170, 170, 170, 170, 170, 170, 170,
+170, 170, 170, 170, 170, 170, 170, 170, 170, 170,
+170, 170, 170, 170, 170, 170, 170, 170, 170, 170,
+170, 170, 170, 170, 170, 170, 170, 170, 170, 170,
+170, 170, 170, 170, 170, 170, 170, 170, 170, 170,
+170, 170, 170, 170, 170, 170, 170, 170, 170, 170,
+170, 170, 170, 170, 170, 170, 170, 170, 170, 170,
+170, 170, 170, 170, 170, 170, 170, 170, 170, 170,
+170, 170, 170, 170, 170, 170, 170, 170, 170, 170};
+
+static int rtot_t10_i1p0[] = {//GoldenVE battery
+1200, 450, 230, 180, 180, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150};
+
+static int rtot_t10_i1p5[] = {
+1200, 450, 230, 180, 180, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150};
+
+
+
+
+
+
+static int rtot_t10_i0p3c[] = {//GoldenVE battery
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400};
+
+static int rtot_t10_i0p5c[] = {//GoldenVE battery
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400};
+
+
+static int rtot_t10_i0p7c[] = {//GoldenVE battery
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400};
+
+static int rtot_t10_i1p0c[] = {//GoldenVE battery
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+400, 400, 400, 400, 400, 400, 400, 400, 400, 400};
+
+
+
+static int rtot_t25_i0p15[] = {//Goya battery
+850, 750, 650, 550, 500, 450, 400, 350, 300, 250,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+//179, 176, 195, 230, 250, 236, 218, 214, 216, 214,
+//206, 195, 186, 182, 183, 190, 195, 197, 196, 194,
+//194, 193, 191, 187, 184, 182, 180, 180, 179, 179,
+//179, 181, 182, 182, 184, 187, 188, 190, 192, 194,
+//196, 198, 200, 204, 208, 213, 219, 226, 236, 249,
+//264, 282, 298, 306, 303, 297, 286, 277, 270, 265,
+//263, 262, 265, 270, 273, 272, 269, 265, 264, 266,
+//269, 271, 272, 273, 273, 273, 275, 276, 276, 277,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230};
+//277, 278, 280, 281, 280, 280, 280, 280, 283, 140};
+
+static int rtot_t25_i0p3[] = {//Goya battery
+650, 550, 450, 400, 350, 300, 280, 250, 200, 171,
+151, 151, 151, 151, 151, 151, 151, 151, 151, 151,
+151, 151, 151, 151, 151, 151, 151, 151, 151, 151,
+151, 151, 151, 151, 151, 151, 151, 151, 151, 151,
+151, 151, 151, 151, 151, 151, 151, 151, 151, 151,
+151, 151, 151, 151, 151, 151, 151, 151, 151, 151,
+151, 151, 151, 151, 151, 151, 151, 151, 151, 151,
+151, 151, 151, 151, 151, 151, 151, 151, 151, 151,
+151, 151, 151, 151, 151, 151, 151, 151, 151, 151,
+151, 151, 151, 151, 151, 151, 151, 151, 151, 151};
+//192, 191, 192, 192, 192, 192, 192, 191, 192, 95};
+
+static int rtot_t25_i0p5[] = {//Goya battery
+550, 450, 400, 360, 330, 280, 250, 220, 180, 150,
+130, 130, 130, 130, 130, 130, 130, 130, 130, 130,
+130, 130, 130, 130, 130, 130, 130, 130, 130, 130,
+130, 130, 130, 130, 130, 130, 130, 130, 130, 130,
+130, 130, 130, 130, 130, 130, 130, 130, 130, 130,
+130, 130, 130, 130, 130, 130, 130, 130, 130, 130,
+130, 130, 130, 130, 130, 130, 130, 130, 130, 130,
+130, 130, 130, 130, 130, 130, 130, 130, 130, 130,
+130, 130, 130, 130, 130, 130, 130, 130, 130, 130,
+130, 130, 130, 130, 130, 130, 130, 130, 130, 130};
+//164, 164, 164, 164, 163, 163, 162, 162, 162, 80};
+
+static int rtot_t25_i0p7[] = {//Goya battery
+550, 450, 400, 360, 330, 280, 250, 220, 180, 150,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120};
+//150, 150, 150, 150, 149, 149, 149, 149, 149, 75};
+
+static int rtot_t25_i1p0[] = { //Goya battery
+550, 450, 400, 360, 330, 280, 250, 220, 180, 150,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100};
+//140, 139, 139, 139, 139, 139, 139, 139, 139, 70};
+
+
+static int rtot_t25_i1p5[] = {//Goya battery
+671, 671, 410, 321, 276, 246, 236, 180, 140, 110,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90};
+//133, 133, 133, 133, 133, 133, 133, 133, 133, 65};
+
+
+static int rtot_t25_i0p3c[] = { //GoldenVE battery
+215, 215, 215, 215, 215, 215, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220};
+
+static int rtot_t25_i0p5c[] = {//GoldenVE battery
+214, 214, 214, 214, 214, 214, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
+220, 220, 220, 220, 220, 220, 220, 220, 220, 220};
+
+static int rtot_t25_i0p7c[] = {//GoldenVE battery
+218, 218, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150};
+
+static int rtot_t25_i1p0c[] = {//GoldenVE battery
+204, 204, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110};
+
+static int rtot_t40_i0p15[] = {//Goya battery = 25
+850, 750, 650, 550, 500, 450, 400, 350, 300, 250,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230,
+230, 230, 230, 230, 230, 230, 230, 230, 230, 230};
+//277, 278, 280, 281, 280, 280, 280, 280, 283, 140};
+
+static int rtot_t40_i0p3[] = {//Goya battery
+650, 550, 450, 400, 350, 300, 280, 250, 200, 171,
+140, 140, 140, 140, 140, 140, 140, 140, 140, 140,
+140, 140, 140, 140, 140, 140, 140, 140, 140, 140,
+140, 140, 140, 140, 140, 140, 140, 140, 140, 140,
+140, 140, 140, 140, 140, 140, 140, 140, 140, 140,
+140, 140, 140, 140, 140, 140, 140, 140, 140, 140,
+140, 140, 140, 140, 140, 140, 140, 140, 140, 140,
+140, 140, 140, 140, 140, 140, 140, 140, 140, 140,
+140, 140, 140, 140, 140, 140, 140, 140, 140, 140,
+140, 140, 140, 140, 140, 140, 140, 140, 140, 140};
+//182, 182, 183, 184, 184, 185, 186, 186, 187, 95};
+
+
+static int rtot_t40_i0p5[] = {//Goya battery  not charact
+650, 550, 450, 400, 330, 300, 260, 230, 190, 131,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 140,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
+120, 120, 120, 120, 120, 120, 120, 120, 120, 120};
+
+
+static int rtot_t40_i0p7[] = {//Goya battery
+550, 450, 400, 350, 300, 260, 230, 210, 150, 111,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
+100, 100, 100, 100, 100, 100, 100, 100, 100, 100};
+//136, 136, 136, 136, 136, 136, 136, 136, 136, 70};
+
+static int rtot_t40_i1p0[] = { //Goya battery
+450, 400, 350, 300, 265, 255, 230, 180, 140, 110,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 99,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 99,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 99,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 99,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 99};
+//126, 125, 125, 125, 125, 125, 125, 125, 125, 62};
+
+static int rtot_t40_i1p5[] = {//Goya battery
+852, 852, 405, 313, 265, 255, 230, 180, 140, 110,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 99,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 99,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 99,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 99,
+90, 90, 90, 90, 90, 90, 90, 90, 90, 99};
+
+
+static int rtot_t40_i0p3c[] = { //GoldenVE battery
+362, 362, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200};
+
+static int rtot_t40_i0p5c[] = { //GoldenVE battery
+362, 362, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
+200, 200, 200, 200, 200, 200, 200, 200, 200, 200};
+
+
+static int rtot_t40_i0p7c[] = { //GoldenVE battery
+218, 218, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150,
+150, 150, 150, 150, 150, 150, 150, 150, 150, 150};
+
+static int rtot_t40_i1p0c[] = { //GoldenVE battery
+204, 204, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
+110, 110, 110, 110, 110, 110, 110, 110, 110, 110};
+
+static int* dis_chg_rtot[6][5] = {
+	{rtot_tm20_i0p15,  rtot_tm5_i0p15,  rtot_t10_i0p15,  rtot_t25_i0p15,  rtot_t40_i0p15},
+	{rtot_tm20_i0p3,  rtot_tm5_i0p3,  rtot_t10_i0p3,  rtot_t25_i0p3,  rtot_t40_i0p3},
+	{rtot_tm20_i0p5,  rtot_tm5_i0p5,  rtot_t10_i0p5,  rtot_t25_i0p5,  rtot_t40_i0p5},
+	{rtot_tm20_i0p7,  rtot_tm5_i0p7,  rtot_t10_i0p7,  rtot_t25_i0p7,  rtot_t40_i0p7},
+	{rtot_tm20_i1p0,  rtot_tm5_i1p0,  rtot_t10_i1p0,  rtot_t25_i1p0,  rtot_t40_i1p0},
+	{rtot_tm20_i1p5,  rtot_tm5_i1p5,  rtot_t10_i1p5,  rtot_t25_i1p5,  rtot_t40_i1p5}
+};
+
+static int dischg_ib[6] = {150, 300, 500, 700, 1000, 1500};
+
+static int* chg_rtot[4][4] = {
+	{rtot_tm5_i0p3c,  rtot_t10_i0p3c,  rtot_t25_i0p3c,  rtot_t40_i0p3c},
+	{rtot_tm5_i0p5c,  rtot_t10_i0p5c,  rtot_t25_i0p5c,  rtot_t40_i0p5c},
+	{rtot_tm5_i0p7c,  rtot_t10_i0p7c,  rtot_t25_i0p7c,  rtot_t40_i0p7c},
+	{rtot_tm5_i1p0c,  rtot_t10_i1p0c,  rtot_t25_i1p0c,  rtot_t40_i1p0c}
+};
+
+static int chg_ib[4] = {300,500,700, 1000};
+
+#endif
diff --git a/include/linux/battery/sec_battery.h b/include/linux/battery/sec_battery.h
new file mode 100755
index 00000000..672e72d9
--- /dev/null
+++ b/include/linux/battery/sec_battery.h
@@ -0,0 +1,245 @@
+/*
+ * sec_battery.h
+ * Samsung Mobile Battery Header
+ *
+ *
+ * Copyright (C) 2012 Samsung Electronics, Inc.
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SEC_BATTERY_H
+#define __SEC_BATTERY_H __FILE__
+
+#include <linux/battery/sec_charging_common.h>
+#if defined(CONFIG_ANDROID_ALARM_ACTIVATED)
+#include <linux/android_alarm.h>
+#else
+#include <linux/alarmtimer.h>
+#endif
+#include <linux/wakelock.h>
+#include <linux/workqueue.h>
+#include <linux/proc_fs.h>
+#include <linux/jiffies.h>
+
+#define ADC_CH_COUNT		10
+#define ADC_SAMPLE_COUNT	10
+
+struct adc_sample_info {
+	unsigned int cnt;
+	int total_adc;
+	int average_adc;
+	int adc_arr[ADC_SAMPLE_COUNT];
+	int index;
+};
+
+struct sec_battery_info {
+	struct device *dev;
+	sec_battery_platform_data_t *pdata;
+	/* power supply used in Android */
+	struct power_supply psy_bat;
+	struct power_supply psy_usb;
+	struct power_supply psy_ac;
+	unsigned int irq;
+
+	int status;
+	int health;
+	bool present;
+
+	int voltage_now;		/* cell voltage (mV) */
+	int voltage_avg;		/* average voltage (mV) */
+	int voltage_ocv;		/* open circuit voltage (mV) */
+	int current_now;		/* current (mA) */
+	int current_avg;		/* average current (mA) */
+	int current_adc;
+
+	unsigned int capacity;			/* SOC (%) */
+
+	struct mutex adclock;
+	struct adc_sample_info	adc_sample[ADC_CH_COUNT];
+
+	/* keep awake until monitor is done */
+	struct wake_lock monitor_wake_lock;
+	struct workqueue_struct *monitor_wqueue;
+	struct delayed_work monitor_work;
+#if defined(CONFIG_SEC_GPIO_DVS)
+	struct delayed_work initdvs_work;
+#endif
+	unsigned int polling_count;
+	unsigned int polling_time;
+	bool polling_in_sleep;
+	bool polling_short;
+
+	struct delayed_work polling_work;
+	struct alarm polling_alarm;
+	ktime_t last_poll_time;
+
+	/* event set */
+	unsigned int event;
+	unsigned int event_wait;
+
+	struct alarm event_termination_alarm;
+
+	ktime_t	last_event_time;
+
+	/* battery check */
+	unsigned int check_count;
+	/* ADC check */
+	unsigned int check_adc_count;
+	unsigned int check_adc_value;
+
+	/* time check */
+	unsigned long charging_start_time;
+	unsigned long charging_passed_time;
+	unsigned long charging_next_time;
+	unsigned long charging_fullcharged_time;
+
+	/* temperature check */
+	int temperature;	/* battery temperature */
+	int temper_amb;		/* target temperature */
+
+	int temp_adc;
+	int temp_ambient_adc;
+
+	int temp_high_threshold;
+	int temp_high_recovery;
+	int temp_low_threshold;
+	int temp_low_recovery;
+
+	unsigned int temp_high_cnt;
+	unsigned int temp_low_cnt;
+	unsigned int temp_recover_cnt;
+
+	/* charging */
+	unsigned int charging_mode;
+	bool is_recharging;
+	int cable_type;
+	int extended_cable_type;
+	struct wake_lock cable_wake_lock;
+	struct work_struct cable_work;
+	struct wake_lock vbus_wake_lock;
+	unsigned int full_check_cnt;
+	unsigned int recharge_check_cnt;
+
+	/* wireless charging enable*/
+	int wc_enable;
+
+	/* test mode */
+	int test_activated;
+	bool factory_mode;
+	bool slate_mode;
+
+	int siop_level;
+	int siop_activated;
+};
+
+ssize_t sec_bat_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+ssize_t sec_usb_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+ssize_t sec_bat_store_attrs(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count);
+
+#define SEC_USB_ATTR(_name)						\
+{									\
+	.attr = {.name = #_name, .mode = 0664},	\
+	.show = sec_usb_show_attrs,					\
+}
+
+
+#define SEC_BATTERY_ATTR(_name)						\
+{									\
+	.attr = {.name = #_name, .mode = 0664},	\
+	.show = sec_bat_show_attrs,					\
+	.store = sec_bat_store_attrs,					\
+}
+
+/* event check */
+#define EVENT_NONE				(0)
+#define EVENT_2G_CALL			(0x1 << 0)
+#define EVENT_3G_CALL			(0x1 << 1)
+#define EVENT_MUSIC				(0x1 << 2)
+#define EVENT_VIDEO				(0x1 << 3)
+#define EVENT_BROWSER			(0x1 << 4)
+#define EVENT_HOTSPOT			(0x1 << 5)
+#define EVENT_CAMERA			(0x1 << 6)
+#define EVENT_CAMCORDER			(0x1 << 7)
+#define EVENT_DATA_CALL			(0x1 << 8)
+#define EVENT_WIFI				(0x1 << 9)
+#define EVENT_WIBRO				(0x1 << 10)
+#define EVENT_LTE				(0x1 << 11)
+#define EVENT_LCD			(0x1 << 12)
+#define EVENT_GPS			(0x1 << 13)
+
+enum {
+	BATT_RESET_SOC = 0,
+	BATT_READ_RAW_SOC,
+	BATT_READ_ADJ_SOC,
+	BATT_TYPE,
+	BATT_VFOCV,
+	BATT_VOL_ADC,
+	BATT_VOL_ADC_CAL,
+	BATT_VOL_AVER,
+	BATT_VOL_ADC_AVER,
+	BATT_TEMP_ADC,
+	BATT_TEMP_AVER,
+	BATT_TEMP_ADC_AVER,
+	BATT_VF_ADC,
+	BATT_SLATE_MODE,
+
+	BATT_LP_CHARGING,
+	SIOP_ACTIVATED,
+	SIOP_LEVEL,
+	BATT_CHARGING_SOURCE,
+	FG_REG_DUMP,
+	FG_RESET_CAP,
+	FG_CAPACITY,
+	AUTH,
+	CHG_CURRENT_ADC,
+	WC_ADC,
+	WC_STATUS,
+	WC_ENABLE,
+	FACTORY_MODE,
+	UPDATE,
+	TEST_MODE,
+
+	BATT_EVENT_CALL,
+	BATT_EVENT_2G_CALL,
+	BATT_EVENT_TALK_GSM,
+	BATT_EVENT_3G_CALL,
+	BATT_EVENT_TALK_WCDMA,
+	BATT_EVENT_MUSIC,
+	BATT_EVENT_VIDEO,
+	BATT_EVENT_BROWSER,
+	BATT_EVENT_HOTSPOT,
+	BATT_EVENT_CAMERA,
+	BATT_EVENT_CAMCORDER,
+	BATT_EVENT_DATA_CALL,
+	BATT_EVENT_WIFI,
+	BATT_EVENT_WIBRO,
+	BATT_EVENT_LTE,
+	BATT_EVENT_LCD,
+	BATT_EVENT_GPS,
+	BATT_EVENT,
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	BATT_TEST_CHARGE_CURRENT,
+#endif
+};
+
+enum {
+	CHARGING_MODE_BOOTING = 0,
+};
+
+#endif /* __SEC_BATTERY_H */
diff --git a/include/linux/battery/sec_charger.h b/include/linux/battery/sec_charger.h
new file mode 100755
index 00000000..5b3faf3d
--- /dev/null
+++ b/include/linux/battery/sec_charger.h
@@ -0,0 +1,151 @@
+/*
+ * sec_charger.h
+ * Samsung Mobile Charger Header
+ *
+ * Copyright (C) 2012 Samsung Electronics, Inc.
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SEC_CHARGER_H
+#define __SEC_CHARGER_H __FILE__
+
+#if defined(CONFIG_CHARGER_MFD)
+#define charger_variable charger
+#define charger_variable_t struct sec_charger_info
+#else
+#define charger_variable (charger->client)
+#define charger_variable_t struct i2c_client
+#endif
+
+#include <linux/battery/sec_charging_common.h>
+
+#if defined(CONFIG_CHARGER_DUMMY) || \
+	defined(CONFIG_CHARGER_PM8917)
+#include <linux/battery/charger/dummy_charger.h>
+#elif defined(CONFIG_CHARGER_MAX8903)
+#include <linux/battery/charger/max8903_charger.h>
+#elif defined(CONFIG_CHARGER_SMB327)
+#include <linux/battery/charger/smb327_charger.h>
+#elif defined(CONFIG_CHARGER_SMB328)
+#include <linux/battery/charger/smb328_charger.h>
+#elif defined(CONFIG_CHARGER_SMB347)
+#include <linux/battery/charger/smb347_charger.h>
+#elif defined(CONFIG_CHARGER_SMB358)
+#include <linux/battery/charger/smb358_charger.h>
+#elif defined(CONFIG_CHARGER_BQ24157)
+#include <linux/battery/charger/bq24157_charger.h>
+#elif defined(CONFIG_CHARGER_BQ24190) || \
+		defined(CONFIG_CHARGER_BQ24191)
+#include <linux/battery/charger/bq24190_charger.h>
+#elif defined(CONFIG_CHARGER_BQ24260)
+#include <linux/battery/charger/bq24260_charger.h>
+#elif defined(CONFIG_CHARGER_MAX77803)
+#include <linux/battery/charger/max77803_charger.h>
+#elif defined(CONFIG_CHARGER_NCP1851)
+#include <linux/battery/charger/ncp1851_charger.h>
+#elif defined(CONFIG_CHARGER_RT5033)
+#include <linux/battery/charger/rt5033_charger.h>
+#elif defined(CONFIG_STBC_SAMSUNG)
+#include <linux/battery/charger/stbcfg01_charger.h>
+#elif defined(CONFIG_CHARGER_RT9455)
+#include <linux/battery/charger/rt9455_charger.h>
+#endif
+
+struct sec_charger_info {
+	struct i2c_client		*client;
+	sec_battery_platform_data_t *pdata;
+	struct power_supply		psy_chg;
+	struct delayed_work isr_work;
+
+	struct workqueue_struct *wq;
+	struct delayed_work delayed_work;
+
+	int cable_type;
+	int status;
+	bool is_charging;
+
+	/* HW-dedicated charger info structure
+	 * used in individual charger file only
+	 * (ex. dummy_charger.c)
+	 */
+#if defined(CONFIG_BATTERY_SAMSUNG) && defined(CONFIG_CHARGER_BQ24157)
+		struct sec_chg_info info;
+#endif
+
+	/* charging current : + charging, - OTG */
+	int charging_current;
+	unsigned charging_current_max;
+
+	/* register programming */
+	int reg_addr;
+	int reg_data;
+	int irq_base;
+
+};
+#if defined(CONFIG_STBC_SAMSUNG)
+bool sec_hal_chg_init(charger_variable_t *);
+bool sec_hal_chg_suspend(charger_variable_t *);
+bool sec_hal_chg_resume(charger_variable_t *);
+bool sec_hal_chg_shutdown(charger_variable_t *);
+bool sec_hal_chg_get_property(charger_variable_t *,
+				enum power_supply_property,
+				union power_supply_propval *);
+bool sec_hal_chg_set_property(charger_variable_t *,
+				enum power_supply_property,
+				const union power_supply_propval *);
+#else
+bool sec_hal_chg_init(struct i2c_client *);
+bool sec_hal_chg_suspend(struct i2c_client *);
+bool sec_hal_chg_resume(struct i2c_client *);
+bool sec_hal_chg_shutdown(struct i2c_client *);
+bool sec_hal_chg_get_property(struct i2c_client *,
+				enum power_supply_property,
+				union power_supply_propval *);
+bool sec_hal_chg_set_property(struct i2c_client *,
+				enum power_supply_property,
+				const union power_supply_propval *);
+#endif
+ssize_t sec_hal_chg_show_attrs(struct device *dev,
+				const ptrdiff_t offset, char *buf);
+
+ssize_t sec_hal_chg_store_attrs(struct device *dev,
+				const ptrdiff_t offset,
+				const char *buf, size_t count);
+
+ssize_t sec_chg_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+ssize_t sec_chg_store_attrs(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count);
+
+#define SEC_CHARGER_ATTR(_name)				\
+{							\
+	.attr = {.name = #_name, .mode = 0664},	\
+	.show = sec_chg_show_attrs,			\
+	.store = sec_chg_store_attrs,			\
+}
+
+static struct device_attribute sec_charger_attrs[] = {
+	SEC_CHARGER_ATTR(reg),
+	SEC_CHARGER_ATTR(data),
+	SEC_CHARGER_ATTR(regs),
+};
+
+enum {
+	CHG_REG = 0,
+	CHG_DATA,
+	CHG_REGS,
+};
+
+#endif /* __SEC_CHARGER_H */
diff --git a/include/linux/battery/sec_charging_common.h b/include/linux/battery/sec_charging_common.h
new file mode 100755
index 00000000..c7a839ac
--- /dev/null
+++ b/include/linux/battery/sec_charging_common.h
@@ -0,0 +1,594 @@
+/*
+ * sec_charging_common.h
+ * Samsung Mobile Charging Common Header
+ *
+ * Copyright (C) 2012 Samsung Electronics, Inc.
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SEC_CHARGING_COMMON_H
+#define __SEC_CHARGING_COMMON_H __FILE__
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/power_supply.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/wakelock.h>
+
+
+/* definitions */
+#define	SEC_SIZEOF_POWER_SUPPLY_TYPE	13
+
+enum sec_battery_voltage_mode {
+	/* average voltage */
+	SEC_BATTEY_VOLTAGE_AVERAGE = 0,
+	/* open circuit voltage */
+	SEC_BATTEY_VOLTAGE_OCV,
+};
+
+enum sec_battery_capacity_mode {
+	/* designed capacity */
+	SEC_BATTEY_CAPACITY_DESIGNED = 0,
+	/* absolute capacity by fuel gauge */
+	SEC_BATTEY_CAPACITY_ABSOLUTE,
+	/* temperary capacity in the time */
+	SEC_BATTEY_CAPACITY_TEMPERARY,
+	/* current capacity now */
+	SEC_BATTEY_CAPACITY_CURRENT,
+};
+
+/* ADC type */
+#define SEC_BATTERY_ADC_TYPE_NUM	3
+
+enum sec_battery_adc_type {
+	/* NOT using this ADC channel */
+	SEC_BATTERY_ADC_TYPE_NONE = 0,
+	/* ADC in AP */
+	SEC_BATTERY_ADC_TYPE_AP,
+	/* ADC by additional IC */
+	SEC_BATTERY_ADC_TYPE_IC,
+};
+
+enum sec_battery_adc_channel {
+	SEC_BAT_ADC_CHANNEL_CABLE_CHECK = 0,
+	SEC_BAT_ADC_CHANNEL_BAT_CHECK,
+	SEC_BAT_ADC_CHANNEL_TEMP,
+	SEC_BAT_ADC_CHANNEL_TEMP_AMBIENT,
+	SEC_BAT_ADC_CHANNEL_FULL_CHECK,
+};
+
+/* charging mode */
+enum sec_battery_charging_mode {
+	/* no charging */
+	SEC_BATTERY_CHARGING_NONE = 0,
+	/* 1st charging */
+	SEC_BATTERY_CHARGING_1ST,
+	/* 2nd charging */
+	SEC_BATTERY_CHARGING_2ND,
+	/* recharging */
+	SEC_BATTERY_CHARGING_RECHARGING,
+	/* abs charging*/
+	SEC_BATTERY_CHARGING_ABS,
+};
+
+struct sec_bat_adc_api {
+	bool (*init)(struct platform_device *);
+	bool (*exit)(void);
+	int (*read)(unsigned int);
+};
+#define sec_bat_adc_api_t struct sec_bat_adc_api
+
+/* monitor activation */
+enum sec_battery_polling_time_type {
+	/* same order with power supply status */
+	SEC_BATTERY_POLLING_TIME_BASIC = 0,
+	SEC_BATTERY_POLLING_TIME_CHARGING,
+	SEC_BATTERY_POLLING_TIME_DISCHARGING,
+	SEC_BATTERY_POLLING_TIME_NOT_CHARGING,
+	SEC_BATTERY_POLLING_TIME_SLEEP,
+};
+
+enum sec_battery_monitor_polling {
+	/* polling work queue */
+	SEC_BATTERY_MONITOR_WORKQUEUE,
+	/* alarm polling */
+	SEC_BATTERY_MONITOR_ALARM,
+	/* timer polling (NOT USE) */
+	SEC_BATTERY_MONITOR_TIMER,
+};
+#define sec_battery_monitor_polling_t \
+	enum sec_battery_monitor_polling
+
+/* full charged check : POWER_SUPPLY_PROP_STATUS */
+enum sec_battery_full_charged {
+	SEC_BATTERY_FULLCHARGED_NONE = 0,
+	/* current check by ADC */
+	SEC_BATTERY_FULLCHARGED_ADC,
+	/* fuel gauge current check */
+	SEC_BATTERY_FULLCHARGED_FG_CURRENT,
+	/* time check */
+	SEC_BATTERY_FULLCHARGED_TIME,
+	/* SOC check */
+	SEC_BATTERY_FULLCHARGED_SOC,
+	/* charger GPIO, NO additional full condition */
+	SEC_BATTERY_FULLCHARGED_CHGGPIO,
+	/* charger interrupt, NO additional full condition */
+	SEC_BATTERY_FULLCHARGED_CHGINT,
+	/* charger power supply property, NO additional full condition */
+	SEC_BATTERY_FULLCHARGED_CHGPSY,
+};
+#define sec_battery_full_charged_t \
+	enum sec_battery_full_charged
+
+/* full check condition type (can be used overlapped) */
+#define sec_battery_full_condition_t unsigned int
+/* SEC_BATTERY_FULL_CONDITION_NOTIMEFULL
+  * full-charged by absolute-timer only in high voltage
+  */
+#define SEC_BATTERY_FULL_CONDITION_NOTIMEFULL	1
+/* SEC_BATTERY_FULL_CONDITION_SLEEPINFULL
+  * change polling time as sleep polling time even in full-charged
+  */
+#define SEC_BATTERY_FULL_CONDITION_NOSLEEPINFULL	2
+/* SEC_BATTERY_FULL_CONDITION_SOC
+  * use capacity for full-charged check
+  */
+#define SEC_BATTERY_FULL_CONDITION_SOC		4
+/* SEC_BATTERY_FULL_CONDITION_VCELL
+  * use VCELL for full-charged check
+  */
+#define SEC_BATTERY_FULL_CONDITION_VCELL	8
+/* SEC_BATTERY_FULL_CONDITION_AVGVCELL
+  * use average VCELL for full-charged check
+  */
+#define SEC_BATTERY_FULL_CONDITION_AVGVCELL	16
+/* SEC_BATTERY_FULL_CONDITION_OCV
+  * use OCV for full-charged check
+  */
+#define SEC_BATTERY_FULL_CONDITION_OCV		32
+
+/* recharge check condition type (can be used overlapped) */
+#define sec_battery_recharge_condition_t unsigned int
+/* SEC_BATTERY_RECHARGE_CONDITION_SOC
+  * use capacity for recharging check
+  */
+#define SEC_BATTERY_RECHARGE_CONDITION_SOC		1
+/* SEC_BATTERY_RECHARGE_CONDITION_AVGVCELL
+  * use average VCELL for recharging check
+  */
+#define SEC_BATTERY_RECHARGE_CONDITION_AVGVCELL		2
+/* SEC_BATTERY_RECHARGE_CONDITION_VCELL
+  * use VCELL for recharging check
+  */
+#define SEC_BATTERY_RECHARGE_CONDITION_VCELL		4
+
+/* battery check : POWER_SUPPLY_PROP_PRESENT */
+enum sec_battery_check {
+	/* No Check for internal battery */
+	SEC_BATTERY_CHECK_NONE,
+	/* by ADC */
+	SEC_BATTERY_CHECK_ADC,
+	/* by callback function (battery certification by 1 wired)*/
+	SEC_BATTERY_CHECK_CALLBACK,
+	/* by PMIC */
+	SEC_BATTERY_CHECK_PMIC,
+	/* by fuel gauge */
+	SEC_BATTERY_CHECK_FUELGAUGE,
+	/* by charger */
+	SEC_BATTERY_CHECK_CHARGER,
+	/* by interrupt (use check_battery_callback() to check battery) */
+	SEC_BATTERY_CHECK_INT,
+};
+#define sec_battery_check_t \
+	enum sec_battery_check
+
+/* OVP, UVLO check : POWER_SUPPLY_PROP_HEALTH */
+enum sec_battery_ovp_uvlo {
+	/* by callback function */
+	SEC_BATTERY_OVP_UVLO_CALLBACK,
+	/* by PMIC polling */
+	SEC_BATTERY_OVP_UVLO_PMICPOLLING,
+	/* by PMIC interrupt */
+	SEC_BATTERY_OVP_UVLO_PMICINT,
+	/* by charger polling */
+	SEC_BATTERY_OVP_UVLO_CHGPOLLING,
+	/* by charger interrupt */
+	SEC_BATTERY_OVP_UVLO_CHGINT,
+};
+#define sec_battery_ovp_uvlo_t \
+	enum sec_battery_ovp_uvlo
+
+/* thermal source */
+enum sec_battery_thermal_source {
+	/* by fuel gauge */
+	SEC_BATTERY_THERMAL_SOURCE_FG,
+	/* by external source */
+	SEC_BATTERY_THERMAL_SOURCE_CALLBACK,
+	/* by ADC */
+	SEC_BATTERY_THERMAL_SOURCE_ADC,
+};
+#define sec_battery_thermal_source_t \
+	enum sec_battery_thermal_source
+
+/* temperature check type */
+enum sec_battery_temp_check {
+	SEC_BATTERY_TEMP_CHECK_NONE = 0,	/* no temperature check */
+	SEC_BATTERY_TEMP_CHECK_ADC,	/* by ADC value */
+	SEC_BATTERY_TEMP_CHECK_TEMP,	/* by temperature */
+};
+#define sec_battery_temp_check_t \
+	enum sec_battery_temp_check
+
+/* cable check (can be used overlapped) */
+#define sec_battery_cable_check_t unsigned int
+/* SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE
+  * for USB cable in tablet model,
+  * status is stuck into discharging,
+  * but internal charging logic is working
+  */
+#define SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE		1
+/* SEC_BATTERY_CABLE_CHECK_NOINCOMPATIBLECHARGE
+  * for incompatible charger
+  * (Not compliant to USB specification,
+  *  cable type is POWER_SUPPLY_TYPE_UNKNOWN),
+  * do NOT charge and show message to user
+  * (only for VZW)
+  */
+#define SEC_BATTERY_CABLE_CHECK_NOINCOMPATIBLECHARGE	2
+/* SEC_BATTERY_CABLE_CHECK_PSY
+  * check cable by power supply set_property
+  */
+#define SEC_BATTERY_CABLE_CHECK_PSY			4
+/* SEC_BATTERY_CABLE_CHECK_INT
+  * check cable by interrupt
+  */
+#define SEC_BATTERY_CABLE_CHECK_INT			8
+/* SEC_BATTERY_CABLE_CHECK_CHGINT
+  * check cable by charger interrupt
+  */
+#define SEC_BATTERY_CABLE_CHECK_CHGINT			16
+/* SEC_BATTERY_CABLE_CHECK_POLLING
+  * check cable by GPIO polling
+  */
+#define SEC_BATTERY_CABLE_CHECK_POLLING			32
+
+/* check cable source (can be used overlapped) */
+#define sec_battery_cable_source_t unsigned int
+/* SEC_BATTERY_CABLE_SOURCE_EXTERNAL
+ * already given by external argument
+ */
+#define	SEC_BATTERY_CABLE_SOURCE_EXTERNAL	1
+/* SEC_BATTERY_CABLE_SOURCE_CALLBACK
+ * by callback (MUIC, USB switch)
+ */
+#define	SEC_BATTERY_CABLE_SOURCE_CALLBACK	2
+/* SEC_BATTERY_CABLE_SOURCE_ADC
+ * by ADC
+ */
+#define	SEC_BATTERY_CABLE_SOURCE_ADC		4
+/* SEC_BATTERY_CABLE_SOURCE_EXTENDED
+ * use extended cable type
+ */
+#define SEC_BATTERY_CABLE_SOURCE_EXTENDED	8
+
+/* capacity calculation type (can be used overlapped) */
+#define sec_fuelgauge_capacity_type_t int
+/* SEC_FUELGAUGE_CAPACITY_TYPE_RESET
+  * use capacity information to reset fuel gauge
+  * (only for driver algorithm, can NOT be set by user)
+  */
+#define SEC_FUELGAUGE_CAPACITY_TYPE_RESET	(-1)
+/* SEC_FUELGAUGE_CAPACITY_TYPE_RAW
+  * use capacity information from fuel gauge directly
+  */
+#define SEC_FUELGAUGE_CAPACITY_TYPE_RAW		1
+/* SEC_FUELGAUGE_CAPACITY_TYPE_SCALE
+  * rescale capacity by scaling, need min and max value for scaling
+  */
+#define SEC_FUELGAUGE_CAPACITY_TYPE_SCALE	2
+/* SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE
+  * change only maximum capacity dynamically
+  * to keep time for every SOC unit
+  */
+#define SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE	4
+/* SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC
+  * change capacity value by only -1 or +1
+  * no sudden change of capacity
+  */
+#define SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC	8
+/* SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL
+  * skip current capacity value
+  * if it is abnormal value
+  */
+#define SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL	16
+
+/* charger function settings (can be used overlapped) */
+#define sec_charger_functions_t unsigned int
+/* SEC_CHARGER_NO_GRADUAL_CHARGING_CURRENT
+ * disable gradual charging current setting
+ * SUMMIT:AICL, MAXIM:regulation loop
+ */
+#define SEC_CHARGER_NO_GRADUAL_CHARGING_CURRENT		1
+
+/* SEC_CHARGER_MINIMUM_SIOP_CHARGING_CURRENT
+ * charging current should be over than USB charging current
+ */
+#define SEC_CHARGER_MINIMUM_SIOP_CHARGING_CURRENT	2
+
+/**
+ * struct sec_bat_adc_table_data - adc to temperature table for sec battery
+ * driver
+ * @adc: adc value
+ * @temperature: temperature(C) * 10
+ */
+struct sec_bat_adc_table_data {
+	int adc;
+	int temperature;
+};
+#define sec_bat_adc_table_data_t \
+	struct sec_bat_adc_table_data
+
+struct sec_bat_adc_region {
+	int min;
+	int max;
+};
+#define sec_bat_adc_region_t \
+	struct sec_bat_adc_region
+
+struct sec_charging_current {
+	int input_current_limit;
+	int fast_charging_current;
+	int full_check_current_1st;
+	int full_check_current_2nd;
+};
+#define sec_charging_current_t \
+	struct sec_charging_current
+
+struct sec_battery_platform_data {
+	/* NO NEED TO BE CHANGED */
+	/* callback functions */
+	void (*initial_check)(void);
+	bool (*bat_gpio_init)(void);
+	bool (*fg_gpio_init)(void);
+	bool (*chg_gpio_init)(void);
+	bool (*is_lpm)(void);
+	bool (*check_jig_status) (void);
+	bool (*is_interrupt_cable_check_possible)(int);
+	int (*check_cable_callback)(void);
+	int (*get_cable_from_extended_cable_type)(int);
+	bool (*cable_switch_check)(void);
+	bool (*cable_switch_normal)(void);
+	bool (*check_cable_result_callback)(int);
+	bool (*check_battery_callback)(void);
+	bool (*check_battery_result_callback)(void);
+	int (*ovp_uvlo_callback)(void);
+	bool (*ovp_uvlo_result_callback)(int);
+	bool (*fuelalert_process)(bool);
+	bool (*get_temperature_callback)(
+			enum power_supply_property,
+			union power_supply_propval*);
+	void  (*check_vf_callback)(void);
+
+	/* ADC API for each ADC type */
+	sec_bat_adc_api_t adc_api[SEC_BATTERY_ADC_TYPE_NUM];
+	/* ADC region by power supply type
+	 * ADC region should be exclusive
+	 */
+	sec_bat_adc_region_t *cable_adc_value;
+	/* charging current for type (0: not use) */
+	sec_charging_current_t *charging_current;
+	int *polling_time;
+	/* NO NEED TO BE CHANGED */
+
+	char *pmic_name;
+
+	/* battery */
+	char *vendor;
+	int technology;
+	int battery_type;
+	void *battery_data;
+
+	int bat_gpio_ta_nconnected;
+	/* 1 : active high, 0 : active low */
+	int bat_polarity_ta_nconnected;
+	int bat_irq;
+	unsigned long bat_irq_attr;
+	int jig_irq;
+	unsigned long jig_irq_attr;
+	sec_battery_cable_check_t cable_check_type;
+	sec_battery_cable_source_t cable_source_type;
+
+	bool use_LED;				/* use charging LED */
+
+	bool event_check;
+	/* sustaining event after deactivated (second) */
+	unsigned int event_waiting_time;
+
+	/* Monitor setting */
+	sec_battery_monitor_polling_t polling_type;
+	/* for initial check */
+	unsigned int monitor_initial_count;
+
+	/* Battery check */
+	sec_battery_check_t battery_check_type;
+	/* how many times do we need to check battery */
+	unsigned int check_count;
+	/* ADC */
+	/* battery check ADC maximum value */
+	unsigned int check_adc_max;
+	/* battery check ADC minimum value */
+	unsigned int check_adc_min;
+
+	/* OVP/UVLO check */
+	sec_battery_ovp_uvlo_t ovp_uvlo_check_type;
+
+	sec_battery_thermal_source_t thermal_source;
+	const sec_bat_adc_table_data_t *temp_adc_table;
+	unsigned int temp_adc_table_size;
+	const sec_bat_adc_table_data_t *temp_amb_adc_table;
+	unsigned int temp_amb_adc_table_size;
+
+	sec_battery_temp_check_t temp_check_type;
+	unsigned int temp_check_count;
+	/*
+	 * limit can be ADC value or Temperature
+	 * depending on temp_check_type
+	 * temperature should be temp x 10 (0.1 degree)
+	 */
+	int temp_high_threshold_event;
+	int temp_high_recovery_event;
+	int temp_low_threshold_event;
+	int temp_low_recovery_event;
+	int temp_high_threshold_normal;
+	int temp_high_recovery_normal;
+	int temp_low_threshold_normal;
+	int temp_low_recovery_normal;
+	int temp_high_threshold_lpm;
+	int temp_high_recovery_lpm;
+	int temp_low_threshold_lpm;
+	int temp_low_recovery_lpm;
+
+	/* If these is NOT full check type or NONE full check type,
+	 * it is skipped
+	 */
+	/* 1st full check */
+	sec_battery_full_charged_t full_check_type;
+	/* 2nd full check */
+	sec_battery_full_charged_t full_check_type_2nd;
+	unsigned int full_check_count;
+	unsigned int full_check_adc_1st;
+	unsigned int full_check_adc_2nd;
+	int chg_gpio_full_check;
+	/* 1 : active high, 0 : active low */
+	int chg_polarity_full_check;
+	sec_battery_full_condition_t full_condition_type;
+	unsigned int full_condition_soc;
+	unsigned int full_condition_vcell;
+	unsigned int full_condition_avgvcell;
+	unsigned int full_condition_ocv;
+
+	unsigned int recharge_check_count;
+	sec_battery_recharge_condition_t recharge_condition_type;
+	unsigned int recharge_condition_soc;
+	unsigned int recharge_condition_avgvcell;
+	unsigned int recharge_condition_vcell;
+
+	/* for absolute timer (second) */
+	unsigned long charging_total_time;
+	/* for recharging timer (second) */
+	unsigned long recharging_total_time;
+	/* reset charging for abnormal malfunction (0: not use) */
+	unsigned long charging_reset_time;
+
+	/* fuel gauge */
+	char *fuelgauge_name;
+	int fg_irq;
+	unsigned long fg_irq_attr;
+	/* fuel alert SOC (-1: not use) */
+	int fuel_alert_soc;
+	/* fuel alert can be repeated */
+	bool repeated_fuelalert;
+	sec_fuelgauge_capacity_type_t capacity_calculation_type;
+	/* soc should be soc x 10 (0.1% degree)
+	 * only for scaling
+	 */
+	unsigned int capacity_max;
+	unsigned int capacity_max_margin;
+	unsigned int capacity_min;
+
+	int vf_adc;
+
+	/* charger */
+	char *charger_name;
+	int chg_gpio_en;
+	/* 1 : active high, 0 : active low */
+	int chg_polarity_en;
+	int chg_gpio_curr_adj;
+	/* 1 : active high, 0 : active low */
+	int chg_polarity_curr_adj;
+	int chg_gpio_status;
+	/* 1 : active high, 0 : active low */
+	int chg_polarity_status;
+	int chg_irq;
+	unsigned long chg_irq_attr;
+	/* float voltage (mV) */
+	int chg_float_voltage;
+	sec_charger_functions_t chg_functions_setting;
+
+	int siop_level;
+	bool siop_activated;
+
+	/* ADC setting */
+	unsigned int adc_check_count;
+	/* ADC type for each channel */
+	unsigned int adc_type[];
+};
+#define sec_battery_platform_data_t \
+	struct sec_battery_platform_data
+
+static inline struct power_supply *get_power_supply_by_name(char *name)
+{
+	if (!name)
+		return (struct power_supply *)NULL;
+	else
+		return power_supply_get_by_name(name);
+}
+
+#define psy_do_property(name, function, property, value) \
+{	\
+	struct power_supply *psy;	\
+	int ret;	\
+	psy = get_power_supply_by_name((name));	\
+	if (!psy) {	\
+		pr_err("%s: Fail to "#function" psy (%s)\n",	\
+			__func__, (name));	\
+		value.intval = 0;	\
+	} else {	\
+		ret = psy->function##_property(psy, (property), &(value)); \
+		if (ret < 0) {	\
+			pr_err("%s: Fail to "#name" "#function" (%d=>%d)\n", \
+				__func__, (property), ret);	\
+			value.intval = 0;	\
+		}	\
+	}	\
+}
+
+#define adc_init(pdev, pdata, channel)	\
+	(((pdata)->adc_api)[((pdata)->adc_type[(channel)])].init((pdev)))
+
+#define adc_exit(pdata, channel)	\
+	(((pdata)->adc_api)[((pdata)->adc_type[(channel)])].exit())
+
+#define adc_read(pdata, channel)	\
+	(((pdata)->adc_api)[((pdata)->adc_type[(channel)])].read((channel)))
+
+#define get_battery_data(driver)	\
+	(((struct battery_data_t *)(driver)->pdata->battery_data)	\
+	[(driver)->pdata->battery_type])
+
+#define GET_MAIN_CABLE_TYPE(extended)	\
+	((extended >> ONLINE_TYPE_MAIN_SHIFT)&0xf)
+#define GET_SUB_CABLE_TYPE(extended)	\
+	((extended >> ONLINE_TYPE_SUB_SHIFT)&0xf)
+#define GET_POWER_CABLE_TYPE(extended)	\
+	((extended >> ONLINE_TYPE_PWR_SHIFT)&0xf)
+
+#endif /* __SEC_CHARGING_COMMON_H */
diff --git a/include/linux/battery/sec_fuelgauge.h b/include/linux/battery/sec_fuelgauge.h
new file mode 100755
index 00000000..0202d77f
--- /dev/null
+++ b/include/linux/battery/sec_fuelgauge.h
@@ -0,0 +1,143 @@
+/*
+ * sec_fuelgauge.h
+ * Samsung Mobile Fuel Gauge Header
+ *
+ * Copyright (C) 2012 Samsung Electronics, Inc.
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SEC_FUELGAUGE_H
+#define __SEC_FUELGAUGE_H __FILE__
+
+#if defined(CONFIG_FUELGAUGE_MFD)
+#define fuelgauge_variable fuelgauge
+#define fuelgauge_variable_t struct sec_fuelgauge_info
+#else
+#define fuelgauge_variable (fuelgauge->client)
+#define fuelgauge_variable_t struct i2c_client
+#endif
+
+#include <linux/battery/sec_charging_common.h>
+
+#if defined(CONFIG_FUELGAUGE_DUMMY) || \
+	defined(CONFIG_FUELGAUGE_PM8917)
+#include <linux/battery/fuelgauge/dummy_fuelgauge.h>
+#elif defined(CONFIG_FUELGAUGE_ADC)
+#include <linux/battery/fuelgauge/adc_fuelgauge.h>
+#elif defined(CONFIG_FUELGAUGE_MAX17042)
+#include <linux/battery/fuelgauge/max17042_fuelgauge.h>
+#elif defined(CONFIG_FUELGAUGE_MAX17048)
+#include <linux/battery/fuelgauge/max17048_fuelgauge.h>
+#elif defined(CONFIG_FUELGAUGE_MAX17050)
+#include <linux/battery/fuelgauge/max17050_fuelgauge.h>
+#elif defined(CONFIG_FUELGAUGE_STC3115)
+#include <linux/battery/fuelgauge/stc3115_fuelgauge.h>
+#elif defined(CONFIG_FUELGAUGE_D2199)
+#include <linux/battery/fuelgauge/d2199_fuelgauge.h>
+#elif defined(CONFIG_FUELGAUGE_RT5033)
+#include <linux/battery/fuelgauge/rt5033_fuelgauge.h>
+#elif defined(CONFIG_STBC_SAMSUNG)
+#include <linux/battery/fuelgauge/stbcfg01_fuelgauge.h>
+#elif defined (CONFIG_FUELGAUGE_88PM822)
+#include <linux/battery/fuelgauge/88pm80x_fg.h>
+#endif
+
+struct sec_fuelgauge_reg_data {
+	u8 reg_addr;
+	u8 reg_data1;
+	u8 reg_data2;
+};
+
+struct sec_fuelgauge_info {
+	struct i2c_client		*client;
+	sec_battery_platform_data_t *pdata;
+	struct power_supply		psy_fg;
+	struct delayed_work isr_work;
+
+	int cable_type;
+	bool is_charging;
+
+	/* HW-dedicated fuel guage info structure
+	 * used in individual fuel gauge file only
+	 * (ex. dummy_fuelgauge.c)
+	 */
+
+	struct sec_fg_info	info;
+
+	bool is_fuel_alerted;
+	struct wake_lock fuel_alert_wake_lock;
+
+	unsigned int capacity_old;	/* only for atomic calculation */
+	unsigned int capacity_max;	/* only for dynamic calculation */
+
+	bool initial_update_of_soc;
+	struct mutex fg_lock;
+
+	/* register programming */
+	int reg_addr;
+	u8 reg_data[2];
+
+};
+
+bool sec_hal_fg_init(fuelgauge_variable_t *);
+bool sec_hal_fg_suspend(fuelgauge_variable_t *);
+bool sec_hal_fg_resume(fuelgauge_variable_t *);
+bool sec_hal_fg_fuelalert_init(fuelgauge_variable_t *, int);
+bool sec_hal_fg_is_fuelalerted(fuelgauge_variable_t *);
+bool sec_hal_fg_fuelalert_process(void *, bool);
+bool sec_hal_fg_full_charged(fuelgauge_variable_t *);
+bool sec_hal_fg_reset(fuelgauge_variable_t *);
+bool sec_hal_fg_get_property(fuelgauge_variable_t *,
+				enum power_supply_property,
+				union power_supply_propval *);
+bool sec_hal_fg_set_property(fuelgauge_variable_t *,
+				enum power_supply_property,
+				const union power_supply_propval *);
+
+ssize_t sec_hal_fg_show_attrs(struct device *dev,
+				const ptrdiff_t offset, char *buf);
+
+ssize_t sec_hal_fg_store_attrs(struct device *dev,
+				const ptrdiff_t offset,
+				const char *buf, size_t count);
+
+ssize_t sec_fg_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+ssize_t sec_fg_store_attrs(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count);
+
+#define SEC_FG_ATTR(_name)				\
+{							\
+	.attr = {.name = #_name, .mode = 0664},	\
+	.show = sec_fg_show_attrs,			\
+	.store = sec_fg_store_attrs,			\
+}
+
+#if defined(CONFIG_FUELGAUGE_D2199)
+enum {
+	FG_REG = 0,
+	FG_DATA,
+	FG_REGS,
+};
+#else
+enum {
+	FG_CURR_UA = 0,
+	FG_REG,
+	FG_DATA,
+	FG_REGS,
+};
+#endif
+
+#endif /* __SEC_FUELGAUGE_H */
diff --git a/include/linux/capability.h b/include/linux/capability.h
index 12d52ded..c398cff3 100644
--- a/include/linux/capability.h
+++ b/include/linux/capability.h
@@ -360,8 +360,11 @@ struct cpu_vfs_cap_data {
 
 #define CAP_WAKE_ALARM            35
 
+/* Allow preventing system suspends while epoll events are pending */
 
-#define CAP_LAST_CAP         CAP_WAKE_ALARM
+#define CAP_EPOLLWAKEUP      36
+
+#define CAP_LAST_CAP         CAP_EPOLLWAKEUP
 
 #define cap_valid(x) ((x) >= 0 && (x) <= CAP_LAST_CAP)
 
diff --git a/include/linux/cgroup.h b/include/linux/cgroup.h
index 5a85b341..b2a37357 100644
--- a/include/linux/cgroup.h
+++ b/include/linux/cgroup.h
@@ -84,12 +84,6 @@ enum {
 	CSS_REMOVED, /* This CSS is dead */
 };
 
-/* Caller must verify that the css is not for root cgroup */
-static inline void __css_get(struct cgroup_subsys_state *css, int count)
-{
-	atomic_add(count, &css->refcnt);
-}
-
 /*
  * Call css_get() to hold a reference on the css; it can be used
  * for a reference obtained via:
@@ -97,6 +91,7 @@ static inline void __css_get(struct cgroup_subsys_state *css, int count)
  * - task->cgroups for a locked task
  */
 
+extern void __css_get(struct cgroup_subsys_state *css, int count);
 static inline void css_get(struct cgroup_subsys_state *css)
 {
 	/* We don't need to reference count the root state */
@@ -143,10 +138,7 @@ static inline void css_put(struct cgroup_subsys_state *css)
 enum {
 	/* Control Group is dead */
 	CGRP_REMOVED,
-	/*
-	 * Control Group has previously had a child cgroup or a task,
-	 * but no longer (only if CGRP_NOTIFY_ON_RELEASE is set)
-	 */
+	/* Control Group has ever had a child cgroup or a task */
 	CGRP_RELEASABLE,
 	/* Control Group requires release notifications to userspace */
 	CGRP_NOTIFY_ON_RELEASE,
@@ -255,6 +247,7 @@ struct css_set {
 
 	/* For RCU-protected deletion */
 	struct rcu_head rcu_head;
+	struct work_struct work;
 };
 
 /*
@@ -455,6 +448,7 @@ struct cgroup_subsys {
 	struct cgroup_subsys_state *(*create)(struct cgroup *cgrp);
 	int (*pre_destroy)(struct cgroup *cgrp);
 	void (*destroy)(struct cgroup *cgrp);
+	int (*allow_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);
 	int (*can_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);
 	void (*cancel_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);
 	void (*attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);
diff --git a/include/linux/clk.h b/include/linux/clk.h
index b0252726..70cf722a 100644
--- a/include/linux/clk.h
+++ b/include/linux/clk.h
@@ -100,6 +100,26 @@ int clk_notifier_unregister(struct clk *clk, struct notifier_block *nb);
  */
 struct clk *clk_get(struct device *dev, const char *id);
 
+/**
+ * devm_clk_get - lookup and obtain a managed reference to a clock producer.
+ * @dev: device for clock "consumer"
+ * @id: clock comsumer ID
+ *
+ * Returns a struct clk corresponding to the clock producer, or
+ * valid IS_ERR() condition containing errno.  The implementation
+ * uses @dev and @id to determine the clock consumer, and thereby
+ * the clock producer.  (IOW, @id may be identical strings, but
+ * clk_get may return different clock producers depending on @dev.)
+ *
+ * Drivers must assume that the clock source is not enabled.
+ *
+ * devm_clk_get should not be called from within interrupt context.
+ *
+ * The clock will automatically be freed when the device is unbound
+ * from the bus.
+ */
+struct clk *devm_clk_get(struct device *dev, const char *id);
+
 /**
  * clk_prepare - prepare a clock source
  * @clk: clock source
@@ -206,6 +226,18 @@ unsigned long clk_get_rate(struct clk *clk);
  */
 void clk_put(struct clk *clk);
 
+/**
+ * devm_clk_put	- "free" a managed clock source
+ * @dev: device used to acuqire the clock
+ * @clk: clock source acquired with devm_clk_get()
+ *
+ * Note: drivers must ensure that all clk_enable calls made on this
+ * clock source are balanced by clk_disable calls prior to calling
+ * this function.
+ *
+ * clk_put should not be called from within interrupt context.
+ */
+void devm_clk_put(struct device *dev, struct clk *clk);
 
 /*
  * The remaining APIs are optional for machine class support.
diff --git a/include/linux/cpu.h b/include/linux/cpu.h
index ee28844a..11dd01b8 100644
--- a/include/linux/cpu.h
+++ b/include/linux/cpu.h
@@ -212,4 +212,11 @@ static inline int disable_nonboot_cpus(void) { return 0; }
 static inline void enable_nonboot_cpus(void) {}
 #endif /* !CONFIG_PM_SLEEP_SMP */
 
+#define IDLE_START 1
+#define IDLE_END 2
+
+void idle_notifier_register(struct notifier_block *n);
+void idle_notifier_unregister(struct notifier_block *n);
+void idle_notifier_call_chain(unsigned long val);
+
 #endif /* _LINUX_CPU_H_ */
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index b60f6ba0..a05dcec2 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -90,7 +90,9 @@ struct cpufreq_policy {
 	cpumask_var_t		related_cpus; /* CPUs with any coordination */
 	unsigned int		shared_type; /* ANY or ALL affected CPUs
 						should set cpufreq */
-	unsigned int		cpu;    /* cpu nr of registered CPU */
+	unsigned int		cpu;    /* cpu nr of CPU managing this policy */
+	unsigned int		last_cpu; /* cpu nr of previous CPU that managed
+					   * this policy */
 	struct cpufreq_cpuinfo	cpuinfo;/* see above */
 
 	unsigned int		min;    /* in kHz */
@@ -113,6 +115,7 @@ struct cpufreq_policy {
 #define CPUFREQ_INCOMPATIBLE	(1)
 #define CPUFREQ_NOTIFY		(2)
 #define CPUFREQ_START		(3)
+#define CPUFREQ_UPDATE_POLICY_CPU	(4)
 
 #define CPUFREQ_SHARED_TYPE_NONE (0) /* None */
 #define CPUFREQ_SHARED_TYPE_HW	 (1) /* HW does needed coordination */
@@ -364,6 +367,9 @@ extern struct cpufreq_governor cpufreq_gov_ondemand;
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE)
 extern struct cpufreq_governor cpufreq_gov_conservative;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_conservative)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE)
+extern struct cpufreq_governor cpufreq_gov_interactive;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_interactive)
 #endif
 
 
@@ -402,6 +408,7 @@ extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
 
 void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 				      unsigned int cpu);
+void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy);
 
 void cpufreq_frequency_table_put_attr(unsigned int cpu);
 
diff --git a/include/linux/cpuidle.h b/include/linux/cpuidle.h
index 6c26a3da..5ab71833 100644
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@ -57,6 +57,7 @@ struct cpuidle_state {
 
 /* Idle State Flags */
 #define CPUIDLE_FLAG_TIME_VALID	(0x01) /* is residency time measurable? */
+#define CPUIDLE_FLAG_COUPLED	(0x02) /* state applies to multiple cpus */
 
 #define CPUIDLE_DRIVER_FLAGS_MASK (0xFFFF0000)
 
@@ -100,6 +101,12 @@ struct cpuidle_device {
 	struct list_head 	device_list;
 	struct kobject		kobj;
 	struct completion	kobj_unregister;
+
+#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED
+	int			safe_state_index;
+	cpumask_t		coupled_cpus;
+	struct cpuidle_coupled	*coupled;
+#endif
 };
 
 DECLARE_PER_CPU(struct cpuidle_device *, cpuidle_devices);
@@ -176,6 +183,10 @@ static inline int cpuidle_play_dead(void) {return -ENODEV; }
 
 #endif
 
+#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED
+void cpuidle_coupled_parallel_barrier(struct cpuidle_device *dev, atomic_t *a);
+#endif
+
 /******************************
  * CPUIDLE GOVERNOR INTERFACE *
  ******************************/
diff --git a/include/linux/devfreq.h b/include/linux/devfreq.h
index 281c72a3..e5036637 100644
--- a/include/linux/devfreq.h
+++ b/include/linux/devfreq.h
@@ -41,6 +41,7 @@ struct devfreq_dev_status {
 	unsigned long total_time;
 	unsigned long busy_time;
 	unsigned long current_frequency;
+	int throughput;
 	void *private_data;
 };
 
@@ -52,11 +53,40 @@ struct devfreq_dev_status {
  */
 #define DEVFREQ_FLAG_LEAST_UPPER_BOUND		0x1
 
+#define DEVFREQ_ENTRY_INVALID (~0)
+#define DEVFREQ_TABLE_END     (~1)
+
+struct devfreq_frequency_table {
+	unsigned int index;
+	unsigned long frequency;
+};
+
+/**
+ * struct devfreq_pm_qos_table - An PM QoS requiement entry for devfreq dev.
+ * @freq		Lowest frequency to meet the QoS requirement
+ *			represented by qos_value. If freq=0, it means that
+ *			this element is the last in the array.
+ * @qos_value		The qos value defined in pm_qos_params.h
+ *
+ * Note that the array of devfreq_pm_qos_table should be sorted by freq
+ * in the ascending order except for the last element, which should be 0.
+ */
+struct devfreq_pm_qos_table {
+	unsigned long freq; /* 0 if this is the last element */
+	s32 qos_value;
+};
+
+
 /**
  * struct devfreq_dev_profile - Devfreq's user device profile
  * @initial_freq	The operating frequency when devfreq_add_device() is
  *			called.
  * @polling_ms		The polling interval in ms. 0 disables polling.
+ * @qos_type		 QoS Type (defined in pm_qos_params.h)
+ *			 0 (PM_QOS_RESERVED) if not used.
+ * @qos_list		 Array of QoS requirements ending with .freq = 0
+ *			 NULL if not used. It should be either NULL or
+ *			 have a length > 1 with a first element effective.
  * @target		The device should set its operating frequency at
  *			freq or lowest-upper-than-freq value. If freq is
  *			higher than any operable frequency, set maximum.
@@ -71,11 +101,17 @@ struct devfreq_dev_status {
  *			from devfreq_remove_device() call. If the user
  *			has registered devfreq->nb at a notifier-head,
  *			this is the time to unregister it.
+ *
+ * Note that the array of qos_list should be sorted by freq
+ * in the ascending order.
  */
 struct devfreq_dev_profile {
 	unsigned long initial_freq;
 	unsigned int polling_ms;
 
+	int qos_type;
+	struct devfreq_pm_qos_table *qos_list;
+
 	int (*target)(struct device *dev, unsigned long *freq, u32 flags);
 	int (*get_dev_status)(struct device *dev,
 			      struct devfreq_dev_status *stat);
@@ -136,6 +172,10 @@ struct devfreq_governor {
  *			order to prevent trying to remove the object multiple times.
  * @min_freq	Limit minimum frequency requested by user (0: none)
  * @max_freq	Limit maximum frequency requested by user (0: none)
+ * @qos_nb	 notifier block used to notify pm qos requests
+ * @qos_min_freq	 Limit minimum frequency requested by QoS
+ * @qos_use_max		 true: throughput (larger is faster)
+ *			 false: latency (smaller is faster)
  *
  * This structure stores the devfreq information for a give device.
  *
@@ -157,6 +197,7 @@ struct devfreq {
 	unsigned long polling_jiffies;
 	unsigned long previous_freq;
 	unsigned int next_polling;
+	struct devfreq_frequency_table *freq_table;
 
 	void *data; /* private data for governors */
 
@@ -164,6 +205,11 @@ struct devfreq {
 
 	unsigned long min_freq;
 	unsigned long max_freq;
+	struct notifier_block qos_min_nb;
+	struct notifier_block qos_max_nb;
+	unsigned long qos_min_freq;
+	unsigned long qos_max_freq;
+	bool qos_use_max;
 };
 
 #if defined(CONFIG_PM_DEVFREQ)
@@ -180,6 +226,8 @@ extern int devfreq_register_opp_notifier(struct device *dev,
 					 struct devfreq *devfreq);
 extern int devfreq_unregister_opp_notifier(struct device *dev,
 					   struct devfreq *devfreq);
+extern void devfreq_set_freq_table(struct devfreq *devfreq,
+				   struct devfreq_frequency_table *table);
 
 #ifdef CONFIG_DEVFREQ_GOV_POWERSAVE
 extern const struct devfreq_governor devfreq_powersave;
@@ -211,6 +259,22 @@ struct devfreq_simple_ondemand_data {
 };
 #endif
 
+#ifdef CONFIG_DEVFREQ_GOV_THROUGHPUT
+extern const struct devfreq_governor devfreq_throughput;
+
+struct throughput_threshold {
+	unsigned int up;
+	unsigned int down;
+};
+struct devfreq_throughput_data {
+	unsigned int upthreshold;
+	unsigned int downdifferential;
+	u32 table_len;
+	u32 *freq_table;	/* unit Khz */
+	struct throughput_threshold *throughput_table;
+};
+#endif
+
 #else /* !CONFIG_PM_DEVFREQ */
 static struct devfreq *devfreq_add_device(struct device *dev,
 					  struct devfreq_dev_profile *profile,
@@ -243,6 +307,13 @@ static int devfreq_unregister_opp_notifier(struct device *dev,
 	return -EINVAL;
 }
 
+static void devfreq_set_freq_table(struct devfreq *devfreq,
+				   struct devfreq_frequency_table *table)
+{
+	return;
+}
+
+
 #define devfreq_powersave	NULL
 #define devfreq_performance	NULL
 #define devfreq_userspace	NULL
diff --git a/include/linux/device.h b/include/linux/device.h
index 5ad17ccc..e3399290 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -661,6 +661,10 @@ struct device {
 
 	struct dma_coherent_mem	*dma_mem; /* internal for coherent mem
 					     override */
+#ifdef CONFIG_CMA
+	struct cma *cma_area;		/* contiguous memory area for dma
+					   allocations */
+#endif
 	/* arch specific additions */
 	struct dev_archdata	archdata;
 
diff --git a/include/linux/dma-buf.h b/include/linux/dma-buf.h
index 3efbfc21..1f78d159 100644
--- a/include/linux/dma-buf.h
+++ b/include/linux/dma-buf.h
@@ -61,6 +61,10 @@ struct dma_buf_attachment;
  * 		   This Callback must not sleep.
  * @kmap: maps a page from the buffer into kernel address space.
  * @kunmap: [optional] unmaps a page from the buffer.
+ * @mmap: used to expose the backing storage to userspace. Note that the
+ * 	  mapping needs to be coherent - if the exporter doesn't directly
+ * 	  support this, it needs to fake coherency by shooting down any ptes
+ * 	  when transitioning away from the cpu domain.
  */
 struct dma_buf_ops {
 	int (*attach)(struct dma_buf *, struct device *,
@@ -92,6 +96,8 @@ struct dma_buf_ops {
 	void (*kunmap_atomic)(struct dma_buf *, unsigned long, void *);
 	void *(*kmap)(struct dma_buf *, unsigned long);
 	void (*kunmap)(struct dma_buf *, unsigned long, void *);
+
+	int (*mmap)(struct dma_buf *, struct vm_area_struct *vma);
 };
 
 /**
@@ -167,6 +173,9 @@ void *dma_buf_kmap_atomic(struct dma_buf *, unsigned long);
 void dma_buf_kunmap_atomic(struct dma_buf *, unsigned long, void *);
 void *dma_buf_kmap(struct dma_buf *, unsigned long);
 void dma_buf_kunmap(struct dma_buf *, unsigned long, void *);
+
+int dma_buf_mmap(struct dma_buf *, struct vm_area_struct *,
+		 unsigned long);
 #else
 
 static inline struct dma_buf_attachment *dma_buf_attach(struct dma_buf *dmabuf,
@@ -248,6 +257,13 @@ static inline void dma_buf_kunmap(struct dma_buf *dmabuf,
 				  unsigned long pnum, void *vaddr)
 {
 }
+
+static inline int dma_buf_mmap(struct dma_buf *dmabuf,
+			       struct vm_area_struct *vma,
+			       unsigned long pgoff)
+{
+	return -ENODEV;
+}
 #endif /* CONFIG_DMA_SHARED_BUFFER */
 
 #endif /* __DMA_BUF_H__ */
diff --git a/include/linux/dma-contiguous.h b/include/linux/dma-contiguous.h
new file mode 100644
index 00000000..70796ea2
--- /dev/null
+++ b/include/linux/dma-contiguous.h
@@ -0,0 +1,112 @@
+#ifndef __LINUX_CMA_H
+#define __LINUX_CMA_H
+
+/*
+ * Contiguous Memory Allocator for DMA mapping framework
+ * Copyright (c) 2010-2011 by Samsung Electronics.
+ * Written by:
+ *	Marek Szyprowski <m.szyprowski@samsung.com>
+ *	Michal Nazarewicz <mina86@mina86.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License or (at your optional) any later version of the license.
+ */
+
+/*
+ * Contiguous Memory Allocator
+ *
+ *   The Contiguous Memory Allocator (CMA) makes it possible to
+ *   allocate big contiguous chunks of memory after the system has
+ *   booted.
+ *
+ * Why is it needed?
+ *
+ *   Various devices on embedded systems have no scatter-getter and/or
+ *   IO map support and require contiguous blocks of memory to
+ *   operate.  They include devices such as cameras, hardware video
+ *   coders, etc.
+ *
+ *   Such devices often require big memory buffers (a full HD frame
+ *   is, for instance, more then 2 mega pixels large, i.e. more than 6
+ *   MB of memory), which makes mechanisms such as kmalloc() or
+ *   alloc_page() ineffective.
+ *
+ *   At the same time, a solution where a big memory region is
+ *   reserved for a device is suboptimal since often more memory is
+ *   reserved then strictly required and, moreover, the memory is
+ *   inaccessible to page system even if device drivers don't use it.
+ *
+ *   CMA tries to solve this issue by operating on memory regions
+ *   where only movable pages can be allocated from.  This way, kernel
+ *   can use the memory for pagecache and when device driver requests
+ *   it, allocated pages can be migrated.
+ *
+ * Driver usage
+ *
+ *   CMA should not be used by the device drivers directly. It is
+ *   only a helper framework for dma-mapping subsystem.
+ *
+ *   For more information, see kernel-docs in drivers/base/dma-contiguous.c
+ */
+
+#ifdef __KERNEL__
+
+struct cma;
+struct page;
+struct device;
+
+#ifdef CONFIG_CMA
+
+/*
+ * There is always at least global CMA area and a few optional device
+ * private areas configured in kernel .config.
+ */
+#define MAX_CMA_AREAS	(1 + CONFIG_CMA_AREAS)
+
+extern struct cma *dma_contiguous_default_area;
+extern int cma_available;
+
+void dma_contiguous_reserve(phys_addr_t addr_limit);
+int dma_declare_contiguous(struct device *dev, unsigned long size,
+			   phys_addr_t base, phys_addr_t limit);
+
+struct page *dma_alloc_from_contiguous(struct device *dev, int count,
+				       unsigned int order);
+bool dma_release_from_contiguous(struct device *dev, struct page *pages,
+				 int count);
+
+#else
+
+#define MAX_CMA_AREAS	(0)
+
+static inline void dma_contiguous_reserve(phys_addr_t limit) { }
+#define cma_available (0)
+
+static inline
+int dma_declare_contiguous(struct device *dev, unsigned long size,
+			   phys_addr_t base, phys_addr_t limit)
+{
+	return -ENOSYS;
+}
+
+static inline
+struct page *dma_alloc_from_contiguous(struct device *dev, int count,
+				       unsigned int order)
+{
+	return NULL;
+}
+
+static inline
+bool dma_release_from_contiguous(struct device *dev, struct page *pages,
+				 int count)
+{
+	return false;
+}
+
+#endif
+
+#endif
+
+#endif
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index f9a2e5e6..6bd06ff2 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -656,6 +656,12 @@ static inline int dmaengine_resume(struct dma_chan *chan)
 	return dmaengine_device_control(chan, DMA_RESUME, 0);
 }
 
+static inline enum dma_status dmaengine_tx_status(struct dma_chan *chan,
+	dma_cookie_t cookie, struct dma_tx_state *state)
+{
+	return chan->device->device_tx_status(chan, cookie, state);
+}
+
 static inline dma_cookie_t dmaengine_submit(struct dma_async_tx_descriptor *desc)
 {
 	return desc->tx_submit(desc);
diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
index 657ab55b..6f8be328 100644
--- a/include/linux/eventpoll.h
+++ b/include/linux/eventpoll.h
@@ -26,6 +26,18 @@
 #define EPOLL_CTL_DEL 2
 #define EPOLL_CTL_MOD 3
 
+/*
+ * Request the handling of system wakeup events so as to prevent system suspends
+ * from happening while those events are being processed.
+ *
+ * Assuming neither EPOLLET nor EPOLLONESHOT is set, system suspends will not be
+ * re-allowed until epoll_wait is called again after consuming the wakeup
+ * event(s).
+ *
+ * Requires CAP_EPOLLWAKEUP
+ */
+#define EPOLLWAKEUP (1 << 29)
+
 /* Set the One Shot behaviour for the target file descriptor */
 #define EPOLLONESHOT (1 << 30)
 
diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index d09af4b6..a628084e 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -41,6 +41,17 @@ extern int freeze_kernel_threads(void);
 extern void thaw_processes(void);
 extern void thaw_kernel_threads(void);
 
+/*
+ * HACK: prevent sleeping while atomic warnings due to ARM signal handling
+ * disabling irqs
+ */
+static inline bool try_to_freeze_nowarn(void)
+{
+	if (likely(!freezing(current)))
+		return false;
+	return __refrigerator(false);
+}
+
 static inline bool try_to_freeze(void)
 {
 	might_sleep();
diff --git a/include/linux/gfp.h b/include/linux/gfp.h
index 581e74b7..bd3b96ff 100644
--- a/include/linux/gfp.h
+++ b/include/linux/gfp.h
@@ -37,6 +37,7 @@ struct vm_area_struct;
 #define ___GFP_NO_KSWAPD	0x400000u
 #define ___GFP_OTHER_NODE	0x800000u
 #define ___GFP_WRITE		0x1000000u
+#define ___GFP_CMA		0x20000000u
 
 /*
  * GFP bitmasks..
@@ -87,6 +88,7 @@ struct vm_area_struct;
 #define __GFP_NO_KSWAPD	((__force gfp_t)___GFP_NO_KSWAPD)
 #define __GFP_OTHER_NODE ((__force gfp_t)___GFP_OTHER_NODE) /* On behalf of other node */
 #define __GFP_WRITE	((__force gfp_t)___GFP_WRITE)	/* Allocator intends to dirty page */
+#define __GFP_CMA	((__force gfp_t)___GFP_CMA)	/* Allocator intends to cma page */
 
 /*
  * This may seem redundant, but it's a way of annotating false positives vs.
@@ -391,4 +393,16 @@ static inline bool pm_suspended_storage(void)
 }
 #endif /* CONFIG_PM_SLEEP */
 
+#ifdef CONFIG_CMA
+
+/* The below functions must be run on a range from a single zone. */
+extern int alloc_contig_range(unsigned long start, unsigned long end,
+			      unsigned migratetype);
+extern void free_contig_range(unsigned long pfn, unsigned nr_pages);
+
+/* CMA stuff */
+extern void init_cma_reserved_pageblock(struct page *page);
+
+#endif
+
 #endif /* __LINUX_GFP_H */
diff --git a/include/linux/gpio-pxa.h b/include/linux/gpio-pxa.h
index d755b28b..4dee0038 100644
--- a/include/linux/gpio-pxa.h
+++ b/include/linux/gpio-pxa.h
@@ -11,6 +11,9 @@
  */
 extern int pxa_last_gpio;
 
+#ifdef CONFIG_SEC_GPIO_DVS
+extern int pxa_direction_get(unsigned int* gpdr);
+#endif
 extern int pxa_irq_to_gpio(int irq);
 
 struct pxa_gpio_platform_data {
diff --git a/include/linux/gpio_event.h b/include/linux/gpio_event.h
new file mode 100644
index 00000000..2613fc5e
--- /dev/null
+++ b/include/linux/gpio_event.h
@@ -0,0 +1,170 @@
+/* include/linux/gpio_event.h
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_GPIO_EVENT_H
+#define _LINUX_GPIO_EVENT_H
+
+#include <linux/input.h>
+
+struct gpio_event_input_devs {
+	int count;
+	struct input_dev *dev[];
+};
+enum {
+	GPIO_EVENT_FUNC_UNINIT  = 0x0,
+	GPIO_EVENT_FUNC_INIT    = 0x1,
+	GPIO_EVENT_FUNC_SUSPEND = 0x2,
+	GPIO_EVENT_FUNC_RESUME  = 0x3,
+};
+struct gpio_event_info {
+	int (*func)(struct gpio_event_input_devs *input_devs,
+		    struct gpio_event_info *info,
+		    void **data, int func);
+	int (*event)(struct gpio_event_input_devs *input_devs,
+		     struct gpio_event_info *info,
+		     void **data, unsigned int dev, unsigned int type,
+		     unsigned int code, int value); /* out events */
+	bool no_suspend;
+};
+
+struct gpio_event_platform_data {
+	const char *name;
+	struct gpio_event_info **info;
+	size_t info_count;
+	int (*power)(const struct gpio_event_platform_data *pdata, bool on);
+	const char *names[]; /* If name is NULL, names contain a NULL */
+			     /* terminated list of input devices to create */
+};
+
+#define GPIO_EVENT_DEV_NAME "gpio-event"
+
+/* Key matrix */
+
+enum gpio_event_matrix_flags {
+	/* unset: drive active output low, set: drive active output high */
+	GPIOKPF_ACTIVE_HIGH              = 1U << 0,
+	GPIOKPF_DEBOUNCE                 = 1U << 1,
+	GPIOKPF_REMOVE_SOME_PHANTOM_KEYS = 1U << 2,
+	GPIOKPF_REMOVE_PHANTOM_KEYS      = GPIOKPF_REMOVE_SOME_PHANTOM_KEYS |
+					   GPIOKPF_DEBOUNCE,
+	GPIOKPF_DRIVE_INACTIVE           = 1U << 3,
+	GPIOKPF_LEVEL_TRIGGERED_IRQ      = 1U << 4,
+	GPIOKPF_PRINT_UNMAPPED_KEYS      = 1U << 16,
+	GPIOKPF_PRINT_MAPPED_KEYS        = 1U << 17,
+	GPIOKPF_PRINT_PHANTOM_KEYS       = 1U << 18,
+};
+
+#define MATRIX_CODE_BITS (10)
+#define MATRIX_KEY_MASK ((1U << MATRIX_CODE_BITS) - 1)
+#define MATRIX_KEY(dev, code) \
+	(((dev) << MATRIX_CODE_BITS) | (code & MATRIX_KEY_MASK))
+
+extern int gpio_event_matrix_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+struct gpio_event_matrix_info {
+	/* initialize to gpio_event_matrix_func */
+	struct gpio_event_info info;
+	/* size must be ninputs * noutputs */
+	const unsigned short *keymap;
+	unsigned int *input_gpios;
+	unsigned int *output_gpios;
+	unsigned int ninputs;
+	unsigned int noutputs;
+	/* time to wait before reading inputs after driving each output */
+	ktime_t settle_time;
+	/* time to wait before scanning the keypad a second time */
+	ktime_t debounce_delay;
+	ktime_t poll_time;
+	unsigned flags;
+};
+
+/* Directly connected inputs and outputs */
+
+enum gpio_event_direct_flags {
+	GPIOEDF_ACTIVE_HIGH         = 1U << 0,
+/*	GPIOEDF_USE_DOWN_IRQ        = 1U << 1, */
+/*	GPIOEDF_USE_IRQ             = (1U << 2) | GPIOIDF_USE_DOWN_IRQ, */
+	GPIOEDF_PRINT_KEYS          = 1U << 8,
+	GPIOEDF_PRINT_KEY_DEBOUNCE  = 1U << 9,
+	GPIOEDF_PRINT_KEY_UNSTABLE  = 1U << 10,
+};
+
+struct gpio_event_direct_entry {
+	uint32_t gpio:16;
+	uint32_t code:10;
+	uint32_t dev:6;
+};
+
+/* inputs */
+extern int gpio_event_input_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+struct gpio_event_input_info {
+	/* initialize to gpio_event_input_func */
+	struct gpio_event_info info;
+	ktime_t debounce_time;
+	ktime_t poll_time;
+	uint16_t flags;
+	uint16_t type;
+	const struct gpio_event_direct_entry *keymap;
+	size_t keymap_size;
+};
+
+/* outputs */
+extern int gpio_event_output_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+extern int gpio_event_output_event(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data,
+			unsigned int dev, unsigned int type,
+			unsigned int code, int value);
+struct gpio_event_output_info {
+	/* initialize to gpio_event_output_func and gpio_event_output_event */
+	struct gpio_event_info info;
+	uint16_t flags;
+	uint16_t type;
+	const struct gpio_event_direct_entry *keymap;
+	size_t keymap_size;
+};
+
+
+/* axes */
+
+enum gpio_event_axis_flags {
+	GPIOEAF_PRINT_UNKNOWN_DIRECTION  = 1U << 16,
+	GPIOEAF_PRINT_RAW                = 1U << 17,
+	GPIOEAF_PRINT_EVENT              = 1U << 18,
+};
+
+extern int gpio_event_axis_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+struct gpio_event_axis_info {
+	/* initialize to gpio_event_axis_func */
+	struct gpio_event_info info;
+	uint8_t  count; /* number of gpios for this axis */
+	uint8_t  dev; /* device index when using multiple input devices */
+	uint8_t  type; /* EV_REL or EV_ABS */
+	uint16_t code;
+	uint16_t decoded_size;
+	uint16_t (*map)(struct gpio_event_axis_info *info, uint16_t in);
+	uint32_t *gpio;
+	uint32_t flags;
+};
+#define gpio_axis_2bit_gray_map gpio_axis_4bit_gray_map
+#define gpio_axis_3bit_gray_map gpio_axis_4bit_gray_map
+uint16_t gpio_axis_4bit_gray_map(
+			struct gpio_event_axis_info *info, uint16_t in);
+uint16_t gpio_axis_5bit_singletrack_map(
+			struct gpio_event_axis_info *info, uint16_t in);
+
+#endif
diff --git a/include/linux/huge_mm.h b/include/linux/huge_mm.h
index c8af7a2e..d811cb0d 100644
--- a/include/linux/huge_mm.h
+++ b/include/linux/huge_mm.h
@@ -100,8 +100,8 @@ extern void __split_huge_page_pmd(struct mm_struct *mm, pmd_t *pmd);
 #define wait_split_huge_page(__anon_vma, __pmd)				\
 	do {								\
 		pmd_t *____pmd = (__pmd);				\
-		anon_vma_lock(__anon_vma);				\
-		anon_vma_unlock(__anon_vma);				\
+		anon_vma_lock_write(__anon_vma);			\
+		anon_vma_unlock_write(__anon_vma);			\
 		BUG_ON(pmd_trans_splitting(*____pmd) ||			\
 		       pmd_trans_huge(*____pmd));			\
 	} while (0)
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 195d8b3d..cb09f10c 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -378,6 +378,9 @@ struct i2c_adapter {
 
 	/* data fields that are valid for all devices	*/
 	struct rt_mutex bus_lock;
+	void (*hardware_lock)(void);
+	void (*hardware_unlock)(void);
+	int (*hardware_trylock)(void);
 
 	int timeout;			/* in jiffies */
 	int retries;
diff --git a/include/linux/i2c/ft5306_touch.h b/include/linux/i2c/ft5306_touch.h
new file mode 100644
index 00000000..d598695e
--- /dev/null
+++ b/include/linux/i2c/ft5306_touch.h
@@ -0,0 +1,32 @@
+#ifndef __LINUX_I2C_FT5306_TOUCH_H
+#define __LINUX_I2C_FT5306_TOUCH_H
+
+#include <linux/input.h>
+
+/*
+ * power func:	power on / off touch
+ * reset func:	reset touch
+ * keypad_func: get virtual key code
+ * abs_x_max:	max value of abs_x
+ * abs_y_max:	max value of abs_y
+ * abs_flag:	convert the frame of axes
+ *		0: no change
+ *		1: convert the frame of axes 90 degree by clockwise
+ *		2: convert the frame of axes 180 degree by clockwise
+ *		3: convert the frame of axes 270 degree by clockwise
+ * virtual_key: enable/disable virtual key flag
+ *		0: disable virtual key
+ *		1: enable virtual key
+ */
+struct ft5306_touch_platform_data {
+	int (*power)(struct device *dev, int);
+	void (*reset)(void);
+	u32 (*keypad)(u16, u16, u16, u16);
+	int abs_x_max;
+	int abs_y_max;
+	int abs_flag;
+	int virtual_key;
+	int (*set_virtual_key)(struct input_dev *);
+};
+
+#endif
diff --git a/include/linux/i2c/pxa-i2c.h b/include/linux/i2c/pxa-i2c.h
index 1a9f65e6..cc13b713 100644
--- a/include/linux/i2c/pxa-i2c.h
+++ b/include/linux/i2c/pxa-i2c.h
@@ -67,6 +67,15 @@ struct i2c_pxa_platform_data {
 	unsigned int		class;
 	unsigned int		use_pio :1;
 	unsigned int		fast_mode :1;
+	unsigned int		high_mode:1;
+	unsigned int		fifo_mode:1;
+	unsigned char		master_code;
+	unsigned int		ilcr;
+	unsigned int		iwcr;
+	void			(*hardware_lock)(void);
+	void			(*hardware_unlock)(void);
+	int			(*hardware_trylock)(void);
+	void			(*i2c_bus_reset)(int i2c_bus_num);
 };
 
 extern void pxa_set_i2c_info(struct i2c_pxa_platform_data *info);
diff --git a/include/linux/input.h b/include/linux/input.h
index a8167145..86bef1c7 100644
--- a/include/linux/input.h
+++ b/include/linux/input.h
@@ -154,6 +154,9 @@ struct input_keymap_entry {
 
 #define EVIOCGRAB		_IOW('E', 0x90, int)			/* Grab/Release device */
 
+#define EVIOCGSUSPENDBLOCK	_IOR('E', 0x91, int)			/* get suspend block enable */
+#define EVIOCSSUSPENDBLOCK	_IOW('E', 0x91, int)			/* set suspend block enable */
+
 #define EVIOCSCLOCKID		_IOW('E', 0xa0, int)			/* Set clockid to be used for timestamps */
 
 /*
@@ -813,11 +816,15 @@ struct input_keymap_entry {
 #define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
 #define ABS_MT_PRESSURE		0x3a	/* Pressure on contact area */
 #define ABS_MT_DISTANCE		0x3b	/* Contact hover distance */
+#define ABS_MT_ANGLE		0x3c	/* touch angle */
+#define ABS_MT_PALM			0x3d	/* palm touch */
+#define ABS_MT_COMPONENT	0x3e	/* touch component */
+#define ABS_MT_SUMSIZE	0x3f	/* touch sumsize */
 
 #ifdef __KERNEL__
 /* Implementation details, userspace should not care about these */
 #define ABS_MT_FIRST		ABS_MT_TOUCH_MAJOR
-#define ABS_MT_LAST		ABS_MT_DISTANCE
+#define ABS_MT_LAST		ABS_MT_SUMSIZE //ABS_MT_DISTANCE : same as serrano 
 #endif
 
 #define ABS_MAX			0x3f
diff --git a/include/linux/input/bt532_ts.h b/include/linux/input/bt532_ts.h
new file mode 100755
index 00000000..7549a546
--- /dev/null
+++ b/include/linux/input/bt532_ts.h
@@ -0,0 +1,58 @@
+/*
+ *
+ * Zinitix bt532 touch driver
+ *
+ * Copyright (C) 2013 Samsung Electronics Co.Ltd
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+
+#ifndef _LINUX_BT532_TS_H
+#define _LINUX_BT532_TS_H
+
+#define TS_DRVIER_VERSION	"1.0.18_1"
+
+#define BT532_TS_DEVICE		"bt532_ts_device"
+
+#define zinitix_debug_msg(fmt, args...) \
+	do { \
+		if (m_ts_debug_mode) \
+			printk(KERN_INFO "bt532_ts[%-18s:%5d] " fmt, \
+					__func__, __LINE__, ## args); \
+	} while (0);
+
+#define zinitix_printk(fmt, args...) \
+	do { \
+		printk(KERN_INFO "bt532_ts[%-18s:%5d] " fmt, \
+				__func__, __LINE__, ## args); \
+	} while (0);
+
+#define bt532_err(fmt) \
+	do { \
+		pr_err("bt532_ts : %s " fmt, __func__); \
+	} while (0);
+
+struct bt532_ts_platform_data {
+	u32		gpio_int;
+	u32		gpio_scl;
+	u32		gpio_sda;
+	u32		gpio_ldo_en;
+	int (*tsp_power)(int on);
+	u16		x_resolution;
+	u16		y_resolution;
+	u16		page_size;
+	u8		orientation;
+};
+
+extern struct class *sec_class;
+
+#endif /* LINUX_BT532_TS_H */
diff --git a/include/linux/ion.h b/include/linux/ion.h
new file mode 100644
index 00000000..a0fd39b6
--- /dev/null
+++ b/include/linux/ion.h
@@ -0,0 +1,361 @@
+/*
+ * include/linux/ion.h
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_ION_H
+#define _LINUX_ION_H
+
+#include <linux/types.h>
+
+struct ion_handle;
+/**
+ * enum ion_heap_types - list of all possible types of heaps
+ * @ION_HEAP_TYPE_SYSTEM:	 memory allocated via vmalloc
+ * @ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kmalloc
+ * @ION_HEAP_TYPE_CARVEOUT:	 memory allocated from a prereserved
+ * 				 carveout heap, allocations are physically
+ * 				 contiguous
+ * @ION_NUM_HEAPS:		 helper for iterating over heaps, a bit mask
+ * 				 is used to identify the heaps, so only 32
+ * 				 total heap types are supported
+ */
+enum ion_heap_type {
+	ION_HEAP_TYPE_SYSTEM,
+	ION_HEAP_TYPE_SYSTEM_CONTIG,
+	ION_HEAP_TYPE_CARVEOUT,
+	ION_HEAP_TYPE_CUSTOM, /* must be last so device specific heaps always
+				 are at the end of this enum */
+	ION_NUM_HEAPS = 16,
+};
+
+#define ION_HEAP_SYSTEM_MASK		(1 << ION_HEAP_TYPE_SYSTEM)
+#define ION_HEAP_SYSTEM_CONTIG_MASK	(1 << ION_HEAP_TYPE_SYSTEM_CONTIG)
+#define ION_HEAP_CARVEOUT_MASK		(1 << ION_HEAP_TYPE_CARVEOUT)
+
+/**
+ * heap flags - the lower 16 bits are used by core ion, the upper 16
+ * bits are reserved for use by the heaps themselves.
+ */
+#define ION_FLAG_CACHED 1		/* mappings of this buffer should be
+					   cached, ion will do cache
+					   maintenance when the buffer is
+					   mapped for dma */
+#define ION_FLAG_CACHED_NEEDS_SYNC 2	/* mappings of this buffer will created
+					   at mmap time, if this is set
+					   caches must be managed manually */
+
+#ifdef __KERNEL__
+struct ion_device;
+struct ion_heap;
+struct ion_mapper;
+struct ion_client;
+struct ion_buffer;
+
+/* This should be removed some day when phys_addr_t's are fully
+   plumbed in the kernel, and all instances of ion_phys_addr_t should
+   be converted to phys_addr_t.  For the time being many kernel interfaces
+   do not accept phys_addr_t's that would have to */
+#define ion_phys_addr_t unsigned long
+
+/**
+ * struct ion_platform_heap - defines a heap in the given platform
+ * @type:	type of the heap from ion_heap_type enum
+ * @id:		unique identifier for heap.  When allocating (lower numbers 
+ * 		will be allocated from first)
+ * @name:	used for debug purposes
+ * @base:	base address of heap in physical memory if applicable
+ * @size:	size of the heap in bytes if applicable
+ *
+ * Provided by the board file.
+ */
+struct ion_platform_heap {
+	enum ion_heap_type type;
+	unsigned int id;
+	const char *name;
+	ion_phys_addr_t base;
+	size_t size;
+};
+
+/**
+ * struct ion_platform_data - array of platform heaps passed from board file
+ * @nr:		number of structures in the array
+ * @heaps:	array of platform_heap structions
+ *
+ * Provided by the board file in the form of platform data to a platform device.
+ */
+struct ion_platform_data {
+	int nr;
+	struct ion_platform_heap heaps[];
+};
+
+/**
+ * ion_reserve() - reserve memory for ion heaps if applicable
+ * @data:	platform data specifying starting physical address and
+ *		size
+ *
+ * Calls memblock reserve to set aside memory for heaps that are
+ * located at specific memory addresses or of specfic sizes not
+ * managed by the kernel
+ */
+void ion_reserve(struct ion_platform_data *data);
+
+/**
+ * ion_client_create() -  allocate a client and returns it
+ * @dev:	the global ion device
+ * @heap_mask:	mask of heaps this client can allocate from
+ * @name:	used for debugging
+ */
+struct ion_client *ion_client_create(struct ion_device *dev,
+				     unsigned int heap_mask, const char *name);
+
+/**
+ * ion_client_destroy() -  free's a client and all it's handles
+ * @client:	the client
+ *
+ * Free the provided client and all it's resources including
+ * any handles it is holding.
+ */
+void ion_client_destroy(struct ion_client *client);
+
+/**
+ * ion_alloc - allocate ion memory
+ * @client:	the client
+ * @len:	size of the allocation
+ * @align:	requested allocation alignment, lots of hardware blocks have
+ *		alignment requirements of some kind
+ * @heap_mask:	mask of heaps to allocate from, if multiple bits are set
+ *		heaps will be tried in order from lowest to highest order bit
+ * @flags:	heap flags, the low 16 bits are consumed by ion, the high 16
+ *		bits are passed on to the respective heap and can be heap
+ * 		custom
+ *
+ * Allocate memory in one of the heaps provided in heap mask and return
+ * an opaque handle to it.
+ */
+struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
+			     size_t align, unsigned int heap_mask,
+			     unsigned int flags);
+
+/**
+ * ion_free - free a handle
+ * @client:	the client
+ * @handle:	the handle to free
+ *
+ * Free the provided handle.
+ */
+void ion_free(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_phys - returns the physical address and len of a handle
+ * @client:	the client
+ * @handle:	the handle
+ * @addr:	a pointer to put the address in
+ * @len:	a pointer to put the length in
+ *
+ * This function queries the heap for a particular handle to get the
+ * handle's physical address.  It't output is only correct if
+ * a heap returns physically contiguous memory -- in other cases
+ * this api should not be implemented -- ion_sg_table should be used
+ * instead.  Returns -EINVAL if the handle is invalid.  This has
+ * no implications on the reference counting of the handle --
+ * the returned value may not be valid if the caller is not
+ * holding a reference.
+ */
+int ion_phys(struct ion_client *client, struct ion_handle *handle,
+	     ion_phys_addr_t *addr, size_t *len);
+
+/**
+ * ion_map_dma - return an sg_table describing a handle
+ * @client:	the client
+ * @handle:	the handle
+ *
+ * This function returns the sg_table describing
+ * a particular ion handle.
+ */
+struct sg_table *ion_sg_table(struct ion_client *client,
+			      struct ion_handle *handle);
+
+/**
+ * ion_map_kernel - create mapping for the given handle
+ * @client:	the client
+ * @handle:	handle to map
+ *
+ * Map the given handle into the kernel and return a kernel address that
+ * can be used to access this address.
+ */
+void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_unmap_kernel() - destroy a kernel mapping for a handle
+ * @client:	the client
+ * @handle:	handle to unmap
+ */
+void ion_unmap_kernel(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_share_dma_buf() - given an ion client, create a dma-buf fd
+ * @client:	the client
+ * @handle:	the handle
+ */
+int ion_share_dma_buf(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_import_dma_buf() - given an dma-buf fd from the ion exporter get handle
+ * @client:	the client
+ * @fd:		the dma-buf fd
+ *
+ * Given an dma-buf fd that was allocated through ion via ion_share_dma_buf,
+ * import that fd and return a handle representing it.  If a dma-buf from
+ * another exporter is passed in this function will return ERR_PTR(-EINVAL)
+ */
+struct ion_handle *ion_import_dma_buf(struct ion_client *client, int fd);
+
+bool ion_handle_validate(struct ion_client *client, struct ion_handle *handle);
+
+struct vm_area_struct *pxa_ion_find_vma(struct ion_buffer *buffer);
+
+#endif /* __KERNEL__ */
+
+/**
+ * DOC: Ion Userspace API
+ *
+ * create a client by opening /dev/ion
+ * most operations handled via following ioctls
+ *
+ */
+
+/**
+ * struct ion_allocation_data - metadata passed from userspace for allocations
+ * @len:	size of the allocation
+ * @align:	required alignment of the allocation
+ * @heap_mask:	mask of heaps to allocate from
+ * @flags:	flags passed to heap
+ * @handle:	pointer that will be populated with a cookie to use to refer
+ *		to this allocation
+ *
+ * Provided by userspace as an argument to the ioctl
+ */
+struct ion_allocation_data {
+	size_t len;
+	size_t align;
+	unsigned int heap_mask;
+	unsigned int flags;
+	struct ion_handle *handle;
+};
+
+/**
+ * struct ion_fd_data - metadata passed to/from userspace for a handle/fd pair
+ * @handle:	a handle
+ * @fd:		a file descriptor representing that handle
+ *
+ * For ION_IOC_SHARE or ION_IOC_MAP userspace populates the handle field with
+ * the handle returned from ion alloc, and the kernel returns the file
+ * descriptor to share or map in the fd field.  For ION_IOC_IMPORT, userspace
+ * provides the file descriptor and the kernel returns the handle.
+ */
+struct ion_fd_data {
+	struct ion_handle *handle;
+	int fd;
+};
+
+/**
+ * struct ion_handle_data - a handle passed to/from the kernel
+ * @handle:	a handle
+ */
+struct ion_handle_data {
+	struct ion_handle *handle;
+};
+
+/**
+ * struct ion_custom_data - metadata passed to/from userspace for a custom ioctl
+ * @cmd:	the custom ioctl function to call
+ * @arg:	additional data to pass to the custom ioctl, typically a user
+ *		pointer to a predefined structure
+ *
+ * This works just like the regular cmd and arg fields of an ioctl.
+ */
+struct ion_custom_data {
+	unsigned int cmd;
+	unsigned long arg;
+};
+
+#define ION_IOC_MAGIC		'I'
+
+/**
+ * DOC: ION_IOC_ALLOC - allocate memory
+ *
+ * Takes an ion_allocation_data struct and returns it with the handle field
+ * populated with the opaque handle for the allocation.
+ */
+#define ION_IOC_ALLOC		_IOWR(ION_IOC_MAGIC, 0, \
+				      struct ion_allocation_data)
+
+/**
+ * DOC: ION_IOC_FREE - free memory
+ *
+ * Takes an ion_handle_data struct and frees the handle.
+ */
+#define ION_IOC_FREE		_IOWR(ION_IOC_MAGIC, 1, struct ion_handle_data)
+
+/**
+ * DOC: ION_IOC_MAP - get a file descriptor to mmap
+ *
+ * Takes an ion_fd_data struct with the handle field populated with a valid
+ * opaque handle.  Returns the struct with the fd field set to a file
+ * descriptor open in the current address space.  This file descriptor
+ * can then be used as an argument to mmap.
+ */
+#define ION_IOC_MAP		_IOWR(ION_IOC_MAGIC, 2, struct ion_fd_data)
+
+/**
+ * DOC: ION_IOC_SHARE - creates a file descriptor to use to share an allocation
+ *
+ * Takes an ion_fd_data struct with the handle field populated with a valid
+ * opaque handle.  Returns the struct with the fd field set to a file
+ * descriptor open in the current address space.  This file descriptor
+ * can then be passed to another process.  The corresponding opaque handle can
+ * be retrieved via ION_IOC_IMPORT.
+ */
+#define ION_IOC_SHARE		_IOWR(ION_IOC_MAGIC, 4, struct ion_fd_data)
+
+/**
+ * DOC: ION_IOC_IMPORT - imports a shared file descriptor
+ *
+ * Takes an ion_fd_data struct with the fd field populated with a valid file
+ * descriptor obtained from ION_IOC_SHARE and returns the struct with the handle
+ * filed set to the corresponding opaque handle.
+ */
+#define ION_IOC_IMPORT		_IOWR(ION_IOC_MAGIC, 5, struct ion_fd_data)
+
+/**
+ * DOC: ION_IOC_SYNC - syncs a shared file descriptors to memory
+ *
+ * Deprecated in favor of using the dma_buf api's correctly (syncing
+ * will happend automatically when the buffer is mapped to a device).
+ * If necessary should be used after touching a cached buffer from the cpu,
+ * this will make the buffer in memory coherent.
+ */
+struct ion_pxa_cache_region;
+#define ION_IOC_SYNC		_IOWR(ION_IOC_MAGIC, 7, struct ion_pxa_cache_region)
+
+/**
+ * DOC: ION_IOC_CUSTOM - call architecture specific ion ioctl
+ *
+ * Takes the argument of the architecture specific ioctl to call and
+ * passes appropriate userdata for that ioctl
+ */
+#define ION_IOC_CUSTOM		_IOWR(ION_IOC_MAGIC, 6, struct ion_custom_data)
+
+#endif /* _LINUX_ION_H */
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 645231c3..747404ab 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -705,6 +705,9 @@ static inline void ftrace_dump(enum ftrace_dump_mode oops_dump_mode) { }
 
 extern int do_sysinfo(struct sysinfo *info);
 
+/* To identify board information in panic logs, set this */
+extern char *mach_panic_string;
+
 #endif /* __KERNEL__ */
 
 #endif
diff --git a/include/linux/kexec.h b/include/linux/kexec.h
index 0d7d6a1b..4324015c 100644
--- a/include/linux/kexec.h
+++ b/include/linux/kexec.h
@@ -119,6 +119,7 @@ struct kimage {
 
 
 /* kexec interface functions */
+extern void machine_crash_update(struct pt_regs *regs);
 extern void machine_kexec(struct kimage *image);
 extern int machine_kexec_prepare(struct kimage *image);
 extern void machine_kexec_cleanup(struct kimage *image);
@@ -136,6 +137,7 @@ extern asmlinkage long compat_sys_kexec_load(unsigned long entry,
 extern struct page *kimage_alloc_control_pages(struct kimage *image,
 						unsigned int order);
 extern void crash_kexec(struct pt_regs *);
+extern void crash_update(struct pt_regs *);
 int kexec_should_crash(struct task_struct *);
 void crash_save_cpu(struct pt_regs *regs, int cpu);
 void crash_save_vmcoreinfo(void);
@@ -225,6 +227,7 @@ void crash_free_reserved_phys_range(unsigned long begin, unsigned long end);
 #else /* !CONFIG_KEXEC */
 struct pt_regs;
 struct task_struct;
+static inline void crash_update(struct pt_regs *regs) { }
 static inline void crash_kexec(struct pt_regs *regs) { }
 static inline int kexec_should_crash(struct task_struct *p) { return 0; }
 #endif /* CONFIG_KEXEC */
diff --git a/include/linux/keyreset.h b/include/linux/keyreset.h
new file mode 100644
index 00000000..3ed854bc
--- /dev/null
+++ b/include/linux/keyreset.h
@@ -0,0 +1,30 @@
+/*
+ * include/linux/keyreset.h - platform data structure for resetkeys driver
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_KEYRESET_H
+#define _LINUX_KEYRESET_H
+
+#define KEYRESET_NAME "keyreset"
+
+struct keyreset_platform_data {
+	int (*reset_fn)(void);
+	int (*dump_fn)(int pressed);
+	int panic_before_reset;
+	int *keys_up;
+	int keys_down[]; /* 0 terminated */
+};
+
+#endif /* _LINUX_KEYRESET_H */
diff --git a/include/linux/kthread.h b/include/linux/kthread.h
index 0714b24c..22ccf9de 100644
--- a/include/linux/kthread.h
+++ b/include/linux/kthread.h
@@ -49,8 +49,6 @@ extern int tsk_fork_get_node(struct task_struct *tsk);
  * can be queued and flushed using queue/flush_kthread_work()
  * respectively.  Queued kthread_works are processed by a kthread
  * running kthread_worker_fn().
- *
- * A kthread_work can't be freed while it is executing.
  */
 struct kthread_work;
 typedef void (*kthread_work_func_t)(struct kthread_work *work);
@@ -59,15 +57,14 @@ struct kthread_worker {
 	spinlock_t		lock;
 	struct list_head	work_list;
 	struct task_struct	*task;
+	struct kthread_work	*current_work;
 };
 
 struct kthread_work {
 	struct list_head	node;
 	kthread_work_func_t	func;
 	wait_queue_head_t	done;
-	atomic_t		flushing;
-	int			queue_seq;
-	int			done_seq;
+	struct kthread_worker	*worker;
 };
 
 #define KTHREAD_WORKER_INIT(worker)	{				\
@@ -79,7 +76,6 @@ struct kthread_work {
 	.node = LIST_HEAD_INIT((work).node),				\
 	.func = (fn),							\
 	.done = __WAIT_QUEUE_HEAD_INITIALIZER((work).done),		\
-	.flushing = ATOMIC_INIT(0),					\
 	}
 
 #define DEFINE_KTHREAD_WORKER(worker)					\
diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index 8877123f..d45435e7 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -92,6 +92,8 @@ struct lcd_platform_data {
 	void *pdata;
 };
 
+extern struct class *lcd_class;
+
 static inline void lcd_set_power(struct lcd_device *ld, int power)
 {
 	mutex_lock(&ld->update_lock);
diff --git a/include/linux/linux_logo.h b/include/linux/linux_logo.h
index ca5bd91d..b2fff217 100644
--- a/include/linux/linux_logo.h
+++ b/include/linux/linux_logo.h
@@ -47,6 +47,7 @@ extern const struct linux_logo logo_superh_vga16;
 extern const struct linux_logo logo_superh_clut224;
 extern const struct linux_logo logo_m32r_clut224;
 extern const struct linux_logo logo_spe_clut224;
+extern const struct linux_logo logo_android_clut224;
 
 extern const struct linux_logo *fb_find_logo(int depth);
 #ifdef CONFIG_FB_LOGO_EXTRA
diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h
index d36619ea..17d38043 100644
--- a/include/linux/lockdep.h
+++ b/include/linux/lockdep.h
@@ -506,14 +506,17 @@ static inline void print_irqtrace_events(struct task_struct *curr)
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 # ifdef CONFIG_PROVE_LOCKING
 #  define rwsem_acquire(l, s, t, i)		lock_acquire(l, s, t, 0, 2, NULL, i)
+#  define rwsem_acquire_nest(l, s, t, n, i)	lock_acquire(l, s, t, 0, 2, n, i)
 #  define rwsem_acquire_read(l, s, t, i)	lock_acquire(l, s, t, 1, 2, NULL, i)
 # else
 #  define rwsem_acquire(l, s, t, i)		lock_acquire(l, s, t, 0, 1, NULL, i)
+#  define rwsem_acquire_nest(l, s, t, n, i)	lock_acquire(l, s, t, 0, 1, n, i)
 #  define rwsem_acquire_read(l, s, t, i)	lock_acquire(l, s, t, 1, 1, NULL, i)
 # endif
 # define rwsem_release(l, n, i)			lock_release(l, n, i)
 #else
 # define rwsem_acquire(l, s, t, i)		do { } while (0)
+# define rwsem_acquire_nest(l, s, t, n, i)	do { } while (0)
 # define rwsem_acquire_read(l, s, t, i)		do { } while (0)
 # define rwsem_release(l, n, i)			do { } while (0)
 #endif
diff --git a/include/linux/lps331ap.h b/include/linux/lps331ap.h
new file mode 100644
index 00000000..d996f0dc
--- /dev/null
+++ b/include/linux/lps331ap.h
@@ -0,0 +1,57 @@
+/*
+* lps331wp.h
+*
+* STMicroelectronics LPS331AP Pressure / Temperature Sensor module driver
+*
+* Copyright (C) 2010 STMicroelectronics- MSH - Motion Mems BU - Application Team
+* Matteo Dameno (matteo.dameno@st.com)
+* Carmine Iascone (carmine.iascone@st.com)
+*
+* Both authors are willing to be considered the contact and update points for
+* the driver.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License
+* version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301 USA
+*
+*/
+/******************************************************************************
+ Revision 1.0.0 2011/Feb/14:
+	first release
+	moved to input/misc
+ Revision 1.0.1 2011/Apr/04:
+	xxx
+ Revision 1.0.2 2011/Sep/15:
+	corrects ord bug, forces BDU enable
+ Revision 1.0.3 2011/Sep/15:
+	introduces compansation params reading and sysfs file to get them
+ Revision 1.0.4 2011/Dec/12:
+	sets maximum allowable resolution modes dynamically with ODR;
+ Revision 1.0.5 2012/Feb/29:
+	introduces more compansation params and extends sysfs file content
+	format to get them; reduces minimum polling period define;
+ Revision 1.0.6 2012/Mar/30:
+	introduces one more compansation param and extends sysfs file content
+	format to get it.
+******************************************************************************/
+
+#ifndef	__LPS331AP_H__
+#define	__LPS331AP_H__
+
+struct lps331ap_prs_platform_data {
+	int (*power_on)(int);
+	unsigned int poll_interval;
+	unsigned int min_interval;
+};
+
+#endif  /* __LPS331AP_H__ */
diff --git a/include/linux/mfd/88pm80x.h b/include/linux/mfd/88pm80x.h
new file mode 100644
index 00000000..36a75071
--- /dev/null
+++ b/include/linux/mfd/88pm80x.h
@@ -0,0 +1,645 @@
+/*
+ * Marvell 88PM80x Interface
+ *
+ * Copyright (C) 2012 Marvell International Ltd.
+ * Qiao Zhou <zhouqiao@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_MFD_88PM80X_H
+#define __LINUX_MFD_88PM80X_H
+
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/regmap.h>
+#include <linux/atomic.h>
+#include <linux/regulator/machine.h>
+#include <linux/proc_fs.h>
+
+#define PM80X_VERSION_MASK		(0xFF)	/* 80X chip ID mask */
+
+/*88PM800 registers*/
+enum {
+	PM80X_INVALID_PAGE = 0,
+	PM80X_BASE_PAGE,
+	PM80X_POWER_PAGE,
+	PM80X_GPADC_PAGE,
+};
+
+enum {
+	CHIP_INVALID = 0,
+	CHIP_PM800,
+	CHIP_PM805,
+	CHIP_MAX,
+};
+
+enum {
+	PM800_ID_BUCK1 = 0,
+	PM800_ID_BUCK2,
+	PM800_ID_BUCK3,
+	PM800_ID_BUCK4,
+	PM800_ID_BUCK5,
+
+	PM800_ID_LDO1,
+	PM800_ID_LDO2,
+	PM800_ID_LDO3,
+	PM800_ID_LDO4,
+	PM800_ID_LDO5,
+	PM800_ID_LDO6,
+	PM800_ID_LDO7,
+	PM800_ID_LDO8,
+	PM800_ID_LDO9,
+	PM800_ID_LDO10,
+	PM800_ID_LDO11,
+	PM800_ID_LDO12,
+	PM800_ID_LDO13,
+	PM800_ID_LDO14,
+	PM800_ID_LDO15,
+	PM800_ID_LDO16,
+	PM800_ID_LDO17,
+	PM800_ID_LDO18,
+	PM800_ID_LDO19,
+
+	/* below 4 ids are fake id, they are only used in new dvc */
+	PM800_ID_BUCK1_AP_ACTIVE,
+	PM800_ID_BUCK1_AP_LPM,
+	PM800_ID_BUCK1_APSUB_IDLE,
+	PM800_ID_BUCK1_APSUB_SLEEP,
+
+	PM800_ID_RG_MAX,
+};
+
+enum {
+	PM800_NO_GPIO = -1,
+	PM800_GPIO0 = 0,
+	PM800_GPIO1,
+	PM800_GPIO2,
+	PM800_GPIO3,
+	PM800_GPIO4,
+};
+
+enum {
+	PM800_NO_GPADC = -1,
+	PM800_GPADC0 = 0,
+	PM800_GPADC1,
+	PM800_GPADC2,
+	PM800_GPADC3,
+	PM800_GPADC4,
+};
+
+#define PM800_MAX_REGULATOR	PM800_ID_RG_MAX	/* 5 Bucks, 19 LDOs */
+#define PM800_NUM_BUCK (5)	/*5 Bucks */
+#define PM800_NUM_LDO (19)	/*19 Bucks */
+
+/* page 0 basic: slave adder 0x60 */
+
+#define PM800_STATUS_1			(0x01)
+#define PM800_ONKEY_STS1		(1 << 0)
+#define PM800_EXTON_STS1		(1 << 1)
+#define PM800_CHG_STS1			(1 << 2)
+#define PM800_BAT_STS1			(1 << 3)
+#define PM800_VBUS_STS1			(1 << 4)
+#define PM800_LDO_PGOOD_STS1	(1 << 5)
+#define PM800_BUCK_PGOOD_STS1	(1 << 6)
+
+#define PM800_STATUS_2			(0x02)
+#define PM800_RTC_ALARM_STS2	(1 << 0)
+
+/* Wakeup Registers */
+#define PM800_WAKEUP1		(0x0D)
+
+#define PM800_WAKEUP2		(0x0E)
+#define PM800_WAKEUP2_INV_INT		(1 << 0)
+#define PM800_WAKEUP2_INT_CLEAR		(1 << 1)
+#define PM800_WAKEUP2_INT_MASK		(1 << 2)
+
+#define PM800_POWER_UP_LOG	(0x10)
+
+/* Referance and low power registers */
+#define PM800_LOW_POWER1		(0x20)
+#define PM800_LOW_POWER2		(0x21)
+#define PM800_LOW_POWER_CONFIG3	(0x22)
+#define PM800_LOW_POWER_CONFIG4	(0x23)
+
+/* GPIO register */
+#define PM800_GPIO_0_1_CNTRL		(0x30)
+#define PM800_GPIO0_VAL				(1 << 0)
+#define PM800_GPIO0_GPIO_MODE(x)	(x << 1)
+#define PM800_GPIO1_VAL				(1 << 4)
+#define PM800_GPIO1_GPIO_MODE(x)	(x << 5)
+
+#define PM800_GPIO_2_3_CNTRL		(0x31)
+#define PM800_GPIO2_VAL				(1 << 0)
+#define PM800_GPIO2_GPIO_MODE(x)	(x << 1)
+#define PM800_GPIO3_VAL				(1 << 4)
+#define PM800_GPIO3_GPIO_MODE(x)	(x << 5)
+#define PM800_GPIO3_MODE_MASK		0x1F
+#define PM800_GPIO3_HEADSET_MODE	PM800_GPIO3_GPIO_MODE(6)
+
+#define PM800_GPIO_4_CNTRL			(0x32)
+#define PM800_GPIO4_VAL				(1 << 0)
+#define PM800_GPIO4_GPIO_MODE(x)	(x << 1)
+
+#define PM800_HEADSET_CNTRL		(0x38)
+#define PM800_HEADSET_DET_EN		(1 << 7)
+#define PM800_HSDET_SLP			(1 << 1)
+/* PWM register */
+#define PM800_PWM1		(0x40)
+#define PM800_PWM2		(0x41)
+#define PM800_PWM3		(0x42)
+#define PM800_PWM4		(0x43)
+/* Oscillator control */
+#define OSC_CNTRL1		(0x50)
+#define OSC_CNTRL2		(0x51)
+#define OSC_CNTRL3		(0x52)
+#define OSC_CNTRL4		(0x53)
+#define OSC_CNTRL5		(0x54)
+#define OSC_CNTRL6		(0x55)
+#define OSC_CNTRL7		(0x56)
+#define OSC_CNTRL8		(0x57)
+#define OSC_CNTRL9		(0x58)
+#define OSC_CNTRL11		(0x5a)
+#define OSC_CNTRL12		(0x5b)
+#define OSC_CNTRL13		(0x5c)
+
+/* RTC Registers */
+#define PM800_RTC_CONTROL		(0xD0)
+#define PM800_RTC_COUNTER1		(0xD1)
+#define PM800_RTC_COUNTER2		(0xD2)
+#define PM800_RTC_COUNTER3		(0xD3)
+#define PM800_RTC_COUNTER4		(0xD4)
+#define PM800_RTC_EXPIRE1_1		(0xD5)
+#define PM800_RTC_EXPIRE1_2		(0xD6)
+#define PM800_RTC_EXPIRE1_3		(0xD7)
+#define PM800_RTC_EXPIRE1_4		(0xD8)
+#define PM800_RTC_TRIM1			(0xD9)
+#define PM800_RTC_TRIM2			(0xDA)
+#define PM800_RTC_TRIM3			(0xDB)
+#define PM800_RTC_TRIM4			(0xDC)
+#define PM800_RTC_EXPIRE2_1		(0xDD)
+#define PM800_RTC_EXPIRE2_2		(0xDE)
+#define PM800_RTC_EXPIRE2_3		(0xDF)
+#define PM800_RTC_EXPIRE2_4		(0xE0)
+#define PM800_RTC_MISC1			(0xE1)
+#define PM800_RTC_MISC2			(0xE2)
+#define PM800_RTC_MISC3			(0xE3)
+#define PM800_RTC_MISC4			(0xE4)
+#define PM800_RTC_MISC5			(0xE7)
+/* bit definitions of RTC Register 1 (0xD0) */
+#define PM800_ALARM1_EN			(1 << 0)
+#define PM800_ALARM_WAKEUP		(1 << 4)
+#define PM800_ALARM			(1 << 5)
+#define PM800_RTC1_USE_XO		(1 << 7)
+
+#define PM800_RTC_MISC6			(0xE8)
+#define PM800_RTC_MISC7			(0xE9)
+/*for save RTC offset*/
+#define PM800_USER_DATA1		(0xEA)
+#define PM800_USER_DATA2		(0xEB)
+#define PM800_USER_DATA3		(0xEC)
+#define PM800_USER_DATA4		(0xED)
+#define PM800_USER_DATA5		(0xEE)
+#define PM800_USER_DATA6		(0xEF)
+
+#define PM800_POWER_DOWN_LOG1	(0xE5)
+#define PM800_POWER_DOWN_LOG2	(0xE6)
+
+/* Regulator Control Registers: BUCK1,BUCK5,LDO1 have DVC */
+
+/* buck registers */
+#define PM800_SLEEP_BUCK1	(0x30)
+
+/* BUCK Sleep Mode Register 1: BUCK[1..4] */
+#define PM800_BUCK_SLP_PWR_OFF	0x0	/* power off */
+#define PM800_BUCK_SLP_PWR_ACT1	0x1	/* auto & VBUCK_SET_SLP */
+#define PM800_BUCK_SLP_PWR_LOW	0x2	/* VBUCK_SET_SLP */
+#define PM800_BUCK_SLP_PWR_ACT2	0x3	/* auto & VBUCK_SET */
+
+#define PM800_BUCK_SLP1		(0x5A)
+#define PM800_BUCK1_SLP1_SHIFT	0
+#define PM800_BUCK1_SLP1_MASK	(0x3 << PM800_BUCK1_SLP1_SHIFT)
+#define PM800_BUCK2_SLP1_SHIFT	2
+#define PM800_BUCK2_SLP1_MASK	(0x3 << PM800_BUCK2_SLP1_SHIFT)
+#define PM800_BUCK2_SLP1_UNMASK (0x2 << PM800_BUCK2_SLP1_SHIFT)
+
+/* page 1 POWER */
+
+/* BUCK4 with DVC[0..3] */
+#define PM800_AUDIO_MODE_CONFIG1	(0x38)
+#define PM800_BUCK3		(0x41)
+#define PM800_BUCK4		(0x42)
+#define PM800_BUCK4_1		(0x43)
+#define PM800_BUCK4_2		(0x44)
+#define PM800_BUCK4_3		(0x45)
+#define PM800_BUCK5		(0x46)
+/* BUCK Sleep Mode Register 2: BUCK5 */
+#define PM800_BUCK_SLP2		(0x5B)
+#define PM800_BUCK5_SLP2_SHIFT	0
+#define PM800_BUCK5_SLP2_MASK	(0x3 << PM800_BUCK5_SLP2_SHIFT)
+
+#define PM800_LDO1_1		(0x08)
+#define PM800_LDO1_2		(0x09)
+#define PM800_LDO1_3		(0x0a)
+#define PM800_LDO2		(0x0b)
+#define PM800_LDO3		(0x0c)
+#define PM800_LDO4		(0x0d)
+#define PM800_LDO5		(0x0e)
+#define PM800_LDO6		(0x0f)
+#define PM800_LDO7		(0x10)
+#define PM800_LDO8		(0x11)
+#define PM800_LDO9		(0x12)
+#define PM800_LDO10		(0x13)
+#define PM800_LDO11		(0x14)
+#define PM800_LDO12		(0x15)
+#define PM800_LDO13		(0x16)
+#define PM800_LDO14		(0x17)
+#define PM800_LDO15		(0x18)
+#define PM800_LDO16		(0x19)
+#define PM800_LDO17		(0x1a)
+#define PM800_LDO18		(0x1b)
+#define PM800_LDO19		(0x1c)
+
+#define PM800_LDO_SLP1		(0x5c)
+#define PM800_LDO_SLP2		(0x5d)
+#define PM800_LDO_SLP3		(0x5e)
+#define PM800_LDO_SLP4		(0x5f)
+
+/* LDO Sleep Mode Register 5: LDO[17..19] */
+#define PM800_LDO_SLP5		(0x60)
+#define PM800_LDO17_SLP5_SHIFT	0
+#define PM800_LDO17_SLP5_MASK	(0x3 << PM800_LDO17_SLP5_SHIFT)
+#define PM800_LDO18_SLP5_SHIFT	2
+#define PM800_LDO18_SLP5_MASK	(0x3 << PM800_LDO18_SLP5_SHIFT)
+#define PM800_LDO19_SLP5_SHIFT	4
+#define PM800_LDO19_SLP5_MASK	(0x3 << PM800_LDO19_SLP5_SHIFT)
+#define PM800_LDO_MISC6    (0X95)
+
+unsigned char pm80x_get_power_on_reason(void);
+#define PMIC_GENERAL_USE_REGISTER PM800_USER_DATA1
+#define PMIC_GENERAL_USE_BOOT_BY_NONE		0
+#define PMIC_GENERAL_USE_BOOT_BY_ONKEY	(0x1 << 0)
+#define PMIC_GENERAL_USE_BOOT_BY_CHG		(0x1 << 1)
+#define PMIC_GENERAL_USE_BOOT_BY_EXTON	(0x1 << 2)
+#define PMIC_GENERAL_USE_BOOT_BY_RTC_ALARM	(0x1 << 3)
+#define PMIC_GENERAL_USE_BOOT_BY_FOTA		(0x1 << 4)
+#define PMIC_GENERAL_USE_BOOT_BY_FULL_RESET		(0x1 << 5)
+#define PMIC_GENERAL_USE_BOOT_BY_HW_RESET		(0x1 << 6)
+#define PMIC_GENERAL_USE_BOOT_BY_INTENDED_RESET	(0x1 << 7)
+#define PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_LOW	(0x1 << 7) | 0x1
+#define PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_MID	(0x1 << 6) | 0x1
+#define PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_HIGH	(0x1 << 5) | 0x1
+#define PMIC_GENERAL_USE_BOOT_BY_RECOVERY_DONE	(0x1 << 4) | 0x1
+#define PMIC_GENERAL_USE_BOOT_BY_SET_SWITCH_SEL	(0x5 << 4)	/* used as mask */
+
+/* page 2 GPADC: slave adder 0x02 */
+#define PM800_GPADC_MEAS_EN1		(0x01)
+#define PM800_MEAS_EN1_VBAT         (1 << 2)
+#define PM800_GPADC_MEAS_EN2		(0x02)
+#define PM800_MEAS_EN2_RFTMP        (1 << 0)
+#define PM800_MEAS_GP0_EN			(1 << 2)
+#define PM800_MEAS_GP1_EN			(1 << 3)
+#define PM800_MEAS_GP2_EN			(1 << 4)
+#define PM800_MEAS_GP3_EN			(1 << 5)
+#define PM800_MEAS_GP4_EN			(1 << 6)
+
+#define PM800_GPADC_MISC_CONFIG1	(0x05)
+#define PM800_GPADC_MISC_CONFIG2	(0x06)
+#define PM800_GPADC_MISC_GPFSM_EN	(1 << 0)
+#define PM800_GPADC_SLOW_MODE(x)	(x << 3)
+
+#define PM800_GPADC_MEASURE_OFF1	(0x07)
+#define PM800_GPADC_MEASURE_OFF2	(0x08)
+#define PM800_BD_PREBIAS		(1 << 4)
+#define PM800_BD_EN			(1 << 5)
+#define PM800_BD_GP1_EN			(1 << 6)
+#define PM800_BD_GP3_EN			(1 << 7)
+
+#define PM800_GPADC_MISC_CONFIG3		(0x09)
+#define PM800_GPADC_MISC_CONFIG4		(0x0A)
+#define PM800_GPADC_BIAS1			(0x0B)
+#define PM800_GPADC_BIAS2			(0x0C)
+#define PM800_GPADC_BIAS3			(0x0D)
+#define PM800_GPADC_BIAS4			(0x0E)
+
+#define GP_BIAS_SET(x)				(x << 0)
+#define GP_PREBIAS(x)				(x << 4)
+
+#define PM800_GPADC_PREBIAS1			(0x0F)
+#define PM800_GPADC0_GP_PREBIAS_TIME(x)	(x << 0)
+#define PM800_GPADC_PREBIAS2			(0x10)
+
+#define PM800_GP_BIAS_ENA1				(0x14)
+#define PM800_GPADC_GP_BIAS_EN0			(1 << 0)
+#define PM800_GPADC_GP_BIAS_EN1			(1 << 1)
+#define PM800_GPADC_GP_BIAS_EN2			(1 << 2)
+#define PM800_GPADC_GP_BIAS_EN3			(1 << 3)
+#define PM800_GPADC_GP_BIAS_OUT0		(1 << 4)
+#define PM800_GPADC_GP_BIAS_OUT1		(1 << 5)
+#define PM800_GPADC_GP_BIAS_OUT2		(1 << 6)
+#define PM800_GPADC_GP_BIAS_OUT3		(1 << 7)
+
+#define PM800_GP_BIAS_OUT1		(0x15)
+#define PM800_BIAS_OUT_GP0		(1 << 0)
+#define PM800_BIAS_OUT_GP1		(1 << 1)
+#define PM800_BIAS_OUT_GP2		(1 << 2)
+#define PM800_BIAS_OUT_GP3		(1 << 3)
+
+#define PM800_VBAT_LOW_TH		0x18
+
+#define PM800_GPADC_GP_BIAS_OUT0			(1 << 4)
+#define PM800_GPADC_GP_BIAS_OUT1			(1 << 5)
+#define PM800_GPADC_GP_BIAS_OUT2			(1 << 6)
+#define PM800_GPADC_GP_BIAS_OUT3			(1 << 7)
+#define PM800_GPADC_GP_BIAS_SHIFT0		0
+#define PM800_GPADC_GP_BIAS_MASK0		(0xFF << PM800_GPADC_GP_BIAS_SHIFT0)
+#define PM800_GPADC0_LOW_TH		0x20
+#define PM800_GPADC1_LOW_TH		0x21
+#define PM800_GPADC2_LOW_TH		0x22
+#define PM800_GPADC3_LOW_TH		0x23
+#define PM800_GPADC4_LOW_TH		0x24
+
+#define PM800_GPADC0_UPP_TH		0x30
+#define PM800_GPADC1_UPP_TH		0x31
+#define PM800_GPADC2_UPP_TH		0x32
+#define PM800_GPADC3_UPP_TH		0x33
+#define PM800_GPADC4_UPP_TH		0x34
+
+#define PM800_VBBAT_MEAS1		0x40
+#define PM800_VBBAT_MEAS2		0x41
+#define PM800_VBAT_MEAS1		0x42
+#define PM800_VBAT_MEAS2		0x43
+#define PM800_VSYS_MEAS1		0x44
+#define PM800_VSYS_MEAS2		0x45
+#define PM800_VCHG_MEAS1		0x46
+#define PM800_VCHG_MEAS2		0x47
+#define PM800_TINT_MEAS1		0x50
+#define PM800_TINT_MEAS2		0x51
+#define PM800_PMOD_MEAS1		0x52
+#define PM800_PMOD_MEAS2		0x53
+
+#define PM800_GPADC0_MEAS1		0x54
+#define PM800_GPADC0_MEAS2		0x55
+#define PM800_GPADC1_MEAS1		0x56
+#define PM800_GPADC1_MEAS2		0x57
+#define PM800_GPADC2_MEAS1		0x58
+#define PM800_GPADC2_MEAS2		0x59
+#define PM800_GPADC3_MEAS1		0x5A
+#define PM800_GPADC3_MEAS2		0x5B
+#define PM800_GPADC4_MEAS1		0x5C
+#define PM800_GPADC4_MEAS2		0x5D
+
+#define PM800_GPADC4_AVG1		0xA8
+#define PM800_GPADC4_AVG2		0xA9
+#define PM800_VBAT_AVG                  0xA0
+#define PM800_VBAT_AVG2                 0xA1
+#define PM800_VBAT_SLP			0xB0
+
+#define PM800_GPADC_BIAS1_D0				(0x0C)
+#define PM800_GPADC_GP_BIAS_SHIFT1_D0	0
+/* 88PM805 Registers */
+#define PM805_MAIN_POWERUP		(0x01)
+#define PM805_INT_STATUS0		(0x02)	/* for ena/dis all interrupts */
+
+#define PM805_STATUS0_INT_CLEAR		(1 << 0)
+#define PM805_STATUS0_INV_INT		(1 << 1)
+#define PM800_STATUS0_INT_MASK		(1 << 2)
+
+#define PM805_INT_STATUS1		(0x03)
+
+#define PM805_INT1_HP1_SHRT		(1 << 0)
+#define PM805_INT1_HP2_SHRT		(1 << 1)
+#define PM805_INT1_MIC_CONFLICT		(1 << 2)
+#define PM805_INT1_CLIP_FAULT		(1 << 3)
+#define PM805_INT1_LDO_OFF			(1 << 4)
+#define PM805_INT1_SRC_DPLL_LOCK	(1 << 5)
+
+#define PM805_INT_STATUS2		(0x04)
+
+#define PM805_INT2_MIC_DET			(1 << 0)
+#define PM805_INT2_SHRT_BTN_DET		(1 << 1)
+#define PM805_INT2_VOLM_BTN_DET		(1 << 2)
+#define PM805_INT2_VOLP_BTN_DET		(1 << 3)
+#define PM805_INT2_RAW_PLL_FAULT	(1 << 4)
+#define PM805_INT2_FINE_PLL_FAULT	(1 << 5)
+
+#define PM805_INT_MASK1			(0x05)
+#define PM805_INT_MASK2			(0x06)
+#define PM805_SHRT_BTN_DET		(1 << 1)
+
+/* number of status and int reg in a row */
+#define PM805_INT_REG_NUM		(2)
+
+#define PM805_MIC_DET1			(0x07)
+#define PM805_MIC_DET_EN_MIC_DET (1 << 0)
+#define PM805_MIC_DET2			(0x08)
+#define PM805_MIC_DET_STATUS1	(0x09)
+
+#define PM805_MIC_DET_STATUS3	(0x0A)
+#define PM805_AUTO_SEQ_STATUS1	(0x0B)
+#define PM805_AUTO_SEQ_STATUS2	(0x0C)
+
+#define PM805_ADC_SETTING1		(0x10)
+#define PM805_ADC_SETTING2		(0x11)
+#define PM805_ADC_SETTING3		(0x11)
+#define PM805_ADC_GAIN1			(0x12)
+#define PM805_ADC_GAIN2			(0x13)
+#define PM805_DMIC_SETTING		(0x15)
+#define PM805_DWS_SETTING		(0x16)
+#define PM805_MIC_CONFLICT_STS	(0x17)
+
+#define PM805_PDM_SETTING1		(0x20)
+#define PM805_PDM_SETTING2		(0x21)
+#define PM805_PDM_SETTING3		(0x22)
+#define PM805_PDM_CONTROL1		(0x23)
+#define PM805_PDM_CONTROL2		(0x24)
+#define PM805_PDM_CONTROL3		(0x25)
+
+#define PM805_HEADPHONE_SETTING			(0x26)
+#define PM805_HEADPHONE_GAIN_A2A		(0x27)
+#define PM805_HEADPHONE_SHORT_STATE		(0x28)
+#define PM805_EARPHONE_SETTING			(0x29)
+#define PM805_AUTO_SEQ_SETTING			(0x2A)
+
+#define PMIC_GENERAL_DOWNLOAD_MODE_NONE	0
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD1	1
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD2	2
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD3	3
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD4	4
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD5	5
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD6	6
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD7	7
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD8	8
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD9	9
+#define PMIC_GENERAL_DOWNLOAD_MODE_FUS		10
+
+struct pm80x_rtc_pdata {
+	int		(*sync)(unsigned int ticks);
+	int		vrtc;
+	int		rtc_wakeup;
+};
+
+struct pm80x_dvc_pdata {
+	int dvc1;
+	int dvc2;
+	unsigned int *vol_val;
+	int size;
+	int gpio_dvc;	/* 0 when gpios are not used for dvc */
+	int reg_dvc;	/* 0 when direct register is used for dvc */
+	int (*set_dvc)(int reg_id, int volt);
+	void __iomem *write_reg; /* Register to set level */
+	void __iomem *read_reg;  /* Register to read level */
+};
+
+struct pm80x_headset_pdata {
+	int headset_flag;
+	void (*mic_set_power)(int on);
+	int		hook_press_th;
+	int		vol_up_press_th;
+	int		vol_down_press_th;
+	int		mic_det_th;
+	int		press_release_th;
+};
+
+struct pm80x_vibrator_pdata {
+	int		min_timeout;
+	void		(*vibrator_power)(int on);
+};
+
+struct pm80x_bat_pdata {
+	int bat_ntc; /* bat det by GPADC1 */
+	int capacity; /* mAh */
+	int r_int; /* mOhm */
+};
+
+struct pm80x_usb_pdata {
+	int	vbus_gpio;
+	int	id_gpadc;
+};
+
+
+struct pm80x_subchip {
+	struct i2c_client *power_page;	/* chip client for power page */
+	struct i2c_client *gpadc_page;	/* chip client for gpadc page */
+	struct i2c_client *test_page;	/* chip client for test page */
+	struct regmap *regmap_power;
+	struct regmap *regmap_gpadc;
+	struct regmap *regmap_test;
+	unsigned short power_page_addr;	/* power page I2C address */
+	unsigned short gpadc_page_addr;	/* gpadc page I2C address */
+	unsigned short test_page_addr;	/* test page I2C address */
+};
+
+struct pm80x_chip {
+	struct pm80x_subchip *subchip;
+	struct device *dev;
+	struct i2c_client *client;
+	struct i2c_client *companion;
+	struct regmap *regmap;
+	struct regmap_irq_chip *regmap_irq_chip;
+	struct regmap_irq_chip_data *irq_data;
+	unsigned char version;
+	int id;
+	int irq;
+	int irq_mode;
+	int irq_base;
+	unsigned long wu_flag;
+	spinlock_t lock;
+	struct proc_dir_entry *proc_file;
+};
+
+struct pm80x_platform_data {
+	struct pm80x_rtc_pdata *rtc;
+#ifdef CONFIG_SAMSUNG_JACK
+	struct sec_jack_platform_data *headset;
+#else
+	struct pm80x_headset_pdata *headset;
+#endif
+	struct regulator_init_data *regulator;
+	struct pm80x_vibrator_pdata *vibrator;
+	struct pm80x_dvc_pdata *dvc;
+	struct pm80x_bat_pdata *bat;
+	struct pm80x_usb_pdata *usb;
+
+	unsigned short power_page_addr;	/* power page I2C address */
+	unsigned short gpadc_page_addr;	/* gpadc page I2C address */
+	unsigned short test_page_addr;	/* test page I2C address */
+	int irq_mode;		/* Clear interrupt by read/write(0/1) */
+	int batt_det;		/* enable/disable */
+	int num_regulators;
+	int (*plat_config)(struct pm80x_chip *chip,
+				struct pm80x_platform_data *pdata);
+};
+
+extern int pm80x_read_temperature(int *tbat);
+extern int pm80x_read_gpadc(int *tbat, unsigned int channel);
+
+extern const struct dev_pm_ops pm80x_pm_ops;
+extern const struct regmap_config pm80x_regmap_config;
+
+static inline int pm80x_request_irq(struct pm80x_chip *pm80x, int irq,
+				     irq_handler_t handler, unsigned long flags,
+				     const char *name, void *data)
+{
+	/*
+	 * kernel 3.4 doesn't have regmap_irq_get_virq support yet, so
+	 * switch to use normal real irq to request_threaded_irq.
+	 */
+#if 0
+	if (!pm80x->irq_data)
+		return -EINVAL;
+	return request_threaded_irq(regmap_irq_get_virq(pm80x->irq_data, irq),
+				    NULL, handler, flags, name, data);
+#endif
+	return request_threaded_irq(irq, NULL, handler, flags, name, data);
+}
+
+static inline void pm80x_free_irq(struct pm80x_chip *pm80x, int irq, void *data)
+{
+	if (!pm80x->irq_data)
+		return;
+#if 0
+	free_irq(regmap_irq_get_virq(pm80x->irq_data, irq), data);
+#endif
+	free_irq(irq, data);
+}
+
+#ifdef CONFIG_PM
+static inline int pm80x_dev_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pm80x_chip *chip = dev_get_drvdata(pdev->dev.parent);
+	int irq = platform_get_irq(pdev, 0);
+
+	if (device_may_wakeup(dev))
+		set_bit(irq, &chip->wu_flag);
+
+	return 0;
+}
+
+static inline int pm80x_dev_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pm80x_chip *chip = dev_get_drvdata(pdev->dev.parent);
+	int irq = platform_get_irq(pdev, 0);
+
+	if (device_may_wakeup(dev))
+		clear_bit(irq, &chip->wu_flag);
+
+	return 0;
+}
+#endif
+
+extern int pm80x_init(struct i2c_client *client,
+			     const struct i2c_device_id *id) __devinit;
+extern int pm80x_deinit(void);
+
+#ifdef CONFIG_MFD_88PM800
+extern int pm800_extern_read(int page, int reg);
+extern int pm800_extern_write(int page, int reg, unsigned char val);
+extern int pm800_extern_setbits(int page, int reg,
+			 unsigned char mask, unsigned char val);
+#endif
+#endif /* __LINUX_MFD_88PM80X_H */
diff --git a/include/linux/mfd/88pm822.h b/include/linux/mfd/88pm822.h
new file mode 100755
index 00000000..ceab1658
--- /dev/null
+++ b/include/linux/mfd/88pm822.h
@@ -0,0 +1,602 @@
+/*
+ * Marvell 88PM822 Interface
+ *
+ * Copyright (C) 2013 Marvell International Ltd.
+ * Yipeng <ypyao@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_MFD_88PM822_H
+#define __LINUX_MFD_88PM822_H
+
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/regmap.h>
+#include <linux/atomic.h>
+#include <linux/regulator/machine.h>
+#include <linux/proc_fs.h>
+#include <linux/battery/sec_fuelgauge.h>
+
+enum {
+	PM822_INVALID_PAGE = 0,
+	PM822_BASE_PAGE,
+	PM822_POWER_PAGE,
+	PM822_GPADC_PAGE,
+};
+
+enum {
+	PM822_ID_BUCK1 = 0,
+	PM822_ID_BUCK2,
+	PM822_ID_BUCK3,
+	PM822_ID_BUCK4,
+	PM822_ID_BUCK5,
+
+	PM822_ID_LDO1,
+	PM822_ID_LDO2,
+	PM822_ID_LDO3,
+	PM822_ID_LDO4,
+	PM822_ID_LDO5,
+	PM822_ID_LDO6,
+	PM822_ID_LDO7,
+	PM822_ID_LDO8,
+	PM822_ID_LDO9,
+	PM822_ID_LDO10,
+	PM822_ID_LDO11,
+	PM822_ID_LDO12,
+	PM822_ID_LDO13,
+	PM822_ID_LDO14,
+	PM822_ID_VOUTSW,
+
+#if defined(CONFIG_CPU_PXA1L88) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	/* below 4 ids are fake id, they are only used in new dvc */
+	PM822_ID_BUCK1_AP_ACTIVE,
+	PM822_ID_BUCK1_AP_LPM,
+	PM822_ID_BUCK1_APSUB_IDLE,
+	PM822_ID_BUCK1_APSUB_SLEEP,
+#endif
+
+	PM822_ID_RG_MAX,
+};
+
+enum {
+	PM822_NO_GPIO = -1,
+	PM822_GPIO0 = 0,
+	PM822_GPIO1,
+	PM822_GPIO2,
+	PM822_GPIO3,
+};
+
+enum {
+	PM822_NO_GPADC = -1,
+	PM822_GPADC0 = 0,
+	PM822_GPADC1,
+	PM822_GPADC2,
+	PM822_GPADC3,
+};
+
+#define PM822_BASE_REG_NUM		0xF0
+#define PM822_POWER_REG_NUM		0xD9
+#define PM822_GPADC_REG_NUM		0xC8
+
+/*
+ * Page 0: basic
+ */
+#define PM822_CHIP_ID			(0x00)
+#define PM822_STATUS1			(0x01)
+#define PM822_ONKEY_STS1		(1 << 0)
+#define PM822_CHG_STS1			(1 << 2)
+#define PM822_BAT_STS1			(1 << 3)
+#define PM822_LDO_PGOOD_STS1	(1 << 5)
+#define PM822_BUCK_PGOOD_STS1	(1 << 6)
+
+/* Interrupt Registers */
+#define PM822_INT_STATUS1		(0x05)
+#define PM822_INT_STATUS2		(0x06)
+#define PM822_INT_STATUS3		(0x07)
+#define PM822_INT_EN1			(0x09)
+	/* PM822_INT_EN1 bit definition */
+#define PM822_IRQ_ONKEY_EN		(1 << 0)
+#define PM822_IRQ_CHG_EN		(1 << 2)
+#define PM822_IRQ_BAT_EN		(1 << 3)
+#define PM822_IRQ_RTC_EN		(1 << 4)
+#define PM822_IRQ_CLASSD_EN		(1 << 5)
+	/* end */
+#define PM822_INT_EN2			(0x0A)
+	/* PM822_INT_EN2 bit definition */
+#define PM822_IRQ_VBAT_EN		(1 << 0)
+#define PM822_IRQ_VSYS_EN		(1 << 1)
+#define PM822_IRQ_TINT_EN		(1 << 3)
+#define PM822_IRQ_LDO_PGOOD_EN		(1 << 4)
+#define PM822_IRQ_BUCK_PGOOD_EN		(1 << 5)
+	/* end */
+#define PM822_INT_EN3			(0x0B)
+	/* PM822_INT_EN3 bit definition */
+#define PM822_IRQ_GPADC0_EN		(1 << 0)
+#define PM822_IRQ_GPADC1_EN		(1 << 1)
+#define PM822_IRQ_GPADC2_EN		(1 << 2)
+#define PM822_IRQ_GPADC3_EN		(1 << 3)
+#define PM822_IRQ_MIC_DET_EN		(1 << 4)
+#define PM822_IRQ_HS_DET_EN		(1 << 5)
+	/* end */
+
+/* Wakeup Registers */
+#define PM822_WAKEUP1			(0x0D)
+#define PM822_WAKEUP1_WD_MODE	(1 << 0)
+#define PM822_WAKEUP2			(0x0E)
+	/* PM822_WAKEUP2 bit definition */
+#define PM822_INV_INT			(1 << 0)
+#define PM822_INT_CLEAR_MODE		(1 << 1)
+#define PM822_INT_MASK_MODE		(1 << 2)
+#define PM822_WD_TIMER_ACT_MASK  (7 << 3)
+#define PM822_WD_TIMER_ACT_1S		(0 << 3)
+#define PM822_WD_TIMER_ACT_2S		(1 << 3)
+#define PM822_WD_TIMER_ACT_4S		(2 << 3)
+#define PM822_WD_TIMER_ACT_8S		(3 << 3)
+#define PM822_WD_TIMER_ACT_16S		(4 << 3)
+#define PM822_WD_TIMER_ACT_32S		(5 << 3)
+#define PM822_WD_TIMER_ACT_64S		(6 << 3)
+#define PM822_WD_TIMER_ACT_256S		(7 << 3)
+
+	/* end */
+#define PM822_POWER_UP_LOG		(0x10)
+
+#define PM822_WATCHDOG_REG		(0x1D)
+#define PM822_WD_DIS			(1 << 0)
+#define PM822_WD_EN				(0)
+
+/* Referance and low power registers */
+#define PM822_LOW_POWER1		(0x20)
+#define PM822_LOW_POWER2		(0x21)
+#define PM822_LOW_POWER_CONFIG3		(0x22)
+#define PM822_LOW_POWER_CONFIG4		(0x23)
+#define PM822_LOW_POWER_CONFIG5		(0x24)
+
+/* GPIO register */
+#define PM822_GPIO0_CTRL		(0x30)
+#define PM822_GPIO0_VAL			(1 << 0)
+#define PM822_GPIO0_GPIO_MODE(x)	(x << 1)
+#define PM822_GPIO1_CTRL		(0x31)
+#define PM822_GPIO1_VAL			(1 << 0)
+#define PM822_GPIO1_GPIO_MODE(x)	(x << 1)
+#define PM822_GPIO2_CTRL		(0x32)
+#define PM822_GPIO2_VAL			(1 << 0)
+#define PM822_GPIO2_GPIO_MODE(x)	(x << 1)
+#define PM822_GPIO3_CTRL		(0x33)
+#define PM822_GPIO3_VAL			(1 << 0)
+#define PM822_GPIO3_GPIO_MODE(x)	(x << 1)
+
+#define PM822_HEADSET_CNTRL		(0x38)
+#define PM822_HEADSET_DET_EN		(1 << 7)
+#define PM822_HSDET_PERIOD_128MS  	(0)
+#define PM822_HSDET_PERIOD_256MS  	(1 << 2)
+#define PM822_HSDET_PERIOD_512MS  	(2 << 2)
+#define PM822_HSDET_PERIOD_CONT  	(3 << 2)
+#define PM822_HSDET_SLP				(1 << 1)
+#define PM822_HSDET_COUNT       	(1 << 0) 
+
+#define PM822_MIC_CNTRL			(0x39)
+#define PM822_HEADSET_DET_MASK		(1 << 7)
+#define PM822_MIC_DET_EN			(1 << 0)
+
+/* PWM register */
+#define PM822_PWM1			(0x40)
+#define PM822_PWM2			(0x41)
+#define PM822_PWM3			(0x42)
+#define PM822_PWM4			(0x43)
+
+/* Oscillator control */
+#define PM822_OSC_CTRL1			(0x50)
+#define PM822_OSC_CTRL2			(0x51)
+#define PM822_OSC_CTRL3			(0x52)
+#define PM822_OSC_CTRL4			(0x53)
+#define PM822_OSC_CTRL5			(0x54)
+#define PM822_OSC_CTRL6			(0x55)
+#define PM822_OSC_CTRL7			(0x56)
+#define PM822_OSC_CTRL8			(0x57)
+#define PM822_OSC_CTRL9			(0x58)
+#define PM822_OSC_CTRL11		(0x5A)
+#define PM822_OSC_CTRL12		(0x5B)
+#define PM822_OSC_CTRL13		(0x5C)
+
+/* RTC Registers */
+#define PM822_RTC_CTRL			(0xD0)
+/* bit definitions of RTC Register 1 (0xD0) */
+#define PM822_ALARM1_EN			(1 << 0)
+#define PM822_ALARM_WAKEUP		(1 << 4)
+#define PM822_ALARM			(1 << 5)
+#define PM822_RTC1_USE_XO		(1 << 7)
+
+	/* end */
+#define PM822_RTC_COUNTER1		(0xD1)
+#define PM822_RTC_COUNTER2		(0xD2)
+#define PM822_RTC_COUNTER3		(0xD3)
+#define PM822_RTC_COUNTER4		(0xD4)
+#define PM822_RTC_EXPIRE1_1		(0xD5)
+#define PM822_RTC_EXPIRE1_2		(0xD6)
+#define PM822_RTC_EXPIRE1_3		(0xD7)
+#define PM822_RTC_EXPIRE1_4		(0xD8)
+#define PM822_RTC_TRIM1			(0xD9)
+#define PM822_RTC_TRIM2			(0xDA)
+#define PM822_RTC_TRIM3			(0xDB)
+#define PM822_RTC_TRIM4			(0xDC)
+#define PM822_RTC_EXPIRE2_1		(0xDD)
+#define PM822_RTC_EXPIRE2_2		(0xDE)
+#define PM822_RTC_EXPIRE2_3		(0xDF)
+#define PM822_RTC_EXPIRE2_4		(0xE0)
+#define PM822_RTC_MISC1			(0xE1)
+#define PM822_RTC_MISC2			(0xE2)
+#define PM822_RTC_MISC3			(0xE3)
+#define PM822_RTC_MISC4			(0xE4)
+#define PM822_RTC_MISC5			(0xE7)
+#define PM822_RTC_MISC6			(0xE8)
+#define PM822_RTC_MISC7			(0xE9)
+#define PM822_USER_DATA1		(0xEA)
+#define PM822_USER_DATA2		(0xEB)
+#define PM822_USER_DATA3		(0xEC)
+#define PM822_USER_DATA4		(0xED)
+#define PM822_USER_DATA5		(0xEE)
+#define PM822_USER_DATA6		(0xEF)
+#define PM822_POWER_DOWN_LOG1		(0xE5)
+#define PM822_POWER_DOWN_LOG2		(0xE6)
+
+/*
+ * Page 1: power
+ */
+#define PM822_NOUSE			(0xFF)
+#define PM822_LDO1			(0x08)
+#define PM822_LDO2_AUDIO		(0x0A)
+#define PM822_LDO2			(0x0B)
+#define PM822_LDO3			(0x0C)
+#define PM822_LDO4			(0x0D)
+#define PM822_LDO5			(0x0E)
+#define PM822_LDO6			(0x0F)
+#define PM822_LDO7			(0x10)
+#define PM822_LDO8			(0x11)
+#define PM822_LDO9			(0x12)
+#define PM822_LDO10			(0x13)
+#define PM822_LDO11			(0x14)
+#define PM822_LDO12			(0x15)
+#define PM822_LDO13			(0x16)
+#define PM822_LDO14			(0x17)
+#define PM822_VOUTSW			(0xFF)	/* fake register */
+
+#define PM822_BUCK1_SLP			(0x30)
+#define PM822_BUCK2_SLP			(0x31)
+#define PM822_BUCK3_SLP			(0x32)
+#define PM822_BUCK4_SLP			(0x33)
+#define PM822_BUCK5_SLP			(0x34)
+#define PM822_AUDIO_MODE		(0x38)
+
+#define PM822_BUCK1			(0x3C)
+#define PM822_BUCK2			(0x40)
+#define PM822_BUCK3			(0x41)
+#define PM822_BUCK3_1			(0x42)
+#define PM822_BUCK3_2			(0x43)
+#define PM822_BUCK3_3			(0x44)
+#define PM822_BUCK4			(0x45)
+#define PM822_BUCK5			(0x46)
+
+#define PM822_BUCK_EN1			(0x50)
+#define PM822_LDO1_8_EN1		(0x51)
+#define PM822_LDO9_14_EN1		(0x52)
+#define PM822_MISC_EN1			(0x54)
+#define PM822_BUCK_EN2			(0X55)
+#define PM822_LDO1_8_EN2		(0x56)
+#define PM822_LDO9_14_EN2		(0x57)
+#define PM822_MISC_EN3			(0x59)
+
+#define PM822_BUCK_SLP1			(0x5A)
+
+/* BUCK Sleep Mode Register 1: BUCK[1..4] */
+#define PM822_BUCK_SLP_PWR_OFF	0x0	/* power off */
+#define PM822_BUCK_SLP_PWR_ACT1	0x1	/* auto & VBUCK_SET_SLP */
+#define PM822_BUCK_SLP_PWR_LOW	0x2	/* VBUCK_SET_SLP */
+#define PM822_BUCK_SLP_PWR_ACT2	0x3	/* auto & VBUCK_SET */
+
+#define PM822_BUCK1_SLP1_SHIFT		0
+#define PM822_BUCK1_SLP1_MASK		(0x3 << PM822_BUCK1_SLP1_SHIFT)
+#define PM822_BUCK2_SLP1_SHIFT		2
+#define PM822_BUCK2_SLP1_MASK		(0x3 << PM822_BUCK2_SLP1_SHIFT)
+#define PM822_BUCK2_SLP1_UNMASK	(0x2 << PM822_BUCK2_SLP1_SHIFT)
+
+#define PM822_BUCK_SLP2			(0x5B)
+#define PM822_LDO_SLP1			(0x5C)
+#define PM822_LDO_SLP2			(0x5D)
+#define PM822_LDO_SLP3			(0x5E)
+#define PM822_LDO_SLP4			(0x5F)
+
+#define PM822_BUCK4_MISC2		(0x82)
+#define PM822_BUCK_SHARED_CTRL		(0x8F)
+
+#define PM822_LDO_MISC1			(0x90)
+#define PM822_LDO_MISC2			(0x92)
+#define PM822_LDO_MISC8			(0x98)
+/*
+ * Page 2: GPADC
+ */
+#define PM822_GPADC_MEAS_EN1		(0x01)
+#define PM822_GPADC_MEAS_EN2		(0x02)
+#define PM822_GPADC0_MEANS_EN		(1 << 2)
+#define PM822_GPADC1_MEANS_EN		(1 << 3)
+#define PM822_GPADC2_MEANS_EN		(1 << 4)
+#define PM822_GPADC3_MEANS_EN		(1 << 5)
+#define PM822_GPADC_MISC_CONFIG1	(0x05)
+#define PM822_GPADC4_DIR		(1 << 6)
+#define PM822_GPADC_MISC_CONFIG2	(0x06)
+	/* PM822_GPADC_MISC_CONFIG2 bit definition */
+#define PM822_GPADC_EN			(1 << 0)
+#define PM822_GPADC_NON_STOP		(1 << 1)
+#define PM822_MEANS_EN_SLP		(1 << 4)
+#define PM822_MEANS_GP_SLP_MODE		(3 << 5)
+	/* end */
+
+#define PM822_GPADC_MEAS_OFF1		(0x07)
+#define PM822_GPADC_MEAS_OFF2		(0x08)
+#define PM822_GPADC_MISC_CONFIG3	(0x0A)
+#define PM822_GPADC_BIAS1		(0x0B)
+#define PM822_GPADC_BIAS2		(0x0C)
+#define PM822_GPADC_BIAS3		(0x0D)
+#define PM822_GPADC_BIAS4		(0x0E)
+#define PM822_GPADC_BIAS_EN1		(0x14)
+#define PM822_GPADC_GP_BIAS_EN0		(1 << 0)
+#define PM822_GPADC_GP_BIAS_EN1		(1 << 1)
+#define PM822_GPADC_GP_BIAS_EN2		(1 << 2)
+#define PM822_GPADC_GP_BIAS_EN3		(1 << 3)
+#define PM822_GPADC_GP_BIAS_OUT0	(1 << 4)
+#define PM822_GPADC_GP_BIAS_OUT1	(1 << 5)
+#define PM822_GPADC_GP_BIAS_OUT2	(1 << 6)
+#define PM822_GPADC_GP_BIAS_OUT3	(1 << 7)
+#define PM822_VBAT_LOW_TH		(0x18)
+#define PM822_VSYS_LOW_TH		(0x19)
+#define PM822_TINT_LOW_TH		(0x1B)
+#define PM822_GPADC0_LOW_TH		(0x20)
+#define PM822_GPADC1_LOW_TH		(0x21)
+#define PM822_GPADC2_LOW_TH		(0x22)
+#define PM822_GPADC3_LOW_TH		(0x23)
+#define PM822_MIC_DET_LOW_TH		(0x24)
+
+#define PM822_VBAT_UPP_TH		(0x28)
+#define PM822_VSYS_UPP_TH		(0x29)
+#define PM822_VCHG_UPP_TH		(0x2A)
+#define PM822_TINT_UPP_TH		(0x2B)
+#define PM822_GPADC0_UPP_TH		(0x30)
+#define PM822_GPADC1_UPP_TH		(0x31)
+#define PM822_GPADC2_UPP_TH		(0x32)
+#define PM822_GPADC3_UPP_TH		(0x33)
+#define PM822_MIC_DET_UPP_TH		(0x34)
+
+#define PM822_VBBAT_MEAS1		(0x40)
+#define PM822_VBBAT_MEAS2		(0x41)
+#define PM822_VBAT_MEAS1		(0x42)
+#define PM822_VBAT_MEAS2		(0x43)
+#define PM822_VSYS_MEAS1		(0x44)
+#define PM822_VSYS_MEAS2		(0x45)
+#define PM822_TINT_MEAS1		(0x50)
+#define PM822_TINT_MEAS2		(0x51)
+
+#define PM822_GPADC0_MEAS1		(0x54)
+#define PM822_GPADC0_MEAS2		(0x55)
+#define PM822_GPADC1_MEAS1		(0x56)
+#define PM822_GPADC1_MEAS2		(0x57)
+#define PM822_GPADC2_MEAS1		(0x58)
+#define PM822_GPADC2_MEAS2		(0x59)
+#define PM822_GPADC3_MEAS1		(0x5A)
+#define PM822_GPADC3_MEAS2		(0x5B)
+#define PM822_MIC_DET_MEAS1		(0x5C)
+#define PM822_MIC_DET_MEAS2		(0x5D)
+
+#define PM822_VBAT_AVG                  (0xA0)
+#define PM822_VBAT_AVG2                 (0xA1)
+#define PM822_VSYS_AVG                  (0xA2)
+#define PM822_VSYS_AVG2                 (0xA3)
+#define PM822_GPADC3_AVG1		(0xA6)
+#define PM822_GPADC3_AVG2		(0xA7)
+#define PM822_MIC_DET_AVG1		(0xA8)
+#define PM822_MIC_DET_AVG2		(0xA9)
+#define PM822_GPADC4_AVG2		(0xA9)
+#define PM822_VBAT_SLP			(0xB0)
+
+#define PMIC_GENERAL_DOWNLOAD_MODE_NONE		0
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD1		1
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD2		2
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD3		3
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD4		4
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD5		5
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD6		6
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD7		7
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD8		8
+#define PMIC_GENERAL_DOWNLOAD_MODE_SUD9		9
+#define PMIC_GENERAL_DOWNLOAD_MODE_FUS		10
+
+#define PMIC_GENERAL_USE_REGISTER			PM822_USER_DATA6
+#define PMIC_GENERAL_USE_REBOOT_DN_MASK			(0x1F)
+#define PMIC_GENERAL_USE_BOOT_BY_NONE			(0)
+#define PMIC_GENERAL_USE_BOOT_BY_ONKEY			(1)
+#define PMIC_GENERAL_USE_BOOT_BY_CHG			(2)
+#define PMIC_GENERAL_USE_BOOT_BY_EXTON			(3)
+#define PMIC_GENERAL_USE_BOOT_BY_RTC_ALARM		(4)
+#define PMIC_GENERAL_USE_BOOT_BY_FOTA			(5)
+#define PMIC_GENERAL_USE_BOOT_BY_FULL_RESET		(6)
+#define PMIC_GENERAL_USE_BOOT_BY_HW_RESET		(7)
+#define PMIC_GENERAL_USE_BOOT_BY_INTENDED_RESET		(8)
+#define PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_LOW		(9)
+#define PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_MID		(10)
+#define PMIC_GENERAL_USE_BOOT_BY_DEBUGLEVEL_HIGH	(11)
+#define PMIC_GENERAL_USE_BOOT_BY_RECOVERY_DONE		(12)
+#define PMIC_GENERAL_USE_BOOT_BY_SET_SWITCH_SEL		(13)
+#define DOWNLOAD_FUS_SUD_BASE				(20)
+#define CODE_NOT_SYS_POWER_OFF				(31)
+#define PMIC_GENERAL_USE_SHUTDOWN_SHIFT		(5)
+#define PMIC_GENERAL_USE_SHUTDOWN_MASK	(7 << PMIC_GENERAL_USE_SHUTDOWN_SHIFT)
+#define PMIC_GENERAL_USE_SHUTDOWN_BY_FGERR	(1 << PMIC_GENERAL_USE_SHUTDOWN_SHIFT)
+#define PMIC_GENERAL_USE_SHUTDOWN_BY_CHGERR	(2 << PMIC_GENERAL_USE_SHUTDOWN_SHIFT)
+#define PMIC_GENERAL_USE_SHUTDOWN_BY_ONKEY	(3 << PMIC_GENERAL_USE_SHUTDOWN_SHIFT)
+#define PMIC_GENERAL_USE_SHUTDOWN_BY_UNKNOWN	(4 << PMIC_GENERAL_USE_SHUTDOWN_SHIFT)
+#define PMIC_GENERAL_USE_SHUTDOWN_BY_POWEROFF	(5 << PMIC_GENERAL_USE_SHUTDOWN_SHIFT)
+
+struct  __attribute((unused)) pm822_dvc_pdata {
+	unsigned int *vol_val;
+	int size;
+	int reg_dvc;
+	int (*set_dvc)(int reg_id, int volt);
+	void __iomem *write_reg; /* Register to set level */
+	void __iomem *read_reg;  /* Register to read level */
+};
+
+struct pm822_rtc_pdata {
+	int		(*sync)(unsigned int ticks);
+	int		vrtc;
+	int		rtc_wakeup;
+};
+
+#ifndef CONFIG_SAMSUNG_JACK
+struct pm822_headset_pdata {
+	int		headset_flag;
+	void		(*mic_set_power)(int on);
+	int		hook_press_th;
+	int		vol_up_press_th;
+	int		vol_down_press_th;
+	int		mic_det_th;
+	int		press_release_th;
+};
+#endif
+
+struct pm822_vibrator_pdata {
+	int		min_timeout;
+	int		duty_cycle; /* duty cycle of the PWM */
+	void		(*vibrator_power)(struct device *vib_dev, int on);
+};
+
+struct pm822_usb_pdata {
+	int	vbus_gpio;
+	int	id_gpadc;
+};
+
+struct pm822_subchip {
+	struct i2c_client *power_page;	/* chip client for power page */
+	struct i2c_client *gpadc_page;	/* chip client for gpadc page */
+	struct regmap *regmap_power;
+	struct regmap *regmap_gpadc;
+	unsigned short power_page_addr;	/* power page I2C address */
+	unsigned short gpadc_page_addr;	/* gpadc page I2C address */
+};
+
+struct pm822_chip {
+	struct pm822_subchip *subchip;
+	struct device *dev;
+	struct i2c_client *i2c;
+	struct regmap *regmap;
+	struct regmap_irq_chip *regmap_irq_chip;
+	struct regmap_irq_chip_data *irq_data;
+	unsigned char version;
+	int irq;
+	int irq_base;
+	unsigned long wu_flag;
+	struct proc_dir_entry *proc_file;
+	int batt_gp_nr;
+};
+
+struct pm822_bat_pdata {
+	int bat_ntc; /* bat det by GPADC1 */
+	int capacity; /* mAh */
+	int r_int; /* mOhm */
+};
+
+struct pm822_platform_data {
+	struct pm822_rtc_pdata *rtc;
+#ifdef CONFIG_SAMSUNG_JACK
+	struct sec_jack_platform_data *headset; /* Samsung headset driver data KSND */
+#else
+	struct pm822_headset_pdata *headset;
+#endif
+	struct pm822_vibrator_pdata *vibrator;
+	struct pm822_usb_pdata *usb;
+#if defined(CONFIG_BATTERY_SAMSUNG)
+	struct sec_battery_platform_data *fuelgauge_data;
+#else
+	struct pm822_bat_pdata *bat;
+#endif
+	struct regulator_init_data *regulator;
+#if defined(CONFIG_CPU_PXA1L88) || defined(CONFIG_CPU_PXA988) || defined(CONFIG_CPU_PXA1088)
+	struct pm822_dvc_pdata *dvc;
+#endif
+	int irq_mode;		/* Clear interrupt by read/write(0/1) */
+	unsigned short power_page_addr;	/* power page I2C address */
+	unsigned short gpadc_page_addr;	/* gpadc page I2C address */
+	int num_regulators;
+	int (*plat_config)(struct pm822_chip *chip,
+				struct pm822_platform_data *pdata);
+	unsigned int dummy_dvc_reg;
+	unsigned int (*dvc_init_map)[4];
+	unsigned long irq_flags;
+	int batt_gp_nr;
+};
+
+static inline int pm822_request_irq(struct pm822_chip *pm822, int irq,
+				     irq_handler_t handler, unsigned long flags,
+				     const char *name, void *data)
+{
+	/*
+	 * kernel 3.4 doesn't have regmap_irq_get_virq support yet, so
+	 * switch to use normal real irq to request_threaded_irq.
+	 */
+	return request_threaded_irq(irq, NULL, handler, flags, name, data);
+}
+
+static inline void pm822_free_irq(struct pm822_chip *pm822, int irq, void *data)
+{
+	if (!pm822->irq_data)
+		return;
+
+	free_irq(irq, data);
+}
+
+#ifdef CONFIG_PM
+static inline int pm822_dev_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pm822_chip *chip = dev_get_drvdata(pdev->dev.parent);
+	int irq = platform_get_irq(pdev, 0);
+
+	if (device_may_wakeup(dev))
+		set_bit(irq, &chip->wu_flag);
+
+	return 0;
+}
+
+static inline int pm822_dev_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pm822_chip *chip = dev_get_drvdata(pdev->dev.parent);
+	int irq = platform_get_irq(pdev, 0);
+
+	if (device_may_wakeup(dev))
+		clear_bit(irq, &chip->wu_flag);
+
+	return 0;
+}
+#endif
+
+extern int pm822_init(struct i2c_client *client,
+			     const struct i2c_device_id *id) __devinit;
+extern int pm822_deinit(void);
+extern int pm822_read_gpadc(int *tbat, unsigned int channel);
+extern int get_dynamicbiasgpadc(int *tbat, int gpadc_bias, unsigned int channel);
+extern int is_pm822_a0(void);
+
+#ifdef CONFIG_MFD_88PM822
+extern int pm822_extern_read(int page, int reg);
+extern int pm822_extern_write(int page, int reg, unsigned char val);
+extern int pm822_extern_setbits(int page, int reg,
+			 unsigned char mask, unsigned char val);
+#endif
+
+#ifdef CONFIG_REGULATOR_88PM822
+extern int pm822_set_dvc_idx(struct regulator *reg, int dvc_idx);
+extern int pm822_get_dvc_vol(struct regulator *reg, int dvc_idx);
+#endif
+
+#endif /* __LINUX_MFD_88PM822_H */
diff --git a/include/linux/mfd/rt8973.h b/include/linux/mfd/rt8973.h
new file mode 100644
index 00000000..5933a879
--- /dev/null
+++ b/include/linux/mfd/rt8973.h
@@ -0,0 +1,76 @@
+/*
+ * include/linux/mfd/rt8973.h
+ *
+ * Richtek RT8973 driver header file
+ *
+ * Copyright (C) 2013 Richtek Technology Corp.
+ * Author: Patrick Chang <patrick_chang@richtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#ifndef LINUX_MFD_RT8973_H
+#define LINUX_MFD_RT8973_H
+
+#define SAMSUNG_MVRL_MUIC_RT8973 1
+
+#ifdef SAMSUNG_MVRL_MUIC_RT8973
+#define cable_change_callback sec_charger_cb
+extern struct class *sec_class;
+extern void sec_charger_cb(u8 cable_type);
+#endif
+
+enum {
+	MUIC_RT8973_CABLE_TYPE_NONE = 0,
+	MUIC_RT8973_CABLE_TYPE_UART,            /* adc 0x16 */
+	MUIC_RT8973_CABLE_TYPE_USB,             /* adc 0x1f (none id) */
+	MUIC_RT8973_CABLE_TYPE_OTG,             /* adc 0x00, regDev1&0x01 */
+
+	/* TA Group */
+	MUIC_RT8973_CABLE_TYPE_REGULAR_TA,      /* adc 0x1f (D+ short to D-) */
+	MUIC_RT8973_CABLE_TYPE_ATT_TA,          /* adc 0x1f (only VBUS)AT&T */
+	MUIC_RT8973_CABLE_TYPE_0x15,            /* adc 0x15 */
+	MUIC_RT8973_CABLE_TYPE_TYPE1_CHARGER,   /* adc 0x17 (id : 200k) */
+	MUIC_RT8973_CABLE_TYPE_0x1A,            /* adc 0x1A */
+	MUIC_RT8973_CABLE_TYPE_0x1A_VBUS,       /* adc 0x1A VBUS (DESKDOCK) */
+
+	/* JIG Group */
+	MUIC_RT8973_CABLE_TYPE_JIG_USB_OFF,     /* adc 0x18 */
+	MUIC_RT8973_CABLE_TYPE_JIG_USB_ON,      /* adc 0x19 */
+	MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF,    /* adc 0x1C */
+	MUIC_RT8973_CABLE_TYPE_JIG_UART_ON,     /* adc 0x1D */
+
+	/* JIG type with VBUS */
+	MUIC_RT8973_CABLE_TYPE_JIG_UART_OFF_WITH_VBUS,    /* adc 0x1C */
+	MUIC_RT8973_CABLE_TYPE_JIG_UART_ON_WITH_VBUS,     /* adc 0x1D */
+
+	MUIC_RT8973_CABLE_TYPE_CDP, /* USB CDP, usually treated as SDP */
+	MUIC_RT8973_CABLE_TYPE_L_SPEC_USB, /* L USB cable */
+	MUIC_RT8973_CABLE_TYPE_UNKNOWN,
+	MUIC_RT8973_CABLE_TYPE_INVALID, /* Un-initialized */
+};
+
+typedef enum {
+	JIG_USB_BOOT_OFF,
+	JIG_USB_BOOT_ON,
+	JIG_UART_BOOT_OFF,
+	JIG_UART_BOOT_ON,
+} jig_type_t;
+
+struct rt8973_platform_data {
+	int irq_gpio;
+	void (*cable_chg_callback)(int32_t cable_type);
+	void (*ocp_callback)(void);
+	void (*otp_callback)(void);
+	void (*ovp_callback)(void);
+	void (*usb_callback)(uint8_t attached);
+	void (*uart_callback)(uint8_t attached);
+	void (*otg_callback)(uint8_t attached);
+	void (*jig_callback)(jig_type_t type, uint8_t attached);
+};
+
+#endif /* LINUX_MFD_RT8973_H */
+
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 74aa71be..d4e6e80e 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -249,6 +249,18 @@ struct inode;
 #define page_private(page)		((page)->private)
 #define set_page_private(page, v)	((page)->private = (v))
 
+/* It's valid only if the page is free path or free_list */
+static inline void set_freepage_migratetype(struct page *page, int migratetype)
+{
+	page->index = migratetype;
+}
+
+/* It's valid only if the page is free path or free_list */
+static inline int get_freepage_migratetype(struct page *page)
+{
+	return page->index;
+}
+
 /*
  * FIXME: take this include out, include page-flags.h in
  * files which need it (119 of them)
@@ -873,6 +885,7 @@ extern bool skip_free_areas_node(unsigned int flags, int nid);
 
 int shmem_lock(struct file *file, int lock, struct user_struct *user);
 struct file *shmem_file_setup(const char *name, loff_t size, unsigned long flags);
+void shmem_set_file(struct vm_area_struct *vma, struct file *file);
 int shmem_zero_setup(struct vm_area_struct *);
 
 extern int can_do_mlock(void);
@@ -1046,7 +1059,8 @@ vm_is_stack(struct task_struct *task, struct vm_area_struct *vma, int in_group);
 
 extern unsigned long move_page_tables(struct vm_area_struct *vma,
 		unsigned long old_addr, struct vm_area_struct *new_vma,
-		unsigned long new_addr, unsigned long len);
+		unsigned long new_addr, unsigned long len,
+		bool need_rmap_locks);
 extern unsigned long do_mremap(unsigned long addr,
 			       unsigned long old_len, unsigned long new_len,
 			       unsigned long flags, unsigned long new_addr);
@@ -1335,6 +1349,7 @@ void warn_alloc_failed(gfp_t gfp_mask, int order, const char *fmt, ...);
 extern void setup_per_cpu_pageset(void);
 
 extern void zone_pcp_update(struct zone *zone);
+extern void zone_pcp_reset(struct zone *zone);
 
 /* nommu.c */
 extern atomic_long_t mmap_pages_allocated;
@@ -1374,7 +1389,8 @@ extern void __vma_link_rb(struct mm_struct *, struct vm_area_struct *,
 	struct rb_node **, struct rb_node *);
 extern void unlink_file_vma(struct vm_area_struct *);
 extern struct vm_area_struct *copy_vma(struct vm_area_struct **,
-	unsigned long addr, unsigned long len, pgoff_t pgoff);
+	unsigned long addr, unsigned long len, pgoff_t pgoff,
+	bool *need_rmap_locks);
 extern void exit_mmap(struct mm_struct *);
 
 extern int mm_take_all_locks(struct mm_struct *mm);
@@ -1507,6 +1523,8 @@ int vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,
 			unsigned long pfn);
 int vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,
 			unsigned long pfn);
+int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len);
+
 
 struct page *follow_page(struct vm_area_struct *, unsigned long address,
 			unsigned int foll_flags);
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 629b823f..71282be4 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -57,7 +57,12 @@ struct mmc_ext_csd {
 	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		generic_cmd6_time;	/* Units: 10ms */
 	unsigned int            power_off_longtime;     /* Units: ms */
+	u8			power_off_notification;	/* state */
 	unsigned int		hs_max_dtr;
+#define MMC_HIGH_26_MAX_DTR	26000000
+#define MMC_HIGH_52_MAX_DTR	52000000
+#define MMC_HIGH_DDR_MAX_DTR	52000000
+#define MMC_HS200_MAX_DTR	200000000
 	unsigned int		sectors;
 	unsigned int		card_type;
 	unsigned int		hc_erase_size;		/* In sectors */
@@ -145,6 +150,7 @@ struct sd_switch_caps {
 #define SD_SET_CURRENT_LIMIT_400	1
 #define SD_SET_CURRENT_LIMIT_600	2
 #define SD_SET_CURRENT_LIMIT_800	3
+#define SD_SET_CURRENT_NO_CHANGE	(-1)
 
 #define SD_MAX_CURRENT_200	(1 << SD_SET_CURRENT_LIMIT_200)
 #define SD_MAX_CURRENT_400	(1 << SD_SET_CURRENT_LIMIT_400)
@@ -220,7 +226,6 @@ struct mmc_card {
 #define MMC_CARD_SDXC		(1<<6)		/* card is SDXC */
 #define MMC_CARD_REMOVED	(1<<7)		/* card has been removed */
 #define MMC_STATE_HIGHSPEED_200	(1<<8)		/* card is in HS200 mode */
-#define MMC_STATE_SLEEP		(1<<9)		/* card is in sleep state */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -234,12 +239,9 @@ struct mmc_card {
 #define MMC_QUIRK_BLK_NO_CMD23	(1<<7)		/* Avoid CMD23 for regular multiblock */
 #define MMC_QUIRK_BROKEN_BYTE_MODE_512 (1<<8)	/* Avoid sending 512 bytes in */
 #define MMC_QUIRK_LONG_READ_TIME (1<<9)		/* Data read time > CSD says */
+#define MMC_QUIRK_SANDISK_MLC (1<<30)			/* Check the iNAND MLC */
+#define MMC_QUIRK_MOVINAND_TLC (1<<31)			/* Check the moviNAND TLC */
 						/* byte mode */
-	unsigned int    poweroff_notify_state;	/* eMMC4.5 notify feature */
-#define MMC_NO_POWER_NOTIFICATION	0
-#define MMC_POWERED_ON			1
-#define MMC_POWEROFF_SHORT		2
-#define MMC_POWEROFF_LONG		3
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */
@@ -386,7 +388,6 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_sd_card_uhs(c)	((c)->state & MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 #define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
-#define mmc_card_is_sleep(c)	((c)->state & MMC_STATE_SLEEP)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
@@ -398,9 +399,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_sd_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 #define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
-#define mmc_card_set_sleep(c)	((c)->state |= MMC_STATE_SLEEP)
 
-#define mmc_card_clr_sleep(c)	((c)->state &= ~MMC_STATE_SLEEP)
 /*
  * Quirk add/remove for MMC products.
  */
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index 1b431c72..beb06f40 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -115,8 +115,15 @@ struct mmc_data {
 	struct mmc_command	*stop;		/* stop command */
 	struct mmc_request	*mrq;		/* associated request */
 
+	dma_addr_t		adma_addr;	/* Mapped ADMA descr. table */
+	dma_addr_t		align_addr;	/* Mapped bounce buffer */
+	unsigned int		prepared;	/* data prepared */
+	unsigned int		finished;	/* data finished */
+	u8 *adma_desc;				/* ADMA descriptor table */
+	u8 *align_buffer;			/* Bounce buffer */
 	unsigned int		sg_len;		/* size of scatter list */
 	struct scatterlist	*sg;		/* I/O scatter list */
+	int sg_count;
 	s32			host_cookie;	/* host private data */
 };
 
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0707d228..9d3d60c9 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -11,13 +11,31 @@
 #define LINUX_MMC_HOST_H
 
 #include <linux/leds.h>
+#include <linux/mutex.h>
 #include <linux/sched.h>
 #include <linux/device.h>
 #include <linux/fault-inject.h>
+#include <linux/wakelock.h>
 
 #include <linux/mmc/core.h>
 #include <linux/mmc/pm.h>
 
+#define _MMC_SAFE_ACCESS_
+
+
+enum timing_type {
+	MMC_TIMING_LEGACY = 0, /* 0~25MHz */
+	MMC_TIMING_UHS_SDR12, /* 0~25MHz */
+	MMC_TIMING_MMC_HS, /* 52MHz */
+	MMC_TIMING_SD_HS, /* 50MHz */
+	MMC_TIMING_UHS_SDR25, /* 50MHz */
+	MMC_TIMING_UHS_SDR50,	/* 100MHz */
+	MMC_TIMING_UHS_SDR104, /* 208MHz */
+	MMC_TIMING_UHS_DDR50, /* 50MHz */
+	MMC_TIMING_MMC_HS200, /* 200MHz */
+	MMC_TIMING_MAX,
+};
+
 struct mmc_ios {
 	unsigned int	clock;			/* clock rate */
 	unsigned short	vdd;
@@ -49,16 +67,6 @@ struct mmc_ios {
 
 	unsigned char	timing;			/* timing specification used */
 
-#define MMC_TIMING_LEGACY	0
-#define MMC_TIMING_MMC_HS	1
-#define MMC_TIMING_SD_HS	2
-#define MMC_TIMING_UHS_SDR12	MMC_TIMING_LEGACY
-#define MMC_TIMING_UHS_SDR25	MMC_TIMING_SD_HS
-#define MMC_TIMING_UHS_SDR50	3
-#define MMC_TIMING_UHS_SDR104	4
-#define MMC_TIMING_UHS_DDR50	5
-#define MMC_TIMING_MMC_HS200	6
-
 #define MMC_SDR_MODE		0
 #define MMC_1_2V_DDR_MODE	1
 #define MMC_1_8V_DDR_MODE	2
@@ -70,6 +78,7 @@ struct mmc_ios {
 #define MMC_SIGNAL_VOLTAGE_330	0
 #define MMC_SIGNAL_VOLTAGE_180	1
 #define MMC_SIGNAL_VOLTAGE_120	2
+#define MMC_SIGNAL_VOLTAGE_OFF	3
 
 	unsigned char	drv_type;		/* driver type (A, B, C, D) */
 
@@ -132,7 +141,6 @@ struct mmc_host_ops {
 
 	/* The tuning command opcode value is different for SD and eMMC cards */
 	int	(*execute_tuning)(struct mmc_host *host, u32 opcode);
-	void	(*enable_preset_value)(struct mmc_host *host, bool enable);
 	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv, int card_drv);
 	void	(*hw_reset)(struct mmc_host *host);
 };
@@ -150,11 +158,31 @@ struct mmc_async_req {
 	int (*err_check) (struct mmc_card *, struct mmc_async_req *);
 };
 
-struct mmc_hotplug {
-	unsigned int irq;
+/**
+ * struct mmc_slot - MMC slot functions
+ *
+ * @cd_irq:		MMC/SD-card slot hotplug detection IRQ or -EINVAL
+ * @lock:		protect the @handler_priv pointer
+ * @handler_priv:	MMC/SD-card slot context
+ *
+ * Some MMC/SD host controllers implement slot-functions like card and
+ * write-protect detection natively. However, a large number of controllers
+ * leave these functions to the CPU. This struct provides a hook to attach
+ * such slot-function drivers.
+ */
+struct mmc_slot {
+	int cd_irq;
+	struct mutex lock;
 	void *handler_priv;
 };
 
+struct regulator;
+
+struct mmc_supply {
+	struct regulator *vmmc;		/* Card power supply */
+	struct regulator *vqmmc;	/* Optional Vccq supply */
+};
+
 struct mmc_host {
 	struct device		*parent;
 	struct device		class_dev;
@@ -168,6 +196,9 @@ struct mmc_host {
 	u32			ocr_avail_sd;	/* SD-specific OCR */
 	u32			ocr_avail_mmc;	/* MMC-specific OCR */
 	struct notifier_block	pm_notify;
+	u32			max_current_330;
+	u32			max_current_300;
+	u32			max_current_180;
 
 #define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
 #define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
@@ -211,16 +242,9 @@ struct mmc_host {
 #define MMC_CAP_UHS_SDR50	(1 << 17)	/* Host supports UHS SDR50 mode */
 #define MMC_CAP_UHS_SDR104	(1 << 18)	/* Host supports UHS SDR104 mode */
 #define MMC_CAP_UHS_DDR50	(1 << 19)	/* Host supports UHS DDR50 mode */
-#define MMC_CAP_SET_XPC_330	(1 << 20)	/* Host supports >150mA current at 3.3V */
-#define MMC_CAP_SET_XPC_300	(1 << 21)	/* Host supports >150mA current at 3.0V */
-#define MMC_CAP_SET_XPC_180	(1 << 22)	/* Host supports >150mA current at 1.8V */
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */
-#define MMC_CAP_MAX_CURRENT_200	(1 << 26)	/* Host max current limit is 200mA */
-#define MMC_CAP_MAX_CURRENT_400	(1 << 27)	/* Host max current limit is 400mA */
-#define MMC_CAP_MAX_CURRENT_600	(1 << 28)	/* Host max current limit is 600mA */
-#define MMC_CAP_MAX_CURRENT_800	(1 << 29)	/* Host max current limit is 800mA */
 #define MMC_CAP_CMD23		(1 << 30)	/* CMD23 supported. */
 #define MMC_CAP_HW_RESET	(1 << 31)	/* Hardware reset */
 
@@ -238,12 +262,32 @@ struct mmc_host {
 #define MMC_CAP2_BROKEN_VOLTAGE	(1 << 7)	/* Use the broken voltage */
 #define MMC_CAP2_DETECT_ON_ERR	(1 << 8)	/* On I/O err check card removal */
 #define MMC_CAP2_HC_ERASE_SZ	(1 << 9)	/* High-capacity erase size */
+#define MMC_CAP2_CD_ACTIVE_HIGH	(1 << 10)	/* Card-detect signal active high */
+#define MMC_CAP2_RO_ACTIVE_HIGH	(1 << 11)	/* Write-protect signal active high */
+#define MMC_CAP2_BUS_AUTO_CLK_GATE (1 << 12)	/* host can auto gate bus clk */
+/*
+ * controller could disable card scanning in probe procedure for
+ * some cases, eg, for Marvell 8787 SDIO card in phone system
+ */
+#define MMC_CAP2_DISABLE_PROBE_CDSCAN	(1 << 13)
+
+/*
+ * disable the block devices' pre/post feature
+ * So that the next data transfer will only be perpared/triggered
+ * when previous transfer has been totally finished
+ */
+#define MMC_CAP2_DISABLE_BLK_ASYNC		(1 << 14)
+
+
+/*
+ * disable the block devices' pre/post feature
+ * So that the next data transfer will only be perpared/triggered
+ * when previous transfer has been totally finished
+ */
+#define MMC_CAP2_DISABLE_BLK_ASYNC		(1 << 14)
+#define MMC_CAP2_SECURE_ERASE_EN		(1 << 31)
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
-	unsigned int        power_notify_type;
-#define MMC_HOST_PW_NOTIFY_NONE		0
-#define MMC_HOST_PW_NOTIFY_SHORT	1
-#define MMC_HOST_PW_NOTIFY_LONG		2
 
 #ifdef CONFIG_MMC_CLKGATE
 	int			clk_requests;	/* internal reference counter */
@@ -271,6 +315,7 @@ struct mmc_host {
 
 	struct mmc_ios		ios;		/* current io bus settings */
 	u32			ocr;		/* the current OCR setting */
+	u32			ocr_bak;	/* save current OCR setting */
 
 	/* group bitfields together to minimize padding */
 	unsigned int		use_spi_crc:1;
@@ -289,16 +334,24 @@ struct mmc_host {
 	int			claim_cnt;	/* "claim" nesting count */
 
 	struct delayed_work	detect;
+	void                    *detect_complete;
+	struct wake_lock	detect_wake_lock;
 	int			detect_change;	/* card detect flag */
-	struct mmc_hotplug	hotplug;
+	struct mmc_slot		slot;
 
 	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
 	unsigned int		bus_refs;	/* reference counter */
 
+	unsigned int		bus_resume_flags;
+#define MMC_BUSRESUME_MANUAL_RESUME	(1 << 0)
+#define MMC_BUSRESUME_NEEDS_RESUME	(1 << 1)
+
 	unsigned int		sdio_irqs;
 	struct task_struct	*sdio_irq_thread;
 	bool			sdio_irq_pending;
 	atomic_t		sdio_irq_thread_abort;
+	unsigned int		irq_wakeup;
+	unsigned int		break_suspend;
 
 	mmc_pm_flag_t		pm_flags;	/* requested pm features */
 
@@ -309,6 +362,7 @@ struct mmc_host {
 #ifdef CONFIG_REGULATOR
 	bool			regulator_enabled; /* regulator state */
 #endif
+	struct mmc_supply	supply;
 
 	struct dentry		*debugfs_root;
 
@@ -320,6 +374,15 @@ struct mmc_host {
 
 	unsigned int		actual_clock;	/* Actual HC clock rate */
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	struct {
+		struct sdio_cis			*cis;
+		struct sdio_cccr		*cccr;
+		struct sdio_embedded_func	*funcs;
+		int				num_funcs;
+	} embedded_sdio_data;
+#endif
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 
@@ -328,6 +391,14 @@ extern int mmc_add_host(struct mmc_host *);
 extern void mmc_remove_host(struct mmc_host *);
 extern void mmc_free_host(struct mmc_host *);
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+extern void mmc_set_embedded_sdio_data(struct mmc_host *host,
+				       struct sdio_cis *cis,
+				       struct sdio_cccr *cccr,
+				       struct sdio_embedded_func *funcs,
+				       int num_funcs);
+#endif
+
 static inline void *mmc_priv(struct mmc_host *host)
 {
 	return (void *)host->private;
@@ -338,6 +409,18 @@ static inline void *mmc_priv(struct mmc_host *host)
 #define mmc_dev(x)	((x)->parent)
 #define mmc_classdev(x)	(&(x)->class_dev)
 #define mmc_hostname(x)	(dev_name(&(x)->class_dev))
+#define mmc_bus_needs_resume(host) ((host)->bus_resume_flags & MMC_BUSRESUME_NEEDS_RESUME)
+#define mmc_bus_manual_resume(host) ((host)->bus_resume_flags & MMC_BUSRESUME_MANUAL_RESUME)
+
+static inline void mmc_set_bus_resume_policy(struct mmc_host *host, int manual)
+{
+	if (manual)
+		host->bus_resume_flags |= MMC_BUSRESUME_MANUAL_RESUME;
+	else
+		host->bus_resume_flags &= ~MMC_BUSRESUME_MANUAL_RESUME;
+}
+
+extern int mmc_resume_bus(struct mmc_host *host);
 
 extern int mmc_suspend_host(struct mmc_host *);
 extern int mmc_resume_host(struct mmc_host *);
@@ -349,21 +432,23 @@ extern void mmc_detect_change(struct mmc_host *, unsigned long delay);
 extern void mmc_request_done(struct mmc_host *, struct mmc_request *);
 
 extern int mmc_cache_ctrl(struct mmc_host *, u8);
+extern void mmc_sdio_irq_wakeup(struct mmc_host *host);
 
 static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 {
 	host->ops->enable_sdio_irq(host, 0);
 	host->sdio_irq_pending = true;
+	if (host->irq_wakeup)
+		mmc_sdio_irq_wakeup(host);
 	wake_up_process(host->sdio_irq_thread);
 }
 
-struct regulator;
-
 #ifdef CONFIG_REGULATOR
 int mmc_regulator_get_ocrmask(struct regulator *supply);
 int mmc_regulator_set_ocr(struct mmc_host *mmc,
 			struct regulator *supply,
 			unsigned short vdd_bit);
+int mmc_regulator_get_supply(struct mmc_host *mmc);
 #else
 static inline int mmc_regulator_get_ocrmask(struct regulator *supply)
 {
@@ -376,6 +461,11 @@ static inline int mmc_regulator_set_ocr(struct mmc_host *mmc,
 {
 	return 0;
 }
+
+static inline int mmc_regulator_get_supply(struct mmc_host *mmc)
+{
+	return 0;
+}
 #endif
 
 int mmc_card_awake(struct mmc_host *host);
diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index b822a2cb..4c73000e 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -141,6 +141,9 @@ static inline bool mmc_op_multi(u32 opcode)
 #define R1_SWITCH_ERROR		(1 << 7)	/* sx, c */
 #define R1_APP_CMD		(1 << 5)	/* sr, c */
 
+#define R1_ERROR_BITS	0xFDFF8008	/* all error bits */
+#define R1_CMD13_ERROR_BITS	0xCDF98000	/* all error bits for CMD13 */
+
 #define R1_STATE_IDLE	0
 #define R1_STATE_READY	1
 #define R1_STATE_IDENT	2
@@ -275,6 +278,7 @@ struct _mmc_csd {
 #define EXT_CSD_CACHE_CTRL		33      /* R/W */
 #define EXT_CSD_POWER_OFF_NOTIFICATION	34	/* R/W */
 #define EXT_CSD_DATA_SECTOR_SIZE	61	/* R */
+#define EXT_CSD_VENDOR_SPECIFIC_FIELD   64      /* RO, 64bytes */
 #define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
@@ -318,6 +322,7 @@ struct _mmc_csd {
 #define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
 #define EXT_CSD_TAG_UNIT_SIZE		498	/* RO */
 #define EXT_CSD_DATA_TAG_SUPPORT	499	/* RO */
+#define EXT_CSD_MAX_PACKED_READS	501 /* RO */
 #define EXT_CSD_HPI_FEATURES		503	/* RO */
 
 /*
@@ -354,66 +359,6 @@ struct _mmc_csd {
 #define EXT_CSD_CARD_TYPE_SDR_1_2V	(1<<5)	/* Card can run at 200MHz */
 						/* SDR mode @1.2V I/O */
 
-#define EXT_CSD_CARD_TYPE_SDR_200	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
-					 EXT_CSD_CARD_TYPE_SDR_1_2V)
-
-#define EXT_CSD_CARD_TYPE_SDR_ALL	(EXT_CSD_CARD_TYPE_SDR_200 | \
-					 EXT_CSD_CARD_TYPE_52 | \
-					 EXT_CSD_CARD_TYPE_26)
-
-#define	EXT_CSD_CARD_TYPE_SDR_1_2V_ALL	(EXT_CSD_CARD_TYPE_SDR_1_2V | \
-					 EXT_CSD_CARD_TYPE_52 | \
-					 EXT_CSD_CARD_TYPE_26)
-
-#define	EXT_CSD_CARD_TYPE_SDR_1_8V_ALL	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
-					 EXT_CSD_CARD_TYPE_52 | \
-					 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_1_2V_DDR_1_8V	(EXT_CSD_CARD_TYPE_SDR_1_2V | \
-						 EXT_CSD_CARD_TYPE_DDR_1_8V | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_1_8V_DDR_1_8V	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
-						 EXT_CSD_CARD_TYPE_DDR_1_8V | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_1_2V_DDR_1_2V	(EXT_CSD_CARD_TYPE_SDR_1_2V | \
-						 EXT_CSD_CARD_TYPE_DDR_1_2V | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_1_8V_DDR_1_2V	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
-						 EXT_CSD_CARD_TYPE_DDR_1_2V | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_1_2V_DDR_52	(EXT_CSD_CARD_TYPE_SDR_1_2V | \
-						 EXT_CSD_CARD_TYPE_DDR_52 | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_1_8V_DDR_52	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
-						 EXT_CSD_CARD_TYPE_DDR_52 | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_ALL_DDR_1_8V	(EXT_CSD_CARD_TYPE_SDR_200 | \
-						 EXT_CSD_CARD_TYPE_DDR_1_8V | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_ALL_DDR_1_2V	(EXT_CSD_CARD_TYPE_SDR_200 | \
-						 EXT_CSD_CARD_TYPE_DDR_1_2V | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_ALL_DDR_52	(EXT_CSD_CARD_TYPE_SDR_200 | \
-						 EXT_CSD_CARD_TYPE_DDR_52 | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
 #define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
diff --git a/include/linux/mmc/pm.h b/include/linux/mmc/pm.h
index 4a139204..6e2d6a13 100644
--- a/include/linux/mmc/pm.h
+++ b/include/linux/mmc/pm.h
@@ -26,5 +26,6 @@ typedef unsigned int mmc_pm_flag_t;
 
 #define MMC_PM_KEEP_POWER	(1 << 0)	/* preserve card power during suspend */
 #define MMC_PM_WAKE_SDIO_IRQ	(1 << 1)	/* wake up host system on SDIO IRQ assertion */
+#define MMC_PM_IGNORE_PM_NOTIFY	(1 << 2)	/* ignore mmc pm notify */
 
 #endif /* LINUX_MMC_PM_H */
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index e9051e1c..84e3923c 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -16,6 +16,7 @@
 #include <linux/types.h>
 #include <linux/io.h>
 #include <linux/mmc/host.h>
+#include <linux/slab.h>
 
 struct sdhci_host {
 	/* Data set by hardware interface driver */
@@ -91,13 +92,25 @@ struct sdhci_host {
 	unsigned int quirks2;	/* More deviations from spec. */
 
 #define SDHCI_QUIRK2_HOST_OFF_CARD_ON			(1<<0)
+/* Some SDHCI v3 controller doesn't suppport current limit error*/
+#define SDHCI_QUIRK2_NO_CURRENT_LIMIT                  	(1<<1)
+#define SDHCI_QUIRK2_PRESET_VALUE_BROKEN               	(1<<2)
+/* Controller data timeout counter is 4 times long as spec defined */
+#define SDHCI_QUIRK2_TIMEOUT_DIVIDE_4			(1<<3)
+/* Controller enable HW bus clock gating by default */
+#define SDHCI_QUIRK2_BUS_CLK_GATE_ENABLED		(1<<4)
+/* Controller must disable clock gate by software during CMDs */
+#define SDHCI_QUIRK2_SDIO_SW_CLK_GATE			(1<<5)
+/* After SD host request, prevent system to suspend state for a while */
+#define SDHCI_QUIRK2_HOLDSUSPEND_AFTER_REQUEST		(1<<6)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
 
 	const struct sdhci_ops *ops;	/* Low level hw interface */
 
-	struct regulator *vmmc;	/* Power regulator */
+	struct regulator *vmmc;		/* Power regulator (vmmc) */
+	struct regulator *vqmmc;	/* Signaling regulator (vccq) */
 
 	/* Internal data */
 	struct mmc_host *mmc;	/* MMC structure */
@@ -122,6 +135,7 @@ struct sdhci_host {
 #define SDHCI_PV_ENABLED	(1<<8)	/* Preset value enabled */
 #define SDHCI_SDIO_IRQ_ENABLED	(1<<9)	/* SDIO irq enabled */
 #define SDHCI_HS200_NEEDS_TUNING (1<<10)	/* HS200 needs tuning */
+#define SDHCI_USING_RETUNING_TIMER (1<<11)	/* Host is using a retuning timer for the card */
 
 	unsigned int version;	/* SDHCI spec. version */
 
@@ -136,7 +150,7 @@ struct sdhci_host {
 
 	struct mmc_request *mrq;	/* Current request */
 	struct mmc_command *cmd;	/* Current command */
-	struct mmc_data *data;	/* Current data request */
+	struct mmc_data *data;		/* Current data request */
 	unsigned int data_early:1;	/* Data finished before cmd */
 
 	struct sg_mapping_iter sg_miter;	/* SG state for PIO */
@@ -147,6 +161,8 @@ struct sdhci_host {
 	u8 *adma_desc;		/* ADMA descriptor table */
 	u8 *align_buffer;	/* Bounce buffer */
 
+	struct kmem_cache *adma_cache;
+	struct kmem_cache *align_cache;
 	dma_addr_t adma_addr;	/* Mapped ADMA descr. table */
 	dma_addr_t align_addr;	/* Mapped bounce buffer */
 
@@ -155,7 +171,8 @@ struct sdhci_host {
 
 	struct timer_list timer;	/* Timer for timeouts */
 
-	unsigned int caps;	/* Alternative capabilities */
+	unsigned int caps;	/* Alternative CAPABILITY_0 */
+	unsigned int caps1;	/* Alternative CAPABILITY_1 */
 
 	unsigned int            ocr_avail_sdio;	/* OCR bit masks */
 	unsigned int            ocr_avail_sd;
@@ -166,8 +183,18 @@ struct sdhci_host {
 
 	unsigned int		tuning_count;	/* Timer count for re-tuning */
 	unsigned int		tuning_mode;	/* Re-tuning mode supported by host */
+	unsigned int		power_mode;	/* Contain the current power mode of the host */
 #define SDHCI_TUNING_MODE_1	0
 	struct timer_list	tuning_timer;	/* Timer for tuning */
+	int	constrain_ref;
+
+	/*
+	* New feature: prevent suspend if bus is keepping busy
+	* enabled by "SDHCI_QUIRK_HOLDSUSPEND_AFTER_REQUEST" in the quirks2
+	*/
+	struct wake_lock busbusy_wakelock;
+	int	busbusy_wakelock_en;
+	int	busbusy_timeout;
 
 	unsigned long private[0] ____cacheline_aligned;
 };
diff --git a/include/linux/mmu_notifier.h b/include/linux/mmu_notifier.h
index 1d1b1e13..39bb45cb 100644
--- a/include/linux/mmu_notifier.h
+++ b/include/linux/mmu_notifier.h
@@ -150,7 +150,7 @@ struct mmu_notifier_ops {
  * Therefore notifier chains can only be traversed when either
  *
  * 1. mmap_sem is held.
- * 2. One of the reverse map locks is held (i_mmap_mutex or anon_vma->mutex).
+ * 2. One of the reverse map locks is held (i_mmap_mutex or anon_vma->rwsem).
  * 3. No other concurrent thread can access the list (release)
  */
 struct mmu_notifier {
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index 5f6806bd..6ec1885a 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -35,13 +35,37 @@
  */
 #define PAGE_ALLOC_COSTLY_ORDER 3
 
-#define MIGRATE_UNMOVABLE     0
-#define MIGRATE_RECLAIMABLE   1
-#define MIGRATE_MOVABLE       2
-#define MIGRATE_PCPTYPES      3 /* the number of types on the pcp lists */
-#define MIGRATE_RESERVE       3
-#define MIGRATE_ISOLATE       4 /* can't allocate from here */
-#define MIGRATE_TYPES         5
+enum {
+	MIGRATE_UNMOVABLE,
+	MIGRATE_RECLAIMABLE,
+	MIGRATE_MOVABLE,
+	MIGRATE_PCPTYPES,	/* the number of types on the pcp lists */
+	MIGRATE_RESERVE = MIGRATE_PCPTYPES,
+#ifdef CONFIG_CMA
+	/*
+	 * MIGRATE_CMA migration type is designed to mimic the way
+	 * ZONE_MOVABLE works.  Only movable pages can be allocated
+	 * from MIGRATE_CMA pageblocks and page allocator never
+	 * implicitly change migration type of MIGRATE_CMA pageblock.
+	 *
+	 * The way to use it is to change migratetype of a range of
+	 * pageblocks to MIGRATE_CMA which can be done by
+	 * __free_pageblock_cma() function.  What is important though
+	 * is that a range of pageblocks must be aligned to
+	 * MAX_ORDER_NR_PAGES should biggest page be bigger then
+	 * a single pageblock.
+	 */
+	MIGRATE_CMA,
+#endif
+	MIGRATE_ISOLATE,	/* can't allocate from here */
+	MIGRATE_TYPES
+};
+
+#ifdef CONFIG_CMA
+#  define is_migrate_cma(migratetype) unlikely((migratetype) == MIGRATE_CMA)
+#else
+#  define is_migrate_cma(migratetype) false
+#endif
 
 #define for_each_migratetype_order(order, type) \
 	for (order = 0; order < MAX_ORDER; order++) \
@@ -116,6 +140,7 @@ enum zone_stat_item {
 	NUMA_OTHER,		/* allocation from other node */
 #endif
 	NR_ANON_TRANSPARENT_HUGEPAGES,
+	NR_FREE_CMA_PAGES,
 	NR_VM_ZONE_STAT_ITEMS };
 
 /*
@@ -179,6 +204,8 @@ struct lruvec {
 #define ISOLATE_UNMAPPED	((__force isolate_mode_t)0x8)
 /* Isolate for asynchronous migration */
 #define ISOLATE_ASYNC_MIGRATE	((__force isolate_mode_t)0x10)
+/* Isolate unevictable pages */
+#define ISOLATE_UNEVICTABLE	((__force isolate_mode_t)0x20)
 
 /* LRU Isolation modes. */
 typedef unsigned __bitwise__ isolate_mode_t;
@@ -342,7 +369,6 @@ struct zone {
 	 * free areas of different sizes
 	 */
 	spinlock_t		lock;
-	int                     all_unreclaimable; /* All pages pinned */
 #ifdef CONFIG_MEMORY_HOTPLUG
 	/* see spanned/present_pages for more description */
 	seqlock_t		span_seqlock;
@@ -687,7 +713,7 @@ typedef struct pglist_data {
 #include <linux/memory_hotplug.h>
 
 extern struct mutex zonelists_mutex;
-void build_all_zonelists(void *data);
+void build_all_zonelists(pg_data_t *pgdat, struct zone *zone);
 void wakeup_kswapd(struct zone *zone, int order, enum zone_type classzone_idx);
 bool zone_watermark_ok(struct zone *z, int order, unsigned long mark,
 		int classzone_idx, int alloc_flags);
@@ -733,6 +759,8 @@ static inline int zone_movable_is_highmem(void)
 {
 #if defined(CONFIG_HIGHMEM) && defined(CONFIG_HAVE_MEMBLOCK_NODE)
 	return movable_zone == ZONE_HIGHMEM;
+#elif defined(CONFIG_MEMORY_FORCE_MOVABLE_HIGHMEM)
+	return 1;
 #else
 	return 0;
 #endif
diff --git a/include/linux/mpu.h b/include/linux/mpu.h
new file mode 100644
index 00000000..643cba98
--- /dev/null
+++ b/include/linux/mpu.h
@@ -0,0 +1,110 @@
+/*
+* Copyright (C) 2012 Invensense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+*/
+
+/**
+ *  @addtogroup  DRIVERS
+ *  @brief       Hardware drivers.
+ *
+ *  @{
+ *      @file    mpu.h
+ *      @brief   mpu definition
+ */
+
+#ifndef __MPU_H_
+#define __MPU_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#endif
+
+enum secondary_slave_type {
+	SECONDARY_SLAVE_TYPE_NONE,
+	SECONDARY_SLAVE_TYPE_ACCEL,
+	SECONDARY_SLAVE_TYPE_COMPASS,
+	SECONDARY_SLAVE_TYPE_PRESSURE,
+
+	SECONDARY_SLAVE_TYPE_TYPES
+};
+
+enum ext_slave_id {
+	ID_INVALID = 0,
+	GYRO_ID_MPU3050,
+	GYRO_ID_MPU6050A2,
+	GYRO_ID_MPU6050B1,
+	GYRO_ID_MPU6050B1_NO_ACCEL,
+	GYRO_ID_ITG3500,
+
+	ACCEL_ID_LIS331,
+	ACCEL_ID_LSM303DLX,
+	ACCEL_ID_LIS3DH,
+	ACCEL_ID_KXSD9,
+	ACCEL_ID_KXTF9,
+	ACCEL_ID_BMA150,
+	ACCEL_ID_BMA222,
+	ACCEL_ID_BMA250,
+	ACCEL_ID_ADXL34X,
+	ACCEL_ID_MMA8450,
+	ACCEL_ID_MMA845X,
+	ACCEL_ID_MPU6050,
+
+	COMPASS_ID_AK8963,
+	COMPASS_ID_AK8975,
+	COMPASS_ID_AK8972,
+	COMPASS_ID_AMI30X,
+	COMPASS_ID_AMI306,
+	COMPASS_ID_YAS529,
+	COMPASS_ID_YAS530,
+	COMPASS_ID_HMC5883,
+	COMPASS_ID_LSM303DLH,
+	COMPASS_ID_LSM303DLM,
+	COMPASS_ID_MMC314X,
+	COMPASS_ID_MMC328X,
+	COMPASS_ID_HSCDTD002B,
+	COMPASS_ID_HSCDTD004A,
+
+	PRESSURE_ID_BMA085,
+};
+
+#define INV_PROD_KEY(ver, rev) (ver * 100 + rev)
+/**
+ * struct mpu_platform_data - Platform data for the mpu driver
+ * @int_config:		Bits [7:3] of the int config register.
+ * @level_shifter:	0: VLogic, 1: VDD
+ * @orientation:	Orientation matrix of the gyroscope
+ * @sec_slave_type:     secondary slave device type, can be compass, accel, etc
+ * @sec_slave_id:       id of the secondary slave device
+ * @secondary_i2c_address: secondary device's i2c address
+ * @secondary_orientation: secondary device's orientation matrix
+ * @key:                key for MPL library.
+ *
+ * Contains platform specific information on how to configure the MPU3050 to
+ * work on this platform.  The orientation matricies are 3x3 rotation matricies
+ * that are applied to the data to rotate from the mounting orientation to the
+ * platform orientation.  The values must be one of 0, 1, or -1 and each row and
+ * column should have exactly 1 non-zero value.
+ */
+struct mpu_platform_data {
+	__u8 int_config;
+	__u8 level_shifter;
+	__s8 orientation[9];
+	enum secondary_slave_type sec_slave_type;
+	enum ext_slave_id sec_slave_id;
+	__u16 secondary_i2c_addr;
+	__s8 secondary_orientation[9];
+	__u8 key[16];
+	int (*set_power) (int);
+};
+
+#endif	/* __MPU_H_ */
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index cf5ea8cd..516a52f1 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -237,6 +237,7 @@ struct mtd_info {
 	int subpage_sft;
 
 	void *priv;
+	void *bbm;
 
 	struct module *owner;
 	struct device dev;
diff --git a/include/linux/mvisp.h b/include/linux/mvisp.h
new file mode 100644
index 00000000..a20dcbd3
--- /dev/null
+++ b/include/linux/mvisp.h
@@ -0,0 +1,311 @@
+/*
+ * mvisp.h
+ *
+ * Marvell DxO ISP - DMA module
+ *
+ * Copyright:  (C) Copyright 2011 Marvell International Ltd.
+ *              Henry Zhao <xzhao10@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+
+#ifndef ISP_USER_H
+#define ISP_USER_H
+
+#include <linux/videodev2.h>
+#include <linux/types.h>
+#ifdef CONFIG_VIDEO_MRVL_CAM_DEBUG
+#include <media/mc_debug.h>
+#endif
+
+struct v4l2_dxoipc_set_fb {
+	void	*virAddr[4];
+	int		phyAddr[4];
+	int		size[4];
+	int		fbcnt;
+	int		burst_read;
+	int		burst_write;
+	int		flush_fifo_by_timer;
+};
+
+struct v4l2_ispdma_timeinfo {
+	unsigned long sec;
+	unsigned long usec;
+};
+
+struct v4l2_dxoipc_ipcwait {
+	int				timeout;
+	struct v4l2_ispdma_timeinfo tickinfo;
+};
+
+struct v4l2_dxoipc_streaming_config {
+	int		enable_in;
+	int		enable_disp;
+	int		enable_codec;
+	int		enable_fbrx;
+	int		enable_fbtx;
+};
+
+struct v4l2_dxoipc_config_codec {
+	int		vbnum;
+	int		vbsize;
+	int		dma_burst_size;
+};
+
+struct v4l2_sensor_get_driver_name {
+	char	driver[16];
+};
+
+struct v4l2_sensor_register_access {
+	unsigned long	reg;
+	unsigned long	value;
+};
+
+struct v4l2_sensor_list_regs_access {
+	struct v4l2_sensor_register_access *regs;
+	int continuous;
+	int num;
+};
+
+/*Normal: */
+/* 1. Dummy buffer will reuse filled buffer.*/
+/* 2. Driver will hold one buffer in queue serve as dummy buffer.*/
+/*Still: */
+/* 1. Dummy buffer will only use idle buffer.*/
+/* 2. Driver will not hold any buffer in queue.*/
+enum ispvideo_capture_mode {
+	ISPVIDEO_NORMAL_CAPTURE = 0,
+	ISPVIDEO_STILL_CAPTURE,
+};
+
+enum ispdma_port {
+	ISPDMA_PORT_CODEC = 0,
+	ISPDMA_PORT_DISPLAY,
+	ISPDMA_PORT_FBRX,
+	ISPDMA_PORT_FBTX,
+	ISPDMA_PORT_INPUT,
+};
+
+struct v4l2_ispdma_capture_mode {
+	enum ispdma_port port;
+	enum ispvideo_capture_mode mode;
+};
+
+struct v4l2_ispdma_reset {
+	unsigned long	param;
+};
+
+struct v4l2_ccic_config_mipi {
+	int lanes;
+};
+
+struct v4l2_ccic_dump_registers {
+	unsigned long y0_base_addr;
+	unsigned long y1_base_addr;
+	unsigned long y2_base_addr;
+	unsigned long irq_raw_status;
+	unsigned long irq_status;
+	unsigned long irq_mask;
+	unsigned long ctrl_0;
+	unsigned long ctrl_1;
+	unsigned long clock_ctrl;
+	unsigned long csi2_irq_raw_status;
+	unsigned long csi2_dphy3;
+	unsigned long csi2_dphy5;
+	unsigned long csi2_dphy6;
+	unsigned long img_size;
+	unsigned long img_pitch;
+};
+
+struct v4l2_ispdma_dump_registers {
+	unsigned long ispdma_mainctrl;
+	unsigned long ispdma_dmaena;
+	unsigned long ispdma_clkena;
+	unsigned long ispdma_irqraw;
+	unsigned long ispdma_irqmask;
+	unsigned long ispdma_irqstat;
+	unsigned long ispdma_insz;
+	unsigned long ispdma_inpsdma_ctrl;
+	unsigned long ispdma_fbtx0_sdca;
+	unsigned long ispdma_fbtx0_dcsz;
+	unsigned long ispdma_fbtx0_ctrl;
+	unsigned long ispdma_fbtx0_dstsz;
+	unsigned long ispdma_fbtx0_dstaddr;
+	unsigned long ispdma_fbtx0_tmr;
+	unsigned long ispdma_fbtx0_ramctrl;
+	unsigned long ispdma_fbrx0_sdca;
+	unsigned long ispdma_fbrx0_dcsz;
+	unsigned long ispdma_fbrx0_ctrl;
+	unsigned long ispdma_fbrx0_tmr;
+	unsigned long ispdma_fbrx0_ramctrl;
+	unsigned long ispdma_fbrx0_stat;
+	unsigned long ispdma_fbtx1_sdca;
+	unsigned long ispdma_fbtx1_dcsz;
+	unsigned long ispdma_fbtx1_ctrl;
+	unsigned long ispdma_fbtx1_dstsz;
+	unsigned long ispdma_fbtx1_dstaddr;
+	unsigned long ispdma_fbtx1_tmr;
+	unsigned long ispdma_fbtx1_ramctrl;
+	unsigned long ispdma_fbrx1_sdca;
+	unsigned long ispdma_fbrx1_dcsz;
+	unsigned long ispdma_fbrx1_ctrl;
+	unsigned long ispdma_fbrx1_tmr;
+	unsigned long ispdma_fbrx1_ramctrl;
+	unsigned long ispdma_fbrx1_stat;
+	unsigned long ispdma_fbtx2_sdca;
+	unsigned long ispdma_fbtx2_dcsz;
+	unsigned long ispdma_fbtx2_ctrl;
+	unsigned long ispdma_fbtx2_dstsz;
+	unsigned long ispdma_fbtx2_dstaddr;
+	unsigned long ispdma_fbtx2_tmr;
+	unsigned long ispdma_fbtx2_ramctrl;
+	unsigned long ispdma_fbrx2_sdca;
+	unsigned long ispdma_fbrx2_dcsz;
+	unsigned long ispdma_fbrx2_ctrl;
+	unsigned long ispdma_fbrx2_tmr;
+	unsigned long ispdma_fbrx2_ramctrl;
+	unsigned long ispdma_fbrx2_stat;
+	unsigned long ispdma_fbtx3_sdca;
+	unsigned long ispdma_fbtx3_dcsz;
+	unsigned long ispdma_fbtx3_ctrl;
+	unsigned long ispdma_fbtx3_dstsz;
+	unsigned long ispdma_fbtx3_dstaddr;
+	unsigned long ispdma_fbtx3_tmr;
+	unsigned long ispdma_fbtx3_ramctrl;
+	unsigned long ispdma_fbrx3_sdca;
+	unsigned long ispdma_fbrx3_dcsz;
+	unsigned long ispdma_fbrx3_ctrl;
+	unsigned long ispdma_fbrx3_tmr;
+	unsigned long ispdma_fbrx3_ramctrl;
+	unsigned long ispdma_fbrx3_stat;
+	unsigned long ispdma_disp_ctrl;
+	unsigned long ispdma_disp_dstsz;
+	unsigned long ispdma_disp_dstaddr;
+	unsigned long ispdma_disp_ramctrl;
+	unsigned long ispdma_disp_pitch;
+	unsigned long ispdma_codec_ctrl;
+	unsigned long ispdma_codec_dstsz;
+	unsigned long ispdma_codec_dstaddr;
+	unsigned long ispdma_codec_ramctrl;
+	unsigned long ispdma_codec_stat;
+	unsigned long ispdma_codec_pitch;
+	unsigned long ispdma_codec_vbsz;
+	unsigned long ispdma_inpsdma_srcaddr;
+	unsigned long ispdma_inpsdma_srcsz;
+	unsigned long ispdma_inpsdma_pixsz;
+	unsigned long isp_irqraw;
+	unsigned long isp_irqmask;
+	unsigned long isp_irqstat;
+};
+
+struct v4l2_ispdma_dma_timeinfo {
+	struct v4l2_ispdma_timeinfo disp_dma_timeinfo;
+	struct v4l2_ispdma_timeinfo disp_ps_timeinfo;
+	struct v4l2_ispdma_timeinfo codec_dma_timeinfo;
+	struct v4l2_ispdma_timeinfo codec_ps_timeinfo;
+};
+
+struct v4l2_csi_dphy_desc {
+/*not set it when set clk_freq*/
+	unsigned int clk_mul;
+/*not set it wneh set clk_freq
+ * clk_freq = mclk * clk_mul / clk_div*/
+	unsigned int clk_div;
+/*must set, which is mipi_bit_clk / 2, unit is hz*/
+	unsigned int clk_freq;
+	unsigned int cl_prepare;	/*for dphy*/
+	unsigned int cl_zero;		/*for dphy*/
+/*for dphy, when sesnor_set_dphy is 1, must set it*/
+	unsigned int hs_prepare;
+/*for dphy, when sesnor_set_dphy is 1, must set it*/
+	unsigned int hs_zero;
+	unsigned int nr_lane;		/*must set*/
+};
+
+struct v4l2_sensor_csi_dphy {
+	int sensor_set_dphy;	/*set it 1, when set hs_prepare
+				*hs_zero, then driver use them to dphy*/
+	struct v4l2_csi_dphy_desc dphy_desc;
+};
+
+#define CLK_RATE_NUM 6
+enum isp_fclk_ops {
+	GET_CURR_CLK,
+	GET_AVAILABLE_CLK,
+	SET_CLK,
+};
+
+struct v4l2_ispdma_isp_func_clk {
+	enum isp_fclk_ops ops;
+	unsigned int fclk_mhz;
+	unsigned int avail_clk_rate[CLK_RATE_NUM];	/*Mhz*/
+	unsigned int avail_clk_rate_num;
+
+};
+
+#ifdef CONFIG_VIDEO_MRVL_CAM_DEBUG
+struct mvisp_mcd {
+	struct mcd		mcd;
+	struct mcd_entity	*pitem[MCD_ENTITY_END];
+};
+#endif /* CONFIG_VIDEO_MRVL_CAM_DEBUG */
+
+#define VIDIOC_PRIVATE_DXOIPC_SET_FB \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 1, struct v4l2_dxoipc_set_fb)
+#define VIDIOC_PRIVATE_DXOIPC_WAIT_IPC \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 2, struct v4l2_dxoipc_ipcwait)
+#define VIDIOC_PRIVATE_DXOIPC_SET_STREAM \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 3, struct v4l2_dxoipc_streaming_config)
+#define VIDIOC_PRIVATE_SENSER_GET_DRIVER_NAME \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 4, struct v4l2_sensor_get_driver_name)
+#define VIDIOC_PRIVATE_SENSER_REGISTER_SET \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 5, struct v4l2_sensor_register_access)
+#define VIDIOC_PRIVATE_SENSER_REGISTER_GET \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 6, struct v4l2_sensor_register_access)
+#define VIDIOC_PRIVATE_DXOIPC_CONFIG_CODEC \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 7, struct v4l2_dxoipc_config_codec)
+#define VIDIOC_PRIVATE_ISPDMA_CAPTURE_MODE \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 8, struct v4l2_ispdma_capture_mode)
+#define VIDIOC_PRIVATE_ISPDMA_RESET \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 9, struct v4l2_ispdma_reset)
+#define VIDIOC_PRIVATE_ISPDMA_GETDELTA \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 10, struct v4l2_ispdma_timeinfo)
+#define VIDIOC_PRIVATE_CCIC_CONFIG_MIPI \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 11, struct v4l2_ccic_config_mipi)
+#define VIDIOC_PRIVATE_CCIC_DUMP_REGISTERS \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 12, struct v4l2_ccic_dump_registers)
+#define VIDIOC_PRIVATE_ISPDMA_DUMP_REGISTERS \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 13, struct v4l2_ispdma_dump_registers)
+#define VIDIOC_PRIVATE_ISPDMA_GET_DMA_TIMEINFO \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 14, struct v4l2_ispdma_dma_timeinfo)
+#define VIDIOC_PRIVATE_CCIC_SET_STREAM \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 15, int)
+#define VIDIOC_PRIVATE_ISPDMA_SET_STREAM \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 16, int)
+#define VIDIOC_PRIVATE_ISPDMA_ISP_FUNC_CLK_OPS\
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 17, struct v4l2_ispdma_isp_func_clk)
+#define VIDIOC_PRIVATE_CCIC_GET_SENSOR_MCLK\
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 18, int)
+#define VIDIOC_PRIVATE_SENSER_REGS_LIST_SET \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 19, \
+					struct v4l2_sensor_list_regs_access)
+#define VIDIOC_PRIVATE_ISPDMA_LCD_DMA_OPS\
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 20, int)
+#define VIDIOC_PRIVATE_DXOIPC_SET_FB_DC \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 21, struct v4l2_dxoipc_set_fb)
+#define VIDIOC_PRIVATE_SENSER_SET_CSI_DPHY \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 22, struct v4l2_sensor_csi_dphy)
+#endif	/* ISP_USER_H */
diff --git a/include/linux/namei.h b/include/linux/namei.h
index ffc02135..c2670768 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -65,6 +65,9 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_JUMPED		0x1000
 #define LOOKUP_ROOT		0x2000
 #define LOOKUP_EMPTY		0x4000
+#ifdef CONFIG_SDCARD_FS_CI_SEARCH
+#define LOOKUP_CASE_INSENSITIVE	0x8000
+#endif
 
 extern int user_path_at(int, const char __user *, unsigned, struct path *);
 extern int user_path_at_empty(int, const char __user *, unsigned, struct path *, int *empty);
diff --git a/include/linux/page-isolation.h b/include/linux/page-isolation.h
index 051c1b1e..ca72160f 100644
--- a/include/linux/page-isolation.h
+++ b/include/linux/page-isolation.h
@@ -1,9 +1,13 @@
 #ifndef __LINUX_PAGEISOLATION_H
 #define __LINUX_PAGEISOLATION_H
 
+int move_freepages(struct zone *zone,
+			struct page *start_page, struct page *end_page,
+			int migratetype);
+
 /*
  * Changes migrate type in [start_pfn, end_pfn) to be MIGRATE_ISOLATE.
- * If specified range includes migrate types other than MOVABLE,
+ * If specified range includes migrate types other than MOVABLE or CMA,
  * this will fail with -EBUSY.
  *
  * For isolating all pages in the range finally, the caller have to
@@ -11,27 +15,27 @@
  * test it.
  */
 extern int
-start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn);
+start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,
+			 unsigned migratetype);
 
 /*
  * Changes MIGRATE_ISOLATE to MIGRATE_MOVABLE.
  * target range is [start_pfn, end_pfn)
  */
 extern int
-undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn);
+undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,
+			unsigned migratetype);
 
 /*
- * test all pages in [start_pfn, end_pfn)are isolated or not.
+ * Test all pages in [start_pfn, end_pfn) are isolated or not.
  */
-extern int
-test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn);
+int test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn);
 
 /*
- * Internal funcs.Changes pageblock's migrate type.
- * Please use make_pagetype_isolated()/make_pagetype_movable().
+ * Internal functions. Changes pageblock's migrate type.
  */
 extern int set_migratetype_isolate(struct page *page);
-extern void unset_migratetype_isolate(struct page *page);
+extern void unset_migratetype_isolate(struct page *page, unsigned migratetype);
 
 
 #endif
diff --git a/include/linux/persistent_ram.h b/include/linux/persistent_ram.h
new file mode 100644
index 00000000..22422171
--- /dev/null
+++ b/include/linux/persistent_ram.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __LINUX_PERSISTENT_RAM_H__
+#define __LINUX_PERSISTENT_RAM_H__
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/types.h>
+
+struct persistent_ram_buffer;
+
+struct persistent_ram_descriptor {
+	const char	*name;
+	phys_addr_t	size;
+};
+
+struct persistent_ram {
+	phys_addr_t	start;
+	phys_addr_t	size;
+
+	int ecc_block_size;
+	int ecc_size;
+	int ecc_symsize;
+	int ecc_poly;
+
+	int					num_descs;
+	struct persistent_ram_descriptor	*descs;
+
+	struct list_head node;
+};
+
+struct persistent_ram_zone {
+	struct list_head node;
+	void *vaddr;
+	struct persistent_ram_buffer *buffer;
+	size_t buffer_size;
+
+	/* ECC correction */
+	bool ecc;
+	char *par_buffer;
+	char *par_header;
+	struct rs_control *rs_decoder;
+	int corrected_bytes;
+	int bad_blocks;
+	int ecc_block_size;
+	int ecc_size;
+	int ecc_symsize;
+	int ecc_poly;
+
+	char *old_log;
+	size_t old_log_size;
+	size_t old_log_footer_size;
+	bool early;
+};
+
+int persistent_ram_early_init(struct persistent_ram *ram);
+
+struct persistent_ram_zone *persistent_ram_init_ringbuffer(struct device *dev,
+		bool ecc);
+
+int persistent_ram_write(struct persistent_ram_zone *prz, const void *s,
+	unsigned int count);
+
+size_t persistent_ram_old_size(struct persistent_ram_zone *prz);
+void *persistent_ram_old(struct persistent_ram_zone *prz);
+void persistent_ram_free_old(struct persistent_ram_zone *prz);
+ssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,
+	char *str, size_t len);
+
+#endif
diff --git a/include/linux/platform_data/mmp_audio.h b/include/linux/platform_data/mmp_audio.h
new file mode 100644
index 00000000..0f25d165
--- /dev/null
+++ b/include/linux/platform_data/mmp_audio.h
@@ -0,0 +1,22 @@
+/*
+ *  MMP Platform AUDIO Management
+ *
+ *  Copyright (c) 2011 Marvell Semiconductors Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#ifndef MMP_AUDIO_H
+#define MMP_AUDIO_H
+
+struct mmp_audio_platdata {
+	u32 period_max_capture;
+	u32 buffer_max_capture;
+	u32 period_max_playback;
+	u32 buffer_max_playback;
+};
+
+#endif /* MMP_AUDIO_H */
diff --git a/include/linux/platform_data/mv_usb.h b/include/linux/platform_data/mv_usb.h
index d94804ac..86e6df61 100644
--- a/include/linux/platform_data/mv_usb.h
+++ b/include/linux/platform_data/mv_usb.h
@@ -10,6 +10,8 @@
 #ifndef __MV_PLATFORM_USB_H
 #define __MV_PLATFORM_USB_H
 
+#include <linux/notifier.h>
+
 enum pxa_ehci_type {
 	EHCI_UNDEFINED = 0,
 	PXA_U2OEHCI,	/* pxa 168, 9xx */
@@ -18,9 +20,17 @@ enum pxa_ehci_type {
 	MMP3_FSIC,	/* mmp3 fsic */
 };
 
+enum usb_port_speed {
+	USB_PORT_SPEED_FULL = 0,	/* full speed: 0x0 */
+	USB_PORT_SPEED_LOW,		/* low speed: 0x1 */
+	USB_PORT_SPEED_HIGH,		/* high speed: 0x2 */
+	USB_PORT_SPEED_UNKNOWN,		/* unknown speed: 0x3 */
+};
+
 enum {
 	MV_USB_MODE_OTG,
 	MV_USB_MODE_HOST,
+	MV_USB_MODE_DEVICE,
 };
 
 enum {
@@ -28,16 +38,99 @@ enum {
 	VBUS_HIGH	= 1 << 0,
 };
 
-struct mv_usb_addon_irq {
-	unsigned int	irq;
-	int		(*poll)(void);
+enum charger_type {
+	NULL_CHARGER	= 0,
+	DEFAULT_CHARGER,
+	VBUS_CHARGER,
+	AC_CHARGER_STANDARD,
+	AC_CHARGER_OTHER,
+};
+
+/* for usb middle layer support */
+enum {
+	PXA_USB_DEV_OTG,
+	PXA_USB_DEV_SPH1,
+	PXA_USB_DEV_SPH2,
+	PXA_USB_DEV_SPH3,
+	PXA_USB_DEV_MAX,
+};
+
+enum {
+	EVENT_VBUS,
+	EVENT_ID,
+};
+
+struct pxa_usb_vbus_ops {
+	int (*get_vbus)(unsigned int *level);
+	int (*set_vbus)(unsigned int level);
+	int (*init)(void);
+};
+
+struct pxa_usb_idpin_ops {
+	int (*get_idpin)(unsigned int *level);
+	int (*init)(void);
+};
+
+struct pxa_usb_extern_ops {
+	struct pxa_usb_vbus_ops		vbus;
+	struct pxa_usb_idpin_ops	idpin;
 };
 
+#define pxa_usb_has_extern_call(id, o, f, arg...)	( \
+{ \
+	struct pxa_usb_extern_ops *ops;			\
+	int ret;					\
+	ops  = pxa_usb_get_extern_ops(id);		\
+	ret = (!ops ? 0 : ((ops->o.f) ?			\
+		1 : 0));				\
+	ret;						\
+} \
+)
+
+#define pxa_usb_extern_call(id, o, f, args...)	( \
+{ \
+	struct pxa_usb_extern_ops *ops;			\
+	int ret;					\
+	ops  = pxa_usb_get_extern_ops(id);		\
+	ret = (!ops ? -ENODEV : ((ops->o.f) ?		\
+		ops->o.f(args) : -ENOIOCTLCMD));	\
+	ret;						\
+} \
+)
+
+#define pxa_usb_set_extern_call(id, o, f, p) ( \
+{ \
+	struct pxa_usb_extern_ops *ops;		\
+	int ret;				\
+	ops = pxa_usb_get_extern_ops(id);	\
+	ret = !ops ? -ENODEV : ((ops->o.f) ?	\
+		-EINVAL : ({ops->o.f = p; 0; }));\
+	ret;					\
+} \
+)
+
+extern struct pxa_usb_extern_ops *pxa_usb_get_extern_ops(unsigned int id);
+extern int pxa_usb_register_notifier(unsigned int id,
+					struct notifier_block *nb);
+extern int pxa_usb_unregister_notifier(unsigned int id,
+					struct notifier_block *nb);
+extern int pxa_usb_notify(unsigned int id, unsigned long val, void *v);
+/* end of usb middle layer support */
+
+extern int mv_udc_register_client(struct notifier_block *nb);
+extern int mv_udc_unregister_client(struct notifier_block *nb);
+
+#define MV_USB_HAS_VBUS_DETECTION	(1 << 0)
+#define MV_USB_HAS_IDPIN_DETECTION	(1 << 1)
 struct mv_usb_platform_data {
 	unsigned int		clknum;
 	char			**clkname;
-	struct mv_usb_addon_irq	*id;	/* Only valid for OTG. ID pin change*/
-	struct mv_usb_addon_irq	*vbus;	/* valid for OTG/UDC. VBUS change*/
+	/*
+	 * select from PXA_USB_DEV_OTG to PXA_USB_DEV_MAX.
+	 * It indicates the index of usb device.
+	 */
+	unsigned int		id;
+	unsigned int		extern_attr;
 
 	/* only valid for HCD. OTG or Host only*/
 	unsigned int		mode;
@@ -49,7 +142,6 @@ struct mv_usb_platform_data {
 
 	int	(*phy_init)(void __iomem *regbase);
 	void	(*phy_deinit)(void __iomem *regbase);
-	int	(*set_vbus)(unsigned int vbus);
 	int     (*private_init)(void __iomem *opregs, void __iomem *phyregs);
 };
 
diff --git a/include/linux/platform_data/pxa_sdhci.h b/include/linux/platform_data/pxa_sdhci.h
index 51ad0995..7814d54c 100644
--- a/include/linux/platform_data/pxa_sdhci.h
+++ b/include/linux/platform_data/pxa_sdhci.h
@@ -14,6 +14,45 @@
 #ifndef _PXA_SDHCI_H_
 #define _PXA_SDHCI_H_
 
+#include <linux/pm_qos.h>
+
+enum cd_types {
+	PXA_SDHCI_CD_HOST,	/* use mmc internal CD line */
+	PXA_SDHCI_CD_EXTERNAL,	/* use external callback */
+	PXA_SDHCI_CD_GPIO,	/* use external gpio pin for CD line */
+	PXA_SDHCI_CD_NONE,	/* no CD line, use polling to detect card */
+	PXA_SDHCI_CD_PERMANENT,	/* no CD line, card permanently wired to host */
+};
+
+/*
+ * sdhci_pxa_dtr_data: sdhc data transfer rate table
+ * @timing: the specification used timing
+ * @preset_rate: the clock could set by the SOC
+ * @src_rate: send to the clock subsystem
+ *            related to APMU on SOC
+ * @tx_delay: use DDLL to delay clock waveform
+ */
+struct sdhci_pxa_dtr_data {
+	unsigned char timing;
+	unsigned long preset_rate;
+	unsigned int tx_delay;
+/*
+ * PXA platform special preset/src clock rate
+ * use to preset the MMC defined clock rate
+ */
+#define PXA_SDH_DTR_25M 25000000
+#define PXA_SDH_DTR_26M 26000000
+#define PXA_SDH_DTR_45M 45000000
+#define PXA_SDH_DTR_52M 52000000
+#define PXA_SDH_DTR_89M 89142857
+#define PXA_SDH_DTR_104M 104000000
+#define PXA_SDH_DTR_156M 156000000
+#define PXA_SDH_DTR_208M 208000000
+#define PXA_SDH_DTR_416M 416000000
+#define PXA_SDH_DTR_624M 624000000
+#define PXA_SDH_DTR_PS_NONE -1
+	unsigned long src_rate;
+};
 /* pxa specific flag */
 /* Require clock free running */
 #define PXA_FLAG_ENABLE_CLOCK_GATING (1<<0)
@@ -21,6 +60,16 @@
 #define PXA_FLAG_CARD_PERMANENT	(1<<1)
 /* Board design supports 8-bit data on SD/SDIO BUS */
 #define PXA_FLAG_SD_8_BIT_CAPABLE_SLOT (1<<2)
+/* SDIO device/SD Card detect wakeup host sleep feature */
+#define PXA_FLAG_WAKEUP_HOST (1<<3)
+/* disable card scanning in probe procedure */
+#define PXA_FLAG_DISABLE_PROBE_CDSCAN (1<<4)
+/* whether supports RPM in driver, it can used for source clock gating */
+#define PXA_FLAG_EN_PM_RUNTIME (1<<5)
+/* whether Tx configure support bus clock as internal clock */
+#define PXA_FLAG_TX_SEL_BUS_CLK (1<<6)
+/* whether Rx configure Reg is changed, like pxa988, 1088 */
+#define PXA_FLAG_NEW_RX_CFG_REG (1<<7)
 
 /*
  * struct pxa_sdhci_platdata() - Platform device data for PXA SDHCI
@@ -38,7 +87,9 @@
  * @max_speed: the maximum speed supported
  * @host_caps: Standard MMC host capabilities bit field.
  * @quirks: quirks of platfrom
+ * @quirks2: quirks of platfrom
  * @pm_caps: pm_caps of platfrom
+ * @signal_vol_change: signaling voltage change
  */
 struct sdhci_pxa_platdata {
 	unsigned int	flags;
@@ -46,11 +97,23 @@ struct sdhci_pxa_platdata {
 	unsigned int	clk_delay_sel;
 	bool		clk_delay_enable;
 	unsigned int	ext_cd_gpio;
+	enum cd_types	cd_type;
 	bool		ext_cd_gpio_invert;
 	unsigned int	max_speed;
 	unsigned int	host_caps;
+	unsigned int	host_caps2;
+	unsigned int    host_caps_disable;
 	unsigned int	quirks;
+	unsigned int	quirks2;
 	unsigned int	pm_caps;
+	void	(*signal_vol_change)(unsigned int set);
+	void (*clear_wakeup_event)(void);
+#ifdef CONFIG_SD8XXX_RFKILL
+	/* for sd8xxx-rfkill device */
+	struct mmc_host **pmmc;
+#endif
+	struct  pm_qos_request	qos_idle;
+	struct sdhci_pxa_dtr_data *dtr_data;
 };
 
 struct sdhci_pxa {
diff --git a/include/linux/pm.h b/include/linux/pm.h
index 715305e0..f067e60a 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -544,8 +544,6 @@ struct dev_pm_info {
 	unsigned long		active_jiffies;
 	unsigned long		suspended_jiffies;
 	unsigned long		accounting_timestamp;
-	ktime_t			suspend_time;
-	s64			max_time_suspended_ns;
 	struct dev_pm_qos_request *pq_req;
 #endif
 	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */
diff --git a/include/linux/pm_qos.h b/include/linux/pm_qos.h
index 233149cb..c5983b47 100644
--- a/include/linux/pm_qos.h
+++ b/include/linux/pm_qos.h
@@ -15,8 +15,20 @@ enum {
 	PM_QOS_CPU_DMA_LATENCY,
 	PM_QOS_NETWORK_LATENCY,
 	PM_QOS_NETWORK_THROUGHPUT,
-
+	PM_QOS_CPUIDLE_BLOCK,
 	/* insert new class ID */
+#ifdef CONFIG_DDR_DEVFREQ
+	PM_QOS_DDR_DEVFREQ_MIN,
+	PM_QOS_DDR_DEVFREQ_MAX,
+#endif
+	PM_QOS_CPUFREQ_MIN,
+	PM_QOS_CPUFREQ_MAX,
+	PM_QOS_GPUFREQ_3D_MIN,
+	PM_QOS_GPUFREQ_2D_MIN,
+	PM_QOS_GPUFREQ_SH_MIN,
+	PM_QOS_GPUFREQ_3D_MAX,
+	PM_QOS_GPUFREQ_2D_MAX,
+	PM_QOS_GPUFREQ_SH_MAX,
 	PM_QOS_NUM_CLASSES,
 };
 
@@ -26,10 +38,15 @@ enum {
 #define PM_QOS_NETWORK_LAT_DEFAULT_VALUE	(2000 * USEC_PER_SEC)
 #define PM_QOS_NETWORK_THROUGHPUT_DEFAULT_VALUE	0
 #define PM_QOS_DEV_LAT_DEFAULT_VALUE		0
+#define PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE	0
+#define PM_QOS_CPUIDLE_BLOCK_VCTCXO_VALUE	1
+#define PM_QOS_CPUIDLE_BLOCK_DDR_VALUE		2
+#define PM_QOS_CPUIDLE_BLOCK_AXI_VALUE		3
 
 struct pm_qos_request {
 	struct plist_node node;
 	int pm_qos_class;
+	const char *name;
 	struct delayed_work work; /* for pm_qos_update_request_timeout */
 };
 
@@ -64,6 +81,21 @@ enum pm_qos_req_action {
 	PM_QOS_REMOVE_REQ	/* Remove an existing request */
 };
 
+/*
+ * locking rule: all changes to constraints or notifiers lists
+ * or pm_qos_object list and pm_qos_objects need to happen with pm_qos_lock
+ * held, taken with _irqsave.  One lock to rule them all
+ */
+struct pm_qos_object {
+	struct pm_qos_constraints *constraints;
+	struct miscdevice pm_qos_power_miscdev;
+	char *name;
+};
+
+/* Declare qos_array in case other drivers may access it */
+extern spinlock_t pm_qos_lock;
+extern struct pm_qos_object *pm_qos_array[];
+
 static inline int dev_pm_qos_request_active(struct dev_pm_qos_request *req)
 {
 	return req->dev != 0;
diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 609daae7..f271860c 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -150,9 +150,6 @@ static inline void pm_runtime_set_autosuspend_delay(struct device *dev,
 static inline unsigned long pm_runtime_autosuspend_expiration(
 				struct device *dev) { return 0; }
 
-static inline void pm_runtime_update_max_time_suspended(struct device *dev,
-							s64 delta_ns) {}
-
 #endif /* !CONFIG_PM_RUNTIME */
 
 static inline int pm_runtime_idle(struct device *dev)
diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index d9f05113..569781fa 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -33,12 +33,15 @@
  *
  * @total_time: Total time this wakeup source has been active.
  * @max_time: Maximum time this wakeup source has been continuously active.
- * @last_time: Monotonic clock when the wakeup source's was activated last time.
+ * @last_time: Monotonic clock when the wakeup source's was touched last time.
+ * @prevent_sleep_time: Total time this source has been preventing autosleep.
  * @event_count: Number of signaled wakeup events.
  * @active_count: Number of times the wakeup sorce was activated.
  * @relax_count: Number of times the wakeup sorce was deactivated.
- * @hit_count: Number of times the wakeup sorce might abort system suspend.
+ * @expire_count: Number of times the wakeup source's timeout has expired.
+ * @wakeup_count: Number of times the wakeup source might abort suspend.
  * @active: Status of the wakeup source.
+ * @has_timeout: The wakeup source has been activated with a timeout.
  */
 struct wakeup_source {
 	const char 		*name;
@@ -49,11 +52,15 @@ struct wakeup_source {
 	ktime_t total_time;
 	ktime_t max_time;
 	ktime_t last_time;
+	ktime_t start_prevent_time;
+	ktime_t prevent_sleep_time;
 	unsigned long		event_count;
 	unsigned long		active_count;
 	unsigned long		relax_count;
-	unsigned long		hit_count;
-	unsigned int		active:1;
+	unsigned long		expire_count;
+	unsigned long		wakeup_count;
+	bool			active:1;
+	bool			autosleep_enabled:1;
 };
 
 #ifdef CONFIG_PM_SLEEP
diff --git a/include/linux/power/fake-sysoff.h b/include/linux/power/fake-sysoff.h
new file mode 100644
index 00000000..2d72df27
--- /dev/null
+++ b/include/linux/power/fake-sysoff.h
@@ -0,0 +1,22 @@
+#ifndef __FAKE_SYSOFF_H__
+#define __FAKE_SYSOFF_H__
+
+#ifdef CONFIG_FAKE_SYSTEMOFF
+/*
+ * fake_sysoff_status_query
+ * return 1: sysoff mode
+ * return 0: normal mode
+ */
+extern unsigned int fake_sysoff_status_query(void);
+extern unsigned int fake_sysoff_block_onkey(void);
+extern void fake_sysoff_work_cancel(void);
+extern void fake_sysoff_set_block_onkey(int block);
+#else /*!CONFIG_FAKE_SYSTEMOFF*/
+static inline unsigned int fake_sysoff_status_query(void) { return 0; }
+static inline unsigned int fake_sysoff_block_onkey(void) { return 0; }
+static inline void fake_sysoff_work_cancel(void) {}
+static inline void fake_sysoff_set_block_onkey(int block) {}
+#endif
+
+#endif
+
diff --git a/include/linux/power_supply.h b/include/linux/power_supply.h
index c38c13db..409b02ab 100644
--- a/include/linux/power_supply.h
+++ b/include/linux/power_supply.h
@@ -13,6 +13,8 @@
 #ifndef __LINUX_POWER_SUPPLY_H__
 #define __LINUX_POWER_SUPPLY_H__
 
+#include <linux/device.h>
+#include <linux/wakelock.h>
 #include <linux/workqueue.h>
 #include <linux/leds.h>
 
@@ -44,6 +46,7 @@ enum {
 	POWER_SUPPLY_CHARGE_TYPE_NONE,
 	POWER_SUPPLY_CHARGE_TYPE_TRICKLE,
 	POWER_SUPPLY_CHARGE_TYPE_FAST,
+	POWER_SUPPLY_CHARGE_TYPE_SLOW,
 };
 
 enum {
@@ -54,6 +57,7 @@ enum {
 	POWER_SUPPLY_HEALTH_OVERVOLTAGE,
 	POWER_SUPPLY_HEALTH_UNSPEC_FAILURE,
 	POWER_SUPPLY_HEALTH_COLD,
+	POWER_SUPPLY_HEALTH_UNDERVOLTAGE,
 };
 
 enum {
@@ -81,6 +85,19 @@ enum {
 	POWER_SUPPLY_SCOPE_DEVICE,
 };
 
+/* for SAMSUNG OTG */
+enum {
+	POWER_SUPPLY_CAPACITY_OTG_ENABLE = 0,
+	POWER_SUPPLY_CAPACITY_OTG_DISABLE,
+};
+
+#if defined(CONFIG_FUELGAUGE_88PM822)
+enum {
+	POWER_SUPPLY_PWR_RDY_FALSE = 0,
+	POWER_SUPPLY_PWR_RDY_TRUE,
+};
+#endif
+
 enum power_supply_property {
 	/* Properties of type `int' */
 	POWER_SUPPLY_PROP_STATUS = 0,
@@ -117,17 +134,39 @@ enum power_supply_property {
 	POWER_SUPPLY_PROP_CAPACITY, /* in percents! */
 	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
 	POWER_SUPPLY_PROP_TEMP,
+#if defined(CONFIG_SPA) //book
+	POWER_SUPPLY_PROP_TEMP_ADC,
+#endif
 	POWER_SUPPLY_PROP_TEMP_AMBIENT,
 	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
 	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,
 	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
 	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG,
 	POWER_SUPPLY_PROP_TYPE, /* use power_supply.type instead */
+#if defined(CONFIG_SPA) //book
+	POWER_SUPPLY_PROP_BATT_VOL,
+	POWER_SUPPLY_PROP_BATT_VOL_AVER,
+	POWER_SUPPLY_PROP_BATT_TEMP,
+	POWER_SUPPLY_PROP_BATT_TEMP_ADC,
+	POWER_SUPPLY_PROP_BATT_TEMP_AVER,
+	POWER_SUPPLY_PROP_BATT_TEMP_ADC_AVER,
+	POWER_SUPPLY_PROP_BATT_CHARGING_SOURCE,
+	/* DFT */
+	POWER_SUPPLY_PROP_BATT_READ_RAW_SOC,
+	/* DFT */
+#endif
 	POWER_SUPPLY_PROP_SCOPE,
+	/* Local extensions */
+	POWER_SUPPLY_PROP_USB_HC,
+	POWER_SUPPLY_PROP_USB_OTG,
+	POWER_SUPPLY_PROP_CHARGE_ENABLED,
 	/* Properties of type `const char *' */
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,
+#if defined(CONFIG_FUELGAUGE_88PM822)
+	POWER_SUPPLY_PROP_POWER_STATUS,
+#endif
 };
 
 enum power_supply_type {
@@ -139,7 +178,47 @@ enum power_supply_type {
 	POWER_SUPPLY_TYPE_USB_DCP,	/* Dedicated Charging Port */
 	POWER_SUPPLY_TYPE_USB_CDP,	/* Charging Downstream Port */
 	POWER_SUPPLY_TYPE_USB_ACA,	/* Accessory Charger Adapters */
+	POWER_SUPPLY_TYPE_MISC,
+	POWER_SUPPLY_TYPE_CARDOCK,
+	POWER_SUPPLY_TYPE_WPC,		/* Wireless Charging should be 10 */
+	POWER_SUPPLY_TYPE_UARTOFF,
+	POWER_SUPPLY_TYPE_OTG,
+};
+
+/*
+ * EXTENDED_ONLINE_TYPE
+ * - support various charger cable type
+ * - set type from each accessory driver(muic, host, mhl, etc,,,)
+ *
+ * - type format
+ * | 31-24: RSVD | 23-16: MAIN TYPE | 15-8: SUB TYPE | 7-0: POWER TYPE |
+ */
+#define ONLINE_TYPE_RSVD_SHIFT	24
+#define ONLINE_TYPE_RSVD_MASK	(0xF << ONLINE_TYPE_RSVD_SHIFT)
+#define ONLINE_TYPE_MAIN_SHIFT	16
+#define ONLINE_TYPE_MAIN_MASK	(0xF << ONLINE_TYPE_MAIN_SHIFT)
+#define ONLINE_TYPE_SUB_SHIFT	8
+#define ONLINE_TYPE_SUB_MASK	(0xF << ONLINE_TYPE_SUB_SHIFT)
+#define ONLINE_TYPE_PWR_SHIFT	0
+#define ONLINE_TYPE_PWR_MASK	(0xF << ONLINE_TYPE_PWR_SHIFT)
+
+enum online_sub_type {
+	ONLINE_SUB_TYPE_UNKNOWN	= 0,
+	ONLINE_SUB_TYPE_MHL,
+	ONLINE_SUB_TYPE_AUDIO,
+	ONLINE_SUB_TYPE_DESK,
+	ONLINE_SUB_TYPE_SMART_NOTG,
+	ONLINE_SUB_TYPE_SMART_OTG,
+	ONLINE_SUB_TYPE_KBD,
+};
+
+enum online_power_type {
+	ONLINE_POWER_TYPE_UNKNOWN = 0,
+	ONLINE_POWER_TYPE_BATTERY,
+	ONLINE_POWER_TYPE_TA,
+	ONLINE_POWER_TYPE_USB,
 };
+/* EXTENDED_ONLINE_TYPE */
 
 union power_supply_propval {
 	int intval;
@@ -172,6 +251,9 @@ struct power_supply {
 	/* private */
 	struct device *dev;
 	struct work_struct changed_work;
+	spinlock_t changed_lock;
+	bool changed;
+	struct wake_lock work_wake_lock;
 
 #ifdef CONFIG_LEDS_TRIGGERS
 	struct led_trigger *charging_full_trig;
@@ -210,6 +292,9 @@ extern struct power_supply *power_supply_get_by_name(char *name);
 extern void power_supply_changed(struct power_supply *psy);
 extern int power_supply_am_i_supplied(struct power_supply *psy);
 extern int power_supply_set_battery_charged(struct power_supply *psy);
+extern int power_supply_set_current_limit(struct power_supply *psy, int limit);
+extern int power_supply_set_online(struct power_supply *psy, bool enable);
+extern int power_supply_set_charge_type(struct power_supply *psy, int type);
 
 #if defined(CONFIG_POWER_SUPPLY) || defined(CONFIG_POWER_SUPPLY_MODULE)
 extern int power_supply_is_system_supplied(void);
diff --git a/include/linux/pxa2xx_ssp.h b/include/linux/pxa2xx_ssp.h
index 44835fb3..e5e53b36 100644
--- a/include/linux/pxa2xx_ssp.h
+++ b/include/linux/pxa2xx_ssp.h
@@ -80,7 +80,7 @@
 #define SSSR_RFS	(1 << 6)	/* Receive FIFO Service Request */
 #define SSSR_ROR	(1 << 7)	/* Receive FIFO Overrun */
 
-#ifdef CONFIG_ARCH_PXA
+#if defined(CONFIG_ARCH_PXA) || defined(CONFIG_ARCH_MMP)
 #define RX_THRESH_DFLT	8
 #define TX_THRESH_DFLT	8
 
@@ -160,7 +160,11 @@ enum pxa_ssp_type {
 	PXA25x_SSP,  /* pxa 210, 250, 255, 26x */
 	PXA25x_NSSP, /* pxa 255, 26x (including ASSP) */
 	PXA27x_SSP,
+	PXA3xx_SSP,
 	PXA168_SSP,
+	PXA910_SSP,
+	PXA988_SSP,
+	EDEN_SSP,
 	CE4100_SSP,
 };
 
diff --git a/include/linux/pxa_ion.h b/include/linux/pxa_ion.h
new file mode 100644
index 00000000..f31685e9
--- /dev/null
+++ b/include/linux/pxa_ion.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2012 Marvell International Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _PXA_ION_H
+#define _PXA_ION_H
+
+#include <linux/ion.h>
+
+struct ion_pxa_region {
+	struct ion_handle *handle;
+	unsigned long addr;
+	size_t len;
+};
+
+#define ION_PXA_PHYS		1
+#define ION_PXA_SYNC		2
+
+enum {
+	PXA_DMA_BIDIRECTIONAL = 0,
+	PXA_DMA_TO_DEVICE = 1,
+	PXA_DMA_FROM_DEVICE = 2,
+	PXA_DMA_NONE = 3,
+};
+
+struct ion_pxa_cache_region {
+	int fd;				/* buf id used in 3.4 */
+	struct ion_handle *handle;	/* handle used in 3.0, will remove */
+	unsigned long offset;
+	size_t len;
+	unsigned int dir;
+};
+
+#endif /* _PXA_ION_H */
diff --git a/include/linux/regdump_ops.h b/include/linux/regdump_ops.h
new file mode 100644
index 00000000..ad894dbb
--- /dev/null
+++ b/include/linux/regdump_ops.h
@@ -0,0 +1,51 @@
+/*
+ *  regdump.h - framework for dump the system periperal registers.
+ *
+ *  Copyright (C) 2012 Lei Wen <leiwen@marvell.com>, Marvell Inc.
+ *
+ *  This file is released under the GPLv2.
+ */
+
+#ifndef _LINUX_REGDUMP_OPS_H
+#define _LINUX_REGDUMP_OPS_H
+
+#include <linux/list.h>
+#include <linux/slab.h>
+
+#ifdef CONFIG_REGDUMP
+struct regdump_ops;
+struct regdump_region {
+	const char		*name;
+	unsigned long		start;
+	unsigned long		size;
+	int (*cond) (struct regdump_ops *ops);
+};
+
+struct regdump_ops {
+	struct list_head 	node;
+	const char		*dev_name;
+	int			enable;
+	unsigned long		base;
+	void			*buffer;
+
+	struct regdump_region	*regions;
+	unsigned long		reg_nums;
+	unsigned long		phy_base;
+};
+
+extern int dump_reg_to_mem(void);
+extern int dump_reg_to_console(void);
+extern int register_regdump_ops(struct regdump_ops *ops);
+extern int unregister_regdump_ops(struct regdump_ops *ops);
+static int inline regdump_cond_true(struct regdump_ops *ops)
+{
+	return 1;
+}
+#else
+#define register_regdump_ops()		do {} while(0)
+#define unregister_regdump_ops()	do {} while(0)
+#define dump_reg_to_mem()		do {} while(0)
+#define regdump_cond_true()		do {} while(0)
+#define dump_reg_to_console()   do {} while (0)
+#endif
+#endif
diff --git a/include/linux/regmap.h b/include/linux/regmap.h
index a90abb6b..b3aee20b 100644
--- a/include/linux/regmap.h
+++ b/include/linux/regmap.h
@@ -203,6 +203,7 @@ struct regmap_irq_chip {
 	unsigned int status_base;
 	unsigned int mask_base;
 	unsigned int ack_base;
+	unsigned int mask_invert;
 
 	int num_regs;
 
diff --git a/include/linux/regulator/consumer.h b/include/linux/regulator/consumer.h
index 4ed1b30a..da339fd8 100644
--- a/include/linux/regulator/consumer.h
+++ b/include/linux/regulator/consumer.h
@@ -290,6 +290,12 @@ static inline int regulator_set_voltage(struct regulator *regulator,
 }
 
 static inline int regulator_get_voltage(struct regulator *regulator)
+{
+	return -EINVAL;
+}
+
+static inline int regulator_is_supported_voltage(struct regulator *regulator,
+				   int min_uV, int max_uV)
 {
 	return 0;
 }
diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 6fdf0273..a02f2488 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -192,6 +192,7 @@ int __must_check rfkill_register(struct rfkill *rfkill);
  */
 void rfkill_pause_polling(struct rfkill *rfkill);
 
+#ifdef CONFIG_RFKILL_PM
 /**
  * rfkill_resume_polling(struct rfkill *rfkill)
  *
@@ -200,7 +201,11 @@ void rfkill_pause_polling(struct rfkill *rfkill);
  * core stops polling anyway
  */
 void rfkill_resume_polling(struct rfkill *rfkill);
-
+#else
+static inline void rfkill_resume_polling(struct rfkill *rfkill)
+{
+}
+#endif
 
 /**
  * rfkill_unregister - Unregister a rfkill structure.
diff --git a/include/linux/rmap.h b/include/linux/rmap.h
index fd07c454..f5c56ab9 100644
--- a/include/linux/rmap.h
+++ b/include/linux/rmap.h
@@ -7,7 +7,7 @@
 #include <linux/list.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
-#include <linux/mutex.h>
+#include <linux/rwsem.h>
 #include <linux/memcontrol.h>
 
 /*
@@ -25,8 +25,8 @@
  * pointing to this anon_vma once its vma list is empty.
  */
 struct anon_vma {
-	struct anon_vma *root;	/* Root of this anon_vma tree */
-	struct mutex mutex;	/* Serialize access to vma list */
+	struct anon_vma *root;		/* Root of this anon_vma tree */
+	struct rw_semaphore rwsem;	/* W: modification, R: walking the list */
 	/*
 	 * The refcount is taken on an anon_vma when there is no
 	 * guarantee that the vma of page tables will exist for
@@ -67,6 +67,17 @@ struct anon_vma_chain {
 	struct list_head same_anon_vma;	/* locked by anon_vma->mutex */
 };
 
+enum ttu_flags {
+	TTU_UNMAP = 0,			/* unmap mode */
+	TTU_MIGRATION = 1,		/* migration mode */
+	TTU_MUNLOCK = 2,		/* munlock mode */
+	TTU_ACTION_MASK = 0xff,
+
+	TTU_IGNORE_MLOCK = (1 << 8),	/* ignore mlock */
+	TTU_IGNORE_ACCESS = (1 << 9),	/* don't age */
+	TTU_IGNORE_HWPOISON = (1 << 10),/* corrupted page is recoverable */
+};
+
 #ifdef CONFIG_MMU
 static inline void get_anon_vma(struct anon_vma *anon_vma)
 {
@@ -93,26 +104,37 @@ static inline void vma_lock_anon_vma(struct vm_area_struct *vma)
 {
 	struct anon_vma *anon_vma = vma->anon_vma;
 	if (anon_vma)
-		mutex_lock(&anon_vma->root->mutex);
+		down_write(&anon_vma->root->rwsem);
 }
 
 static inline void vma_unlock_anon_vma(struct vm_area_struct *vma)
 {
 	struct anon_vma *anon_vma = vma->anon_vma;
 	if (anon_vma)
-		mutex_unlock(&anon_vma->root->mutex);
+		up_write(&anon_vma->root->rwsem);
+}
+
+static inline void anon_vma_lock_write(struct anon_vma *anon_vma)
+{
+	down_write(&anon_vma->root->rwsem);
 }
 
-static inline void anon_vma_lock(struct anon_vma *anon_vma)
+static inline void anon_vma_unlock_write(struct anon_vma *anon_vma)
 {
-	mutex_lock(&anon_vma->root->mutex);
+	up_write(&anon_vma->root->rwsem);
 }
 
-static inline void anon_vma_unlock(struct anon_vma *anon_vma)
+static inline void anon_vma_lock_read(struct anon_vma *anon_vma)
 {
-	mutex_unlock(&anon_vma->root->mutex);
+	down_read(&anon_vma->root->rwsem);
 }
 
+static inline void anon_vma_unlock_read(struct anon_vma *anon_vma)
+{
+	up_read(&anon_vma->root->rwsem);
+}
+
+
 /*
  * anon_vma helper functions.
  */
@@ -120,7 +142,6 @@ void anon_vma_init(void);	/* create anon_vma_cachep */
 int  anon_vma_prepare(struct vm_area_struct *);
 void unlink_anon_vmas(struct vm_area_struct *);
 int anon_vma_clone(struct vm_area_struct *, struct vm_area_struct *);
-void anon_vma_moveto_tail(struct vm_area_struct *);
 int anon_vma_fork(struct vm_area_struct *, struct vm_area_struct *);
 
 static inline void anon_vma_merge(struct vm_area_struct *vma,
@@ -161,16 +182,6 @@ int page_referenced(struct page *, int is_locked,
 int page_referenced_one(struct page *, struct vm_area_struct *,
 	unsigned long address, unsigned int *mapcount, unsigned long *vm_flags);
 
-enum ttu_flags {
-	TTU_UNMAP = 0,			/* unmap mode */
-	TTU_MIGRATION = 1,		/* migration mode */
-	TTU_MUNLOCK = 2,		/* munlock mode */
-	TTU_ACTION_MASK = 0xff,
-
-	TTU_IGNORE_MLOCK = (1 << 8),	/* ignore mlock */
-	TTU_IGNORE_ACCESS = (1 << 9),	/* don't age */
-	TTU_IGNORE_HWPOISON = (1 << 10),/* corrupted page is recoverable */
-};
 #define TTU_ACTION(x) ((x) & TTU_ACTION_MASK)
 
 bool is_vma_temporary_stack(struct vm_area_struct *vma);
@@ -218,8 +229,8 @@ int try_to_munlock(struct page *);
 /*
  * Called by memory-failure.c to kill processes.
  */
-struct anon_vma *page_lock_anon_vma(struct page *page);
-void page_unlock_anon_vma(struct anon_vma *anon_vma);
+struct anon_vma *page_lock_anon_vma_read(struct page *page);
+void page_unlock_anon_vma_read(struct anon_vma *anon_vma);
 int page_mapped_in_vma(struct page *page, struct vm_area_struct *vma);
 
 /*
diff --git a/include/linux/rtdefs.h b/include/linux/rtdefs.h
new file mode 100644
index 00000000..674194ef
--- /dev/null
+++ b/include/linux/rtdefs.h
@@ -0,0 +1,81 @@
+/*
+ * include/linux/rtdefs.h
+ *
+ * Richtek driver common definitions
+ *
+ * Copyright (C) 2013 Richtek Technology Corp.
+ * Author: Patrick Chang <patrick_chang@richtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#ifndef RTDEFS_H
+#define RTDEFS_H
+#include <linux/kernel.h>
+
+#ifndef RTDBGLEVEL
+#define RTDBGLEVEL  3
+#endif
+
+#define RTDBGINFO_LEVEL 3
+#define RTDBGWARN_LEVEL 2
+#define RTDBGERR_LEVEL  1
+#define RTDBGFPRN_LEVEL 0
+
+
+#if RTDBGINFO_LEVEL<=RTDBGLEVEL
+#define RTINFO(format, args...) \
+    printk(KERN_INFO "%s:%s() line-%d: " format, \
+            ALIAS_NAME, __FUNCTION__, __LINE__, ## args)
+#define RTINFO_IF(cond, format, args...) \
+    if (cond) \
+        printk(KERN_INFO "%s:%s() line-%d: " format, \
+                ALIAS_NAME, __FUNCTION__, __LINE__, ## args)
+#else
+#define RTINFO(format, args...)
+#define RTINFO_IF(cond, format, args...)
+#endif
+
+#if RTDBGWARN_LEVEL<=RTDBGLEVEL
+#define RTWARN(format, args...) \
+    printk(KERN_WARNING "%s:%s() line-%d: " format, \
+            ALIAS_NAME, __FUNCTION__, __LINE__, ## args)
+#define RTWARN_IF(cond, format, args...) \
+    if (cond) \
+        printk(KERN_WARNING "%s:%s() line-%d: " format, \
+                ALIAS_NAME, __FUNCTION__, __LINE__, ## args)
+#else
+#define RTWARN(format, args...)
+#define RTWARN_IF(cond, format, args...)
+#endif
+
+#if RTDBGERR_LEVEL<=RTDBGLEVEL
+#define RTERR(format, args...) \
+    printk(KERN_ERR "%s:%s() line-%d: " format, \
+            ALIAS_NAME, __FUNCTION__, __LINE__, ## args)
+#define RTERR_IF(cond, format, args...) \
+    if (cond) printk(KERN_ERR "%s:%s() line-%d: " format, \
+            ALIAS_NAME, __FUNCTION__, __LINE__, ## args)
+#else
+#define RTERR(format, args...)
+#define RTERR_IF(cond, format, args...)
+#endif
+
+#if RTDBGFPRN_LEVEL<=RTDBGLEVEL
+#define RTPRN(format, args...) \
+    printk(KERN_DEBUG "%s:%s() line-%d: " format, \
+            ALIAS_NAME, __FUNCTION__, __LINE__, ## args)
+#define RTPRN_IF(cond, format, args...) \
+    if (cond) printk(KERN_DEBUG "%s:%s() line-%d: " format, \
+            ALIAS_NAME, __FUNCTION__, __LINE__, ## args)
+#else
+#define RTPRN(format, args...)
+#define RTPRN_IF(cond, format, args...)
+#endif
+
+
+
+#endif // RTDEFS_H
diff --git a/include/linux/rwsem.h b/include/linux/rwsem.h
index 54bd7cd7..413cc11e 100644
--- a/include/linux/rwsem.h
+++ b/include/linux/rwsem.h
@@ -125,8 +125,17 @@ extern void downgrade_write(struct rw_semaphore *sem);
  */
 extern void down_read_nested(struct rw_semaphore *sem, int subclass);
 extern void down_write_nested(struct rw_semaphore *sem, int subclass);
+extern void _down_write_nest_lock(struct rw_semaphore *sem, struct lockdep_map *nest_lock);
+
+# define down_write_nest_lock(sem, nest_lock)			\
+do {								\
+	typecheck(struct lockdep_map *, &(nest_lock)->dep_map);	\
+	_down_write_nest_lock(sem, &(nest_lock)->dep_map);	\
+} while (0);
+
 #else
 # define down_read_nested(sem, subclass)		down_read(sem)
+# define down_write_nest_lock(sem, nest_lock)	down_read(sem)
 # define down_write_nested(sem, subclass)	down_write(sem)
 #endif
 
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 81a173c0..6ab76890 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -141,6 +141,10 @@ extern unsigned long nr_uninterruptible(void);
 extern unsigned long nr_iowait(void);
 extern unsigned long nr_iowait_cpu(int cpu);
 extern unsigned long this_cpu_load(void);
+extern unsigned long get_cpu_nr_running(unsigned int cpu);
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+extern unsigned long this_cpu_loadx(int i);
+#endif
 
 
 extern void calc_global_load(unsigned long ticks);
@@ -317,6 +321,11 @@ extern int proc_dowatchdog_thresh(struct ctl_table *table, int write,
 				  size_t *lenp, loff_t *ppos);
 extern unsigned int  softlockup_panic;
 void lockup_detector_init(void);
+#ifdef CONFIG_SMP_HARDLOCKUP_DETECTOR
+extern unsigned int  hardlockup_enable;
+extern int proc_hardlockup(struct ctl_table *, int ,
+			   void __user *, size_t *, loff_t *);
+#endif
 #else
 static inline void touch_softlockup_watchdog(void)
 {
@@ -1801,6 +1810,9 @@ static inline void put_task_struct(struct task_struct *t)
 extern void task_times(struct task_struct *p, cputime_t *ut, cputime_t *st);
 extern void thread_group_times(struct task_struct *p, cputime_t *ut, cputime_t *st);
 
+extern int task_free_register(struct notifier_block *n);
+extern int task_free_unregister(struct notifier_block *n);
+
 /*
  * Per process flags
  */
@@ -2684,7 +2696,16 @@ static inline void thread_group_cputime_init(struct signal_struct *sig)
 extern void recalc_sigpending_and_wake(struct task_struct *t);
 extern void recalc_sigpending(void);
 
-extern void signal_wake_up(struct task_struct *t, int resume_stopped);
+extern void signal_wake_up_state(struct task_struct *t, unsigned int state);
+
+static inline void signal_wake_up(struct task_struct *t, bool resume)
+{
+	signal_wake_up_state(t, resume ? TASK_WAKEKILL : 0);
+}
+static inline void ptrace_signal_wake_up(struct task_struct *t, bool resume)
+{
+	signal_wake_up_state(t, resume ? __TASK_TRACED : 0);
+}
 
 /*
  * Wrappers for p->thread_info->cpu access. No-op on UP.
diff --git a/include/linux/sd8x_rfkill.h b/include/linux/sd8x_rfkill.h
new file mode 100644
index 00000000..668c48db
--- /dev/null
+++ b/include/linux/sd8x_rfkill.h
@@ -0,0 +1,53 @@
+/*
+ * rfkill power contorl for Marvell sd8xxx wlan/bt
+ *
+ * Copyright (C) 2009 Marvell, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _LINUX_SD8X_RFKILL_H
+#define _LINUX_SD8X_RFKILL_H
+
+#include <linux/rfkill.h>
+#include <linux/mmc/mmc.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+
+typedef void (*rfkill_plat_set_power) (unsigned int);
+
+struct sd8x_rfkill_platform_data {
+	int gpio_power_down;
+	int gpio_reset;
+
+	struct rfkill *wlan_rfkill;
+	struct rfkill *bt_rfkill;
+	struct rfkill *fm_rfkill;
+
+	/*for issue mmc card_detection interrupt */
+	struct mmc_host *mmc;
+
+	/* for platform specific power on sequence */
+	rfkill_plat_set_power set_power;
+};
+
+int sd8x_sdh_init(struct device *dev, irq_handler_t detect_irq, void *data);
+
+int add_sd8x_rfkill_device(int gpio_power_down, int gpio_reset,
+			   struct mmc_host ***pmmc,
+			   rfkill_plat_set_power set_power);
+#endif
diff --git a/include/linux/secgpio_dvs.h b/include/linux/secgpio_dvs.h
new file mode 100755
index 00000000..3769c480
--- /dev/null
+++ b/include/linux/secgpio_dvs.h
@@ -0,0 +1,31 @@
+/*
+ * secgpio_dvs.h -- Samsung GPIO debugging and verification system
+ */
+
+#ifndef __SECGPIO_DVS_H
+#define __SECGPIO_DVS_H
+
+#include <linux/types.h>
+
+enum gdvs_phone_status {
+	PHONE_INIT = 0,
+	PHONE_SLEEP,
+	GDVS_PHONE_STATUS_MAX
+};
+
+struct gpiomap_result {
+	unsigned char *init;
+	unsigned char *sleep;
+};
+
+struct gpio_dvs {
+	struct gpiomap_result *result;
+	unsigned int count;
+	bool check_sleep;
+	void (*check_gpio_status)(unsigned char phonestate);
+};
+
+void gpio_dvs_check_initgpio(void);
+void gpio_dvs_check_sleepgpio(void);
+
+#endif /* __SECGPIO_DVS_H */
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 2db407a4..828c8037 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -252,6 +252,7 @@ struct uart_ops {
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
 	int		(*set_wake)(struct uart_port *, unsigned int state);
+	void		(*wake_peer)(struct uart_port *);
 
 	/*
 	 * Return a string describing the type of the port
diff --git a/include/linux/serial_reg.h b/include/linux/serial_reg.h
index 8ce70d76..4f853569 100644
--- a/include/linux/serial_reg.h
+++ b/include/linux/serial_reg.h
@@ -2,10 +2,10 @@
  * include/linux/serial_reg.h
  *
  * Copyright (C) 1992, 1994 by Theodore Ts'o.
- * 
- * Redistribution of this file is permitted under the terms of the GNU 
+ *
+ * Redistribution of this file is permitted under the terms of the GNU
  * Public License (GPL)
- * 
+ *
  * These are the UART port assignments, expressed as offsets from the base
  * register.  These assignments should hold for any serial port based on
  * a 8250, 16450, or 16550(A).
@@ -86,7 +86,7 @@
 
 #define UART_LCR	3	/* Out: Line Control Register */
 /*
- * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
+ * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting
  * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
  */
 #define UART_LCR_DLAB		0x80 /* Divisor latch access bit */
@@ -223,6 +223,7 @@
 #define UART_IER_UUE	0x40	/* UART Unit Enable */
 #define UART_IER_NRZE	0x20	/* NRZ coding Enable */
 #define UART_IER_RTOIE	0x10	/* Receiver Time Out Interrupt Enable */
+#define UART_IER_HSE	0x100	/* High Speed UART Enable */
 
 #define UART_IIR_TOD	0x08	/* Character Timeout Indication Detected */
 
@@ -230,6 +231,10 @@
 #define UART_FCR_PXAR8	0x40	/* receive FIFO threshold = 8 */
 #define UART_FCR_PXAR16	0x80	/* receive FIFO threshold = 16 */
 #define UART_FCR_PXAR32	0xc0	/* receive FIFO threshold = 32 */
+#define UART_FCR_PXA_BUS32	0x20	/* 32-Bit Peripheral Bus */
+#define UART_FCR_PXA_TRAIL	0x10	/* Trailing Bytes */
+
+#define UART_LSR_FIFOE	0x80	/* FIFO Error Status */
 
 /*
  * Intel MID on-chip HSU (High Speed UART) defined bits
diff --git a/include/linux/sockios.h b/include/linux/sockios.h
index 7997a506..f7ffe36d 100644
--- a/include/linux/sockios.h
+++ b/include/linux/sockios.h
@@ -65,6 +65,7 @@
 #define SIOCDIFADDR	0x8936		/* delete PA address		*/
 #define	SIOCSIFHWBROADCAST	0x8937	/* set hardware broadcast addr	*/
 #define SIOCGIFCOUNT	0x8938		/* get number of devices */
+#define SIOCKILLADDR	0x8939		/* kill sockets with this local addr */
 
 #define SIOCGIFBR	0x8940		/* Bridging support		*/
 #define SIOCSIFBR	0x8941		/* Set bridging options 	*/
diff --git a/include/linux/spi/cmmb.h b/include/linux/spi/cmmb.h
new file mode 100644
index 00000000..75a816a0
--- /dev/null
+++ b/include/linux/spi/cmmb.h
@@ -0,0 +1,19 @@
+#ifndef LINUX_SPI_CMMB_H
+#define LINUX_SPI_CMMB_H
+
+struct cmmb_platform_data {
+	int (*power_on) (void);
+	int (*power_off) (void);
+	int (*power_reset) (void);
+	int (*cs_assert) (void);
+	int (*cs_deassert) (void);
+
+	int (*cmmb_regulator) (bool en);
+
+	int gpio_power;
+	int gpio_reset;
+	int gpio_cs;
+	int gpio_defined;
+};
+
+#endif
diff --git a/include/linux/spi/pxa2xx_spi.h b/include/linux/spi/pxa2xx_spi.h
index d3e1075f..b6b61f15 100644
--- a/include/linux/spi/pxa2xx_spi.h
+++ b/include/linux/spi/pxa2xx_spi.h
@@ -40,10 +40,11 @@ struct pxa2xx_spi_chip {
 	u32 timeout;
 	u8 enable_loopback;
 	int gpio_cs;
+	int using_gpio_cs;
 	void (*cs_control)(u32 command);
 };
 
-#ifdef CONFIG_ARCH_PXA
+#if defined(CONFIG_ARCH_PXA) || defined(CONFIG_ARCH_MMP)
 
 #include <linux/clk.h>
 #include <mach/dma.h>
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index fa702aeb..aa0ccf73 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -648,6 +648,8 @@ spi_write(struct spi_device *spi, const void *buf, size_t len)
 	struct spi_transfer	t = {
 			.tx_buf		= buf,
 			.len		= len,
+			.bits_per_word = 16,
+			.speed_hz = 13000000,
 		};
 	struct spi_message	m;
 
@@ -672,6 +674,8 @@ spi_read(struct spi_device *spi, void *buf, size_t len)
 	struct spi_transfer	t = {
 			.rx_buf		= buf,
 			.len		= len,
+			.bits_per_word = 16,
+			.speed_hz = 13000000,
 		};
 	struct spi_message	m;
 
diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index ac1c114c..4965bafc 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -356,8 +356,10 @@ extern int unregister_pm_notifier(struct notifier_block *nb);
 extern bool events_check_enabled;
 
 extern bool pm_wakeup_pending(void);
-extern bool pm_get_wakeup_count(unsigned int *count);
+extern bool pm_get_wakeup_count(unsigned int *count, bool block);
 extern bool pm_save_wakeup_count(unsigned int count);
+extern void pm_wakep_autosleep_enabled(bool set);
+extern void print_active_wakeup_events(void);
 
 static inline void lock_system_sleep(void)
 {
@@ -407,6 +409,17 @@ static inline void unlock_system_sleep(void) {}
 
 #endif /* !CONFIG_PM_SLEEP */
 
+#ifdef CONFIG_PM_AUTOSLEEP
+
+/* kernel/power/autosleep.c */
+void queue_up_suspend_work(void);
+
+#else /* !CONFIG_PM_AUTOSLEEP */
+
+static inline void queue_up_suspend_work(void) {}
+
+#endif /* !CONFIG_PM_AUTOSLEEP */
+
 #ifdef CONFIG_ARCH_SAVE_PAGE_KEYS
 /*
  * The ARCH_SAVE_PAGE_KEYS functions can be used by an architecture
diff --git a/include/linux/switch.h b/include/linux/switch.h
new file mode 100644
index 00000000..3e4c748e
--- /dev/null
+++ b/include/linux/switch.h
@@ -0,0 +1,53 @@
+/*
+ *  Switch class driver
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#ifndef __LINUX_SWITCH_H__
+#define __LINUX_SWITCH_H__
+
+struct switch_dev {
+	const char	*name;
+	struct device	*dev;
+	int		index;
+	int		state;
+
+	ssize_t	(*print_name)(struct switch_dev *sdev, char *buf);
+	ssize_t	(*print_state)(struct switch_dev *sdev, char *buf);
+};
+
+struct gpio_switch_platform_data {
+	const char *name;
+	unsigned 	gpio;
+
+	/* if NULL, switch_dev.name will be printed */
+	const char *name_on;
+	const char *name_off;
+	/* if NULL, "0" or "1" will be printed */
+	const char *state_on;
+	const char *state_off;
+};
+
+extern int switch_dev_register(struct switch_dev *sdev);
+extern void switch_dev_unregister(struct switch_dev *sdev);
+
+static inline int switch_get_state(struct switch_dev *sdev)
+{
+	return sdev->state;
+}
+
+extern void switch_set_state(struct switch_dev *sdev, int state);
+
+#endif /* __LINUX_SWITCH_H__ */
diff --git a/include/linux/uid_stat.h b/include/linux/uid_stat.h
new file mode 100644
index 00000000..6bd6c4e5
--- /dev/null
+++ b/include/linux/uid_stat.h
@@ -0,0 +1,29 @@
+/* include/linux/uid_stat.h
+ *
+ * Copyright (C) 2008-2009 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __uid_stat_h
+#define __uid_stat_h
+
+/* Contains definitions for resource tracking per uid. */
+
+#ifdef CONFIG_UID_STAT
+int uid_stat_tcp_snd(uid_t uid, int size);
+int uid_stat_tcp_rcv(uid_t uid, int size);
+#else
+#define uid_stat_tcp_snd(uid, size) do {} while (0);
+#define uid_stat_tcp_rcv(uid, size) do {} while (0);
+#endif
+
+#endif /* _LINUX_UID_STAT_H */
diff --git a/include/linux/uio_coda7542.h b/include/linux/uio_coda7542.h
new file mode 100644
index 00000000..96b86ffa
--- /dev/null
+++ b/include/linux/uio_coda7542.h
@@ -0,0 +1,49 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * (C) Copyright 2012 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#ifndef _UIO_CODA7542_H_
+#define _UIO_CODA7542_H_
+
+#define CODA7542_IOC_MAGIC 'C'
+#define CODA7542_POWER_ON	_IO(CODA7542_IOC_MAGIC, 1)
+#define CODA7542_POWER_OFF	_IO(CODA7542_IOC_MAGIC, 2)
+#define CODA7542_CLK_ON		_IO(CODA7542_IOC_MAGIC, 3)
+#define CODA7542_CLK_OFF	_IO(CODA7542_IOC_MAGIC, 4)
+#define CODA7542_LOCK		_IOW(CODA7542_IOC_MAGIC, 5, unsigned int)
+#define CODA7542_UNLOCK		_IO(CODA7542_IOC_MAGIC, 6)
+#define CODA7542_GETSET_INFO	_IOW(CODA7542_IOC_MAGIC, 7, unsigned int)
+#define UIO_CODA7542_NAME	"pxa-coda7542"
+
+#define VPU_FEATURE_BITMASK_SRAM(n)	((n & 0x7) << 0)
+#define SRAM_EXTERNAL	0
+#define SRAM_INTERNAL	1
+
+#define VPU_FEATURE_BITMASK_NV21(n)	((n & 0x7) << 3)
+#define NV21_NONE		0
+#define NV21_SUPPORT	1
+
+/* definition should be same as user space lib*/
+#define VPU_CODEC_TYPEID_ENC_H264	0x1
+#define VPU_CODEC_TYPEID_ENC_MPEG4	0x2
+#define VPU_CODEC_TYPEID_ENC_H263	0x4
+#define VPU_CODEC_TYPEID_ENC_JPG	0x8
+#define VPU_CODEC_TYPEID_ENC_MASK	0xf
+#define VPU_CODEC_TYPEID_DEC_H264	0x10000
+#define VPU_CODEC_TYPEID_DEC_MPEG4	0x20000
+#define VPU_CODEC_TYPEID_DEC_H263	0x40000
+#define VPU_CODEC_TYPEID_DEC_MPEG2	0x80000
+#define VPU_CODEC_TYPEID_DEC_VC1	0x100000
+#define VPU_CODEC_TYPEID_DEC_JPG	0x200000
+#define VPU_CODEC_TYPEID_DEC_RV	0x400000
+#define VPU_CODEC_TYPEID_DEC_DIV3	0x800000
+
+
+extern void coda7542_power_switch(int on);
+
+#endif /* _UIO_CODA7542_H_ */
diff --git a/include/linux/uio_driver.h b/include/linux/uio_driver.h
index 1ad47244..22d51acc 100644
--- a/include/linux/uio_driver.h
+++ b/include/linux/uio_driver.h
@@ -64,6 +64,11 @@ struct uio_port {
 #define MAX_UIO_PORT_REGIONS	5
 
 struct uio_device;
+struct uio_listener {
+	struct uio_device *dev;
+	s32 event_count;
+	void *extend;
+};
 
 /**
  * struct uio_info - UIO device capabilities
@@ -92,9 +97,13 @@ struct uio_info {
 	void			*priv;
 	irqreturn_t (*handler)(int irq, struct uio_info *dev_info);
 	int (*mmap)(struct uio_info *info, struct vm_area_struct *vma);
-	int (*open)(struct uio_info *info, struct inode *inode);
-	int (*release)(struct uio_info *info, struct inode *inode);
+	int (*open)(struct uio_info *info,
+			struct inode *inode, void *file_priv);
+	int (*release)(struct uio_info *info,
+			struct inode *inode, void *file_priv);
 	int (*irqcontrol)(struct uio_info *info, s32 irq_on);
+	int (*ioctl)(struct uio_info *info, unsigned int cmd,
+			unsigned long arg, void *file_priv);
 };
 
 extern int __must_check
diff --git a/include/linux/uio_mvisp.h b/include/linux/uio_mvisp.h
new file mode 100644
index 00000000..de6cf72f
--- /dev/null
+++ b/include/linux/uio_mvisp.h
@@ -0,0 +1,29 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * (C) Copyright 2012 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#ifndef _UIO_MVISP_H_
+#define _UIO_MVISP_H_
+
+struct mvisp_get_uio_name {
+	char driver[16];
+};
+
+#define MVISP_IOC_MAGIC 'C'
+#define MVISP_UIO_NAME \
+		_IOWR(MVISP_IOC_MAGIC, 1, struct mvisp_get_uio_name)
+#define MVISP_POWER_ON	_IO(MVISP_IOC_MAGIC, 2)
+#define MVISP_POWER_OFF	_IO(MVISP_IOC_MAGIC, 3)
+#define MVISP_CLK_ON		_IO(MVISP_IOC_MAGIC, 4)
+#define MVISP_CLK_OFF	_IO(MVISP_IOC_MAGIC, 5)
+#define MVISP_LOCK		_IOW(MVISP_IOC_MAGIC, 6, unsigned int)
+#define MVISP_UNLOCK		_IO(MVISP_IOC_MAGIC, 7)
+#define MVISP_GETSET_INFO	_IOW(MVISP_IOC_MAGIC, 8, unsigned int)
+#define UIO_MVISP_NAME	"uio-mvisp"
+
+#endif /* _UIO_MVISP_H_ */
diff --git a/include/linux/vibrator.h b/include/linux/vibrator.h
new file mode 100755
index 00000000..1eb794a7
--- /dev/null
+++ b/include/linux/vibrator.h
@@ -0,0 +1,28 @@
+/*
+ *
+ * vibrator.h
+ *
+ * Copyright (C) 2013 Samsung Electronics Co.Ltd
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+
+#ifndef _LINUX_VIB_H
+#define _LINUX_VIB_H
+
+struct vib_info{
+	int gpio;
+};
+
+
+#endif /* LINUX_VIB_H */
+
diff --git a/include/linux/videodev2.h b/include/linux/videodev2.h
index c9c9a468..f882d25d 100644
--- a/include/linux/videodev2.h
+++ b/include/linux/videodev2.h
@@ -1264,8 +1264,48 @@ enum v4l2_colorfx {
 
 #define V4L2_CID_ALPHA_COMPONENT		(V4L2_CID_BASE+41)
 
+
+/**++ Add the Cam CTRL Functions : 20130401 dhee79.lee@samsung.com ++**/
+#define V4L2_CID_SCENE							(V4L2_CID_BASE+42)
+#define V4L2_CID_EFFECT							(V4L2_CID_BASE+43)
+#define V4L2_CID_ISO							(V4L2_CID_BASE+44)
+#define V4L2_CID_PHOTOMETRY					(V4L2_CID_BASE+45)
+#define V4L2_CID_QUALITY						(V4L2_CID_BASE+46)
+#define V4L2_CID_CAMERA_CHECK_DATALINE	 	(V4L2_CID_BASE+47)
+#define V4L2_CID_CAMERA_CHECK_DATALINE_STOP (V4L2_CID_BASE+48)
+#define V4L2_CID_FPS							(V4L2_CID_BASE+49)
+#define V4L2_CID_FRAME_TIME					(V4L2_CID_BASE+50)
+#define V4L2_CID_SELECT_MODE				(V4L2_CID_BASE+51)
+#define V4L2_CID_CAMERA_PREVIEW_SIZE		(V4L2_CID_BASE+52)
+#define V4L2_CID_FOCUS_MODE					(V4L2_CID_BASE+53)
+#define V4L2_CID_AF							(V4L2_CID_BASE+54)
+#define V4L2_CID_AF_STATUS					(V4L2_CID_BASE+55)
+#define V4L2_CID_AF_2nd_STATUS					(V4L2_CID_BASE+56)
+#define V4L2_CID_CAMERA_OBJECT_POSITION_X	(V4L2_CID_BASE+57)
+#define V4L2_CID_CAMERA_OBJECT_POSITION_Y	(V4L2_CID_BASE+58)
+#define V4L2_CID_AF_POSITION_START			(V4L2_CID_BASE+59)
+#define V4L2_CID_AF_POSITION_STOP			(V4L2_CID_BASE+60)
+#define V4L2_CID_AE_LOCK					(V4L2_CID_BASE+61)
+#define V4L2_CID_LIGHTNESS_CHECK					(V4L2_CID_BASE+62)
+//#define V4L2_CID_VFLIP						(V4L2_CID_BASE+63)
+#define V4L2_CID_FOCUS_MODE_STEP1 (V4L2_CID_BASE+64)
+#define V4L2_CID_FOCUS_MODE_STEP2 (V4L2_CID_BASE+65)
+#define V4L2_CID_FOCUS_MODE_STEP3 (V4L2_CID_BASE+66)
+#define V4L2_CID_ESD_CHECK (V4L2_CID_BASE+67)
+#define V4L2_CID_SET_STILL_STATUS	(V4L2_CID_BASE + 68)
+#define V4L2_CID_SET_PREVIEW_STATUS	(V4L2_CID_BASE + 69)
+#define V4L2_CID_PRIVATE_GET_FRAME_TIME	(V4L2_CID_BASE + 70)
+#define V4L2_CID_GET_AF_STATUS (V4L2_CID_BASE+71)
+#define V4L2_CID_GET_EXIF_EXPOSURETIME_DENOMINAL (V4L2_CID_BASE+72)
+#define V4L2_CID_GET_EXIF_ISO_SPEED (V4L2_CID_BASE+73)
+#define V4L2_CID_GET_EXIF_FLASH (V4L2_CID_BASE+74)
+#define V4L2_CID_SET_FLASH_STATUS	(V4L2_CID_BASE + 75)
+#define V4L2_CID_SET_FLASH_MODE	(V4L2_CID_BASE + 76)
+#define V4L2_CID_GET_FLASH_STATUS	(V4L2_CID_BASE + 77)
+/**-- Add the Cam CTRL Functions : 20130401 dhee79.lee@samsung.com --**/
+
 /* last CID + 1 */
-#define V4L2_CID_LASTP1                         (V4L2_CID_BASE+42)
+#define V4L2_CID_LASTP1                         (V4L2_CID_BASE+78)
 
 /*  MPEG-class control IDs defined by V4L2 */
 #define V4L2_CID_MPEG_BASE 			(V4L2_CTRL_CLASS_MPEG | 0x900)
@@ -2334,10 +2374,13 @@ struct v4l2_create_buffers {
 #define VIDIOC_S_TUNER		 _IOW('V', 30, struct v4l2_tuner)
 #define VIDIOC_G_AUDIO		 _IOR('V', 33, struct v4l2_audio)
 #define VIDIOC_S_AUDIO		 _IOW('V', 34, struct v4l2_audio)
+#define VIDIOC_G_EXIF          _IOWR('V', 35, struct v4l2_exif_info) // Add by DHL : 20120531
 #define VIDIOC_QUERYCTRL	_IOWR('V', 36, struct v4l2_queryctrl)
 #define VIDIOC_QUERYMENU	_IOWR('V', 37, struct v4l2_querymenu)
 #define VIDIOC_G_INPUT		 _IOR('V', 38, int)
 #define VIDIOC_S_INPUT		_IOWR('V', 39, int)
+#define VIDIOC_S_THUMBNAIL             _IOWR('V', 40, struct v4l2_pix_format) // Add by DHL : 20120531
+#define VIDIOC_AE_AWB_STATUS            _IOWR('V', 41, int) // Add by DHL : 20120531
 #define VIDIOC_G_OUTPUT		 _IOR('V', 46, int)
 #define VIDIOC_S_OUTPUT		_IOWR('V', 47, int)
 #define VIDIOC_ENUMOUTPUT	_IOWR('V', 48, struct v4l2_output)
diff --git a/include/linux/vmstat.h b/include/linux/vmstat.h
index 65efb92d..f12f9b35 100644
--- a/include/linux/vmstat.h
+++ b/include/linux/vmstat.h
@@ -141,6 +141,7 @@ static inline unsigned long zone_page_state_snapshot(struct zone *zone,
 
 extern unsigned long global_reclaimable_pages(void);
 extern unsigned long zone_reclaimable_pages(struct zone *zone);
+extern bool zone_reclaimable(struct zone *zone);
 
 #ifdef CONFIG_NUMA
 /*
@@ -258,6 +259,14 @@ static inline void refresh_zone_stat_thresholds(void) { }
 
 #endif		/* CONFIG_SMP */
 
+static inline void __mod_zone_freepage_state(struct zone *zone, int nr_pages,
+					     int migratetype)
+{
+	__mod_zone_page_state(zone, NR_FREE_PAGES, nr_pages);
+	if (is_migrate_cma(migratetype))
+		__mod_zone_page_state(zone, NR_FREE_CMA_PAGES, nr_pages);
+}
+
 extern const char * const vmstat_text[];
 
 #endif /* _LINUX_VMSTAT_H */
diff --git a/include/linux/wakelock.h b/include/linux/wakelock.h
new file mode 100644
index 00000000..f4a698a2
--- /dev/null
+++ b/include/linux/wakelock.h
@@ -0,0 +1,67 @@
+/* include/linux/wakelock.h
+ *
+ * Copyright (C) 2007-2012 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_WAKELOCK_H
+#define _LINUX_WAKELOCK_H
+
+#include <linux/ktime.h>
+#include <linux/device.h>
+
+/* A wake_lock prevents the system from entering suspend or other low power
+ * states when active. If the type is set to WAKE_LOCK_SUSPEND, the wake_lock
+ * prevents a full system suspend.
+ */
+
+enum {
+	WAKE_LOCK_SUSPEND, /* Prevent suspend */
+	WAKE_LOCK_TYPE_COUNT
+};
+
+struct wake_lock {
+	struct wakeup_source ws;
+};
+
+static inline void wake_lock_init(struct wake_lock *lock, int type,
+				  const char *name)
+{
+	wakeup_source_init(&lock->ws, name);
+}
+
+static inline void wake_lock_destroy(struct wake_lock *lock)
+{
+	wakeup_source_trash(&lock->ws);
+}
+
+static inline void wake_lock(struct wake_lock *lock)
+{
+	__pm_stay_awake(&lock->ws);
+}
+
+static inline void wake_lock_timeout(struct wake_lock *lock, long timeout)
+{
+	__pm_wakeup_event(&lock->ws, jiffies_to_msecs(timeout));
+}
+
+static inline void wake_unlock(struct wake_lock *lock)
+{
+	__pm_relax(&lock->ws);
+}
+
+static inline int wake_lock_active(struct wake_lock *lock)
+{
+	return lock->ws.active;
+}
+
+#endif
diff --git a/include/media/ispvideo.h b/include/media/ispvideo.h
new file mode 100644
index 00000000..13c265c7
--- /dev/null
+++ b/include/media/ispvideo.h
@@ -0,0 +1,75 @@
+/*
+* ispvideo.h
+*
+* Marvell DxO ISP - video node module
+*  Based on omap3isp
+*
+* Copyright:  (C) Copyright 2011 Marvell International Ltd.
+*			   Henry Zhao <xzhao10@marvell.com>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
+* General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301 USA
+*/
+
+
+#ifndef ISP_VIDEO_H
+#define ISP_VIDEO_H
+
+#include <linux/v4l2-mediabus.h>
+#include <linux/version.h>
+#include <media/media-entity.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-fh.h>
+#include <media/videobuf2-core.h>
+#include <media/map_vnode.h>
+
+#include <linux/mvisp.h>
+
+#define ISP_VIDEO_DRIVER_NAME		"mvsocisp"
+#define ISP_VIDEO_DRIVER_VERSION	KERNEL_VERSION(0, 0, 1)
+
+#define MIN_DRV_BUF			2
+
+enum isp_buf_paddr {
+	ISP_BUF_PADDR = 0,
+	ISP_BUF_PADDR_U,
+	ISP_BUF_PADDR_V,
+	ISP_BUF_MAX_PADDR,
+};
+
+#define ISP_VIDEO_INPUT_NAME	"dma_input"
+#define ISP_VIDEO_CODEC_NAME	"dma_codec"
+#define ISP_VIDEO_DISPLAY_NAME	"dma_display"
+#define ISP_VIDEO_CCIC1_NAME	"dma_ccic1"
+
+#define ISP_VIDEO_NR_BASE		5
+
+enum isp_video_type {
+	ISP_VIDEO_UNKNOWN = 0,
+	ISP_VIDEO_INPUT,
+	ISP_VIDEO_DISPLAY,
+	ISP_VIDEO_CODEC,
+	ISP_VIDEO_CCIC
+};
+
+enum isp_pipeline_stream_state {
+	ISP_PIPELINE_STREAM_STOPPED = 0,
+	ISP_PIPELINE_STREAM_CONTINUOUS = 1,
+};
+
+int mvisp_video_register(struct map_vnode *video, struct v4l2_device *vdev,
+			enum isp_video_type video_type);
+void mvisp_video_unregister(struct map_vnode *video);
+
+#endif /* ISP_VIDEO_H */
diff --git a/include/media/map_camera.h b/include/media/map_camera.h
new file mode 100644
index 00000000..584690a7
--- /dev/null
+++ b/include/media/map_camera.h
@@ -0,0 +1,162 @@
+#ifndef _MAP_CAMERA_H
+#define _MAP_CAMERA_H
+
+#include <media/v4l2-common.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+
+#include <media/map_hw.h>
+#include <media/ispvideo.h>
+#include <media/map_vnode.h>
+
+struct map_manager {
+	struct v4l2_device	v4l2_dev;
+	struct media_device	media_dev;
+	struct device		*dev;
+	struct mutex		graph_mutex;
+	const char		*name;
+
+	/* MAP related */
+	struct hw_manager	*hw;
+	struct list_head	pipeline_pool;
+	int			pipeline_cnt;
+
+	void			*plat_priv;
+};
+
+#define MC_QOS_OPEN	(1 << 0)
+#define MC_QOS_TOP_BIT	7
+#define MC_QOS_LEVEL	((1 << (MC_QOS_TOP_BIT+1)) - 1 - MC_QOS_OPEN)
+
+#define AGENT_PAD_MAX	5
+
+#define GID_AGENT_GROUP	0x19830915
+
+struct map_agent {
+	struct v4l2_subdev	subdev;
+	struct media_pad	pads[AGENT_PAD_MAX];
+	int			pad_vdev;
+	int			pads_cnt;
+	struct v4l2_mbus_framefmt	fmt_hw[AGENT_PAD_MAX];
+	struct v4l2_ctrl_handler	ctrl_handler;
+	int			ctrl_cnt;
+	struct hw_agent		hw;
+	/* point to the driver specific structure that contains this agent*/
+	void			*drv_priv;
+	struct map_manager	*manager;
+	struct map_pipeline	*pipeline;
+
+	/* It's possible that one agent be used by more than one pipeline,
+	 * following data structure helps manage such use case */
+	spinlock_t		user_lock;	/* lock of user_* below */
+	unsigned long		user_map;
+
+	struct map_agent_ops	*ops;
+
+	/* Work-arounds for isp_video, will be removed in final solution */
+	const struct vnode_ops	*vops;
+	enum isp_video_type video_type;
+};
+
+struct map_agent_ops {
+	/* Called before register to manager */
+	int	(*add)(struct map_agent *agent);
+	/* Called after remove from manager */
+	void	(*remove)(struct map_agent *agent);
+	/* Called before add to pipeline */
+	int	(*open)(struct map_agent *agent);
+	/* Called after remove from pipeline */
+	void	(*close)(struct map_agent *agent);
+	/* Called upon pipeline stream on */
+	int	(*start)(struct map_agent *agent);
+	/* Called upon pipeline stream off */
+	void	(*stop)(struct map_agent *agent);
+};
+
+#define MC_PIPELINE_LEN_MAX	10
+
+enum pipeline_state {
+	MAP_PIPELINE_DEAD = 0,
+	MAP_PIPELINE_IDLE,
+	MAP_PIPELINE_BUSY,
+};
+
+struct map_pipeline {
+	struct media_pipeline	mpipe;
+	struct list_head	hook;
+	u32			id;
+
+	struct media_entity	*def_src;
+	struct media_entity	*input;
+	struct map_vnode	output;
+	struct media_link	*route[MC_PIPELINE_LEN_MAX];
+	int			route_sz;
+	struct map_manager	*mngr;
+	int			drv_own:1; /* pipeline is owned by the driver */
+
+	enum pipeline_state	state;
+	struct mutex		st_lock;
+
+	struct mutex		fmt_lock; /* MUST hold this lock in G/S/T_FMT */
+};
+
+struct map_link_dscr {
+	union agent_id	*src_id;
+	union agent_id	*dst_id;
+	u16		src_pad;
+	u16		dst_pad;
+	u32		flags;
+};
+
+/* register an agent to manager */
+/* make sure following field is initialzed
+ * mc_agent::v4l2_subdev::ops
+ * mc_agent::v4l2_subdev::internal	optional
+ * mc_agent::v4l2_subdev::name
+ * mc_agent::v4l2_subdev::flags
+ * mc_agent::pads
+ * mc_agent::pads_cnt;
+ * mc_agent::ctrl_handler		optional
+ * mc_agent::ctrl_cnt			optional
+ * mc_agent::map_agent::dev_id
+ * mc_agent::map_agent::type
+ * mc_agent::map_agent::id
+ * mc_agent::map_agent::ops */
+int map_agent_register(struct map_agent *agent);
+struct map_vnode *agent_get_video(struct map_agent *agent);
+struct map_agent *video_get_agent(struct map_vnode *video);
+int map_agent_set_format(struct map_agent *agent,
+					struct v4l2_subdev_format *fmt);
+int map_agent_get_format(struct map_agent *agent,
+					struct v4l2_subdev_format *fmt);
+
+int map_pipeline_setup(struct map_pipeline *pipe);
+void map_pipeline_clean(struct map_pipeline *pipe);
+int map_pipeline_validate(struct map_pipeline *pipe);
+
+int map_pipeline_querycap(struct map_pipeline *pipeline,
+			struct v4l2_capability *cap);
+int map_pipeline_set_format(struct map_pipeline *pipeline,
+				struct v4l2_mbus_framefmt *fmt);
+int map_pipeline_get_format(struct map_pipeline *pipeline,
+				struct v4l2_mbus_framefmt *fmt);
+int map_pipeline_try_format(struct map_pipeline *pipeline,
+				struct v4l2_mbus_framefmt *fmt);
+int map_pipeline_set_stream(struct map_pipeline *, int enable);
+
+void map_manager_exit(struct map_manager *mngr);
+int map_manager_init(struct map_manager *mngr);
+int map_manager_attach_agents(struct map_manager *mngr);
+int map_manager_add_agent(struct map_agent *agent, struct map_manager *mngr);
+
+int map_create_links(struct map_manager *mngr, struct map_link_dscr *link,
+			int cnt);
+
+#define agent_to_mngr(agent) \
+	container_of((agent)->hw.mngr, struct map_manager, hw)
+
+#define subdev_has_fn(sd, o, f) ((sd) && (sd->ops) && (sd->ops->o) && \
+				(sd->ops->o->f))
+
+#endif
diff --git a/include/media/map_hw.h b/include/media/map_hw.h
new file mode 100644
index 00000000..d591a8a2
--- /dev/null
+++ b/include/media/map_hw.h
@@ -0,0 +1,268 @@
+#ifndef _MAP_HARDWARE_H
+#define _MAP_HARDWARE_H
+
+/* This file declears all the data structures to support hardware part of
+ * Manager-Agent-Pack model. */
+
+/* MAP camera model aims to provide a framework to realize a batch of camera
+ * driver solutions for a serial of SOCs, which use combinations of several
+ * same camera IP cores as the camera H/W solution. */
+
+/* SOC vendors may designe a family of SOC chips, which enclose different
+ * configurations of a serial of camera IP cores, in order to provide
+ * different capability of camera subsystem. Or these chips may expose
+ * different capability due to different SOC H/W limitation (bandwidth, etc)
+ */
+
+/* By the time MAP camera model is designed, camera H/W evolution arrives at
+ * an era when mobile camera is expected to provied at least two kind of
+ * capability: front camera should be power-friendly / quality-insensitive,
+ * back camera should be qulity-sensitive / fancy-featured / power-insensitive.
+ * This pushes SOC designers to carefully breakdown camera controller to
+ * several agents, and make them configurable to formup different H/W pipelines,
+ * so that these H/W pipeline has different power / performace attributes.
+ * Or, SOC designers provide more than one carefully designed camera controller,
+ * each with different power / performance, so as to meet the various request.
+ */
+
+/* MediaController is designed to track this trend, so S/W can use concept
+ * such as "entity", "pipeline" to describe the corresponding H/W concepts.
+ */
+
+/* MAP Camera Model push this effort one step further, to help camera driver
+ * designers manage the power/clock/quality of each agents and implement
+ * the multifarious use case */
+
+#include <linux/io.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+
+#define MAX_AGENT_PER_SYSTEM	20
+#define MAX_AGENT_PER_EVENT	10
+#define MAX_CLOCK_PER_AGENT	5
+
+enum map_agent_type {
+	MAP_AGENT_NONE	= 0,
+	MAP_AGENT_NORMAL,
+	MAP_AGENT_DMA_OUT,
+	MAP_AGENT_DMA_IN,
+	MAP_AGENT_SENSOR,
+};
+
+enum hw_res_type {
+	MAP_RES_IO = 0,
+	MAP_RES_MEM,
+	MAP_RES_IRQ,
+	MAP_RES_DMA,
+	MAP_RES_BUS,
+	MAP_RES_CLK,
+	MAP_RES_END,
+};
+
+struct hw_agent;
+struct hw_manager;
+
+struct hw_agent_ops {
+	/* Called in H/W initialize */
+	int	(*init)(struct hw_agent *agent);
+	/* Called before H/W destroy */
+	void	(*clean)(struct hw_agent *agent);
+	/* Called upon H/W enable/disable, used to set clock rate, etc*/
+	int	(*set_power)(struct hw_agent *agent, int level);
+	int	(*set_clock)(struct hw_agent *agent, int rate);
+	/* Called upon H/W function start (pipeline enable) */
+	int	(*open)(struct hw_agent *agent);
+	/* Called upon H/W function stop (pipeline disable) */
+	void	(*close)(struct hw_agent *agent);
+	/* Called upon H/W QoS update (ie: resolution change) */
+	int	(*set_qos)(struct hw_agent *agent, int qos_id);
+};
+
+union agent_id {
+	struct {
+		u8	dev_type; /* What kind of device own this mod? */
+		u8	dev_id; /* Which device instance owns it? */
+		u8	mod_type; /* H/W mod type */
+		u8	mod_id; /* H/W instance ID */
+	};
+	int	ident;
+};
+
+struct hw_res_req {
+	enum hw_res_type	type;	/* Xlate from pdev::res::type*/
+	int			id;
+	/* Pointer to tell manager how to dispatch this resource to agent */
+	/* For MAP_RES_MEM, it's the agent's offset from device base address*/
+	void *priv;
+};
+
+/* Data structure to describe each H/W agent, which can be part of a
+ * or an entire camera IP core */
+struct hw_agent {
+	union agent_id		id;
+	char			*name;
+	struct hw_manager	*mngr;
+
+	/* platform resource */
+	struct hw_res_req	*req_list;
+	void __iomem		*reg_base;
+	u32			irq_num;
+	struct clk		*clock[MAX_CLOCK_PER_AGENT];
+	int			clock_cnt;
+
+	int		pwrcnt;
+	struct mutex	mux_lock;	/* lock of HW reg/clock/power/qos/refcnt
+					 * between irq and process */
+	void		*plat_priv;	/* point to platform specific data */
+	struct hw_agent_ops	*ops;
+};
+
+struct hw_resrc {
+	const char		*name;	/* platform_device::resource::name*/
+	struct device		*dev;
+	int			type;	/* Xlate from pdev::res::type*/
+	int			id;
+	union agent_id		mask;	/* only allocate within mask */
+	u32			base;
+	u32			size;
+	struct list_head	hook;	/* hook for manager::resrc_pool */
+	void			*priv;	/* private pointer to none-standard
+					 * data types that will be passed to
+					 * resource handler */
+	void			*handle;
+	int			refcnt;
+};
+
+struct hw_manager {
+	struct list_head	resrc_pool;
+	struct hw_agent	*agent_addr[MAX_AGENT_PER_SYSTEM];
+	int			(*get_slot)(union agent_id);
+	void			*drv_priv;
+};
+
+struct hw_event;
+typedef int __must_check (*event_handler_t)\
+	(struct hw_agent *receiver, struct hw_event *event);
+
+struct hw_dispatch_entry {
+	struct hw_agent	*agent;
+	event_handler_t	handler;
+};
+/* event us used to provide a tricky method, to send messages between agents,
+ * could be useful for irq dispatching / agent behavior dispatching, etc */
+struct hw_event {
+	const char	*name;	/* event of this name */
+	const char	*owner_name;
+	struct hw_agent	*owner; /* sender agent */
+	u32		type;	/* event type, could be irq number */
+	u32		id;	/* event id as allocated by manager */
+	struct hw_dispatch_entry	dispatch_list[MAX_AGENT_PER_EVENT];
+	void		*msg;	/* event message */
+};
+
+struct hw_resrc *hw_res_register(struct device *dev,
+	struct resource *res, struct hw_manager *mngr, const char *name,
+	union agent_id mask, int res_id, void *handle, void *priv);
+int hw_res_dispatch(struct hw_manager *mngr);
+void hw_res_withdraw(struct hw_manager *mngr);
+
+int hw_agent_register(struct hw_agent *agent, struct hw_manager *mngr);
+void hw_agent_unregister(struct hw_agent *agent, struct hw_manager *mngr);
+struct hw_agent *hw_agent_find(struct hw_manager *mngr, union agent_id id);
+int hw_agent_init_default(struct hw_agent *agent);
+
+static inline int hw_event_subscribe(struct hw_event *event,
+					struct hw_agent *agent,
+					event_handler_t handler)
+{
+	struct hw_dispatch_entry *item = event->dispatch_list;
+	int i;
+	/* Find a free slot to register the agent */
+	for (i = 0; i < MAX_AGENT_PER_EVENT; i++, item++) {
+		if (item->agent == NULL) {
+			item->agent = agent;
+			item->handler = handler;
+			return 0;
+		}
+	}
+	return -ENOMEM;
+}
+static inline int hw_event_unsubscribe(struct hw_event *event,
+					struct hw_agent *agent)
+{
+	struct hw_dispatch_entry *item = event->dispatch_list;
+	int i, ret = -EINVAL;
+
+	for (i = 0; i < MAX_AGENT_PER_EVENT; i++, item++) {
+		if (item->agent == agent) {
+			item->agent = NULL;
+			item->handler = NULL;
+			ret = 0;
+		}
+	}
+	return ret;
+}
+static inline struct hw_event *hw_local_event_find(struct hw_agent *agent,
+					const char *name)
+{
+	struct hw_resrc *res;
+	/* find event on local IP */
+	list_for_each_entry(res, &agent->mngr->resrc_pool, hook) {
+		if ((agent->id.ident == (res->mask.ident & agent->id.ident))
+			&& (res->type == MAP_RES_IRQ)
+			&& (res->name) && strlen(res->name) && name
+			&& (!strcmp(res->name, name)))
+			return res->priv;
+	}
+	return NULL;
+}
+int hw_event_dispatch(struct hw_agent *sender, struct hw_event *event);
+
+int hw_manager_init(struct hw_manager *mngr);
+void hw_manager_clean(struct hw_manager *mngr);
+
+/* Helper functions */
+int hw_tune_power(struct hw_agent *agent, int level);
+int hw_enable(struct hw_agent *agent);
+void hw_disable(struct hw_agent *agent);
+
+/* MAP topology setup process:
+ * 1> use probe function of a common platform_device to breakdown an camera
+ *    H/W IP core into several agent
+ * 2> each agent driver is then invoked by breakdown function to register
+ *    itself to the agent list.
+ * 3> Pipeline manager, which holes all the knowledge to describe the topology
+ *    and setup/enable/disable/destroy a pipeline, is then initialized, and
+ *    setup a default pipeline to accomodate legacy V4L2 behavior
+ * 4> Pipeline manager accept requests to change/add/remove pipeline, and
+ *    manipulate each agent according to input. Each agent is not
+ *    aware of the existance of pipeline.
+ */
+static inline u32 agent_read(struct hw_agent *agent, const u32 addr)
+{
+	return readl(agent->reg_base + addr);
+}
+
+static inline void agent_write(struct hw_agent *agent,
+				const u32 addr, const u32 value)
+{
+	writel(value, agent->reg_base + addr);
+}
+
+static inline void agent_set(struct hw_agent *agent,
+				const u32 addr, const u32 mask)
+{
+	u32 val = readl(agent->reg_base + addr);
+	val |= mask;
+	writel(val, agent->reg_base + addr);
+}
+
+static inline void agent_clr(struct hw_agent *agent,
+				const u32 addr, const u32 mask)
+{
+	u32 val = readl(agent->reg_base + addr);
+	val &= ~mask;
+	writel(val, agent->reg_base + addr);
+}
+
+#endif
diff --git a/include/media/map_vnode.h b/include/media/map_vnode.h
new file mode 100644
index 00000000..12378244
--- /dev/null
+++ b/include/media/map_vnode.h
@@ -0,0 +1,81 @@
+#ifndef _MAP_VIDEO_DEVICE_H
+#define _MAP_VIDEO_DEVICE_H
+
+#include <media/videobuf2-core.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+#include <media/videobuf2-core.h>
+
+enum map_vnode_state {
+	MAP_VNODE_DETACH = 0,
+	MAP_VNODE_STANDBY,
+	MAP_VNODE_STREAM,
+};
+
+struct isp_format_convert_info {
+	enum v4l2_mbus_pixelcode code;
+	u32 pixelformat;
+	unsigned int bpp;
+	unsigned int num_planes;
+};
+
+struct map_vnode {
+	struct video_device	vdev;	/* has entity */
+
+	/* buffer */
+	spinlock_t		vb_lock;
+	struct list_head	idle_buf;
+	struct list_head	busy_buf;
+	u8			idle_buf_cnt;
+	u8			busy_buf_cnt;
+	u16			min_buf_cnt;
+	struct vb2_alloc_ctx	*alloc_ctx;
+	struct vb2_queue	vq;
+	enum v4l2_buf_type	buf_type;
+
+	/* H/W and MC */
+	struct map_pipeline	*pipeline;
+	struct media_pad	pad;
+	const struct vnode_ops	*ops;
+
+	/* state and pipeline-video coherency */
+	struct mutex		st_lock;
+	enum map_vnode_state	state;
+
+	struct mutex		vdev_lock;	/* lock for vdev */
+	struct v4l2_format	format;		/* internal format cache */
+};
+
+struct vnode_ops {
+	int(*qbuf_notify)(struct map_vnode *video);
+	int(*stream_on_notify)(struct map_vnode *video);
+	int(*stream_off_notify)(struct map_vnode *video);
+};
+
+struct map_videobuf {
+	struct vb2_buffer	vb;
+	dma_addr_t		paddr[VIDEO_MAX_PLANES];
+	struct list_head	hook;
+};
+
+struct map_format_desc {
+	enum v4l2_mbus_pixelcode code;
+	u32 pixelformat;
+	unsigned int bpp;
+	unsigned int num_planes;
+};
+
+#define ALIGN_SIZE	(cache_line_size())
+#define ALIGN_MASK	(ALIGN_SIZE - 1)
+
+int map_vnode_add(struct map_vnode *vnode, struct v4l2_device *vdev,
+			int dir, int min_buf, int vdev_nr);
+void map_vnode_remove(struct map_vnode *vdev);
+/* Should be called upon every IRQ, and before streamon. */
+/* First fetch full buffer from DMA-busy queue,
+ * if there is enough buffer to susutain DMA. Then move a idle buffer to busy
+ * queue if any. The function will access idle queue and busy queue with a lock
+ * hold */
+struct map_videobuf *map_vnode_xchg_buffer(struct map_vnode *vnode,
+						bool deliver, bool discard);
+#endif
diff --git a/include/media/mrvl-camera.h b/include/media/mrvl-camera.h
new file mode 100644
index 00000000..b177ded9
--- /dev/null
+++ b/include/media/mrvl-camera.h
@@ -0,0 +1,130 @@
+#ifndef _MARVELL_CAMERA_H_
+#define _MARVELL_CAMERA_H_
+
+#include <linux/delay.h>
+#include <media/soc_camera.h>
+
+/* Sensor installation related */
+enum {
+	SENSOR_USED		= (1 << 31),
+	SENSOR_UNUSED		= 0,
+	SENSOR_POS_LEFT		= (1 << 2),
+	SENSOR_POS_RIGHT	= 0,
+	SENSOR_POS_FRONT	= (1 << 1),
+	SENSOR_POS_BACK		= 0,
+	SENSOR_RES_HIGH		= (1 << 0),
+	SENSOR_RES_LOW		= 0,
+};
+
+struct sensor_board_data {
+	/* Sensor connector install orientation */
+	int mount_pos;
+
+	/* Data bus H/W interface */
+	enum v4l2_mbus_type bus_type;
+	int bus_flag;		/* Mediabus defined flags */
+
+	/* Pointer to platform data structure */
+	void *plat;
+
+	/* Per sensor MIPI config */
+	int dphy[3];		/* DPHY: CSI2_DPHY3, CSI2_DPHY5, CSI2_DPHY6 */
+	int dphy3_algo;		/* Exist 2 algos for calculate CSI2_DPHY3 */
+	int mipi_enabled;	/* MIPI enabled flag */
+
+	/* Board specific function pointers, I.E. LED/flash/tuner/lens */
+	/* The handle to control "coupled" flash chip */
+	int (*v4l2_flash_if)(void *ctrl, bool op);
+	/* TODO: add more function handler to control "coupled" actuators */
+};
+
+/* MIPI related */
+/* Sensor MIPI behavior descriptor, sensor driver should pass it to controller
+ * driver, and let controller driver decide how to config its PHY registers */
+struct csi_dphy_desc {
+	u32 clk_mul;
+	u32 clk_div;	/* clock_lane_freq = input_clock * clk_mul / clk_div */
+	u32 clk_freq;	/* not suggest to use, maybe useful for legacy code */
+	u32 cl_prepare;	/* cl_* describes clock lane timing in the unit of ns */
+	u32 cl_zero;
+	u32 hs_prepare;	/* hs_* describes data LP to HS transition timing */
+	u32 hs_zero;	/* in the unit of clock lane period(DDR period) */
+	u32 nr_lane;	/* When set to 0, S/W will try to figure out a value */
+};
+
+static inline int csi2phy_desc_to_mbus_cfg(struct csi_dphy_desc *dsc,
+					struct v4l2_mbus_config *cfg)
+{
+	if (dsc == NULL)
+		return -EINVAL;
+
+	if ((dsc->nr_lane < 1) || (dsc->nr_lane > 4))
+		return -ERANGE;
+
+	cfg->type = V4L2_MBUS_CSI2;
+	cfg->flags = (V4L2_MBUS_CSI2_2_LANE << (dsc->nr_lane - 1));
+	return 0;
+}
+
+struct csi_dphy_calc {
+	char name[16];
+	int hs_termen_pos;
+	int hs_settle_pos;	/* 0~100 */
+};
+
+/* Controller driver PHY register data, maybe need to add more item for other
+ * controller type */
+struct csi_dphy_reg {
+	u16 cl_termen;
+	u16 cl_settle;
+	u16 cl_miss;
+	u16 hs_termen;
+	u16 hs_settle;
+	u16 hs_rx_to;
+	u16 lane;	/* When set to 0, S/W will try to figure out a value */
+	u16 vc;		/* Virtual channel */
+	u16 dt1;	/* Data type 1: For video or main data type */
+	u16 dt2;	/* Data type 2: For thumbnail or auxiliry data type */
+};
+
+/*
+ * Add macro definiton for sensor power.
+ * Plese note the POWER_OFF and POWER_ON
+ * value is fixed since in soc_camera.c
+ * the value is directly used.
+ */
+#define POWER_OFF	0
+#define POWER_ON	1
+#define POWER_SAVING	2
+#define POWER_RESTORE	3
+
+/*
+ * Add macro definiton for CCIC controller.
+ */
+#define MIPI_DISABLE	(0 << 1)
+#define MIPI_ENABLE	(1 << 1)
+
+/* V4L2 related */
+#define V4L2_CID_PRIVATE_FIRMWARE_DOWNLOAD \
+					(V4L2_CID_CAMERA_CLASS_BASE + 0x1000)
+#define V4L2_CID_PRIVATE_GET_MIPI_PHY \
+					(V4L2_CID_CAMERA_CLASS_BASE + 0x1001)
+
+/* sleep function for sensor power sequence, only provide 1ms precision */
+/* According to Documentation/timers/timers-howto.txt, we should choose *sleep
+ * family function according to the time:
+ * >= 20ms	msleep
+ * >= 10us	usleep
+ * for camera power usecase, we mostly need 1~2ms for power on/off sequence and
+ * 100~500us for software reset, no precision control below 100us is used,
+ * so sleep_range is good enough for us */
+#define cam_msleep(x) \
+do { \
+	unsigned int ms = (x); \
+	if (ms >= 20) \
+		msleep(ms); \
+	else \
+		usleep_range(ms*1000, ms*1000+100); \
+} while (0)
+
+#endif
diff --git a/include/media/soc_camera.h b/include/media/soc_camera.h
index cad374bd..bb75f1ce 100644
--- a/include/media/soc_camera.h
+++ b/include/media/soc_camera.h
@@ -35,6 +35,7 @@ struct soc_camera_device {
 	s32 user_height;
 	u32 bytesperline;		/* for padding, zero if unused */
 	u32 sizeimage;
+	u32 state;			/* state if soc camera formated */
 	enum v4l2_colorspace colorspace;
 	unsigned char iface;		/* Host number */
 	unsigned char devnum;		/* Device number per host */
@@ -56,6 +57,11 @@ struct soc_camera_device {
 	};
 };
 
+#define SOCAM_STATE_UNKNOWN	0
+#define SOCAM_STATE_STANDBY	1
+#define SOCAM_STATE_FORMATED	2
+#define SOCAM_STATE_STREAM	3
+
 struct soc_camera_host {
 	struct v4l2_device v4l2_dev;
 	struct list_head list;
diff --git a/include/media/v4l2-subdev.h b/include/media/v4l2-subdev.h
index f0f3358d..84f341be 100644
--- a/include/media/v4l2-subdev.h
+++ b/include/media/v4l2-subdev.h
@@ -172,6 +172,7 @@ struct v4l2_subdev_core_ops {
 			       struct v4l2_event_subscription *sub);
 	int (*unsubscribe_event)(struct v4l2_subdev *sd, struct v4l2_fh *fh,
 				 struct v4l2_event_subscription *sub);
+	int (*mmap)(struct v4l2_subdev *sd, struct vm_area_struct *vma);
 };
 
 /* s_radio: v4l device was opened in radio mode.
diff --git a/include/net/activity_stats.h b/include/net/activity_stats.h
new file mode 100644
index 00000000..10e4c150
--- /dev/null
+++ b/include/net/activity_stats.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2010 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Author: Mike Chan (mike@android.com)
+ */
+
+#ifndef __activity_stats_h
+#define __activity_stats_h
+
+#ifdef CONFIG_NET_ACTIVITY_STATS
+void activity_stats_update(void);
+#else
+#define activity_stats_update(void) {}
+#endif
+
+#endif /* _NET_ACTIVITY_STATS_H */
diff --git a/include/net/dst.h b/include/net/dst.h
index 8197eadc..f76722d5 100644
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@ -408,7 +408,8 @@ static inline void dst_confirm(struct dst_entry *dst)
 
 static inline struct neighbour *dst_neigh_lookup(const struct dst_entry *dst, const void *daddr)
 {
-	return dst->ops->neigh_lookup(dst, daddr);
+	struct neighbour *n = dst->ops->neigh_lookup(dst, daddr);
+	return IS_ERR(n) ? NULL : n;
 }
 
 static inline void dst_link_failure(struct sk_buff *skb)
diff --git a/include/trace/events/cpufreq_interactive.h b/include/trace/events/cpufreq_interactive.h
new file mode 100644
index 00000000..951e6ca1
--- /dev/null
+++ b/include/trace/events/cpufreq_interactive.h
@@ -0,0 +1,112 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM cpufreq_interactive
+
+#if !defined(_TRACE_CPUFREQ_INTERACTIVE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_CPUFREQ_INTERACTIVE_H
+
+#include <linux/tracepoint.h>
+
+DECLARE_EVENT_CLASS(set,
+	TP_PROTO(u32 cpu_id, unsigned long targfreq,
+	         unsigned long actualfreq),
+	TP_ARGS(cpu_id, targfreq, actualfreq),
+
+	TP_STRUCT__entry(
+	    __field(          u32, cpu_id    )
+	    __field(unsigned long, targfreq   )
+	    __field(unsigned long, actualfreq )
+	   ),
+
+	TP_fast_assign(
+	    __entry->cpu_id = (u32) cpu_id;
+	    __entry->targfreq = targfreq;
+	    __entry->actualfreq = actualfreq;
+	),
+
+	TP_printk("cpu=%u targ=%lu actual=%lu",
+	      __entry->cpu_id, __entry->targfreq,
+	      __entry->actualfreq)
+);
+
+DEFINE_EVENT(set, cpufreq_interactive_setspeed,
+	TP_PROTO(u32 cpu_id, unsigned long targfreq,
+	     unsigned long actualfreq),
+	TP_ARGS(cpu_id, targfreq, actualfreq)
+);
+
+DECLARE_EVENT_CLASS(loadeval,
+	    TP_PROTO(unsigned long cpu_id, unsigned long load,
+		     unsigned long curtarg, unsigned long curactual,
+		     unsigned long newtarg),
+		    TP_ARGS(cpu_id, load, curtarg, curactual, newtarg),
+
+	    TP_STRUCT__entry(
+		    __field(unsigned long, cpu_id    )
+		    __field(unsigned long, load      )
+		    __field(unsigned long, curtarg   )
+		    __field(unsigned long, curactual )
+		    __field(unsigned long, newtarg   )
+	    ),
+
+	    TP_fast_assign(
+		    __entry->cpu_id = cpu_id;
+		    __entry->load = load;
+		    __entry->curtarg = curtarg;
+		    __entry->curactual = curactual;
+		    __entry->newtarg = newtarg;
+	    ),
+
+	    TP_printk("cpu=%lu load=%lu cur=%lu actual=%lu targ=%lu",
+		      __entry->cpu_id, __entry->load, __entry->curtarg,
+		      __entry->curactual, __entry->newtarg)
+);
+
+DEFINE_EVENT(loadeval, cpufreq_interactive_target,
+	    TP_PROTO(unsigned long cpu_id, unsigned long load,
+		     unsigned long curtarg, unsigned long curactual,
+		     unsigned long newtarg),
+	    TP_ARGS(cpu_id, load, curtarg, curactual, newtarg)
+);
+
+DEFINE_EVENT(loadeval, cpufreq_interactive_already,
+	    TP_PROTO(unsigned long cpu_id, unsigned long load,
+		     unsigned long curtarg, unsigned long curactual,
+		     unsigned long newtarg),
+	    TP_ARGS(cpu_id, load, curtarg, curactual, newtarg)
+);
+
+DEFINE_EVENT(loadeval, cpufreq_interactive_notyet,
+	    TP_PROTO(unsigned long cpu_id, unsigned long load,
+		     unsigned long curtarg, unsigned long curactual,
+		     unsigned long newtarg),
+	    TP_ARGS(cpu_id, load, curtarg, curactual, newtarg)
+);
+
+TRACE_EVENT(cpufreq_interactive_boost,
+	    TP_PROTO(const char *s),
+	    TP_ARGS(s),
+	    TP_STRUCT__entry(
+		    __string(s, s)
+	    ),
+	    TP_fast_assign(
+		    __assign_str(s, s);
+	    ),
+	    TP_printk("%s", __get_str(s))
+);
+
+TRACE_EVENT(cpufreq_interactive_unboost,
+	    TP_PROTO(const char *s),
+	    TP_ARGS(s),
+	    TP_STRUCT__entry(
+		    __string(s, s)
+	    ),
+	    TP_fast_assign(
+		    __assign_str(s, s);
+	    ),
+	    TP_printk("%s", __get_str(s))
+);
+
+#endif /* _TRACE_CPUFREQ_INTERACTIVE_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/include/trace/events/power.h b/include/trace/events/power.h
index cae9a94f..243c677c 100644
--- a/include/trace/events/power.h
+++ b/include/trace/events/power.h
@@ -65,6 +65,40 @@ TRACE_EVENT(machine_suspend,
 	TP_printk("state=%lu", (unsigned long)__entry->state)
 );
 
+DECLARE_EVENT_CLASS(wakeup_source,
+
+	TP_PROTO(const char *name, unsigned int state),
+
+	TP_ARGS(name, state),
+
+	TP_STRUCT__entry(
+		__string(       name,           name            )
+		__field(        u64,            state           )
+	),
+
+	TP_fast_assign(
+		__assign_str(name, name);
+		__entry->state = state;
+	),
+
+	TP_printk("%s state=0x%lx", __get_str(name),
+		(unsigned long)__entry->state)
+);
+
+DEFINE_EVENT(wakeup_source, wakeup_source_activate,
+
+	TP_PROTO(const char *name, unsigned int state),
+
+	TP_ARGS(name, state)
+);
+
+DEFINE_EVENT(wakeup_source, wakeup_source_deactivate,
+
+	TP_PROTO(const char *name, unsigned int state),
+
+	TP_ARGS(name, state)
+);
+
 #ifdef CONFIG_EVENT_POWER_TRACING_DEPRECATED
 
 /*
@@ -204,6 +238,25 @@ DEFINE_EVENT(clock, clock_set_rate,
 	TP_ARGS(name, state, cpu_id)
 );
 
+TRACE_EVENT(clock_set_parent,
+
+	TP_PROTO(const char *name, const char *parent_name),
+
+	TP_ARGS(name, parent_name),
+
+	TP_STRUCT__entry(
+		__string(       name,           name            )
+		__string(       parent_name,    parent_name     )
+	),
+
+	TP_fast_assign(
+		__assign_str(name, name);
+		__assign_str(parent_name, parent_name);
+	),
+
+	TP_printk("%s parent=%s", __get_str(name), __get_str(parent_name))
+);
+
 /*
  * The power domain events are used for power domains transitions
  */
diff --git a/include/video/mmpdisp_export_funcs.h b/include/video/mmpdisp_export_funcs.h
new file mode 100644
index 00000000..b4ec6544
--- /dev/null
+++ b/include/video/mmpdisp_export_funcs.h
@@ -0,0 +1,62 @@
+/*
+ * linux/include/video/mmpdisp_export_funcs.h
+ * Header file for Marvell MMP Display Controller
+ *
+ * Copyright (C) 2012 Marvell Technology Group Ltd.
+ * Authors: Zhou Zhu <zzhu3@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _MMPDISP_EXPORT_FUNC_H_
+#define _MMPDISP_EXPORT_FUNC_H_
+#define MMP_DISP_NO_UPSTREAM
+#if defined(CONFIG_MMP_DISP)
+
+static inline int disp_is_on(void)
+{
+	return 1;
+}
+
+static inline void disp_onoff(int onoff)
+{
+}
+
+
+static inline void disp_eofintr_onoff(int on)
+{
+}
+#elif defined(CONFIG_FB_PXA168)
+#include <mach/pxa168fb.h>
+extern atomic_t displayon;
+static inline int disp_is_on(void)
+{
+	return atomic_read(&displayon);
+}
+
+static inline void disp_onoff(int flag)
+{
+	panel_dma_ctrl(flag);
+}
+
+static inline void disp_eofintr_onoff(int on)
+{
+	if (!on)
+		irq_mask_eof(0);
+	else
+		irq_unmask_eof(0);
+}
+#endif
+#endif	/* _MMPDISP_EXPORT_FUNC_ */
diff --git a/init/Kconfig b/init/Kconfig
index 6cfd71d0..e8148f91 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -953,6 +953,12 @@ config SYSCTL
 config ANON_INODES
 	bool
 
+config PANIC_TIMEOUT
+	int "Default panic timeout"
+	default 0
+	help
+	  Set default panic timeout.
+
 menuconfig EXPERT
 	bool "Configure standard kernel features (expert users)"
 	# Unhide debug options, to make the on-by-default options visible
@@ -1012,6 +1018,14 @@ config KALLSYMS_ALL
 
 	   Say N unless you really need all symbols.
 
+config CGITINFO
+	 bool "Create git info for current branch"
+	 default y
+	 help
+	   Say Y here to let the kernel save git information. This increases
+	   the size of the kernel somewhat, as all infos have to be loaded into
+	   the kernel image.
+
 config HOTPLUG
 	bool "Support for hot-pluggable devices" if EXPERT
 	default y
diff --git a/init/main.c b/init/main.c
index b08c5f75..d55f8d24 100644
--- a/init/main.c
+++ b/init/main.c
@@ -501,7 +501,7 @@ asmlinkage void __init start_kernel(void)
 	setup_per_cpu_areas();
 	smp_prepare_boot_cpu();	/* arch-specific boot-cpu hooks */
 
-	build_all_zonelists(NULL);
+	build_all_zonelists(NULL, NULL);
 	page_alloc_init();
 
 	printk(KERN_NOTICE "Kernel command line: %s\n", boot_command_line);
diff --git a/kernel/Makefile b/kernel/Makefile
index cb41b954..d2bb4bbf 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_PROVE_LOCKING) += spinlock.o
 obj-$(CONFIG_UID16) += uid16.o
 obj-$(CONFIG_MODULES) += module.o
 obj-$(CONFIG_KALLSYMS) += kallsyms.o
+obj-$(CONFIG_CGITINFO) += gitinfo.o
 obj-$(CONFIG_BSD_PROCESS_ACCT) += acct.o
 obj-$(CONFIG_KEXEC) += kexec.o
 obj-$(CONFIG_BACKTRACE_SELF_TEST) += backtracetest.o
@@ -127,3 +128,9 @@ quiet_cmd_timeconst  = TIMEC   $@
 targets += timeconst.h
 $(obj)/timeconst.h: $(src)/timeconst.pl FORCE
 	$(call if_changed,timeconst)
+
+targets += gitinfo.S
+quiet_cmd_cgitinfo = CGIT    $@
+      cmd_cgitinfo = $(CGITINFO) > $@
+$(obj)/gitinfo.S: FORCE
+	$(call cmd,cgitinfo)
diff --git a/kernel/cpu.c b/kernel/cpu.c
index 2060c6e5..bb7d4f95 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -361,7 +361,7 @@ int __cpuinit cpu_up(unsigned int cpu)
 
 	if (pgdat->node_zonelists->_zonerefs->zone == NULL) {
 		mutex_lock(&zonelists_mutex);
-		build_all_zonelists(NULL);
+		build_all_zonelists(NULL, NULL);
 		mutex_unlock(&zonelists_mutex);
 	}
 #endif
@@ -668,3 +668,23 @@ void init_cpu_online(const struct cpumask *src)
 {
 	cpumask_copy(to_cpumask(cpu_online_bits), src);
 }
+
+static ATOMIC_NOTIFIER_HEAD(idle_notifier);
+
+void idle_notifier_register(struct notifier_block *n)
+{
+	atomic_notifier_chain_register(&idle_notifier, n);
+}
+EXPORT_SYMBOL_GPL(idle_notifier_register);
+
+void idle_notifier_unregister(struct notifier_block *n)
+{
+	atomic_notifier_chain_unregister(&idle_notifier, n);
+}
+EXPORT_SYMBOL_GPL(idle_notifier_unregister);
+
+void idle_notifier_call_chain(unsigned long val)
+{
+	atomic_notifier_call_chain(&idle_notifier, val, NULL);
+}
+EXPORT_SYMBOL_GPL(idle_notifier_call_chain);
diff --git a/kernel/fork.c b/kernel/fork.c
index 81633337..bc3398ee 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -158,6 +158,9 @@ struct kmem_cache *vm_area_cachep;
 /* SLAB cache for mm_struct structures (tsk->mm) */
 static struct kmem_cache *mm_cachep;
 
+/* Notifier list called when a task struct is freed */
+static ATOMIC_NOTIFIER_HEAD(task_free_notifier);
+
 static void account_kernel_stack(struct thread_info *ti, int account)
 {
 	struct zone *zone = page_zone(virt_to_page(ti));
@@ -188,6 +191,18 @@ static inline void put_signal_struct(struct signal_struct *sig)
 		free_signal_struct(sig);
 }
 
+int task_free_register(struct notifier_block *n)
+{
+	return atomic_notifier_chain_register(&task_free_notifier, n);
+}
+EXPORT_SYMBOL(task_free_register);
+
+int task_free_unregister(struct notifier_block *n)
+{
+	return atomic_notifier_chain_unregister(&task_free_notifier, n);
+}
+EXPORT_SYMBOL(task_free_unregister);
+
 void __put_task_struct(struct task_struct *tsk)
 {
 	WARN_ON(!tsk->exit_state);
@@ -199,6 +214,7 @@ void __put_task_struct(struct task_struct *tsk)
 	delayacct_tsk_free(tsk);
 	put_signal_struct(tsk->signal);
 
+	atomic_notifier_call_chain(&task_free_notifier, 0, tsk);
 	if (!profile_handoff_task(tsk))
 		free_task(tsk);
 }
@@ -677,7 +693,8 @@ struct mm_struct *mm_access(struct task_struct *task, unsigned int mode)
 
 	mm = get_task_mm(task);
 	if (mm && mm != current->mm &&
-			!ptrace_may_access(task, mode)) {
+			!ptrace_may_access(task, mode) &&
+			!capable(CAP_SYS_RESOURCE)) {
 		mmput(mm);
 		mm = ERR_PTR(-EACCES);
 	}
diff --git a/kernel/futex.c b/kernel/futex.c
index e2b0fb9a..03a70447 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -840,6 +840,9 @@ static void wake_futex(struct futex_q *q)
 {
 	struct task_struct *p = q->task;
 
+	if (WARN(q->pi_state || q->rt_waiter, "refusing to wake PI futex\n"))
+		return;
+
 	/*
 	 * We set q->lock_ptr = NULL _before_ we wake up the task. If
 	 * a non-futex wake up happens on another CPU then the task
@@ -1075,6 +1078,10 @@ retry_private:
 
 	plist_for_each_entry_safe(this, next, head, list) {
 		if (match_futex (&this->key, &key1)) {
+			if (this->pi_state || this->rt_waiter) {
+				ret = -EINVAL;
+				goto out_unlock;
+			}
 			wake_futex(this);
 			if (++ret >= nr_wake)
 				break;
@@ -1087,6 +1094,10 @@ retry_private:
 		op_ret = 0;
 		plist_for_each_entry_safe(this, next, head, list) {
 			if (match_futex (&this->key, &key2)) {
+				if (this->pi_state || this->rt_waiter) {
+					ret = -EINVAL;
+					goto out_unlock;
+				}
 				wake_futex(this);
 				if (++op_ret >= nr_wake2)
 					break;
@@ -1095,6 +1106,7 @@ retry_private:
 		ret += op_ret;
 	}
 
+out_unlock:
 	double_unlock_hb(hb1, hb2);
 out_put_keys:
 	put_futex_key(&key2);
@@ -1384,9 +1396,13 @@ retry_private:
 		/*
 		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
 		 * be paired with each other and no other futex ops.
+		 *
+		 * We should never be requeueing a futex_q with a pi_state,
+		 * which is awaiting a futex_unlock_pi().
 		 */
 		if ((requeue_pi && !this->rt_waiter) ||
-		    (!requeue_pi && this->rt_waiter)) {
+		    (!requeue_pi && this->rt_waiter) ||
+		    this->pi_state) {
 			ret = -EINVAL;
 			break;
 		}
diff --git a/kernel/irq/handle.c b/kernel/irq/handle.c
index bdb18032..f63e9acd 100644
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@ -17,7 +17,9 @@
 #include <linux/kernel_stat.h>
 
 #include <trace/events/irq.h>
-
+#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
+#include <mach/sec_debug.h>
+#endif
 #include "internals.h"
 
 /**
@@ -137,10 +139,15 @@ handle_irq_event_percpu(struct irq_desc *desc, struct irqaction *action)
 
 	do {
 		irqreturn_t res;
-
+#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
+		sec_debug_irq_log(irq, (void *)action->handler, 1);
+#endif
 		trace_irq_handler_entry(irq, action);
 		res = action->handler(irq, action->dev_id);
 		trace_irq_handler_exit(irq, action, res);
+#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
+		sec_debug_irq_log(irq, (void *)action->handler, 2);
+#endif
 
 		if (WARN_ONCE(!irqs_disabled(),"irq %u handler %pF enabled interrupts\n",
 			      irq, action->handler))
diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 15e53b17..fe4b09cf 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -104,8 +104,13 @@ int check_wakeup_irqs(void)
 
 	for_each_irq_desc(irq, desc) {
 		if (irqd_is_wakeup_set(&desc->irq_data)) {
-			if (desc->istate & IRQS_PENDING)
+			if (desc->istate & IRQS_PENDING) {
+				pr_info("Wakeup IRQ %d %s pending, suspend aborted\n",
+					irq,
+					desc->action && desc->action->name ?
+					desc->action->name : "");
 				return -EBUSY;
+			}
 			continue;
 		}
 		/*
diff --git a/kernel/kexec.c b/kernel/kexec.c
index 4e2e472f..e422e9ce 100644
--- a/kernel/kexec.c
+++ b/kernel/kexec.c
@@ -936,7 +936,6 @@ struct kimage *kexec_image;
 struct kimage *kexec_crash_image;
 
 static DEFINE_MUTEX(kexec_mutex);
-
 SYSCALL_DEFINE4(kexec_load, unsigned long, entry, unsigned long, nr_segments,
 		struct kexec_segment __user *, segments, unsigned long, flags)
 {
@@ -1078,8 +1077,11 @@ asmlinkage long compat_sys_kexec_load(unsigned long entry,
 }
 #endif
 
+void __weak panic_flush(struct pt_regs *regs) { }
 void crash_kexec(struct pt_regs *regs)
 {
+	panic_flush(regs);
+
 	/* Take the kexec_mutex here to prevent sys_kexec_load
 	 * running on one cpu from replacing the crash kernel
 	 * we are using after a panic on a different cpu.
diff --git a/kernel/kthread.c b/kernel/kthread.c
index 3d3de633..b579af57 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -360,16 +360,12 @@ repeat:
 					struct kthread_work, node);
 		list_del_init(&work->node);
 	}
+	worker->current_work = work;
 	spin_unlock_irq(&worker->lock);
 
 	if (work) {
 		__set_current_state(TASK_RUNNING);
 		work->func(work);
-		smp_wmb();	/* wmb worker-b0 paired with flush-b1 */
-		work->done_seq = work->queue_seq;
-		smp_mb();	/* mb worker-b1 paired with flush-b0 */
-		if (atomic_read(&work->flushing))
-			wake_up_all(&work->done);
 	} else if (!freezing(current))
 		schedule();
 
@@ -378,6 +374,19 @@ repeat:
 }
 EXPORT_SYMBOL_GPL(kthread_worker_fn);
 
+/* insert @work before @pos in @worker */
+static void insert_kthread_work(struct kthread_worker *worker,
+			       struct kthread_work *work,
+			       struct list_head *pos)
+{
+	lockdep_assert_held(&worker->lock);
+
+	list_add_tail(&work->node, pos);
+	work->worker = worker;
+	if (likely(worker->task))
+		wake_up_process(worker->task);
+}
+
 /**
  * queue_kthread_work - queue a kthread_work
  * @worker: target kthread_worker
@@ -395,10 +404,7 @@ bool queue_kthread_work(struct kthread_worker *worker,
 
 	spin_lock_irqsave(&worker->lock, flags);
 	if (list_empty(&work->node)) {
-		list_add_tail(&work->node, &worker->work_list);
-		work->queue_seq++;
-		if (likely(worker->task))
-			wake_up_process(worker->task);
+		insert_kthread_work(worker, work, &worker->work_list);
 		ret = true;
 	}
 	spin_unlock_irqrestore(&worker->lock, flags);
@@ -406,6 +412,18 @@ bool queue_kthread_work(struct kthread_worker *worker,
 }
 EXPORT_SYMBOL_GPL(queue_kthread_work);
 
+struct kthread_flush_work {
+	struct kthread_work	work;
+	struct completion	done;
+};
+
+static void kthread_flush_work_fn(struct kthread_work *work)
+{
+	struct kthread_flush_work *fwork =
+		container_of(work, struct kthread_flush_work, work);
+	complete(&fwork->done);
+}
+
 /**
  * flush_kthread_work - flush a kthread_work
  * @work: work to flush
@@ -414,39 +432,37 @@ EXPORT_SYMBOL_GPL(queue_kthread_work);
  */
 void flush_kthread_work(struct kthread_work *work)
 {
-	int seq = work->queue_seq;
-
-	atomic_inc(&work->flushing);
+	struct kthread_flush_work fwork = {
+		KTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn),
+		COMPLETION_INITIALIZER_ONSTACK(fwork.done),
+	};
+	struct kthread_worker *worker;
+	bool noop = false;
 
-	/*
-	 * mb flush-b0 paired with worker-b1, to make sure either
-	 * worker sees the above increment or we see done_seq update.
-	 */
-	smp_mb__after_atomic_inc();
+retry:
+	worker = work->worker;
+	if (!worker)
+		return;
 
-	/* A - B <= 0 tests whether B is in front of A regardless of overflow */
-	wait_event(work->done, seq - work->done_seq <= 0);
-	atomic_dec(&work->flushing);
+	spin_lock_irq(&worker->lock);
+	if (work->worker != worker) {
+		spin_unlock_irq(&worker->lock);
+		goto retry;
+	}
 
-	/*
-	 * rmb flush-b1 paired with worker-b0, to make sure our caller
-	 * sees every change made by work->func().
-	 */
-	smp_mb__after_atomic_dec();
-}
-EXPORT_SYMBOL_GPL(flush_kthread_work);
+	if (!list_empty(&work->node))
+		insert_kthread_work(worker, &fwork.work, work->node.next);
+	else if (worker->current_work == work)
+		insert_kthread_work(worker, &fwork.work, worker->work_list.next);
+	else
+		noop = true;
 
-struct kthread_flush_work {
-	struct kthread_work	work;
-	struct completion	done;
-};
+	spin_unlock_irq(&worker->lock);
 
-static void kthread_flush_work_fn(struct kthread_work *work)
-{
-	struct kthread_flush_work *fwork =
-		container_of(work, struct kthread_flush_work, work);
-	complete(&fwork->done);
+	if (!noop)
+		wait_for_completion(&fwork.done);
 }
+EXPORT_SYMBOL_GPL(flush_kthread_work);
 
 /**
  * flush_kthread_worker - flush all current works on a kthread_worker
diff --git a/kernel/panic.c b/kernel/panic.c
index 9ed023b8..04a17868 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -27,13 +27,19 @@
 #define PANIC_TIMER_STEP 100
 #define PANIC_BLINK_SPD 18
 
+/* Machine specific panic information string */
+char *mach_panic_string;
+
 int panic_on_oops;
 static unsigned long tainted_mask;
 static int pause_on_oops;
 static int pause_on_oops_flag;
 static DEFINE_SPINLOCK(pause_on_oops_lock);
 
-int panic_timeout;
+#ifndef CONFIG_PANIC_TIMEOUT
+#define CONFIG_PANIC_TIMEOUT 0
+#endif
+int panic_timeout = CONFIG_PANIC_TIMEOUT;
 EXPORT_SYMBOL_GPL(panic_timeout);
 
 ATOMIC_NOTIFIER_HEAD(panic_notifier_list);
@@ -101,7 +107,7 @@ void panic(const char *fmt, ...)
 		dump_stack();
 #endif
 
-	/*
+        /*
 	 * If we have crashed and we have a crash kernel loaded let it handle
 	 * everything else.
 	 * Do we want to call this before we try to display a message?
@@ -375,6 +381,11 @@ late_initcall(init_oops_id);
 void print_oops_end_marker(void)
 {
 	init_oops_id();
+
+	if (mach_panic_string)
+		printk(KERN_WARNING "Board Information: %s\n",
+		       mach_panic_string);
+
 	printk(KERN_WARNING "---[ end trace %016llx ]---\n",
 		(unsigned long long)oops_id);
 }
@@ -475,4 +486,4 @@ static int __init oops_setup(char *s)
 		panic_on_oops = 1;
 	return 0;
 }
-early_param("oops", oops_setup);
+early_param("oops", oops_setup);
\ No newline at end of file
diff --git a/kernel/power/Makefile b/kernel/power/Makefile
index 66d808ec..8450b85d 100644
--- a/kernel/power/Makefile
+++ b/kernel/power/Makefile
@@ -9,5 +9,8 @@ obj-$(CONFIG_SUSPEND)		+= suspend.o
 obj-$(CONFIG_PM_TEST_SUSPEND)	+= suspend_test.o
 obj-$(CONFIG_HIBERNATION)	+= hibernate.o snapshot.o swap.o user.o \
 				   block_io.o
+obj-$(CONFIG_PM_AUTOSLEEP)	+= autosleep.o
+obj-$(CONFIG_PM_WAKELOCKS)	+= wakelock.o
+obj-$(CONFIG_SUSPEND_TIME)	+= suspend_time.o
 
 obj-$(CONFIG_MAGIC_SYSRQ)	+= poweroff.o
diff --git a/kernel/power/autosleep.c b/kernel/power/autosleep.c
new file mode 100644
index 00000000..7c5fa732
--- /dev/null
+++ b/kernel/power/autosleep.c
@@ -0,0 +1,128 @@
+/*
+ * kernel/power/autosleep.c
+ *
+ * Opportunistic sleep support.
+ *
+ * Copyright (C) 2012 Rafael J. Wysocki <rjw@sisk.pl>
+ */
+
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/pm_wakeup.h>
+
+#include "power.h"
+
+static suspend_state_t autosleep_state;
+static struct workqueue_struct *autosleep_wq;
+/*
+ * Note: it is only safe to mutex_lock(&autosleep_lock) if a wakeup_source
+ * is active, otherwise a deadlock with try_to_suspend() is possible.
+ * Alternatively mutex_lock_interruptible() can be used.  This will then fail
+ * if an auto_sleep cycle tries to freeze processes.
+ */
+static DEFINE_MUTEX(autosleep_lock);
+static struct wakeup_source *autosleep_ws;
+
+static void try_to_suspend(struct work_struct *work)
+{
+	unsigned int initial_count, final_count;
+
+	if (!pm_get_wakeup_count(&initial_count, true))
+		goto out;
+
+	mutex_lock(&autosleep_lock);
+
+	if (!pm_save_wakeup_count(initial_count)) {
+		mutex_unlock(&autosleep_lock);
+		goto out;
+	}
+
+	if (autosleep_state == PM_SUSPEND_ON) {
+		mutex_unlock(&autosleep_lock);
+		return;
+	}
+	if (autosleep_state >= PM_SUSPEND_MAX)
+		hibernate();
+	else
+		pm_suspend(autosleep_state);
+
+	mutex_unlock(&autosleep_lock);
+
+	if (!pm_get_wakeup_count(&final_count, false))
+		goto out;
+
+	/*
+	 * If the wakeup occured for an unknown reason, wait to prevent the
+	 * system from trying to suspend and waking up in a tight loop.
+	 */
+	if (final_count == initial_count)
+		schedule_timeout_uninterruptible(HZ / 2);
+
+ out:
+	queue_up_suspend_work();
+}
+
+static DECLARE_WORK(suspend_work, try_to_suspend);
+
+void queue_up_suspend_work(void)
+{
+	if (!work_pending(&suspend_work) && autosleep_state > PM_SUSPEND_ON)
+		queue_work(autosleep_wq, &suspend_work);
+}
+
+suspend_state_t pm_autosleep_state(void)
+{
+	return autosleep_state;
+}
+
+int pm_autosleep_lock(void)
+{
+	return mutex_lock_interruptible(&autosleep_lock);
+}
+
+void pm_autosleep_unlock(void)
+{
+	mutex_unlock(&autosleep_lock);
+}
+
+int pm_autosleep_set_state(suspend_state_t state)
+{
+
+#ifndef CONFIG_HIBERNATION
+	if (state >= PM_SUSPEND_MAX)
+		return -EINVAL;
+#endif
+
+	__pm_stay_awake(autosleep_ws);
+
+	mutex_lock(&autosleep_lock);
+
+	autosleep_state = state;
+
+	__pm_relax(autosleep_ws);
+
+	if (state > PM_SUSPEND_ON) {
+		print_active_wakeup_events();
+		pm_wakep_autosleep_enabled(true);
+		queue_up_suspend_work();
+	} else {
+		pm_wakep_autosleep_enabled(false);
+	}
+
+	mutex_unlock(&autosleep_lock);
+	return 0;
+}
+
+int __init pm_autosleep_init(void)
+{
+	autosleep_ws = wakeup_source_register("autosleep");
+	if (!autosleep_ws)
+		return -ENOMEM;
+
+	autosleep_wq = alloc_ordered_workqueue("autosleep", 0);
+	if (autosleep_wq)
+		return 0;
+
+	wakeup_source_unregister(autosleep_ws);
+	return -ENOMEM;
+}
diff --git a/kernel/power/main.c b/kernel/power/main.c
index 1c12581f..428f8a03 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -269,8 +269,7 @@ static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
 	return (s - buf);
 }
 
-static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
-			   const char *buf, size_t n)
+static suspend_state_t decode_state(const char *buf, size_t n)
 {
 #ifdef CONFIG_SUSPEND
 	suspend_state_t state = PM_SUSPEND_STANDBY;
@@ -278,27 +277,48 @@ static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 #endif
 	char *p;
 	int len;
-	int error = -EINVAL;
 
 	p = memchr(buf, '\n', n);
 	len = p ? p - buf : n;
 
-	/* First, check if we are requested to hibernate */
-	if (len == 4 && !strncmp(buf, "disk", len)) {
-		error = hibernate();
-		goto Exit;
-	}
+	/* Check hibernation first. */
+	if (len == 4 && !strncmp(buf, "disk", len))
+		return PM_SUSPEND_MAX;
 
 #ifdef CONFIG_SUSPEND
-	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++) {
-		if (*s && len == strlen(*s) && !strncmp(buf, *s, len)) {
-			error = pm_suspend(state);
-			break;
-		}
-	}
+	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++)
+		if (*s && len == strlen(*s) && !strncmp(buf, *s, len))
+			return state;
 #endif
 
- Exit:
+	return PM_SUSPEND_ON;
+}
+
+static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
+			   const char *buf, size_t n)
+{
+	suspend_state_t state;
+	int error;
+
+	error = pm_autosleep_lock();
+	if (error)
+		return error;
+
+	if (pm_autosleep_state() > PM_SUSPEND_ON) {
+		error = -EBUSY;
+		goto out;
+	}
+
+	state = decode_state(buf, n);
+	if (state < PM_SUSPEND_MAX)
+		error = pm_suspend(state);
+	else if (state == PM_SUSPEND_MAX)
+		error = hibernate();
+	else
+		error = -EINVAL;
+
+ out:
+	pm_autosleep_unlock();
 	return error ? error : n;
 }
 
@@ -339,7 +359,8 @@ static ssize_t wakeup_count_show(struct kobject *kobj,
 {
 	unsigned int val;
 
-	return pm_get_wakeup_count(&val) ? sprintf(buf, "%u\n", val) : -EINTR;
+	return pm_get_wakeup_count(&val, true) ?
+		sprintf(buf, "%u\n", val) : -EINTR;
 }
 
 static ssize_t wakeup_count_store(struct kobject *kobj,
@@ -347,15 +368,106 @@ static ssize_t wakeup_count_store(struct kobject *kobj,
 				const char *buf, size_t n)
 {
 	unsigned int val;
+	int error;
+
+	error = pm_autosleep_lock();
+	if (error)
+		return error;
+
+	if (pm_autosleep_state() > PM_SUSPEND_ON) {
+		error = -EBUSY;
+		goto out;
+	}
 
+	error = -EINVAL;
 	if (sscanf(buf, "%u", &val) == 1) {
 		if (pm_save_wakeup_count(val))
-			return n;
+			error = n;
 	}
-	return -EINVAL;
+
+ out:
+	pm_autosleep_unlock();
+	return error;
 }
 
 power_attr(wakeup_count);
+
+#ifdef CONFIG_PM_AUTOSLEEP
+static ssize_t autosleep_show(struct kobject *kobj,
+			      struct kobj_attribute *attr,
+			      char *buf)
+{
+	suspend_state_t state = pm_autosleep_state();
+
+	if (state == PM_SUSPEND_ON)
+		return sprintf(buf, "off\n");
+
+#ifdef CONFIG_SUSPEND
+	if (state < PM_SUSPEND_MAX)
+		return sprintf(buf, "%s\n", valid_state(state) ?
+						pm_states[state] : "error");
+#endif
+#ifdef CONFIG_HIBERNATION
+	return sprintf(buf, "disk\n");
+#else
+	return sprintf(buf, "error");
+#endif
+}
+
+static ssize_t autosleep_store(struct kobject *kobj,
+			       struct kobj_attribute *attr,
+			       const char *buf, size_t n)
+{
+	suspend_state_t state = decode_state(buf, n);
+	int error;
+
+	if (state == PM_SUSPEND_ON
+	    && strcmp(buf, "off") && strcmp(buf, "off\n"))
+		return -EINVAL;
+
+	error = pm_autosleep_set_state(state);
+	return error ? error : n;
+}
+
+power_attr(autosleep);
+#endif /* CONFIG_PM_AUTOSLEEP */
+
+#ifdef CONFIG_PM_WAKELOCKS
+static ssize_t wake_lock_show(struct kobject *kobj,
+			      struct kobj_attribute *attr,
+			      char *buf)
+{
+	return pm_show_wakelocks(buf, true);
+}
+
+static ssize_t wake_lock_store(struct kobject *kobj,
+			       struct kobj_attribute *attr,
+			       const char *buf, size_t n)
+{
+	int error = pm_wake_lock(buf);
+	return error ? error : n;
+}
+
+power_attr(wake_lock);
+
+static ssize_t wake_unlock_show(struct kobject *kobj,
+				struct kobj_attribute *attr,
+				char *buf)
+{
+	return pm_show_wakelocks(buf, false);
+}
+
+static ssize_t wake_unlock_store(struct kobject *kobj,
+				 struct kobj_attribute *attr,
+				 const char *buf, size_t n)
+{
+	int error = pm_wake_unlock(buf);
+	return error ? error : n;
+}
+
+power_attr(wake_unlock);
+
+#endif /* CONFIG_PM_WAKELOCKS */
 #endif /* CONFIG_PM_SLEEP */
 
 #ifdef CONFIG_PM_TRACE
@@ -409,6 +521,13 @@ static struct attribute * g[] = {
 #ifdef CONFIG_PM_SLEEP
 	&pm_async_attr.attr,
 	&wakeup_count_attr.attr,
+#ifdef CONFIG_PM_AUTOSLEEP
+	&autosleep_attr.attr,
+#endif
+#ifdef CONFIG_PM_WAKELOCKS
+	&wake_lock_attr.attr,
+	&wake_unlock_attr.attr,
+#endif
 #ifdef CONFIG_PM_DEBUG
 	&pm_test_attr.attr,
 #endif
@@ -444,7 +563,10 @@ static int __init pm_init(void)
 	power_kobj = kobject_create_and_add("power", NULL);
 	if (!power_kobj)
 		return -ENOMEM;
-	return sysfs_create_group(power_kobj, &attr_group);
+	error = sysfs_create_group(power_kobj, &attr_group);
+	if (error)
+		return error;
+	return pm_autosleep_init();
 }
 
 core_initcall(pm_init);
diff --git a/kernel/power/power.h b/kernel/power/power.h
index 98f3622d..b0bd4bea 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -264,3 +264,30 @@ static inline void suspend_thaw_processes(void)
 {
 }
 #endif
+
+#ifdef CONFIG_PM_AUTOSLEEP
+
+/* kernel/power/autosleep.c */
+extern int pm_autosleep_init(void);
+extern int pm_autosleep_lock(void);
+extern void pm_autosleep_unlock(void);
+extern suspend_state_t pm_autosleep_state(void);
+extern int pm_autosleep_set_state(suspend_state_t state);
+
+#else /* !CONFIG_PM_AUTOSLEEP */
+
+static inline int pm_autosleep_init(void) { return 0; }
+static inline int pm_autosleep_lock(void) { return 0; }
+static inline void pm_autosleep_unlock(void) {}
+static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }
+
+#endif /* !CONFIG_PM_AUTOSLEEP */
+
+#ifdef CONFIG_PM_WAKELOCKS
+
+/* kernel/power/wakelock.c */
+extern ssize_t pm_show_wakelocks(char *buf, bool show_active);
+extern int pm_wake_lock(const char *buf);
+extern int pm_wake_unlock(const char *buf);
+
+#endif /* !CONFIG_PM_WAKELOCKS */
diff --git a/kernel/power/qos.c b/kernel/power/qos.c
index 6a031e68..6d1084d3 100644
--- a/kernel/power/qos.c
+++ b/kernel/power/qos.c
@@ -29,8 +29,10 @@
 
 /*#define DEBUG*/
 
+#include <linux/debugfs.h>
 #include <linux/pm_qos.h>
 #include <linux/sched.h>
+#include <linux/seq_file.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
 #include <linux/time.h>
@@ -45,18 +47,8 @@
 #include <linux/uaccess.h>
 #include <linux/export.h>
 
-/*
- * locking rule: all changes to constraints or notifiers lists
- * or pm_qos_object list and pm_qos_objects need to happen with pm_qos_lock
- * held, taken with _irqsave.  One lock to rule them all
- */
-struct pm_qos_object {
-	struct pm_qos_constraints *constraints;
-	struct miscdevice pm_qos_power_miscdev;
-	char *name;
-};
 
-static DEFINE_SPINLOCK(pm_qos_lock);
+DEFINE_SPINLOCK(pm_qos_lock);
 
 static struct pm_qos_object null_pm_qos;
 
@@ -100,12 +92,115 @@ static struct pm_qos_object network_throughput_pm_qos = {
 	.name = "network_throughput",
 };
 
+static BLOCKING_NOTIFIER_HEAD(cpuidle_block_notifier);
+static struct pm_qos_constraints cpuidle_block_constraints = {
+	.list = PLIST_HEAD_INIT(cpuidle_block_constraints.list),
+	.target_value = PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE,
+	.default_value = PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE,
+	.type = PM_QOS_MAX,
+	.notifiers = &cpuidle_block_notifier,
+};
+static struct pm_qos_object cpuidle_block_pm_qos = {
+	.constraints = &cpuidle_block_constraints,
+	.name = "cpuidle_block",
+};
+
+#ifdef CONFIG_DDR_DEVFREQ
+static BLOCKING_NOTIFIER_HEAD(ddr_devfreq_min_notifier);
+static struct pm_qos_constraints ddr_devfreq_min_constraints = {
+	.list = PLIST_HEAD_INIT(ddr_devfreq_min_constraints.list),
+	.target_value = PM_QOS_DEFAULT_VALUE,
+	.default_value = PM_QOS_DEFAULT_VALUE,
+	.type = PM_QOS_MAX,
+	.notifiers = &ddr_devfreq_min_notifier,
+};
+static struct pm_qos_object ddr_devfreq_min_pm_qos = {
+	.constraints = &ddr_devfreq_min_constraints,
+	.name = "ddr_devfreq_min",
+};
+
+static BLOCKING_NOTIFIER_HEAD(ddr_devfreq_max_notifier);
+static struct pm_qos_constraints ddr_devfreq_max_constraints = {
+	.list = PLIST_HEAD_INIT(ddr_devfreq_max_constraints.list),
+	.target_value = PM_QOS_DEFAULT_VALUE,
+	.default_value = PM_QOS_DEFAULT_VALUE,
+	.type = PM_QOS_MIN,
+	.notifiers = &ddr_devfreq_max_notifier,
+};
+static struct pm_qos_object ddr_devfreq_max_pm_qos = {
+	.constraints = &ddr_devfreq_max_constraints,
+	.name = "ddr_devfreq_max",
+};
+
+#endif
+
+static BLOCKING_NOTIFIER_HEAD(cpu_freq_min_notifier);
+static struct pm_qos_constraints cpu_freq_min_constraints = {
+	.list = PLIST_HEAD_INIT(cpu_freq_min_constraints.list),
+	.notifiers = &cpu_freq_min_notifier,
+	.default_value = 0,
+	.target_value = 0,
+	.type = PM_QOS_MAX,
+};
+
+static struct pm_qos_object cpu_freq_min_pm_qos = {
+	.constraints = &cpu_freq_min_constraints,
+	.name = "cpu_freq_min",
+};
+
+static BLOCKING_NOTIFIER_HEAD(cpu_freq_max_notifier);
+static struct pm_qos_constraints cpu_freq_max_constraints = {
+	.list = PLIST_HEAD_INIT(cpu_freq_max_constraints.list),
+	.notifiers = &cpu_freq_max_notifier,
+	.default_value = 0,
+	.target_value = 0,
+	.type = PM_QOS_MIN,
+};
+
+static struct pm_qos_object cpu_freq_max_pm_qos = {
+	.constraints = &cpu_freq_max_constraints,
+	.name = "cpu_freq_max",
+};
 
-static struct pm_qos_object *pm_qos_array[] = {
+#define DECLARE_GPU_NOTIFIER(CORE, MINMAX, TYPE) \
+	static BLOCKING_NOTIFIER_HEAD(gpu_freq_##CORE##_##MINMAX##_notifier); \
+	static struct pm_qos_constraints gpu_freq_##CORE##_##MINMAX##_constraints = { \
+		.list = PLIST_HEAD_INIT(gpu_freq_##CORE##_##MINMAX##_constraints.list), \
+		.notifiers = &gpu_freq_##CORE##_##MINMAX##_notifier, \
+		.default_value = 0, \
+		.target_value = 0, \
+		.type = TYPE, \
+	}; \
+	static struct pm_qos_object gpu_freq_##CORE##_##MINMAX##_pm_qos = { \
+		.constraints = &gpu_freq_##CORE##_##MINMAX##_constraints, \
+		.name = "gpu_freq_"#CORE"_"#MINMAX, \
+	};
+
+DECLARE_GPU_NOTIFIER(3d, min, PM_QOS_MAX);
+DECLARE_GPU_NOTIFIER(2d, min, PM_QOS_MAX);
+DECLARE_GPU_NOTIFIER(sh, min, PM_QOS_MAX);
+DECLARE_GPU_NOTIFIER(3d, max, PM_QOS_MIN);
+DECLARE_GPU_NOTIFIER(2d, max, PM_QOS_MIN);
+DECLARE_GPU_NOTIFIER(sh, max, PM_QOS_MIN);
+
+struct pm_qos_object *pm_qos_array[] = {
 	&null_pm_qos,
 	&cpu_dma_pm_qos,
 	&network_lat_pm_qos,
-	&network_throughput_pm_qos
+	&network_throughput_pm_qos,
+	&cpuidle_block_pm_qos,
+#ifdef CONFIG_DDR_DEVFREQ
+	&ddr_devfreq_min_pm_qos,
+	&ddr_devfreq_max_pm_qos,
+#endif
+	&cpu_freq_min_pm_qos,
+	&cpu_freq_max_pm_qos,
+	&gpu_freq_3d_min_pm_qos,
+	&gpu_freq_2d_min_pm_qos,
+	&gpu_freq_sh_min_pm_qos,
+	&gpu_freq_3d_max_pm_qos,
+	&gpu_freq_2d_max_pm_qos,
+	&gpu_freq_sh_max_pm_qos,
 };
 
 static ssize_t pm_qos_power_write(struct file *filp, const char __user *buf,
@@ -515,6 +610,71 @@ static ssize_t pm_qos_power_write(struct file *filp, const char __user *buf,
 	return count;
 }
 
+static struct dentry *cpuidle_block_dentry;
+
+/**
+ * cpuidle_block_show - Print information of devices blocking LPM.
+ * @m: seq_file to print the statistics into.
+ */
+
+static ssize_t cpuidle_block_show(struct seq_file *m, void *unused)
+{
+	unsigned long flags;
+	struct pm_qos_object *o;
+	struct list_head *list;
+	struct plist_node *node;
+	struct pm_qos_request *req;
+	s32 target_value = 0;
+	/* The item sequence should align with PM_QOS_CPUIDLE_BLOCK_*. */
+	char *lpm_modes[] = {"Default", "D2", "D1", "D1P"};
+
+	o = pm_qos_array[PM_QOS_CPUIDLE_BLOCK];
+	list = &o->constraints->list.node_list;
+
+	rcu_read_lock();
+	spin_lock_irqsave(&pm_qos_lock, flags);
+
+	target_value = pm_qos_read_value(o->constraints);
+	if (target_value != PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE) {
+		seq_printf(m, "Can't enter state equals to or deeper than %s\n",
+				lpm_modes[target_value]);
+		seq_printf(m, "*****Blocking devices*****\n");
+	} else
+		seq_printf(m, "SOC can enter all states\n");
+
+	list_for_each_entry(node, list, node_list) {
+		req = container_of(node, struct pm_qos_request, node);
+		if (node->prio != PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE)
+			seq_printf(m, "%s:\t%s\n",
+				lpm_modes[node->prio], req->name);
+	}
+
+	spin_unlock_irqrestore(&pm_qos_lock, flags);
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static int cpuidle_block_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cpuidle_block_show, NULL);
+}
+
+const struct file_operations cpuidle_block_stats_fops = {
+	.owner = THIS_MODULE,
+	.open = cpuidle_block_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+};
+
+static int __init cpuidle_block_debugfs_init(void)
+{
+	cpuidle_block_dentry = debugfs_create_file("cpuidle_block_devices",
+			S_IRUGO, NULL, NULL, &cpuidle_block_stats_fops);
+	return 0;
+}
+
+postcore_initcall(cpuidle_block_debugfs_init);
 
 static int __init pm_qos_power_init(void)
 {
@@ -536,3 +696,142 @@ static int __init pm_qos_power_init(void)
 }
 
 late_initcall(pm_qos_power_init);
+
+
+/**
+ * cpufreq_qos_show - Print information of cpu freq qos min and max.
+ * @m: seq_file to print the statistics into.
+ */
+static ssize_t cpufreq_qos_show(struct seq_file *m, void *unused)
+{
+	unsigned long flags;
+	struct pm_qos_object *qos_min, *qos_max;
+	struct list_head *list_min, *list_max;
+	struct plist_node *node;
+	s32 target_min = 0, target_max = 0;
+	struct pm_qos_request *req;
+
+	qos_min = pm_qos_array[PM_QOS_CPUFREQ_MIN];
+	list_min = &qos_min->constraints->list.node_list;
+	qos_max = pm_qos_array[PM_QOS_CPUFREQ_MAX];
+	list_max = &qos_max->constraints->list.node_list;
+
+	rcu_read_lock();
+	spin_lock_irqsave(&pm_qos_lock, flags);
+
+	target_min = pm_qos_read_value(qos_min->constraints);
+	target_max = pm_qos_read_value(qos_max->constraints);
+
+	seq_printf(m, "Target min %d\n", target_min);
+	list_for_each_entry(node, list_min, node_list) {
+		req = container_of(node, struct pm_qos_request, node);
+		if (node->prio != PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE)
+			seq_printf(m, "Req: %d\t Name: %s\n",
+				node->prio, req->name);
+	}
+
+	seq_printf(m, "Target max %d\n", target_max);
+	list_for_each_entry(node, list_max, node_list) {
+		req = container_of(node, struct pm_qos_request, node);
+		if (node->prio != PM_QOS_CPUIDLE_BLOCK_DEFAULT_VALUE)
+			seq_printf(m, "Req: %d\t Name: %s\n",
+				node->prio, req->name);
+	}
+	spin_unlock_irqrestore(&pm_qos_lock, flags);
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static int cpufreq_qos_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cpufreq_qos_show, NULL);
+}
+
+const struct file_operations cpufreq_qos_fops = {
+	.owner = THIS_MODULE,
+	.open = cpufreq_qos_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+};
+
+static int __init cpufreq_qos_debugfs_init(void)
+{
+	debugfs_create_file("cpufreq_qos",
+			S_IRUGO, NULL, NULL, &cpufreq_qos_fops);
+	return 0;
+}
+postcore_initcall(cpufreq_qos_debugfs_init);
+
+/**
+ * gpufreq_qos_show - Print information of gpu freq qos min and max.
+ * @m: seq_file to print the statistics into.
+ */
+#define __GPUFREQ_QOS_SHOW(CORE, PM_QOS_CLASS_MIN, PM_QOS_CLASS_MAX) \
+{ \
+	unsigned long flags; \
+	struct pm_qos_object *qos_min, *qos_max; \
+	struct list_head *list_min, *list_max; \
+	struct plist_node *node; \
+	s32 target_min = 0, target_max = 0; \
+	struct pm_qos_request *req; \
+\
+	qos_min = pm_qos_array[PM_QOS_CLASS_MIN]; \
+	list_min = &qos_min->constraints->list.node_list; \
+	qos_max = pm_qos_array[PM_QOS_CLASS_MAX]; \
+	list_max = &qos_max->constraints->list.node_list; \
+\
+	rcu_read_lock(); \
+	spin_lock_irqsave(&pm_qos_lock, flags); \
+\
+	target_min = pm_qos_read_value(qos_min->constraints); \
+	target_max = pm_qos_read_value(qos_max->constraints); \
+\
+	seq_printf(m, #CORE " | Target min %d\n", target_min); \
+	list_for_each_entry(node, list_min, node_list) { \
+		req = container_of(node, struct pm_qos_request, node); \
+		if (node->prio != 0) \
+			seq_printf(m, "Req: %d\t Name: %s\n", \
+				node->prio, req->name); \
+	} \
+	seq_printf(m, "\n"); \
+\
+	seq_printf(m, #CORE " | Target max %d\n", target_max); \
+	list_for_each_entry(node, list_max, node_list) { \
+		req = container_of(node, struct pm_qos_request, node); \
+		if (node->prio != 0) \
+			seq_printf(m, "Req: %d\t Name: %s\n", \
+				node->prio, req->name); \
+	} \
+	seq_printf(m, "\n"); \
+	spin_unlock_irqrestore(&pm_qos_lock, flags); \
+	rcu_read_unlock(); \
+}
+
+static ssize_t gpufreq_qos_show(struct seq_file *m, void *unused)
+{
+	__GPUFREQ_QOS_SHOW(3D, PM_QOS_GPUFREQ_3D_MIN, PM_QOS_GPUFREQ_3D_MAX);
+	__GPUFREQ_QOS_SHOW(2D, PM_QOS_GPUFREQ_2D_MIN, PM_QOS_GPUFREQ_2D_MAX);
+	__GPUFREQ_QOS_SHOW(SH, PM_QOS_GPUFREQ_SH_MIN, PM_QOS_GPUFREQ_SH_MAX);
+	return 0;
+}
+
+static int gpufreq_qos_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, gpufreq_qos_show, NULL);
+}
+
+const struct file_operations gpufreq_qos_fops = {
+	.owner = THIS_MODULE,
+	.open = gpufreq_qos_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+};
+
+static int __init gpufreq_qos_debugfs_init(void)
+{
+	debugfs_create_file("gpufreq_qos",
+			S_IRUGO, NULL, NULL, &gpufreq_qos_fops);
+	return 0;
+}
+postcore_initcall(gpufreq_qos_debugfs_init);
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index 396d262b..9bb2f077 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -24,6 +24,7 @@
 #include <linux/export.h>
 #include <linux/suspend.h>
 #include <linux/syscore_ops.h>
+#include <linux/rtc.h>
 #include <trace/events/power.h>
 
 #include "power.h"
@@ -300,6 +301,18 @@ static int enter_state(suspend_state_t state)
 	return error;
 }
 
+static void pm_suspend_marker(char *annotation)
+{
+	struct timespec ts;
+	struct rtc_time tm;
+
+	getnstimeofday(&ts);
+	rtc_time_to_tm(ts.tv_sec, &tm);
+	pr_info("PM: suspend %s %d-%02d-%02d %02d:%02d:%02d.%09lu UTC\n",
+		annotation, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+		tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
+}
+
 /**
  * pm_suspend - Externally visible function for suspending the system.
  * @state: System sleep state to enter.
@@ -314,6 +327,7 @@ int pm_suspend(suspend_state_t state)
 	if (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)
 		return -EINVAL;
 
+	pm_suspend_marker("entry");
 	error = enter_state(state);
 	if (error) {
 		suspend_stats.fail++;
@@ -321,6 +335,7 @@ int pm_suspend(suspend_state_t state)
 	} else {
 		suspend_stats.success++;
 	}
+	pm_suspend_marker("exit");
 	return error;
 }
 EXPORT_SYMBOL(pm_suspend);
diff --git a/kernel/printk.c b/kernel/printk.c
index b663c2c9..77b02a72 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -46,6 +46,7 @@
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/printk.h>
+#include <mach/sec_debug.h>
 
 /*
  * Architectures can override it:
@@ -56,6 +57,10 @@ void asmlinkage __attribute__((weak)) early_printk(const char *fmt, ...)
 
 #define __LOG_BUF_LEN	(1 << CONFIG_LOG_BUF_SHIFT)
 
+#ifdef        CONFIG_DEBUG_LL
+extern void printascii(char *);
+#endif
+
 /* printk's without a loglevel use this.. */
 #define DEFAULT_MESSAGE_LOGLEVEL CONFIG_DEFAULT_MESSAGE_LOGLEVEL
 
@@ -153,6 +158,26 @@ static int log_buf_len = __LOG_BUF_LEN;
 static unsigned logged_chars; /* Number of chars produced since last read+clear operation */
 static int saved_console_loglevel = -1;
 
+/* Mark for GetLog */
+#ifdef CONFIG_KERNEL_DEBUG_SEC
+struct struct_kernel_log_mark {
+	u32 special_mark_1;
+	u32 special_mark_2;
+	u32 special_mark_3;
+	u32 special_mark_4;
+	void *p__log_buf;
+};
+
+static struct struct_kernel_log_mark kernel_log_mark = {
+	.special_mark_1 = (('*' << 24) | ('^' << 16) | ('^' << 8) | ('*' << 0)),
+	.special_mark_2 = (('I' << 24) | ('n' << 16) | ('f' << 8) | ('o' << 0)),
+	.special_mark_3 = (('H' << 24) | ('e' << 16) | ('r' << 8) | ('e' << 0)),
+	.special_mark_4 = (('k' << 24) | ('l' << 16) | ('o' << 8) | ('g' << 0)),
+	.p__log_buf = __log_buf,
+
+};
+#endif
+
 #ifdef CONFIG_KEXEC
 /*
  * This appends the listed symbols to /proc/vmcoreinfo
@@ -238,6 +263,14 @@ void __init setup_log_buf(int early)
 	pr_info("log_buf_len: %d\n", log_buf_len);
 	pr_info("early log buf free: %d(%d%%)\n",
 		free, (free * 100) / __LOG_BUF_LEN);
+
+/* Mark for GetLog */
+#ifdef CONFIG_KERNEL_DEBUG_SEC
+		//{{Mark for GetLog -2/2
+		kernel_log_mark.p__log_buf = __log_buf;
+		//}} Mark for GetLog -2/2
+#endif /* CONFIG_SAMSUNG_USE_GETLOG */
+
 }
 
 #ifdef CONFIG_BOOT_PRINTK_DELAY
@@ -293,6 +326,53 @@ static inline void boot_delay_msec(void)
 }
 #endif
 
+/*
+ * Return the number of unread characters in the log buffer.
+ */
+static int log_buf_get_len(void)
+{
+	return logged_chars;
+}
+
+/*
+ * Clears the ring-buffer
+ */
+void log_buf_clear(void)
+{
+	logged_chars = 0;
+}
+
+/*
+ * Copy a range of characters from the log buffer.
+ */
+int log_buf_copy(char *dest, int idx, int len)
+{
+	int ret, max;
+	bool took_lock = false;
+
+	if (!oops_in_progress) {
+		raw_spin_lock_irq(&logbuf_lock);
+		took_lock = true;
+	}
+
+	max = log_buf_get_len();
+	if (idx < 0 || idx >= max) {
+		ret = -1;
+	} else {
+		if (len > max - idx)
+			len = max - idx;
+		ret = len;
+		idx += (log_end - max);
+		while (len-- > 0)
+			dest[len] = LOG_BUF(idx + len);
+	}
+
+	if (took_lock)
+		raw_spin_unlock_irq(&logbuf_lock);
+
+	return ret;
+}
+
 #ifdef CONFIG_SECURITY_DMESG_RESTRICT
 int dmesg_restrict = 1;
 #else
@@ -666,6 +746,35 @@ static void call_console_drivers(unsigned start, unsigned end)
 	_call_console_drivers(start_print, end, msg_level);
 }
 
+#ifdef CONFIG_SEC_LOG
+static void (*log_char_hook)(char c);
+
+void register_log_char_hook(void (*f) (char c))
+{
+	unsigned start;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&logbuf_lock, flags);
+
+	start = min(con_start, log_start);
+	while (start != log_end)
+		f(__log_buf[start++ & (__LOG_BUF_LEN - 1)]);
+
+	log_char_hook = f;
+
+	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+}
+EXPORT_SYMBOL(register_log_char_hook);
+
+void sec_getlog_supply_kloginfo(void *klog_buf)
+{
+	pr_info("%s: 0x%p\n", __func__, klog_buf);
+	kernel_log_mark.p__log_buf = klog_buf;
+}
+EXPORT_SYMBOL(sec_getlog_supply_kloginfo);
+
+#endif
+
 static void emit_log_char(char c)
 {
 	LOG_BUF(log_end) = c;
@@ -676,6 +785,11 @@ static void emit_log_char(char c)
 		con_start = log_end - log_buf_len;
 	if (logged_chars < log_buf_len)
 		logged_chars++;
+
+#ifdef CONFIG_SEC_LOG
+	if (log_char_hook)
+		log_char_hook(c);
+#endif
 }
 
 /*
@@ -707,6 +821,27 @@ static bool printk_time = 0;
 #endif
 module_param_named(time, printk_time, bool, S_IRUGO | S_IWUSR);
 
+#if defined(CONFIG_PRINTK_CPU_ID)
+static bool printk_cpu_id = 1;
+#else
+static bool printk_cpu_id;
+#endif
+module_param_named(cpu, printk_cpu_id, bool, S_IRUGO | S_IWUSR);
+
+#if defined(CONFIG_PRINTK_PID)
+static bool printk_pid = 1;
+#else
+static bool printk_pid;
+#endif
+module_param_named(pid, printk_pid, bool, S_IRUGO | S_IWUSR);
+
+#if defined(CONFIG_PRINTK_COMM)
+static bool printk_comm = 1;
+#else
+static bool printk_comm;
+#endif
+module_param_named(comm, printk_comm, bool, S_IRUGO | S_IWUSR);
+
 static bool always_kmsg_dump;
 module_param_named(always_kmsg_dump, always_kmsg_dump, bool, S_IRUGO | S_IWUSR);
 
@@ -884,6 +1019,11 @@ asmlinkage int vprintk(const char *fmt, va_list args)
 	printed_len += vscnprintf(printk_buf + printed_len,
 				  sizeof(printk_buf) - printed_len, fmt, args);
 
+#ifdef	CONFIG_DEBUG_LL
+	if (console_drivers == NULL)
+		printascii(printk_buf);
+#endif
+
 	p = printk_buf;
 
 	/* Read log level and handle special printk prefix */
@@ -946,6 +1086,43 @@ asmlinkage int vprintk(const char *fmt, va_list args)
 				printed_len += tlen;
 			}
 
+			if (printk_cpu_id) {
+				/* Add the cpu id */
+				char tbuf[10], *tp;
+				unsigned tlen;
+
+				tlen = sprintf(tbuf, "c%u ", printk_cpu);
+
+				for (tp = tbuf; tp < tbuf + tlen; tp++)
+					emit_log_char(*tp);
+				printed_len += tlen;
+			}
+
+			if (printk_pid) {
+				/* Add the current process id */
+				char tbuf[10], *tp;
+				unsigned tlen;
+
+				tlen = sprintf(tbuf, "%u ", current->pid);
+
+				for (tp = tbuf; tp < tbuf + tlen; tp++)
+					emit_log_char(*tp);
+				printed_len += tlen;
+			}
+
+			if (printk_comm) {
+				/* Add the current process comm */
+				char tbuf[TASK_COMM_LEN + 4] = {0,}, *tp;
+				unsigned tlen;
+
+				tlen = snprintf(tbuf, sizeof(tbuf), "(%s) ",
+						current->comm);
+
+				for (tp = tbuf; tp < tbuf + tlen; tp++)
+					emit_log_char(*tp);
+				printed_len += tlen;
+			}
+
 			if (!*p)
 				break;
 		}
@@ -1161,7 +1338,6 @@ static int __cpuinit console_cpu_notify(struct notifier_block *self,
 	switch (action) {
 	case CPU_ONLINE:
 	case CPU_DEAD:
-	case CPU_DYING:
 	case CPU_DOWN_FAILED:
 	case CPU_UP_CANCELED:
 		console_lock();
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index ee8d49b9..daf4394d 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -117,11 +117,45 @@ void __ptrace_unlink(struct task_struct *child)
 	 * TASK_KILLABLE sleeps.
 	 */
 	if (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))
-		signal_wake_up(child, task_is_traced(child));
+		ptrace_signal_wake_up(child, true);
 
 	spin_unlock(&child->sighand->siglock);
 }
 
+/* Ensure that nothing can wake it up, even SIGKILL */
+static bool ptrace_freeze_traced(struct task_struct *task)
+{
+	bool ret = false;
+
+	/* Lockless, nobody but us can set this flag */
+	if (task->jobctl & JOBCTL_LISTENING)
+		return ret;
+
+	spin_lock_irq(&task->sighand->siglock);
+	if (task_is_traced(task) && !__fatal_signal_pending(task)) {
+		task->state = __TASK_TRACED;
+		ret = true;
+	}
+	spin_unlock_irq(&task->sighand->siglock);
+
+	return ret;
+}
+
+static void ptrace_unfreeze_traced(struct task_struct *task)
+{
+	if (task->state != __TASK_TRACED)
+		return;
+
+	WARN_ON(!task->ptrace || task->parent != current);
+
+	spin_lock_irq(&task->sighand->siglock);
+	if (__fatal_signal_pending(task))
+		wake_up_state(task, __TASK_TRACED);
+	else
+		task->state = TASK_TRACED;
+	spin_unlock_irq(&task->sighand->siglock);
+}
+
 /**
  * ptrace_check_attach - check whether ptracee is ready for ptrace operation
  * @child: ptracee to check for
@@ -151,24 +185,29 @@ int ptrace_check_attach(struct task_struct *child, bool ignore_state)
 	 * be changed by us so it's not changing right after this.
 	 */
 	read_lock(&tasklist_lock);
-	if ((child->ptrace & PT_PTRACED) && child->parent == current) {
+	if (child->ptrace && child->parent == current) {
+		WARN_ON(child->state == __TASK_TRACED);
 		/*
 		 * child->sighand can't be NULL, release_task()
 		 * does ptrace_unlink() before __exit_signal().
 		 */
-		spin_lock_irq(&child->sighand->siglock);
-		WARN_ON_ONCE(task_is_stopped(child));
-		if (ignore_state || (task_is_traced(child) &&
-				     !(child->jobctl & JOBCTL_LISTENING)))
+		if (ignore_state || ptrace_freeze_traced(child))
 			ret = 0;
-		spin_unlock_irq(&child->sighand->siglock);
 	}
 	read_unlock(&tasklist_lock);
 
-	if (!ret && !ignore_state)
-		ret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;
+	if (!ret && !ignore_state) {
+		if (!wait_task_inactive(child, __TASK_TRACED)) {
+			/*
+			 * This can only happen if may_ptrace_stop() fails and
+			 * ptrace_stop() changes ->state back to TASK_RUNNING,
+			 * so we should not worry about leaking __TASK_TRACED.
+			 */
+			WARN_ON(child->state == __TASK_TRACED);
+			ret = -ESRCH;
+		}
+	}
 
-	/* All systems go.. */
 	return ret;
 }
 
@@ -311,7 +350,7 @@ static int ptrace_attach(struct task_struct *task, long request,
 	 */
 	if (task_is_stopped(task) &&
 	    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))
-		signal_wake_up(task, 1);
+		signal_wake_up_state(task, __TASK_STOPPED);
 
 	spin_unlock(&task->sighand->siglock);
 
@@ -728,7 +767,7 @@ int ptrace_request(struct task_struct *child, long request,
 		 * tracee into STOP.
 		 */
 		if (likely(task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)))
-			signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);
+			ptrace_signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);
 
 		unlock_task_sighand(child, &flags);
 		ret = 0;
@@ -754,7 +793,7 @@ int ptrace_request(struct task_struct *child, long request,
 			 * start of this trap and now.  Trigger re-trap.
 			 */
 			if (child->jobctl & JOBCTL_TRAP_NOTIFY)
-				signal_wake_up(child, true);
+				ptrace_signal_wake_up(child, true);
 			ret = 0;
 		}
 		unlock_task_sighand(child, &flags);
@@ -891,6 +930,8 @@ SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,
 		goto out_put_task_struct;
 
 	ret = arch_ptrace(child, request, addr, data);
+	if (ret || request != PTRACE_DETACH)
+		ptrace_unfreeze_traced(child);
 
  out_put_task_struct:
 	put_task_struct(child);
@@ -1030,8 +1071,11 @@ asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,
 
 	ret = ptrace_check_attach(child, request == PTRACE_KILL ||
 				  request == PTRACE_INTERRUPT);
-	if (!ret)
+	if (!ret) {
 		ret = compat_arch_ptrace(child, request, addr, data);
+		if (ret || request != PTRACE_DETACH)
+			ptrace_unfreeze_traced(child);
+	}
 
  out_put_task_struct:
 	put_task_struct(child);
diff --git a/kernel/rcutree.c b/kernel/rcutree.c
index d0c5baf1..3cf7bc89 100644
--- a/kernel/rcutree.c
+++ b/kernel/rcutree.c
@@ -724,7 +724,7 @@ static void print_other_cpu_stall(struct rcu_state *rsp)
 	int cpu;
 	long delta;
 	unsigned long flags;
-	int ndetected;
+	int ndetected = 0;
 	struct rcu_node *rnp = rcu_get_root(rsp);
 
 	/* Only let one CPU complain about others per time interval. */
@@ -765,7 +765,7 @@ static void print_other_cpu_stall(struct rcu_state *rsp)
 	 */
 	rnp = rcu_get_root(rsp);
 	raw_spin_lock_irqsave(&rnp->lock, flags);
-	ndetected = rcu_print_task_stall(rnp);
+	ndetected += rcu_print_task_stall(rnp);
 	raw_spin_unlock_irqrestore(&rnp->lock, flags);
 
 	print_cpu_stall_info_end();
diff --git a/kernel/rwsem.c b/kernel/rwsem.c
index 6850f53e..b3c6c3fc 100644
--- a/kernel/rwsem.c
+++ b/kernel/rwsem.c
@@ -116,6 +116,16 @@ void down_read_nested(struct rw_semaphore *sem, int subclass)
 
 EXPORT_SYMBOL(down_read_nested);
 
+void _down_write_nest_lock(struct rw_semaphore *sem, struct lockdep_map *nest)
+{
+	might_sleep();
+	rwsem_acquire_nest(&sem->dep_map, 0, 0, nest, _RET_IP_);
+
+	LOCK_CONTENDED(sem, __down_write_trylock, __down_write);
+}
+
+EXPORT_SYMBOL(_down_write_nest_lock);
+
 void down_write_nested(struct rw_semaphore *sem, int subclass)
 {
 	might_sleep();
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 2000e069..6a915335 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -87,6 +87,10 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/sched.h>
 
+#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
+#include <mach/sec_debug.h>
+#endif
+
 void start_bandwidth_timer(struct hrtimer *period_timer, ktime_t period)
 {
 	unsigned long delta;
@@ -2111,6 +2115,14 @@ unsigned long nr_running(void)
 	return sum;
 }
 
+unsigned long get_cpu_nr_running(unsigned int cpu)
+{
+	if (cpu < num_possible_cpus())
+		return cpu_rq(cpu)->nr_running;
+	else
+		return 0;
+}
+
 unsigned long nr_uninterruptible(void)
 {
 	unsigned long i, sum = 0;
@@ -2162,6 +2174,61 @@ unsigned long this_cpu_load(void)
 }
 
 
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+unsigned long this_cpu_loadx(int i)
+{
+	struct rq *this = this_rq();
+	return this->cpu_load[i];
+}
+#endif
+
+/*
+ * Global load-average calculations
+ *
+ * We take a distributed and async approach to calculating the global load-avg
+ * in order to minimize overhead.
+ *
+ * The global load average is an exponentially decaying average of nr_running +
+ * nr_uninterruptible.
+ *
+ * Once every LOAD_FREQ:
+ *
+ *   nr_active = 0;
+ *   for_each_possible_cpu(cpu)
+ *   	nr_active += cpu_of(cpu)->nr_running + cpu_of(cpu)->nr_uninterruptible;
+ *
+ *   avenrun[n] = avenrun[0] * exp_n + nr_active * (1 - exp_n)
+ *
+ * Due to a number of reasons the above turns in the mess below:
+ *
+ *  - for_each_possible_cpu() is prohibitively expensive on machines with
+ *    serious number of cpus, therefore we need to take a distributed approach
+ *    to calculating nr_active.
+ *
+ *        \Sum_i x_i(t) = \Sum_i x_i(t) - x_i(t_0) | x_i(t_0) := 0
+ *                      = \Sum_i { \Sum_j=1 x_i(t_j) - x_i(t_j-1) }
+ *
+ *    So assuming nr_active := 0 when we start out -- true per definition, we
+ *    can simply take per-cpu deltas and fold those into a global accumulate
+ *    to obtain the same result. See calc_load_fold_active().
+ *
+ *    Furthermore, in order to avoid synchronizing all per-cpu delta folding
+ *    across the machine, we assume 10 ticks is sufficient time for every
+ *    cpu to have completed this task.
+ *
+ *    This places an upper-bound on the IRQ-off latency of the machine. Then
+ *    again, being late doesn't loose the delta, just wrecks the sample.
+ *
+ *  - cpu_rq()->nr_uninterruptible isn't accurately tracked per-cpu because
+ *    this would add another cross-cpu cacheline miss and atomic operation
+ *    to the wakeup path. Instead we increment on whatever cpu the task ran
+ *    when it went into uninterruptible state and decrement on whatever cpu
+ *    did the wakeup. This means that only the sum of nr_uninterruptible over
+ *    all cpus yields the correct result.
+ *
+ *  This covers the NO_HZ=n code, for extra head-aches, see the comment below.
+ */
+
 /* Variables and functions for calc_load */
 static atomic_long_t calc_load_tasks;
 static unsigned long calc_load_update;
@@ -3243,7 +3310,9 @@ need_resched:
 		rq = cpu_rq(cpu);
 	} else
 		raw_spin_unlock_irq(&rq->lock);
-
+#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
+	sec_debug_task_log(cpu,rq->curr);
+#endif
 	post_schedule(rq);
 
 	sched_preempt_enable_no_resched();
@@ -7072,13 +7141,24 @@ static inline int preempt_count_equals(int preempt_offset)
 	return (nested == preempt_offset);
 }
 
+static int __might_sleep_init_called;
+int __init __might_sleep_init(void)
+{
+	__might_sleep_init_called = 1;
+	return 0;
+}
+early_initcall(__might_sleep_init);
+
 void __might_sleep(const char *file, int line, int preempt_offset)
 {
 	static unsigned long prev_jiffy;	/* ratelimiting */
 
 	rcu_sleep_check(); /* WARN_ON_ONCE() by default, no rate limit reqd. */
 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) ||
-	    system_state != SYSTEM_RUNNING || oops_in_progress)
+	    oops_in_progress)
+		return;
+	if (system_state != SYSTEM_RUNNING &&
+	    (!__might_sleep_init_called || system_state != SYSTEM_BOOTING))
 		return;
 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)
 		return;
@@ -7631,6 +7711,23 @@ static void cpu_cgroup_destroy(struct cgroup *cgrp)
 	sched_destroy_group(tg);
 }
 
+static int
+cpu_cgroup_allow_attach(struct cgroup *cgrp, struct cgroup_taskset *tset)
+{
+	const struct cred *cred = current_cred(), *tcred;
+	struct task_struct *task;
+
+	cgroup_taskset_for_each(task, cgrp, tset) {
+		tcred = __task_cred(task);
+
+		if ((current != task) && !capable(CAP_SYS_NICE) &&
+		    cred->euid != tcred->uid && cred->euid != tcred->suid)
+			return -EACCES;
+	}
+
+	return 0;
+}
+
 static int cpu_cgroup_can_attach(struct cgroup *cgrp,
 				 struct cgroup_taskset *tset)
 {
@@ -7992,6 +8089,7 @@ struct cgroup_subsys cpu_cgroup_subsys = {
 	.destroy	= cpu_cgroup_destroy,
 	.can_attach	= cpu_cgroup_can_attach,
 	.attach		= cpu_cgroup_attach,
+	.allow_attach	= cpu_cgroup_allow_attach,
 	.exit		= cpu_cgroup_exit,
 	.populate	= cpu_cgroup_populate,
 	.subsys_id	= cpu_cgroup_subsys_id,
diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index e9553640..6090ca43 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -86,9 +86,11 @@ unsigned int sysctl_sched_child_runs_first __read_mostly;
  */
 unsigned int sysctl_sched_wakeup_granularity = 1000000UL;
 unsigned int normalized_sysctl_sched_wakeup_granularity = 1000000UL;
-
+#if (CONFIG_NR_CPUS >= 3)
+const_debug unsigned int sysctl_sched_migration_cost = 0;
+#else
 const_debug unsigned int sysctl_sched_migration_cost = 500000UL;
-
+#endif
 /*
  * The exponential sliding  window over which load is averaged for shares
  * distribution.
diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c
index 44af55e6..e11c3100 100644
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@ -715,9 +715,11 @@ static void __enable_runtime(struct rq *rq)
 
 		raw_spin_lock(&rt_b->rt_runtime_lock);
 		raw_spin_lock(&rt_rq->rt_runtime_lock);
-		rt_rq->rt_runtime = rt_b->rt_runtime;
-		rt_rq->rt_time = 0;
-		rt_rq->rt_throttled = 0;
+		if (rt_rq->rt_runtime == RUNTIME_INF) {
+			rt_rq->rt_runtime = rt_b->rt_runtime;
+			rt_rq->rt_time = 0;
+			rt_rq->rt_throttled = 0;
+		}
 		raw_spin_unlock(&rt_rq->rt_runtime_lock);
 		raw_spin_unlock(&rt_b->rt_runtime_lock);
 	}
@@ -1983,6 +1985,8 @@ static void watchdog(struct rq *rq, struct task_struct *p)
 
 static void task_tick_rt(struct rq *rq, struct task_struct *p, int queued)
 {
+	struct sched_rt_entity *rt_se = &p->rt;
+
 	update_curr_rt(rq);
 
 	watchdog(rq, p);
@@ -2000,12 +2004,15 @@ static void task_tick_rt(struct rq *rq, struct task_struct *p, int queued)
 	p->rt.time_slice = RR_TIMESLICE;
 
 	/*
-	 * Requeue to the end of queue if we are not the only element
-	 * on the queue:
+	 * Requeue to the end of queue if we (and all of our ancestors) are the
+	 * only element on the queue
 	 */
-	if (p->rt.run_list.prev != p->rt.run_list.next) {
-		requeue_task_rt(rq, p, 0);
-		set_tsk_need_resched(p);
+	for_each_sched_rt_entity(rt_se) {
+		if (rt_se->run_list.prev != rt_se->run_list.next) {
+			requeue_task_rt(rq, p, 0);
+			set_tsk_need_resched(p);
+			return;
+		}
 	}
 }
 
diff --git a/kernel/signal.c b/kernel/signal.c
index 17afcaf5..e1b8729c 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -482,6 +482,9 @@ flush_signal_handlers(struct task_struct *t, int force_default)
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
+#ifdef SA_RESTORER
+		ka->sa.sa_restorer = NULL;
+#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
@@ -677,23 +680,17 @@ int dequeue_signal(struct task_struct *tsk, sigset_t *mask, siginfo_t *info)
  * No need to set need_resched since signal event passing
  * goes through ->blocked
  */
-void signal_wake_up(struct task_struct *t, int resume)
+void signal_wake_up_state(struct task_struct *t, unsigned int state)
 {
-	unsigned int mask;
-
 	set_tsk_thread_flag(t, TIF_SIGPENDING);
-
 	/*
-	 * For SIGKILL, we want to wake it up in the stopped/traced/killable
+	 * TASK_WAKEKILL also means wake it up in the stopped/traced/killable
 	 * case. We don't check t->state here because there is a race with it
 	 * executing another processor and just now entering stopped state.
 	 * By using wake_up_state, we ensure the process will wake up and
 	 * handle its death signal.
 	 */
-	mask = TASK_INTERRUPTIBLE;
-	if (resume)
-		mask |= TASK_WAKEKILL;
-	if (!wake_up_state(t, mask))
+	if (!wake_up_state(t, state | TASK_INTERRUPTIBLE))
 		kick_process(t);
 }
 
@@ -1808,6 +1805,10 @@ static inline int may_ptrace_stop(void)
 	 * If SIGKILL was already sent before the caller unlocked
 	 * ->siglock we must see ->core_state != NULL. Otherwise it
 	 * is safe to enter schedule().
+	 *
+	 * This is almost outdated, a task with the pending SIGKILL can't
+	 * block in TASK_TRACED. But PTRACE_EVENT_EXIT can be reported
+	 * after SIGKILL was already dequeued.
 	 */
 	if (unlikely(current->mm->core_state) &&
 	    unlikely(current->mm == current->parent->mm))
@@ -1933,6 +1934,7 @@ static void ptrace_stop(int exit_code, int why, int clear_code, siginfo_t *info)
 		if (gstop_done)
 			do_notify_parent_cldstop(current, false, why);
 
+		/* tasklist protects us from ptrace_freeze_traced() */
 		__set_current_state(TASK_RUNNING);
 		if (clear_code)
 			current->exit_code = 0;
@@ -2209,7 +2211,7 @@ relock:
 	 * Now that we woke up, it's crucial if we're supposed to be
 	 * frozen that we freeze now before running anything substantial.
 	 */
-	try_to_freeze();
+	try_to_freeze_nowarn();
 
 	spin_lock_irq(&sighand->siglock);
 	/*
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 671f9594..8499aa20 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -29,6 +29,9 @@
 #include <trace/events/irq.h>
 
 #include <asm/irq.h>
+#ifdef CONFIG_SEC_DEBUG_SOFTIRQ_LOG
+#include <mach/sec_debug.h>
+#endif
 /*
    - No shared variables, all the data are CPU local.
    - If a softirq needs serialization, let it serialize itself
@@ -235,7 +238,13 @@ restart:
 			kstat_incr_softirqs_this_cpu(vec_nr);
 
 			trace_softirq_entry(vec_nr);
+#ifdef CONFIG_SEC_DEBUG_SOFTIRQ_LOG
+			sec_debug_softirq_log(9999, h->action, 4);
+#endif
 			h->action(h);
+#ifdef CONFIG_SEC_DEBUG_SOFTIRQ_LOG
+			sec_debug_softirq_log(9999, h->action, 5);
+#endif
 			trace_softirq_exit(vec_nr);
 			if (unlikely(prev_count != preempt_count())) {
 				printk(KERN_ERR "huh, entered softirq %u %s %p"
@@ -456,7 +465,13 @@ static void tasklet_action(struct softirq_action *a)
 			if (!atomic_read(&t->count)) {
 				if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 					BUG();
+#ifdef CONFIG_SEC_DEBUG_SOFTIRQ_LOG
+				sec_debug_softirq_log(9997, t->func, 4);
+#endif
 				t->func(t->data);
+#ifdef CONFIG_SEC_DEBUG_SOFTIRQ_LOG
+				sec_debug_softirq_log(9997, t->func, 5);
+#endif
 				tasklet_unlock(t);
 				continue;
 			}
@@ -491,7 +506,13 @@ static void tasklet_hi_action(struct softirq_action *a)
 			if (!atomic_read(&t->count)) {
 				if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 					BUG();
+#ifdef CONFIG_SEC_DEBUG_SOFTIRQ_LOG
+				sec_debug_softirq_log(9998, t->func, 4);
+#endif
 				t->func(t->data);
+#ifdef CONFIG_SEC_DEBUG_SOFTIRQ_LOG
+				sec_debug_softirq_log(9998, t->func, 5);
+#endif
 				tasklet_unlock(t);
 				continue;
 			}
diff --git a/kernel/sys.c b/kernel/sys.c
index e7006eb6..f208bca4 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -123,6 +123,54 @@ EXPORT_SYMBOL(cad_pid);
 
 void (*pm_power_off_prepare)(void);
 
+#if defined CONFIG_SEC_RESTRICT_SETUID
+int sec_check_execpath(struct mm_struct *mm, char *denypath);
+#if defined CONFIG_SEC_RESTRICT_ROOTING_LOG
+#define PRINT_LOG(...)	printk(KERN_ERR __VA_ARGS__)
+#else
+#define PRINT_LOG(...)
+#endif	// End of CONFIG_SEC_RESTRICT_ROOTING_LOG
+
+static int sec_restrict_uid(void)
+{
+	int ret = 0;
+	struct task_struct *parent_tsk;
+	const struct cred *parent_cred;
+
+	read_lock(&tasklist_lock);
+	parent_tsk = current->parent;
+	if (!parent_tsk) {
+		read_unlock(&tasklist_lock);
+		return 0;
+	}
+
+	get_task_struct(parent_tsk);
+	/* holding on to the task struct is enough so just release
+	 * the tasklist lock here */
+	read_unlock(&tasklist_lock);
+
+	parent_cred = get_task_cred(parent_tsk);
+	if (!parent_cred)
+		goto out;
+	if (parent_cred->euid == 0 || parent_tsk->pid == 1) {
+		ret = 0;
+	} else if (sec_check_execpath(current->mm, "/system/bin/pppd")) {
+		PRINT_LOG("VPN allowed to use root permission");
+		ret = 0;
+	} else {
+		PRINT_LOG("Restricted changing UID. PID = %d(%s) PPID = %d(%s)\n",
+			current->pid, current->comm,
+			parent_tsk->pid, parent_tsk->comm);
+		ret = 1;
+	}
+	put_cred(parent_cred);
+out:
+	put_task_struct(parent_tsk);
+
+	return ret;
+}
+#endif // End of CONFIG_SEC_RESTRICT_SETUID
+
 /*
  * Returns true if current's euid is same as p's uid or euid,
  * or has CAP_SYS_NICE to p's user_ns.
@@ -354,6 +402,7 @@ int unregister_reboot_notifier(struct notifier_block *nb)
 }
 EXPORT_SYMBOL(unregister_reboot_notifier);
 
+
 /**
  *	kernel_restart - reboot the system
  *	@cmd: pointer to buffer containing command to execute for restart
@@ -557,6 +606,14 @@ SYSCALL_DEFINE2(setregid, gid_t, rgid, gid_t, egid)
 	struct cred *new;
 	int retval;
 
+#if defined CONFIG_SEC_RESTRICT_SETUID
+	if(rgid == 0 || egid == 0)
+	{
+		if(sec_restrict_uid())
+			return -EACCES;
+	}
+#endif // End of CONFIG_SEC_RESTRICT_SETUID
+
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
@@ -604,6 +661,14 @@ SYSCALL_DEFINE1(setgid, gid_t, gid)
 	struct cred *new;
 	int retval;
 
+#if defined CONFIG_SEC_RESTRICT_SETUID
+	if(gid == 0)
+	{
+		if(sec_restrict_uid())
+			return -EACCES;
+	}
+#endif // End of CONFIG_SEC_RESTRICT_SETUID
+
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
@@ -674,6 +739,14 @@ SYSCALL_DEFINE2(setreuid, uid_t, ruid, uid_t, euid)
 	struct cred *new;
 	int retval;
 
+#if defined CONFIG_SEC_RESTRICT_SETUID
+	if(ruid == 0 || euid == 0)
+	{
+		if(sec_restrict_uid())
+			return -EACCES;
+	}
+#endif // End of CONFIG_SEC_RESTRICT_SETUID
+
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
@@ -735,6 +808,14 @@ SYSCALL_DEFINE1(setuid, uid_t, uid)
 	struct cred *new;
 	int retval;
 
+#if defined CONFIG_SEC_RESTRICT_SETUID
+	if(uid == 0)
+	{
+		if(sec_restrict_uid())
+			return -EACCES;
+	}
+#endif // End of CONFIG_SEC_RESTRICT_SETUID
+
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
@@ -776,6 +857,14 @@ SYSCALL_DEFINE3(setresuid, uid_t, ruid, uid_t, euid, uid_t, suid)
 	struct cred *new;
 	int retval;
 
+#if defined CONFIG_SEC_RESTRICT_SETUID
+	if(ruid == 0 || euid == 0 || suid == 0)
+	{
+		if(sec_restrict_uid())
+			return -EACCES;
+	}
+#endif // End of CONFIG_SEC_RESTRICT_SETUID
+
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
@@ -841,6 +930,14 @@ SYSCALL_DEFINE3(setresgid, gid_t, rgid, gid_t, egid, gid_t, sgid)
 	struct cred *new;
 	int retval;
 
+#if defined CONFIG_SEC_RESTRICT_SETUID
+	if(rgid == 0 || egid == 0 || sgid == 0)
+	{
+		if(sec_restrict_uid())
+			return -EACCES;
+	}
+#endif // End of CONFIG_SEC_RESTRICT_SETUID
+
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
@@ -1179,15 +1276,16 @@ DECLARE_RWSEM(uts_sem);
  * Work around broken programs that cannot handle "Linux 3.0".
  * Instead we map 3.x to 2.6.40+x, so e.g. 3.0 would be 2.6.40
  */
-static int override_release(char __user *release, int len)
+static int override_release(char __user *release, size_t len)
 {
 	int ret = 0;
-	char buf[65];
 
 	if (current->personality & UNAME26) {
-		char *rest = UTS_RELEASE;
+		const char *rest = UTS_RELEASE;
+		char buf[65] = { 0 };
 		int ndots = 0;
 		unsigned v;
+		size_t copy;
 
 		while (*rest) {
 			if (*rest == '.' && ++ndots >= 3)
@@ -1197,8 +1295,9 @@ static int override_release(char __user *release, int len)
 			rest++;
 		}
 		v = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;
-		snprintf(buf, len, "2.6.%u%s", v, rest);
-		ret = copy_to_user(release, buf, len);
+		copy = clamp_t(size_t, len, 1, sizeof(buf));
+		copy = scnprintf(buf, copy, "2.6.%u%s", v, rest);
+		ret = copy_to_user(release, buf, copy + 1);
 	}
 	return ret;
 }
@@ -2038,7 +2137,7 @@ int orderly_poweroff(bool force)
 
 	call_usermodehelper_setfns(info, NULL, argv_cleanup, NULL);
 
-	ret = call_usermodehelper_exec(info, UMH_NO_WAIT);
+	ret = call_usermodehelper_exec(info, UMH_WAIT_PROC);
 
   out:
 	if (ret && force) {
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 4ab11879..1bafea8e 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -102,6 +102,7 @@ extern char core_pattern[];
 extern unsigned int core_pipe_limit;
 extern int pid_max;
 extern int min_free_kbytes;
+extern int min_free_order_shift;
 extern int pid_max_min, pid_max_max;
 extern int sysctl_drop_caches;
 extern int percpu_pagelist_fraction;
@@ -114,6 +115,9 @@ extern int sysctl_nr_trim_pages;
 #ifdef CONFIG_BLOCK
 extern int blk_iopoll_enabled;
 #endif
+#ifdef CONFIG_CMA
+extern int cma_balance_ratio;
+#endif
 
 /* Constants used for minimum and  maximum */
 #ifdef CONFIG_LOCKUP_DETECTOR
@@ -768,6 +772,17 @@ static struct ctl_table kern_table[] = {
 		.extra1		= &zero,
 		.extra2		= &one,
 	},
+#if defined(CONFIG_SMP_HARDLOCKUP_DETECTOR)
+	{
+		.procname	= "hardlockup_enable",
+		.data		= &hardlockup_enable,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_hardlockup,
+		.extra1		= &zero,
+		.extra2		= &one,
+	},
+#endif
 #endif
 #if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_X86)
 	{
@@ -1198,6 +1213,13 @@ static struct ctl_table vm_table[] = {
 		.proc_handler	= min_free_kbytes_sysctl_handler,
 		.extra1		= &zero,
 	},
+	{
+		.procname	= "min_free_order_shift",
+		.data		= &min_free_order_shift,
+		.maxlen		= sizeof(min_free_order_shift),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
 	{
 		.procname	= "percpu_pagelist_fraction",
 		.data		= &percpu_pagelist_fraction,
@@ -1361,6 +1383,17 @@ static struct ctl_table vm_table[] = {
 		.extra1		= &zero,
 		.extra2		= &one,
 	},
+#endif
+#ifdef CONFIG_CMA
+	{
+		.procname	= "cma_balance_ratio",
+		.data		= &cma_balance_ratio,
+		.maxlen		= sizeof(cma_balance_ratio),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &zero,
+		.extra2		= &one_hundred,
+	},
 #endif
 	{ }
 };
diff --git a/kernel/time/alarmtimer.c b/kernel/time/alarmtimer.c
index 8a538c55..a01e14e5 100644
--- a/kernel/time/alarmtimer.c
+++ b/kernel/time/alarmtimer.c
@@ -37,7 +37,6 @@
 static struct alarm_base {
 	spinlock_t		lock;
 	struct timerqueue_head	timerqueue;
-	struct hrtimer		timer;
 	ktime_t			(*gettime)(void);
 	clockid_t		base_clockid;
 } alarm_bases[ALARM_NUMTYPE];
@@ -46,6 +45,8 @@ static struct alarm_base {
 static ktime_t freezer_delta;
 static DEFINE_SPINLOCK(freezer_delta_lock);
 
+static struct wakeup_source *ws;
+
 #ifdef CONFIG_RTC_CLASS
 /* rtc timer and device for setting alarm wakeups at suspend */
 static struct rtc_timer		rtctimer;
@@ -59,7 +60,7 @@ static DEFINE_SPINLOCK(rtcdev_lock);
  * If one has not already been chosen, it checks to see if a
  * functional rtc device is available.
  */
-static struct rtc_device *alarmtimer_get_rtcdev(void)
+struct rtc_device *alarmtimer_get_rtcdev(void)
 {
 	unsigned long flags;
 	struct rtc_device *ret;
@@ -115,7 +116,7 @@ static void alarmtimer_rtc_interface_remove(void)
 	class_interface_unregister(&alarmtimer_rtc_interface);
 }
 #else
-static inline struct rtc_device *alarmtimer_get_rtcdev(void)
+struct rtc_device *alarmtimer_get_rtcdev(void)
 {
 	return NULL;
 }
@@ -130,21 +131,17 @@ static inline void alarmtimer_rtc_timer_init(void) { }
  * @base: pointer to the base where the timer is being run
  * @alarm: pointer to alarm being enqueued.
  *
- * Adds alarm to a alarm_base timerqueue and if necessary sets
- * an hrtimer to run.
+ * Adds alarm to a alarm_base timerqueue
  *
  * Must hold base->lock when calling.
  */
 static void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)
 {
+	if (alarm->state & ALARMTIMER_STATE_ENQUEUED)
+		timerqueue_del(&base->timerqueue, &alarm->node);
+
 	timerqueue_add(&base->timerqueue, &alarm->node);
 	alarm->state |= ALARMTIMER_STATE_ENQUEUED;
-
-	if (&alarm->node == timerqueue_getnext(&base->timerqueue)) {
-		hrtimer_try_to_cancel(&base->timer);
-		hrtimer_start(&base->timer, alarm->node.expires,
-				HRTIMER_MODE_ABS);
-	}
 }
 
 /**
@@ -152,28 +149,17 @@ static void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)
  * @base: pointer to the base where the timer is running
  * @alarm: pointer to alarm being removed
  *
- * Removes alarm to a alarm_base timerqueue and if necessary sets
- * a new timer to run.
+ * Removes alarm to a alarm_base timerqueue
  *
  * Must hold base->lock when calling.
  */
 static void alarmtimer_remove(struct alarm_base *base, struct alarm *alarm)
 {
-	struct timerqueue_node *next = timerqueue_getnext(&base->timerqueue);
-
 	if (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))
 		return;
 
 	timerqueue_del(&base->timerqueue, &alarm->node);
 	alarm->state &= ~ALARMTIMER_STATE_ENQUEUED;
-
-	if (next == &alarm->node) {
-		hrtimer_try_to_cancel(&base->timer);
-		next = timerqueue_getnext(&base->timerqueue);
-		if (!next)
-			return;
-		hrtimer_start(&base->timer, next->expires, HRTIMER_MODE_ABS);
-	}
 }
 
 
@@ -188,42 +174,23 @@ static void alarmtimer_remove(struct alarm_base *base, struct alarm *alarm)
  */
 static enum hrtimer_restart alarmtimer_fired(struct hrtimer *timer)
 {
-	struct alarm_base *base = container_of(timer, struct alarm_base, timer);
-	struct timerqueue_node *next;
+	struct alarm *alarm = container_of(timer, struct alarm, timer);
+	struct alarm_base *base = &alarm_bases[alarm->type];
 	unsigned long flags;
-	ktime_t now;
 	int ret = HRTIMER_NORESTART;
 	int restart = ALARMTIMER_NORESTART;
 
 	spin_lock_irqsave(&base->lock, flags);
-	now = base->gettime();
-	while ((next = timerqueue_getnext(&base->timerqueue))) {
-		struct alarm *alarm;
-		ktime_t expired = next->expires;
-
-		if (expired.tv64 > now.tv64)
-			break;
-
-		alarm = container_of(next, struct alarm, node);
-
-		timerqueue_del(&base->timerqueue, &alarm->node);
-		alarm->state &= ~ALARMTIMER_STATE_ENQUEUED;
-
-		alarm->state |= ALARMTIMER_STATE_CALLBACK;
-		spin_unlock_irqrestore(&base->lock, flags);
-		if (alarm->function)
-			restart = alarm->function(alarm, now);
-		spin_lock_irqsave(&base->lock, flags);
-		alarm->state &= ~ALARMTIMER_STATE_CALLBACK;
+	alarmtimer_remove(base, alarm);
+	spin_unlock_irqrestore(&base->lock, flags);
 
-		if (restart != ALARMTIMER_NORESTART) {
-			timerqueue_add(&base->timerqueue, &alarm->node);
-			alarm->state |= ALARMTIMER_STATE_ENQUEUED;
-		}
-	}
+	if (alarm->function)
+		restart = alarm->function(alarm, base->gettime());
 
-	if (next) {
-		hrtimer_set_expires(&base->timer, next->expires);
+	spin_lock_irqsave(&base->lock, flags);
+	if (restart != ALARMTIMER_NORESTART) {
+		hrtimer_set_expires(&alarm->timer, alarm->node.expires);
+		alarmtimer_enqueue(base, alarm);
 		ret = HRTIMER_RESTART;
 	}
 	spin_unlock_irqrestore(&base->lock, flags);
@@ -250,6 +217,7 @@ static int alarmtimer_suspend(struct device *dev)
 	unsigned long flags;
 	struct rtc_device *rtc;
 	int i;
+	int ret;
 
 	spin_lock_irqsave(&freezer_delta_lock, flags);
 	min = freezer_delta;
@@ -281,6 +249,10 @@ static int alarmtimer_suspend(struct device *dev)
 
 	/* XXX - Should we enforce a minimum sleep time? */
 	WARN_ON(min.tv64 < NSEC_PER_SEC);
+	if (ktime_to_ns(min) < 2 * NSEC_PER_SEC) {
+		__pm_wakeup_event(ws, 2 * MSEC_PER_SEC);
+		return -EBUSY;
+	}
 
 	/* Setup an rtc timer to fire that far in the future */
 	rtc_timer_cancel(rtc, &rtctimer);
@@ -288,9 +260,10 @@ static int alarmtimer_suspend(struct device *dev)
 	now = rtc_tm_to_ktime(tm);
 	now = ktime_add(now, min);
 
-	rtc_timer_start(rtc, &rtctimer, now, ktime_set(0, 0));
-
-	return 0;
+	ret = rtc_timer_start(rtc, &rtctimer, now, ktime_set(0, 0));
+	if (ret < 0)
+		__pm_wakeup_event(ws, MSEC_PER_SEC);
+	return ret;
 }
 #else
 static int alarmtimer_suspend(struct device *dev)
@@ -324,6 +297,9 @@ void alarm_init(struct alarm *alarm, enum alarmtimer_type type,
 		enum alarmtimer_restart (*function)(struct alarm *, ktime_t))
 {
 	timerqueue_init(&alarm->node);
+	hrtimer_init(&alarm->timer, alarm_bases[type].base_clockid,
+			HRTIMER_MODE_ABS);
+	alarm->timer.function = alarmtimer_fired;
 	alarm->function = function;
 	alarm->type = type;
 	alarm->state = ALARMTIMER_STATE_INACTIVE;
@@ -334,17 +310,19 @@ void alarm_init(struct alarm *alarm, enum alarmtimer_type type,
  * @alarm: ptr to alarm to set
  * @start: time to run the alarm
  */
-void alarm_start(struct alarm *alarm, ktime_t start)
+int alarm_start(struct alarm *alarm, ktime_t start)
 {
 	struct alarm_base *base = &alarm_bases[alarm->type];
 	unsigned long flags;
+	int ret;
 
 	spin_lock_irqsave(&base->lock, flags);
-	if (alarmtimer_active(alarm))
-		alarmtimer_remove(base, alarm);
 	alarm->node.expires = start;
 	alarmtimer_enqueue(base, alarm);
+	ret = hrtimer_start(&alarm->timer, alarm->node.expires,
+				HRTIMER_MODE_ABS);
 	spin_unlock_irqrestore(&base->lock, flags);
+	return ret;
 }
 
 /**
@@ -358,18 +336,12 @@ int alarm_try_to_cancel(struct alarm *alarm)
 {
 	struct alarm_base *base = &alarm_bases[alarm->type];
 	unsigned long flags;
-	int ret = -1;
-	spin_lock_irqsave(&base->lock, flags);
+	int ret;
 
-	if (alarmtimer_callback_running(alarm))
-		goto out;
-
-	if (alarmtimer_is_queued(alarm)) {
+	spin_lock_irqsave(&base->lock, flags);
+	ret = hrtimer_try_to_cancel(&alarm->timer);
+	if (ret >= 0)
 		alarmtimer_remove(base, alarm);
-		ret = 1;
-	} else
-		ret = 0;
-out:
 	spin_unlock_irqrestore(&base->lock, flags);
 	return ret;
 }
@@ -802,10 +774,6 @@ static int __init alarmtimer_init(void)
 	for (i = 0; i < ALARM_NUMTYPE; i++) {
 		timerqueue_init_head(&alarm_bases[i].timerqueue);
 		spin_lock_init(&alarm_bases[i].lock);
-		hrtimer_init(&alarm_bases[i].timer,
-				alarm_bases[i].base_clockid,
-				HRTIMER_MODE_ABS);
-		alarm_bases[i].timer.function = alarmtimer_fired;
 	}
 
 	error = alarmtimer_rtc_interface_setup();
@@ -821,6 +789,7 @@ static int __init alarmtimer_init(void)
 		error = PTR_ERR(pdev);
 		goto out_drv;
 	}
+	ws = wakeup_source_register("alarmtimer");
 	return 0;
 
 out_drv:
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index d42574df..1ffa67fd 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -1142,7 +1142,8 @@ void get_monotonic_boottime(struct timespec *ts)
 	} while (read_seqretry(&timekeeper.lock, seq));
 
 	set_normalized_timespec(ts, ts->tv_sec + tomono.tv_sec + sleep.tv_sec,
-			ts->tv_nsec + tomono.tv_nsec + sleep.tv_nsec + nsecs);
+			(s64)ts->tv_nsec + (s64)tomono.tv_nsec +
+			(s64)sleep.tv_nsec + nsecs);
 }
 EXPORT_SYMBOL_GPL(get_monotonic_boottime);
 
diff --git a/kernel/timeconst.pl b/kernel/timeconst.pl
index eb51d76e..04612394 100644
--- a/kernel/timeconst.pl
+++ b/kernel/timeconst.pl
@@ -370,7 +370,7 @@ if ($hz eq '--can') {
 	}
 
 	@val = @{$canned_values{$hz}};
-	if (!defined(@val)) {
+	if (!@val) {
 		@val = compute_values($hz);
 	}
 	output($hz, @val);
diff --git a/kernel/timer.c b/kernel/timer.c
index a297ffcf..59330762 100644
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@ -49,6 +49,9 @@
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/timer.h>
+#ifdef CONFIG_SEC_DEBUG_TIMER_LOG
+#include <mach/sec_debug.h>
+#endif
 
 u64 jiffies_64 __cacheline_aligned_in_smp = INITIAL_JIFFIES;
 
@@ -1112,7 +1115,13 @@ static void call_timer_fn(struct timer_list *timer, void (*fn)(unsigned long),
 	lock_map_acquire(&lockdep_map);
 
 	trace_timer_expire_entry(timer);
+#ifdef CONFIG_SEC_DEBUG_TIMER_LOG
+	sec_debug_timer_log(5555, (void*)fn);
+#endif
 	fn(data);
+#ifdef CONFIG_SEC_DEBUG_TIMER_LOG
+	sec_debug_timer_log(6666, (void*)fn);
+#endif
 	trace_timer_expire_exit(timer);
 
 	lock_map_release(&lockdep_map);
diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c
index cf8d11e9..8ed40f61 100644
--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -22,6 +22,22 @@
 
 #include <asm/local.h>
 #include "trace.h"
+#include <linux/vmalloc.h>
+#include <asm/cacheflush.h>
+
+unsigned char non_cache_set;
+unsigned char enable_change_trace_buffer;
+static void *remap_noncached_page(struct page *page)
+{
+	void *start;
+	memset(page_address(page), 0, PAGE_SIZE);
+	dmac_flush_range(page_address(page), page_address(page) + PAGE_SIZE);
+	outer_flush_range(__pa(page_address(page)),
+			__pa(page_address(page)) + PAGE_SIZE);
+
+	start = vmap(&page, 1, 0, pgprot_noncached(pgprot_kernel));
+	return start;
+}
 
 /*
  * The ring buffer header is special. We must manually up keep it.
@@ -349,6 +365,9 @@ struct buffer_page {
 	local_t		 entries;	/* entries on this page */
 	unsigned long	 real_end;	/* real end of data */
 	struct buffer_data_page *page;	/* Actual data page */
+	unsigned long *cached_page;	/* MARVELL: cached page addr for free */
+	unsigned long *struct_page;	/* MARVELL: the struct
+					   located non-cached page */
 };
 
 /*
@@ -389,8 +408,20 @@ size_t ring_buffer_page_len(void *page)
  */
 static void free_buffer_page(struct buffer_page *bpage)
 {
-	free_page((unsigned long)bpage->page);
-	kfree(bpage);
+	if (non_cache_set == 1) {
+		/*
+		 * Free pages of trace buffer.
+		 */
+		free_page((unsigned long)bpage->cached_page);
+		/*
+		 * Free non-cached pages which hold structs.
+		 */
+		if ((unsigned long)(bpage->struct_page))
+			free_page((unsigned long)(bpage->struct_page));
+	} else {
+		free_page((unsigned long)bpage->cached_page);
+		kfree(bpage);
+	}
 }
 
 /*
@@ -969,19 +1000,21 @@ static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,
 	struct buffer_page *bpage, *tmp;
 	LIST_HEAD(pages);
 	unsigned i;
+	struct page *page;
 
 	WARN_ON(!nr_pages);
 
 	for (i = 0; i < nr_pages; i++) {
-		struct page *page;
 		/*
 		 * __GFP_NORETRY flag makes sure that the allocation fails
 		 * gracefully without invoking oom-killer and the system is
 		 * not destabilized.
 		 */
-		bpage = kzalloc_node(ALIGN(sizeof(*bpage), cache_line_size()),
-				    GFP_KERNEL | __GFP_NORETRY,
-				    cpu_to_node(cpu_buffer->cpu));
+		bpage = kzalloc_node(ALIGN(sizeof(*bpage),
+						cache_line_size()),
+					GFP_KERNEL | __GFP_NORETRY,
+					cpu_to_node(cpu_buffer->cpu));
+
 		if (!bpage)
 			goto free_pages;
 
@@ -991,9 +1024,12 @@ static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,
 
 		page = alloc_pages_node(cpu_to_node(cpu_buffer->cpu),
 					GFP_KERNEL | __GFP_NORETRY, 0);
+
 		if (!page)
 			goto free_pages;
+		bpage->cached_page = page_address(page);
 		bpage->page = page_address(page);
+
 		rb_init_page(bpage->page);
 	}
 
@@ -1004,7 +1040,6 @@ static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,
 	 */
 	cpu_buffer->pages = pages.next;
 	list_del(&pages);
-
 	rb_check_pages(cpu_buffer);
 
 	return 0;
@@ -1026,7 +1061,7 @@ rb_allocate_cpu_buffer(struct ring_buffer *buffer, int cpu)
 	int ret;
 
 	cpu_buffer = kzalloc_node(ALIGN(sizeof(*cpu_buffer), cache_line_size()),
-				  GFP_KERNEL, cpu_to_node(cpu));
+			GFP_KERNEL, cpu_to_node(cpu));
 	if (!cpu_buffer)
 		return NULL;
 
@@ -1037,7 +1072,8 @@ rb_allocate_cpu_buffer(struct ring_buffer *buffer, int cpu)
 	cpu_buffer->lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;
 
 	bpage = kzalloc_node(ALIGN(sizeof(*bpage), cache_line_size()),
-			    GFP_KERNEL, cpu_to_node(cpu));
+			GFP_KERNEL, cpu_to_node(cpu));
+
 	if (!bpage)
 		goto fail_free_buffer;
 
@@ -1047,7 +1083,10 @@ rb_allocate_cpu_buffer(struct ring_buffer *buffer, int cpu)
 	page = alloc_pages_node(cpu_to_node(cpu), GFP_KERNEL, 0);
 	if (!page)
 		goto fail_free_reader;
+	bpage->cached_page = page_address(page);
+
 	bpage->page = page_address(page);
+
 	rb_init_page(bpage->page);
 
 	INIT_LIST_HEAD(&cpu_buffer->reader_page->list);
@@ -1069,6 +1108,7 @@ rb_allocate_cpu_buffer(struct ring_buffer *buffer, int cpu)
 
  fail_free_buffer:
 	kfree(cpu_buffer);
+
 	return NULL;
 }
 
@@ -1222,6 +1262,167 @@ void ring_buffer_set_clock(struct ring_buffer *buffer,
 
 static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);
 
+/*
+ * The fucntion put structs into one page, which include cpu_buffer,
+ * reader_page, buffer_page.
+ */
+static struct ring_buffer_per_cpu *
+rb_switch_cpu_buffer(struct ring_buffer *buffer, int cpu)
+{
+	struct ring_buffer_per_cpu *cpu_buffer;
+	struct buffer_page *bpage, *p, *tmp;
+	struct page *page, *page_s;
+	void *start_struct, *start;
+	unsigned nr_pages = 0;
+	struct page **pages_list = NULL;
+
+	/* init list head for each cpu */
+	LIST_HEAD(pages);
+	LIST_HEAD(pages_l);
+
+	rb_head_page_deactivate(buffer->buffers[cpu]);
+
+	/*
+	 * for each cpu, allocate a page to hold the struct of
+	 * a cpu_buffer, struct buffer_pages of a new reader
+	 * and two pages
+	 */
+	page_s = alloc_pages_node(cpu_to_node(cpu),
+			GFP_KERNEL, 0);
+	if (!page_s)
+		return NULL;
+	start_struct = remap_noncached_page(page_s);
+	start = start_struct;
+	if (!start) {
+		printk(KERN_WARNING
+				"trace:switch non-cached:"
+				"vmap cpu_buffer fail.\n");
+		goto fail_free_struct_page;
+	}
+	cpu_buffer = start;
+	memcpy(cpu_buffer, buffer->buffers[cpu], sizeof(*cpu_buffer));
+
+	/* new a reader page */
+	start += ALIGN(sizeof(*cpu_buffer), cache_line_size());
+	bpage = start;
+	memcpy(bpage, buffer->buffers[cpu]->reader_page,
+			sizeof(*bpage));
+
+	page = alloc_pages_node(cpu_to_node(cpu),
+			GFP_KERNEL, 0);
+
+	if (!page)
+		goto fail_free_struct;
+	bpage->cached_page = page_address(page);
+	bpage->page = remap_noncached_page(page);
+	if (!bpage->page) {
+		printk(KERN_WARNING
+				"trace:switch non-cached:"
+				"vmap reader page fail.\n");
+		free_page((unsigned int)page_address(page));
+		goto fail_free_struct;
+	}
+	memcpy(bpage->page, buffer->buffers[cpu]->reader_page->page,
+			PAGE_SIZE);
+
+	cpu_buffer->reader_page = bpage;
+
+	pages_list = vmalloc(sizeof(struct page *) * 2);
+	/* new two pages */
+	list_add(&pages_l, &buffer->buffers[cpu]->head_page->list);
+	list_for_each_entry(p, &pages_l, list) {
+		start += ALIGN(sizeof(*p), cache_line_size());
+		bpage = start;
+		memcpy(bpage, p, sizeof(*p));
+
+		page = alloc_pages_node(cpu_to_node(cpu),
+				GFP_KERNEL, 0);
+
+		if (!page)
+			goto free_pages;
+		/* invalidate the page */
+		memset(page_address(page), 0, PAGE_SIZE);
+		dmac_flush_range(page_address(page),
+				page_address(page) + PAGE_SIZE);
+		outer_flush_range(__pa(page_address(page)),
+				__pa(page_address(page))
+				+ PAGE_SIZE);
+		bpage->cached_page = page_address(page);
+		bpage->page = page_address(page);
+		pages_list[nr_pages++] = page;
+
+		memcpy(bpage->page, p->page, PAGE_SIZE);
+		list_add(&bpage->list, &pages);
+	}
+	list_del_init(&pages_l);
+
+	/* change to non-cached */
+	start = vmap(pages_list, nr_pages, 0, pgprot_noncached(pgprot_kernel));
+	if (!start) {
+		printk(KERN_WARNING
+				"switch_cpu_buffer: vmap fialure\n");
+		vfree(pages_list);
+		goto free_pages;
+	}
+	list_for_each_entry_reverse(tmp, &pages, list) {
+		tmp->page = start;
+		start += PAGE_SIZE;
+	}
+	vfree(pages_list);
+
+	/* init the new struct cpu_buffer */
+	cpu_buffer->pages = pages.next;
+	list_del_init(&pages);
+
+	cpu_buffer->head_page =
+		 list_entry(cpu_buffer->pages,
+				 struct buffer_page, list);
+	cpu_buffer->tail_page = cpu_buffer->commit_page =
+		cpu_buffer->head_page;
+	rb_head_page_activate(cpu_buffer);
+
+	rb_free_cpu_buffer(buffer->buffers[cpu]);
+
+	return cpu_buffer;
+
+ free_pages:
+	non_cache_set = 1;
+	free_buffer_page(cpu_buffer->reader_page);
+	list_for_each_entry_safe(bpage, tmp, &pages, list) {
+		list_del_init(&bpage->list);
+		free_buffer_page(bpage);
+	}
+ fail_free_struct:
+	vunmap(start_struct);
+ fail_free_struct_page:
+	free_page((unsigned int)page_address(page_s));
+
+	return NULL;
+}
+
+/*
+ * MARVELL:this function is used to change cached to noncached
+ * before trace is working
+ */
+static int change_ring_buffer_struct(struct ring_buffer *buffer)
+{
+	int cpu;
+	void *tmp;
+
+	for_each_buffer_cpu(buffer, cpu) {
+		tmp = rb_switch_cpu_buffer(buffer, cpu);
+		if (!tmp) {
+			WARN(1, "failed to swtich ring buffer on CPU %d\n",
+			     cpu);
+			return -ENOMEM;
+		}
+		buffer->buffers[cpu] = tmp;
+	}
+
+	non_cache_set = 1;
+	return 0;
+}
+
 static void
 rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned nr_pages)
 {
@@ -1292,8 +1493,11 @@ int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size)
 	struct buffer_page *bpage, *tmp;
 	unsigned long buffer_size;
 	LIST_HEAD(pages);
-	int i, cpu;
-
+	int i = 0, cpu, ret;
+	struct page *page;
+	struct page **pages_list = NULL;
+	struct page **struct_list = NULL;
+	void *start = NULL, *struct_start = NULL;
 	/*
 	 * Always succeed at resizing a non-existent buffer:
 	 */
@@ -1319,6 +1523,28 @@ int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size)
 	mutex_lock(&buffer->mutex);
 	get_online_cpus();
 
+	/*
+	 * non_cached_set value meaning:
+	 * 1: indicate buffer noncached and trace is working
+	 * 2: indicate buffer cached and trace is working
+	 * 0: indicate trace is not working, we can switch
+	 *
+	 * we only can change to non-cachedable once, and
+	 * it is irreversible.
+	 */
+	if (non_cache_set != 1) {
+		non_cache_set = 2;
+		if (enable_change_trace_buffer) {
+			ret = change_ring_buffer_struct(buffer);
+			if (ret < 0) {
+				printk(KERN_WARNING
+						"trace:resize:switch to non_cached fail\n");
+				non_cache_set = 2;
+				enable_change_trace_buffer = 0;
+			}
+		}
+	}
+
 	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);
 
 	if (size < buffer_size) {
@@ -1348,31 +1574,165 @@ int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size)
 		goto out_fail;
 
 	new_pages = nr_pages - buffer->pages;
+	/*
+	 * Non cached trace: need to set non-cached struct and buffer.
+	 */
+	if (non_cache_set == 1) {
+		unsigned vm_times = 0;
+		unsigned long size_struct, struct_phy;
+		int nr, nr_struct;
+
+		/*
+		 * For buffer:
+		 * Count the numbers of struct page needed to allocate.
+		 */
+		for_each_buffer_cpu(buffer, cpu)
+				vm_times++;
+		nr = new_pages * vm_times;
+		pages_list = vmalloc(sizeof(struct page *) * nr);
+		if (!pages_list)
+			return -ENOMEM;
+
+		/*
+		 * For struct:
+		 * Count the numbers of struct page, allocate pages,
+		 * vmap to non-cached.
+		 */
+		size_struct = new_pages * ALIGN(sizeof(*bpage),
+				cache_line_size());
+		size_struct = PAGE_ALIGN(size_struct);
+		size_struct *= vm_times;
+		nr_struct = size_struct >> PAGE_SHIFT;
+		struct_start = alloc_pages_exact(size_struct,
+				GFP_KERNEL | __GFP_NORETRY);
+
+		if (!struct_start) {
+			vfree(pages_list);
+			return -ENOMEM;
+		}
+
+		struct_phy = virt_to_phys(struct_start);
+		memset(struct_start, 0x0, size_struct);
+		/* invalidate the buffer before vmap as noncacheable */
+		dmac_flush_range(struct_start, struct_start + size_struct);
+		outer_flush_range(struct_phy, struct_phy + size_struct);
+
+		struct_list = vmalloc(sizeof(struct page *) * nr_struct);
+		if (!struct_list) {
+			free_pages_exact(struct_start, size_struct);
+			vfree(pages_list);
+			return -ENOMEM;
+		}
+
+		while (i < nr_struct) {
+			struct_list[i] = phys_to_page(struct_phy +
+					(i << PAGE_SHIFT));
+			i++;
+		}
+
+		start = vmap(struct_list, nr_struct,
+				0, pgprot_noncached(pgprot_kernel));
+		if (!start) {
+			printk(KERN_WARNING
+					"trace: vmap failure, please set a"
+					"smaller size < 50000\n");
+			vfree(struct_list);
+			free_pages_exact(struct_start, size_struct);
+			vfree(pages_list);
+			return -ENOMEM;
+		}
+		vfree(struct_list);
+	}
 
 	for_each_buffer_cpu(buffer, cpu) {
+		if (non_cache_set == 1) {
+			start = (void *)PAGE_ALIGN((unsigned long)start);
+			struct_start = (void *) \
+				PAGE_ALIGN((unsigned long)struct_start);
+		}
 		for (i = 0; i < new_pages; i++) {
-			struct page *page;
 			/*
-			 * __GFP_NORETRY flag makes sure that the allocation
-			 * fails gracefully without invoking oom-killer and
-			 * the system is not destabilized.
+			 * Handle struct allocation
 			 */
-			bpage = kzalloc_node(ALIGN(sizeof(*bpage),
-						  cache_line_size()),
-					    GFP_KERNEL | __GFP_NORETRY,
-					    cpu_to_node(cpu));
+			if (non_cache_set == 1) {
+				/*
+				 * Put every buffer_page on
+				 * non-cached pages.
+				 */
+				bpage = start;
+				start += ALIGN(sizeof(*bpage),
+						cache_line_size());
+				/*
+				 * Save the page address for free
+				 */
+				if (!((unsigned long)struct_start % PAGE_SIZE))
+					bpage->struct_page = struct_start;
+				struct_start += ALIGN(sizeof(*bpage),
+						cache_line_size());
+			} else
+				/*
+				 * __GFP_NORETRY flag makes sure that the
+				 * allocation fails gracefully without
+				 * invoking oom-killer and the system is
+				 * not destabilized.
+				 */
+				bpage = kzalloc_node(ALIGN(sizeof(*bpage),
+							cache_line_size()),
+						GFP_KERNEL | __GFP_NORETRY,
+						cpu_to_node(cpu));
+
 			if (!bpage)
 				goto free_pages;
 			list_add(&bpage->list, &pages);
 			page = alloc_pages_node(cpu_to_node(cpu),
 						GFP_KERNEL | __GFP_NORETRY, 0);
+
 			if (!page)
 				goto free_pages;
+
+			/*
+			 * Add all buffer pages into pages_list
+			 * in order to be non-cached by vmap.
+			 */
+			bpage->cached_page = page_address(page);
+			if (non_cache_set == 1) {
+				/*
+				 * For non-cached purpose, invalidate page
+				 * and update pages_list.
+				 */
+				memset(page_address(page), 0, PAGE_SIZE);
+				dmac_flush_range(page_address(page),
+						page_address(page) + PAGE_SIZE);
+				outer_flush_range(__pa(page_address(page)),
+						__pa(page_address(page))
+						+ PAGE_SIZE);
+				pages_list[i + cpu*new_pages] = page;
+			}
 			bpage->page = page_address(page);
 			rb_init_page(bpage->page);
 		}
 	}
 
+	/*
+	 * vmap all buffer pages and update the value of "page"
+	 * in struct "buffer_page".
+	 */
+	if (non_cache_set == 1) {
+		start = vmap(pages_list, new_pages*cpu,
+				0, pgprot_noncached(pgprot_kernel));
+		if (!start) {
+			printk(KERN_WARNING
+					"trace: vmap failure, please set a "
+					"smaller size < 50000!\n");
+			vfree(pages_list);
+			goto free_pages;
+		}
+		list_for_each_entry_reverse(tmp, &pages, list) {
+			tmp->page = start;
+			start += PAGE_SIZE;
+		}
+		vfree(pages_list);
+	}
 	for_each_buffer_cpu(buffer, cpu) {
 		cpu_buffer = buffer->buffers[cpu];
 		rb_insert_pages(cpu_buffer, &pages, new_pages);
@@ -3846,11 +4206,23 @@ void *ring_buffer_alloc_read_page(struct ring_buffer *buffer, int cpu)
 	if (!page)
 		return NULL;
 
-	bpage = page_address(page);
+	if (non_cache_set == 1) {
+		bpage = remap_noncached_page(page);
+		if (!bpage) {
+			printk(KERN_WARNING
+					"trace:allocate read page fail.\n");
+			goto free_pages;
+		}
+	} else
+		bpage = page_address(page);
 
 	rb_init_page(bpage);
 
 	return bpage;
+
+ free_pages:
+	free_page((unsigned long)page_address(page));
+	return NULL;
 }
 EXPORT_SYMBOL_GPL(ring_buffer_alloc_read_page);
 
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 55e4d4c5..3f838909 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -1529,12 +1529,13 @@ int trace_vbprintk(unsigned long ip, const char *fmt, va_list args)
 	cpu = raw_smp_processor_id();
 	data = tr->data[cpu];
 
+	/* Lockdep uses trace_printk for lock tracing */
+	local_irq_save(flags);
+
 	disable = atomic_inc_return(&data->disabled);
 	if (unlikely(disable != 1))
 		goto out;
 
-	/* Lockdep uses trace_printk for lock tracing */
-	local_irq_save(flags);
 	arch_spin_lock(&trace_buf_lock);
 	len = vbin_printf(trace_buf, TRACE_BUF_SIZE, fmt, args);
 
@@ -1559,10 +1560,10 @@ int trace_vbprintk(unsigned long ip, const char *fmt, va_list args)
 
 out_unlock:
 	arch_spin_unlock(&trace_buf_lock);
-	local_irq_restore(flags);
 
 out:
 	atomic_dec_return(&data->disabled);
+	local_irq_restore(flags);
 	preempt_enable_notrace();
 	unpause_graph_tracing();
 
@@ -1608,12 +1609,13 @@ int trace_array_vprintk(struct trace_array *tr,
 	cpu = raw_smp_processor_id();
 	data = tr->data[cpu];
 
+	pause_graph_tracing();
+	raw_local_irq_save(irq_flags);
+
 	disable = atomic_inc_return(&data->disabled);
 	if (unlikely(disable != 1))
 		goto out;
 
-	pause_graph_tracing();
-	raw_local_irq_save(irq_flags);
 	arch_spin_lock(&trace_buf_lock);
 	len = vsnprintf(trace_buf, TRACE_BUF_SIZE, fmt, args);
 
@@ -1635,10 +1637,10 @@ int trace_array_vprintk(struct trace_array *tr,
 
  out_unlock:
 	arch_spin_unlock(&trace_buf_lock);
-	raw_local_irq_restore(irq_flags);
-	unpause_graph_tracing();
  out:
 	atomic_dec_return(&data->disabled);
+	raw_local_irq_restore(irq_flags);
+	unpause_graph_tracing();
 	preempt_enable_notrace();
 
 	return len;
@@ -4680,6 +4682,52 @@ static const struct file_operations rb_simple_fops = {
 	.llseek		= default_llseek,
 };
 
+static ssize_t
+tracing_noncached_read(struct file *filp, char __user *ubuf,
+		size_t cnt, loff_t *ppos)
+{
+	char buf[96];
+	int r;
+
+	r = sprintf(buf, "enable_trace_buffer_noncached=%d,non_cache_set=%d\n",
+			enable_change_trace_buffer, non_cache_set);
+	return simple_read_from_buffer(ubuf, cnt, ppos, buf, r);
+}
+
+static ssize_t
+tracing_noncached_write(struct file *filp, const char __user *ubuf,
+		size_t cnt, loff_t *ppos)
+{
+	unsigned long val;
+	int ret;
+
+	ret = kstrtoul_from_user(ubuf, cnt, 10, &val);
+	if (ret)
+		return ret;
+
+	if (non_cache_set)
+		pr_info("WARNING: can not switch since trace has been working!!\n");
+	else {
+		if (val) {
+			pr_info("ATTENTION:set trace buffer non-cachable!!!\n");
+			enable_change_trace_buffer = 1;
+		} else {
+			pr_info("ATTENTION:set trace buffer cachable!!!\n");
+			enable_change_trace_buffer = 0;
+		}
+	}
+	*ppos += cnt;
+
+	return cnt;
+}
+
+static const struct file_operations tracing_noncached_fops = {
+	.open		= tracing_open_generic,
+	.read		= tracing_noncached_read,
+	.write		= tracing_noncached_write,
+	.llseek		= default_llseek,
+};
+
 static __init int tracer_init_debugfs(void)
 {
 	struct dentry *d_tracer;
@@ -4742,6 +4790,9 @@ static __init int tracer_init_debugfs(void)
 	trace_create_file("tracing_on", 0644, d_tracer,
 			    &global_trace, &rb_simple_fops);
 
+	trace_create_file("trace_noncached_on", 0644, d_tracer,
+			    NULL, &tracing_noncached_fops);
+
 #ifdef CONFIG_DYNAMIC_FTRACE
 	trace_create_file("dyn_ftrace_total_info", 0444, d_tracer,
 			&ftrace_update_tot_cnt, &tracing_dyn_info_fops);
diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h
index f95d65da..bbdebe9f 100644
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@ -329,6 +329,8 @@ struct dentry *trace_create_file(const char *name,
 struct dentry *tracing_init_dentry(void);
 
 struct ring_buffer_event;
+extern unsigned char enable_change_trace_buffer;
+extern unsigned char non_cache_set;
 
 struct ring_buffer_event *
 trace_buffer_lock_reserve(struct ring_buffer *buffer,
diff --git a/kernel/watchdog.c b/kernel/watchdog.c
index df30ee08..efc6d331 100644
--- a/kernel/watchdog.c
+++ b/kernel/watchdog.c
@@ -25,6 +25,9 @@
 
 #include <asm/irq_regs.h>
 #include <linux/perf_event.h>
+#ifdef CONFIG_CORESIGHT_SUPPORT
+#include <mach/regs-coresight.h>
+#endif
 
 int watchdog_enabled = 1;
 int __read_mostly watchdog_thresh = 10;
@@ -33,6 +36,7 @@ static DEFINE_PER_CPU(unsigned long, watchdog_touch_ts);
 static DEFINE_PER_CPU(struct task_struct *, softlockup_watchdog);
 static DEFINE_PER_CPU(struct hrtimer, watchdog_hrtimer);
 static DEFINE_PER_CPU(bool, softlockup_touch_sync);
+static DEFINE_PER_CPU(bool, hrtimer_start_sync);
 static DEFINE_PER_CPU(bool, soft_watchdog_warn);
 #ifdef CONFIG_HARDLOCKUP_DETECTOR
 static DEFINE_PER_CPU(bool, hard_watchdog_warn);
@@ -42,6 +46,10 @@ static DEFINE_PER_CPU(unsigned long, hrtimer_interrupts_saved);
 static DEFINE_PER_CPU(struct perf_event *, watchdog_ev);
 #endif
 
+#ifdef CONFIG_SMP_HARDLOCKUP_DETECTOR
+static DEFINE_PER_CPU(unsigned long, hardlockup_touch_ts);
+#endif /* CONFIG_SMP_HARDLOCKUP_DETECTOR */
+
 /* boot commands */
 /*
  * Should we panic when a soft-lockup or hard-lockup occurs:
@@ -199,6 +207,71 @@ static int is_softlockup(unsigned long touch_ts)
 	return 0;
 }
 
+#ifdef CONFIG_SMP_HARDLOCKUP_DETECTOR
+DEFINE_SPINLOCK(hardlockup_lock);
+
+unsigned int __read_mostly hardlockup_enable = 1;
+
+/* proc handler for /proc/sys/kernel/hardlockup_enable */
+int proc_hardlockup(struct ctl_table *table, int write,
+		    void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	int ret;
+	int cpu;
+
+	ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+	if (ret || !write)
+		goto out;
+
+	if (hardlockup_enable) {
+		for_each_online_cpu(cpu)
+			per_cpu(hardlockup_touch_ts, cpu) = get_timestamp(0);
+	}
+out:
+	return ret;
+}
+
+static void smp_check_and_update_hardlockup(void)
+{
+	int cpu;
+	unsigned long now = get_timestamp(0);
+
+	spin_lock(&hardlockup_lock);
+	for_each_online_cpu(cpu) {
+		if (cpu == smp_processor_id()) {
+			per_cpu(hardlockup_touch_ts, cpu) = now;
+		} else {
+			if (!hardlockup_enable)
+				goto out;
+
+			if (!per_cpu(hrtimer_start_sync, cpu))
+				continue;
+
+			if (time_after(now, per_cpu(hardlockup_touch_ts, cpu)
+					   + watchdog_thresh)) {
+				WARN(1, "cpu%d detected cpu%d HARDLOCKUP!\n",
+					smp_processor_id(), cpu);
+#ifdef CONFIG_CORESIGHT_SUPPORT
+				coresight_panic_locked_cpu(cpu);
+#endif
+				per_cpu(hardlockup_touch_ts, cpu) = now;
+			}
+		}
+	}
+out:
+	spin_unlock(&hardlockup_lock);
+}
+
+static void update_smp_hardlockup_timestamp(int cpu)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hardlockup_lock, flags);
+	per_cpu(hardlockup_touch_ts, cpu) = get_timestamp(0);
+	spin_unlock_irqrestore(&hardlockup_lock, flags);
+}
+#endif /* CONFIG_SMP_HARDLOCKUP_DETECTOR */
+
 #ifdef CONFIG_HARDLOCKUP_DETECTOR
 
 static struct perf_event_attr wd_hw_attr = {
@@ -265,6 +338,10 @@ static enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)
 	/* kick the hardlockup detector */
 	watchdog_interrupt_count();
 
+#ifdef CONFIG_SMP_HARDLOCKUP_DETECTOR
+	smp_check_and_update_hardlockup();
+#endif /* CONFIG_SMP_HARDLOCKUP_DETECTOR */
+
 	/* kick the softlockup detector */
 	wake_up_process(__this_cpu_read(softlockup_watchdog));
 
@@ -331,6 +408,8 @@ static int watchdog(void *unused)
 	/* done here because hrtimer_start can only pin to smp_processor_id() */
 	hrtimer_start(hrtimer, ns_to_ktime(get_sample_period()),
 		      HRTIMER_MODE_REL_PINNED);
+	update_smp_hardlockup_timestamp(smp_processor_id());
+	__this_cpu_write(hrtimer_start_sync, true);
 
 	set_current_state(TASK_INTERRUPTIBLE);
 	/*
@@ -427,6 +506,15 @@ static void watchdog_prepare_cpu(int cpu)
 {
 	struct hrtimer *hrtimer = &per_cpu(watchdog_hrtimer, cpu);
 
+#ifdef CONFIG_SMP_HARDLOCKUP_DETECTOR
+	unsigned long flags;
+
+	spin_lock_irqsave(&hardlockup_lock, flags);
+	/* update boot CPU's timestamp */
+	per_cpu(hardlockup_touch_ts, smp_processor_id()) = get_timestamp(0);
+	spin_unlock_irqrestore(&hardlockup_lock, flags);
+#endif /* CONFIG_SMP_HARDLOCKUP_DETECTOR */
+
 	WARN_ON(per_cpu(softlockup_watchdog, cpu));
 	hrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 	hrtimer->function = watchdog_timer_fn;
@@ -472,6 +560,8 @@ static void watchdog_disable(int cpu)
 	struct task_struct *p = per_cpu(softlockup_watchdog, cpu);
 	struct hrtimer *hrtimer = &per_cpu(watchdog_hrtimer, cpu);
 
+	per_cpu(hrtimer_start_sync, cpu) = false;
+
 	/*
 	 * cancel the timer first to stop incrementing the stats
 	 * and waking up the kthread
@@ -552,6 +642,12 @@ cpu_callback(struct notifier_block *nfb, unsigned long action, void *hcpu)
 	int hotcpu = (unsigned long)hcpu;
 
 	switch (action) {
+#ifdef CONFIG_SMP_HARDLOCKUP_DETECTOR
+	case CPU_STARTING:
+	case CPU_STARTING_FROZEN:
+		update_smp_hardlockup_timestamp(hotcpu);
+		break;
+#endif /* CONFIG_SMP_HARDLOCKUP_DETECTOR */
 	case CPU_UP_PREPARE:
 	case CPU_UP_PREPARE_FROZEN:
 		watchdog_prepare_cpu(hotcpu);
@@ -566,8 +662,8 @@ cpu_callback(struct notifier_block *nfb, unsigned long action, void *hcpu)
 	case CPU_UP_CANCELED_FROZEN:
 		watchdog_disable(hotcpu);
 		break;
-	case CPU_DEAD:
-	case CPU_DEAD_FROZEN:
+	case CPU_DOWN_PREPARE:
+	case CPU_DOWN_PREPARE_FROZEN:
 		watchdog_disable(hotcpu);
 		break;
 #endif /* CONFIG_HOTPLUG_CPU */
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 7da267c8..31a27f68 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -41,7 +41,9 @@
 #include <linux/debug_locks.h>
 #include <linux/lockdep.h>
 #include <linux/idr.h>
-
+#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
+#include <mach/sec_debug.h>
+#endif
 #include "workqueue_sched.h"
 
 enum {
@@ -1868,11 +1870,17 @@ __acquires(&gcwq->lock)
 	lock_map_acquire_read(&cwq->wq->lockdep_map);
 	lock_map_acquire(&lockdep_map);
 	trace_workqueue_execute_start(work);
+#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
+	sec_debug_work_log(worker, work, f, 1);
+#endif
 	f(work);
 	/*
 	 * While we must be careful to not use "work" after this, the trace
 	 * point will only record its address.
 	 */
+#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
+	sec_debug_work_log(worker, work, f, 2);
+#endif
 	trace_workqueue_execute_end(work);
 	lock_map_release(&lockdep_map);
 	lock_map_release(&cwq->wq->lockdep_map);
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index 6777153f..ad13b9bf 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -10,6 +10,33 @@ config PRINTK_TIME
 	  in kernel startup.  Or add printk.time=1 at boot-time.
 	  See Documentation/kernel-parameters.txt
 
+config PRINTK_CPU_ID
+	bool "Show cpu id on printks"
+	depends on PRINTK && SMP
+	help
+	  Selecting this option causes current printk cpu id to be
+	  included in printk output. Or add printk.cpu=1 at boot-time.
+	  This allows you to see the running cpu id with kernel log.
+	  See Documentation/kernel-parameters.txt
+
+config PRINTK_PID
+	bool "Show pid on printks"
+	depends on PRINTK
+	help
+	  Selecting this option causes current task's pid to be
+	  included in printk output. Or add printk.pid=1 at boot-time.
+	  This allows you to see the running process id with kernel log.
+	  See Documentation/kernel-parameters.txt
+
+config PRINTK_COMM
+	bool "Show comm on printks"
+	depends on PRINTK
+	help
+	  Selecting this option causes current task's comm to be
+	  included in printk output. Or add printk.comm=1 at boot-time.
+	  This allows you to see the running process name with kernel log.
+	  See Documentation/kernel-parameters.txt
+
 config DEFAULT_MESSAGE_LOGLEVEL
 	int "Default message log level (1-7)"
 	range 1 7
@@ -186,6 +213,15 @@ config HARDLOCKUP_DETECTOR
 	def_bool LOCKUP_DETECTOR && PERF_EVENTS && HAVE_PERF_EVENTS_NMI && \
 		 !HAVE_NMI_WATCHDOG
 
+config SMP_HARDLOCKUP_DETECTOR
+	bool "Detect hard lockups on SMP systems"
+	depends on SMP
+	help
+	  Say Y to enable hard lockup detector on SMP systems without NMI.
+	  The SMP_HARDLOCKUP_DETECTOR can work only when there are two or
+	  more CPUs online (alive). If there is only one CPU, this detector
+	  will not work.
+
 config BOOTPARAM_HARDLOCKUP_PANIC
 	bool "Panic (Reboot) On Hard Lockups"
 	depends on LOCKUP_DETECTOR
@@ -676,8 +712,9 @@ config DEBUG_LOCKING_API_SELFTESTS
 	  mutexes and rwsems.
 
 config STACKTRACE
-	bool
+	bool "Stacktrace"
 	depends on STACKTRACE_SUPPORT
+	default y
 
 config DEBUG_STACK_USAGE
 	bool "Stack utilization instrumentation"
@@ -1289,6 +1326,13 @@ config ASYNC_RAID6_TEST
 
 	  If unsure, say N.
 
+config REGDUMP
+	bool "perform regdump while in running time or crash"
+	---help---
+	  This is register dump framework
+
+	  If unsure, say N.
+
 source "samples/Kconfig"
 
 source "lib/Kconfig.kgdb"
diff --git a/lib/idr.c b/lib/idr.c
index 4046e29c..ed055b29 100644
--- a/lib/idr.c
+++ b/lib/idr.c
@@ -29,7 +29,7 @@
 #ifndef TEST                        // to test in user space...
 #include <linux/slab.h>
 #include <linux/init.h>
-#include <linux/export.h>
+#include <linux/module.h>
 #endif
 #include <linux/err.h>
 #include <linux/string.h>
@@ -595,10 +595,8 @@ EXPORT_SYMBOL(idr_for_each);
  * Returns pointer to registered object with id, which is next number to
  * given id. After being looked up, *@nextidp will be updated for the next
  * iteration.
- *
- * This function can be called under rcu_read_lock(), given that the leaf
- * pointers lifetimes are correctly managed.
  */
+
 void *idr_get_next(struct idr *idp, int *nextidp)
 {
 	struct idr_layer *p, *pa[MAX_LEVEL];
@@ -607,11 +605,11 @@ void *idr_get_next(struct idr *idp, int *nextidp)
 	int n, max;
 
 	/* find first ent */
+	n = idp->layers * IDR_BITS;
+	max = 1 << n;
 	p = rcu_dereference_raw(idp->top);
 	if (!p)
 		return NULL;
-	n = (p->layer + 1) * IDR_BITS;
-	max = 1 << n;
 
 	while (id < max) {
 		while (n > 0 && p) {
diff --git a/mm/Kconfig b/mm/Kconfig
index e338407f..b7bd2914 100644
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@ -145,7 +145,7 @@ config MEMORY_HOTPLUG
 	bool "Allow for memory hot-add"
 	depends on SPARSEMEM || X86_64_ACPI_NUMA
 	depends on HOTPLUG && ARCH_ENABLE_MEMORY_HOTPLUG
-	depends on (IA64 || X86 || PPC_BOOK3S_64 || SUPERH || S390)
+	depends on (IA64 || X86 || PPC_BOOK3S_64 || SUPERH || S390 || ARM)
 
 config MEMORY_HOTPLUG_SPARSE
 	def_bool y
@@ -156,6 +156,10 @@ config MEMORY_HOTREMOVE
 	depends on MEMORY_HOTPLUG && ARCH_ENABLE_MEMORY_HOTREMOVE
 	depends on MIGRATION
 
+config MEMORY_FORCE_MOVABLE_HIGHMEM
+	bool "force movable zone as highmem"
+	depends on MEMORY_HOTPLUG && HIGHMEM
+
 #
 # If we have space for more page flags then we can enable additional
 # optimizations and functionality.
@@ -198,7 +202,7 @@ config COMPACTION
 config MIGRATION
 	bool "Page migration"
 	def_bool y
-	depends on NUMA || ARCH_ENABLE_MEMORY_HOTREMOVE || COMPACTION
+	depends on NUMA || ARCH_ENABLE_MEMORY_HOTREMOVE || COMPACTION || CMA
 	help
 	  Allows the migration of the physical location of pages of processes
 	  while the virtual addresses are not changed. This is useful in
diff --git a/mm/Makefile b/mm/Makefile
index 50ec00ef..8aada89e 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -13,7 +13,7 @@ obj-y			:= filemap.o mempool.o oom_kill.o fadvise.o \
 			   readahead.o swap.o truncate.o vmscan.o shmem.o \
 			   prio_tree.o util.o mmzone.o vmstat.o backing-dev.o \
 			   page_isolation.o mm_init.o mmu_context.o percpu.o \
-			   $(mmu-y)
+			   compaction.o $(mmu-y)
 obj-y += init-mm.o
 
 ifdef CONFIG_NO_BOOTMEM
@@ -32,7 +32,6 @@ obj-$(CONFIG_NUMA) 	+= mempolicy.o
 obj-$(CONFIG_SPARSEMEM)	+= sparse.o
 obj-$(CONFIG_SPARSEMEM_VMEMMAP) += sparse-vmemmap.o
 obj-$(CONFIG_SLOB) += slob.o
-obj-$(CONFIG_COMPACTION) += compaction.o
 obj-$(CONFIG_MMU_NOTIFIER) += mmu_notifier.o
 obj-$(CONFIG_KSM) += ksm.o
 obj-$(CONFIG_PAGE_POISONING) += debug-pagealloc.o
diff --git a/mm/compaction.c b/mm/compaction.c
index 459b0ab6..8decff49 100644
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@ -16,30 +16,11 @@
 #include <linux/sysfs.h>
 #include "internal.h"
 
+#if defined CONFIG_COMPACTION || defined CONFIG_CMA
+
 #define CREATE_TRACE_POINTS
 #include <trace/events/compaction.h>
 
-/*
- * compact_control is used to track pages being migrated and the free pages
- * they are being migrated to during memory compaction. The free_pfn starts
- * at the end of a zone and migrate_pfn begins at the start. Movable pages
- * are moved to the end of a zone during a compaction run and the run
- * completes when free_pfn <= migrate_pfn
- */
-struct compact_control {
-	struct list_head freepages;	/* List of free pages to migrate to */
-	struct list_head migratepages;	/* List of pages being migrated */
-	unsigned long nr_freepages;	/* Number of isolated free pages */
-	unsigned long nr_migratepages;	/* Number of pages to migrate */
-	unsigned long free_pfn;		/* isolate_freepages search base */
-	unsigned long migrate_pfn;	/* isolate_migratepages search base */
-	bool sync;			/* Synchronous migration */
-
-	int order;			/* order a direct compactor needs */
-	int migratetype;		/* MOVABLE, RECLAIMABLE etc */
-	struct zone *zone;
-};
-
 static unsigned long release_freepages(struct list_head *freelist)
 {
 	struct page *page, *next;
@@ -54,24 +35,35 @@ static unsigned long release_freepages(struct list_head *freelist)
 	return count;
 }
 
-/* Isolate free pages onto a private freelist. Must hold zone->lock */
-static unsigned long isolate_freepages_block(struct zone *zone,
-				unsigned long blockpfn,
-				struct list_head *freelist)
+static void map_pages(struct list_head *list)
+{
+	struct page *page;
+
+	list_for_each_entry(page, list, lru) {
+		arch_alloc_page(page, 0);
+		kernel_map_pages(page, 1, 1);
+	}
+}
+
+static inline bool migrate_async_suitable(int migratetype)
+{
+	return is_migrate_cma(migratetype) || migratetype == MIGRATE_MOVABLE;
+}
+
+/*
+ * Isolate free pages onto a private freelist. Caller must hold zone->lock.
+ * If @strict is true, will abort returning 0 on any invalid PFNs or non-free
+ * pages inside of the pageblock (even though it may still end up isolating
+ * some pages).
+ */
+static unsigned long isolate_freepages_block(unsigned long blockpfn,
+				unsigned long end_pfn,
+				struct list_head *freelist,
+				bool strict)
 {
-	unsigned long zone_end_pfn, end_pfn;
 	int nr_scanned = 0, total_isolated = 0;
 	struct page *cursor;
 
-	/* Get the last PFN we should scan for free pages at */
-	zone_end_pfn = zone->zone_start_pfn + zone->spanned_pages;
-	end_pfn = min(blockpfn + pageblock_nr_pages, zone_end_pfn);
-
-	/* Find the first usable PFN in the block to initialse page cursor */
-	for (; blockpfn < end_pfn; blockpfn++) {
-		if (pfn_valid_within(blockpfn))
-			break;
-	}
 	cursor = pfn_to_page(blockpfn);
 
 	/* Isolate free pages. This assumes the block is valid */
@@ -79,15 +71,23 @@ static unsigned long isolate_freepages_block(struct zone *zone,
 		int isolated, i;
 		struct page *page = cursor;
 
-		if (!pfn_valid_within(blockpfn))
+		if (!pfn_valid_within(blockpfn)) {
+			if (strict)
+				return 0;
 			continue;
+		}
 		nr_scanned++;
 
-		if (!PageBuddy(page))
+		if (!PageBuddy(page)) {
+			if (strict)
+				return 0;
 			continue;
+		}
 
 		/* Found a free page, break it into order-0 pages */
 		isolated = split_free_page(page);
+		if (!isolated && strict)
+			return 0;
 		total_isolated += isolated;
 		for (i = 0; i < isolated; i++) {
 			list_add(&page->lru, freelist);
@@ -105,114 +105,71 @@ static unsigned long isolate_freepages_block(struct zone *zone,
 	return total_isolated;
 }
 
-/* Returns true if the page is within a block suitable for migration to */
-static bool suitable_migration_target(struct page *page)
-{
-
-	int migratetype = get_pageblock_migratetype(page);
-
-	/* Don't interfere with memory hot-remove or the min_free_kbytes blocks */
-	if (migratetype == MIGRATE_ISOLATE || migratetype == MIGRATE_RESERVE)
-		return false;
-
-	/* If the page is a large free page, then allow migration */
-	if (PageBuddy(page) && page_order(page) >= pageblock_order)
-		return true;
-
-	/* If the block is MIGRATE_MOVABLE, allow migration */
-	if (migratetype == MIGRATE_MOVABLE)
-		return true;
-
-	/* Otherwise skip the block */
-	return false;
-}
-
-/*
- * Based on information in the current compact_control, find blocks
- * suitable for isolating free pages from and then isolate them.
+/**
+ * isolate_freepages_range() - isolate free pages.
+ * @start_pfn: The first PFN to start isolating.
+ * @end_pfn:   The one-past-last PFN.
+ *
+ * Non-free pages, invalid PFNs, or zone boundaries within the
+ * [start_pfn, end_pfn) range are considered errors, cause function to
+ * undo its actions and return zero.
+ *
+ * Otherwise, function returns one-past-the-last PFN of isolated page
+ * (which may be greater then end_pfn if end fell in a middle of
+ * a free page).
  */
-static void isolate_freepages(struct zone *zone,
-				struct compact_control *cc)
+unsigned long
+isolate_freepages_range(unsigned long start_pfn, unsigned long end_pfn)
 {
-	struct page *page;
-	unsigned long high_pfn, low_pfn, pfn;
-	unsigned long flags;
-	int nr_freepages = cc->nr_freepages;
-	struct list_head *freelist = &cc->freepages;
-
-	/*
-	 * Initialise the free scanner. The starting point is where we last
-	 * scanned from (or the end of the zone if starting). The low point
-	 * is the end of the pageblock the migration scanner is using.
-	 */
-	pfn = cc->free_pfn;
-	low_pfn = cc->migrate_pfn + pageblock_nr_pages;
+	unsigned long isolated, pfn, block_end_pfn, flags;
+	struct zone *zone = NULL;
+	LIST_HEAD(freelist);
 
-	/*
-	 * Take care that if the migration scanner is at the end of the zone
-	 * that the free scanner does not accidentally move to the next zone
-	 * in the next isolation cycle.
-	 */
-	high_pfn = min(low_pfn, pfn);
-
-	/*
-	 * Isolate free pages until enough are available to migrate the
-	 * pages on cc->migratepages. We stop searching if the migrate
-	 * and free page scanners meet or enough free pages are isolated.
-	 */
-	for (; pfn > low_pfn && cc->nr_migratepages > nr_freepages;
-					pfn -= pageblock_nr_pages) {
-		unsigned long isolated;
+	if (pfn_valid(start_pfn))
+		zone = page_zone(pfn_to_page(start_pfn));
 
-		if (!pfn_valid(pfn))
-			continue;
+	for (pfn = start_pfn; pfn < end_pfn; pfn += isolated) {
+		if (!pfn_valid(pfn) || zone != page_zone(pfn_to_page(pfn)))
+			break;
 
 		/*
-		 * Check for overlapping nodes/zones. It's possible on some
-		 * configurations to have a setup like
-		 * node0 node1 node0
-		 * i.e. it's possible that all pages within a zones range of
-		 * pages do not belong to a single zone.
+		 * On subsequent iterations ALIGN() is actually not needed,
+		 * but we keep it that we not to complicate the code.
 		 */
-		page = pfn_to_page(pfn);
-		if (page_zone(page) != zone)
-			continue;
+		block_end_pfn = ALIGN(pfn + 1, pageblock_nr_pages);
+		block_end_pfn = min(block_end_pfn, end_pfn);
 
-		/* Check the block is suitable for migration */
-		if (!suitable_migration_target(page))
-			continue;
+		spin_lock_irqsave(&zone->lock, flags);
+		isolated = isolate_freepages_block(pfn, block_end_pfn,
+						   &freelist, true);
+		spin_unlock_irqrestore(&zone->lock, flags);
 
 		/*
-		 * Found a block suitable for isolating free pages from. Now
-		 * we disabled interrupts, double check things are ok and
-		 * isolate the pages. This is to minimise the time IRQs
-		 * are disabled
+		 * In strict mode, isolate_freepages_block() returns 0 if
+		 * there are any holes in the block (ie. invalid PFNs or
+		 * non-free pages).
 		 */
-		isolated = 0;
-		spin_lock_irqsave(&zone->lock, flags);
-		if (suitable_migration_target(page)) {
-			isolated = isolate_freepages_block(zone, pfn, freelist);
-			nr_freepages += isolated;
-		}
-		spin_unlock_irqrestore(&zone->lock, flags);
+		if (!isolated)
+			break;
 
 		/*
-		 * Record the highest PFN we isolated pages from. When next
-		 * looking for free pages, the search will restart here as
-		 * page migration may have returned some pages to the allocator
+		 * If we managed to isolate pages, it is always (1 << n) *
+		 * pageblock_nr_pages for some non-negative n.  (Max order
+		 * page may span two pageblocks).
 		 */
-		if (isolated)
-			high_pfn = max(high_pfn, pfn);
 	}
 
 	/* split_free_page does not map the pages */
-	list_for_each_entry(page, freelist, lru) {
-		arch_alloc_page(page, 0);
-		kernel_map_pages(page, 1, 1);
+	map_pages(&freelist);
+
+	if (pfn < end_pfn) {
+		/* Loop terminated early, cleanup. */
+		release_freepages(&freelist);
+		return 0;
 	}
 
-	cc->free_pfn = high_pfn;
-	cc->nr_freepages = nr_freepages;
+	/* We don't use freelists for anything. */
+	return pfn;
 }
 
 /* Update the number of anon and file isolated pages in the zone */
@@ -243,38 +200,35 @@ static bool too_many_isolated(struct zone *zone)
 	return isolated > (inactive + active) / 2;
 }
 
-/* possible outcome of isolate_migratepages */
-typedef enum {
-	ISOLATE_ABORT,		/* Abort compaction now */
-	ISOLATE_NONE,		/* No pages isolated, continue scanning */
-	ISOLATE_SUCCESS,	/* Pages isolated, migrate */
-} isolate_migrate_t;
-
-/*
- * Isolate all pages that can be migrated from the block pointed to by
- * the migrate scanner within compact_control.
+/**
+ * isolate_migratepages_range() - isolate all migrate-able pages in range.
+ * @zone:	Zone pages are in.
+ * @cc:		Compaction control structure.
+ * @low_pfn:	The first PFN of the range.
+ * @end_pfn:	The one-past-the-last PFN of the range.
+ * @unevictable: true if it allows to isolate unevictable pages
+ *
+ * Isolate all pages that can be migrated from the range specified by
+ * [low_pfn, end_pfn).  Returns zero if there is a fatal signal
+ * pending), otherwise PFN of the first page that was not scanned
+ * (which may be both less, equal to or more then end_pfn).
+ *
+ * Assumes that cc->migratepages is empty and cc->nr_migratepages is
+ * zero.
+ *
+ * Apart from cc->migratepages and cc->nr_migratetypes this function
+ * does not modify any cc's fields, in particular it does not modify
+ * (or read for that matter) cc->migrate_pfn.
  */
-static isolate_migrate_t isolate_migratepages(struct zone *zone,
-					struct compact_control *cc)
+unsigned long
+isolate_migratepages_range(struct zone *zone, struct compact_control *cc,
+		unsigned long low_pfn, unsigned long end_pfn, bool unevictable)
 {
-	unsigned long low_pfn, end_pfn;
 	unsigned long last_pageblock_nr = 0, pageblock_nr;
 	unsigned long nr_scanned = 0, nr_isolated = 0;
 	struct list_head *migratelist = &cc->migratepages;
 	isolate_mode_t mode = ISOLATE_ACTIVE|ISOLATE_INACTIVE;
 
-	/* Do not scan outside zone boundaries */
-	low_pfn = max(cc->migrate_pfn, zone->zone_start_pfn);
-
-	/* Only scan within a pageblock boundary */
-	end_pfn = ALIGN(low_pfn + pageblock_nr_pages, pageblock_nr_pages);
-
-	/* Do not cross the free scanner or scan within a memory hole */
-	if (end_pfn > cc->free_pfn || !pfn_valid(low_pfn)) {
-		cc->migrate_pfn = end_pfn;
-		return ISOLATE_NONE;
-	}
-
 	/*
 	 * Ensure that there are not too many pages isolated from the LRU
 	 * list by either parallel reclaimers or compaction. If there are,
@@ -283,12 +237,12 @@ static isolate_migrate_t isolate_migratepages(struct zone *zone,
 	while (unlikely(too_many_isolated(zone))) {
 		/* async migration should just abort */
 		if (!cc->sync)
-			return ISOLATE_ABORT;
+			return 0;
 
 		congestion_wait(BLK_RW_ASYNC, HZ/10);
 
 		if (fatal_signal_pending(current))
-			return ISOLATE_ABORT;
+			return 0;
 	}
 
 	/* Time to isolate some pages for migration */
@@ -351,7 +305,7 @@ static isolate_migrate_t isolate_migratepages(struct zone *zone,
 		 */
 		pageblock_nr = low_pfn >> pageblock_order;
 		if (!cc->sync && last_pageblock_nr != pageblock_nr &&
-				get_pageblock_migratetype(page) != MIGRATE_MOVABLE) {
+		    !migrate_async_suitable(get_pageblock_migratetype(page))) {
 			low_pfn += pageblock_nr_pages;
 			low_pfn = ALIGN(low_pfn, pageblock_nr_pages) - 1;
 			last_pageblock_nr = pageblock_nr;
@@ -374,6 +328,9 @@ static isolate_migrate_t isolate_migratepages(struct zone *zone,
 		if (!cc->sync)
 			mode |= ISOLATE_ASYNC_MIGRATE;
 
+		if (unevictable)
+			mode |= ISOLATE_UNEVICTABLE;
+
 		/* Try isolate the page */
 		if (__isolate_lru_page(page, mode, 0) != 0)
 			continue;
@@ -396,11 +353,124 @@ static isolate_migrate_t isolate_migratepages(struct zone *zone,
 	acct_isolated(zone, cc);
 
 	spin_unlock_irq(&zone->lru_lock);
-	cc->migrate_pfn = low_pfn;
 
 	trace_mm_compaction_isolate_migratepages(nr_scanned, nr_isolated);
 
-	return ISOLATE_SUCCESS;
+	return low_pfn;
+}
+
+#endif /* CONFIG_COMPACTION || CONFIG_CMA */
+#ifdef CONFIG_COMPACTION
+
+/* Returns true if the page is within a block suitable for migration to */
+static bool suitable_migration_target(struct page *page)
+{
+
+	int migratetype = get_pageblock_migratetype(page);
+
+	/* Don't interfere with memory hot-remove or the min_free_kbytes blocks */
+	if (migratetype == MIGRATE_ISOLATE || migratetype == MIGRATE_RESERVE)
+		return false;
+
+	/* If the page is a large free page, then allow migration */
+	if (PageBuddy(page) && page_order(page) >= pageblock_order)
+		return true;
+
+	/* If the block is MIGRATE_MOVABLE or MIGRATE_CMA, allow migration */
+	if (migrate_async_suitable(migratetype))
+		return true;
+
+	/* Otherwise skip the block */
+	return false;
+}
+
+/*
+ * Based on information in the current compact_control, find blocks
+ * suitable for isolating free pages from and then isolate them.
+ */
+static void isolate_freepages(struct zone *zone,
+				struct compact_control *cc)
+{
+	struct page *page;
+	unsigned long high_pfn, low_pfn, pfn, zone_end_pfn, end_pfn;
+	unsigned long flags;
+	int nr_freepages = cc->nr_freepages;
+	struct list_head *freelist = &cc->freepages;
+
+	/*
+	 * Initialise the free scanner. The starting point is where we last
+	 * scanned from (or the end of the zone if starting). The low point
+	 * is the end of the pageblock the migration scanner is using.
+	 */
+	pfn = cc->free_pfn;
+	low_pfn = cc->migrate_pfn + pageblock_nr_pages;
+
+	/*
+	 * Take care that if the migration scanner is at the end of the zone
+	 * that the free scanner does not accidentally move to the next zone
+	 * in the next isolation cycle.
+	 */
+	high_pfn = min(low_pfn, pfn);
+
+	zone_end_pfn = zone->zone_start_pfn + zone->spanned_pages;
+
+	/*
+	 * Isolate free pages until enough are available to migrate the
+	 * pages on cc->migratepages. We stop searching if the migrate
+	 * and free page scanners meet or enough free pages are isolated.
+	 */
+	for (; pfn > low_pfn && cc->nr_migratepages > nr_freepages;
+					pfn -= pageblock_nr_pages) {
+		unsigned long isolated;
+
+		if (!pfn_valid(pfn))
+			continue;
+
+		/*
+		 * Check for overlapping nodes/zones. It's possible on some
+		 * configurations to have a setup like
+		 * node0 node1 node0
+		 * i.e. it's possible that all pages within a zones range of
+		 * pages do not belong to a single zone.
+		 */
+		page = pfn_to_page(pfn);
+		if (page_zone(page) != zone)
+			continue;
+
+		/* Check the block is suitable for migration */
+		if (!suitable_migration_target(page))
+			continue;
+
+		/*
+		 * Found a block suitable for isolating free pages from. Now
+		 * we disabled interrupts, double check things are ok and
+		 * isolate the pages. This is to minimise the time IRQs
+		 * are disabled
+		 */
+		isolated = 0;
+		spin_lock_irqsave(&zone->lock, flags);
+		if (suitable_migration_target(page)) {
+			end_pfn = min(pfn + pageblock_nr_pages, zone_end_pfn);
+			isolated = isolate_freepages_block(pfn, end_pfn,
+							   freelist, false);
+			nr_freepages += isolated;
+		}
+		spin_unlock_irqrestore(&zone->lock, flags);
+
+		/*
+		 * Record the highest PFN we isolated pages from. When next
+		 * looking for free pages, the search will restart here as
+		 * page migration may have returned some pages to the allocator
+		 */
+		if (isolated)
+			high_pfn = max(high_pfn, pfn);
+	}
+
+	/* split_free_page does not map the pages */
+	map_pages(freelist);
+
+	cc->free_pfn = high_pfn;
+	cc->nr_freepages = nr_freepages;
 }
 
 /*
@@ -449,6 +519,44 @@ static void update_nr_listpages(struct compact_control *cc)
 	cc->nr_freepages = nr_freepages;
 }
 
+/* possible outcome of isolate_migratepages */
+typedef enum {
+	ISOLATE_ABORT,		/* Abort compaction now */
+	ISOLATE_NONE,		/* No pages isolated, continue scanning */
+	ISOLATE_SUCCESS,	/* Pages isolated, migrate */
+} isolate_migrate_t;
+
+/*
+ * Isolate all pages that can be migrated from the block pointed to by
+ * the migrate scanner within compact_control.
+ */
+static isolate_migrate_t isolate_migratepages(struct zone *zone,
+					struct compact_control *cc)
+{
+	unsigned long low_pfn, end_pfn;
+
+	/* Do not scan outside zone boundaries */
+	low_pfn = max(cc->migrate_pfn, zone->zone_start_pfn);
+
+	/* Only scan within a pageblock boundary */
+	end_pfn = ALIGN(low_pfn + pageblock_nr_pages, pageblock_nr_pages);
+
+	/* Do not cross the free scanner or scan within a memory hole */
+	if (end_pfn > cc->free_pfn || !pfn_valid(low_pfn)) {
+		cc->migrate_pfn = end_pfn;
+		return ISOLATE_NONE;
+	}
+
+	/* Perform the isolation */
+	low_pfn = isolate_migratepages_range(zone, cc, low_pfn, end_pfn, false);
+	if (!low_pfn)
+		return ISOLATE_ABORT;
+
+	cc->migrate_pfn = low_pfn;
+
+	return ISOLATE_SUCCESS;
+}
+
 static int compact_finished(struct zone *zone,
 			    struct compact_control *cc)
 {
@@ -649,6 +757,7 @@ unsigned long try_to_compact_pages(struct zonelist *zonelist,
 	struct zoneref *z;
 	struct zone *zone;
 	int rc = COMPACT_SKIPPED;
+	int alloc_flags = 0;
 
 	/*
 	 * Check whether it is worth even starting compaction. The order check is
@@ -660,6 +769,10 @@ unsigned long try_to_compact_pages(struct zonelist *zonelist,
 
 	count_vm_event(COMPACTSTALL);
 
+#ifdef CONFIG_CMA
+	if (allocflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)
+		alloc_flags |= ALLOC_CMA;
+#endif
 	/* Compact each zone in the list */
 	for_each_zone_zonelist_nodemask(zone, z, zonelist, high_zoneidx,
 								nodemask) {
@@ -669,7 +782,8 @@ unsigned long try_to_compact_pages(struct zonelist *zonelist,
 		rc = max(status, rc);
 
 		/* If a normal allocation would succeed, stop compacting */
-		if (zone_watermark_ok(zone, order, low_wmark_pages(zone), 0, 0))
+		if (zone_watermark_ok(zone, order, low_wmark_pages(zone), 0,
+				      alloc_flags))
 			break;
 	}
 
@@ -798,3 +912,5 @@ void compaction_unregister_node(struct node *node)
 	return device_remove_file(&node->dev, &dev_attr_compact);
 }
 #endif /* CONFIG_SYSFS && CONFIG_NUMA */
+
+#endif /* CONFIG_COMPACTION */
diff --git a/mm/internal.h b/mm/internal.h
index 2189af49..3928a0cb 100644
--- a/mm/internal.h
+++ b/mm/internal.h
@@ -100,6 +100,39 @@ extern void prep_compound_page(struct page *page, unsigned long order);
 extern bool is_free_buddy_page(struct page *page);
 #endif
 
+#if defined CONFIG_COMPACTION || defined CONFIG_CMA
+
+/*
+ * in mm/compaction.c
+ */
+/*
+ * compact_control is used to track pages being migrated and the free pages
+ * they are being migrated to during memory compaction. The free_pfn starts
+ * at the end of a zone and migrate_pfn begins at the start. Movable pages
+ * are moved to the end of a zone during a compaction run and the run
+ * completes when free_pfn <= migrate_pfn
+ */
+struct compact_control {
+	struct list_head freepages;	/* List of free pages to migrate to */
+	struct list_head migratepages;	/* List of pages being migrated */
+	unsigned long nr_freepages;	/* Number of isolated free pages */
+	unsigned long nr_migratepages;	/* Number of pages to migrate */
+	unsigned long free_pfn;		/* isolate_freepages search base */
+	unsigned long migrate_pfn;	/* isolate_migratepages search base */
+	bool sync;			/* Synchronous migration */
+
+	int order;			/* order a direct compactor needs */
+	int migratetype;		/* MOVABLE, RECLAIMABLE etc */
+	struct zone *zone;
+};
+
+unsigned long
+isolate_freepages_range(unsigned long start_pfn, unsigned long end_pfn);
+unsigned long
+isolate_migratepages_range(struct zone *zone, struct compact_control *cc,
+	unsigned long low_pfn, unsigned long end_pfn, bool unevictable);
+
+#endif
 
 /*
  * function for dealing with page's order in buddy system.
@@ -309,3 +342,20 @@ extern u64 hwpoison_filter_flags_mask;
 extern u64 hwpoison_filter_flags_value;
 extern u64 hwpoison_filter_memcg;
 extern u32 hwpoison_filter_enable;
+
+/* The ALLOC_WMARK bits are used as an index to zone->watermark */
+#define ALLOC_WMARK_MIN		WMARK_MIN
+#define ALLOC_WMARK_LOW		WMARK_LOW
+#define ALLOC_WMARK_HIGH	WMARK_HIGH
+#define ALLOC_NO_WATERMARKS	0x04 /* don't check watermarks at all */
+
+/* Mask to get the watermark bits */
+#define ALLOC_WMARK_MASK	(ALLOC_NO_WATERMARKS-1)
+
+#define ALLOC_HARDER		0x10 /* try to alloc harder */
+#define ALLOC_HIGH		0x20 /* __GFP_HIGH set */
+#define ALLOC_CPUSET		0x40 /* check for correct cpuset */
+#define ALLOC_CMA		0x80 /* allow allocations from CMA areas */
+
+unsigned long reclaim_clean_pages_from_list(struct zone *zone,
+					    struct list_head *page_list);
diff --git a/mm/memory.c b/mm/memory.c
index 6105f475..c16f0da5 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2324,6 +2324,53 @@ int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,
 }
 EXPORT_SYMBOL(remap_pfn_range);
 
+/**
+ * vm_iomap_memory - remap memory to userspace
+ * @vma: user vma to map to
+ * @start: start of area
+ * @len: size of area
+ *
+ * This is a simplified io_remap_pfn_range() for common driver use. The
+ * driver just needs to give us the physical memory range to be mapped,
+ * we'll figure out the rest from the vma information.
+ *
+ * NOTE! Some drivers might want to tweak vma->vm_page_prot first to get
+ * whatever write-combining details or similar.
+ */
+int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)
+{
+	unsigned long vm_len, pfn, pages;
+
+	/* Check that the physical memory area passed in looks valid */
+	if (start + len < start)
+		return -EINVAL;
+	/*
+	 * You *really* shouldn't map things that aren't page-aligned,
+	 * but we've historically allowed it because IO memory might
+	 * just have smaller alignment.
+	 */
+	len += start & ~PAGE_MASK;
+	pfn = start >> PAGE_SHIFT;
+	pages = (len + ~PAGE_MASK) >> PAGE_SHIFT;
+	if (pfn + pages < pfn)
+		return -EINVAL;
+
+	/* We start the mapping 'vm_pgoff' pages into the area */
+	if (vma->vm_pgoff > pages)
+		return -EINVAL;
+	pfn += vma->vm_pgoff;
+	pages -= vma->vm_pgoff;
+
+	/* Can we fit all of the mapping? */
+	vm_len = vma->vm_end - vma->vm_start;
+	if (vm_len >> PAGE_SHIFT > pages)
+		return -EINVAL;
+
+	/* Ok, let it rip */
+	return io_remap_pfn_range(vma, vma->vm_start, pfn, vm_len, vma->vm_page_prot);
+}
+EXPORT_SYMBOL(vm_iomap_memory);
+
 static int apply_to_pte_range(struct mm_struct *mm, pmd_t *pmd,
 				     unsigned long addr, unsigned long end,
 				     pte_fn_t fn, void *data)
@@ -3124,7 +3171,8 @@ static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,
 	/* Allocate our own private page. */
 	if (unlikely(anon_vma_prepare(vma)))
 		goto oom;
-	page = alloc_zeroed_user_highpage_movable(vma, address);
+	page = __alloc_zeroed_user_highpage(__GFP_MOVABLE | __GFP_CMA,
+			vma, address);
 	if (!page)
 		goto oom;
 	__SetPageUptodate(page);
diff --git a/mm/migrate.c b/mm/migrate.c
index 11072383..4f65468f 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -39,6 +39,8 @@
 
 #include "internal.h"
 
+unsigned long migrate_page_copy_count;
+
 /*
  * migrate_prep() needs to be called before we start compiling a list of pages
  * to be migrated using isolate_lru_page(). If scheduling work on other CPUs is
@@ -145,7 +147,7 @@ static int remove_migration_pte(struct page *new, struct vm_area_struct *vma,
 	if (PageHuge(new))
 		pte = pte_mkhuge(pte);
 #endif
-	flush_cache_page(vma, addr, pte_pfn(pte));
+	flush_dcache_page(new);
 	set_pte_at(mm, addr, ptep, pte);
 
 	if (PageHuge(new)) {
@@ -446,6 +448,8 @@ void migrate_page_copy(struct page *newpage, struct page *page)
 	ClearPagePrivate(page);
 	set_page_private(page, 0);
 
+	atomic_inc((atomic_t *)&migrate_page_copy_count);
+
 	/*
 	 * If any waiters have accumulated on the new page then
 	 * wake them up.
@@ -753,7 +757,7 @@ static int __unmap_and_move(struct page *page, struct page *newpage,
 	 */
 	if (PageAnon(page)) {
 		/*
-		 * Only page_lock_anon_vma() understands the subtleties of
+		 * Only page_lock_anon_vma_read() understands the subtleties of
 		 * getting a hold on an anon_vma from outside one of its mms.
 		 */
 		anon_vma = page_get_anon_vma(page);
diff --git a/mm/mmap.c b/mm/mmap.c
index 848ef52d..f8ce151b 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -570,7 +570,7 @@ again:			remove_next = 1 + (end > next->vm_end);
 	 */
 	if (vma->anon_vma && (importer || start != vma->vm_start)) {
 		anon_vma = vma->anon_vma;
-		anon_vma_lock(anon_vma);
+		anon_vma_lock_write(anon_vma);
 	}
 
 	if (root) {
@@ -613,7 +613,7 @@ again:			remove_next = 1 + (end > next->vm_end);
 	}
 
 	if (anon_vma)
-		anon_vma_unlock(anon_vma);
+		anon_vma_unlock_write(anon_vma);
 	if (mapping)
 		mutex_unlock(&mapping->i_mmap_mutex);
 
@@ -2361,7 +2361,8 @@ int insert_vm_struct(struct mm_struct * mm, struct vm_area_struct * vma)
  * prior to moving page table entries, to effect an mremap move.
  */
 struct vm_area_struct *copy_vma(struct vm_area_struct **vmap,
-	unsigned long addr, unsigned long len, pgoff_t pgoff)
+	unsigned long addr, unsigned long len, pgoff_t pgoff,
+	bool *need_rmap_locks)
 {
 	struct vm_area_struct *vma = *vmap;
 	unsigned long vma_start = vma->vm_start;
@@ -2402,23 +2403,23 @@ struct vm_area_struct *copy_vma(struct vm_area_struct **vmap,
 			 * linear if there are no pages mapped yet.
 			 */
 			VM_BUG_ON(faulted_in_anon_vma);
-			*vmap = new_vma;
-		} else
-			anon_vma_moveto_tail(new_vma);
+			*vmap = vma = new_vma;
+		}
+		*need_rmap_locks = (new_vma->vm_pgoff <= vma->vm_pgoff);
 	} else {
 		new_vma = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
 		if (new_vma) {
 			*new_vma = *vma;
+			new_vma->vm_start = addr;
+			new_vma->vm_end = addr + len;
+			new_vma->vm_pgoff = pgoff;
 			pol = mpol_dup(vma_policy(vma));
 			if (IS_ERR(pol))
 				goto out_free_vma;
+			vma_set_policy(new_vma, pol);
 			INIT_LIST_HEAD(&new_vma->anon_vma_chain);
 			if (anon_vma_clone(new_vma, vma))
 				goto out_free_mempol;
-			vma_set_policy(new_vma, pol);
-			new_vma->vm_start = addr;
-			new_vma->vm_end = addr + len;
-			new_vma->vm_pgoff = pgoff;
 			if (new_vma->vm_file) {
 				get_file(new_vma->vm_file);
 				if (vma->vm_flags & VM_EXECUTABLE)
@@ -2427,6 +2428,7 @@ struct vm_area_struct *copy_vma(struct vm_area_struct **vmap,
 			if (new_vma->vm_ops && new_vma->vm_ops->open)
 				new_vma->vm_ops->open(new_vma);
 			vma_link(mm, new_vma, prev, rb_link, rb_parent);
+			*need_rmap_locks = false;
 		}
 	}
 	return new_vma;
@@ -2553,15 +2555,15 @@ static void vm_lock_anon_vma(struct mm_struct *mm, struct anon_vma *anon_vma)
 		 * The LSB of head.next can't change from under us
 		 * because we hold the mm_all_locks_mutex.
 		 */
-		mutex_lock_nest_lock(&anon_vma->root->mutex, &mm->mmap_sem);
+		down_write_nest_lock(&anon_vma->root->rwsem, &mm->mmap_sem);
 		/*
 		 * We can safely modify head.next after taking the
-		 * anon_vma->root->mutex. If some other vma in this mm shares
+		 * anon_vma->root->rwsem. If some other vma in this mm shares
 		 * the same anon_vma we won't take it again.
 		 *
 		 * No need of atomic instructions here, head.next
 		 * can't change from under us thanks to the
-		 * anon_vma->root->mutex.
+		 * anon_vma->root->rwsem.
 		 */
 		if (__test_and_set_bit(0, (unsigned long *)
 				       &anon_vma->root->head.next))
@@ -2610,7 +2612,7 @@ static void vm_lock_mapping(struct mm_struct *mm, struct address_space *mapping)
  * vma in this mm is backed by the same anon_vma or address_space.
  *
  * We can take all the locks in random order because the VM code
- * taking i_mmap_mutex or anon_vma->mutex outside the mmap_sem never
+ * taking i_mmap_mutex or anon_vma->rwsem outside the mmap_sem never
  * takes more than one of them in a row. Secondly we're protected
  * against a concurrent mm_take_all_locks() by the mm_all_locks_mutex.
  *
@@ -2663,12 +2665,12 @@ static void vm_unlock_anon_vma(struct anon_vma *anon_vma)
 		 *
 		 * No need of atomic instructions here, head.next
 		 * can't change from under us until we release the
-		 * anon_vma->root->mutex.
+		 * anon_vma->root->rwsem.
 		 */
 		if (!__test_and_clear_bit(0, (unsigned long *)
 					  &anon_vma->root->head.next))
 			BUG();
-		anon_vma_unlock(anon_vma);
+		anon_vma_unlock_write(anon_vma);
 	}
 }
 
diff --git a/mm/mremap.c b/mm/mremap.c
index db8d983b..91a045a6 100644
--- a/mm/mremap.c
+++ b/mm/mremap.c
@@ -71,22 +71,41 @@ static pmd_t *alloc_new_pmd(struct mm_struct *mm, struct vm_area_struct *vma,
 static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,
 		unsigned long old_addr, unsigned long old_end,
 		struct vm_area_struct *new_vma, pmd_t *new_pmd,
-		unsigned long new_addr)
+		unsigned long new_addr, bool need_rmap_locks)
 {
 	struct address_space *mapping = NULL;
+	struct anon_vma *anon_vma = NULL;
 	struct mm_struct *mm = vma->vm_mm;
 	pte_t *old_pte, *new_pte, pte;
 	spinlock_t *old_ptl, *new_ptl;
 
-	if (vma->vm_file) {
-		/*
-		 * Subtle point from Rajesh Venkatasubramanian: before
-		 * moving file-based ptes, we must lock truncate_pagecache
-		 * out, since it might clean the dst vma before the src vma,
-		 * and we propagate stale pages into the dst afterward.
-		 */
-		mapping = vma->vm_file->f_mapping;
-		mutex_lock(&mapping->i_mmap_mutex);
+	/*
+	 * When need_rmap_locks is true, we take the i_mmap_mutex and anon_vma
+	 * locks to ensure that rmap will always observe either the old or the
+	 * new ptes. This is the easiest way to avoid races with
+	 * truncate_pagecache(), page migration, etc...
+	 *
+	 * When need_rmap_locks is false, we use other ways to avoid
+	 * such races:
+	 *
+	 * - During exec() shift_arg_pages(), we use a specially tagged vma
+	 *   which rmap call sites look for using is_vma_temporary_stack().
+	 *
+	 * - During mremap(), new_vma is often known to be placed after vma
+	 *   in rmap traversal order. This ensures rmap will always observe
+	 *   either the old pte, or the new pte, or both (the page table locks
+	 *   serialize access to individual ptes, but only rmap traversal
+	 *   order guarantees that we won't miss both the old and new ptes).
+	 */
+	if (need_rmap_locks) {
+		if (vma->vm_file) {
+			mapping = vma->vm_file->f_mapping;
+			mutex_lock(&mapping->i_mmap_mutex);
+		}
+		if (vma->anon_vma) {
+			anon_vma = vma->anon_vma;
+			anon_vma_lock_write(anon_vma);
+		}
 	}
 
 	/*
@@ -114,6 +133,8 @@ static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,
 		spin_unlock(new_ptl);
 	pte_unmap(new_pte - 1);
 	pte_unmap_unlock(old_pte - 1, old_ptl);
+	if (anon_vma)
+		anon_vma_unlock_write(anon_vma);
 	if (mapping)
 		mutex_unlock(&mapping->i_mmap_mutex);
 }
@@ -122,7 +143,8 @@ static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,
 
 unsigned long move_page_tables(struct vm_area_struct *vma,
 		unsigned long old_addr, struct vm_area_struct *new_vma,
-		unsigned long new_addr, unsigned long len)
+		unsigned long new_addr, unsigned long len,
+		bool need_rmap_locks)
 {
 	unsigned long extent, next, old_end;
 	pmd_t *old_pmd, *new_pmd;
@@ -169,7 +191,7 @@ unsigned long move_page_tables(struct vm_area_struct *vma,
 		if (extent > LATENCY_LIMIT)
 			extent = LATENCY_LIMIT;
 		move_ptes(vma, old_pmd, old_addr, old_addr + extent,
-				new_vma, new_pmd, new_addr);
+			  new_vma, new_pmd, new_addr, need_rmap_locks);
 		need_flush = true;
 	}
 	if (likely(need_flush))
@@ -193,6 +215,7 @@ static unsigned long move_vma(struct vm_area_struct *vma,
 	unsigned long hiwater_vm;
 	int split = 0;
 	int err;
+	bool need_rmap_locks;
 
 	/*
 	 * We'd prefer to avoid failure later on in do_munmap:
@@ -214,27 +237,21 @@ static unsigned long move_vma(struct vm_area_struct *vma,
 		return err;
 
 	new_pgoff = vma->vm_pgoff + ((old_addr - vma->vm_start) >> PAGE_SHIFT);
-	new_vma = copy_vma(&vma, new_addr, new_len, new_pgoff);
+	new_vma = copy_vma(&vma, new_addr, new_len, new_pgoff,
+			   &need_rmap_locks);
 	if (!new_vma)
 		return -ENOMEM;
 
-	moved_len = move_page_tables(vma, old_addr, new_vma, new_addr, old_len);
+	moved_len = move_page_tables(vma, old_addr, new_vma, new_addr, old_len,
+				     need_rmap_locks);
 	if (moved_len < old_len) {
-		/*
-		 * Before moving the page tables from the new vma to
-		 * the old vma, we need to be sure the old vma is
-		 * queued after new vma in the same_anon_vma list to
-		 * prevent SMP races with rmap_walk (that could lead
-		 * rmap_walk to miss some page table).
-		 */
-		anon_vma_moveto_tail(vma);
-
 		/*
 		 * On error, move entries back from new area to old,
 		 * which will succeed since page tables still there,
 		 * and then proceed to unmap new area instead of old.
 		 */
-		move_page_tables(new_vma, new_addr, vma, old_addr, moved_len);
+		move_page_tables(new_vma, new_addr, vma, old_addr, moved_len,
+				 true);
 		vma = new_vma;
 		old_len = new_len;
 		old_addr = new_addr;
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 918330f7..fe82ca30 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -57,12 +57,17 @@
 #include <linux/ftrace_event.h>
 #include <linux/memcontrol.h>
 #include <linux/prefetch.h>
+#include <linux/migrate.h>
 #include <linux/page-debug-flags.h>
 
 #include <asm/tlbflush.h>
 #include <asm/div64.h>
 #include "internal.h"
 
+#ifdef CONFIG_CMA
+#include <asm/dma-contiguous.h>
+#endif
+
 #ifdef CONFIG_USE_PERCPU_NUMA_NODE_ID
 DEFINE_PER_CPU(int, numa_node);
 EXPORT_PER_CPU_SYMBOL(numa_node);
@@ -192,6 +197,7 @@ static char * const zone_names[MAX_NR_ZONES] = {
 };
 
 int min_free_kbytes = 1024;
+int min_free_order_shift = 1;
 
 static unsigned long __meminitdata nr_kernel_pages;
 static unsigned long __meminitdata nr_all_pages;
@@ -497,6 +503,23 @@ static inline int page_is_buddy(struct page *page, struct page *buddy,
 	return 0;
 }
 
+
+#ifdef CONFIG_CMA
+void list_add_cma(struct list_head *new, struct list_head *head)
+{
+	struct list_head *pos = head;
+	struct list_head *curr;
+
+	list_for_each(curr, head) {
+		if ((unsigned long)new > (unsigned long)curr)
+			break;
+		pos = curr;
+	}
+
+	list_add(new, pos);
+}
+#endif
+
 /*
  * Freeing function for a buddy system allocator.
  *
@@ -513,10 +536,10 @@ static inline int page_is_buddy(struct page *page, struct page *buddy,
  * free pages of length of (1 << order) and marked with _mapcount -2. Page's
  * order is recorded in page_private(page) field.
  * So when we are allocating or freeing one, we can derive the state of the
- * other.  That is, if we allocate a small block, and both were   
- * free, the remainder of the region must be split into blocks.   
+ * other.  That is, if we allocate a small block, and both were
+ * free, the remainder of the region must be split into blocks.
  * If a block is freed, and its buddy is also free, then this
- * triggers coalescing into a block of larger size.            
+ * triggers coalescing into a block of larger size.
  *
  * -- wli
  */
@@ -553,7 +576,8 @@ static inline void __free_one_page(struct page *page,
 		if (page_is_guard(buddy)) {
 			clear_page_guard_flag(buddy);
 			set_page_private(page, 0);
-			__mod_zone_page_state(zone, NR_FREE_PAGES, 1 << order);
+			__mod_zone_freepage_state(zone, 1 << order,
+						  migratetype);
 		} else {
 			list_del(&buddy->lru);
 			zone->free_area[order].nr_free--;
@@ -566,6 +590,14 @@ static inline void __free_one_page(struct page *page,
 	}
 	set_page_order(page, order);
 
+	#ifdef CONFIG_CMA
+	if (is_migrate_cma(migratetype)) {
+		list_add_cma(&page->lru,
+			&zone->free_area[order].free_list[migratetype]);
+		goto out;
+	}
+	#endif
+
 	/*
 	 * If this is not the largest possible page, check if the buddy
 	 * of the next-highest order is free. If it is, it's possible
@@ -579,7 +611,7 @@ static inline void __free_one_page(struct page *page,
 		combined_idx = buddy_idx & page_idx;
 		higher_page = page + (combined_idx - page_idx);
 		buddy_idx = __find_buddy_index(combined_idx, order + 1);
-		higher_buddy = page + (buddy_idx - combined_idx);
+		higher_buddy = higher_page + (buddy_idx - combined_idx);
 		if (page_is_buddy(higher_page, higher_buddy, order + 1)) {
 			list_add_tail(&page->lru,
 				&zone->free_area[order].free_list[migratetype]);
@@ -637,7 +669,6 @@ static void free_pcppages_bulk(struct zone *zone, int count,
 	int to_free = count;
 
 	spin_lock(&zone->lock);
-	zone->all_unreclaimable = 0;
 	zone->pages_scanned = 0;
 
 	while (to_free) {
@@ -663,12 +694,18 @@ static void free_pcppages_bulk(struct zone *zone, int count,
 			batch_free = to_free;
 
 		do {
+			int mt;	/* migratetype of the to-be-freed page */
+
 			page = list_entry(list->prev, struct page, lru);
 			/* must delete as __free_one_page list manipulates */
 			list_del(&page->lru);
+			mt = get_freepage_migratetype(page);
 			/* MIGRATE_MOVABLE list may include MIGRATE_RESERVEs */
-			__free_one_page(page, zone, 0, page_private(page));
-			trace_mm_page_pcpu_drain(page, 0, page_private(page));
+			__free_one_page(page, zone, 0, mt);
+			trace_mm_page_pcpu_drain(page, 0, mt);
+			if (is_migrate_cma(mt))
+				__mod_zone_page_state(zone,
+					NR_FREE_CMA_PAGES, 1);
 		} while (--to_free && --batch_free && !list_empty(list));
 	}
 	__mod_zone_page_state(zone, NR_FREE_PAGES, count);
@@ -679,11 +716,11 @@ static void free_one_page(struct zone *zone, struct page *page, int order,
 				int migratetype)
 {
 	spin_lock(&zone->lock);
-	zone->all_unreclaimable = 0;
 	zone->pages_scanned = 0;
 
 	__free_one_page(page, zone, order, migratetype);
-	__mod_zone_page_state(zone, NR_FREE_PAGES, 1 << order);
+	if (unlikely(migratetype != MIGRATE_ISOLATE))
+		__mod_zone_freepage_state(zone, 1 << order, migratetype);
 	spin_unlock(&zone->lock);
 }
 
@@ -717,6 +754,7 @@ static void __free_pages_ok(struct page *page, unsigned int order)
 {
 	unsigned long flags;
 	int wasMlocked = __TestClearPageMlocked(page);
+	int migratetype;
 
 	if (!free_pages_prepare(page, order))
 		return;
@@ -725,8 +763,9 @@ static void __free_pages_ok(struct page *page, unsigned int order)
 	if (unlikely(wasMlocked))
 		free_page_mlock(page);
 	__count_vm_events(PGFREE, 1 << order);
-	free_one_page(page_zone(page), page, order,
-					get_pageblock_migratetype(page));
+	migratetype = get_pageblock_migratetype(page);
+	set_freepage_migratetype(page, migratetype);
+	free_one_page(page_zone(page), page, order, migratetype);
 	local_irq_restore(flags);
 }
 
@@ -749,6 +788,24 @@ void __meminit __free_pages_bootmem(struct page *page, unsigned int order)
 	__free_pages(page, order);
 }
 
+#ifdef CONFIG_CMA
+/* Free whole pageblock and set it's migration type to MIGRATE_CMA. */
+void __init init_cma_reserved_pageblock(struct page *page)
+{
+	unsigned i = pageblock_nr_pages;
+	struct page *p = page;
+
+	do {
+		__ClearPageReserved(p);
+		set_page_count(p, 0);
+	} while (++p, --i);
+
+	set_page_refcounted(page);
+	set_pageblock_migratetype(page, MIGRATE_CMA);
+	__free_pages(page, pageblock_order);
+	totalram_pages += pageblock_nr_pages;
+}
+#endif
 
 /*
  * The order of subdivision here is critical for the IO subsystem.
@@ -788,11 +845,19 @@ static inline void expand(struct zone *zone, struct page *page,
 			set_page_guard_flag(&page[size]);
 			set_page_private(&page[size], high);
 			/* Guard pages are not available for any usage */
-			__mod_zone_page_state(zone, NR_FREE_PAGES, -(1 << high));
+			__mod_zone_freepage_state(zone, -(1 << high),
+						  migratetype);
 			continue;
 		}
 #endif
-		list_add(&page[size].lru, &area->free_list[migratetype]);
+		#ifdef CONFIG_CMA
+		if (is_migrate_cma(migratetype))
+			list_add_cma(&page[size].lru,
+				&area->free_list[migratetype]);
+		else
+		#endif
+			list_add(&page[size].lru,
+				&area->free_list[migratetype]);
 		area->nr_free++;
 		set_page_order(&page[size], high);
 	}
@@ -869,16 +934,73 @@ struct page *__rmqueue_smallest(struct zone *zone, unsigned int order,
 	return NULL;
 }
 
+#ifdef CONFIG_CMA
+static inline
+struct page *__rmqueue_highest_cma(struct zone *zone, unsigned int order)
+{
+	unsigned int cur_order, sel_order;
+	struct free_area *area, *sel_area;
+	struct page *page, *sel_page = NULL;
+
+	/* Select the available block with the highest address */
+	for (cur_order = order; cur_order < MAX_ORDER; ++cur_order) {
+		area = &(zone->free_area[cur_order]);
+		if (list_empty(&area->free_list[MIGRATE_CMA]))
+			continue;
+
+		page = list_entry(area->free_list[MIGRATE_CMA].next,
+							struct page, lru);
+
+		if (!sel_page || (page > sel_page)) {
+			sel_page = page;
+			sel_area = area;
+			sel_order = cur_order;
+		}
+	}
+
+	if (sel_page) {
+		unsigned long size = 1 << sel_order;
+		unsigned long offset = 0;
+
+		list_del(&sel_page->lru);
+		rmv_page_order(sel_page);
+		sel_area->nr_free--;
+
+		while (sel_order > order) {
+			sel_area--;
+			sel_order--;
+
+			list_add_cma(&sel_page[offset].lru,
+				&sel_area->free_list[MIGRATE_CMA]);
+			sel_area->nr_free++;
+			set_page_order(&sel_page[offset], sel_order);
+
+			size >>= 1;
+			offset += size;
+		}
+
+		sel_page = &sel_page[offset];
+	}
+
+	return sel_page;
+}
+#endif
 
 /*
  * This array describes the order lists are fallen back to when
  * the free lists for the desirable migrate type are depleted
  */
-static int fallbacks[MIGRATE_TYPES][MIGRATE_TYPES-1] = {
-	[MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_RESERVE },
-	[MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_RESERVE },
+static int fallbacks[MIGRATE_TYPES][4] = {
+	[MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,     MIGRATE_RESERVE },
+	[MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,     MIGRATE_RESERVE },
+#ifdef CONFIG_CMA
 	[MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_RESERVE },
-	[MIGRATE_RESERVE]     = { MIGRATE_RESERVE,     MIGRATE_RESERVE,   MIGRATE_RESERVE }, /* Never used */
+	[MIGRATE_CMA]         = { MIGRATE_RESERVE }, /* Never used */
+#else
+	[MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE,   MIGRATE_RESERVE },
+#endif
+	[MIGRATE_RESERVE]     = { MIGRATE_RESERVE }, /* Never used */
+	[MIGRATE_ISOLATE]     = { MIGRATE_RESERVE }, /* Never used */
 };
 
 /*
@@ -886,7 +1008,7 @@ static int fallbacks[MIGRATE_TYPES][MIGRATE_TYPES-1] = {
  * Note that start_page and end_pages are not aligned on a pageblock
  * boundary. If alignment is required, use move_freepages_block()
  */
-static int move_freepages(struct zone *zone,
+int move_freepages(struct zone *zone,
 			  struct page *start_page, struct page *end_page,
 			  int migratetype)
 {
@@ -920,8 +1042,17 @@ static int move_freepages(struct zone *zone,
 		}
 
 		order = page_order(page);
+#ifdef CONFIG_CMA
+		if (is_migrate_cma(migratetype)) {
+			struct free_area *area = &zone->free_area[order];
+			__list_del_entry(&page->lru);
+			list_add_cma(&page->lru,
+				&area->free_list[migratetype]);
+		} else
+#endif
 		list_move(&page->lru,
 			  &zone->free_area[order].free_list[migratetype]);
+		set_freepage_migratetype(page, migratetype);
 		page += 1 << order;
 		pages_moved += 1 << order;
 	}
@@ -961,6 +1092,26 @@ static void change_pageblock_range(struct page *pageblock_page,
 	}
 }
 
+#ifdef CONFIG_CMA
+int cma_balance_ratio = 50;
+static struct page *__rmqueue_cma_balance(struct zone *zone,
+	unsigned int order, int migratetype)
+{
+	unsigned long nr_free_pages, nr_free_cma_pages;
+
+	if (migratetype != MIGRATE_MOVABLE)
+		return NULL;
+
+	nr_free_pages = global_page_state(NR_FREE_PAGES);
+	nr_free_cma_pages = global_page_state(NR_FREE_CMA_PAGES);
+
+	if ((nr_free_pages * cma_balance_ratio) > (nr_free_cma_pages * 100))
+		return NULL;
+
+	return __rmqueue_highest_cma(zone, order);
+}
+#endif
+
 /* Remove an element from the buddy allocator from the fallback list */
 static inline struct page *
 __rmqueue_fallback(struct zone *zone, int order, int start_migratetype)
@@ -970,15 +1121,23 @@ __rmqueue_fallback(struct zone *zone, int order, int start_migratetype)
 	struct page *page;
 	int migratetype, i;
 
+#ifdef CONFIG_CMA
+	if (cma_available && (!cma_balance_ratio) &&
+			(start_migratetype == MIGRATE_MOVABLE)) {
+		page = __rmqueue_highest_cma(zone, order);
+		if (page)
+			return page;
+	}
+#endif
 	/* Find the largest possible block of pages in the other list */
 	for (current_order = MAX_ORDER-1; current_order >= order;
 						--current_order) {
-		for (i = 0; i < MIGRATE_TYPES - 1; i++) {
+		for (i = 0;; i++) {
 			migratetype = fallbacks[start_migratetype][i];
 
 			/* MIGRATE_RESERVE handled later if necessary */
 			if (migratetype == MIGRATE_RESERVE)
-				continue;
+				break;
 
 			area = &(zone->free_area[current_order]);
 			if (list_empty(&area->free_list[migratetype]))
@@ -993,11 +1152,18 @@ __rmqueue_fallback(struct zone *zone, int order, int start_migratetype)
 			 * pages to the preferred allocation list. If falling
 			 * back for a reclaimable kernel allocation, be more
 			 * aggressive about taking ownership of free pages
+			 *
+			 * On the other hand, never change migration
+			 * type of MIGRATE_CMA pageblocks nor move CMA
+			 * pages on different free lists. We don't
+			 * want unmovable pages to be allocated from
+			 * MIGRATE_CMA areas.
 			 */
-			if (unlikely(current_order >= (pageblock_order >> 1)) ||
-					start_migratetype == MIGRATE_RECLAIMABLE ||
-					page_group_by_mobility_disabled) {
-				unsigned long pages;
+			if (!is_migrate_cma(migratetype) &&
+			    (unlikely(current_order >= pageblock_order / 2) ||
+			     start_migratetype == MIGRATE_RECLAIMABLE ||
+			     page_group_by_mobility_disabled)) {
+				int pages;
 				pages = move_freepages_block(zone, page,
 								start_migratetype);
 
@@ -1015,11 +1181,14 @@ __rmqueue_fallback(struct zone *zone, int order, int start_migratetype)
 			rmv_page_order(page);
 
 			/* Take ownership for orders >= pageblock_order */
-			if (current_order >= pageblock_order)
+			if (current_order >= pageblock_order &&
+			    !is_migrate_cma(migratetype))
 				change_pageblock_range(page, current_order,
 							start_migratetype);
 
-			expand(zone, page, order, current_order, area, migratetype);
+			expand(zone, page, order, current_order, area,
+			       is_migrate_cma(migratetype)
+			     ? migratetype : start_migratetype);
 
 			trace_mm_page_alloc_extfrag(page, order, current_order,
 				start_migratetype, migratetype);
@@ -1038,10 +1207,15 @@ __rmqueue_fallback(struct zone *zone, int order, int start_migratetype)
 static struct page *__rmqueue(struct zone *zone, unsigned int order,
 						int migratetype)
 {
-	struct page *page;
+	struct page *page = NULL;
 
 retry_reserve:
-	page = __rmqueue_smallest(zone, order, migratetype);
+#ifdef CONFIG_CMA
+	if (cma_available && cma_balance_ratio)
+		page = __rmqueue_cma_balance(zone, order, migratetype);
+	if (!page)
+#endif
+		page = __rmqueue_smallest(zone, order, migratetype);
 
 	if (unlikely(!page) && migratetype != MIGRATE_RESERVE) {
 		page = __rmqueue_fallback(zone, order, migratetype);
@@ -1061,17 +1235,17 @@ retry_reserve:
 	return page;
 }
 
-/* 
+/*
  * Obtain a specified number of elements from the buddy allocator, all under
  * a single hold of the lock, for efficiency.  Add them to the supplied list.
  * Returns the number of new pages which were placed at *list.
  */
-static int rmqueue_bulk(struct zone *zone, unsigned int order, 
+static int rmqueue_bulk(struct zone *zone, unsigned int order,
 			unsigned long count, struct list_head *list,
 			int migratetype, int cold)
 {
-	int i;
-	
+	int mt = migratetype, i;
+
 	spin_lock(&zone->lock);
 	for (i = 0; i < count; ++i) {
 		struct page *page = __rmqueue(zone, order, migratetype);
@@ -1091,8 +1265,16 @@ static int rmqueue_bulk(struct zone *zone, unsigned int order,
 			list_add(&page->lru, list);
 		else
 			list_add_tail(&page->lru, list);
-		set_page_private(page, migratetype);
+		if (IS_ENABLED(CONFIG_CMA)) {
+			mt = get_pageblock_migratetype(page);
+			if (!is_migrate_cma(mt) && mt != MIGRATE_ISOLATE)
+				mt = migratetype;
+		}
+		set_freepage_migratetype(page, mt);
 		list = &page->lru;
+		if (is_migrate_cma(mt))
+			__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,
+					      -(1 << order));
 	}
 	__mod_zone_page_state(zone, NR_FREE_PAGES, -(i << order));
 	spin_unlock(&zone->lock);
@@ -1256,7 +1438,7 @@ void free_hot_cold_page(struct page *page, int cold)
 		return;
 
 	migratetype = get_pageblock_migratetype(page);
-	set_page_private(page, migratetype);
+	set_freepage_migratetype(page, migratetype);
 	local_irq_save(flags);
 	if (unlikely(wasMlocked))
 		free_page_mlock(page);
@@ -1270,7 +1452,8 @@ void free_hot_cold_page(struct page *page, int cold)
 	 * excessively into the page allocator
 	 */
 	if (migratetype >= MIGRATE_PCPTYPES) {
-		if (unlikely(migratetype == MIGRATE_ISOLATE)) {
+		if (unlikely(migratetype == MIGRATE_ISOLATE)
+		   || is_migrate_cma(migratetype)) {
 			free_one_page(zone, page, 0, migratetype);
 			goto out;
 		}
@@ -1348,22 +1531,27 @@ int split_free_page(struct page *page)
 	unsigned int order;
 	unsigned long watermark;
 	struct zone *zone;
+	int mt;
 
 	BUG_ON(!PageBuddy(page));
 
 	zone = page_zone(page);
 	order = page_order(page);
+	mt = get_pageblock_migratetype(page);
 
-	/* Obey watermarks as if the page was being allocated */
-	watermark = low_wmark_pages(zone) + (1 << order);
-	if (!zone_watermark_ok(zone, 0, watermark, 0, 0))
-		return 0;
+	if (mt != MIGRATE_ISOLATE) {
+		/* Obey watermarks as if the page was being allocated */
+		watermark = low_wmark_pages(zone) + (1 << order);
+		if (!zone_watermark_ok(zone, 0, watermark, 0, 0))
+			return 0;
+
+		__mod_zone_freepage_state(zone, -(1UL << order), mt);
+	}
 
 	/* Remove page from free list */
 	list_del(&page->lru);
 	zone->free_area[order].nr_free--;
 	rmv_page_order(page);
-	__mod_zone_page_state(zone, NR_FREE_PAGES, -(1UL << order));
 
 	/* Split into individual pages */
 	set_page_refcounted(page);
@@ -1371,8 +1559,12 @@ int split_free_page(struct page *page)
 
 	if (order >= pageblock_order - 1) {
 		struct page *endpage = page + (1 << order) - 1;
-		for (; page < endpage; page += pageblock_nr_pages)
-			set_pageblock_migratetype(page, MIGRATE_MOVABLE);
+		for (; page < endpage; page += pageblock_nr_pages) {
+			int mt = get_pageblock_migratetype(page);
+			if (mt != MIGRATE_ISOLATE && !is_migrate_cma(mt))
+				set_pageblock_migratetype(page,
+							  MIGRATE_MOVABLE);
+		}
 	}
 
 	return 1 << order;
@@ -1434,7 +1626,8 @@ again:
 		spin_unlock(&zone->lock);
 		if (!page)
 			goto failed;
-		__mod_zone_page_state(zone, NR_FREE_PAGES, -(1 << order));
+		__mod_zone_freepage_state(zone, -(1 << order),
+					  get_pageblock_migratetype(page));
 	}
 
 	__count_zone_vm_events(PGALLOC, zone, 1 << order);
@@ -1451,19 +1644,6 @@ failed:
 	return NULL;
 }
 
-/* The ALLOC_WMARK bits are used as an index to zone->watermark */
-#define ALLOC_WMARK_MIN		WMARK_MIN
-#define ALLOC_WMARK_LOW		WMARK_LOW
-#define ALLOC_WMARK_HIGH	WMARK_HIGH
-#define ALLOC_NO_WATERMARKS	0x04 /* don't check watermarks at all */
-
-/* Mask to get the watermark bits */
-#define ALLOC_WMARK_MASK	(ALLOC_NO_WATERMARKS-1)
-
-#define ALLOC_HARDER		0x10 /* try to alloc harder */
-#define ALLOC_HIGH		0x20 /* __GFP_HIGH set */
-#define ALLOC_CPUSET		0x40 /* check for correct cpuset */
-
 #ifdef CONFIG_FAIL_PAGE_ALLOC
 
 static struct {
@@ -1550,7 +1730,9 @@ static bool __zone_watermark_ok(struct zone *z, int order, unsigned long mark,
 {
 	/* free_pages my go negative - that's OK */
 	long min = mark;
+	long lowmem_reserve = z->lowmem_reserve[classzone_idx];
 	int o;
+	long free_cma = 0;
 
 	free_pages -= (1 << order) - 1;
 	if (alloc_flags & ALLOC_HIGH)
@@ -1558,14 +1740,20 @@ static bool __zone_watermark_ok(struct zone *z, int order, unsigned long mark,
 	if (alloc_flags & ALLOC_HARDER)
 		min -= min / 4;
 
-	if (free_pages <= min + z->lowmem_reserve[classzone_idx])
+#ifdef CONFIG_CMA
+	/* If allocation can't use CMA areas don't use free CMA pages */
+	if (!(alloc_flags & ALLOC_CMA))
+		free_cma = zone_page_state(z, NR_FREE_CMA_PAGES);
+#endif
+
+	if (free_pages - free_cma <= min + lowmem_reserve)
 		return false;
 	for (o = 0; o < order; o++) {
 		/* At the next order, this order's pages become unavailable */
 		free_pages -= z->free_area[o].nr_free << o;
 
 		/* Require fewer higher order pages to be free */
-		min >>= 1;
+		min >>= min_free_order_shift;
 
 		if (free_pages <= min)
 			return false;
@@ -2086,16 +2274,13 @@ __alloc_pages_direct_compact(gfp_t gfp_mask, unsigned int order,
 }
 #endif /* CONFIG_COMPACTION */
 
-/* The really slow allocator path where we enter direct reclaim */
-static inline struct page *
-__alloc_pages_direct_reclaim(gfp_t gfp_mask, unsigned int order,
-	struct zonelist *zonelist, enum zone_type high_zoneidx,
-	nodemask_t *nodemask, int alloc_flags, struct zone *preferred_zone,
-	int migratetype, unsigned long *did_some_progress)
+/* Perform direct synchronous page reclaim */
+static int
+__perform_reclaim(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist,
+		  nodemask_t *nodemask)
 {
-	struct page *page = NULL;
 	struct reclaim_state reclaim_state;
-	bool drained = false;
+	int progress;
 
 	cond_resched();
 
@@ -2106,7 +2291,7 @@ __alloc_pages_direct_reclaim(gfp_t gfp_mask, unsigned int order,
 	reclaim_state.reclaimed_slab = 0;
 	current->reclaim_state = &reclaim_state;
 
-	*did_some_progress = try_to_free_pages(zonelist, order, gfp_mask, nodemask);
+	progress = try_to_free_pages(zonelist, order, gfp_mask, nodemask);
 
 	current->reclaim_state = NULL;
 	lockdep_clear_current_reclaim_state();
@@ -2114,6 +2299,21 @@ __alloc_pages_direct_reclaim(gfp_t gfp_mask, unsigned int order,
 
 	cond_resched();
 
+	return progress;
+}
+
+/* The really slow allocator path where we enter direct reclaim */
+static inline struct page *
+__alloc_pages_direct_reclaim(gfp_t gfp_mask, unsigned int order,
+	struct zonelist *zonelist, enum zone_type high_zoneidx,
+	nodemask_t *nodemask, int alloc_flags, struct zone *preferred_zone,
+	int migratetype, unsigned long *did_some_progress)
+{
+	struct page *page = NULL;
+	bool drained = false;
+
+	*did_some_progress = __perform_reclaim(gfp_mask, order, zonelist,
+					       nodemask);
 	if (unlikely(!(*did_some_progress)))
 		return NULL;
 
@@ -2214,7 +2414,10 @@ gfp_to_alloc_flags(gfp_t gfp_mask)
 		     unlikely(test_thread_flag(TIF_MEMDIE))))
 			alloc_flags |= ALLOC_NO_WATERMARKS;
 	}
-
+#ifdef CONFIG_CMA
+	if (allocflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)
+		alloc_flags |= ALLOC_CMA;
+#endif
 	return alloc_flags;
 }
 
@@ -2231,6 +2434,10 @@ __alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,
 	unsigned long did_some_progress;
 	bool sync_migration = false;
 	bool deferred_compaction = false;
+#ifdef CONFIG_ANDROID_OOM_KILLER
+	unsigned long oom_invoke_timeout = jiffies + HZ;
+	int oom_invoke_cnt = 0;
+#endif
 
 	/*
 	 * In the slowpath, we sanity check order to avoid ever trying to
@@ -2340,7 +2547,12 @@ rebalance:
 	 * If we failed to make any progress reclaiming, then we are
 	 * running out of options and have to consider going OOM
 	 */
-	if (!did_some_progress) {
+#ifdef CONFIG_ANDROID_OOM_KILLER
+#define SHOULD_CONSIDER_OOM !did_some_progress || time_after(jiffies, oom_invoke_timeout)
+#else
+#define SHOULD_CONSIDER_OOM !did_some_progress
+#endif
+	if (SHOULD_CONSIDER_OOM) {
 		if ((gfp_mask & __GFP_FS) && !(gfp_mask & __GFP_NORETRY)) {
 			if (oom_killer_disabled)
 				goto nopage;
@@ -2348,6 +2560,12 @@ rebalance:
 			if ((current->flags & PF_DUMPCORE) &&
 			    !(gfp_mask & __GFP_NOFAIL))
 				goto nopage;
+#ifdef CONFIG_ANDROID_OOM_KILLER
+			if (did_some_progress)
+				pr_info("time's up : calling "
+						"__alloc_pages_may_oom(%d)\n", oom_invoke_cnt++);
+
+#endif
 			page = __alloc_pages_may_oom(gfp_mask, order,
 					zonelist, high_zoneidx,
 					nodemask, preferred_zone,
@@ -2372,7 +2590,9 @@ rebalance:
 				if (high_zoneidx < ZONE_NORMAL)
 					goto nopage;
 			}
-
+#ifdef CONFIG_ANDROID_OOM_KILLER
+			oom_invoke_timeout = jiffies + HZ/4;
+#endif
 			goto restart;
 		}
 	}
@@ -2421,9 +2641,20 @@ __alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order,
 	enum zone_type high_zoneidx = gfp_zone(gfp_mask);
 	struct zone *preferred_zone;
 	struct page *page = NULL;
-	int migratetype = allocflags_to_migratetype(gfp_mask);
+	int migratetype;
 	unsigned int cpuset_mems_cookie;
+	int alloc_flags = ALLOC_WMARK_LOW|ALLOC_CPUSET;
 
+	/*
+	 * Limit the page allocation of "movable" when cma is enabled, make
+	 * "movable" only valid when it's capable of cma.
+	 */
+#ifdef CONFIG_CMA
+	if (cma_available && !(gfp_mask & __GFP_CMA)) {
+		gfp_mask &= ~(__GFP_MOVABLE);
+	}
+#endif
+	migratetype = allocflags_to_migratetype(gfp_mask);
 	gfp_mask &= gfp_allowed_mask;
 
 	lockdep_trace_alloc(gfp_mask);
@@ -2451,9 +2682,13 @@ retry_cpuset:
 	if (!preferred_zone)
 		goto out;
 
+#ifdef CONFIG_CMA
+	if (allocflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)
+		alloc_flags |= ALLOC_CMA;
+#endif
 	/* First allocation attempt */
 	page = get_page_from_freelist(gfp_mask|__GFP_HARDWALL, nodemask, order,
-			zonelist, high_zoneidx, ALLOC_WMARK_LOW|ALLOC_CPUSET,
+			zonelist, high_zoneidx, alloc_flags,
 			preferred_zone, migratetype);
 	if (unlikely(!page))
 		page = __alloc_pages_slowpath(gfp_mask, order,
@@ -2734,7 +2969,8 @@ void show_free_areas(unsigned int filter)
 		" unevictable:%lu"
 		" dirty:%lu writeback:%lu unstable:%lu\n"
 		" free:%lu slab_reclaimable:%lu slab_unreclaimable:%lu\n"
-		" mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n",
+		" mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n"
+		" free_cma:%lu\n",
 		global_page_state(NR_ACTIVE_ANON),
 		global_page_state(NR_INACTIVE_ANON),
 		global_page_state(NR_ISOLATED_ANON),
@@ -2751,7 +2987,8 @@ void show_free_areas(unsigned int filter)
 		global_page_state(NR_FILE_MAPPED),
 		global_page_state(NR_SHMEM),
 		global_page_state(NR_PAGETABLE),
-		global_page_state(NR_BOUNCE));
+		global_page_state(NR_BOUNCE),
+		global_page_state(NR_FREE_CMA_PAGES));
 
 	for_each_populated_zone(zone) {
 		int i;
@@ -2783,6 +3020,7 @@ void show_free_areas(unsigned int filter)
 			" pagetables:%lukB"
 			" unstable:%lukB"
 			" bounce:%lukB"
+			" free_cma:%lukB"
 			" writeback_tmp:%lukB"
 			" pages_scanned:%lu"
 			" all_unreclaimable? %s"
@@ -2812,9 +3050,10 @@ void show_free_areas(unsigned int filter)
 			K(zone_page_state(zone, NR_PAGETABLE)),
 			K(zone_page_state(zone, NR_UNSTABLE_NFS)),
 			K(zone_page_state(zone, NR_BOUNCE)),
+			K(zone_page_state(zone, NR_FREE_CMA_PAGES)),
 			K(zone_page_state(zone, NR_WRITEBACK_TEMP)),
 			zone->pages_scanned,
-			(zone->all_unreclaimable ? "yes" : "no")
+			(!zone_reclaimable(zone) ? "yes" : "no")
 			);
 		printk("lowmem_reserve[]:");
 		for (i = 0; i < MAX_NR_ZONES; i++)
@@ -2824,6 +3063,7 @@ void show_free_areas(unsigned int filter)
 
 	for_each_populated_zone(zone) {
  		unsigned long nr[MAX_ORDER], flags, order, total = 0;
+		unsigned long fl[MAX_ORDER + 1][MIGRATE_TYPES], mtype;
 
 		if (skip_free_areas_node(filter, zone_to_nid(zone)))
 			continue;
@@ -2835,10 +3075,36 @@ void show_free_areas(unsigned int filter)
 			nr[order] = zone->free_area[order].nr_free;
 			total += nr[order] << order;
 		}
+		for (mtype = 0; mtype < MIGRATE_TYPES; mtype++) {
+			unsigned long sum = 0;
+			for (order = 0; order < MAX_ORDER; ++order) {
+				unsigned long freecount = 0;
+				struct free_area *area;
+				struct list_head *curr;
+				area = &(zone->free_area[order]);
+				list_for_each(curr, &area->free_list[mtype])
+					freecount++;
+				fl[order][mtype] = freecount;
+				sum += freecount << order;
+			}
+			fl[MAX_ORDER][mtype] = sum;
+		}
 		spin_unlock_irqrestore(&zone->lock, flags);
 		for (order = 0; order < MAX_ORDER; order++)
 			printk("%lu*%lukB ", nr[order], K(1UL) << order);
 		printk("= %lukB\n", K(total));
+
+		printk("%-16s ", "Free pages:");
+		for (order = 0; order < MAX_ORDER; ++order)
+			printk("%6lu ", order);
+		printk("\n");
+
+		for (mtype = 0; mtype < MIGRATE_TYPES; mtype++) {
+			printk("%8s: M[%2lu]: ", zone->name, mtype);
+			for (order = 0; order <= MAX_ORDER; ++order)
+				printk("%6lu ", fl[order][mtype]);
+			printk("\n");
+		}
 	}
 
 	printk("%ld total pagecache pages\n", global_page_state(NR_FILE_PAGES));
@@ -2974,7 +3240,7 @@ int numa_zonelist_order_handler(ctl_table *table, int write,
 			user_zonelist_order = oldval;
 		} else if (oldval != user_zonelist_order) {
 			mutex_lock(&zonelists_mutex);
-			build_all_zonelists(NULL);
+			build_all_zonelists(NULL, NULL);
 			mutex_unlock(&zonelists_mutex);
 		}
 	}
@@ -3357,10 +3623,17 @@ static __init_refok int __build_all_zonelists(void *data)
 {
 	int nid;
 	int cpu;
+	pg_data_t *self = data;
 
 #ifdef CONFIG_NUMA
 	memset(node_load, 0, sizeof(node_load));
 #endif
+
+	if (self && !node_online(self->node_id)) {
+		build_zonelists(self);
+		build_zonelist_cache(self);
+	}
+
 	for_each_online_node(nid) {
 		pg_data_t *pgdat = NODE_DATA(nid);
 
@@ -3405,7 +3678,7 @@ static __init_refok int __build_all_zonelists(void *data)
  * Called with zonelists_mutex held always
  * unless system_state == SYSTEM_BOOTING.
  */
-void __ref build_all_zonelists(void *data)
+void __ref build_all_zonelists(pg_data_t *pgdat, struct zone *zone)
 {
 	set_zonelist_order();
 
@@ -3417,10 +3690,10 @@ void __ref build_all_zonelists(void *data)
 		/* we have to stop all cpus to guarantee there is no user
 		   of zonelist */
 #ifdef CONFIG_MEMORY_HOTPLUG
-		if (data)
-			setup_zone_pageset((struct zone *)data);
+		if (zone)
+			setup_zone_pageset(zone);
 #endif
-		stop_machine(__build_all_zonelists, NULL, NULL);
+		stop_machine(__build_all_zonelists, pgdat, NULL);
 		/* cpuset refresh routine should be here */
 	}
 	vm_total_pages = nr_free_pagecache_pages();
@@ -4301,7 +4574,7 @@ static void __paginginit free_area_init_core(struct pglist_data *pgdat,
 	init_waitqueue_head(&pgdat->kswapd_wait);
 	pgdat->kswapd_max_order = 0;
 	pgdat_page_cgroup_init(pgdat);
-	
+
 	for (j = 0; j < MAX_NR_ZONES; j++) {
 		struct zone *zone = pgdat->node_zones + j;
 		unsigned long size, realsize, memmap_pages;
@@ -4976,14 +5249,7 @@ static void setup_per_zone_lowmem_reserve(void)
 	calculate_totalreserve_pages();
 }
 
-/**
- * setup_per_zone_wmarks - called when min_free_kbytes changes
- * or when memory is hot-{added|removed}
- *
- * Ensures that the watermark[min,low,high] values for each zone are set
- * correctly with respect to min_free_kbytes.
- */
-void setup_per_zone_wmarks(void)
+static void __setup_per_zone_wmarks(void)
 {
 	unsigned long pages_min = min_free_kbytes >> (PAGE_SHIFT - 10);
 	unsigned long lowmem_pages = 0;
@@ -5030,6 +5296,7 @@ void setup_per_zone_wmarks(void)
 
 		zone->watermark[WMARK_LOW]  = min_wmark_pages(zone) + (tmp >> 2);
 		zone->watermark[WMARK_HIGH] = min_wmark_pages(zone) + (tmp >> 1);
+
 		setup_zone_migrate_reserve(zone);
 		spin_unlock_irqrestore(&zone->lock, flags);
 	}
@@ -5038,6 +5305,20 @@ void setup_per_zone_wmarks(void)
 	calculate_totalreserve_pages();
 }
 
+/**
+ * setup_per_zone_wmarks - called when min_free_kbytes changes
+ * or when memory is hot-{added|removed}
+ *
+ * Ensures that the watermark[min,low,high] values for each zone are set
+ * correctly with respect to min_free_kbytes.
+ */
+void setup_per_zone_wmarks(void)
+{
+	mutex_lock(&zonelists_mutex);
+	__setup_per_zone_wmarks();
+	mutex_unlock(&zonelists_mutex);
+}
+
 /*
  * The inactive anon list should be small enough that the VM never has to
  * do too much work, but large enough that each inactive page has a chance
@@ -5412,14 +5693,16 @@ static int
 __count_immobile_pages(struct zone *zone, struct page *page, int count)
 {
 	unsigned long pfn, iter, found;
+	int mt;
+
 	/*
 	 * For avoiding noise data, lru_add_drain_all() should be called
 	 * If ZONE_MOVABLE, the zone never contains immobile pages
 	 */
 	if (zone_idx(zone) == ZONE_MOVABLE)
 		return true;
-
-	if (get_pageblock_migratetype(page) == MIGRATE_MOVABLE)
+	mt = get_pageblock_migratetype(page);
+	if (mt == MIGRATE_MOVABLE || is_migrate_cma(mt))
 		return true;
 
 	pfn = page_to_pfn(page);
@@ -5526,8 +5809,13 @@ int set_migratetype_isolate(struct page *page)
 
 out:
 	if (!ret) {
+		unsigned long nr_pages;
+		int migratetype = get_pageblock_migratetype(page);
+
 		set_pageblock_migratetype(page, MIGRATE_ISOLATE);
-		move_freepages_block(zone, page, MIGRATE_ISOLATE);
+		nr_pages = move_freepages_block(zone, page, MIGRATE_ISOLATE);
+
+		__mod_zone_freepage_state(zone, -nr_pages, migratetype);
 	}
 
 	spin_unlock_irqrestore(&zone->lock, flags);
@@ -5536,21 +5824,245 @@ out:
 	return ret;
 }
 
-void unset_migratetype_isolate(struct page *page)
+void unset_migratetype_isolate(struct page *page, unsigned migratetype)
 {
 	struct zone *zone;
-	unsigned long flags;
+	unsigned long flags, nr_pages;
+
 	zone = page_zone(page);
 	spin_lock_irqsave(&zone->lock, flags);
 	if (get_pageblock_migratetype(page) != MIGRATE_ISOLATE)
 		goto out;
-	set_pageblock_migratetype(page, MIGRATE_MOVABLE);
-	move_freepages_block(zone, page, MIGRATE_MOVABLE);
+	nr_pages = move_freepages_block(zone, page, migratetype);
+	__mod_zone_freepage_state(zone, nr_pages, migratetype);
+	set_pageblock_migratetype(page, migratetype);
 out:
 	spin_unlock_irqrestore(&zone->lock, flags);
 }
 
+#ifdef CONFIG_CMA
+
+static unsigned long pfn_max_align_down(unsigned long pfn)
+{
+	return pfn & ~(max_t(unsigned long, MAX_ORDER_NR_PAGES,
+			     pageblock_nr_pages) - 1);
+}
+
+static unsigned long pfn_max_align_up(unsigned long pfn)
+{
+	return ALIGN(pfn, max_t(unsigned long, MAX_ORDER_NR_PAGES,
+				pageblock_nr_pages));
+}
+
+static struct page *
+__alloc_contig_migrate_alloc(struct page *page, unsigned long private,
+			     int **resultp)
+{
+	gfp_t gfp_mask = GFP_USER | __GFP_MOVABLE | __GFP_CMA;
+
+	if (PageHighMem(page))
+		gfp_mask |= __GFP_HIGHMEM;
+
+	return alloc_page(gfp_mask);
+}
+
+/* [start, end) must belong to a single zone. */
+static int __alloc_contig_migrate_range(unsigned long start, unsigned long end)
+{
+	/* This function is based on compact_zone() from compaction.c. */
+	unsigned long nr_reclaimed;
+	unsigned long pfn = start;
+	unsigned int tries = 0;
+	int ret = 0;
+
+	struct compact_control cc = {
+		.nr_migratepages = 0,
+		.order = -1,
+		.zone = page_zone(pfn_to_page(start)),
+		.sync = true,
+	};
+	INIT_LIST_HEAD(&cc.migratepages);
+
+	migrate_prep_local();
+
+	while (pfn < end || !list_empty(&cc.migratepages)) {
+		if (fatal_signal_pending(current)) {
+			ret = -EINTR;
+			break;
+		}
+
+		if (list_empty(&cc.migratepages)) {
+			cc.nr_migratepages = 0;
+			pfn = isolate_migratepages_range(cc.zone, &cc,
+							 pfn, end, true);
+			if (!pfn) {
+				ret = -EINTR;
+				break;
+			}
+			tries = 0;
+		} else if (++tries == 5) {
+			ret = ret < 0 ? ret : -EBUSY;
+			break;
+		}
+
+		nr_reclaimed = reclaim_clean_pages_from_list(cc.zone,
+							&cc.migratepages);
+		cc.nr_migratepages -= nr_reclaimed;
+
+		ret = migrate_pages(&cc.migratepages,
+				    __alloc_contig_migrate_alloc,
+				    0, false, MIGRATE_SYNC);
+	}
+	if (ret < 0) {
+		putback_lru_pages(&cc.migratepages);
+		return ret;
+	}
+	return 0;
+}
+
+/**
+ * alloc_contig_range() -- tries to allocate given range of pages
+ * @start:	start PFN to allocate
+ * @end:	one-past-the-last PFN to allocate
+ * @migratetype:	migratetype of the underlaying pageblocks (either
+ *			#MIGRATE_MOVABLE or #MIGRATE_CMA).  All pageblocks
+ *			in range must have the same migratetype and it must
+ *			be either of the two.
+ *
+ * The PFN range does not have to be pageblock or MAX_ORDER_NR_PAGES
+ * aligned, however it's the caller's responsibility to guarantee that
+ * we are the only thread that changes migrate type of pageblocks the
+ * pages fall in.
+ *
+ * The PFN range must belong to a single zone.
+ *
+ * Returns zero on success or negative error code.  On success all
+ * pages which PFN is in [start, end) are allocated for the caller and
+ * need to be freed with free_contig_range().
+ */
+int alloc_contig_range(unsigned long start, unsigned long end,
+		       unsigned migratetype)
+{
+	unsigned long outer_start, outer_end;
+	int ret = 0, order;
+
+	/*
+	 * What we do here is we mark all pageblocks in range as
+	 * MIGRATE_ISOLATE.  Because pageblock and max order pages may
+	 * have different sizes, and due to the way page allocator
+	 * work, we align the range to biggest of the two pages so
+	 * that page allocator won't try to merge buddies from
+	 * different pageblocks and change MIGRATE_ISOLATE to some
+	 * other migration type.
+	 *
+	 * Once the pageblocks are marked as MIGRATE_ISOLATE, we
+	 * migrate the pages from an unaligned range (ie. pages that
+	 * we are interested in).  This will put all the pages in
+	 * range back to page allocator as MIGRATE_ISOLATE.
+	 *
+	 * When this is done, we take the pages in range from page
+	 * allocator removing them from the buddy system.  This way
+	 * page allocator will never consider using them.
+	 *
+	 * This lets us mark the pageblocks back as
+	 * MIGRATE_CMA/MIGRATE_MOVABLE so that free pages in the
+	 * aligned range but not in the unaligned, original range are
+	 * put back to page allocator so that buddy can use them.
+	 */
+
+	ret = start_isolate_page_range(pfn_max_align_down(start),
+				       pfn_max_align_up(end), migratetype);
+	if (ret)
+		return ret;
+
+	ret = __alloc_contig_migrate_range(start, end);
+	if (ret)
+		goto done;
+
+	/*
+	 * Pages from [start, end) are within a MAX_ORDER_NR_PAGES
+	 * aligned blocks that are marked as MIGRATE_ISOLATE.  What's
+	 * more, all pages in [start, end) are free in page allocator.
+	 * What we are going to do is to allocate all pages from
+	 * [start, end) (that is remove them from page allocator).
+	 *
+	 * The only problem is that pages at the beginning and at the
+	 * end of interesting range may be not aligned with pages that
+	 * page allocator holds, ie. they can be part of higher order
+	 * pages.  Because of this, we reserve the bigger range and
+	 * once this is done free the pages we are not interested in.
+	 *
+	 * We don't have to hold zone->lock here because the pages are
+	 * isolated thus they won't get removed from buddy.
+	 */
+
+	lru_add_drain_all();
+	drain_all_pages();
+
+	order = 0;
+	outer_start = start;
+	while (!PageBuddy(pfn_to_page(outer_start))) {
+		if (++order >= MAX_ORDER) {
+			ret = -EBUSY;
+			goto done;
+		}
+		outer_start &= ~0UL << order;
+	}
+
+	/* Make sure the range is really isolated. */
+	if (test_pages_isolated(outer_start, end)) {
+		pr_warn("alloc_contig_range test_pages_isolated(%lx, %lx) failed\n",
+		       outer_start, end);
+		ret = -EBUSY;
+		goto done;
+	}
+
+
+	/* Grab isolated pages from freelists. */
+	outer_end = isolate_freepages_range(outer_start, end);
+	if (!outer_end) {
+		ret = -EBUSY;
+		goto done;
+	}
+
+	/* Free head and tail (if any) */
+	if (start != outer_start)
+		free_contig_range(outer_start, start - outer_start);
+	if (end != outer_end)
+		free_contig_range(end, outer_end - end);
+
+done:
+	undo_isolate_page_range(pfn_max_align_down(start),
+				pfn_max_align_up(end), migratetype);
+	return ret;
+}
+
+void free_contig_range(unsigned long pfn, unsigned nr_pages)
+{
+	struct page *page = pfn_to_page(pfn);
+	int count = 0;
+	for (; nr_pages--; page++) {
+		count += page_count(page) != 1;
+		__free_page(page);
+	}
+	WARN(count != 0, "%d pages are still in use!\n", count);
+}
+#endif
+
 #ifdef CONFIG_MEMORY_HOTREMOVE
+void zone_pcp_reset(struct zone *zone)
+{
+	unsigned long flags;
+
+	/* avoid races with drain_pages()  */
+	local_irq_save(flags);
+	if (zone->pageset != &boot_pageset) {
+		free_percpu(zone->pageset);
+		zone->pageset = &boot_pageset;
+	}
+	local_irq_restore(flags);
+}
+
 /*
  * All pages in the range must be isolated before calling this.
  */
diff --git a/mm/page_isolation.c b/mm/page_isolation.c
index 4ae42bb4..d32967cd 100644
--- a/mm/page_isolation.c
+++ b/mm/page_isolation.c
@@ -24,6 +24,7 @@ __first_valid_page(unsigned long pfn, unsigned long nr_pages)
  * to be MIGRATE_ISOLATE.
  * @start_pfn: The lower PFN of the range to be isolated.
  * @end_pfn: The upper PFN of the range to be isolated.
+ * @migratetype: migrate type to set in error recovery.
  *
  * Making page-allocation-type to be MIGRATE_ISOLATE means free pages in
  * the range will never be allocated. Any free pages and pages freed in the
@@ -32,8 +33,8 @@ __first_valid_page(unsigned long pfn, unsigned long nr_pages)
  * start_pfn/end_pfn must be aligned to pageblock_order.
  * Returns 0 on success and -EBUSY if any part of range cannot be isolated.
  */
-int
-start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn)
+int start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,
+			     unsigned migratetype)
 {
 	unsigned long pfn;
 	unsigned long undo_pfn;
@@ -56,7 +57,7 @@ undo:
 	for (pfn = start_pfn;
 	     pfn < undo_pfn;
 	     pfn += pageblock_nr_pages)
-		unset_migratetype_isolate(pfn_to_page(pfn));
+		unset_migratetype_isolate(pfn_to_page(pfn), migratetype);
 
 	return -EBUSY;
 }
@@ -64,8 +65,8 @@ undo:
 /*
  * Make isolated pages available again.
  */
-int
-undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn)
+int undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,
+			    unsigned migratetype)
 {
 	unsigned long pfn;
 	struct page *page;
@@ -77,7 +78,7 @@ undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn)
 		page = __first_valid_page(pfn, pageblock_nr_pages);
 		if (!page || get_pageblock_migratetype(page) != MIGRATE_ISOLATE)
 			continue;
-		unset_migratetype_isolate(page);
+		unset_migratetype_isolate(page, migratetype);
 	}
 	return 0;
 }
@@ -86,7 +87,7 @@ undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn)
  * all pages in [start_pfn...end_pfn) must be in the same zone.
  * zone->lock must be held before call this.
  *
- * Returns 1 if all pages in the range is isolated.
+ * Returns 1 if all pages in the range are isolated.
  */
 static int
 __test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn)
@@ -99,10 +100,24 @@ __test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn)
 			continue;
 		}
 		page = pfn_to_page(pfn);
-		if (PageBuddy(page))
+		if (PageBuddy(page)) {
+			/*
+			 * If race between isolatation and allocation happens,
+			 * some free pages could be in MIGRATE_MOVABLE list
+			 * although pageblock's migratation type of the page
+			 * is MIGRATE_ISOLATE. Catch it and move the page into
+			 * MIGRATE_ISOLATE list.
+			 */
+			if (get_freepage_migratetype(page) != MIGRATE_ISOLATE) {
+				struct page *end_page;
+
+				end_page = page + (1 << page_order(page)) - 1;
+				move_freepages(page_zone(page), page, end_page,
+						MIGRATE_ISOLATE);
+			}
 			pfn += 1 << page_order(page);
-		else if (page_count(page) == 0 &&
-				page_private(page) == MIGRATE_ISOLATE)
+		} else if (page_count(page) == 0 &&
+			get_freepage_migratetype(page) == MIGRATE_ISOLATE)
 			pfn += 1;
 		else
 			break;
diff --git a/mm/rmap.c b/mm/rmap.c
index 5b5ad584..fd8957d6 100644
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@ -24,7 +24,7 @@
  *   mm->mmap_sem
  *     page->flags PG_locked (lock_page)
  *       mapping->i_mmap_mutex
- *         anon_vma->mutex
+ *         anon_vma->rwsem
  *           mm->page_table_lock or pte_lock
  *             zone->lru_lock (in mark_page_accessed, isolate_lru_page)
  *             swap_lock (in swap_duplicate, swap_info_get)
@@ -37,7 +37,7 @@
  *                           in arch-dependent flush_dcache_mmap_lock,
  *                           within bdi.wb->list_lock in __sync_single_inode)
  *
- * anon_vma->mutex,mapping->i_mutex      (memory_failure, collect_procs_anon)
+ * anon_vma->rwsem,mapping->i_mutex      (memory_failure, collect_procs_anon)
  *   ->tasklist_lock
  *     pte map lock
  */
@@ -56,6 +56,7 @@
 #include <linux/mmu_notifier.h>
 #include <linux/migrate.h>
 #include <linux/hugetlb.h>
+#include <linux/backing-dev.h>
 
 #include <asm/tlbflush.h>
 
@@ -86,25 +87,25 @@ static inline void anon_vma_free(struct anon_vma *anon_vma)
 	VM_BUG_ON(atomic_read(&anon_vma->refcount));
 
 	/*
-	 * Synchronize against page_lock_anon_vma() such that
+	 * Synchronize against page_lock_anon_vma_read() such that
 	 * we can safely hold the lock without the anon_vma getting
 	 * freed.
 	 *
 	 * Relies on the full mb implied by the atomic_dec_and_test() from
 	 * put_anon_vma() against the acquire barrier implied by
-	 * mutex_trylock() from page_lock_anon_vma(). This orders:
+	 * down_read_trylock() from page_lock_anon_vma_read(). This orders:
 	 *
-	 * page_lock_anon_vma()		VS	put_anon_vma()
-	 *   mutex_trylock()			  atomic_dec_and_test()
+	 * page_lock_anon_vma_read()	VS	put_anon_vma()
+	 *   down_read_trylock()		  atomic_dec_and_test()
 	 *   LOCK				  MB
-	 *   atomic_read()			  mutex_is_locked()
+	 *   atomic_read()			  rwsem_is_locked()
 	 *
 	 * LOCK should suffice since the actual taking of the lock must
 	 * happen _before_ what follows.
 	 */
-	if (mutex_is_locked(&anon_vma->root->mutex)) {
-		anon_vma_lock(anon_vma);
-		anon_vma_unlock(anon_vma);
+	if (rwsem_is_locked(&anon_vma->root->rwsem)) {
+		anon_vma_lock_write(anon_vma);
+		anon_vma_unlock_write(anon_vma);
 	}
 
 	kmem_cache_free(anon_vma_cachep, anon_vma);
@@ -150,7 +151,7 @@ static void anon_vma_chain_link(struct vm_area_struct *vma,
  * allocate a new one.
  *
  * Anon-vma allocations are very subtle, because we may have
- * optimistically looked up an anon_vma in page_lock_anon_vma()
+ * optimistically looked up an anon_vma in page_lock_anon_vma_read()
  * and that may actually touch the spinlock even in the newly
  * allocated vma (it depends on RCU to make sure that the
  * anon_vma isn't actually destroyed).
@@ -185,7 +186,7 @@ int anon_vma_prepare(struct vm_area_struct *vma)
 			allocated = anon_vma;
 		}
 
-		anon_vma_lock(anon_vma);
+		anon_vma_lock_write(anon_vma);
 		/* page_table_lock to protect against threads */
 		spin_lock(&mm->page_table_lock);
 		if (likely(!vma->anon_vma)) {
@@ -195,7 +196,7 @@ int anon_vma_prepare(struct vm_area_struct *vma)
 			avc = NULL;
 		}
 		spin_unlock(&mm->page_table_lock);
-		anon_vma_unlock(anon_vma);
+		anon_vma_unlock_write(anon_vma);
 
 		if (unlikely(allocated))
 			put_anon_vma(allocated);
@@ -223,9 +224,9 @@ static inline struct anon_vma *lock_anon_vma_root(struct anon_vma *root, struct
 	struct anon_vma *new_root = anon_vma->root;
 	if (new_root != root) {
 		if (WARN_ON_ONCE(root))
-			mutex_unlock(&root->mutex);
+			up_write(&root->rwsem);
 		root = new_root;
-		mutex_lock(&root->mutex);
+		down_write(&root->rwsem);
 	}
 	return root;
 }
@@ -233,7 +234,7 @@ static inline struct anon_vma *lock_anon_vma_root(struct anon_vma *root, struct
 static inline void unlock_anon_vma_root(struct anon_vma *root)
 {
 	if (root)
-		mutex_unlock(&root->mutex);
+		up_write(&root->rwsem);
 }
 
 /*
@@ -268,51 +269,6 @@ int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)
 	return -ENOMEM;
 }
 
-/*
- * Some rmap walk that needs to find all ptes/hugepmds without false
- * negatives (like migrate and split_huge_page) running concurrent
- * with operations that copy or move pagetables (like mremap() and
- * fork()) to be safe. They depend on the anon_vma "same_anon_vma"
- * list to be in a certain order: the dst_vma must be placed after the
- * src_vma in the list. This is always guaranteed by fork() but
- * mremap() needs to call this function to enforce it in case the
- * dst_vma isn't newly allocated and chained with the anon_vma_clone()
- * function but just an extension of a pre-existing vma through
- * vma_merge.
- *
- * NOTE: the same_anon_vma list can still be changed by other
- * processes while mremap runs because mremap doesn't hold the
- * anon_vma mutex to prevent modifications to the list while it
- * runs. All we need to enforce is that the relative order of this
- * process vmas isn't changing (we don't care about other vmas
- * order). Each vma corresponds to an anon_vma_chain structure so
- * there's no risk that other processes calling anon_vma_moveto_tail()
- * and changing the same_anon_vma list under mremap() will screw with
- * the relative order of this process vmas in the list, because we
- * they can't alter the order of any vma that belongs to this
- * process. And there can't be another anon_vma_moveto_tail() running
- * concurrently with mremap() coming from this process because we hold
- * the mmap_sem for the whole mremap(). fork() ordering dependency
- * also shouldn't be affected because fork() only cares that the
- * parent vmas are placed in the list before the child vmas and
- * anon_vma_moveto_tail() won't reorder vmas from either the fork()
- * parent or child.
- */
-void anon_vma_moveto_tail(struct vm_area_struct *dst)
-{
-	struct anon_vma_chain *pavc;
-	struct anon_vma *root = NULL;
-
-	list_for_each_entry_reverse(pavc, &dst->anon_vma_chain, same_vma) {
-		struct anon_vma *anon_vma = pavc->anon_vma;
-		VM_BUG_ON(pavc->vma != dst);
-		root = lock_anon_vma_root(root, anon_vma);
-		list_del(&pavc->same_anon_vma);
-		list_add_tail(&pavc->same_anon_vma, &anon_vma->head);
-	}
-	unlock_anon_vma_root(root);
-}
-
 /*
  * Attach vma to its own anon_vma, as well as to the anon_vmas that
  * the corresponding VMA in the parent process is attached to.
@@ -355,9 +311,9 @@ int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)
 	get_anon_vma(anon_vma->root);
 	/* Mark this anon_vma as the one where our new (COWed) pages go. */
 	vma->anon_vma = anon_vma;
-	anon_vma_lock(anon_vma);
+	anon_vma_lock_write(anon_vma);
 	anon_vma_chain_link(vma, avc, anon_vma);
-	anon_vma_unlock(anon_vma);
+	anon_vma_unlock_write(anon_vma);
 
 	return 0;
 
@@ -398,7 +354,7 @@ void unlink_anon_vmas(struct vm_area_struct *vma)
 	/*
 	 * Iterate the list once more, it now only contains empty and unlinked
 	 * anon_vmas, destroy them. Could not do before due to __put_anon_vma()
-	 * needing to acquire the anon_vma->root->mutex.
+	 * needing to write-acquire the anon_vma->root->rwsem.
 	 */
 	list_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {
 		struct anon_vma *anon_vma = avc->anon_vma;
@@ -414,7 +370,7 @@ static void anon_vma_ctor(void *data)
 {
 	struct anon_vma *anon_vma = data;
 
-	mutex_init(&anon_vma->mutex);
+	init_rwsem(&anon_vma->rwsem);
 	atomic_set(&anon_vma->refcount, 0);
 	INIT_LIST_HEAD(&anon_vma->head);
 }
@@ -491,7 +447,7 @@ out:
  * atomic op -- the trylock. If we fail the trylock, we fall back to getting a
  * reference like with page_get_anon_vma() and then block on the mutex.
  */
-struct anon_vma *page_lock_anon_vma(struct page *page)
+struct anon_vma *page_lock_anon_vma_read(struct page *page)
 {
 	struct anon_vma *anon_vma = NULL;
 	struct anon_vma *root_anon_vma;
@@ -506,14 +462,16 @@ struct anon_vma *page_lock_anon_vma(struct page *page)
 
 	anon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);
 	root_anon_vma = ACCESS_ONCE(anon_vma->root);
-	if (mutex_trylock(&root_anon_vma->mutex)) {
+	if(!root_anon_vma)
+		goto out;
+	if (down_read_trylock(&root_anon_vma->rwsem)) {
 		/*
 		 * If the page is still mapped, then this anon_vma is still
 		 * its anon_vma, and holding the mutex ensures that it will
 		 * not go away, see anon_vma_free().
 		 */
 		if (!page_mapped(page)) {
-			mutex_unlock(&root_anon_vma->mutex);
+			up_read(&root_anon_vma->rwsem);
 			anon_vma = NULL;
 		}
 		goto out;
@@ -533,15 +491,15 @@ struct anon_vma *page_lock_anon_vma(struct page *page)
 
 	/* we pinned the anon_vma, its safe to sleep */
 	rcu_read_unlock();
-	anon_vma_lock(anon_vma);
+	anon_vma_lock_read(anon_vma);
 
 	if (atomic_dec_and_test(&anon_vma->refcount)) {
 		/*
 		 * Oops, we held the last refcount, release the lock
 		 * and bail -- can't simply use put_anon_vma() because
-		 * we'll deadlock on the anon_vma_lock() recursion.
+		 * we'll deadlock on the anon_vma_lock_write() recursion.
 		 */
-		anon_vma_unlock(anon_vma);
+		anon_vma_unlock_read(anon_vma);
 		__put_anon_vma(anon_vma);
 		anon_vma = NULL;
 	}
@@ -553,9 +511,9 @@ out:
 	return anon_vma;
 }
 
-void page_unlock_anon_vma(struct anon_vma *anon_vma)
+void page_unlock_anon_vma_read(struct anon_vma *anon_vma)
 {
-	anon_vma_unlock(anon_vma);
+	anon_vma_unlock_read(anon_vma);
 }
 
 /*
@@ -755,12 +713,6 @@ int page_referenced_one(struct page *page, struct vm_area_struct *vma,
 		pte_unmap_unlock(pte, ptl);
 	}
 
-	/* Pretend the page is referenced if the task has the
-	   swap token and is in the middle of a page fault. */
-	if (mm != current->mm && has_swap_token(mm) &&
-			rwsem_is_locked(&mm->mmap_sem))
-		referenced++;
-
 	(*mapcount)--;
 
 	if (referenced)
@@ -778,7 +730,7 @@ static int page_referenced_anon(struct page *page,
 	struct anon_vma_chain *avc;
 	int referenced = 0;
 
-	anon_vma = page_lock_anon_vma(page);
+	anon_vma = page_lock_anon_vma_read(page);
 	if (!anon_vma)
 		return referenced;
 
@@ -801,7 +753,7 @@ static int page_referenced_anon(struct page *page,
 			break;
 	}
 
-	page_unlock_anon_vma(anon_vma);
+	page_unlock_anon_vma_read(anon_vma);
 	return referenced;
 }
 
@@ -977,11 +929,8 @@ int page_mkclean(struct page *page)
 
 	if (page_mapped(page)) {
 		struct address_space *mapping = page_mapping(page);
-		if (mapping) {
+		if (mapping)
 			ret = page_mkclean_file(mapping, page);
-			if (page_test_and_clear_dirty(page_to_pfn(page), 1))
-				ret = 1;
-		}
 	}
 
 	return ret;
@@ -1167,6 +1116,7 @@ void page_add_file_rmap(struct page *page)
  */
 void page_remove_rmap(struct page *page)
 {
+	struct address_space *mapping = page_mapping(page);
 	bool anon = PageAnon(page);
 	bool locked;
 	unsigned long flags;
@@ -1189,8 +1139,19 @@ void page_remove_rmap(struct page *page)
 	 * this if the page is anon, so about to be freed; but perhaps
 	 * not if it's in swapcache - there might be another pte slot
 	 * containing the swap entry, but page not yet written to swap.
+	 *
+	 * And we can skip it on file pages, so long as the filesystem
+	 * participates in dirty tracking; but need to catch shm and tmpfs
+	 * and ramfs pages which have been modified since creation by read
+	 * fault.
+	 *
+	 * Note that mapping must be decided above, before decrementing
+	 * mapcount (which luckily provides a barrier): once page is unmapped,
+	 * it could be truncated and page->mapping reset to NULL at any moment.
+	 * Note also that we are relying on page_mapping(page) to set mapping
+	 * to &swapper_space when PageSwapCache(page).
 	 */
-	if ((!anon || PageSwapCache(page)) &&
+	if (mapping && !mapping_cap_account_dirty(mapping) &&
 	    page_test_and_clear_dirty(page_to_pfn(page), 1))
 		set_page_dirty(page);
 	/*
@@ -1334,7 +1295,7 @@ out_mlock:
 	/*
 	 * We need mmap_sem locking, Otherwise VM_LOCKED check makes
 	 * unstable result and race. Plus, We can't wait here because
-	 * we now hold anon_vma->mutex or mapping->i_mmap_mutex.
+	 * we now hold anon_vma->rwsem or mapping->i_mmap_mutex.
 	 * if trylock failed, the page remain in evictable lru and later
 	 * vmscan could retry to move the page to unevictable lru if the
 	 * page is actually mlocked.
@@ -1501,7 +1462,7 @@ static int try_to_unmap_anon(struct page *page, enum ttu_flags flags)
 	struct anon_vma_chain *avc;
 	int ret = SWAP_AGAIN;
 
-	anon_vma = page_lock_anon_vma(page);
+	anon_vma = page_lock_anon_vma_read(page);
 	if (!anon_vma)
 		return ret;
 
@@ -1529,7 +1490,7 @@ static int try_to_unmap_anon(struct page *page, enum ttu_flags flags)
 			break;
 	}
 
-	page_unlock_anon_vma(anon_vma);
+	page_unlock_anon_vma_read(anon_vma);
 	return ret;
 }
 
@@ -1726,7 +1687,7 @@ static int rmap_walk_anon(struct page *page, int (*rmap_one)(struct page *,
 	int ret = SWAP_AGAIN;
 
 	/*
-	 * Note: remove_migration_ptes() cannot use page_lock_anon_vma()
+	 * Note: remove_migration_ptes() cannot use page_lock_anon_vma_read()
 	 * because that depends on page_mapped(); but not all its usages
 	 * are holding mmap_sem. Users without mmap_sem are required to
 	 * take a reference count to prevent the anon_vma disappearing
@@ -1734,7 +1695,7 @@ static int rmap_walk_anon(struct page *page, int (*rmap_one)(struct page *,
 	anon_vma = page_anon_vma(page);
 	if (!anon_vma)
 		return ret;
-	anon_vma_lock(anon_vma);
+	anon_vma_lock_read(anon_vma);
 	list_for_each_entry(avc, &anon_vma->head, same_anon_vma) {
 		struct vm_area_struct *vma = avc->vma;
 		unsigned long address = vma_address(page, vma);
@@ -1744,7 +1705,7 @@ static int rmap_walk_anon(struct page *page, int (*rmap_one)(struct page *,
 		if (ret != SWAP_AGAIN)
 			break;
 	}
-	anon_vma_unlock(anon_vma);
+	anon_vma_unlock_read(anon_vma);
 	return ret;
 }
 
diff --git a/mm/shmem.c b/mm/shmem.c
index 9d65a02a..deb9d406 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -713,8 +713,17 @@ static int shmem_writepage(struct page *page, struct writeback_control *wbc)
 	info = SHMEM_I(inode);
 	if (info->flags & VM_LOCKED)
 		goto redirty;
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+	/*
+	 * Modification for compcache
+	 * shmem_writepage can be reason of kernel panic when using swap.
+	 * This modification prevent using swap by shmem.
+	 */
+	goto redirty;
+#else
 	if (!total_swap_pages)
 		goto redirty;
+#endif
 
 	/*
 	 * shmem_backing_dev_info's capabilities prevent regular writeback or
@@ -2607,6 +2616,15 @@ put_memory:
 }
 EXPORT_SYMBOL_GPL(shmem_file_setup);
 
+void shmem_set_file(struct vm_area_struct *vma, struct file *file)
+{
+	if (vma->vm_file)
+		fput(vma->vm_file);
+	vma->vm_file = file;
+	vma->vm_ops = &shmem_vm_ops;
+	vma->vm_flags |= VM_CAN_NONLINEAR;
+}
+
 /**
  * shmem_zero_setup - setup a shared anonymous mapping
  * @vma: the vma to be mmapped is prepared by do_mmap_pgoff
@@ -2620,11 +2638,7 @@ int shmem_zero_setup(struct vm_area_struct *vma)
 	if (IS_ERR(file))
 		return PTR_ERR(file);
 
-	if (vma->vm_file)
-		fput(vma->vm_file);
-	vma->vm_file = file;
-	vma->vm_ops = &shmem_vm_ops;
-	vma->vm_flags |= VM_CAN_NONLINEAR;
+	shmem_set_file(vma, file);
 	return 0;
 }
 
diff --git a/mm/slub.c b/mm/slub.c
index 71de9b56..c8eecc59 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -1879,21 +1879,32 @@ redo:
 	}
 }
 
-/* Unfreeze all the cpu partial slabs */
+/*
+ * Unfreeze all the cpu partial slabs.
+ *
+ * This function must be called with interrupt disabled.
+ */
 static void unfreeze_partials(struct kmem_cache *s)
 {
-	struct kmem_cache_node *n = NULL;
+	
+	struct kmem_cache_node *n = NULL, *n2 = NULL;	
 	struct kmem_cache_cpu *c = this_cpu_ptr(s->cpu_slab);
 	struct page *page, *discard_page = NULL;
 
 	while ((page = c->partial)) {
-		enum slab_modes { M_PARTIAL, M_FREE };
-		enum slab_modes l, m;
 		struct page new;
 		struct page old;
 
 		c->partial = page->next;
-		l = M_FREE;
+
+		n2 = get_node(s, page_to_nid(page));
+		if (n != n2) {
+			if (n)
+				spin_unlock(&n->list_lock);
+
+			n = n2;
+			spin_lock(&n->list_lock);
+		}
 
 		do {
 
@@ -1906,43 +1917,17 @@ static void unfreeze_partials(struct kmem_cache *s)
 
 			new.frozen = 0;
 
-			if (!new.inuse && (!n || n->nr_partial > s->min_partial))
-				m = M_FREE;
-			else {
-				struct kmem_cache_node *n2 = get_node(s,
-							page_to_nid(page));
-
-				m = M_PARTIAL;
-				if (n != n2) {
-					if (n)
-						spin_unlock(&n->list_lock);
-
-					n = n2;
-					spin_lock(&n->list_lock);
-				}
-			}
-
-			if (l != m) {
-				if (l == M_PARTIAL) {
-					remove_partial(n, page);
-					stat(s, FREE_REMOVE_PARTIAL);
-				} else {
-					add_partial(n, page,
-						DEACTIVATE_TO_TAIL);
-					stat(s, FREE_ADD_PARTIAL);
-				}
-
-				l = m;
-			}
-
-		} while (!cmpxchg_double_slab(s, page,
+		} while (!__cmpxchg_double_slab(s, page,
 				old.freelist, old.counters,
 				new.freelist, new.counters,
 				"unfreezing slab"));
 
-		if (m == M_FREE) {
+		if (unlikely(!new.inuse && n->nr_partial > s->min_partial)) {		
 			page->next = discard_page;
 			discard_page = page;
+		} else {
+			add_partial(n, page, DEACTIVATE_TO_TAIL);
+			stat(s, FREE_ADD_PARTIAL);
 		}
 	}
 
@@ -2163,6 +2148,8 @@ static inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,
  * The page is still frozen if the return value is not NULL.
  *
  * If this function returns NULL then the page has been unfrozen.
+ *
+ * This function must be called with interrupt disabled.
  */
 static inline void *get_freelist(struct kmem_cache *s, struct page *page)
 {
@@ -2179,7 +2166,7 @@ static inline void *get_freelist(struct kmem_cache *s, struct page *page)
 		new.inuse = page->objects;
 		new.frozen = freelist != NULL;
 
-	} while (!cmpxchg_double_slab(s, page,
+	} while (!__cmpxchg_double_slab(s, page,	
 		freelist, counters,
 		NULL, new.counters,
 		"get_freelist"));
@@ -3320,7 +3307,7 @@ static inline int size_index_elem(size_t bytes)
 	return (bytes - 1) / 8;
 }
 
-static struct kmem_cache *get_slab(size_t size, gfp_t flags)
+static __always_inline struct kmem_cache *get_slab(size_t size, gfp_t flags)
 {
 	int index;
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 4607cc62..f9a65a28 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -42,6 +42,7 @@
 #include <linux/sysctl.h>
 #include <linux/oom.h>
 #include <linux/prefetch.h>
+#include <linux/debugfs.h>
 
 #include <asm/tlbflush.h>
 #include <asm/div64.h>
@@ -120,6 +121,11 @@ struct mem_cgroup_zone {
 	struct zone *zone;
 };
 
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+atomic_t kswapd_thread_on = ATOMIC_INIT(1);
+extern int get_soft_reclaim_status(void);
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
+
 #define lru_to_page(_head) (list_entry((_head)->prev, struct page, lru))
 
 #ifdef ARCH_HAS_PREFETCH
@@ -201,6 +207,39 @@ static unsigned long zone_nr_lru_pages(struct mem_cgroup_zone *mz,
 	return zone_page_state(mz->zone, NR_LRU_BASE + lru);
 }
 
+struct dentry *debug_file;
+
+static int debug_shrinker_show(struct seq_file *s, void *unused)
+{
+	struct shrinker *shrinker;
+	struct shrink_control sc;
+
+	sc.gfp_mask = -1;
+	sc.nr_to_scan = 0;
+
+	down_read(&shrinker_rwsem);
+	list_for_each_entry(shrinker, &shrinker_list, list) {
+		char name[64];
+		int num_objs;
+
+		num_objs = shrinker->shrink(shrinker, &sc);
+		seq_printf(s, "%pf %d\n", shrinker->shrink, num_objs);
+	}
+	up_read(&shrinker_rwsem);
+	return 0;
+}
+
+static int debug_shrinker_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, debug_shrinker_show, inode->i_private);
+}
+
+static const struct file_operations debug_shrinker_fops = {
+        .open = debug_shrinker_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+        .release = single_release,
+};
 
 /*
  * Add a shrinker callback to be called from the vm
@@ -214,6 +253,15 @@ void register_shrinker(struct shrinker *shrinker)
 }
 EXPORT_SYMBOL(register_shrinker);
 
+static int __init add_shrinker_debug(void)
+{
+	debugfs_create_file("shrinker", 0644, NULL, NULL,
+			    &debug_shrinker_fops);
+	return 0;
+}
+
+late_initcall(add_shrinker_debug);
+
 /*
  * Remove one
  */
@@ -701,13 +749,13 @@ enum page_references {
 };
 
 static enum page_references page_check_references(struct page *page,
-						  struct mem_cgroup_zone *mz,
+						  struct mem_cgroup *mem_cgroup,
 						  struct scan_control *sc)
 {
 	int referenced_ptes, referenced_page;
 	unsigned long vm_flags;
 
-	referenced_ptes = page_referenced(page, 1, mz->mem_cgroup, &vm_flags);
+	referenced_ptes = page_referenced(page, 1, mem_cgroup, &vm_flags);
 	referenced_page = TestClearPageReferenced(page);
 
 	/* Lumpy reclaim - ignore references */
@@ -763,11 +811,13 @@ static enum page_references page_check_references(struct page *page,
  * shrink_page_list() returns the number of reclaimed pages
  */
 static unsigned long shrink_page_list(struct list_head *page_list,
-				      struct mem_cgroup_zone *mz,
+				      struct zone *zone,
 				      struct scan_control *sc,
+				      enum ttu_flags ttu_flags,
 				      int priority,
 				      unsigned long *ret_nr_dirty,
-				      unsigned long *ret_nr_writeback)
+				      unsigned long *ret_nr_writeback,
+				      bool force_reclaim)
 {
 	LIST_HEAD(ret_pages);
 	LIST_HEAD(free_pages);
@@ -780,10 +830,10 @@ static unsigned long shrink_page_list(struct list_head *page_list,
 	cond_resched();
 
 	while (!list_empty(page_list)) {
-		enum page_references references;
 		struct address_space *mapping;
 		struct page *page;
 		int may_enter_fs;
+		enum page_references references = PAGEREF_RECLAIM_CLEAN;
 
 		cond_resched();
 
@@ -794,7 +844,7 @@ static unsigned long shrink_page_list(struct list_head *page_list,
 			goto keep;
 
 		VM_BUG_ON(PageActive(page));
-		VM_BUG_ON(page_zone(page) != mz->zone);
+		VM_BUG_ON(page_zone(page) != zone);
 
 		sc->nr_scanned++;
 
@@ -812,23 +862,47 @@ static unsigned long shrink_page_list(struct list_head *page_list,
 			(PageSwapCache(page) && (sc->gfp_mask & __GFP_IO));
 
 		if (PageWriteback(page)) {
-			nr_writeback++;
 			/*
-			 * Synchronous reclaim cannot queue pages for
-			 * writeback due to the possibility of stack overflow
-			 * but if it encounters a page under writeback, wait
-			 * for the IO to complete.
+			 * memcg doesn't have any dirty pages throttling so we
+			 * could easily OOM just because too many pages are in
+			 * writeback and there is nothing else to reclaim.
+			 *
+			 * Check __GFP_IO, certainly because a loop driver
+			 * thread might enter reclaim, and deadlock if it waits
+			 * on a page for which it is needed to do the write
+			 * (loop masks off __GFP_IO|__GFP_FS for this reason);
+			 * but more thought would probably show more reasons.
+			 *
+			 * Don't require __GFP_FS, since we're not going into
+			 * the FS, just waiting on its writeback completion.
+			 * Worryingly, ext4 gfs2 and xfs allocate pages with
+			 * grab_cache_page_write_begin(,,AOP_FLAG_NOFS), so
+			 * testing may_enter_fs here is liable to OOM on them.
 			 */
-			if ((sc->reclaim_mode & RECLAIM_MODE_SYNC) &&
-			    may_enter_fs)
-				wait_on_page_writeback(page);
-			else {
-				unlock_page(page);
-				goto keep_lumpy;
+			if (global_reclaim(sc) ||
+			    !PageReclaim(page) || !(sc->gfp_mask & __GFP_IO)) {
+				/*
+				 * This is slightly racy - end_page_writeback()
+				 * might have just cleared PageReclaim, then
+				 * setting PageReclaim here end up interpreted
+				 * as PageReadahead - but that does not matter
+				 * enough to care.  What we do want is for this
+				 * page to have PageReclaim set next time memcg
+				 * reclaim reaches the tests above, so it will
+				 * then wait_on_page_writeback() to avoid OOM;
+				 * and it's also appropriate in global reclaim.
+				 */
+				SetPageReclaim(page);
+				nr_writeback++;
+				goto keep_locked;
 			}
+			wait_on_page_writeback(page);
 		}
 
-		references = page_check_references(page, mz, sc);
+		if (!force_reclaim)
+			references = page_check_references(page,
+					sc->target_mem_cgroup, sc);
+
 		switch (references) {
 		case PAGEREF_ACTIVATE:
 			goto activate_locked;
@@ -858,7 +932,7 @@ static unsigned long shrink_page_list(struct list_head *page_list,
 		 * processes. Try to unmap it here.
 		 */
 		if (page_mapped(page) && mapping) {
-			switch (try_to_unmap(page, TTU_UNMAP)) {
+			switch (try_to_unmap(page, ttu_flags)) {
 			case SWAP_FAIL:
 				goto activate_locked;
 			case SWAP_AGAIN:
@@ -1020,7 +1094,7 @@ keep_lumpy:
 	 * will encounter the same problem
 	 */
 	if (nr_dirty && nr_dirty == nr_congested && global_reclaim(sc))
-		zone_set_flag(mz->zone, ZONE_CONGESTED);
+		zone_set_flag(zone, ZONE_CONGESTED);
 
 	free_hot_cold_page_list(&free_pages, 1);
 
@@ -1031,6 +1105,32 @@ keep_lumpy:
 	return nr_reclaimed;
 }
 
+unsigned long reclaim_clean_pages_from_list(struct zone *zone,
+					    struct list_head *page_list)
+{
+	struct scan_control sc = {
+		.gfp_mask = GFP_KERNEL,
+		.may_unmap = 1,
+	};
+	unsigned long ret, dummy1 = 0, dummy2 = 0;
+	struct page *page, *next;
+	LIST_HEAD(clean_pages);
+
+	list_for_each_entry_safe(page, next, page_list, lru) {
+		if (page_is_file_cache(page) && !PageDirty(page)) {
+			ClearPageActive(page);
+			list_move(&page->lru, &clean_pages);
+		}
+	}
+
+	ret = shrink_page_list(&clean_pages, zone, &sc,
+				TTU_UNMAP | TTU_IGNORE_ACCESS,
+				DEF_PRIORITY, &dummy1, &dummy2, true);
+	list_splice(&clean_pages, page_list);
+	__mod_zone_page_state(zone, NR_ISOLATED_FILE, -ret);
+	return ret;
+}
+
 /*
  * Attempt to remove the specified page from its LRU.  Only take this page
  * if it is of the appropriate PageActive status.  Pages which are being
@@ -1064,12 +1164,8 @@ int __isolate_lru_page(struct page *page, isolate_mode_t mode, int file)
 	if (!all_lru_mode && !!page_is_file_cache(page) != file)
 		return ret;
 
-	/*
-	 * When this function is being called for lumpy reclaim, we
-	 * initially look into all LRU pages, active, inactive and
-	 * unevictable; only give shrink_page_list evictable pages.
-	 */
-	if (PageUnevictable(page))
+	/* Compaction should not handle unevictable pages but CMA can do so */
+	if (PageUnevictable(page) && !(mode & ISOLATE_UNEVICTABLE))
 		return ret;
 
 	ret = -EBUSY;
@@ -1339,6 +1435,13 @@ static int too_many_isolated(struct zone *zone, int file,
 {
 	unsigned long inactive, isolated;
 
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+	if(get_soft_reclaim_status() == 1)
+	{
+		return 0;
+	}
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
+
 	if (current_is_kswapd())
 		return 0;
 
@@ -1353,6 +1456,14 @@ static int too_many_isolated(struct zone *zone, int file,
 		isolated = zone_page_state(zone, NR_ISOLATED_ANON);
 	}
 
+	/*
+	 * GFP_NOIO/GFP_NOFS callers are allowed to isolate more pages, so they
+	 * won't get blocked by normal direct-reclaimers, forming a circular
+	 * deadlock.
+	 */
+	if ((sc->gfp_mask & GFP_IOFS) == GFP_IOFS)
+		inactive >>= 3;
+
 	return isolated > inactive;
 }
 
@@ -1553,14 +1664,14 @@ shrink_inactive_list(unsigned long nr_to_scan, struct mem_cgroup_zone *mz,
 
 	update_isolated_counts(mz, &page_list, &nr_anon, &nr_file);
 
-	nr_reclaimed = shrink_page_list(&page_list, mz, sc, priority,
-						&nr_dirty, &nr_writeback);
+	nr_reclaimed = shrink_page_list(&page_list, mz->zone, sc, TTU_UNMAP,
+				priority, &nr_dirty, &nr_writeback, false);
 
 	/* Check if we should syncronously wait for writeback */
 	if (should_reclaim_stall(nr_taken, nr_reclaimed, priority, sc)) {
 		set_reclaim_mode(priority, sc, true);
-		nr_reclaimed += shrink_page_list(&page_list, mz, sc,
-					priority, &nr_dirty, &nr_writeback);
+		nr_reclaimed += shrink_page_list(&page_list, mz->zone, sc,
+			TTU_UNMAP, priority, &nr_dirty, &nr_writeback, false);
 	}
 
 	spin_lock_irq(&zone->lru_lock);
@@ -1918,7 +2029,7 @@ static void get_scan_count(struct mem_cgroup_zone *mz, struct scan_control *sc,
 	 * latencies, so it's better to scan a minimum amount there as
 	 * well.
 	 */
-	if (current_is_kswapd() && mz->zone->all_unreclaimable)
+	if (current_is_kswapd() && !zone_reclaimable(mz->zone))
 		force_scan = true;
 	if (!global_reclaim(sc))
 		force_scan = true;
@@ -2114,6 +2225,10 @@ restart:
 		 */
 		if (nr_reclaimed >= nr_to_reclaim && priority < DEF_PRIORITY)
 			break;
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+		if ((sc->nr_reclaimed + nr_reclaimed) >= nr_to_reclaim && sc->may_swap)
+			break;
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
 	}
 	blk_finish_plug(&plug);
 	sc->nr_reclaimed += nr_reclaimed;
@@ -2231,7 +2346,11 @@ static bool shrink_zones(int priority, struct zonelist *zonelist,
 {
 	struct zoneref *z;
 	struct zone *zone;
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+	unsigned long nr_soft_reclaimed = 0;
+#else
 	unsigned long nr_soft_reclaimed;
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
 	unsigned long nr_soft_scanned;
 	bool aborted_reclaim = false;
 
@@ -2254,7 +2373,9 @@ static bool shrink_zones(int priority, struct zonelist *zonelist,
 		if (global_reclaim(sc)) {
 			if (!cpuset_zone_allowed_hardwall(zone, GFP_KERNEL))
 				continue;
-			if (zone->all_unreclaimable && priority != DEF_PRIORITY)
+			if (priority != DEF_PRIORITY &&
+				!zone_reclaimable(zone))
+
 				continue;	/* Let kswapd poll it */
 			if (COMPACTION_BUILD) {
 				/*
@@ -2278,9 +2399,11 @@ static bool shrink_zones(int priority, struct zonelist *zonelist,
 			 * and balancing, not for a memcg's limit.
 			 */
 			nr_soft_scanned = 0;
+#ifndef CONFIG_ZRAM_FOR_ANDROID
 			nr_soft_reclaimed = mem_cgroup_soft_limit_reclaim(zone,
 						sc->order, sc->gfp_mask,
 						&nr_soft_scanned);
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
 			sc->nr_reclaimed += nr_soft_reclaimed;
 			sc->nr_scanned += nr_soft_scanned;
 			/* need some check for avoid more shrink_zone() */
@@ -2292,7 +2415,7 @@ static bool shrink_zones(int priority, struct zonelist *zonelist,
 	return aborted_reclaim;
 }
 
-static bool zone_reclaimable(struct zone *zone)
+bool zone_reclaimable(struct zone *zone)
 {
 	return zone->pages_scanned < zone_reclaimable_pages(zone) * 6;
 }
@@ -2310,7 +2433,7 @@ static bool all_unreclaimable(struct zonelist *zonelist,
 			continue;
 		if (!cpuset_zone_allowed_hardwall(zone, GFP_KERNEL))
 			continue;
-		if (!zone->all_unreclaimable)
+		if (zone_reclaimable(zone))
 			return false;
 	}
 
@@ -2440,7 +2563,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		.may_writepage = !laptop_mode,
 		.nr_to_reclaim = SWAP_CLUSTER_MAX,
 		.may_unmap = 1,
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+		.may_swap = 0,
+#else
 		.may_swap = 1,
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
 		.order = order,
 		.target_mem_cgroup = NULL,
 		.nodemask = nodemask,
@@ -2623,7 +2750,7 @@ static bool sleeping_prematurely(pg_data_t *pgdat, int order, long remaining,
 		 * they must be considered balanced here as well if kswapd
 		 * is to sleep
 		 */
-		if (zone->all_unreclaimable) {
+		if (!zone_reclaimable(zone)) {
 			balanced += zone->present_pages;
 			continue;
 		}
@@ -2677,12 +2804,20 @@ static unsigned long balance_pgdat(pg_data_t *pgdat, int order,
 	int end_zone = 0;	/* Inclusive.  0 = ZONE_DMA */
 	unsigned long total_scanned;
 	struct reclaim_state *reclaim_state = current->reclaim_state;
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+	unsigned long nr_soft_reclaimed = 0;
+#else
 	unsigned long nr_soft_reclaimed;
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
 	unsigned long nr_soft_scanned;
 	struct scan_control sc = {
 		.gfp_mask = GFP_KERNEL,
 		.may_unmap = 1,
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+		.may_swap = 0,
+#else
 		.may_swap = 1,
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
 		/*
 		 * kswapd doesn't want to be bailed out while reclaim. because
 		 * we want to put equal scanning pressure on each zone.
@@ -2721,7 +2856,8 @@ loop_again:
 			if (!populated_zone(zone))
 				continue;
 
-			if (zone->all_unreclaimable && priority != DEF_PRIORITY)
+			if (priority != DEF_PRIORITY &&
+			    !zone_reclaimable(zone))
 				continue;
 
 			/*
@@ -2770,13 +2906,14 @@ loop_again:
 		 */
 		for (i = 0; i <= end_zone; i++) {
 			struct zone *zone = pgdat->node_zones + i;
-			int nr_slab, testorder;
+			int testorder;
 			unsigned long balance_gap;
 
 			if (!populated_zone(zone))
 				continue;
 
-			if (zone->all_unreclaimable && priority != DEF_PRIORITY)
+			if (priority != DEF_PRIORITY &&
+			    !zone_reclaimable(zone))
 				continue;
 
 			sc.nr_scanned = 0;
@@ -2785,9 +2922,11 @@ loop_again:
 			/*
 			 * Call soft limit reclaim before calling shrink_zone.
 			 */
+#ifndef CONFIG_ZRAM_FOR_ANDROID
 			nr_soft_reclaimed = mem_cgroup_soft_limit_reclaim(zone,
 							order, sc.gfp_mask,
 							&nr_soft_scanned);
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
 			sc.nr_reclaimed += nr_soft_reclaimed;
 			total_scanned += nr_soft_scanned;
 
@@ -2823,12 +2962,9 @@ loop_again:
 				shrink_zone(priority, zone, &sc);
 
 				reclaim_state->reclaimed_slab = 0;
-				nr_slab = shrink_slab(&shrink, sc.nr_scanned, lru_pages);
+				shrink_slab(&shrink, sc.nr_scanned, lru_pages);
 				sc.nr_reclaimed += reclaim_state->reclaimed_slab;
 				total_scanned += sc.nr_scanned;
-
-				if (nr_slab == 0 && !zone_reclaimable(zone))
-					zone->all_unreclaimable = 1;
 			}
 
 			/*
@@ -2840,7 +2976,7 @@ loop_again:
 			    total_scanned > sc.nr_reclaimed + sc.nr_reclaimed / 2)
 				sc.may_writepage = 1;
 
-			if (zone->all_unreclaimable) {
+			if (!zone_reclaimable(zone)) {
 				if (end_zone && end_zone == i)
 					end_zone--;
 				continue;
@@ -2942,7 +3078,7 @@ out:
 			if (!populated_zone(zone))
 				continue;
 
-			if (zone->all_unreclaimable && priority != DEF_PRIORITY)
+			if (priority != DEF_PRIORITY && !zone_reclaimable(zone))
 				continue;
 
 			/* Would compaction fail due to lack of free memory? */
@@ -3012,8 +3148,16 @@ static void kswapd_try_to_sleep(pg_data_t *pgdat, int order, int classzone_idx)
 		 * per-cpu vmstat threshold while kswapd is awake and restore
 		 * them before going back to sleep.
 		 */
+
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+		atomic_set(&kswapd_thread_on,0);
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
+
 		set_pgdat_percpu_threshold(pgdat, calculate_normal_threshold);
-		schedule();
+
+		if (!kthread_should_stop())
+			schedule();
+
 		set_pgdat_percpu_threshold(pgdat, calculate_pressure_threshold);
 	} else {
 		if (remaining)
@@ -3114,6 +3258,10 @@ static int kswapd(void *p)
 		if (kthread_should_stop())
 			break;
 
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+		atomic_set(&kswapd_thread_on, 1);
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
+
 		/*
 		 * We can speed up thawing tasks if we don't call balance_pgdat
 		 * after returning from the refrigerator
@@ -3125,6 +3273,8 @@ static int kswapd(void *p)
 						&balanced_classzone_idx);
 		}
 	}
+
+	current->reclaim_state = NULL;
 	return 0;
 }
 
@@ -3167,11 +3317,12 @@ unsigned long global_reclaimable_pages(void)
 
 	nr = global_page_state(NR_ACTIVE_FILE) +
 	     global_page_state(NR_INACTIVE_FILE);
-
+//DO NOT care anonymous dirty buffer
+#if 0
 	if (nr_swap_pages > 0)
 		nr += global_page_state(NR_ACTIVE_ANON) +
 		      global_page_state(NR_INACTIVE_ANON);
-
+#endif
 	return nr;
 }
 
@@ -3182,13 +3333,143 @@ unsigned long zone_reclaimable_pages(struct zone *zone)
 	nr = zone_page_state(zone, NR_ACTIVE_FILE) +
 	     zone_page_state(zone, NR_INACTIVE_FILE);
 
+#ifndef CONFIG_ZRAM_FOR_ANDROID
 	if (nr_swap_pages > 0)
 		nr += zone_page_state(zone, NR_ACTIVE_ANON) +
 		      zone_page_state(zone, NR_INACTIVE_ANON);
+#endif
 
 	return nr;
 }
 
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+#ifdef CONFIG_ZRAM_FOR_RTCC2
+/*
+ * This is the main entry point to direct page reclaim for RTCC.
+ *
+ * If a full scan of the inactive list fails to free enough memory then we
+ * are "out of memory" and something needs to be killed.
+ *
+ * If the caller is !__GFP_FS then the probability of a failure is reasonably
+ * high - the zone may be full of dirty or under-writeback pages, which this
+ * caller can't do much about.  We kick the writeback threads and take explicit
+ * naps in the hope that some of these pages can be written.  But if the
+ * allocating task holds filesystem locks which prevent writeout this might not
+ * work, and the allocation attempt will fail.
+ *
+ * returns:	0, if no pages reclaimed
+ * 		else, the number of pages reclaimed
+ */
+static unsigned long rtcc_do_try_to_free_pages(struct zonelist *zonelist, struct scan_control *sc, struct shrink_control *shrink)
+{
+	int priority;
+	unsigned long total_scanned = 0;
+	unsigned long writeback_threshold;
+	bool aborted_reclaim;
+
+	delayacct_freepages_start();
+
+	if (global_reclaim(sc))
+		count_vm_event(ALLOCSTALL);
+
+	for (priority = DEF_PRIORITY; priority >= 0; priority--) {
+		sc->nr_scanned = 0;
+		if (!priority)
+			disable_swap_token(sc->target_mem_cgroup);
+		aborted_reclaim = shrink_zones(priority, zonelist, sc);
+
+		total_scanned += sc->nr_scanned;
+		if (sc->nr_reclaimed >= sc->nr_to_reclaim)
+			goto out;
+
+		/*
+		 * Try to write back as many pages as we just scanned.  This
+		 * tends to cause slow streaming writers to write data to the
+		 * disk smoothly, at the dirtying rate, which is nice.   But
+		 * that's undesirable in laptop mode, where we *want* lumpy
+		 * writeout.  So in laptop mode, write out the whole world.
+		 */
+		writeback_threshold = sc->nr_to_reclaim + sc->nr_to_reclaim / 2;
+		if (total_scanned > writeback_threshold) {
+			wakeup_flusher_threads(laptop_mode ? 0 : total_scanned,
+						WB_REASON_TRY_TO_FREE_PAGES);
+			sc->may_writepage = 1;
+		}
+
+		/* Take a nap, wait for some writeback to complete */
+		if (!sc->hibernation_mode && sc->nr_scanned &&
+		    priority < DEF_PRIORITY - 2) {
+			struct zone *preferred_zone;
+
+			first_zones_zonelist(zonelist, gfp_zone(sc->gfp_mask),
+						&cpuset_current_mems_allowed,
+						&preferred_zone);
+			wait_iff_congested(preferred_zone, BLK_RW_ASYNC, HZ/10);
+		}
+	}
+
+out:
+	delayacct_freepages_end();
+
+	if (sc->nr_reclaimed)
+		return sc->nr_reclaimed;
+
+	/*
+	 * As hibernation is going on, kswapd is freezed so that it can't mark
+	 * the zone into all_unreclaimable. Thus bypassing all_unreclaimable
+	 * check.
+	 */
+	if (oom_killer_disabled)
+		return 0;
+
+	/* Aborted reclaim to try compaction? don't OOM, then */
+	if (aborted_reclaim)
+		return 1;
+
+	/* top priority shrink_zones still had more to do? don't OOM, then */
+	if (global_reclaim(sc) && !all_unreclaimable(zonelist, sc))
+		return 1;
+
+	return 0;
+}
+
+long rtcc_reclaim_pages(long nr_to_reclaim)
+{
+	struct reclaim_state reclaim_state;
+	struct scan_control sc = {
+		.gfp_mask = GFP_HIGHUSER_MOVABLE,
+		.may_swap = 1,
+		.may_unmap = 1,
+		.may_writepage = 1,
+		.nr_to_reclaim = nr_to_reclaim,
+		.target_mem_cgroup = NULL,
+		.order = 0,
+	};
+	struct shrink_control shrink = {
+		.gfp_mask = sc.gfp_mask,
+	};
+	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
+	struct task_struct *p = current;
+	unsigned long nr_reclaimed;
+
+	p->flags |= PF_MEMALLOC;
+	lockdep_set_current_reclaim_state(sc.gfp_mask);
+	reclaim_state.reclaimed_slab = 0;
+	p->reclaim_state = &reclaim_state;
+
+	nr_reclaimed = rtcc_do_try_to_free_pages(zonelist, &sc, &shrink);
+
+	p->reclaim_state = NULL;
+	lockdep_clear_current_reclaim_state();
+	p->flags &= ~PF_MEMALLOC;
+
+	printk("RTCC, reclaim %ld pages\n", nr_reclaimed);
+
+	return nr_reclaimed;
+}
+#endif /* CONFIG_ZRAM_FOR_RTCC2 */
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
+
 #ifdef CONFIG_HIBERNATION
 /*
  * Try to free `nr_to_reclaim' of memory, system-wide, and return the number of
@@ -3273,6 +3554,7 @@ int kswapd_run(int nid)
 		/* failure at boot is fatal */
 		BUG_ON(system_state == SYSTEM_BOOTING);
 		printk("Failed to start kswapd on node %d\n",nid);
+		pgdat->kswapd = NULL;
 		ret = -1;
 	}
 	return ret;
@@ -3393,7 +3675,11 @@ static int __zone_reclaim(struct zone *zone, gfp_t gfp_mask, unsigned int order)
 	struct scan_control sc = {
 		.may_writepage = !!(zone_reclaim_mode & RECLAIM_WRITE),
 		.may_unmap = !!(zone_reclaim_mode & RECLAIM_SWAP),
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+		.may_swap = 0,
+#else
 		.may_swap = 1,
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
 		.nr_to_reclaim = max_t(unsigned long, nr_pages,
 				       SWAP_CLUSTER_MAX),
 		.gfp_mask = gfp_mask,
@@ -3487,7 +3773,7 @@ int zone_reclaim(struct zone *zone, gfp_t gfp_mask, unsigned int order)
 	    zone_page_state(zone, NR_SLAB_RECLAIMABLE) <= zone->min_slab_pages)
 		return ZONE_RECLAIM_FULL;
 
-	if (zone->all_unreclaimable)
+	if (!zone_reclaimable(zone))
 		return ZONE_RECLAIM_FULL;
 
 	/*
diff --git a/mm/vmstat.c b/mm/vmstat.c
index 7db1b9ba..434e910d 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -613,6 +613,9 @@ static char * const migratetype_names[MIGRATE_TYPES] = {
 	"Reclaimable",
 	"Movable",
 	"Reserve",
+#ifdef CONFIG_CMA
+	"CMA",
+#endif
 	"Isolate",
 };
 
@@ -719,6 +722,7 @@ const char * const vmstat_text[] = {
 	"numa_other",
 #endif
 	"nr_anon_transparent_hugepages",
+	"nr_free_cma",
 	"nr_dirty_threshold",
 	"nr_dirty_background_threshold",
 
@@ -820,6 +824,7 @@ static void pagetypeinfo_showfree_print(struct seq_file *m,
 	int order, mtype;
 
 	for (mtype = 0; mtype < MIGRATE_TYPES; mtype++) {
+		unsigned long sum = 0;
 		seq_printf(m, "Node %4d, zone %8s, type %12s ",
 					pgdat->node_id,
 					zone->name,
@@ -834,11 +839,58 @@ static void pagetypeinfo_showfree_print(struct seq_file *m,
 			list_for_each(curr, &area->free_list[mtype])
 				freecount++;
 			seq_printf(m, "%6lu ", freecount);
+			sum += freecount << order;
 		}
+		seq_printf(m, "%6lu ", sum);
 		seq_putc(m, '\n');
 	}
 }
 
+#ifdef CONFIG_CMA
+static void pagetypeinfo_showfree_cma_detail_print(struct seq_file *m,
+					pg_data_t *pgdat, struct zone *zone)
+{
+	struct free_area *area;
+	struct page *page;
+	struct list_head *hd;
+	int order, count;
+	unsigned long pre, now = 0;
+
+	for (order = 0; order < MAX_ORDER; ++order) {
+		count = 0;
+		area = &(zone->free_area[order]);
+		if (list_empty(&area->free_list[MIGRATE_CMA]))
+			continue;
+
+		hd = &(area->free_list[MIGRATE_CMA]);
+
+		seq_printf(m, "[%2d]:", order);
+		list_for_each_entry(page, hd, lru) {
+			if (count && (count % 16 == 0))
+				seq_printf(m, "     ");
+			if (count == 0) {
+				pre = page_to_pfn(page);
+				now = pre;
+				seq_printf(m, "%7lx", now);
+			} else {
+				pre = now;
+				now = page_to_pfn(page);
+
+				if (now > pre)
+					seq_printf(m, "*%6lx", now);
+				else
+					seq_printf(m, "%7lx", now);
+			}
+			count++;
+			if (count % 16 == 0)
+				seq_putc(m, '\n');
+		}
+		if (count % 16)
+			seq_putc(m, '\n');
+	}
+}
+#endif
+
 /* Print out the free pages at each order for each migatetype */
 static int pagetypeinfo_showfree(struct seq_file *m, void *arg)
 {
@@ -852,7 +904,10 @@ static int pagetypeinfo_showfree(struct seq_file *m, void *arg)
 	seq_putc(m, '\n');
 
 	walk_zones_in_node(m, pgdat, pagetypeinfo_showfree_print);
-
+#ifdef CONFIG_CMA
+	seq_printf(m, "\nList of free pages of cma at order\n");
+	walk_zones_in_node(m, pgdat, pagetypeinfo_showfree_cma_detail_print);
+#endif
 	return 0;
 }
 
@@ -1019,7 +1074,7 @@ static void zoneinfo_show_print(struct seq_file *m, pg_data_t *pgdat,
 		   "\n  all_unreclaimable: %u"
 		   "\n  start_pfn:         %lu"
 		   "\n  inactive_ratio:    %u",
-		   zone->all_unreclaimable,
+		   !zone_reclaimable(zone),
 		   zone->zone_start_pfn,
 		   zone->inactive_ratio);
 	seq_putc(m, '\n');
diff --git a/net/Kconfig b/net/Kconfig
index e07272d0..c8ee300c 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -79,6 +79,20 @@ source "net/netlabel/Kconfig"
 
 endif # if INET
 
+config ANDROID_PARANOID_NETWORK
+	bool "Only allow certain groups to create sockets"
+	default y
+	help
+		none
+
+config NET_ACTIVITY_STATS
+	bool "Network activity statistics tracking"
+	default y
+	help
+	 Network activity statistics are useful for tracking wireless
+	 modem activity on 2G, 3G, 4G wireless networks. Counts number of
+	 transmissions and groups them in specified time buckets.
+
 config NETWORK_SECMARK
 	bool "Security Marking"
 	help
@@ -218,7 +232,7 @@ source "net/batman-adv/Kconfig"
 source "net/openvswitch/Kconfig"
 
 config RPS
-	boolean
+	boolean "RPS"
 	depends on SMP && SYSFS && USE_GENERIC_SMP_HELPERS
 	default y
 
diff --git a/net/Makefile b/net/Makefile
index ad432fa4..6865dab6 100644
--- a/net/Makefile
+++ b/net/Makefile
@@ -70,3 +70,4 @@ obj-$(CONFIG_CEPH_LIB)		+= ceph/
 obj-$(CONFIG_BATMAN_ADV)	+= batman-adv/
 obj-$(CONFIG_NFC)		+= nfc/
 obj-$(CONFIG_OPENVSWITCH)	+= openvswitch/
+obj-$(CONFIG_NET_ACTIVITY_STATS)		+= activity_stats.o
diff --git a/scripts/Makefile b/scripts/Makefile
index 36266665..9bc3cda9 100644
--- a/scripts/Makefile
+++ b/scripts/Makefile
@@ -3,6 +3,7 @@
 # the kernel for the build process.
 # ---------------------------------------------------------------------------
 # kallsyms:      Find all symbols in vmlinux
+# cgitinfo:      Create git info for current branch
 # pnmttologo:    Convert pnm files to logo files
 # conmakehash:   Create chartable
 # conmakehash:	 Create arrays for initializing the kernel console tables
@@ -11,6 +12,7 @@
 HOST_EXTRACFLAGS += -I$(srctree)/tools/include
 
 hostprogs-$(CONFIG_KALLSYMS)     += kallsyms
+hostprogs-$(CONFIG_CGITINFO)     += cgitinfo
 hostprogs-$(CONFIG_LOGO)         += pnmtologo
 hostprogs-$(CONFIG_VT)           += conmakehash
 hostprogs-$(CONFIG_IKCONFIG)     += bin2c
diff --git a/scripts/cgitinfo.c b/scripts/cgitinfo.c
new file mode 100644
index 00000000..12fa5d9b
--- /dev/null
+++ b/scripts/cgitinfo.c
@@ -0,0 +1,159 @@
+/* Generate assembler source containing git information
+ *
+ *  Copyright (C) 2013 Marvell International Ltd.
+ *  All rights reserved.
+ *
+ *  2013-2  Guoqing Li <ligq@marvell.com>
+ *          get top ten commits and current branch info
+ *
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ * Usage: cgitinfo > gitinfo.S
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#define GIT_INFO_NUM 20
+#define GIT_INFO_LEN 100
+#define GIT_CONFIG_INFO_LEN 200
+#define GIT_DIRECTORY ".git"
+#define GIT_BRANCH_FILE ".git/HEAD"
+#define GIT_CONFIG_FILE ".git/config"
+#define GIT_COMMIT_FILE ".git/gitcommit_top10"
+#define HEADER "refs/heads/"
+#define CMD_GET_GITINFO "git log --pretty=%H -10 > .git/gitcommit_top10"
+
+static void create_file(void)
+{
+	char git_info[GIT_INFO_NUM][GIT_INFO_LEN], *p, *q;
+	char head_name[GIT_INFO_LEN], branch_local[GIT_INFO_LEN];
+	char config_info[GIT_CONFIG_INFO_LEN];
+	FILE *fp, *cfg_fp;
+	int i = 0, j, git_info_len[GIT_INFO_NUM], git_info_num = 11;
+
+	/* get git branch info */
+	fp = fopen(GIT_BRANCH_FILE, "r");
+	if (fp) {
+		if (fgets(head_name, GIT_INFO_LEN, fp) == NULL)
+			printf("/* warning: no head found! */\n");
+		fclose(fp);
+	}
+	p = strstr(head_name, HEADER);
+	if (p) {
+		p += sizeof(HEADER) - 1;
+		q = strchr(head_name, '\n');
+		while (p < q)
+			branch_local[i++] = *p++;
+	}
+	printf("/* branch_local:%s */\n", branch_local);
+
+	memset(git_info_len, 0, sizeof(git_info_len));
+	cfg_fp = fopen(GIT_CONFIG_FILE, "r");
+	if (cfg_fp) {
+		while (fgets(config_info, GIT_CONFIG_INFO_LEN, cfg_fp)) {
+			if (strstr(config_info, "branch") &&
+				strstr(config_info, branch_local)) {
+				if (fgets(config_info, GIT_CONFIG_INFO_LEN,
+							cfg_fp) == NULL)
+					printf("/* Warning: no origin config \
+							for the branch:%s */\n",
+							branch_local);
+				if (fgets(config_info, GIT_CONFIG_INFO_LEN,
+							cfg_fp) == NULL)
+					printf("/* Warning: no refs config for \
+							the branch:%s */\n",
+							branch_local);
+				i = 0;
+				p = strstr(config_info, HEADER);
+				if (p) {
+					p += sizeof(HEADER) - 1;
+					q = strchr(config_info, '\n');
+					while (p < q)
+						git_info[0][i++] = *p++;
+				}
+				git_info_len[0] = i;
+				break;
+			}
+		}
+		if (!git_info_len[0])
+			printf("/* warning: no branch found! */\n");
+		fclose(cfg_fp);
+	}
+	printf("/* branch_origin:%s */\n\n", git_info[0]);
+
+	/* get top ten git commits info */
+	fp = fopen(GIT_COMMIT_FILE, "r");
+	if (fp) {
+		for (i = 1; i < 11; i++) {
+			if (fgets(git_info[i], 50, fp) == NULL)
+				printf("/* warning: no commint:%d found */\n",
+						i);
+			p = strchr(git_info[i], '\n');
+			if (p)
+				git_info_len[i] = p - git_info[i];
+			else
+				git_info_len[i] = 0;
+		}
+		fclose(fp);
+	}
+
+	printf("#include <asm/types.h>\n");
+	printf("#if BITS_PER_LONG == 64\n");
+	printf("#define PTR .quad\n");
+	printf("#define ALGN .align 8\n");
+	printf("#else\n");
+	printf("#define PTR .long\n");
+	printf("#define ALGN .align 4\n");
+	printf("#endif\n");
+
+	printf("\t.section .rodata, \"a\"\n");
+
+	printf(".globl git_info_num\n");
+	printf("\tALGN\n");
+	printf("git_info_num:\n");
+	printf("\tPTR\t%d\n", git_info_num);
+	printf("\n");
+	printf(".globl git_info\n");
+	printf("\tALGN\n");
+	printf("git_info:\n");
+	for (i = 0; i < 11; i++) {
+		printf("\t.byte 0x%02x", git_info_len[i]);
+		for (j = 0; j < git_info_len[i]; j++)
+			printf(", 0x%02x", git_info[i][j]);
+		printf("\n");
+	}
+	printf("\n");
+}
+
+static void create_title(void)
+{
+	printf("/*\n");
+	printf(" * kernel/gitinfo.S\n");
+	printf(" * Automatically generated by cgitinfo tool, don't edit\n");
+	printf(" */\n");
+	printf("\n");
+}
+
+int main(void)
+{
+	int ret;
+
+	create_title();
+
+	if (!access(GIT_DIRECTORY, 0)) {
+		ret = system(CMD_GET_GITINFO);
+		if (ret == -1)
+			printf("/* error: git log cmd system call error! */\n");
+	} else
+		printf("/* error: .git not exist! */\n");
+
+	create_file();
+
+	return 0;
+}
diff --git a/scripts/setlocalversion b/scripts/setlocalversion
index bd6dca8a..6ada959e 100755
--- a/scripts/setlocalversion
+++ b/scripts/setlocalversion
@@ -169,7 +169,7 @@ else
 	# LOCALVERSION= is not specified
 	if test "${LOCALVERSION+set}" != "set"; then
 		scm=$(scm_version --short)
-		res="$res${scm:++}"
+		res="$res"
 	fi
 fi
 
diff --git a/security/commoncap.c b/security/commoncap.c
index 71a166a0..0051ac2d 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -31,6 +31,10 @@
 #include <linux/binfmts.h>
 #include <linux/personality.h>
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+#endif
+
 /*
  * If a non-root user executes a setuid-root binary in
  * !secure(SECURE_NOROOT) mode, then we raise capabilities.
@@ -76,6 +80,13 @@ int cap_netlink_send(struct sock *sk, struct sk_buff *skb)
 int cap_capable(const struct cred *cred, struct user_namespace *targ_ns,
 		int cap, int audit)
 {
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+	if (cap == CAP_NET_RAW && in_egroup_p(AID_NET_RAW))
+		return 0;
+	if (cap == CAP_NET_ADMIN && in_egroup_p(AID_NET_ADMIN))
+		return 0;
+#endif
+
 	for (;;) {
 		/* The creator of the user namespace has all caps. */
 		if (targ_ns != &init_user_ns && targ_ns->creator == cred->user)
-- 
2.30.2

